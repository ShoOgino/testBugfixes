{"path":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          IndexReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = IndexReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.isOptimized()){\n                    if(indexCommitPoint == null || indexCommitPoint.getVersion() < ic.getVersion()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getVersion());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          IndexReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = IndexReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.isOptimized()){\n                    if(indexCommitPoint == null || indexCommitPoint.getVersion() < ic.getVersion()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getVersion());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          IndexReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = IndexReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.isOptimized()){\n                    if(indexCommitPoint == null || indexCommitPoint.getVersion() < ic.getVersion()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getVersion());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          IndexReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = IndexReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.isOptimized()){\n                    if(indexCommitPoint == null || indexCommitPoint.getVersion() < ic.getVersion()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getVersion());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          IndexReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = IndexReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.isOptimized()){\n                    if(indexCommitPoint == null || indexCommitPoint.getVersion() < ic.getVersion()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getVersion());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          IndexReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = IndexReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.isOptimized()){\n                    if(indexCommitPoint == null || indexCommitPoint.getVersion() < ic.getVersion()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getVersion());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d14e8d18c0e3970c20354dbeeb49da11bd587fbd","date":1321041051,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          IndexReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = IndexReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getVersion() < ic.getVersion()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getVersion());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          IndexReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = IndexReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.isOptimized()){\n                    if(indexCommitPoint == null || indexCommitPoint.getVersion() < ic.getVersion()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getVersion());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          IndexReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = IndexReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getVersion() < ic.getVersion()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getVersion());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          IndexReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = IndexReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getVersion() < ic.getVersion()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getVersion());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          IndexReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = IndexReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getVersion() < ic.getVersion()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getVersion());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          IndexReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = IndexReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getVersion() < ic.getVersion()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getVersion());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          IndexReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = IndexReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getVersion() < ic.getVersion()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getVersion());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          IndexReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = IndexReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getVersion() < ic.getVersion()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getVersion());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c01638f4dd94981c1d3d52c4f7991246a5a24aba","date":1327876712,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          IndexReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = IndexReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          IndexReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = IndexReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getVersion() < ic.getVersion()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getVersion());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":["b5b99d924e3bae842d6e1e1af92474d9247784a5"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"817882884229bace7dc5d1b75f6b0e4aa1e47122","date":1327879145,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          IndexReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = IndexReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          IndexReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = IndexReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getVersion() < ic.getVersion()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getVersion());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"96d207426bd26fa5c1014e26d21d87603aea68b7","date":1327944562,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          IndexReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = IndexReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b6fdfce35d0adb18836cf8711abe487a934df33","date":1327946200,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          IndexReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = IndexReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          IndexReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = IndexReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getVersion() < ic.getVersion()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getVersion());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          IndexReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = IndexReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4448c35ccdaef2a8501f93c0dfe9fe79b19402cc","date":1330444231,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46ce1fa4d07ab971a9376dccf9d66acb2af57be7","date":1338280779,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1381b91b03f7409d8d548c7070dbc615931a0f50","date":1343667369,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter(true);\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter(true);\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter(true);\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9405f486872f1e416304dfe389741f4ee2f8a4d","date":1351276739,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          // TODO: perhaps this is no longer necessary then?\n         // core.getUpdateHandler().newIndexWriter(true);\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter(true);\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f2126b84bd093fa3d921582a109a0ee578c28126","date":1351522501,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          // TODO: perhaps this is no longer necessary then?\n         // core.getUpdateHandler().newIndexWriter(true);\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          core.getUpdateHandler().newIndexWriter(true);\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          // TODO: perhaps this is no longer necessary then?\n         // core.getUpdateHandler().newIndexWriter(true);\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          // TODO: perhaps this is no longer necessary then?\n         // core.getUpdateHandler().newIndexWriter(true);\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          // TODO: perhaps this is no longer necessary then?\n         // core.getUpdateHandler().newIndexWriter(true);\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          // TODO: perhaps this is no longer necessary then?\n         // core.getUpdateHandler().newIndexWriter(true);\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eeb2d6b1dec4189402e35f8d8a39d411e80e140d","date":1359563345,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          // TODO: perhaps this is no longer necessary then?\n         // core.getUpdateHandler().newIndexWriter(true);\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61d5f95d14e5b9b046998c51e16709a398c15226","date":1359603451,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // reboot the writer on the new index\n          // TODO: perhaps this is no longer necessary then?\n         // core.getUpdateHandler().newIndexWriter(true);\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ebce9d932fe980e03fa2b2724381d343e7444b28","date":1384212453,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || enableSlave) {\n      if (core.getCoreDescriptor().getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || enableSlave) {\n      if (core.getCoreDescriptor().getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || enableSlave) {\n      if (core.getCoreDescriptor().getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<Object>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d196318cb8ce39ae32035f290cd1397833e472","date":1418140712,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || enableSlave) {\n      if (core.getCoreDescriptor().getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerFileStreamResponseWriter();\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || enableSlave) {\n      if (core.getCoreDescriptor().getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"20f6b7cff3771384f27af0f059795d7e64aff6b9","date":1425498309,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || enableSlave) {\n      if (core.getCoreDescriptor().getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || enableSlave) {\n      if (core.getCoreDescriptor().getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || enableSlave) {\n      if (core.getCoreDescriptor().getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      tempSnapPuller = snapPuller = new SnapPuller(slave, this, core);\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || enableSlave) {\n      if (core.getCoreDescriptor().getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = SnapPuller.readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b13106276bb5ea342253dbf6aae7b675adb38d3","date":1428054414,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || enableSlave) {\n      if (core.getCoreDescriptor().getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || enableSlave) {\n      if (core.getCoreDescriptor().getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","date":1428091986,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || enableSlave) {\n      if (core.getCoreDescriptor().getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || enableSlave) {\n      if (core.getCoreDescriptor().getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n    \n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n    \n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n      \n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bcf9886c8ff537aafde14de48ebf744f5673f08b","date":1439041198,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || enableSlave) {\n      if (core.getCoreDescriptor().getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || enableSlave) {\n      if (core.getCoreDescriptor().getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readInterval(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"729cb470f975115d4c60517b2cb7c42e37a7a2e1","date":1492041760,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || enableSlave) {\n      if (core.getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || enableSlave) {\n      if (core.getCoreDescriptor().getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || enableSlave) {\n      if (core.getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || enableSlave) {\n      if (core.getCoreDescriptor().getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f0de3f1a1669c9401afac3401c7ffff6e084c929","date":1496794981,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || (enableSlave && !currentIndexFetcher.fetchFromLeader)) {\n      if (core.getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || enableSlave) {\n      if (core.getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f344bb33ca91f48e99c061980115b46fa84fc8f5","date":1496903283,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || (enableSlave && !currentIndexFetcher.fetchFromLeader)) {\n      if (core.getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || enableSlave) {\n      if (core.getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || (enableSlave && !currentIndexFetcher.fetchFromLeader)) {\n      if (core.getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || enableSlave) {\n      if (core.getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || (enableSlave && !currentIndexFetcher.fetchFromLeader)) {\n      if (core.getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || enableSlave) {\n      if (core.getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"644106f979c612c610132c47c920e636bd89cde4","date":1506013326,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Long deprecatedReserveCommitDuration = null;\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || (enableSlave && !currentIndexFetcher.fetchFromLeader)) {\n      if (core.getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n        deprecatedReserveCommitDuration = reserveCommitDuration;\n        // remove this error check & backcompat logic when Version.LUCENE_7_1_0 is removed\n        assertWarnOrFail(\n          \"Beginning with Solr 7.1, master.\"+RESERVE + \" is deprecated and should now be configured directly on the ReplicationHandler.\",\n          (null == reserve),\n          core.getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_7_1_0));\n      }\n      isMaster = true;\n    }\n\n    {\n      final String reserve = (String) initArgs.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n        if (deprecatedReserveCommitDuration != null) {\n          throw new IllegalArgumentException(\"'master.\"+RESERVE+\"' and '\"+RESERVE+\"' are mutually exclusive.\");\n        }\n      }\n    }\n    LOG.info(\"Commits will be reserved for \" + reserveCommitDuration + \"ms.\");\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || (enableSlave && !currentIndexFetcher.fetchFromLeader)) {\n      if (core.getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6240b74b884c5587f2a4062dd27d6c32bf228889","date":1507037235,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Long deprecatedReserveCommitDuration = null;\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || (enableSlave && !currentIndexFetcher.fetchFromLeader)) {\n      if (core.getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n        deprecatedReserveCommitDuration = reserveCommitDuration;\n        // remove this error check & backcompat logic when Version.LUCENE_7_1_0 is removed\n        assertWarnOrFail(\n          \"Beginning with Solr 7.1, master.\"+RESERVE + \" is deprecated and should now be configured directly on the ReplicationHandler.\",\n          (null == reserve),\n          core.getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_7_1_0));\n      }\n      isMaster = true;\n    }\n\n    {\n      final String reserve = (String) initArgs.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n        if (deprecatedReserveCommitDuration != null) {\n          throw new IllegalArgumentException(\"'master.\"+RESERVE+\"' and '\"+RESERVE+\"' are mutually exclusive.\");\n        }\n      }\n    }\n    LOG.info(\"Commits will be reserved for \" + reserveCommitDuration + \"ms.\");\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || (enableSlave && !currentIndexFetcher.fetchFromLeader)) {\n      if (core.getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n      }\n      LOG.info(\"Commits will be reserved for  \" + reserveCommitDuration);\n      isMaster = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f15af35d55d70c34451f9df5edeaeff6b31f8cbe","date":1519625627,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"resource\"})\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Long deprecatedReserveCommitDuration = null;\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || (enableSlave && !currentIndexFetcher.fetchFromLeader)) {\n      if (core.getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = (s == null) ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n        deprecatedReserveCommitDuration = reserveCommitDuration;\n        // remove this error check & backcompat logic when Version.LUCENE_7_1_0 is removed\n        assertWarnOrFail(\n          \"Beginning with Solr 7.1, master.\"+RESERVE + \" is deprecated and should now be configured directly on the ReplicationHandler.\",\n          (null == reserve),\n          core.getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_7_1_0));\n      }\n      isMaster = true;\n    }\n\n    {\n      final String reserve = (String) initArgs.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n        if (deprecatedReserveCommitDuration != null) {\n          throw new IllegalArgumentException(\"'master.\"+RESERVE+\"' and '\"+RESERVE+\"' are mutually exclusive.\");\n        }\n      }\n    }\n    LOG.info(\"Commits will be reserved for \" + reserveCommitDuration + \"ms.\");\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Long deprecatedReserveCommitDuration = null;\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || (enableSlave && !currentIndexFetcher.fetchFromLeader)) {\n      if (core.getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = s==null ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n        deprecatedReserveCommitDuration = reserveCommitDuration;\n        // remove this error check & backcompat logic when Version.LUCENE_7_1_0 is removed\n        assertWarnOrFail(\n          \"Beginning with Solr 7.1, master.\"+RESERVE + \" is deprecated and should now be configured directly on the ReplicationHandler.\",\n          (null == reserve),\n          core.getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_7_1_0));\n      }\n      isMaster = true;\n    }\n\n    {\n      final String reserve = (String) initArgs.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n        if (deprecatedReserveCommitDuration != null) {\n          throw new IllegalArgumentException(\"'master.\"+RESERVE+\"' and '\"+RESERVE+\"' are mutually exclusive.\");\n        }\n      }\n    }\n    LOG.info(\"Commits will be reserved for \" + reserveCommitDuration + \"ms.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"resource\"})\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Long deprecatedReserveCommitDuration = null;\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || (enableSlave && !currentIndexFetcher.fetchFromLeader)) {\n      if (core.getCoreContainer().getZkController() != null) {\n        log.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        log.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          log.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = (s == null) ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          log.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n        deprecatedReserveCommitDuration = reserveCommitDuration;\n        // remove this error check & backcompat logic when Version.LUCENE_7_1_0 is removed\n        assertWarnOrFail(\n          \"Beginning with Solr 7.1, master.\"+RESERVE + \" is deprecated and should now be configured directly on the ReplicationHandler.\",\n          (null == reserve),\n          core.getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_7_1_0));\n      }\n      isMaster = true;\n    }\n\n    {\n      final String reserve = (String) initArgs.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n        if (deprecatedReserveCommitDuration != null) {\n          throw new IllegalArgumentException(\"'master.\"+RESERVE+\"' and '\"+RESERVE+\"' are mutually exclusive.\");\n        }\n      }\n    }\n    log.info(\"Commits will be reserved for \" + reserveCommitDuration + \"ms.\");\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"resource\"})\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Long deprecatedReserveCommitDuration = null;\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || (enableSlave && !currentIndexFetcher.fetchFromLeader)) {\n      if (core.getCoreContainer().getZkController() != null) {\n        LOG.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        LOG.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          LOG.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = (s == null) ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          LOG.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n        deprecatedReserveCommitDuration = reserveCommitDuration;\n        // remove this error check & backcompat logic when Version.LUCENE_7_1_0 is removed\n        assertWarnOrFail(\n          \"Beginning with Solr 7.1, master.\"+RESERVE + \" is deprecated and should now be configured directly on the ReplicationHandler.\",\n          (null == reserve),\n          core.getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_7_1_0));\n      }\n      isMaster = true;\n    }\n\n    {\n      final String reserve = (String) initArgs.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n        if (deprecatedReserveCommitDuration != null) {\n          throw new IllegalArgumentException(\"'master.\"+RESERVE+\"' and '\"+RESERVE+\"' are mutually exclusive.\");\n        }\n      }\n    }\n    LOG.info(\"Commits will be reserved for \" + reserveCommitDuration + \"ms.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d722b735bc69d2234e957cb69cf96ad28ea7e1c3","date":1546867201,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"resource\"})\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Long deprecatedReserveCommitDuration = null;\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || (enableSlave && !currentIndexFetcher.fetchFromLeader)) {\n      if (core.getCoreContainer().getZkController() != null) {\n        log.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        log.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          log.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = (s == null) ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          log.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n        deprecatedReserveCommitDuration = reserveCommitDuration;\n      }\n      isMaster = true;\n    }\n\n    {\n      final String reserve = (String) initArgs.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n        if (deprecatedReserveCommitDuration != null) {\n          throw new IllegalArgumentException(\"'master.\"+RESERVE+\"' and '\"+RESERVE+\"' are mutually exclusive.\");\n        }\n      }\n    }\n    log.info(\"Commits will be reserved for \" + reserveCommitDuration + \"ms.\");\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"resource\"})\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Long deprecatedReserveCommitDuration = null;\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || (enableSlave && !currentIndexFetcher.fetchFromLeader)) {\n      if (core.getCoreContainer().getZkController() != null) {\n        log.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        log.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          log.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = (s == null) ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          log.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n        deprecatedReserveCommitDuration = reserveCommitDuration;\n        // remove this error check & backcompat logic when Version.LUCENE_7_1_0 is removed\n        assertWarnOrFail(\n          \"Beginning with Solr 7.1, master.\"+RESERVE + \" is deprecated and should now be configured directly on the ReplicationHandler.\",\n          (null == reserve),\n          core.getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_7_1_0));\n      }\n      isMaster = true;\n    }\n\n    {\n      final String reserve = (String) initArgs.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n        if (deprecatedReserveCommitDuration != null) {\n          throw new IllegalArgumentException(\"'master.\"+RESERVE+\"' and '\"+RESERVE+\"' are mutually exclusive.\");\n        }\n      }\n    }\n    log.info(\"Commits will be reserved for \" + reserveCommitDuration + \"ms.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4","date":1588172214,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"resource\"})\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Long deprecatedReserveCommitDuration = null;\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || (enableSlave && !currentIndexFetcher.fetchFromLeader)) {\n      if (core.getCoreContainer().getZkController() != null) {\n        log.warn(\"SolrCloud is enabled for core {} but so is old-style replication. \"\n                + \"Make sure you intend this behavior, it usually indicates a mis-configuration. \"\n                + \"Master setting is {} and slave setting is {}\"\n        , core.getName(), enableMaster, enableSlave);\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        log.info(\"Replication enabled for following config files: {}\", includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          log.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on {}\", policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = (s == null) ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          log.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n        deprecatedReserveCommitDuration = reserveCommitDuration;\n      }\n      isMaster = true;\n    }\n\n    {\n      final String reserve = (String) initArgs.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n        if (deprecatedReserveCommitDuration != null) {\n          throw new IllegalArgumentException(\"'master.\"+RESERVE+\"' and '\"+RESERVE+\"' are mutually exclusive.\");\n        }\n      }\n    }\n    log.info(\"Commits will be reserved for {} ms\", reserveCommitDuration);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"resource\"})\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Long deprecatedReserveCommitDuration = null;\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || (enableSlave && !currentIndexFetcher.fetchFromLeader)) {\n      if (core.getCoreContainer().getZkController() != null) {\n        log.warn(\"SolrCloud is enabled for core \" + core.getName() + \" but so is old-style replication. Make sure you\" +\n            \" intend this behavior, it usually indicates a mis-configuration. Master setting is \" +\n            Boolean.toString(enableMaster) + \" and slave setting is \" + Boolean.toString(enableSlave));\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        log.info(\"Replication enabled for following config files: \" + includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          log.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on \" + policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = (s == null) ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          log.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n        deprecatedReserveCommitDuration = reserveCommitDuration;\n      }\n      isMaster = true;\n    }\n\n    {\n      final String reserve = (String) initArgs.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n        if (deprecatedReserveCommitDuration != null) {\n          throw new IllegalArgumentException(\"'master.\"+RESERVE+\"' and '\"+RESERVE+\"' are mutually exclusive.\");\n        }\n      }\n    }\n    log.info(\"Commits will be reserved for \" + reserveCommitDuration + \"ms.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2caf6d6e842e1a4e4ae68ec6dfa5139c31a84ec5","date":1591384964,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"resource\"})\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Long deprecatedReserveCommitDuration = null;\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || (enableSlave && !currentIndexFetcher.fetchFromLeader)) {\n      if (core.getCoreContainer().getZkController() != null) {\n        log.warn(\"SolrCloud is enabled for core {} but so is old-style replication. \"\n                + \"Make sure you intend this behavior, it usually indicates a mis-configuration. \"\n                + \"Master setting is {} and slave setting is {}\"\n        , core.getName(), enableMaster, enableSlave);\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        log.info(\"Replication enabled for following config files: {}\", includeConfFiles);\n      }\n      @SuppressWarnings({\"rawtypes\"})\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      @SuppressWarnings({\"rawtypes\"})\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          log.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on {}\", policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = (s == null) ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          log.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n        deprecatedReserveCommitDuration = reserveCommitDuration;\n      }\n      isMaster = true;\n    }\n\n    {\n      final String reserve = (String) initArgs.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n        if (deprecatedReserveCommitDuration != null) {\n          throw new IllegalArgumentException(\"'master.\"+RESERVE+\"' and '\"+RESERVE+\"' are mutually exclusive.\");\n        }\n      }\n    }\n    log.info(\"Commits will be reserved for {} ms\", reserveCommitDuration);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"resource\"})\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Long deprecatedReserveCommitDuration = null;\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || (enableSlave && !currentIndexFetcher.fetchFromLeader)) {\n      if (core.getCoreContainer().getZkController() != null) {\n        log.warn(\"SolrCloud is enabled for core {} but so is old-style replication. \"\n                + \"Make sure you intend this behavior, it usually indicates a mis-configuration. \"\n                + \"Master setting is {} and slave setting is {}\"\n        , core.getName(), enableMaster, enableSlave);\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        log.info(\"Replication enabled for following config files: {}\", includeConfFiles);\n      }\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          log.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on {}\", policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = (s == null) ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          log.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n        deprecatedReserveCommitDuration = reserveCommitDuration;\n      }\n      isMaster = true;\n    }\n\n    {\n      final String reserve = (String) initArgs.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n        if (deprecatedReserveCommitDuration != null) {\n          throw new IllegalArgumentException(\"'master.\"+RESERVE+\"' and '\"+RESERVE+\"' are mutually exclusive.\");\n        }\n      }\n    }\n    log.info(\"Commits will be reserved for {} ms\", reserveCommitDuration);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d488dbff9834ca981b2d6a1b6a646bb369faca02","date":1596014597,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"resource\"})\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || (enableSlave && !currentIndexFetcher.fetchFromLeader)) {\n      if (core.getCoreContainer().getZkController() != null) {\n        log.warn(\"SolrCloud is enabled for core {} but so is old-style replication. \"\n                + \"Make sure you intend this behavior, it usually indicates a mis-configuration. \"\n                + \"Master setting is {} and slave setting is {}\"\n        , core.getName(), enableMaster, enableSlave);\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        log.info(\"Replication enabled for following config files: {}\", includeConfFiles);\n      }\n      @SuppressWarnings({\"rawtypes\"})\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      @SuppressWarnings({\"rawtypes\"})\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          log.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on {}\", policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = (s == null) ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          log.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      isMaster = true;\n    }\n\n    {\n      final String reserve = (String) initArgs.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n      }\n    }\n    log.info(\"Commits will be reserved for {} ms\", reserveCommitDuration);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"resource\"})\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Long deprecatedReserveCommitDuration = null;\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || (enableSlave && !currentIndexFetcher.fetchFromLeader)) {\n      if (core.getCoreContainer().getZkController() != null) {\n        log.warn(\"SolrCloud is enabled for core {} but so is old-style replication. \"\n                + \"Make sure you intend this behavior, it usually indicates a mis-configuration. \"\n                + \"Master setting is {} and slave setting is {}\"\n        , core.getName(), enableMaster, enableSlave);\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        log.info(\"Replication enabled for following config files: {}\", includeConfFiles);\n      }\n      @SuppressWarnings({\"rawtypes\"})\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      @SuppressWarnings({\"rawtypes\"})\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          log.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on {}\", policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = (s == null) ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          log.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      String reserve = (String) master.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n        deprecatedReserveCommitDuration = reserveCommitDuration;\n      }\n      isMaster = true;\n    }\n\n    {\n      final String reserve = (String) initArgs.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n        if (deprecatedReserveCommitDuration != null) {\n          throw new IllegalArgumentException(\"'master.\"+RESERVE+\"' and '\"+RESERVE+\"' are mutually exclusive.\");\n        }\n      }\n    }\n    log.info(\"Commits will be reserved for {} ms\", reserveCommitDuration);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"65a5d87a40f9143cd55be76eb1dde1b32a8dae5e","date":1596664368,"type":3,"author":"Marcus","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#inform(SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"resource\"})\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList follower = getObjectWithBackwardCompatibility(initArgs,  \"follower\",  \"slave\");\n    boolean enableFollower = isEnabled( follower );\n    if (enableFollower) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(follower, this, core);\n      setupPolling((String) follower.get(POLL_INTERVAL));\n      isFollower = true;\n    }\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList leader = getObjectWithBackwardCompatibility(initArgs, \"leader\", \"master\");\n    boolean enableLeader = isEnabled( leader );\n\n    if (enableLeader || (enableFollower && !currentIndexFetcher.fetchFromLeader)) {\n      if (core.getCoreContainer().getZkController() != null) {\n        log.warn(\"SolrCloud is enabled for core {} but so is old-style replication. \"\n                + \"Make sure you intend this behavior, it usually indicates a mis-configuration. \"\n                + \"Leader setting is {} and follower setting is {}\"\n        , core.getName(), enableLeader, enableFollower);\n      }\n    }\n\n    if (!enableFollower && !enableLeader) {\n      enableLeader = true;\n      leader = new NamedList<>();\n    }\n\n    if (enableLeader) {\n      includeConfFiles = (String) leader.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        log.info(\"Replication enabled for following config files: {}\", includeConfFiles);\n      }\n      @SuppressWarnings({\"rawtypes\"})\n      List backup = leader.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      @SuppressWarnings({\"rawtypes\"})\n      List replicateAfter = leader.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          log.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on {}\", policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = (s == null) ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          log.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      isLeader = true;\n    }\n\n    {\n      final String reserve = (String) initArgs.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n      }\n    }\n    log.info(\"Commits will be reserved for {} ms\", reserveCommitDuration);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"resource\"})\n  public void inform(SolrCore core) {\n    this.core = core;\n    registerCloseHook();\n    Object nbtk = initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);\n    if(nbtk!=null) {\n      numberBackupsToKeep = Integer.parseInt(nbtk.toString());\n    } else {\n      numberBackupsToKeep = 0;\n    }\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList slave = (NamedList) initArgs.get(\"slave\");\n    boolean enableSlave = isEnabled( slave );\n    if (enableSlave) {\n      currentIndexFetcher = pollingIndexFetcher = new IndexFetcher(slave, this, core);\n      setupPolling((String) slave.get(POLL_INTERVAL));\n      isSlave = true;\n    }\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList master = (NamedList) initArgs.get(\"master\");\n    boolean enableMaster = isEnabled( master );\n\n    if (enableMaster || (enableSlave && !currentIndexFetcher.fetchFromLeader)) {\n      if (core.getCoreContainer().getZkController() != null) {\n        log.warn(\"SolrCloud is enabled for core {} but so is old-style replication. \"\n                + \"Make sure you intend this behavior, it usually indicates a mis-configuration. \"\n                + \"Master setting is {} and slave setting is {}\"\n        , core.getName(), enableMaster, enableSlave);\n      }\n    }\n\n    if (!enableSlave && !enableMaster) {\n      enableMaster = true;\n      master = new NamedList<>();\n    }\n\n    if (enableMaster) {\n      includeConfFiles = (String) master.get(CONF_FILES);\n      if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {\n        List<String> files = Arrays.asList(includeConfFiles.split(\",\"));\n        for (String file : files) {\n          if (file.trim().length() == 0) continue;\n          String[] strs = file.trim().split(\":\");\n          // if there is an alias add it or it is null\n          confFileNameAlias.add(strs[0], strs.length > 1 ? strs[1] : null);\n        }\n        log.info(\"Replication enabled for following config files: {}\", includeConfFiles);\n      }\n      @SuppressWarnings({\"rawtypes\"})\n      List backup = master.getAll(\"backupAfter\");\n      boolean backupOnCommit = backup.contains(\"commit\");\n      boolean backupOnOptimize = !backupOnCommit && backup.contains(\"optimize\");\n      @SuppressWarnings({\"rawtypes\"})\n      List replicateAfter = master.getAll(REPLICATE_AFTER);\n      replicateOnCommit = replicateAfter.contains(\"commit\");\n      replicateOnOptimize = !replicateOnCommit && replicateAfter.contains(\"optimize\");\n\n      if (!replicateOnCommit && ! replicateOnOptimize) {\n        replicateOnCommit = true;\n      }\n\n      // if we only want to replicate on optimize, we need the deletion policy to\n      // save the last optimized commit point.\n      if (replicateOnOptimize) {\n        IndexDeletionPolicyWrapper wrapper = core.getDeletionPolicy();\n        IndexDeletionPolicy policy = wrapper == null ? null : wrapper.getWrappedDeletionPolicy();\n        if (policy instanceof SolrDeletionPolicy) {\n          SolrDeletionPolicy solrPolicy = (SolrDeletionPolicy)policy;\n          if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {\n            solrPolicy.setMaxOptimizedCommitsToKeep(1);\n          }\n        } else {\n          log.warn(\"Replication can't call setMaxOptimizedCommitsToKeep on {}\", policy);\n        }\n      }\n\n      if (replicateOnOptimize || backupOnOptimize) {\n        core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize, replicateOnOptimize));\n      }\n      if (replicateOnCommit || backupOnCommit) {\n        replicateOnCommit = true;\n        core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit, replicateOnCommit));\n      }\n      if (replicateAfter.contains(\"startup\")) {\n        replicateOnStart = true;\n        RefCounted<SolrIndexSearcher> s = core.getNewestSearcher(false);\n        try {\n          DirectoryReader reader = (s == null) ? null : s.get().getIndexReader();\n          if (reader!=null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {\n            try {\n              if(replicateOnOptimize){\n                Collection<IndexCommit> commits = DirectoryReader.listCommits(reader.directory());\n                for (IndexCommit ic : commits) {\n                  if(ic.getSegmentCount() == 1){\n                    if(indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration()) indexCommitPoint = ic;\n                  }\n                }\n              } else{\n                indexCommitPoint = reader.getIndexCommit();\n              }\n            } finally {\n              // We don't need to save commit points for replication, the SolrDeletionPolicy\n              // always saves the last commit point (and the last optimized commit point, if needed)\n              /***\n              if(indexCommitPoint != null){\n                core.getDeletionPolicy().saveCommitPoint(indexCommitPoint.getGeneration());\n              }\n              ***/\n            }\n          }\n\n          // ensure the writer is init'd so that we have a list of commit points\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          iw.decref();\n\n        } catch (IOException e) {\n          log.warn(\"Unable to get IndexCommit on startup\", e);\n        } finally {\n          if (s!=null) s.decref();\n        }\n      }\n      isMaster = true;\n    }\n\n    {\n      final String reserve = (String) initArgs.get(RESERVE);\n      if (reserve != null && !reserve.trim().equals(\"\")) {\n        reserveCommitDuration = readIntervalMs(reserve);\n      }\n    }\n    log.info(\"Commits will be reserved for {} ms\", reserveCommitDuration);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["5cab9a86bd67202d20b6adc463008c8e982b070a","4448c35ccdaef2a8501f93c0dfe9fe79b19402cc"],"96d207426bd26fa5c1014e26d21d87603aea68b7":["817882884229bace7dc5d1b75f6b0e4aa1e47122"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["1381b91b03f7409d8d548c7070dbc615931a0f50"],"46ce1fa4d07ab971a9376dccf9d66acb2af57be7":["4448c35ccdaef2a8501f93c0dfe9fe79b19402cc"],"4448c35ccdaef2a8501f93c0dfe9fe79b19402cc":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4":["d722b735bc69d2234e957cb69cf96ad28ea7e1c3"],"f2126b84bd093fa3d921582a109a0ee578c28126":["1381b91b03f7409d8d548c7070dbc615931a0f50","d9405f486872f1e416304dfe389741f4ee2f8a4d"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["f15af35d55d70c34451f9df5edeaeff6b31f8cbe"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["d14e8d18c0e3970c20354dbeeb49da11bd587fbd","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"1381b91b03f7409d8d548c7070dbc615931a0f50":["46ce1fa4d07ab971a9376dccf9d66acb2af57be7"],"f344bb33ca91f48e99c061980115b46fa84fc8f5":["729cb470f975115d4c60517b2cb7c42e37a7a2e1","f0de3f1a1669c9401afac3401c7ffff6e084c929"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"61d5f95d14e5b9b046998c51e16709a398c15226":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","eeb2d6b1dec4189402e35f8d8a39d411e80e140d"],"6240b74b884c5587f2a4062dd27d6c32bf228889":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","644106f979c612c610132c47c920e636bd89cde4"],"2caf6d6e842e1a4e4ae68ec6dfa5139c31a84ec5":["fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["46ce1fa4d07ab971a9376dccf9d66acb2af57be7","1381b91b03f7409d8d548c7070dbc615931a0f50"],"d488dbff9834ca981b2d6a1b6a646bb369faca02":["2caf6d6e842e1a4e4ae68ec6dfa5139c31a84ec5"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["7b13106276bb5ea342253dbf6aae7b675adb38d3"],"f0de3f1a1669c9401afac3401c7ffff6e084c929":["729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"7530de27b87b961b51f01bd1299b7004d46e8823":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"7b13106276bb5ea342253dbf6aae7b675adb38d3":["20f6b7cff3771384f27af0f059795d7e64aff6b9"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","f344bb33ca91f48e99c061980115b46fa84fc8f5"],"d722b735bc69d2234e957cb69cf96ad28ea7e1c3":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["d9405f486872f1e416304dfe389741f4ee2f8a4d","7530de27b87b961b51f01bd1299b7004d46e8823"],"c01638f4dd94981c1d3d52c4f7991246a5a24aba":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"ebce9d932fe980e03fa2b2724381d343e7444b28":["eeb2d6b1dec4189402e35f8d8a39d411e80e140d"],"d14e8d18c0e3970c20354dbeeb49da11bd587fbd":["c26f00b574427b55127e869b935845554afde1fa"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["a0d196318cb8ce39ae32035f290cd1397833e472","20f6b7cff3771384f27af0f059795d7e64aff6b9"],"20f6b7cff3771384f27af0f059795d7e64aff6b9":["a0d196318cb8ce39ae32035f290cd1397833e472"],"eeb2d6b1dec4189402e35f8d8a39d411e80e140d":["7530de27b87b961b51f01bd1299b7004d46e8823"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["d14e8d18c0e3970c20354dbeeb49da11bd587fbd","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a0d196318cb8ce39ae32035f290cd1397833e472":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","7b13106276bb5ea342253dbf6aae7b675adb38d3"],"5b6fdfce35d0adb18836cf8711abe487a934df33":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","c01638f4dd94981c1d3d52c4f7991246a5a24aba"],"f15af35d55d70c34451f9df5edeaeff6b31f8cbe":["644106f979c612c610132c47c920e636bd89cde4"],"644106f979c612c610132c47c920e636bd89cde4":["28288370235ed02234a64753cdbf0c6ec096304a"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["ebce9d932fe980e03fa2b2724381d343e7444b28"],"65a5d87a40f9143cd55be76eb1dde1b32a8dae5e":["d488dbff9834ca981b2d6a1b6a646bb369faca02"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["c01638f4dd94981c1d3d52c4f7991246a5a24aba","96d207426bd26fa5c1014e26d21d87603aea68b7"],"28288370235ed02234a64753cdbf0c6ec096304a":["729cb470f975115d4c60517b2cb7c42e37a7a2e1","f344bb33ca91f48e99c061980115b46fa84fc8f5"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"817882884229bace7dc5d1b75f6b0e4aa1e47122":["0d22ac6a4146774c1bc8400160fc0b6150294e92","c01638f4dd94981c1d3d52c4f7991246a5a24aba"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["46ce1fa4d07ab971a9376dccf9d66acb2af57be7","1381b91b03f7409d8d548c7070dbc615931a0f50"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["d14e8d18c0e3970c20354dbeeb49da11bd587fbd"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["65a5d87a40f9143cd55be76eb1dde1b32a8dae5e"]},"commit2Childs":{"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"96d207426bd26fa5c1014e26d21d87603aea68b7":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["f2126b84bd093fa3d921582a109a0ee578c28126","7530de27b87b961b51f01bd1299b7004d46e8823","d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"4448c35ccdaef2a8501f93c0dfe9fe79b19402cc":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","46ce1fa4d07ab971a9376dccf9d66acb2af57be7"],"46ce1fa4d07ab971a9376dccf9d66acb2af57be7":["1381b91b03f7409d8d548c7070dbc615931a0f50","d6f074e73200c07d54f242d3880a8da5a35ff97b","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4":["2caf6d6e842e1a4e4ae68ec6dfa5139c31a84ec5"],"f2126b84bd093fa3d921582a109a0ee578c28126":[],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["d722b735bc69d2234e957cb69cf96ad28ea7e1c3"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["5b6fdfce35d0adb18836cf8711abe487a934df33"],"1381b91b03f7409d8d548c7070dbc615931a0f50":["d9405f486872f1e416304dfe389741f4ee2f8a4d","f2126b84bd093fa3d921582a109a0ee578c28126","d6f074e73200c07d54f242d3880a8da5a35ff97b","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"f344bb33ca91f48e99c061980115b46fa84fc8f5":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","28288370235ed02234a64753cdbf0c6ec096304a"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["f344bb33ca91f48e99c061980115b46fa84fc8f5","f0de3f1a1669c9401afac3401c7ffff6e084c929","28288370235ed02234a64753cdbf0c6ec096304a"],"61d5f95d14e5b9b046998c51e16709a398c15226":[],"6240b74b884c5587f2a4062dd27d6c32bf228889":[],"2caf6d6e842e1a4e4ae68ec6dfa5139c31a84ec5":["d488dbff9834ca981b2d6a1b6a646bb369faca02"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"d488dbff9834ca981b2d6a1b6a646bb369faca02":["65a5d87a40f9143cd55be76eb1dde1b32a8dae5e"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["729cb470f975115d4c60517b2cb7c42e37a7a2e1","54ca69905c5d9d1529286f06ab1d12c68f6c13cb"],"f0de3f1a1669c9401afac3401c7ffff6e084c929":["f344bb33ca91f48e99c061980115b46fa84fc8f5"],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","eeb2d6b1dec4189402e35f8d8a39d411e80e140d"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["6240b74b884c5587f2a4062dd27d6c32bf228889"],"7b13106276bb5ea342253dbf6aae7b675adb38d3":["bcf9886c8ff537aafde14de48ebf744f5673f08b","6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c"],"d722b735bc69d2234e957cb69cf96ad28ea7e1c3":["fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["61d5f95d14e5b9b046998c51e16709a398c15226"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"c01638f4dd94981c1d3d52c4f7991246a5a24aba":["5b6fdfce35d0adb18836cf8711abe487a934df33","5cab9a86bd67202d20b6adc463008c8e982b070a","817882884229bace7dc5d1b75f6b0e4aa1e47122"],"c26f00b574427b55127e869b935845554afde1fa":["d14e8d18c0e3970c20354dbeeb49da11bd587fbd"],"d14e8d18c0e3970c20354dbeeb49da11bd587fbd":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"ebce9d932fe980e03fa2b2724381d343e7444b28":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c"],"eeb2d6b1dec4189402e35f8d8a39d411e80e140d":["61d5f95d14e5b9b046998c51e16709a398c15226","ebce9d932fe980e03fa2b2724381d343e7444b28"],"20f6b7cff3771384f27af0f059795d7e64aff6b9":["7b13106276bb5ea342253dbf6aae7b675adb38d3","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["817882884229bace7dc5d1b75f6b0e4aa1e47122"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"a0d196318cb8ce39ae32035f290cd1397833e472":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","20f6b7cff3771384f27af0f059795d7e64aff6b9"],"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c":[],"5b6fdfce35d0adb18836cf8711abe487a934df33":[],"f15af35d55d70c34451f9df5edeaeff6b31f8cbe":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"644106f979c612c610132c47c920e636bd89cde4":["6240b74b884c5587f2a4062dd27d6c32bf228889","f15af35d55d70c34451f9df5edeaeff6b31f8cbe"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["a0d196318cb8ce39ae32035f290cd1397833e472"],"65a5d87a40f9143cd55be76eb1dde1b32a8dae5e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","4448c35ccdaef2a8501f93c0dfe9fe79b19402cc"],"28288370235ed02234a64753cdbf0c6ec096304a":["644106f979c612c610132c47c920e636bd89cde4"],"817882884229bace7dc5d1b75f6b0e4aa1e47122":["96d207426bd26fa5c1014e26d21d87603aea68b7"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":[],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","c01638f4dd94981c1d3d52c4f7991246a5a24aba","0d22ac6a4146774c1bc8400160fc0b6150294e92"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","f2126b84bd093fa3d921582a109a0ee578c28126","61d5f95d14e5b9b046998c51e16709a398c15226","6240b74b884c5587f2a4062dd27d6c32bf228889","d6f074e73200c07d54f242d3880a8da5a35ff97b","6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","5b6fdfce35d0adb18836cf8711abe487a934df33","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}