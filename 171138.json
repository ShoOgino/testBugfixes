{"path":"lucene/core/src/java/org/apache/lucene/index/PendingSoftDeletes#onNewReader(CodecReader,SegmentCommitInfo).mjava","commits":[{"id":"36d13f271b6649357e07f71f7e46559479f69b5b","date":1523888226,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PendingSoftDeletes#onNewReader(CodecReader,SegmentCommitInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/PendingSoftDeletes#onNewReader(SegmentReader,SegmentCommitInfo).mjava","sourceNew":"  @Override\n  void onNewReader(CodecReader reader, SegmentCommitInfo info) throws IOException {\n    super.onNewReader(reader, info);\n    hardDeletes.onNewReader(reader, info);\n    if (dvGeneration < info.getDocValuesGen()) { // only re-calculate this if we haven't seen this generation\n      final DocIdSetIterator iterator = DocValuesFieldExistsQuery.getDocValuesDocIdSetIterator(field, reader);\n      if (iterator != null) { // nothing is deleted we don't have a soft deletes field in this segment\n        assert info.info.maxDoc() > 0 : \"maxDoc is 0\";\n        pendingDeleteCount += applySoftDeletes(iterator, getMutableBits());\n      }\n      dvGeneration = info.getDocValuesGen();\n    }\n    assert numPendingDeletes() + info.getDelCount() <= info.info.maxDoc() :\n        numPendingDeletes() + \" + \" + info.getDelCount() + \" > \" + info.info.maxDoc();\n  }\n\n","sourceOld":"  @Override\n  void onNewReader(SegmentReader reader, SegmentCommitInfo info) throws IOException {\n    super.onNewReader(reader, info);\n    hardDeletes.onNewReader(reader, info);\n    if (dvGeneration < info.getDocValuesGen()) { // only re-calculate this if we haven't seen this generation\n      final DocIdSetIterator iterator = DocValuesFieldExistsQuery.getDocValuesDocIdSetIterator(field, reader);\n      if (iterator == null) { // nothing is deleted we don't have a soft deletes field in this segment\n        this.pendingDeleteCount = 0;\n      } else {\n        assert info.info.maxDoc() > 0 : \"maxDoc is 0\";\n        pendingDeleteCount += applySoftDeletes(iterator, getMutableBits());\n      }\n      dvGeneration = info.getDocValuesGen();\n    }\n    assert numPendingDeletes() + info.getDelCount() <= info.info.maxDoc() :\n        numPendingDeletes() + \" + \" + info.getDelCount() + \" > \" + info.info.maxDoc();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aef2a94da918b657d107b616a643e1759db43b6a","date":1527706131,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PendingSoftDeletes#onNewReader(CodecReader,SegmentCommitInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/PendingSoftDeletes#onNewReader(CodecReader,SegmentCommitInfo).mjava","sourceNew":"  @Override\n  void onNewReader(CodecReader reader, SegmentCommitInfo info) throws IOException {\n    super.onNewReader(reader, info);\n    hardDeletes.onNewReader(reader, info);\n    if (dvGeneration < info.getDocValuesGen()) { // only re-calculate this if we haven't seen this generation\n      final DocIdSetIterator iterator = DocValuesFieldExistsQuery.getDocValuesDocIdSetIterator(field, reader);\n      if (iterator != null) { // nothing is deleted we don't have a soft deletes field in this segment\n        assert info.info.maxDoc() > 0 : \"maxDoc is 0\";\n        pendingDeleteCount += applySoftDeletes(iterator, getMutableBits());\n        assert pendingDeleteCount >= 0 : \" illegal pending delete count: \" + pendingDeleteCount;\n      }\n      dvGeneration = info.getDocValuesGen();\n    }\n    assert getDelCount() <= info.info.maxDoc() : getDelCount() + \" > \" + info.info.maxDoc();\n  }\n\n","sourceOld":"  @Override\n  void onNewReader(CodecReader reader, SegmentCommitInfo info) throws IOException {\n    super.onNewReader(reader, info);\n    hardDeletes.onNewReader(reader, info);\n    if (dvGeneration < info.getDocValuesGen()) { // only re-calculate this if we haven't seen this generation\n      final DocIdSetIterator iterator = DocValuesFieldExistsQuery.getDocValuesDocIdSetIterator(field, reader);\n      if (iterator != null) { // nothing is deleted we don't have a soft deletes field in this segment\n        assert info.info.maxDoc() > 0 : \"maxDoc is 0\";\n        pendingDeleteCount += applySoftDeletes(iterator, getMutableBits());\n      }\n      dvGeneration = info.getDocValuesGen();\n    }\n    assert numPendingDeletes() + info.getDelCount() <= info.info.maxDoc() :\n        numPendingDeletes() + \" + \" + info.getDelCount() + \" > \" + info.info.maxDoc();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8f2203cb8ae87188877cfbf6ad170c5738a0aad5","date":1528117512,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PendingSoftDeletes#onNewReader(CodecReader,SegmentCommitInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/PendingSoftDeletes#onNewReader(CodecReader,SegmentCommitInfo).mjava","sourceNew":"  @Override\n  void onNewReader(CodecReader reader, SegmentCommitInfo info) throws IOException {\n    super.onNewReader(reader, info);\n    hardDeletes.onNewReader(reader, info);\n    if (dvGeneration < info.getDocValuesGen()) { // only re-calculate this if we haven't seen this generation\n      final DocIdSetIterator iterator = DocValuesFieldExistsQuery.getDocValuesDocIdSetIterator(field, reader);\n      int newDelCount;\n      if (iterator != null) { // nothing is deleted we don't have a soft deletes field in this segment\n        assert info.info.maxDoc() > 0 : \"maxDoc is 0\";\n        newDelCount = applySoftDeletes(iterator, getMutableBits());\n        assert newDelCount >= 0 : \" illegal pending delete count: \" + newDelCount;\n      } else {\n        newDelCount = 0;\n      }\n      assert info.getSoftDelCount() == newDelCount : \"softDeleteCount doesn't match \" + info.getSoftDelCount() + \" != \" + newDelCount;\n      dvGeneration = info.getDocValuesGen();\n    }\n    assert getDelCount() <= info.info.maxDoc() : getDelCount() + \" > \" + info.info.maxDoc();\n  }\n\n","sourceOld":"  @Override\n  void onNewReader(CodecReader reader, SegmentCommitInfo info) throws IOException {\n    super.onNewReader(reader, info);\n    hardDeletes.onNewReader(reader, info);\n    if (dvGeneration < info.getDocValuesGen()) { // only re-calculate this if we haven't seen this generation\n      final DocIdSetIterator iterator = DocValuesFieldExistsQuery.getDocValuesDocIdSetIterator(field, reader);\n      if (iterator != null) { // nothing is deleted we don't have a soft deletes field in this segment\n        assert info.info.maxDoc() > 0 : \"maxDoc is 0\";\n        pendingDeleteCount += applySoftDeletes(iterator, getMutableBits());\n        assert pendingDeleteCount >= 0 : \" illegal pending delete count: \" + pendingDeleteCount;\n      }\n      dvGeneration = info.getDocValuesGen();\n    }\n    assert getDelCount() <= info.info.maxDoc() : getDelCount() + \" > \" + info.info.maxDoc();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PendingSoftDeletes#onNewReader(CodecReader,SegmentCommitInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/PendingSoftDeletes#onNewReader(CodecReader,SegmentCommitInfo).mjava","sourceNew":"  @Override\n  void onNewReader(CodecReader reader, SegmentCommitInfo info) throws IOException {\n    super.onNewReader(reader, info);\n    hardDeletes.onNewReader(reader, info);\n    if (dvGeneration < info.getDocValuesGen()) { // only re-calculate this if we haven't seen this generation\n      final DocIdSetIterator iterator = DocValuesFieldExistsQuery.getDocValuesDocIdSetIterator(field, reader);\n      int newDelCount;\n      if (iterator != null) { // nothing is deleted we don't have a soft deletes field in this segment\n        assert info.info.maxDoc() > 0 : \"maxDoc is 0\";\n        newDelCount = applySoftDeletes(iterator, getMutableBits());\n        assert newDelCount >= 0 : \" illegal pending delete count: \" + newDelCount;\n      } else {\n        newDelCount = 0;\n      }\n      assert info.getSoftDelCount() == newDelCount : \"softDeleteCount doesn't match \" + info.getSoftDelCount() + \" != \" + newDelCount;\n      dvGeneration = info.getDocValuesGen();\n    }\n    assert getDelCount() <= info.info.maxDoc() : getDelCount() + \" > \" + info.info.maxDoc();\n  }\n\n","sourceOld":"  @Override\n  void onNewReader(CodecReader reader, SegmentCommitInfo info) throws IOException {\n    super.onNewReader(reader, info);\n    hardDeletes.onNewReader(reader, info);\n    if (dvGeneration < info.getDocValuesGen()) { // only re-calculate this if we haven't seen this generation\n      final DocIdSetIterator iterator = DocValuesFieldExistsQuery.getDocValuesDocIdSetIterator(field, reader);\n      if (iterator != null) { // nothing is deleted we don't have a soft deletes field in this segment\n        assert info.info.maxDoc() > 0 : \"maxDoc is 0\";\n        pendingDeleteCount += applySoftDeletes(iterator, getMutableBits());\n        assert pendingDeleteCount >= 0 : \" illegal pending delete count: \" + pendingDeleteCount;\n      }\n      dvGeneration = info.getDocValuesGen();\n    }\n    assert getDelCount() <= info.info.maxDoc() : getDelCount() + \" > \" + info.info.maxDoc();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PendingSoftDeletes#onNewReader(CodecReader,SegmentCommitInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/PendingSoftDeletes#onNewReader(CodecReader,SegmentCommitInfo).mjava","sourceNew":"  @Override\n  void onNewReader(CodecReader reader, SegmentCommitInfo info) throws IOException {\n    super.onNewReader(reader, info);\n    hardDeletes.onNewReader(reader, info);\n    if (dvGeneration < info.getDocValuesGen()) { // only re-calculate this if we haven't seen this generation\n      final DocIdSetIterator iterator = DocValuesFieldExistsQuery.getDocValuesDocIdSetIterator(field, reader);\n      int newDelCount;\n      if (iterator != null) { // nothing is deleted we don't have a soft deletes field in this segment\n        assert info.info.maxDoc() > 0 : \"maxDoc is 0\";\n        newDelCount = applySoftDeletes(iterator, getMutableBits());\n        assert newDelCount >= 0 : \" illegal pending delete count: \" + newDelCount;\n      } else {\n        newDelCount = 0;\n      }\n      assert info.getSoftDelCount() == newDelCount : \"softDeleteCount doesn't match \" + info.getSoftDelCount() + \" != \" + newDelCount;\n      dvGeneration = info.getDocValuesGen();\n    }\n    assert getDelCount() <= info.info.maxDoc() : getDelCount() + \" > \" + info.info.maxDoc();\n  }\n\n","sourceOld":"  @Override\n  void onNewReader(CodecReader reader, SegmentCommitInfo info) throws IOException {\n    super.onNewReader(reader, info);\n    hardDeletes.onNewReader(reader, info);\n    if (dvGeneration < info.getDocValuesGen()) { // only re-calculate this if we haven't seen this generation\n      final DocIdSetIterator iterator = DocValuesFieldExistsQuery.getDocValuesDocIdSetIterator(field, reader);\n      if (iterator != null) { // nothing is deleted we don't have a soft deletes field in this segment\n        assert info.info.maxDoc() > 0 : \"maxDoc is 0\";\n        pendingDeleteCount += applySoftDeletes(iterator, getMutableBits());\n        assert pendingDeleteCount >= 0 : \" illegal pending delete count: \" + pendingDeleteCount;\n      }\n      dvGeneration = info.getDocValuesGen();\n    }\n    assert getDelCount() <= info.info.maxDoc() : getDelCount() + \" > \" + info.info.maxDoc();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["aef2a94da918b657d107b616a643e1759db43b6a","8f2203cb8ae87188877cfbf6ad170c5738a0aad5"],"36d13f271b6649357e07f71f7e46559479f69b5b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8f2203cb8ae87188877cfbf6ad170c5738a0aad5":["aef2a94da918b657d107b616a643e1759db43b6a"],"aef2a94da918b657d107b616a643e1759db43b6a":["36d13f271b6649357e07f71f7e46559479f69b5b"],"f592209545c71895260367152601e9200399776d":["aef2a94da918b657d107b616a643e1759db43b6a","8f2203cb8ae87188877cfbf6ad170c5738a0aad5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8f2203cb8ae87188877cfbf6ad170c5738a0aad5"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["36d13f271b6649357e07f71f7e46559479f69b5b"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"36d13f271b6649357e07f71f7e46559479f69b5b":["aef2a94da918b657d107b616a643e1759db43b6a"],"8f2203cb8ae87188877cfbf6ad170c5738a0aad5":["b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"aef2a94da918b657d107b616a643e1759db43b6a":["b70042a8a492f7054d480ccdd2be9796510d4327","8f2203cb8ae87188877cfbf6ad170c5738a0aad5","f592209545c71895260367152601e9200399776d"],"f592209545c71895260367152601e9200399776d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}