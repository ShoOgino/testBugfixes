{"path":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete(String).mjava","commits":[{"id":"2c0d0643efdcc41b0c814bf27a381e4dc2ff472b","date":1438774486,"type":1,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete().mjava","sourceNew":"  protected void testCollectionCreateSearchDelete(String collectionName) throws Exception {\n\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId);\n      if (asyncId != null) {\n        assertEquals(\"did not see async createCollection completion\", \"completed\", AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient));\n      }\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState();\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n        \n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner();\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n        Thread.sleep(15000);\n        try {\n          cloudSolrClient.query(query);\n          fail(\"Expected exception on query because collection should not be ready - we have turned on async core loading\");\n        } catch (SolrServerException e) {\n          SolrException rc = (SolrException) e.getRootCause();\n          assertTrue(rc.code() >= 500 && rc.code() < 600);\n        } catch (SolrException e) {\n          assertTrue(e.code() >= 500 && e.code() < 600);\n        }\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  protected void testCollectionCreateSearchDelete() throws Exception {\n\n    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), \"solr-no-core.xml\");\n    Builder jettyConfig = JettyConfig.builder();\n    jettyConfig.waitForLoadingCoresToFinish(null);\n    MiniSolrCloudCluster miniCluster = new MiniSolrCloudCluster(NUM_SERVERS, createTempDir().toFile(), solrXml, jettyConfig.build());\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      String collectionName = \"testSolrCloudCollection\";\n      String configName = \"solrCloudCollectionConfig\";\n      File configDir = new File(SolrTestCaseJ4.TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n      miniCluster.uploadConfigDir(configDir, configName);\n\n      Map<String, String> collectionProperties = new HashMap<>();\n      collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-tlog.xml\");\n      collectionProperties.put(\"solr.tests.maxBufferedDocs\", \"100000\");\n      collectionProperties.put(\"solr.tests.ramBufferSizeMB\", \"100\");\n      // use non-test classes so RandomizedRunner isn't necessary\n      collectionProperties.put(\"solr.tests.mergePolicy\", \"org.apache.lucene.index.TieredMergePolicy\");\n      collectionProperties.put(\"solr.tests.mergeScheduler\", \"org.apache.lucene.index.ConcurrentMergeScheduler\");\n      collectionProperties.put(\"solr.directoryFactory\", \"solr.RAMDirectoryFactory\");\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      miniCluster.createCollection(collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName, asyncId, collectionProperties);\n      if (asyncId != null) {\n        assertEquals(\"did not see async createCollection completion\", \"completed\", AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient));\n      }\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState();\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n        \n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner();\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n        Thread.sleep(15000);\n        try {\n          cloudSolrClient.query(query);\n          fail(\"Expected exception on query because collection should not be ready - we have turned on async core loading\");\n        } catch (SolrServerException e) {\n          SolrException rc = (SolrException) e.getRootCause();\n          assertTrue(rc.code() >= 500 && rc.code() < 600);\n        } catch (SolrException e) {\n          assertTrue(e.code() >= 500 && e.code() < 600);\n        }\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ccfb40e1834cac1619556a0becf198bb7bad5d63","date":1438887805,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete(String).mjava","sourceNew":"  protected void testCollectionCreateSearchDelete(String collectionName) throws Exception {\n\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId);\n      if (asyncId != null) {\n        assertEquals(\"did not see async createCollection completion\", \"completed\", AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient));\n      }\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState();\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n        \n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner();\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n        Thread.sleep(15000);\n        try {\n          cloudSolrClient.query(query);\n          fail(\"Expected exception on query because collection should not be ready - we have turned on async core loading\");\n        } catch (SolrServerException e) {\n          SolrException rc = (SolrException) e.getRootCause();\n          assertTrue(rc.code() >= 500 && rc.code() < 600);\n        } catch (SolrException e) {\n          assertTrue(e.code() >= 500 && e.code() < 600);\n        }\n\n        doExtraTests(miniCluster, zkClient, zkStateReader,cloudSolrClient, collectionName);\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  protected void testCollectionCreateSearchDelete(String collectionName) throws Exception {\n\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId);\n      if (asyncId != null) {\n        assertEquals(\"did not see async createCollection completion\", \"completed\", AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient));\n      }\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState();\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n        \n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner();\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n        Thread.sleep(15000);\n        try {\n          cloudSolrClient.query(query);\n          fail(\"Expected exception on query because collection should not be ready - we have turned on async core loading\");\n        } catch (SolrServerException e) {\n          SolrException rc = (SolrException) e.getRootCause();\n          assertTrue(rc.code() >= 500 && rc.code() < 600);\n        } catch (SolrException e) {\n          assertTrue(e.code() >= 500 && e.code() < 600);\n        }\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":["77aad0f26236c97028aecb0fcc76de2b13edf1a0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"77aad0f26236c97028aecb0fcc76de2b13edf1a0","date":1441298393,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete(String).mjava","sourceNew":"  protected void testCollectionCreateSearchDelete(String collectionName) throws Exception {\n\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId);\n      if (asyncId != null) {\n        assertEquals(\"did not see async createCollection completion\", \"completed\", AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient));\n      }\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState();\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n        \n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner();\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n        Thread.sleep(15000);\n        try {\n          cloudSolrClient.query(query);\n          fail(\"Expected exception on query because collection should not be ready - we have turned on async core loading\");\n        } catch (SolrServerException e) {\n          SolrException rc = (SolrException) e.getRootCause();\n          assertTrue(rc.code() >= 500 && rc.code() < 600);\n        } catch (SolrException e) {\n          assertTrue(e.code() >= 500 && e.code() < 600);\n        }\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  protected void testCollectionCreateSearchDelete(String collectionName) throws Exception {\n\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId);\n      if (asyncId != null) {\n        assertEquals(\"did not see async createCollection completion\", \"completed\", AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient));\n      }\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState();\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n        \n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner();\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n        Thread.sleep(15000);\n        try {\n          cloudSolrClient.query(query);\n          fail(\"Expected exception on query because collection should not be ready - we have turned on async core loading\");\n        } catch (SolrServerException e) {\n          SolrException rc = (SolrException) e.getRootCause();\n          assertTrue(rc.code() >= 500 && rc.code() < 600);\n        } catch (SolrException e) {\n          assertTrue(e.code() >= 500 && e.code() < 600);\n        }\n\n        doExtraTests(miniCluster, zkClient, zkStateReader,cloudSolrClient, collectionName);\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":["ccfb40e1834cac1619556a0becf198bb7bad5d63"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57131fa4ce09b8042f56ebbbd65dfe28c51d2ad7","date":1445955220,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete(String).mjava","sourceNew":"  protected void testCollectionCreateSearchDelete(String collectionName) throws Exception {\n\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId, random().nextBoolean());\n      if (asyncId != null) {\n        assertEquals(\"did not see async createCollection completion\", \"completed\", AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient));\n      }\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState();\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n        \n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner();\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n        Thread.sleep(15000);\n        try {\n          cloudSolrClient.query(query);\n          fail(\"Expected exception on query because collection should not be ready - we have turned on async core loading\");\n        } catch (SolrServerException e) {\n          SolrException rc = (SolrException) e.getRootCause();\n          assertTrue(rc.code() >= 500 && rc.code() < 600);\n        } catch (SolrException e) {\n          assertTrue(e.code() >= 500 && e.code() < 600);\n        }\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  protected void testCollectionCreateSearchDelete(String collectionName) throws Exception {\n\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId);\n      if (asyncId != null) {\n        assertEquals(\"did not see async createCollection completion\", \"completed\", AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient));\n      }\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState();\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n        \n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner();\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n        Thread.sleep(15000);\n        try {\n          cloudSolrClient.query(query);\n          fail(\"Expected exception on query because collection should not be ready - we have turned on async core loading\");\n        } catch (SolrServerException e) {\n          SolrException rc = (SolrException) e.getRootCause();\n          assertTrue(rc.code() >= 500 && rc.code() < 600);\n        } catch (SolrException e) {\n          assertTrue(e.code() >= 500 && e.code() < 600);\n        }\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f0c130ec24cbb2eef3d8e7f0e971736f0bea8f54","date":1446047031,"type":4,"author":"Alan Woodward","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testCollectionCreateSearchDelete(String).mjava","sourceNew":null,"sourceOld":"  protected void testCollectionCreateSearchDelete(String collectionName) throws Exception {\n\n    MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      // shut down a server\n      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);\n      assertTrue(stoppedServer.isStopped());\n      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n\n      // create a server\n      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();\n      assertTrue(startedServer.isRunning());\n      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n\n      // create collection\n      final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n      createCollection(miniCluster, collectionName, null, asyncId, random().nextBoolean());\n      if (asyncId != null) {\n        assertEquals(\"did not see async createCollection completion\", \"completed\", AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient));\n      }\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify/query collection\n        cloudSolrClient.setDefaultCollection(collectionName);\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(\"id\", \"1\");\n        cloudSolrClient.add(doc);\n        cloudSolrClient.commit();\n        SolrQuery query = new SolrQuery();\n        query.setQuery(\"*:*\");\n        QueryResponse rsp = cloudSolrClient.query(query);\n        assertEquals(1, rsp.getResults().getNumFound());\n\n        // remove a server not hosting any replicas\n        zkStateReader.updateClusterState();\n        ClusterState clusterState = zkStateReader.getClusterState();\n        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();\n        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {\n          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + \"://\").length());\n          jettyMap.put(key, jetty);\n        }\n        Collection<Slice> slices = clusterState.getSlices(collectionName);\n        // track the servers not host repliacs\n        for (Slice slice : slices) {\n          jettyMap.remove(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"));\n          for (Replica replica : slice.getReplicas()) {\n            jettyMap.remove(replica.getNodeName().replace(\"_solr\", \"/solr\"));\n          }\n        }\n        assertTrue(\"Expected to find a node without a replica\", jettyMap.size() > 0);\n        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();\n        jettys = miniCluster.getJettySolrRunners();\n        for (int i = 0; i < jettys.size(); ++i) {\n          if (jettys.get(i).equals(jettyToStop)) {\n            miniCluster.stopJettySolrRunner(i);\n            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());\n          }\n        }\n\n        // now restore the original state so that this function could be called multiple times\n        \n        // re-create a server (to restore original NUM_SERVERS count)\n        startedServer = miniCluster.startJettySolrRunner();\n        assertTrue(startedServer.isRunning());\n        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());\n        Thread.sleep(15000);\n        try {\n          cloudSolrClient.query(query);\n          fail(\"Expected exception on query because collection should not be ready - we have turned on async core loading\");\n        } catch (SolrServerException e) {\n          SolrException rc = (SolrException) e.getRootCause();\n          assertTrue(rc.code() >= 500 && rc.code() < 600);\n        } catch (SolrException e) {\n          assertTrue(e.code() >= 500 && e.code() < 600);\n        }\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2c0d0643efdcc41b0c814bf27a381e4dc2ff472b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f0c130ec24cbb2eef3d8e7f0e971736f0bea8f54":["57131fa4ce09b8042f56ebbbd65dfe28c51d2ad7"],"77aad0f26236c97028aecb0fcc76de2b13edf1a0":["ccfb40e1834cac1619556a0becf198bb7bad5d63"],"ccfb40e1834cac1619556a0becf198bb7bad5d63":["2c0d0643efdcc41b0c814bf27a381e4dc2ff472b"],"57131fa4ce09b8042f56ebbbd65dfe28c51d2ad7":["77aad0f26236c97028aecb0fcc76de2b13edf1a0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f0c130ec24cbb2eef3d8e7f0e971736f0bea8f54"]},"commit2Childs":{"2c0d0643efdcc41b0c814bf27a381e4dc2ff472b":["ccfb40e1834cac1619556a0becf198bb7bad5d63"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2c0d0643efdcc41b0c814bf27a381e4dc2ff472b"],"f0c130ec24cbb2eef3d8e7f0e971736f0bea8f54":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"77aad0f26236c97028aecb0fcc76de2b13edf1a0":["57131fa4ce09b8042f56ebbbd65dfe28c51d2ad7"],"ccfb40e1834cac1619556a0becf198bb7bad5d63":["77aad0f26236c97028aecb0fcc76de2b13edf1a0"],"57131fa4ce09b8042f56ebbbd65dfe28c51d2ad7":["f0c130ec24cbb2eef3d8e7f0e971736f0bea8f54"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}