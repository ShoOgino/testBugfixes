{"path":"lucene/contrib/lucli/src/java/lucli/LuceneMethods#terms(String).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/lucli/src/java/lucli/LuceneMethods#terms(String).mjava","pathOld":"contrib/lucli/src/java/lucli/LuceneMethods#terms(String).mjava","sourceNew":"  /** Provides a list of the top terms of the index.\n   *\n   * @param field  - the name of the command or null for all of them.\n   */\n  public void terms(String field) throws IOException {\n    TreeMap<String,Integer> termMap = new TreeMap<String,Integer>();\n    IndexReader indexReader = IndexReader.open(indexName, true);\n    TermEnum terms = indexReader.terms();\n    while (terms.next()) {\n      Term term = terms.term();\n      //message(term.field() + \":\" + term.text() + \" freq:\" + terms.docFreq());\n      //if we're either not looking by field or we're matching the specific field\n      if ((field == null) || field.equals(term.field()))\n        termMap.put(term.field() + \":\" + term.text(), Integer.valueOf((terms.docFreq())));\n    }\n\n    Iterator<String> termIterator = termMap.keySet().iterator();\n    for (int ii = 0; termIterator.hasNext() && ii < 100; ii++) {\n      String termDetails = termIterator.next();\n      Integer termFreq = termMap.get(termDetails);\n      message(termDetails + \": \" + termFreq);\n    }\n    indexReader.close();\n  }\n\n","sourceOld":"  /** Provides a list of the top terms of the index.\n   *\n   * @param field  - the name of the command or null for all of them.\n   */\n  public void terms(String field) throws IOException {\n    TreeMap<String,Integer> termMap = new TreeMap<String,Integer>();\n    IndexReader indexReader = IndexReader.open(indexName, true);\n    TermEnum terms = indexReader.terms();\n    while (terms.next()) {\n      Term term = terms.term();\n      //message(term.field() + \":\" + term.text() + \" freq:\" + terms.docFreq());\n      //if we're either not looking by field or we're matching the specific field\n      if ((field == null) || field.equals(term.field()))\n        termMap.put(term.field() + \":\" + term.text(), Integer.valueOf((terms.docFreq())));\n    }\n\n    Iterator<String> termIterator = termMap.keySet().iterator();\n    for (int ii = 0; termIterator.hasNext() && ii < 100; ii++) {\n      String termDetails = termIterator.next();\n      Integer termFreq = termMap.get(termDetails);\n      message(termDetails + \": \" + termFreq);\n    }\n    indexReader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28427ef110c4c5bf5b4057731b83110bd1e13724","date":1276701452,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/contrib/lucli/src/java/lucli/LuceneMethods#terms(String).mjava","pathOld":"lucene/contrib/lucli/src/java/lucli/LuceneMethods#terms(String).mjava","sourceNew":"  /** Provides a list of the top terms of the index.\n   *\n   * @param field  - the name of the command or null for all of them.\n   */\n  public void terms(String field) throws IOException {\n    TreeMap<String,Integer> termMap = new TreeMap<String,Integer>();\n    IndexReader indexReader = IndexReader.open(indexName, true);\n    Fields fields = MultiFields.getFields(indexReader);\n    if (fields != null) {\n      FieldsEnum fieldsEnum = fields.iterator();\n      String curField;\n      while((curField = fieldsEnum.next()) != null) {\n        TermsEnum terms = fieldsEnum.terms();\n        BytesRef text;\n        while ((text = terms.next()) != null) {\n          //message(term.field() + \":\" + term.text() + \" freq:\" + terms.docFreq());\n          //if we're either not looking by field or we're matching the specific field\n          if ((field == null) || field.equals(curField)) {\n            termMap.put(curField + \":\" + text.utf8ToString(), Integer.valueOf((terms.docFreq())));\n          }\n        }\n      }\n    }\n\n    Iterator<String> termIterator = termMap.keySet().iterator();\n    for (int ii = 0; termIterator.hasNext() && ii < 100; ii++) {\n      String termDetails = termIterator.next();\n      Integer termFreq = termMap.get(termDetails);\n      message(termDetails + \": \" + termFreq);\n    }\n    indexReader.close();\n  }\n\n","sourceOld":"  /** Provides a list of the top terms of the index.\n   *\n   * @param field  - the name of the command or null for all of them.\n   */\n  public void terms(String field) throws IOException {\n    TreeMap<String,Integer> termMap = new TreeMap<String,Integer>();\n    IndexReader indexReader = IndexReader.open(indexName, true);\n    TermEnum terms = indexReader.terms();\n    while (terms.next()) {\n      Term term = terms.term();\n      //message(term.field() + \":\" + term.text() + \" freq:\" + terms.docFreq());\n      //if we're either not looking by field or we're matching the specific field\n      if ((field == null) || field.equals(term.field()))\n        termMap.put(term.field() + \":\" + term.text(), Integer.valueOf((terms.docFreq())));\n    }\n\n    Iterator<String> termIterator = termMap.keySet().iterator();\n    for (int ii = 0; termIterator.hasNext() && ii < 100; ii++) {\n      String termDetails = termIterator.next();\n      Integer termFreq = termMap.get(termDetails);\n      message(termDetails + \": \" + termFreq);\n    }\n    indexReader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/contrib/lucli/src/java/lucli/LuceneMethods#terms(String).mjava","pathOld":"lucene/contrib/lucli/src/java/lucli/LuceneMethods#terms(String).mjava","sourceNew":"  /** Provides a list of the top terms of the index.\n   *\n   * @param field  - the name of the command or null for all of them.\n   */\n  public void terms(String field) throws IOException {\n    TreeMap<String,Integer> termMap = new TreeMap<String,Integer>();\n    IndexReader indexReader = IndexReader.open(indexName, true);\n    Fields fields = MultiFields.getFields(indexReader);\n    if (fields != null) {\n      FieldsEnum fieldsEnum = fields.iterator();\n      String curField;\n      while((curField = fieldsEnum.next()) != null) {\n        TermsEnum terms = fieldsEnum.terms();\n        BytesRef text;\n        while ((text = terms.next()) != null) {\n          //message(term.field() + \":\" + term.text() + \" freq:\" + terms.docFreq());\n          //if we're either not looking by field or we're matching the specific field\n          if ((field == null) || field.equals(curField)) {\n            termMap.put(curField + \":\" + text.utf8ToString(), Integer.valueOf((terms.docFreq())));\n          }\n        }\n      }\n    }\n\n    Iterator<String> termIterator = termMap.keySet().iterator();\n    for (int ii = 0; termIterator.hasNext() && ii < 100; ii++) {\n      String termDetails = termIterator.next();\n      Integer termFreq = termMap.get(termDetails);\n      message(termDetails + \": \" + termFreq);\n    }\n    indexReader.close();\n  }\n\n","sourceOld":"  /** Provides a list of the top terms of the index.\n   *\n   * @param field  - the name of the command or null for all of them.\n   */\n  public void terms(String field) throws IOException {\n    TreeMap<String,Integer> termMap = new TreeMap<String,Integer>();\n    IndexReader indexReader = IndexReader.open(indexName, true);\n    TermEnum terms = indexReader.terms();\n    while (terms.next()) {\n      Term term = terms.term();\n      //message(term.field() + \":\" + term.text() + \" freq:\" + terms.docFreq());\n      //if we're either not looking by field or we're matching the specific field\n      if ((field == null) || field.equals(term.field()))\n        termMap.put(term.field() + \":\" + term.text(), Integer.valueOf((terms.docFreq())));\n    }\n\n    Iterator<String> termIterator = termMap.keySet().iterator();\n    for (int ii = 0; termIterator.hasNext() && ii < 100; ii++) {\n      String termDetails = termIterator.next();\n      Integer termFreq = termMap.get(termDetails);\n      message(termDetails + \": \" + termFreq);\n    }\n    indexReader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a55c46ea262f9033bd9ab60542dea4b38abef33","date":1306109444,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/contrib/lucli/src/java/lucli/LuceneMethods#terms(String).mjava","sourceNew":null,"sourceOld":"  /** Provides a list of the top terms of the index.\n   *\n   * @param field  - the name of the command or null for all of them.\n   */\n  public void terms(String field) throws IOException {\n    TreeMap<String,Integer> termMap = new TreeMap<String,Integer>();\n    IndexReader indexReader = IndexReader.open(indexName, true);\n    Fields fields = MultiFields.getFields(indexReader);\n    if (fields != null) {\n      FieldsEnum fieldsEnum = fields.iterator();\n      String curField;\n      while((curField = fieldsEnum.next()) != null) {\n        TermsEnum terms = fieldsEnum.terms();\n        BytesRef text;\n        while ((text = terms.next()) != null) {\n          //message(term.field() + \":\" + term.text() + \" freq:\" + terms.docFreq());\n          //if we're either not looking by field or we're matching the specific field\n          if ((field == null) || field.equals(curField)) {\n            termMap.put(curField + \":\" + text.utf8ToString(), Integer.valueOf((terms.docFreq())));\n          }\n        }\n      }\n    }\n\n    Iterator<String> termIterator = termMap.keySet().iterator();\n    for (int ii = 0; termIterator.hasNext() && ii < 100; ii++) {\n      String termDetails = termIterator.next();\n      Integer termFreq = termMap.get(termDetails);\n      message(termDetails + \": \" + termFreq);\n    }\n    indexReader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae132b768aece5bf21cda14e2f17fba66eb6f7d6","date":1306128032,"type":4,"author":"Steven Rowe","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/contrib/lucli/src/java/lucli/LuceneMethods#terms(String).mjava","sourceNew":null,"sourceOld":"  /** Provides a list of the top terms of the index.\n   *\n   * @param field  - the name of the command or null for all of them.\n   */\n  public void terms(String field) throws IOException {\n    TreeMap<String,Integer> termMap = new TreeMap<String,Integer>();\n    IndexReader indexReader = IndexReader.open(indexName, true);\n    Fields fields = MultiFields.getFields(indexReader);\n    if (fields != null) {\n      FieldsEnum fieldsEnum = fields.iterator();\n      String curField;\n      while((curField = fieldsEnum.next()) != null) {\n        TermsEnum terms = fieldsEnum.terms();\n        BytesRef text;\n        while ((text = terms.next()) != null) {\n          //message(term.field() + \":\" + term.text() + \" freq:\" + terms.docFreq());\n          //if we're either not looking by field or we're matching the specific field\n          if ((field == null) || field.equals(curField)) {\n            termMap.put(curField + \":\" + text.utf8ToString(), Integer.valueOf((terms.docFreq())));\n          }\n        }\n      }\n    }\n\n    Iterator<String> termIterator = termMap.keySet().iterator();\n    for (int ii = 0; termIterator.hasNext() && ii < 100; ii++) {\n      String termDetails = termIterator.next();\n      Integer termFreq = termMap.get(termDetails);\n      message(termDetails + \": \" + termFreq);\n    }\n    indexReader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c698c0cb88bac4bcd36a1b1001a0c6a2163ea2a","date":1306150983,"type":4,"author":"Simon Willnauer","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/contrib/lucli/src/java/lucli/LuceneMethods#terms(String).mjava","sourceNew":null,"sourceOld":"  /** Provides a list of the top terms of the index.\n   *\n   * @param field  - the name of the command or null for all of them.\n   */\n  public void terms(String field) throws IOException {\n    TreeMap<String,Integer> termMap = new TreeMap<String,Integer>();\n    IndexReader indexReader = IndexReader.open(indexName, true);\n    Fields fields = MultiFields.getFields(indexReader);\n    if (fields != null) {\n      FieldsEnum fieldsEnum = fields.iterator();\n      String curField;\n      while((curField = fieldsEnum.next()) != null) {\n        TermsEnum terms = fieldsEnum.terms();\n        BytesRef text;\n        while ((text = terms.next()) != null) {\n          //message(term.field() + \":\" + term.text() + \" freq:\" + terms.docFreq());\n          //if we're either not looking by field or we're matching the specific field\n          if ((field == null) || field.equals(curField)) {\n            termMap.put(curField + \":\" + text.utf8ToString(), Integer.valueOf((terms.docFreq())));\n          }\n        }\n      }\n    }\n\n    Iterator<String> termIterator = termMap.keySet().iterator();\n    for (int ii = 0; termIterator.hasNext() && ii < 100; ii++) {\n      String termDetails = termIterator.next();\n      Integer termFreq = termMap.get(termDetails);\n      message(termDetails + \": \" + termFreq);\n    }\n    indexReader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ae132b768aece5bf21cda14e2f17fba66eb6f7d6":["28427ef110c4c5bf5b4057731b83110bd1e13724","3a55c46ea262f9033bd9ab60542dea4b38abef33"],"5c698c0cb88bac4bcd36a1b1001a0c6a2163ea2a":["28427ef110c4c5bf5b4057731b83110bd1e13724","3a55c46ea262f9033bd9ab60542dea4b38abef33"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"28427ef110c4c5bf5b4057731b83110bd1e13724":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"3a55c46ea262f9033bd9ab60542dea4b38abef33":["28427ef110c4c5bf5b4057731b83110bd1e13724"],"5f4e87790277826a2aea119328600dfb07761f32":["9454a6510e2db155fb01faa5c049b06ece95fab9","28427ef110c4c5bf5b4057731b83110bd1e13724"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a55c46ea262f9033bd9ab60542dea4b38abef33"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"ae132b768aece5bf21cda14e2f17fba66eb6f7d6":[],"5c698c0cb88bac4bcd36a1b1001a0c6a2163ea2a":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"28427ef110c4c5bf5b4057731b83110bd1e13724":["ae132b768aece5bf21cda14e2f17fba66eb6f7d6","5c698c0cb88bac4bcd36a1b1001a0c6a2163ea2a","3a55c46ea262f9033bd9ab60542dea4b38abef33","5f4e87790277826a2aea119328600dfb07761f32"],"3a55c46ea262f9033bd9ab60542dea4b38abef33":["ae132b768aece5bf21cda14e2f17fba66eb6f7d6","5c698c0cb88bac4bcd36a1b1001a0c6a2163ea2a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5f4e87790277826a2aea119328600dfb07761f32":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["28427ef110c4c5bf5b4057731b83110bd1e13724","5f4e87790277826a2aea119328600dfb07761f32"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ae132b768aece5bf21cda14e2f17fba66eb6f7d6","5c698c0cb88bac4bcd36a1b1001a0c6a2163ea2a","5f4e87790277826a2aea119328600dfb07761f32","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}