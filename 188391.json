{"path":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","commits":[{"id":"71f14bcc8e12885ab59981c9fdecebb7c2ef3ca0","date":1371567556,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps,String).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n    if (handler instanceof LazyRequestHandlerWrapper) {\n      handler = ((LazyRequestHandlerWrapper) handler).getWrappedHandler();\n    }\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) retries = INTERRUPTED;\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Replication for recovery failed.\");\n    }\n\n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    \n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops, String baseUrl)\n      throws SolrServerException, IOException {\n   \n    String leaderBaseUrl = leaderprops.getStr(ZkStateReader.BASE_URL_PROP);\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // if we are the leader, either we are trying to recover faster\n    // then our ephemeral timed out or we are the only node\n    if (!leaderBaseUrl.equals(baseUrl)) {\n      \n      // send commit\n      commitOnLeader(leaderUrl);\n      \n      // use rep handler directly, so we can do this sync rather than async\n      SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n      if (handler instanceof LazyRequestHandlerWrapper) {\n        handler = ((LazyRequestHandlerWrapper)handler).getWrappedHandler();\n      }\n      ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n      \n      if (replicationHandler == null) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n      }\n      \n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n      \n      if (isClosed()) retries = INTERRUPTED;\n      boolean success = replicationHandler.doFetch(solrParams, false);\n\n      if (!success) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n      }\n      \n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":0,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"/dev/null","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n    if (handler instanceof LazyRequestHandlerWrapper) {\n      handler = ((LazyRequestHandlerWrapper) handler).getWrappedHandler();\n    }\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) retries = INTERRUPTED;\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Replication for recovery failed.\");\n    }\n\n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c52ad29218ee436d52c57bf0829b98acad9de379","date":1383401544,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n    if (handler instanceof LazyRequestHandlerWrapper) {\n      handler = ((LazyRequestHandlerWrapper) handler).getWrappedHandler();\n    }\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) retries = INTERRUPTED;\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (Boolean.getBoolean(\"solr.cloud.debug\")) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        try {\n          System.err.println(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + core.getDeletionPolicy().getLatestCommit().getGeneration()\n              + \" data:\" + core.getDataDir());\n        } finally {\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n      }\n    }\n\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n    if (handler instanceof LazyRequestHandlerWrapper) {\n      handler = ((LazyRequestHandlerWrapper) handler).getWrappedHandler();\n    }\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) retries = INTERRUPTED;\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Replication for recovery failed.\");\n    }\n\n      // solrcloud_debug\n//      try {\n//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//        SolrIndexSearcher searcher = searchHolder.get();\n//        try {\n//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replicated \"\n//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + \" from \" + leaderUrl + \" gen:\" + core.getDeletionPolicy().getLatestCommit().getGeneration() + \" data:\" + core.getDataDir());\n//        } finally {\n//          searchHolder.decref();\n//        }\n//      } catch (Exception e) {\n//        \n//      }\n    \n  }\n\n","bugFix":null,"bugIntro":["f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6","6c94d2661bc1c14426980ec7882e951fdcff08d0","190779ba7de3fda15afd1bbafbc383720a4b0966"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"89b56ee224dbe29ee4436d91a7070ca418ffc4fb","date":1383492966,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n    if (handler instanceof LazyRequestHandlerWrapper) {\n      handler = ((LazyRequestHandlerWrapper) handler).getWrappedHandler();\n    }\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) retries = INTERRUPTED;\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        try {\n          log.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + core.getDeletionPolicy().getLatestCommit().getGeneration()\n              + \" data:\" + core.getDataDir());\n        } finally {\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n      }\n    }\n\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n    if (handler instanceof LazyRequestHandlerWrapper) {\n      handler = ((LazyRequestHandlerWrapper) handler).getWrappedHandler();\n    }\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) retries = INTERRUPTED;\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (Boolean.getBoolean(\"solr.cloud.debug\")) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        try {\n          System.err.println(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + core.getDeletionPolicy().getLatestCommit().getGeneration()\n              + \" data:\" + core.getDataDir());\n        } finally {\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"190779ba7de3fda15afd1bbafbc383720a4b0966","date":1384747256,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n    if (handler instanceof LazyRequestHandlerWrapper) {\n      handler = ((LazyRequestHandlerWrapper) handler).getWrappedHandler();\n    }\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) retries = INTERRUPTED;\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          log.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + core.getDeletionPolicy().getLatestCommit().getGeneration()\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n      }\n    }\n\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n    if (handler instanceof LazyRequestHandlerWrapper) {\n      handler = ((LazyRequestHandlerWrapper) handler).getWrappedHandler();\n    }\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) retries = INTERRUPTED;\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        try {\n          log.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + core.getDeletionPolicy().getLatestCommit().getGeneration()\n              + \" data:\" + core.getDataDir());\n        } finally {\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n      }\n    }\n\n  }\n\n","bugFix":["c52ad29218ee436d52c57bf0829b98acad9de379"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n    if (handler instanceof LazyRequestHandlerWrapper) {\n      handler = ((LazyRequestHandlerWrapper) handler).getWrappedHandler();\n    }\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) retries = INTERRUPTED;\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          log.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + core.getDeletionPolicy().getLatestCommit().getGeneration()\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n      }\n    }\n\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n    if (handler instanceof LazyRequestHandlerWrapper) {\n      handler = ((LazyRequestHandlerWrapper) handler).getWrappedHandler();\n    }\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) retries = INTERRUPTED;\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        try {\n          log.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + core.getDeletionPolicy().getLatestCommit().getGeneration()\n              + \" data:\" + core.getDataDir());\n        } finally {\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e8fa677b7b2405d2c2b902646dbae8f5fe34b60e","date":1423420267,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n    if (handler instanceof LazyRequestHandlerWrapper) {\n      handler = ((LazyRequestHandlerWrapper) handler).getWrappedHandler();\n    }\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          log.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + core.getDeletionPolicy().getLatestCommit().getGeneration()\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n      }\n    }\n\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n    if (handler instanceof LazyRequestHandlerWrapper) {\n      handler = ((LazyRequestHandlerWrapper) handler).getWrappedHandler();\n    }\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) retries = INTERRUPTED;\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          log.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + core.getDeletionPolicy().getLatestCommit().getGeneration()\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n      }\n    }\n\n  }\n\n","bugFix":["71f14bcc8e12885ab59981c9fdecebb7c2ef3ca0"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9aea0485ecacb6734c17da2d02569816c23a69c1","date":1425707735,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          log.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + core.getDeletionPolicy().getLatestCommit().getGeneration()\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n      }\n    }\n\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n    if (handler instanceof LazyRequestHandlerWrapper) {\n      handler = ((LazyRequestHandlerWrapper) handler).getWrappedHandler();\n    }\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          log.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + core.getDeletionPolicy().getLatestCommit().getGeneration()\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6c94d2661bc1c14426980ec7882e951fdcff08d0","date":1427167177,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          log.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration()\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        log.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          log.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + core.getDeletionPolicy().getLatestCommit().getGeneration()\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n      }\n    }\n\n  }\n\n","bugFix":["c52ad29218ee436d52c57bf0829b98acad9de379","71f14bcc8e12885ab59981c9fdecebb7c2ef3ca0"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          log.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration()\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        log.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n    if (handler instanceof LazyRequestHandlerWrapper) {\n      handler = ((LazyRequestHandlerWrapper) handler).getWrappedHandler();\n    }\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          log.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + core.getDeletionPolicy().getLatestCommit().getGeneration()\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"439c63ae5d22132fca810a0029a854e97d2c1a3e","date":1432733612,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \".\");\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          log.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration()\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        log.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \". core=\" + coreName);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          log.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration()\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        log.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"610f5499a87a7113d53e5b621b616890f002e9f1","date":1450873010,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration()\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    log.info(\"Attempting to replicate from \" + leaderUrl + \".\");\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          log.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration()\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        log.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"71475d88ea48a7d9a847f209667255318b3ea4c7","date":1461758968,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration()\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(REPLICATION_HANDLER);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + REPLICATION_HANDLER + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration()\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a5d615d62cd8aff3690943d765e46942551f98b6","date":1474881754,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration()\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration()\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","sourceNew":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration()\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7392b75d2c2f2aecf31188732a0764fe0dc74ade","date":1489420141,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","sourceNew":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","sourceOld":"  private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    ZkCoreNodeProps leaderCNodeProps = new ZkCoreNodeProps(leaderprops);\n    String leaderUrl = leaderCNodeProps.getCoreUrl();\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c641347aa34a81b8c172fd46691e3cba6357a6f","date":1490409984,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","sourceNew":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false).getSuccessful();\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","sourceOld":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d5f6959c652bdf332fe98fc9180b54095a4053ae","date":1490594650,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","sourceNew":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false).getSuccessful();\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","sourceOld":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false);\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"729cb470f975115d4c60517b2cb7c42e37a7a2e1","date":1492041760,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","sourceNew":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false).getSuccessful();\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","sourceOld":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false).getSuccessful();\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","sourceNew":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false).getSuccessful();\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","sourceOld":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false).getSuccessful();\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6","date":1498031702,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","sourceNew":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false).getSuccessful();\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.count(new MatchAllDocsQuery())\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","sourceOld":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false).getSuccessful();\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","bugFix":["c52ad29218ee436d52c57bf0829b98acad9de379"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","sourceNew":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false).getSuccessful();\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.count(new MatchAllDocsQuery())\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","sourceOld":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false).getSuccessful();\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","sourceNew":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false).getSuccessful();\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.count(new MatchAllDocsQuery())\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","sourceOld":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false).getSuccessful();\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"04ecf884544ff74add5faa452748f160c4af904b","date":1506527215,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","sourceNew":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    solrParams.set(ReplicationHandler.SKIP_COMMIT_ON_MASTER_VERSION_ZERO, replicaType == Replica.Type.TLOG);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false).getSuccessful();\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.count(new MatchAllDocsQuery())\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","sourceOld":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false).getSuccessful();\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.count(new MatchAllDocsQuery())\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6240b74b884c5587f2a4062dd27d6c32bf228889","date":1507037235,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","sourceNew":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    solrParams.set(ReplicationHandler.SKIP_COMMIT_ON_MASTER_VERSION_ZERO, replicaType == Replica.Type.TLOG);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false).getSuccessful();\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.count(new MatchAllDocsQuery())\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","sourceOld":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false).getSuccessful();\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.count(new MatchAllDocsQuery())\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9767eba84e83b05b2a675421e190f4a4c15dad44","date":1508967004,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","sourceNew":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    solrParams.set(ReplicationHandler.SKIP_COMMIT_ON_MASTER_VERSION_ZERO, replicaType == Replica.Type.TLOG);\n    // always download the tlogs from the leader when running with cdcr enabled. We need to have all the tlogs\n    // to ensure leader failover doesn't cause missing docs on the target\n    if (core.getUpdateHandler().getUpdateLog() != null && core.getUpdateHandler().getUpdateLog() instanceof CdcrUpdateLog) {\n      solrParams.set(ReplicationHandler.TLOG_FILES, true);\n    }\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false).getSuccessful();\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.count(new MatchAllDocsQuery())\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","sourceOld":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    solrParams.set(ReplicationHandler.SKIP_COMMIT_ON_MASTER_VERSION_ZERO, replicaType == Replica.Type.TLOG);\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false).getSuccessful();\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.count(new MatchAllDocsQuery())\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","sourceNew":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n    \n    log.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    solrParams.set(ReplicationHandler.SKIP_COMMIT_ON_MASTER_VERSION_ZERO, replicaType == Replica.Type.TLOG);\n    // always download the tlogs from the leader when running with cdcr enabled. We need to have all the tlogs\n    // to ensure leader failover doesn't cause missing docs on the target\n    if (core.getUpdateHandler().getUpdateLog() != null && core.getUpdateHandler().getUpdateLog() instanceof CdcrUpdateLog) {\n      solrParams.set(ReplicationHandler.TLOG_FILES, true);\n    }\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false).getSuccessful();\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          log.debug(core.getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.count(new MatchAllDocsQuery())\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        log.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","sourceOld":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n    \n    LOG.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    solrParams.set(ReplicationHandler.SKIP_COMMIT_ON_MASTER_VERSION_ZERO, replicaType == Replica.Type.TLOG);\n    // always download the tlogs from the leader when running with cdcr enabled. We need to have all the tlogs\n    // to ensure leader failover doesn't cause missing docs on the target\n    if (core.getUpdateHandler().getUpdateLog() != null && core.getUpdateHandler().getUpdateLog() instanceof CdcrUpdateLog) {\n      solrParams.set(ReplicationHandler.TLOG_FILES, true);\n    }\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false).getSuccessful();\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (LOG.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          LOG.debug(core.getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.count(new MatchAllDocsQuery())\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        LOG.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","sourceNew":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n\n    log.info(\"Attempting to replicate from [{}].\", leaderUrl);\n\n    // send commit\n    commitOnLeader(leaderUrl);\n\n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n\n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n\n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    solrParams.set(ReplicationHandler.SKIP_COMMIT_ON_MASTER_VERSION_ZERO, replicaType == Replica.Type.TLOG);\n    // always download the tlogs from the leader when running with cdcr enabled. We need to have all the tlogs\n    // to ensure leader failover doesn't cause missing docs on the target\n    if (core.getUpdateHandler().getUpdateLog() != null\n        && core.getUpdateHandler().getUpdateLog() instanceof CdcrUpdateLog) {\n      solrParams.set(ReplicationHandler.TLOG_FILES, true);\n    }\n\n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false).getSuccessful();\n\n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n\n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          log.debug(core.getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.count(new MatchAllDocsQuery())\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (core.getDeletionPolicy().getLatestCommit() != null ? \"null\"\n                  : core.getDeletionPolicy().getLatestCommit().getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        log.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","sourceOld":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n    \n    log.info(\"Attempting to replicate from [{}].\", leaderUrl);\n    \n    // send commit\n    commitOnLeader(leaderUrl);\n    \n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n    \n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n    \n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    solrParams.set(ReplicationHandler.SKIP_COMMIT_ON_MASTER_VERSION_ZERO, replicaType == Replica.Type.TLOG);\n    // always download the tlogs from the leader when running with cdcr enabled. We need to have all the tlogs\n    // to ensure leader failover doesn't cause missing docs on the target\n    if (core.getUpdateHandler().getUpdateLog() != null && core.getUpdateHandler().getUpdateLog() instanceof CdcrUpdateLog) {\n      solrParams.set(ReplicationHandler.TLOG_FILES, true);\n    }\n    \n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false).getSuccessful();\n    \n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n    \n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          log.debug(core.getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.count(new MatchAllDocsQuery())\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (core.getDeletionPolicy().getLatestCommit() != null ? \"null\" : core.getDeletionPolicy().getLatestCommit().getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        log.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","bugFix":["71f14bcc8e12885ab59981c9fdecebb7c2ef3ca0","9767eba84e83b05b2a675421e190f4a4c15dad44","a5d615d62cd8aff3690943d765e46942551f98b6"],"bugIntro":["19f02bb04467ed179738a398a7da80bbbe161c16"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"19f02bb04467ed179738a398a7da80bbbe161c16","date":1573660732,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","sourceNew":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n\n    log.info(\"Attempting to replicate from [{}].\", leaderUrl);\n\n    // send commit\n    commitOnLeader(leaderUrl);\n\n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n\n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n\n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    solrParams.set(ReplicationHandler.SKIP_COMMIT_ON_MASTER_VERSION_ZERO, replicaType == Replica.Type.TLOG);\n    // always download the tlogs from the leader when running with cdcr enabled. We need to have all the tlogs\n    // to ensure leader failover doesn't cause missing docs on the target\n    if (core.getUpdateHandler().getUpdateLog() != null\n        && core.getUpdateHandler().getUpdateLog() instanceof CdcrUpdateLog) {\n      solrParams.set(ReplicationHandler.TLOG_FILES, true);\n    }\n\n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false).getSuccessful();\n\n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n\n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          final IndexCommit commit = core.getDeletionPolicy().getLatestCommit();\n          log.debug(core.getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.count(new MatchAllDocsQuery())\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (null == commit ? \"null\" : commit.getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        log.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","sourceOld":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n\n    log.info(\"Attempting to replicate from [{}].\", leaderUrl);\n\n    // send commit\n    commitOnLeader(leaderUrl);\n\n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n\n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n\n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    solrParams.set(ReplicationHandler.SKIP_COMMIT_ON_MASTER_VERSION_ZERO, replicaType == Replica.Type.TLOG);\n    // always download the tlogs from the leader when running with cdcr enabled. We need to have all the tlogs\n    // to ensure leader failover doesn't cause missing docs on the target\n    if (core.getUpdateHandler().getUpdateLog() != null\n        && core.getUpdateHandler().getUpdateLog() instanceof CdcrUpdateLog) {\n      solrParams.set(ReplicationHandler.TLOG_FILES, true);\n    }\n\n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false).getSuccessful();\n\n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n\n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          log.debug(core.getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.count(new MatchAllDocsQuery())\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (core.getDeletionPolicy().getLatestCommit() != null ? \"null\"\n                  : core.getDeletionPolicy().getLatestCommit().getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        log.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","bugFix":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad4957cde742defe6db19689abdc267c5d948066","date":1587990850,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","sourceNew":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n\n    log.info(\"Attempting to replicate from [{}].\", leaderUrl);\n\n    // send commit\n    commitOnLeader(leaderUrl);\n\n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n\n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n\n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    solrParams.set(ReplicationHandler.SKIP_COMMIT_ON_MASTER_VERSION_ZERO, replicaType == Replica.Type.TLOG);\n    // always download the tlogs from the leader when running with cdcr enabled. We need to have all the tlogs\n    // to ensure leader failover doesn't cause missing docs on the target\n    if (core.getUpdateHandler().getUpdateLog() != null\n        && core.getUpdateHandler().getUpdateLog() instanceof CdcrUpdateLog) {\n      solrParams.set(ReplicationHandler.TLOG_FILES, true);\n    }\n\n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false).getSuccessful();\n\n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n\n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          final IndexCommit commit = core.getDeletionPolicy().getLatestCommit();\n          if (log.isDebugEnabled()) {\n            log.debug(\"{} replicated {} from {} gen: {} data: {} index: {} newIndex: {} files: {}\"\n                , core.getCoreContainer().getZkController().getNodeName()\n                , searcher.count(new MatchAllDocsQuery())\n                , leaderUrl\n                , (null == commit ? \"null\" : commit.getGeneration())\n                , core.getDataDir()\n                , core.getIndexDir()\n                , core.getNewIndexDir()\n                , Arrays.asList(dir.listAll()));\n          }\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        log.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","sourceOld":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n\n    log.info(\"Attempting to replicate from [{}].\", leaderUrl);\n\n    // send commit\n    commitOnLeader(leaderUrl);\n\n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n\n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n\n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    solrParams.set(ReplicationHandler.SKIP_COMMIT_ON_MASTER_VERSION_ZERO, replicaType == Replica.Type.TLOG);\n    // always download the tlogs from the leader when running with cdcr enabled. We need to have all the tlogs\n    // to ensure leader failover doesn't cause missing docs on the target\n    if (core.getUpdateHandler().getUpdateLog() != null\n        && core.getUpdateHandler().getUpdateLog() instanceof CdcrUpdateLog) {\n      solrParams.set(ReplicationHandler.TLOG_FILES, true);\n    }\n\n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false).getSuccessful();\n\n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n\n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          final IndexCommit commit = core.getDeletionPolicy().getLatestCommit();\n          log.debug(core.getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replicated \"\n              + searcher.count(new MatchAllDocsQuery())\n              + \" from \"\n              + leaderUrl\n              + \" gen:\"\n              + (null == commit ? \"null\" : commit.getGeneration())\n              + \" data:\" + core.getDataDir()\n              + \" index:\" + core.getIndexDir()\n              + \" newIndex:\" + core.getNewIndexDir()\n              + \" files:\" + Arrays.asList(dir.listAll()));\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        log.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"65a5d87a40f9143cd55be76eb1dde1b32a8dae5e","date":1596664368,"type":3,"author":"Marcus","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","sourceNew":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n\n    log.info(\"Attempting to replicate from [{}].\", leaderUrl);\n\n    // send commit\n    commitOnLeader(leaderUrl);\n\n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n\n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n\n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.LEADER_URL, leaderUrl);\n    solrParams.set(ReplicationHandler.SKIP_COMMIT_ON_LEADER_VERSION_ZERO, replicaType == Replica.Type.TLOG);\n    // always download the tlogs from the leader when running with cdcr enabled. We need to have all the tlogs\n    // to ensure leader failover doesn't cause missing docs on the target\n    if (core.getUpdateHandler().getUpdateLog() != null\n        && core.getUpdateHandler().getUpdateLog() instanceof CdcrUpdateLog) {\n      solrParams.set(ReplicationHandler.TLOG_FILES, true);\n    }\n\n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false).getSuccessful();\n\n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n\n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          final IndexCommit commit = core.getDeletionPolicy().getLatestCommit();\n          if (log.isDebugEnabled()) {\n            log.debug(\"{} replicated {} from {} gen: {} data: {} index: {} newIndex: {} files: {}\"\n                , core.getCoreContainer().getZkController().getNodeName()\n                , searcher.count(new MatchAllDocsQuery())\n                , leaderUrl\n                , (null == commit ? \"null\" : commit.getGeneration())\n                , core.getDataDir()\n                , core.getIndexDir()\n                , core.getNewIndexDir()\n                , Arrays.asList(dir.listAll()));\n          }\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        log.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","sourceOld":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n\n    log.info(\"Attempting to replicate from [{}].\", leaderUrl);\n\n    // send commit\n    commitOnLeader(leaderUrl);\n\n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n\n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n\n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n    solrParams.set(ReplicationHandler.SKIP_COMMIT_ON_MASTER_VERSION_ZERO, replicaType == Replica.Type.TLOG);\n    // always download the tlogs from the leader when running with cdcr enabled. We need to have all the tlogs\n    // to ensure leader failover doesn't cause missing docs on the target\n    if (core.getUpdateHandler().getUpdateLog() != null\n        && core.getUpdateHandler().getUpdateLog() instanceof CdcrUpdateLog) {\n      solrParams.set(ReplicationHandler.TLOG_FILES, true);\n    }\n\n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false).getSuccessful();\n\n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n\n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          final IndexCommit commit = core.getDeletionPolicy().getLatestCommit();\n          if (log.isDebugEnabled()) {\n            log.debug(\"{} replicated {} from {} gen: {} data: {} index: {} newIndex: {} files: {}\"\n                , core.getCoreContainer().getZkController().getNodeName()\n                , searcher.count(new MatchAllDocsQuery())\n                , leaderUrl\n                , (null == commit ? \"null\" : commit.getGeneration())\n                , core.getDataDir()\n                , core.getIndexDir()\n                , core.getNewIndexDir()\n                , Arrays.asList(dir.listAll()));\n          }\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        log.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"23ec6d2969d61cadbfd0a5452e9be1f9999e8aa1","date":1598647393,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replicate(String,SolrCore,ZkNodeProps).mjava","sourceNew":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n\n    log.info(\"Attempting to replicate from [{}].\", leaderUrl);\n\n    // send commit\n    commitOnLeader(leaderUrl);\n\n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n\n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n\n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.LEADER_URL, leaderUrl);\n    solrParams.set(ReplicationHandler.SKIP_COMMIT_ON_LEADER_VERSION_ZERO, replicaType == Replica.Type.TLOG);\n\n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false).getSuccessful();\n\n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n\n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          final IndexCommit commit = core.getDeletionPolicy().getLatestCommit();\n          if (log.isDebugEnabled()) {\n            log.debug(\"{} replicated {} from {} gen: {} data: {} index: {} newIndex: {} files: {}\"\n                , core.getCoreContainer().getZkController().getNodeName()\n                , searcher.count(new MatchAllDocsQuery())\n                , leaderUrl\n                , (null == commit ? \"null\" : commit.getGeneration())\n                , core.getDataDir()\n                , core.getIndexDir()\n                , core.getNewIndexDir()\n                , Arrays.asList(dir.listAll()));\n          }\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        log.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","sourceOld":"  final private void replicate(String nodeName, SolrCore core, ZkNodeProps leaderprops)\n      throws SolrServerException, IOException {\n\n    final String leaderUrl = getReplicateLeaderUrl(leaderprops);\n\n    log.info(\"Attempting to replicate from [{}].\", leaderUrl);\n\n    // send commit\n    commitOnLeader(leaderUrl);\n\n    // use rep handler directly, so we can do this sync rather than async\n    SolrRequestHandler handler = core.getRequestHandler(ReplicationHandler.PATH);\n    ReplicationHandler replicationHandler = (ReplicationHandler) handler;\n\n    if (replicationHandler == null) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Skipping recovery, no \" + ReplicationHandler.PATH + \" handler found\");\n    }\n\n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.set(ReplicationHandler.LEADER_URL, leaderUrl);\n    solrParams.set(ReplicationHandler.SKIP_COMMIT_ON_LEADER_VERSION_ZERO, replicaType == Replica.Type.TLOG);\n    // always download the tlogs from the leader when running with cdcr enabled. We need to have all the tlogs\n    // to ensure leader failover doesn't cause missing docs on the target\n    if (core.getUpdateHandler().getUpdateLog() != null\n        && core.getUpdateHandler().getUpdateLog() instanceof CdcrUpdateLog) {\n      solrParams.set(ReplicationHandler.TLOG_FILES, true);\n    }\n\n    if (isClosed()) return; // we check closed on return\n    boolean success = replicationHandler.doFetch(solrParams, false).getSuccessful();\n\n    if (!success) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\n    }\n\n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        Directory dir = core.getDirectoryFactory().get(core.getIndexDir(), DirContext.META_DATA, null);\n        try {\n          final IndexCommit commit = core.getDeletionPolicy().getLatestCommit();\n          if (log.isDebugEnabled()) {\n            log.debug(\"{} replicated {} from {} gen: {} data: {} index: {} newIndex: {} files: {}\"\n                , core.getCoreContainer().getZkController().getNodeName()\n                , searcher.count(new MatchAllDocsQuery())\n                , leaderUrl\n                , (null == commit ? \"null\" : commit.getGeneration())\n                , core.getDataDir()\n                , core.getIndexDir()\n                , core.getNewIndexDir()\n                , Arrays.asList(dir.listAll()));\n          }\n        } finally {\n          core.getDirectoryFactory().release(dir);\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        log.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"04ecf884544ff74add5faa452748f160c4af904b":["28288370235ed02234a64753cdbf0c6ec096304a"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["d5f6959c652bdf332fe98fc9180b54095a4053ae"],"610f5499a87a7113d53e5b621b616890f002e9f1":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"89b56ee224dbe29ee4436d91a7070ca418ffc4fb":["c52ad29218ee436d52c57bf0829b98acad9de379"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","71f14bcc8e12885ab59981c9fdecebb7c2ef3ca0"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"6c94d2661bc1c14426980ec7882e951fdcff08d0":["9aea0485ecacb6734c17da2d02569816c23a69c1"],"f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6":["729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"ad4957cde742defe6db19689abdc267c5d948066":["19f02bb04467ed179738a398a7da80bbbe161c16"],"e8fa677b7b2405d2c2b902646dbae8f5fe34b60e":["190779ba7de3fda15afd1bbafbc383720a4b0966"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["6c94d2661bc1c14426980ec7882e951fdcff08d0"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["e8fa677b7b2405d2c2b902646dbae8f5fe34b60e","6c94d2661bc1c14426980ec7882e951fdcff08d0"],"19f02bb04467ed179738a398a7da80bbbe161c16":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["71475d88ea48a7d9a847f209667255318b3ea4c7","a5d615d62cd8aff3690943d765e46942551f98b6"],"190779ba7de3fda15afd1bbafbc383720a4b0966":["89b56ee224dbe29ee4436d91a7070ca418ffc4fb"],"9aea0485ecacb6734c17da2d02569816c23a69c1":["e8fa677b7b2405d2c2b902646dbae8f5fe34b60e"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["9767eba84e83b05b2a675421e190f4a4c15dad44"],"9767eba84e83b05b2a675421e190f4a4c15dad44":["04ecf884544ff74add5faa452748f160c4af904b"],"65a5d87a40f9143cd55be76eb1dde1b32a8dae5e":["ad4957cde742defe6db19689abdc267c5d948066"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["7c641347aa34a81b8c172fd46691e3cba6357a6f"],"28288370235ed02234a64753cdbf0c6ec096304a":["729cb470f975115d4c60517b2cb7c42e37a7a2e1","f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["71475d88ea48a7d9a847f209667255318b3ea4c7","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"7c641347aa34a81b8c172fd46691e3cba6357a6f":["7392b75d2c2f2aecf31188732a0764fe0dc74ade"],"a5d615d62cd8aff3690943d765e46942551f98b6":["71475d88ea48a7d9a847f209667255318b3ea4c7"],"71f14bcc8e12885ab59981c9fdecebb7c2ef3ca0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6240b74b884c5587f2a4062dd27d6c32bf228889":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","04ecf884544ff74add5faa452748f160c4af904b"],"d5f6959c652bdf332fe98fc9180b54095a4053ae":["7392b75d2c2f2aecf31188732a0764fe0dc74ade"],"c52ad29218ee436d52c57bf0829b98acad9de379":["71f14bcc8e12885ab59981c9fdecebb7c2ef3ca0"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["89b56ee224dbe29ee4436d91a7070ca418ffc4fb","190779ba7de3fda15afd1bbafbc383720a4b0966"],"23ec6d2969d61cadbfd0a5452e9be1f9999e8aa1":["65a5d87a40f9143cd55be76eb1dde1b32a8dae5e"],"7392b75d2c2f2aecf31188732a0764fe0dc74ade":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"71475d88ea48a7d9a847f209667255318b3ea4c7":["610f5499a87a7113d53e5b621b616890f002e9f1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["23ec6d2969d61cadbfd0a5452e9be1f9999e8aa1"]},"commit2Childs":{"04ecf884544ff74add5faa452748f160c4af904b":["9767eba84e83b05b2a675421e190f4a4c15dad44","6240b74b884c5587f2a4062dd27d6c32bf228889"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1"],"610f5499a87a7113d53e5b621b616890f002e9f1":["71475d88ea48a7d9a847f209667255318b3ea4c7"],"89b56ee224dbe29ee4436d91a7070ca418ffc4fb":["190779ba7de3fda15afd1bbafbc383720a4b0966","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["19f02bb04467ed179738a398a7da80bbbe161c16"],"6c94d2661bc1c14426980ec7882e951fdcff08d0":["439c63ae5d22132fca810a0029a854e97d2c1a3e","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"ad4957cde742defe6db19689abdc267c5d948066":["65a5d87a40f9143cd55be76eb1dde1b32a8dae5e"],"e8fa677b7b2405d2c2b902646dbae8f5fe34b60e":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","9aea0485ecacb6734c17da2d02569816c23a69c1"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["610f5499a87a7113d53e5b621b616890f002e9f1"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"19f02bb04467ed179738a398a7da80bbbe161c16":["ad4957cde742defe6db19689abdc267c5d948066"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["37a0f60745e53927c4c876cfe5b5a58170f0646c","71f14bcc8e12885ab59981c9fdecebb7c2ef3ca0"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","7392b75d2c2f2aecf31188732a0764fe0dc74ade"],"190779ba7de3fda15afd1bbafbc383720a4b0966":["e8fa677b7b2405d2c2b902646dbae8f5fe34b60e","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"9aea0485ecacb6734c17da2d02569816c23a69c1":["6c94d2661bc1c14426980ec7882e951fdcff08d0"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"9767eba84e83b05b2a675421e190f4a4c15dad44":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"65a5d87a40f9143cd55be76eb1dde1b32a8dae5e":["23ec6d2969d61cadbfd0a5452e9be1f9999e8aa1"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["6240b74b884c5587f2a4062dd27d6c32bf228889"],"28288370235ed02234a64753cdbf0c6ec096304a":["04ecf884544ff74add5faa452748f160c4af904b"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6","28288370235ed02234a64753cdbf0c6ec096304a"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"a5d615d62cd8aff3690943d765e46942551f98b6":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"7c641347aa34a81b8c172fd46691e3cba6357a6f":["729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"71f14bcc8e12885ab59981c9fdecebb7c2ef3ca0":["37a0f60745e53927c4c876cfe5b5a58170f0646c","c52ad29218ee436d52c57bf0829b98acad9de379"],"6240b74b884c5587f2a4062dd27d6c32bf228889":[],"d5f6959c652bdf332fe98fc9180b54095a4053ae":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb"],"c52ad29218ee436d52c57bf0829b98acad9de379":["89b56ee224dbe29ee4436d91a7070ca418ffc4fb"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"7392b75d2c2f2aecf31188732a0764fe0dc74ade":["7c641347aa34a81b8c172fd46691e3cba6357a6f","d5f6959c652bdf332fe98fc9180b54095a4053ae"],"23ec6d2969d61cadbfd0a5452e9be1f9999e8aa1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"71475d88ea48a7d9a847f209667255318b3ea4c7":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a5d615d62cd8aff3690943d765e46942551f98b6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","6240b74b884c5587f2a4062dd27d6c32bf228889","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}