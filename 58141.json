{"path":"lucene/tools/src/java/org/apache/lucene/validation/LibVersionsCheckTask#readLogicalPropertiesLine(BufferedReader).mjava","commits":[{"id":"f36164b70e3e1719b71a2bd8e1ab09d551d6ada1","date":1380909825,"type":0,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/LibVersionsCheckTask#readLogicalPropertiesLine(BufferedReader).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Builds up logical {@link java.util.Properties} lines, composed of one non-blank,\n   * non-comment initial line, either:\n   * \n   * 1. without a non-escaped trailing slash; or\n   * 2. with a non-escaped trailing slash, followed by\n   *    zero or more lines with a non-escaped trailing slash, followed by\n   *    one or more lines without a non-escaped trailing slash\n   *\n   * All leading non-escaped whitespace and trailing non-escaped whitespace +\n   * non-escaped slash are trimmed from each line before concatenating.\n   * \n   * After composing the logical line, escaped characters are un-escaped.\n   * \n   * null is returned if there are no lines left to read. \n   */\n  private String readLogicalPropertiesLine(BufferedReader reader) throws IOException {\n    final StringBuilder logicalLine = new StringBuilder();\n    String line;\n    do {\n      line = reader.readLine();\n      if (null == line) { \n        return null;\n      }\n    } while (BLANK_OR_COMMENT_LINE_PATTERN.matcher(line).matches());\n\n    Matcher backslashMatcher = TRAILING_BACKSLASH_PATTERN.matcher(line); \n    // Check for a non-escaped backslash\n    if (backslashMatcher.find() && 1 == (backslashMatcher.group(1).length() % 2)) {\n      final Matcher firstLineMatcher = TRAILING_WHITESPACE_BACKSLASH_PATTERN.matcher(line);\n      if (firstLineMatcher.matches()) {\n        logicalLine.append(firstLineMatcher.group(1)); // trim trailing backslash and any preceding whitespace\n      }\n      line = reader.readLine();\n      while (null != line\n             && (backslashMatcher = TRAILING_BACKSLASH_PATTERN.matcher(line)).find()\n             && 1 == (backslashMatcher.group(1).length() % 2)) {\n        // Trim leading whitespace, the trailing backslash and any preceding whitespace\n        final Matcher goodStuffMatcher = WHITESPACE_GOODSTUFF_WHITESPACE_BACKSLASH_PATTERN.matcher(line);\n        if (goodStuffMatcher.matches()) {\n          logicalLine.append(goodStuffMatcher.group(1));\n        }\n        line = reader.readLine();\n      }\n      if (null != line) {\n        // line can't have a non-escaped trailing backslash\n        final Matcher leadingWhitespaceMatcher = LEADING_WHITESPACE_PATTERN.matcher(line);\n        if (leadingWhitespaceMatcher.matches()) {\n          line = leadingWhitespaceMatcher.group(1); // trim leading whitespace\n        }\n        logicalLine.append(line);\n      }\n    } else {\n      logicalLine.append(line);\n    }\n    // trim non-escaped leading whitespace\n    final Matcher leadingWhitespaceMatcher = LEADING_WHITESPACE_PATTERN.matcher(logicalLine);\n    final CharSequence leadingWhitespaceStripped = leadingWhitespaceMatcher.matches()\n                                                 ? leadingWhitespaceMatcher.group(1)\n                                                 : logicalLine;\n\n    // unescape all chars in the logical line\n    StringBuilder output = new StringBuilder();\n    final int numChars = leadingWhitespaceStripped.length();\n    for (int pos = 0 ; pos < numChars - 1 ; ++pos) {\n      char ch = leadingWhitespaceStripped.charAt(pos);\n      if (ch == '\\\\') {\n        ch = leadingWhitespaceStripped.charAt(++pos); \n      }\n      output.append(ch);\n    }\n    if (numChars > 0) {\n      output.append(leadingWhitespaceStripped.charAt(numChars - 1));\n    }\n\n    return output.toString();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b3e4bd3aed493904d0bbb6c6e0394f619e175087","date":1401446035,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/LibVersionsCheckTask#readLogicalPropertiesLine(BufferedReader).mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/LibVersionsCheckTask#readLogicalPropertiesLine(BufferedReader).mjava","sourceNew":"  /**\n   * Builds up logical {@link java.util.Properties} lines, composed of one non-blank,\n   * non-comment initial line, either:\n   * \n   * 1. without a non-escaped trailing slash; or\n   * 2. with a non-escaped trailing slash, followed by\n   *    zero or more lines with a non-escaped trailing slash, followed by\n   *    one or more lines without a non-escaped trailing slash\n   *\n   * All leading non-escaped whitespace and trailing non-escaped whitespace +\n   * non-escaped slash are trimmed from each line before concatenating.\n   * \n   * After composing the logical line, escaped characters are un-escaped.\n   * \n   * null is returned if there are no lines left to read. \n   */\n  private String readLogicalPropertiesLine(BufferedReader reader) throws IOException {\n    final StringBuilder logicalLine = new StringBuilder();\n    String line;\n    do {\n      line = reader.readLine();\n      if (null == line) { \n        return null;\n      }\n    } while (BLANK_OR_COMMENT_LINE_PATTERN.matcher(line).matches());\n\n    Matcher backslashMatcher = TRAILING_BACKSLASH_PATTERN.matcher(line); \n    // Check for a non-escaped backslash\n    if (backslashMatcher.find() && 1 == (backslashMatcher.group(1).length() % 2)) {\n      final Matcher firstLineMatcher = TRAILING_WHITESPACE_BACKSLASH_PATTERN.matcher(line);\n      if (firstLineMatcher.matches()) {\n        logicalLine.append(firstLineMatcher.group(1)); // trim trailing backslash and any preceding whitespace\n      }\n      line = reader.readLine();\n      while (null != line\n             && (backslashMatcher = TRAILING_BACKSLASH_PATTERN.matcher(line)).find()\n             && 1 == (backslashMatcher.group(1).length() % 2)) {\n        // Trim leading whitespace, the trailing backslash and any preceding whitespace\n        final Matcher goodStuffMatcher = WHITESPACE_GOODSTUFF_WHITESPACE_BACKSLASH_PATTERN.matcher(line);\n        if (goodStuffMatcher.matches()) {\n          logicalLine.append(goodStuffMatcher.group(1));\n        }\n        line = reader.readLine();\n      }\n      if (null != line) {\n        // line can't have a non-escaped trailing backslash\n        final Matcher leadingWhitespaceMatcher = LEADING_WHITESPACE_PATTERN.matcher(line);\n        if (leadingWhitespaceMatcher.matches()) {\n          line = leadingWhitespaceMatcher.group(1); // trim leading whitespace\n        }\n        logicalLine.append(line);\n      }\n    } else {\n      logicalLine.append(line);\n    }\n    // trim non-escaped leading whitespace\n    final Matcher leadingWhitespaceMatcher = LEADING_WHITESPACE_PATTERN.matcher(logicalLine);\n    final CharSequence leadingWhitespaceStripped = leadingWhitespaceMatcher.matches()\n                                                 ? leadingWhitespaceMatcher.group(1)\n                                                 : logicalLine;\n\n    // unescape all chars in the logical line\n    StringBuilder output = new StringBuilder();\n    final int numChars = leadingWhitespaceStripped.length();\n    for (int pos = 0 ; pos < numChars - 1 ; ++pos) {\n      char ch = leadingWhitespaceStripped.charAt(pos);\n      if (ch == '\\\\') {\n        ch = leadingWhitespaceStripped.charAt(++pos);\n      }\n      output.append(ch);\n    }\n    if (numChars > 0) {\n      output.append(leadingWhitespaceStripped.charAt(numChars - 1));\n    }\n\n    return output.toString();\n  }\n\n","sourceOld":"  /**\n   * Builds up logical {@link java.util.Properties} lines, composed of one non-blank,\n   * non-comment initial line, either:\n   * \n   * 1. without a non-escaped trailing slash; or\n   * 2. with a non-escaped trailing slash, followed by\n   *    zero or more lines with a non-escaped trailing slash, followed by\n   *    one or more lines without a non-escaped trailing slash\n   *\n   * All leading non-escaped whitespace and trailing non-escaped whitespace +\n   * non-escaped slash are trimmed from each line before concatenating.\n   * \n   * After composing the logical line, escaped characters are un-escaped.\n   * \n   * null is returned if there are no lines left to read. \n   */\n  private String readLogicalPropertiesLine(BufferedReader reader) throws IOException {\n    final StringBuilder logicalLine = new StringBuilder();\n    String line;\n    do {\n      line = reader.readLine();\n      if (null == line) { \n        return null;\n      }\n    } while (BLANK_OR_COMMENT_LINE_PATTERN.matcher(line).matches());\n\n    Matcher backslashMatcher = TRAILING_BACKSLASH_PATTERN.matcher(line); \n    // Check for a non-escaped backslash\n    if (backslashMatcher.find() && 1 == (backslashMatcher.group(1).length() % 2)) {\n      final Matcher firstLineMatcher = TRAILING_WHITESPACE_BACKSLASH_PATTERN.matcher(line);\n      if (firstLineMatcher.matches()) {\n        logicalLine.append(firstLineMatcher.group(1)); // trim trailing backslash and any preceding whitespace\n      }\n      line = reader.readLine();\n      while (null != line\n             && (backslashMatcher = TRAILING_BACKSLASH_PATTERN.matcher(line)).find()\n             && 1 == (backslashMatcher.group(1).length() % 2)) {\n        // Trim leading whitespace, the trailing backslash and any preceding whitespace\n        final Matcher goodStuffMatcher = WHITESPACE_GOODSTUFF_WHITESPACE_BACKSLASH_PATTERN.matcher(line);\n        if (goodStuffMatcher.matches()) {\n          logicalLine.append(goodStuffMatcher.group(1));\n        }\n        line = reader.readLine();\n      }\n      if (null != line) {\n        // line can't have a non-escaped trailing backslash\n        final Matcher leadingWhitespaceMatcher = LEADING_WHITESPACE_PATTERN.matcher(line);\n        if (leadingWhitespaceMatcher.matches()) {\n          line = leadingWhitespaceMatcher.group(1); // trim leading whitespace\n        }\n        logicalLine.append(line);\n      }\n    } else {\n      logicalLine.append(line);\n    }\n    // trim non-escaped leading whitespace\n    final Matcher leadingWhitespaceMatcher = LEADING_WHITESPACE_PATTERN.matcher(logicalLine);\n    final CharSequence leadingWhitespaceStripped = leadingWhitespaceMatcher.matches()\n                                                 ? leadingWhitespaceMatcher.group(1)\n                                                 : logicalLine;\n\n    // unescape all chars in the logical line\n    StringBuilder output = new StringBuilder();\n    final int numChars = leadingWhitespaceStripped.length();\n    for (int pos = 0 ; pos < numChars - 1 ; ++pos) {\n      char ch = leadingWhitespaceStripped.charAt(pos);\n      if (ch == '\\\\') {\n        ch = leadingWhitespaceStripped.charAt(++pos); \n      }\n      output.append(ch);\n    }\n    if (numChars > 0) {\n      output.append(leadingWhitespaceStripped.charAt(numChars - 1));\n    }\n\n    return output.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e025cf1c07150c8db28879d785db17eb3a66ca9f","date":1598788864,"type":4,"author":"Dawid Weiss","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/LibVersionsCheckTask#readLogicalPropertiesLine(BufferedReader).mjava","sourceNew":null,"sourceOld":"  /**\n   * Builds up logical {@link java.util.Properties} lines, composed of one non-blank,\n   * non-comment initial line, either:\n   * \n   * 1. without a non-escaped trailing slash; or\n   * 2. with a non-escaped trailing slash, followed by\n   *    zero or more lines with a non-escaped trailing slash, followed by\n   *    one or more lines without a non-escaped trailing slash\n   *\n   * All leading non-escaped whitespace and trailing non-escaped whitespace +\n   * non-escaped slash are trimmed from each line before concatenating.\n   * \n   * After composing the logical line, escaped characters are un-escaped.\n   * \n   * null is returned if there are no lines left to read. \n   */\n  private String readLogicalPropertiesLine(BufferedReader reader) throws IOException {\n    final StringBuilder logicalLine = new StringBuilder();\n    String line;\n    do {\n      line = reader.readLine();\n      if (null == line) { \n        return null;\n      }\n    } while (BLANK_OR_COMMENT_LINE_PATTERN.matcher(line).matches());\n\n    Matcher backslashMatcher = TRAILING_BACKSLASH_PATTERN.matcher(line); \n    // Check for a non-escaped backslash\n    if (backslashMatcher.find() && 1 == (backslashMatcher.group(1).length() % 2)) {\n      final Matcher firstLineMatcher = TRAILING_WHITESPACE_BACKSLASH_PATTERN.matcher(line);\n      if (firstLineMatcher.matches()) {\n        logicalLine.append(firstLineMatcher.group(1)); // trim trailing backslash and any preceding whitespace\n      }\n      line = reader.readLine();\n      while (null != line\n             && (backslashMatcher = TRAILING_BACKSLASH_PATTERN.matcher(line)).find()\n             && 1 == (backslashMatcher.group(1).length() % 2)) {\n        // Trim leading whitespace, the trailing backslash and any preceding whitespace\n        final Matcher goodStuffMatcher = WHITESPACE_GOODSTUFF_WHITESPACE_BACKSLASH_PATTERN.matcher(line);\n        if (goodStuffMatcher.matches()) {\n          logicalLine.append(goodStuffMatcher.group(1));\n        }\n        line = reader.readLine();\n      }\n      if (null != line) {\n        // line can't have a non-escaped trailing backslash\n        final Matcher leadingWhitespaceMatcher = LEADING_WHITESPACE_PATTERN.matcher(line);\n        if (leadingWhitespaceMatcher.matches()) {\n          line = leadingWhitespaceMatcher.group(1); // trim leading whitespace\n        }\n        logicalLine.append(line);\n      }\n    } else {\n      logicalLine.append(line);\n    }\n    // trim non-escaped leading whitespace\n    final Matcher leadingWhitespaceMatcher = LEADING_WHITESPACE_PATTERN.matcher(logicalLine);\n    final CharSequence leadingWhitespaceStripped = leadingWhitespaceMatcher.matches()\n                                                 ? leadingWhitespaceMatcher.group(1)\n                                                 : logicalLine;\n\n    // unescape all chars in the logical line\n    StringBuilder output = new StringBuilder();\n    final int numChars = leadingWhitespaceStripped.length();\n    for (int pos = 0 ; pos < numChars - 1 ; ++pos) {\n      char ch = leadingWhitespaceStripped.charAt(pos);\n      if (ch == '\\\\') {\n        ch = leadingWhitespaceStripped.charAt(++pos);\n      }\n      output.append(ch);\n    }\n    if (numChars > 0) {\n      output.append(leadingWhitespaceStripped.charAt(numChars - 1));\n    }\n\n    return output.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f36164b70e3e1719b71a2bd8e1ab09d551d6ada1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e025cf1c07150c8db28879d785db17eb3a66ca9f":["b3e4bd3aed493904d0bbb6c6e0394f619e175087"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b3e4bd3aed493904d0bbb6c6e0394f619e175087":["f36164b70e3e1719b71a2bd8e1ab09d551d6ada1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e025cf1c07150c8db28879d785db17eb3a66ca9f"]},"commit2Childs":{"f36164b70e3e1719b71a2bd8e1ab09d551d6ada1":["b3e4bd3aed493904d0bbb6c6e0394f619e175087"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f36164b70e3e1719b71a2bd8e1ab09d551d6ada1"],"e025cf1c07150c8db28879d785db17eb3a66ca9f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b3e4bd3aed493904d0bbb6c6e0394f619e175087":["e025cf1c07150c8db28879d785db17eb3a66ca9f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}