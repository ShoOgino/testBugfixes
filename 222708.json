{"path":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testLRUConcurrentCachingAcrossSegments().mjava","commits":[{"id":"1fbdd90cd58912788fecb1044df8f566a4420e59","date":1574749923,"type":0,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testLRUConcurrentCachingAcrossSegments().mjava","pathOld":"/dev/null","sourceNew":"  public void testLRUConcurrentCachingAcrossSegments() throws Exception {\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    int numDocs = atLeast(150);\n    int numIterations = atLeast(3);\n\n    for (int i = 0; i < numIterations; i++) {\n      for (int j = 0; j < numDocs; j++) {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"blue\", Store.NO);\n        doc.add(f);\n        w.addDocument(doc);\n        w.addDocument(doc);\n        w.addDocument(doc);\n      }\n      w.commit();\n    }\n\n    final DirectoryReader reader = w.getReader();\n\n    ExecutorService service = new ThreadPoolExecutor(4, 4, 0L, TimeUnit.MILLISECONDS,\n        new LinkedBlockingQueue<Runnable>(),\n        new NamedThreadFactory(\"TestLRUQueryCache\"));\n\n    IndexSearcher searcher = new IndexSearcher(reader, service) {\n      @Override\n      protected LeafSlice[] slices(List<LeafReaderContext> leaves) {\n        ArrayList<LeafSlice> slices = new ArrayList<>();\n        for (LeafReaderContext ctx : leaves) {\n          slices.add(new LeafSlice(Arrays.asList(ctx)));\n        }\n        return slices.toArray(new LeafSlice[0]);\n      }\n    };\n\n    final LRUQueryCache queryCache = new LRUQueryCache(2, 100000, context -> true, Float.POSITIVE_INFINITY);\n\n    final Query blue = new TermQuery(new Term(\"color\", \"blue\"));\n\n    assertEquals(Collections.emptyList(), queryCache.cachedQueries());\n\n    searcher.setQueryCache(queryCache);\n    searcher.setQueryCachingPolicy(ALWAYS_CACHE);\n    assert searcher.getSlices().length > 1;\n\n    searcher.search(new ConstantScoreQuery(blue), 1);\n\n    reader.close();\n    w.close();\n    dir.close();\n    service.shutdown();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56843061f1c237afb1f2a37e65a4a5538999a9a3","date":1574914341,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testLRUConcurrentCachingAcrossSegments().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testLRUConcurrentCachingAcrossSegments().mjava","sourceNew":"  public void testLRUConcurrentCachingAcrossSegments() throws Exception {\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    int numDocs = atLeast(150);\n    int numIterations = atLeast(3);\n\n    for (int i = 0; i < numIterations; i++) {\n      for (int j = 0; j < numDocs; j++) {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"blue\", Store.NO);\n        doc.add(f);\n        w.addDocument(doc);\n        w.addDocument(doc);\n        w.addDocument(doc);\n      }\n      w.commit();\n    }\n\n    final DirectoryReader reader = w.getReader();\n\n    ExecutorService service = new ThreadPoolExecutor(4, 4, 0L, TimeUnit.MILLISECONDS,\n        new LinkedBlockingQueue<Runnable>(),\n        new NamedThreadFactory(\"TestLRUQueryCache\"));\n\n    IndexSearcher searcher = new IndexSearcher(reader, service) {\n      @Override\n      protected LeafSlice[] slices(List<LeafReaderContext> leaves) {\n        ArrayList<LeafSlice> slices = new ArrayList<>();\n        for (LeafReaderContext ctx : leaves) {\n          slices.add(new LeafSlice(Arrays.asList(ctx)));\n        }\n        return slices.toArray(new LeafSlice[0]);\n      }\n    };\n\n    final LRUQueryCache queryCache = new LRUQueryCache(2, 100000, context -> true, Float.POSITIVE_INFINITY);\n\n    final Query blue = new TermQuery(new Term(\"color\", \"blue\"));\n\n    assertEquals(Collections.emptyList(), queryCache.cachedQueries());\n\n    searcher.setQueryCache(queryCache);\n    searcher.setQueryCachingPolicy(ALWAYS_CACHE);\n\n    searcher.search(new ConstantScoreQuery(blue), 1);\n\n    reader.close();\n    w.close();\n    dir.close();\n    service.shutdown();\n  }\n\n","sourceOld":"  public void testLRUConcurrentCachingAcrossSegments() throws Exception {\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    int numDocs = atLeast(150);\n    int numIterations = atLeast(3);\n\n    for (int i = 0; i < numIterations; i++) {\n      for (int j = 0; j < numDocs; j++) {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"blue\", Store.NO);\n        doc.add(f);\n        w.addDocument(doc);\n        w.addDocument(doc);\n        w.addDocument(doc);\n      }\n      w.commit();\n    }\n\n    final DirectoryReader reader = w.getReader();\n\n    ExecutorService service = new ThreadPoolExecutor(4, 4, 0L, TimeUnit.MILLISECONDS,\n        new LinkedBlockingQueue<Runnable>(),\n        new NamedThreadFactory(\"TestLRUQueryCache\"));\n\n    IndexSearcher searcher = new IndexSearcher(reader, service) {\n      @Override\n      protected LeafSlice[] slices(List<LeafReaderContext> leaves) {\n        ArrayList<LeafSlice> slices = new ArrayList<>();\n        for (LeafReaderContext ctx : leaves) {\n          slices.add(new LeafSlice(Arrays.asList(ctx)));\n        }\n        return slices.toArray(new LeafSlice[0]);\n      }\n    };\n\n    final LRUQueryCache queryCache = new LRUQueryCache(2, 100000, context -> true, Float.POSITIVE_INFINITY);\n\n    final Query blue = new TermQuery(new Term(\"color\", \"blue\"));\n\n    assertEquals(Collections.emptyList(), queryCache.cachedQueries());\n\n    searcher.setQueryCache(queryCache);\n    searcher.setQueryCachingPolicy(ALWAYS_CACHE);\n    assert searcher.getSlices().length > 1;\n\n    searcher.search(new ConstantScoreQuery(blue), 1);\n\n    reader.close();\n    w.close();\n    dir.close();\n    service.shutdown();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e27872d5374fa7fb77bca1d07b7af01231170c2","date":1574952318,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testLRUConcurrentCachingAcrossSegments().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testLRUConcurrentCachingAcrossSegments().mjava","sourceNew":"  public void testLRUConcurrentCachingAcrossSegments() throws Exception {\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    int numDocs = atLeast(150);\n    int numIterations = atLeast(3);\n\n    for (int i = 0; i < numIterations; i++) {\n      for (int j = 0; j < numDocs; j++) {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"blue\", Store.NO);\n        doc.add(f);\n        w.addDocument(doc);\n        w.addDocument(doc);\n        w.addDocument(doc);\n      }\n      w.commit();\n    }\n\n    final DirectoryReader reader = w.getReader();\n\n    ExecutorService service = new ThreadPoolExecutor(4, 4, 0L, TimeUnit.MILLISECONDS,\n        new LinkedBlockingQueue<Runnable>(),\n        new NamedThreadFactory(\"TestLRUQueryCache\"));\n\n    IndexSearcher searcher = new IndexSearcher(reader, service) {\n      @Override\n      protected LeafSlice[] slices(List<LeafReaderContext> leaves) {\n        ArrayList<LeafSlice> slices = new ArrayList<>();\n        for (LeafReaderContext ctx : leaves) {\n          slices.add(new LeafSlice(Arrays.asList(ctx)));\n        }\n        return slices.toArray(new LeafSlice[0]);\n      }\n    };\n\n    final LRUQueryCache queryCache = new LRUQueryCache(2, 100000, context -> true, Float.POSITIVE_INFINITY);\n\n    final Query blue = new TermQuery(new Term(\"color\", \"blue\"));\n\n    assertEquals(Collections.emptyList(), queryCache.cachedQueries());\n\n    searcher.setQueryCache(queryCache);\n    searcher.setQueryCachingPolicy(ALWAYS_CACHE);\n    assert searcher.getSlices().length > 1;\n\n    searcher.search(new ConstantScoreQuery(blue), 1);\n\n    reader.close();\n    w.close();\n    dir.close();\n    service.shutdown();\n  }\n\n","sourceOld":"  public void testLRUConcurrentCachingAcrossSegments() throws Exception {\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    int numDocs = atLeast(150);\n    int numIterations = atLeast(3);\n\n    for (int i = 0; i < numIterations; i++) {\n      for (int j = 0; j < numDocs; j++) {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"blue\", Store.NO);\n        doc.add(f);\n        w.addDocument(doc);\n        w.addDocument(doc);\n        w.addDocument(doc);\n      }\n      w.commit();\n    }\n\n    final DirectoryReader reader = w.getReader();\n\n    ExecutorService service = new ThreadPoolExecutor(4, 4, 0L, TimeUnit.MILLISECONDS,\n        new LinkedBlockingQueue<Runnable>(),\n        new NamedThreadFactory(\"TestLRUQueryCache\"));\n\n    IndexSearcher searcher = new IndexSearcher(reader, service) {\n      @Override\n      protected LeafSlice[] slices(List<LeafReaderContext> leaves) {\n        ArrayList<LeafSlice> slices = new ArrayList<>();\n        for (LeafReaderContext ctx : leaves) {\n          slices.add(new LeafSlice(Arrays.asList(ctx)));\n        }\n        return slices.toArray(new LeafSlice[0]);\n      }\n    };\n\n    final LRUQueryCache queryCache = new LRUQueryCache(2, 100000, context -> true, Float.POSITIVE_INFINITY);\n\n    final Query blue = new TermQuery(new Term(\"color\", \"blue\"));\n\n    assertEquals(Collections.emptyList(), queryCache.cachedQueries());\n\n    searcher.setQueryCache(queryCache);\n    searcher.setQueryCachingPolicy(ALWAYS_CACHE);\n\n    searcher.search(new ConstantScoreQuery(blue), 1);\n\n    reader.close();\n    w.close();\n    dir.close();\n    service.shutdown();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9bbc355b3e849ee4a34763155bb78e638d625419","date":1574952532,"type":4,"author":"Atri Sharma","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testLRUConcurrentCachingAcrossSegments().mjava","sourceNew":null,"sourceOld":"  public void testLRUConcurrentCachingAcrossSegments() throws Exception {\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    int numDocs = atLeast(150);\n    int numIterations = atLeast(3);\n\n    for (int i = 0; i < numIterations; i++) {\n      for (int j = 0; j < numDocs; j++) {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"blue\", Store.NO);\n        doc.add(f);\n        w.addDocument(doc);\n        w.addDocument(doc);\n        w.addDocument(doc);\n      }\n      w.commit();\n    }\n\n    final DirectoryReader reader = w.getReader();\n\n    ExecutorService service = new ThreadPoolExecutor(4, 4, 0L, TimeUnit.MILLISECONDS,\n        new LinkedBlockingQueue<Runnable>(),\n        new NamedThreadFactory(\"TestLRUQueryCache\"));\n\n    IndexSearcher searcher = new IndexSearcher(reader, service) {\n      @Override\n      protected LeafSlice[] slices(List<LeafReaderContext> leaves) {\n        ArrayList<LeafSlice> slices = new ArrayList<>();\n        for (LeafReaderContext ctx : leaves) {\n          slices.add(new LeafSlice(Arrays.asList(ctx)));\n        }\n        return slices.toArray(new LeafSlice[0]);\n      }\n    };\n\n    final LRUQueryCache queryCache = new LRUQueryCache(2, 100000, context -> true, Float.POSITIVE_INFINITY);\n\n    final Query blue = new TermQuery(new Term(\"color\", \"blue\"));\n\n    assertEquals(Collections.emptyList(), queryCache.cachedQueries());\n\n    searcher.setQueryCache(queryCache);\n    searcher.setQueryCachingPolicy(ALWAYS_CACHE);\n    assert searcher.getSlices().length > 1;\n\n    searcher.search(new ConstantScoreQuery(blue), 1);\n\n    reader.close();\n    w.close();\n    dir.close();\n    service.shutdown();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1fbdd90cd58912788fecb1044df8f566a4420e59":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1e27872d5374fa7fb77bca1d07b7af01231170c2":["56843061f1c237afb1f2a37e65a4a5538999a9a3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"56843061f1c237afb1f2a37e65a4a5538999a9a3":["1fbdd90cd58912788fecb1044df8f566a4420e59"],"9bbc355b3e849ee4a34763155bb78e638d625419":["1e27872d5374fa7fb77bca1d07b7af01231170c2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9bbc355b3e849ee4a34763155bb78e638d625419"]},"commit2Childs":{"1fbdd90cd58912788fecb1044df8f566a4420e59":["56843061f1c237afb1f2a37e65a4a5538999a9a3"],"1e27872d5374fa7fb77bca1d07b7af01231170c2":["9bbc355b3e849ee4a34763155bb78e638d625419"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1fbdd90cd58912788fecb1044df8f566a4420e59"],"56843061f1c237afb1f2a37e65a4a5538999a9a3":["1e27872d5374fa7fb77bca1d07b7af01231170c2"],"9bbc355b3e849ee4a34763155bb78e638d625419":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}