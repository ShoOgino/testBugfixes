{"path":"solr/solr-ref-guide/tools/BuildNavAndPDFBody.Page#buildPageTreeRecursive(Page,Map[String,Page]).mjava","commits":[{"id":"171df45763ac908e39a8c33b0c742ffb59a1ba53","date":1509039449,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/solr-ref-guide/tools/BuildNavAndPDFBody.Page#buildPageTreeRecursive(Page,Map[String,Page]).mjava","pathOld":"/dev/null","sourceNew":"    /** \n     * Recursively sets {@link #getParent} and populates {@link #kids} from {@link #kidShortnames} \n     * via the <code>allPages</code> Map \n     */\n    public void buildPageTreeRecursive(Page parent, Map<String,Page> allPages) {\n      if (null != parent) {\n        if (null != this.parent) {\n          // as long as we also check (later) that every page has a parent, this check (prior to recusion)\n          // also ensures we never have any loops\n          throw new RuntimeException(file.getName() + \" is listed as the child of (at least) 2 pages: '\" + parent.shortname + \"' and '\" + this.parent.shortname + \"'\");\n        }\n        this.parent = parent;\n      }\n      for (String kidShortname : kidShortnames) {\n        Page kid = allPages.get(kidShortname);\n        if (null == kid) {\n          throw new RuntimeException(\"Unable to locate \" + kidShortname + \"; child of \" + shortname + \"(\"+file.toString());\n        }\n        mutableKids.add(kid);\n        kid.buildPageTreeRecursive(this, allPages);\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"580584a6c5fc0f03777842090bc2d2dfb64337e5","date":1574200470,"type":5,"author":"Cassandra Targett","isMerge":false,"pathNew":"solr/solr-ref-guide/tools/BuildNavDataFiles.Page#buildPageTreeRecursive(Page,Map[String,Page]).mjava","pathOld":"solr/solr-ref-guide/tools/BuildNavAndPDFBody.Page#buildPageTreeRecursive(Page,Map[String,Page]).mjava","sourceNew":"    /** \n     * Recursively sets {@link #getParent} and populates {@link #kids} from {@link #kidShortnames} \n     * via the <code>allPages</code> Map \n     */\n    public void buildPageTreeRecursive(Page parent, Map<String,Page> allPages) {\n      if (null != parent) {\n        if (null != this.parent) {\n          // as long as we also check (later) that every page has a parent, this check (prior to recusion)\n          // also ensures we never have any loops\n          throw new RuntimeException(file.getName() + \" is listed as the child of (at least) 2 pages: '\" + parent.shortname + \"' and '\" + this.parent.shortname + \"'\");\n        }\n        this.parent = parent;\n      }\n      for (String kidShortname : kidShortnames) {\n        Page kid = allPages.get(kidShortname);\n        if (null == kid) {\n          throw new RuntimeException(\"Unable to locate \" + kidShortname + \"; child of \" + shortname + \"(\"+file.toString());\n        }\n        mutableKids.add(kid);\n        kid.buildPageTreeRecursive(this, allPages);\n      }\n    }\n\n","sourceOld":"    /** \n     * Recursively sets {@link #getParent} and populates {@link #kids} from {@link #kidShortnames} \n     * via the <code>allPages</code> Map \n     */\n    public void buildPageTreeRecursive(Page parent, Map<String,Page> allPages) {\n      if (null != parent) {\n        if (null != this.parent) {\n          // as long as we also check (later) that every page has a parent, this check (prior to recusion)\n          // also ensures we never have any loops\n          throw new RuntimeException(file.getName() + \" is listed as the child of (at least) 2 pages: '\" + parent.shortname + \"' and '\" + this.parent.shortname + \"'\");\n        }\n        this.parent = parent;\n      }\n      for (String kidShortname : kidShortnames) {\n        Page kid = allPages.get(kidShortname);\n        if (null == kid) {\n          throw new RuntimeException(\"Unable to locate \" + kidShortname + \"; child of \" + shortname + \"(\"+file.toString());\n        }\n        mutableKids.add(kid);\n        kid.buildPageTreeRecursive(this, allPages);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"171df45763ac908e39a8c33b0c742ffb59a1ba53":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"580584a6c5fc0f03777842090bc2d2dfb64337e5":["171df45763ac908e39a8c33b0c742ffb59a1ba53"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["580584a6c5fc0f03777842090bc2d2dfb64337e5"]},"commit2Childs":{"171df45763ac908e39a8c33b0c742ffb59a1ba53":["580584a6c5fc0f03777842090bc2d2dfb64337e5"],"580584a6c5fc0f03777842090bc2d2dfb64337e5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["171df45763ac908e39a8c33b0c742ffb59a1ba53"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}