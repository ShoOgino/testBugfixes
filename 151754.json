{"path":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsReader.FieldReader.IntersectEnum#seekToStartTerm(BytesRef).mjava","commits":[{"id":"5ad80176d91a6f70fe93880e43dfd697dc4e63ed","date":1400176913,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsReader.FieldReader.IntersectEnum#seekToStartTerm(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.FieldReader.IntersectEnum#seekToStartTerm(BytesRef).mjava","sourceNew":"      // NOTE: specialized to only doing the first-time\n      // seek, but we could generalize it to allow\n      // arbitrary seekExact/Ceil.  Note that this is a\n      // seekFloor!\n      private void seekToStartTerm(BytesRef target) throws IOException {\n        //if (DEBUG) System.out.println(\"seek to startTerm=\" + target.utf8ToString());\n        assert currentFrame.ord == 0;\n        if (term.length < target.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, target.length);\n        }\n        FST.Arc<BytesRef> arc = arcs[0];\n        assert arc == currentFrame.arc;\n\n        for(int idx=0;idx<=target.length;idx++) {\n\n          while (true) {\n            final int savePos = currentFrame.suffixesReader.getPosition();\n            final int saveStartBytePos = currentFrame.startBytePos;\n            final int saveSuffix = currentFrame.suffix;\n            final long saveLastSubFP = currentFrame.lastSubFP;\n            final int saveTermBlockOrd = currentFrame.termState.termBlockOrd;\n\n            final boolean isSubBlock = currentFrame.next();\n\n            //if (DEBUG) System.out.println(\"    cycle ent=\" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") prefix=\" + currentFrame.prefix + \" suffix=\" + currentFrame.suffix + \" isBlock=\" + isSubBlock + \" firstLabel=\" + (currentFrame.suffix == 0 ? \"\" : (currentFrame.suffixBytes[currentFrame.startBytePos])&0xff));\n            term.length = currentFrame.prefix + currentFrame.suffix;\n            if (term.bytes.length < term.length) {\n              term.bytes = ArrayUtil.grow(term.bytes, term.length);\n            }\n            System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n\n            if (isSubBlock && StringHelper.startsWith(target, term)) {\n              // Recurse\n              //if (DEBUG) System.out.println(\"      recurse!\");\n              currentFrame = pushFrame(getState());\n              break;\n            } else {\n              final int cmp = term.compareTo(target);\n              if (cmp < 0) {\n                if (currentFrame.nextEnt == currentFrame.entCount) {\n                  if (!currentFrame.isLastInFloor) {\n                    //if (DEBUG) System.out.println(\"  load floorBlock\");\n                    currentFrame.loadNextFloorBlock();\n                    continue;\n                  } else {\n                    //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                    return;\n                  }\n                }\n                continue;\n              } else if (cmp == 0) {\n                //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                return;\n              } else {\n                // Fallback to prior entry: the semantics of\n                // this method is that the first call to\n                // next() will return the term after the\n                // requested term\n                currentFrame.nextEnt--;\n                currentFrame.lastSubFP = saveLastSubFP;\n                currentFrame.startBytePos = saveStartBytePos;\n                currentFrame.suffix = saveSuffix;\n                currentFrame.suffixesReader.setPosition(savePos);\n                currentFrame.termState.termBlockOrd = saveTermBlockOrd;\n                System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n                term.length = currentFrame.prefix + currentFrame.suffix;\n                // If the last entry was a block we don't\n                // need to bother recursing and pushing to\n                // the last term under it because the first\n                // next() will simply skip the frame anyway\n                return;\n              }\n            }\n          }\n        }\n\n        assert false;\n      }\n\n","sourceOld":"      // NOTE: specialized to only doing the first-time\n      // seek, but we could generalize it to allow\n      // arbitrary seekExact/Ceil.  Note that this is a\n      // seekFloor!\n      private void seekToStartTerm(BytesRef target) throws IOException {\n        //if (DEBUG) System.out.println(\"seek to startTerm=\" + target.utf8ToString());\n        assert currentFrame.ord == 0;\n        if (term.length < target.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, target.length);\n        }\n        FST.Arc<BytesRef> arc = arcs[0];\n        assert arc == currentFrame.arc;\n\n        for(int idx=0;idx<=target.length;idx++) {\n\n          while (true) {\n            final int savePos = currentFrame.suffixesReader.getPosition();\n            final int saveStartBytePos = currentFrame.startBytePos;\n            final int saveSuffix = currentFrame.suffix;\n            final long saveLastSubFP = currentFrame.lastSubFP;\n            final int saveTermBlockOrd = currentFrame.termState.termBlockOrd;\n\n            final boolean isSubBlock = currentFrame.next();\n\n            //if (DEBUG) System.out.println(\"    cycle ent=\" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") prefix=\" + currentFrame.prefix + \" suffix=\" + currentFrame.suffix + \" isBlock=\" + isSubBlock + \" firstLabel=\" + (currentFrame.suffix == 0 ? \"\" : (currentFrame.suffixBytes[currentFrame.startBytePos])&0xff));\n            term.length = currentFrame.prefix + currentFrame.suffix;\n            if (term.bytes.length < term.length) {\n              term.bytes = ArrayUtil.grow(term.bytes, term.length);\n            }\n            System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n\n            if (isSubBlock && StringHelper.startsWith(target, term)) {\n              // Recurse\n              //if (DEBUG) System.out.println(\"      recurse!\");\n              currentFrame = pushFrame(getState());\n              break;\n            } else {\n              final int cmp = term.compareTo(target);\n              if (cmp < 0) {\n                if (currentFrame.nextEnt == currentFrame.entCount) {\n                  if (!currentFrame.isLastInFloor) {\n                    //if (DEBUG) System.out.println(\"  load floorBlock\");\n                    currentFrame.loadNextFloorBlock();\n                    continue;\n                  } else {\n                    //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                    return;\n                  }\n                }\n                continue;\n              } else if (cmp == 0) {\n                //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                return;\n              } else {\n                // Fallback to prior entry: the semantics of\n                // this method is that the first call to\n                // next() will return the term after the\n                // requested term\n                currentFrame.nextEnt--;\n                currentFrame.lastSubFP = saveLastSubFP;\n                currentFrame.startBytePos = saveStartBytePos;\n                currentFrame.suffix = saveSuffix;\n                currentFrame.suffixesReader.setPosition(savePos);\n                currentFrame.termState.termBlockOrd = saveTermBlockOrd;\n                System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n                term.length = currentFrame.prefix + currentFrame.suffix;\n                // If the last entry was a block we don't\n                // need to bother recursing and pushing to\n                // the last term under it because the first\n                // next() will simply skip the frame anyway\n                return;\n              }\n            }\n          }\n        }\n\n        assert false;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"47d9d581b0b317125672636196fa3c73bbcabc56","date":1400178129,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsReader.FieldReader.IntersectEnum#seekToStartTerm(BytesRef).mjava","sourceNew":null,"sourceOld":"      // NOTE: specialized to only doing the first-time\n      // seek, but we could generalize it to allow\n      // arbitrary seekExact/Ceil.  Note that this is a\n      // seekFloor!\n      private void seekToStartTerm(BytesRef target) throws IOException {\n        //if (DEBUG) System.out.println(\"seek to startTerm=\" + target.utf8ToString());\n        assert currentFrame.ord == 0;\n        if (term.length < target.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, target.length);\n        }\n        FST.Arc<BytesRef> arc = arcs[0];\n        assert arc == currentFrame.arc;\n\n        for(int idx=0;idx<=target.length;idx++) {\n\n          while (true) {\n            final int savePos = currentFrame.suffixesReader.getPosition();\n            final int saveStartBytePos = currentFrame.startBytePos;\n            final int saveSuffix = currentFrame.suffix;\n            final long saveLastSubFP = currentFrame.lastSubFP;\n            final int saveTermBlockOrd = currentFrame.termState.termBlockOrd;\n\n            final boolean isSubBlock = currentFrame.next();\n\n            //if (DEBUG) System.out.println(\"    cycle ent=\" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") prefix=\" + currentFrame.prefix + \" suffix=\" + currentFrame.suffix + \" isBlock=\" + isSubBlock + \" firstLabel=\" + (currentFrame.suffix == 0 ? \"\" : (currentFrame.suffixBytes[currentFrame.startBytePos])&0xff));\n            term.length = currentFrame.prefix + currentFrame.suffix;\n            if (term.bytes.length < term.length) {\n              term.bytes = ArrayUtil.grow(term.bytes, term.length);\n            }\n            System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n\n            if (isSubBlock && StringHelper.startsWith(target, term)) {\n              // Recurse\n              //if (DEBUG) System.out.println(\"      recurse!\");\n              currentFrame = pushFrame(getState());\n              break;\n            } else {\n              final int cmp = term.compareTo(target);\n              if (cmp < 0) {\n                if (currentFrame.nextEnt == currentFrame.entCount) {\n                  if (!currentFrame.isLastInFloor) {\n                    //if (DEBUG) System.out.println(\"  load floorBlock\");\n                    currentFrame.loadNextFloorBlock();\n                    continue;\n                  } else {\n                    //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                    return;\n                  }\n                }\n                continue;\n              } else if (cmp == 0) {\n                //if (DEBUG) System.out.println(\"  return term=\" + brToString(term));\n                return;\n              } else {\n                // Fallback to prior entry: the semantics of\n                // this method is that the first call to\n                // next() will return the term after the\n                // requested term\n                currentFrame.nextEnt--;\n                currentFrame.lastSubFP = saveLastSubFP;\n                currentFrame.startBytePos = saveStartBytePos;\n                currentFrame.suffix = saveSuffix;\n                currentFrame.suffixesReader.setPosition(savePos);\n                currentFrame.termState.termBlockOrd = saveTermBlockOrd;\n                System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, term.bytes, currentFrame.prefix, currentFrame.suffix);\n                term.length = currentFrame.prefix + currentFrame.suffix;\n                // If the last entry was a block we don't\n                // need to bother recursing and pushing to\n                // the last term under it because the first\n                // next() will simply skip the frame anyway\n                return;\n              }\n            }\n          }\n        }\n\n        assert false;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5ad80176d91a6f70fe93880e43dfd697dc4e63ed":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"47d9d581b0b317125672636196fa3c73bbcabc56":["5ad80176d91a6f70fe93880e43dfd697dc4e63ed"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"5ad80176d91a6f70fe93880e43dfd697dc4e63ed":["47d9d581b0b317125672636196fa3c73bbcabc56"],"47d9d581b0b317125672636196fa3c73bbcabc56":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5ad80176d91a6f70fe93880e43dfd697dc4e63ed","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["47d9d581b0b317125672636196fa3c73bbcabc56","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}