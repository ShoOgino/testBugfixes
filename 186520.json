{"path":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,SegmentInfos).mjava","commits":[{"id":"c19f985e36a65cc969e8e564fe337a0d41512075","date":1296330536,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,SegmentInfos).mjava","pathOld":"/dev/null","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, SegmentInfos infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    SegmentInfos infos2 = new SegmentInfos();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final BufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.gen) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes();\n        }\n        coalescedDeletes.update(packet);\n        delIDX--;\n      } else if (packet != null && segGen == packet.gen) {\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        try {\n          if (coalescedDeletes != null) {\n            delCount += applyDeletes(coalescedDeletes, reader);\n          }\n          delCount += applyDeletes(packet, reader);\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        // We've applied doc ids, and they're only applied\n        // on the current segment\n        bytesUsed.addAndGet(-packet.docIDs.size() * BufferedDeletes.BYTES_PER_DEL_DOCID);\n        packet.clearDocIDs();\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount);\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes();\n        }\n        coalescedDeletes.update(packet);\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          try {\n            delCount += applyDeletes(coalescedDeletes, reader);\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount);\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n    \n    return new ApplyDeletesResult(anyNewDeletes, nextGen++);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["ae695f21c50b03702b5d0fa2543d5af844bb7cd3","ae695f21c50b03702b5d0fa2543d5af844bb7cd3","7e4c214a1f904dde76f5611b56d4081533055b3b","7e4c214a1f904dde76f5611b56d4081533055b3b","7e4c214a1f904dde76f5611b56d4081533055b3b","7e4c214a1f904dde76f5611b56d4081533055b3b","119ae5b0966bbb5d6948c7f86207613595764d2e","119ae5b0966bbb5d6948c7f86207613595764d2e","119ae5b0966bbb5d6948c7f86207613595764d2e","119ae5b0966bbb5d6948c7f86207613595764d2e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"69a6d2d525aeab53c867ed26934185e5bb627d0e","date":1296516902,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,SegmentInfos).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, SegmentInfos infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    SegmentInfos infos2 = new SegmentInfos();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.gen) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        coalescedDeletes.update(packet);\n        delIDX--;\n      } else if (packet != null && segGen == packet.gen) {\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriter\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount);\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        coalescedDeletes.update(packet);\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount);\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n    \n    return new ApplyDeletesResult(anyNewDeletes, nextGen++);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, SegmentInfos infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    SegmentInfos infos2 = new SegmentInfos();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final BufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.gen) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes();\n        }\n        coalescedDeletes.update(packet);\n        delIDX--;\n      } else if (packet != null && segGen == packet.gen) {\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        try {\n          if (coalescedDeletes != null) {\n            delCount += applyDeletes(coalescedDeletes, reader);\n          }\n          delCount += applyDeletes(packet, reader);\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        // We've applied doc ids, and they're only applied\n        // on the current segment\n        bytesUsed.addAndGet(-packet.docIDs.size() * BufferedDeletes.BYTES_PER_DEL_DOCID);\n        packet.clearDocIDs();\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount);\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes();\n        }\n        coalescedDeletes.update(packet);\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          try {\n            delCount += applyDeletes(coalescedDeletes, reader);\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount);\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n    \n    return new ApplyDeletesResult(anyNewDeletes, nextGen++);\n  }\n\n","bugFix":null,"bugIntro":["7e4c214a1f904dde76f5611b56d4081533055b3b","7e4c214a1f904dde76f5611b56d4081533055b3b","7e4c214a1f904dde76f5611b56d4081533055b3b","7e4c214a1f904dde76f5611b56d4081533055b3b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,SegmentInfos).mjava","pathOld":"/dev/null","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, SegmentInfos infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    SegmentInfos infos2 = new SegmentInfos();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.gen) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        coalescedDeletes.update(packet);\n        delIDX--;\n      } else if (packet != null && segGen == packet.gen) {\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriter\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount);\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        coalescedDeletes.update(packet);\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount);\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n    \n    return new ApplyDeletesResult(anyNewDeletes, nextGen++);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3","date":1297940445,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,SegmentInfos).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, SegmentInfos infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    SegmentInfos infos2 = new SegmentInfos();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    SegmentInfos allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.gen) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        coalescedDeletes.update(packet);\n        delIDX--;\n      } else if (packet != null && segGen == packet.gen) {\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriter\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new SegmentInfos();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        coalescedDeletes.update(packet);\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new SegmentInfos();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n    \n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, SegmentInfos infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    SegmentInfos infos2 = new SegmentInfos();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.gen) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        coalescedDeletes.update(packet);\n        delIDX--;\n      } else if (packet != null && segGen == packet.gen) {\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriter\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount);\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        coalescedDeletes.update(packet);\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount);\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n    \n    return new ApplyDeletesResult(anyNewDeletes, nextGen++);\n  }\n\n","bugFix":null,"bugIntro":["7e4c214a1f904dde76f5611b56d4081533055b3b","7e4c214a1f904dde76f5611b56d4081533055b3b","7e4c214a1f904dde76f5611b56d4081533055b3b","7e4c214a1f904dde76f5611b56d4081533055b3b","119ae5b0966bbb5d6948c7f86207613595764d2e","119ae5b0966bbb5d6948c7f86207613595764d2e","119ae5b0966bbb5d6948c7f86207613595764d2e","119ae5b0966bbb5d6948c7f86207613595764d2e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f1bdbf92da222965b46c0a942c3857ba56e5c638","date":1298297608,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,SegmentInfos).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, SegmentInfos infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    SegmentInfos infos2 = new SegmentInfos();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    SegmentInfos allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.gen) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        coalescedDeletes.update(packet);\n        delIDX--;\n      } else if (packet != null && segGen == packet.gen) {\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriter\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new SegmentInfos();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        coalescedDeletes.update(packet);\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new SegmentInfos();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n    \n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, SegmentInfos infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    SegmentInfos infos2 = new SegmentInfos();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.gen) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        coalescedDeletes.update(packet);\n        delIDX--;\n      } else if (packet != null && segGen == packet.gen) {\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriter\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount);\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        coalescedDeletes.update(packet);\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount);\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n    \n    return new ApplyDeletesResult(anyNewDeletes, nextGen++);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,SegmentInfos).mjava","pathOld":"/dev/null","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, SegmentInfos infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    SegmentInfos infos2 = new SegmentInfos();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    SegmentInfos allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.gen) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        coalescedDeletes.update(packet);\n        delIDX--;\n      } else if (packet != null && segGen == packet.gen) {\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriter\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new SegmentInfos();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        coalescedDeletes.update(packet);\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new SegmentInfos();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"327863a2fd61e831028b6c56c8fef6b00a44eb0b","date":1302686439,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,SegmentInfos).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, SegmentInfos infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    SegmentInfos infos2 = new SegmentInfos();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    SegmentInfos allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * only update the coalescededDeletes if we are NOT on a segment private del packet. \n           * the segment private del packet must only applied to segments with the same delGen. \n           * Yet, if a segment is already deleted from the SI since it had no more documents remaining \n           * after some del packets younger than it segPrivate packet (hihger delGen) have been applied\n           * the segPrivate packet has not been removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new SegmentInfos();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new SegmentInfos();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, SegmentInfos infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    SegmentInfos infos2 = new SegmentInfos();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    SegmentInfos allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.gen) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        coalescedDeletes.update(packet);\n        delIDX--;\n      } else if (packet != null && segGen == packet.gen) {\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriter\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new SegmentInfos();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        coalescedDeletes.update(packet);\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new SegmentInfos();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":["7e4c214a1f904dde76f5611b56d4081533055b3b","7e4c214a1f904dde76f5611b56d4081533055b3b","7e4c214a1f904dde76f5611b56d4081533055b3b","7e4c214a1f904dde76f5611b56d4081533055b3b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f6f4cae61e16730201371ab7e9912721c19324e7","date":1303199575,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,SegmentInfos).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, SegmentInfos infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    SegmentInfos infos2 = new SegmentInfos();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    SegmentInfos allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new SegmentInfos();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new SegmentInfos();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, SegmentInfos infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    SegmentInfos infos2 = new SegmentInfos();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    SegmentInfos allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * only update the coalescededDeletes if we are NOT on a segment private del packet. \n           * the segment private del packet must only applied to segments with the same delGen. \n           * Yet, if a segment is already deleted from the SI since it had no more documents remaining \n           * after some del packets younger than it segPrivate packet (hihger delGen) have been applied\n           * the segPrivate packet has not been removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new SegmentInfos();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new SegmentInfos();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":["7e4c214a1f904dde76f5611b56d4081533055b3b","7e4c214a1f904dde76f5611b56d4081533055b3b","7e4c214a1f904dde76f5611b56d4081533055b3b","7e4c214a1f904dde76f5611b56d4081533055b3b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b3e06be49006ecac364d39d12b9c9f74882f9b9f","date":1304289513,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,SegmentInfos).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, SegmentInfos infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    SegmentInfos infos2 = new SegmentInfos();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    SegmentInfos allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new SegmentInfos();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new SegmentInfos();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, SegmentInfos infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    SegmentInfos infos2 = new SegmentInfos();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    SegmentInfos allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.gen) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        coalescedDeletes.update(packet);\n        delIDX--;\n      } else if (packet != null && segGen == packet.gen) {\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriter\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new SegmentInfos();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        coalescedDeletes.update(packet);\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new SegmentInfos();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n    \n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,SegmentInfos).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, SegmentInfos infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    SegmentInfos infos2 = new SegmentInfos();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    SegmentInfos allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new SegmentInfos();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new SegmentInfos();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, SegmentInfos infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    SegmentInfos infos2 = new SegmentInfos();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    SegmentInfos allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.gen) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        coalescedDeletes.update(packet);\n        delIDX--;\n      } else if (packet != null && segGen == packet.gen) {\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriter\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new SegmentInfos();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        coalescedDeletes.update(packet);\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new SegmentInfos();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n    \n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5270fb4f55a1b77663dda53cb8090c083f0a23b3","date":1305050821,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,SegmentInfos).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, SegmentInfos infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    SegmentInfos infos2 = new SegmentInfos();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    SegmentInfos allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new SegmentInfos();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new SegmentInfos();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c700f8d0842d3e52bb2bdfbfdc046a137e836edb","date":1305285499,"type":5,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,SegmentInfos).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, SegmentInfos infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    SegmentInfos infos2 = new SegmentInfos();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    SegmentInfos allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet\";\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new SegmentInfos();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new SegmentInfos();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":4,"author":"Steven Rowe","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,SegmentInfos).mjava","sourceNew":null,"sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the deletedDocs BitVector for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, SegmentInfos infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      message(\"applyDeletes: no deletes; skipping\");\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream != null) {\n      message(\"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    SegmentInfos infos2 = new SegmentInfos();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortByDelGen);\n\n    BufferedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    SegmentInfos allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.gen) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        coalescedDeletes.update(packet);\n        delIDX--;\n      } else if (packet != null && segGen == packet.gen) {\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        SegmentReader reader = readerPool.get(info, false);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriter\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), reader);\n          segAllDeletes = reader.numDocs() == 0;\n        } finally {\n          readerPool.release(reader);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new SegmentInfos();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream != null) {\n          message(\"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new BufferedDeletes(true);\n        }\n        coalescedDeletes.update(packet);\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          SegmentReader reader = readerPool.get(info, false);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), reader);\n            segAllDeletes = reader.numDocs() == 0;\n          } finally {\n            readerPool.release(reader);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new SegmentInfos();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream != null) {\n            message(\"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] delCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream != null) {\n      message(\"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n    \n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f1bdbf92da222965b46c0a942c3857ba56e5c638":["29ef99d61cda9641b6250bf9567329a6e65f901d","e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["f1bdbf92da222965b46c0a942c3857ba56e5c638","b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3","f6f4cae61e16730201371ab7e9912721c19324e7"],"327863a2fd61e831028b6c56c8fef6b00a44eb0b":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"f6f4cae61e16730201371ab7e9912721c19324e7":["327863a2fd61e831028b6c56c8fef6b00a44eb0b"],"5270fb4f55a1b77663dda53cb8090c083f0a23b3":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"c19f985e36a65cc969e8e564fe337a0d41512075":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3":["69a6d2d525aeab53c867ed26934185e5bb627d0e"],"a3776dccca01c11e7046323cfad46a3b4a471233":["e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3","5270fb4f55a1b77663dda53cb8090c083f0a23b3"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","69a6d2d525aeab53c867ed26934185e5bb627d0e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c700f8d0842d3e52bb2bdfbfdc046a137e836edb":["135621f3a0670a9394eb563224a3b76cc4dddc0f","5270fb4f55a1b77663dda53cb8090c083f0a23b3"],"69a6d2d525aeab53c867ed26934185e5bb627d0e":["c19f985e36a65cc969e8e564fe337a0d41512075"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5270fb4f55a1b77663dda53cb8090c083f0a23b3"]},"commit2Childs":{"f1bdbf92da222965b46c0a942c3857ba56e5c638":["135621f3a0670a9394eb563224a3b76cc4dddc0f"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["c700f8d0842d3e52bb2bdfbfdc046a137e836edb"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["135621f3a0670a9394eb563224a3b76cc4dddc0f","5270fb4f55a1b77663dda53cb8090c083f0a23b3"],"327863a2fd61e831028b6c56c8fef6b00a44eb0b":["f6f4cae61e16730201371ab7e9912721c19324e7"],"f6f4cae61e16730201371ab7e9912721c19324e7":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"5270fb4f55a1b77663dda53cb8090c083f0a23b3":["a3776dccca01c11e7046323cfad46a3b4a471233","c700f8d0842d3e52bb2bdfbfdc046a137e836edb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c19f985e36a65cc969e8e564fe337a0d41512075":["69a6d2d525aeab53c867ed26934185e5bb627d0e"],"e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3":["f1bdbf92da222965b46c0a942c3857ba56e5c638","b3e06be49006ecac364d39d12b9c9f74882f9b9f","a3776dccca01c11e7046323cfad46a3b4a471233","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["f1bdbf92da222965b46c0a942c3857ba56e5c638"],"a3776dccca01c11e7046323cfad46a3b4a471233":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c19f985e36a65cc969e8e564fe337a0d41512075","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"c700f8d0842d3e52bb2bdfbfdc046a137e836edb":[],"69a6d2d525aeab53c867ed26934185e5bb627d0e":["e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3","29ef99d61cda9641b6250bf9567329a6e65f901d"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["327863a2fd61e831028b6c56c8fef6b00a44eb0b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a3776dccca01c11e7046323cfad46a3b4a471233","c700f8d0842d3e52bb2bdfbfdc046a137e836edb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}