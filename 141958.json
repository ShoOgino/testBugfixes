{"path":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","commits":[{"id":"63a9344cff6a72bc4c1ef080c69e10ad0635b811","date":1490410892,"type":1,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final List<LeafReaderContext> leafContexts = searcher.getLeafContexts();\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = searcher.getSchema().getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n      FieldInfo fi = searcher.getFieldInfos().fieldInfo(fieldName);\n      if (fi == null) {\n        continue; // Searcher doesn't have info about this field, hence ignore it.\n      }\n      final DocValuesType dvType = fi.getDocValuesType();\n      switch (dvType) {\n        case NUMERIC:\n          final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n          if (ndv == null) {\n            continue;\n          }\n          Long val;\n          if (ndv.advanceExact(localId)) {\n            val = ndv.longValue();\n          } else {\n            continue;\n          }\n          Object newVal = val;\n          if (schemaField.getType().isPointField()) {\n            // TODO: Maybe merge PointField with TrieFields here\n            NumberType type = schemaField.getType().getNumberType();\n            switch (type) {\n              case INTEGER:\n                newVal = val.intValue();\n                break;\n              case LONG:\n                newVal = val.longValue();\n                break;\n              case FLOAT:\n                newVal = Float.intBitsToFloat(val.intValue());\n                break;\n              case DOUBLE:\n                newVal = Double.longBitsToDouble(val);\n                break;\n              case DATE:\n                newVal = new Date(val);\n                break;\n              default:\n                throw new AssertionError(\"Unexpected PointType: \" + type);\n            }\n          } else {\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n          }\n          doc.addField(fieldName, newVal);\n          break;\n        case BINARY:\n          BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n          if (bdv == null) {\n            continue;\n          }\n          BytesRef value;\n          if (bdv.advanceExact(localId)) {\n            value = BytesRef.deepCopyOf(bdv.binaryValue());\n          } else {\n            continue;\n          }\n          doc.addField(fieldName, value);\n          break;\n        case SORTED:\n          SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n          if (sdv == null) {\n            continue;\n          }\n          if (sdv.advanceExact(localId)) {\n            final BytesRef bRef = sdv.binaryValue();\n            // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n            if (schemaField.getType() instanceof BoolField) {\n              doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n            } else {\n              doc.addField(fieldName, bRef.utf8ToString());\n            }\n          }\n          break;\n        case SORTED_NUMERIC:\n          final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n          NumberType type = schemaField.getType().getNumberType();\n          if (numericDv != null) {\n            if (numericDv.advance(localId) == localId) {\n              final List<Object> outValues = new ArrayList<Object>(numericDv.docValueCount());\n              for (int i = 0; i < numericDv.docValueCount(); i++) {\n                long number = numericDv.nextValue();\n                switch (type) {\n                  case INTEGER:\n                    outValues.add((int)number);\n                    break;\n                  case LONG:\n                    outValues.add(number);\n                    break;\n                  case FLOAT:\n                    outValues.add(NumericUtils.sortableIntToFloat((int)number));\n                    break;\n                  case DOUBLE:\n                    outValues.add(NumericUtils.sortableLongToDouble(number));\n                    break;\n                  case DATE:\n                    outValues.add(new Date(number));\n                    break;\n                  default:\n                    throw new AssertionError(\"Unexpected PointType: \" + type);\n                }\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case SORTED_SET:\n          final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n          if (values != null && values.getValueCount() > 0) {\n            if (values.advance(localId) == localId) {\n              final List<Object> outValues = new LinkedList<>();\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                value = values.lookupOrd(ord);\n                outValues.add(schemaField.getType().toObject(schemaField, value));\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case NONE:\n          break;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n      FieldInfo fi = fieldInfos.fieldInfo(fieldName);\n      if (fi == null) {\n        continue; // Searcher doesn't have info about this field, hence ignore it.\n      }\n      final DocValuesType dvType = fi.getDocValuesType();\n      switch (dvType) {\n        case NUMERIC:\n          final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n          if (ndv == null) {\n            continue;\n          }\n          Long val;\n          if (ndv.advanceExact(localId)) {\n            val = ndv.longValue();\n          } else {\n            continue;\n          }\n          Object newVal = val;\n          if (schemaField.getType().isPointField()) {\n            // TODO: Maybe merge PointField with TrieFields here\n            NumberType type = schemaField.getType().getNumberType();\n            switch (type) {\n              case INTEGER:\n                newVal = val.intValue();\n                break;\n              case LONG:\n                newVal = val;\n                break;\n              case FLOAT:\n                newVal = Float.intBitsToFloat(val.intValue());\n                break;\n              case DOUBLE:\n                newVal = Double.longBitsToDouble(val);\n                break;\n              case DATE:\n                newVal = new Date(val);\n                break;\n              default:\n                throw new AssertionError(\"Unexpected PointType: \" + type);\n            }\n          } else {\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n          }\n          doc.addField(fieldName, newVal);\n          break;\n        case BINARY:\n          BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n          if (bdv == null) {\n            continue;\n          }\n          BytesRef value;\n          if (bdv.advanceExact(localId)) {\n            value = BytesRef.deepCopyOf(bdv.binaryValue());\n          } else {\n            continue;\n          }\n          doc.addField(fieldName, value);\n          break;\n        case SORTED:\n          SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n          if (sdv == null) {\n            continue;\n          }\n          if (sdv.advanceExact(localId)) {\n            final BytesRef bRef = sdv.binaryValue();\n            // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n            if (schemaField.getType() instanceof BoolField) {\n              doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n            } else {\n              doc.addField(fieldName, bRef.utf8ToString());\n            }\n          }\n          break;\n        case SORTED_NUMERIC:\n          final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n          NumberType type = schemaField.getType().getNumberType();\n          if (numericDv != null) {\n            if (numericDv.advance(localId) == localId) {\n              final List<Object> outValues = new ArrayList<Object>(numericDv.docValueCount());\n              for (int i = 0; i < numericDv.docValueCount(); i++) {\n                long number = numericDv.nextValue();\n                switch (type) {\n                  case INTEGER:\n                    outValues.add((int)number);\n                    break;\n                  case LONG:\n                    outValues.add(number);\n                    break;\n                  case FLOAT:\n                    outValues.add(NumericUtils.sortableIntToFloat((int)number));\n                    break;\n                  case DOUBLE:\n                    outValues.add(NumericUtils.sortableLongToDouble(number));\n                    break;\n                  case DATE:\n                    outValues.add(new Date(number));\n                    break;\n                  default:\n                    throw new AssertionError(\"Unexpected PointType: \" + type);\n                }\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case SORTED_SET:\n          final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n          if (values != null && values.getValueCount() > 0) {\n            if (values.advance(localId) == localId) {\n              final List<Object> outValues = new LinkedList<Object>();\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                value = values.lookupOrd(ord);\n                outValues.add(schemaField.getType().toObject(schemaField, value));\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case NONE:\n          break;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"de548de3ce5405595899f548152d4b93ac9eb9cc","date":1490594650,"type":1,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final List<LeafReaderContext> leafContexts = searcher.getLeafContexts();\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = searcher.getSchema().getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n      FieldInfo fi = searcher.getFieldInfos().fieldInfo(fieldName);\n      if (fi == null) {\n        continue; // Searcher doesn't have info about this field, hence ignore it.\n      }\n      final DocValuesType dvType = fi.getDocValuesType();\n      switch (dvType) {\n        case NUMERIC:\n          final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n          if (ndv == null) {\n            continue;\n          }\n          Long val;\n          if (ndv.advanceExact(localId)) {\n            val = ndv.longValue();\n          } else {\n            continue;\n          }\n          Object newVal = val;\n          if (schemaField.getType().isPointField()) {\n            // TODO: Maybe merge PointField with TrieFields here\n            NumberType type = schemaField.getType().getNumberType();\n            switch (type) {\n              case INTEGER:\n                newVal = val.intValue();\n                break;\n              case LONG:\n                newVal = val.longValue();\n                break;\n              case FLOAT:\n                newVal = Float.intBitsToFloat(val.intValue());\n                break;\n              case DOUBLE:\n                newVal = Double.longBitsToDouble(val);\n                break;\n              case DATE:\n                newVal = new Date(val);\n                break;\n              default:\n                throw new AssertionError(\"Unexpected PointType: \" + type);\n            }\n          } else {\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n          }\n          doc.addField(fieldName, newVal);\n          break;\n        case BINARY:\n          BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n          if (bdv == null) {\n            continue;\n          }\n          BytesRef value;\n          if (bdv.advanceExact(localId)) {\n            value = BytesRef.deepCopyOf(bdv.binaryValue());\n          } else {\n            continue;\n          }\n          doc.addField(fieldName, value);\n          break;\n        case SORTED:\n          SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n          if (sdv == null) {\n            continue;\n          }\n          if (sdv.advanceExact(localId)) {\n            final BytesRef bRef = sdv.binaryValue();\n            // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n            if (schemaField.getType() instanceof BoolField) {\n              doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n            } else {\n              doc.addField(fieldName, bRef.utf8ToString());\n            }\n          }\n          break;\n        case SORTED_NUMERIC:\n          final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n          NumberType type = schemaField.getType().getNumberType();\n          if (numericDv != null) {\n            if (numericDv.advance(localId) == localId) {\n              final List<Object> outValues = new ArrayList<Object>(numericDv.docValueCount());\n              for (int i = 0; i < numericDv.docValueCount(); i++) {\n                long number = numericDv.nextValue();\n                switch (type) {\n                  case INTEGER:\n                    outValues.add((int)number);\n                    break;\n                  case LONG:\n                    outValues.add(number);\n                    break;\n                  case FLOAT:\n                    outValues.add(NumericUtils.sortableIntToFloat((int)number));\n                    break;\n                  case DOUBLE:\n                    outValues.add(NumericUtils.sortableLongToDouble(number));\n                    break;\n                  case DATE:\n                    outValues.add(new Date(number));\n                    break;\n                  default:\n                    throw new AssertionError(\"Unexpected PointType: \" + type);\n                }\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case SORTED_SET:\n          final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n          if (values != null && values.getValueCount() > 0) {\n            if (values.advance(localId) == localId) {\n              final List<Object> outValues = new LinkedList<>();\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                value = values.lookupOrd(ord);\n                outValues.add(schemaField.getType().toObject(schemaField, value));\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case NONE:\n          break;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n      FieldInfo fi = fieldInfos.fieldInfo(fieldName);\n      if (fi == null) {\n        continue; // Searcher doesn't have info about this field, hence ignore it.\n      }\n      final DocValuesType dvType = fi.getDocValuesType();\n      switch (dvType) {\n        case NUMERIC:\n          final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n          if (ndv == null) {\n            continue;\n          }\n          Long val;\n          if (ndv.advanceExact(localId)) {\n            val = ndv.longValue();\n          } else {\n            continue;\n          }\n          Object newVal = val;\n          if (schemaField.getType().isPointField()) {\n            // TODO: Maybe merge PointField with TrieFields here\n            NumberType type = schemaField.getType().getNumberType();\n            switch (type) {\n              case INTEGER:\n                newVal = val.intValue();\n                break;\n              case LONG:\n                newVal = val;\n                break;\n              case FLOAT:\n                newVal = Float.intBitsToFloat(val.intValue());\n                break;\n              case DOUBLE:\n                newVal = Double.longBitsToDouble(val);\n                break;\n              case DATE:\n                newVal = new Date(val);\n                break;\n              default:\n                throw new AssertionError(\"Unexpected PointType: \" + type);\n            }\n          } else {\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n          }\n          doc.addField(fieldName, newVal);\n          break;\n        case BINARY:\n          BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n          if (bdv == null) {\n            continue;\n          }\n          BytesRef value;\n          if (bdv.advanceExact(localId)) {\n            value = BytesRef.deepCopyOf(bdv.binaryValue());\n          } else {\n            continue;\n          }\n          doc.addField(fieldName, value);\n          break;\n        case SORTED:\n          SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n          if (sdv == null) {\n            continue;\n          }\n          if (sdv.advanceExact(localId)) {\n            final BytesRef bRef = sdv.binaryValue();\n            // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n            if (schemaField.getType() instanceof BoolField) {\n              doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n            } else {\n              doc.addField(fieldName, bRef.utf8ToString());\n            }\n          }\n          break;\n        case SORTED_NUMERIC:\n          final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n          NumberType type = schemaField.getType().getNumberType();\n          if (numericDv != null) {\n            if (numericDv.advance(localId) == localId) {\n              final List<Object> outValues = new ArrayList<Object>(numericDv.docValueCount());\n              for (int i = 0; i < numericDv.docValueCount(); i++) {\n                long number = numericDv.nextValue();\n                switch (type) {\n                  case INTEGER:\n                    outValues.add((int)number);\n                    break;\n                  case LONG:\n                    outValues.add(number);\n                    break;\n                  case FLOAT:\n                    outValues.add(NumericUtils.sortableIntToFloat((int)number));\n                    break;\n                  case DOUBLE:\n                    outValues.add(NumericUtils.sortableLongToDouble(number));\n                    break;\n                  case DATE:\n                    outValues.add(new Date(number));\n                    break;\n                  default:\n                    throw new AssertionError(\"Unexpected PointType: \" + type);\n                }\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case SORTED_SET:\n          final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n          if (values != null && values.getValueCount() > 0) {\n            if (values.advance(localId) == localId) {\n              final List<Object> outValues = new LinkedList<Object>();\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                value = values.lookupOrd(ord);\n                outValues.add(schemaField.getType().toObject(schemaField, value));\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case NONE:\n          break;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ad8c9e9210e008dc7b8ad5a037ff20879150ea","date":1501889566,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final List<LeafReaderContext> leafContexts = searcher.getLeafContexts();\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = searcher.getSchema().getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n      FieldInfo fi = searcher.getFieldInfos().fieldInfo(fieldName);\n      if (fi == null) {\n        continue; // Searcher doesn't have info about this field, hence ignore it.\n      }\n      final DocValuesType dvType = fi.getDocValuesType();\n      switch (dvType) {\n        case NUMERIC:\n          final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n          if (ndv == null) {\n            continue;\n          }\n          Long val;\n          if (ndv.advanceExact(localId)) {\n            val = ndv.longValue();\n          } else {\n            continue;\n          }\n          Object newVal = val;\n          if (schemaField.getType().isPointField()) {\n            // TODO: Maybe merge PointField with TrieFields here\n            NumberType type = schemaField.getType().getNumberType();\n            switch (type) {\n              case INTEGER:\n                newVal = val.intValue();\n                break;\n              case LONG:\n                newVal = val.longValue();\n                break;\n              case FLOAT:\n                newVal = Float.intBitsToFloat(val.intValue());\n                break;\n              case DOUBLE:\n                newVal = Double.longBitsToDouble(val);\n                break;\n              case DATE:\n                newVal = new Date(val);\n                break;\n              default:\n                throw new AssertionError(\"Unexpected PointType: \" + type);\n            }\n          } else {\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof AbstractEnumField) {\n              newVal = ((AbstractEnumField)schemaField.getType()).getEnumMapping().intValueToStringValue(val.intValue());\n            }\n          }\n          doc.addField(fieldName, newVal);\n          break;\n        case BINARY:\n          BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n          if (bdv == null) {\n            continue;\n          }\n          BytesRef value;\n          if (bdv.advanceExact(localId)) {\n            value = BytesRef.deepCopyOf(bdv.binaryValue());\n          } else {\n            continue;\n          }\n          doc.addField(fieldName, value);\n          break;\n        case SORTED:\n          SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n          if (sdv == null) {\n            continue;\n          }\n          if (sdv.advanceExact(localId)) {\n            final BytesRef bRef = sdv.binaryValue();\n            // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n            if (schemaField.getType() instanceof BoolField) {\n              doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n            } else {\n              doc.addField(fieldName, bRef.utf8ToString());\n            }\n          }\n          break;\n        case SORTED_NUMERIC:\n          final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n          final NumberType type = schemaField.getType().getNumberType();\n          if (numericDv != null) {\n            if (numericDv.advance(localId) == localId) {\n              final List<Object> outValues = new ArrayList<Object>(numericDv.docValueCount());\n              for (int i = 0; i < numericDv.docValueCount(); i++) {\n                long number = numericDv.nextValue();\n                switch (type) {\n                  case INTEGER:\n                    final int raw = (int)number;\n                    if (schemaField.getType() instanceof AbstractEnumField) {\n                      outValues.add(((AbstractEnumField)schemaField.getType()).getEnumMapping().intValueToStringValue(raw));\n                    } else {\n                      outValues.add(raw);\n                    }\n                    break;\n                  case LONG:\n                    outValues.add(number);\n                    break;\n                  case FLOAT:\n                    outValues.add(NumericUtils.sortableIntToFloat((int)number));\n                    break;\n                  case DOUBLE:\n                    outValues.add(NumericUtils.sortableLongToDouble(number));\n                    break;\n                  case DATE:\n                    outValues.add(new Date(number));\n                    break;\n                  default:\n                    throw new AssertionError(\"Unexpected PointType: \" + type);\n                }\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case SORTED_SET:\n          final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n          if (values != null && values.getValueCount() > 0) {\n            if (values.advance(localId) == localId) {\n              final List<Object> outValues = new LinkedList<>();\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                value = values.lookupOrd(ord);\n                outValues.add(schemaField.getType().toObject(schemaField, value));\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case NONE:\n          break;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final List<LeafReaderContext> leafContexts = searcher.getLeafContexts();\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = searcher.getSchema().getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n      FieldInfo fi = searcher.getFieldInfos().fieldInfo(fieldName);\n      if (fi == null) {\n        continue; // Searcher doesn't have info about this field, hence ignore it.\n      }\n      final DocValuesType dvType = fi.getDocValuesType();\n      switch (dvType) {\n        case NUMERIC:\n          final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n          if (ndv == null) {\n            continue;\n          }\n          Long val;\n          if (ndv.advanceExact(localId)) {\n            val = ndv.longValue();\n          } else {\n            continue;\n          }\n          Object newVal = val;\n          if (schemaField.getType().isPointField()) {\n            // TODO: Maybe merge PointField with TrieFields here\n            NumberType type = schemaField.getType().getNumberType();\n            switch (type) {\n              case INTEGER:\n                newVal = val.intValue();\n                break;\n              case LONG:\n                newVal = val.longValue();\n                break;\n              case FLOAT:\n                newVal = Float.intBitsToFloat(val.intValue());\n                break;\n              case DOUBLE:\n                newVal = Double.longBitsToDouble(val);\n                break;\n              case DATE:\n                newVal = new Date(val);\n                break;\n              default:\n                throw new AssertionError(\"Unexpected PointType: \" + type);\n            }\n          } else {\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n          }\n          doc.addField(fieldName, newVal);\n          break;\n        case BINARY:\n          BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n          if (bdv == null) {\n            continue;\n          }\n          BytesRef value;\n          if (bdv.advanceExact(localId)) {\n            value = BytesRef.deepCopyOf(bdv.binaryValue());\n          } else {\n            continue;\n          }\n          doc.addField(fieldName, value);\n          break;\n        case SORTED:\n          SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n          if (sdv == null) {\n            continue;\n          }\n          if (sdv.advanceExact(localId)) {\n            final BytesRef bRef = sdv.binaryValue();\n            // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n            if (schemaField.getType() instanceof BoolField) {\n              doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n            } else {\n              doc.addField(fieldName, bRef.utf8ToString());\n            }\n          }\n          break;\n        case SORTED_NUMERIC:\n          final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n          NumberType type = schemaField.getType().getNumberType();\n          if (numericDv != null) {\n            if (numericDv.advance(localId) == localId) {\n              final List<Object> outValues = new ArrayList<Object>(numericDv.docValueCount());\n              for (int i = 0; i < numericDv.docValueCount(); i++) {\n                long number = numericDv.nextValue();\n                switch (type) {\n                  case INTEGER:\n                    outValues.add((int)number);\n                    break;\n                  case LONG:\n                    outValues.add(number);\n                    break;\n                  case FLOAT:\n                    outValues.add(NumericUtils.sortableIntToFloat((int)number));\n                    break;\n                  case DOUBLE:\n                    outValues.add(NumericUtils.sortableLongToDouble(number));\n                    break;\n                  case DATE:\n                    outValues.add(new Date(number));\n                    break;\n                  default:\n                    throw new AssertionError(\"Unexpected PointType: \" + type);\n                }\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case SORTED_SET:\n          final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n          if (values != null && values.getValueCount() > 0) {\n            if (values.advance(localId) == localId) {\n              final List<Object> outValues = new LinkedList<>();\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                value = values.lookupOrd(ord);\n                outValues.add(schemaField.getType().toObject(schemaField, value));\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case NONE:\n          break;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final List<LeafReaderContext> leafContexts = searcher.getLeafContexts();\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = searcher.getSchema().getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n      FieldInfo fi = searcher.getFieldInfos().fieldInfo(fieldName);\n      if (fi == null) {\n        continue; // Searcher doesn't have info about this field, hence ignore it.\n      }\n      final DocValuesType dvType = fi.getDocValuesType();\n      switch (dvType) {\n        case NUMERIC:\n          final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n          if (ndv == null) {\n            continue;\n          }\n          Long val;\n          if (ndv.advanceExact(localId)) {\n            val = ndv.longValue();\n          } else {\n            continue;\n          }\n          Object newVal = val;\n          if (schemaField.getType().isPointField()) {\n            // TODO: Maybe merge PointField with TrieFields here\n            NumberType type = schemaField.getType().getNumberType();\n            switch (type) {\n              case INTEGER:\n                newVal = val.intValue();\n                break;\n              case LONG:\n                newVal = val.longValue();\n                break;\n              case FLOAT:\n                newVal = Float.intBitsToFloat(val.intValue());\n                break;\n              case DOUBLE:\n                newVal = Double.longBitsToDouble(val);\n                break;\n              case DATE:\n                newVal = new Date(val);\n                break;\n              default:\n                throw new AssertionError(\"Unexpected PointType: \" + type);\n            }\n          } else {\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof AbstractEnumField) {\n              newVal = ((AbstractEnumField)schemaField.getType()).getEnumMapping().intValueToStringValue(val.intValue());\n            }\n          }\n          doc.addField(fieldName, newVal);\n          break;\n        case BINARY:\n          BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n          if (bdv == null) {\n            continue;\n          }\n          BytesRef value;\n          if (bdv.advanceExact(localId)) {\n            value = BytesRef.deepCopyOf(bdv.binaryValue());\n          } else {\n            continue;\n          }\n          doc.addField(fieldName, value);\n          break;\n        case SORTED:\n          SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n          if (sdv == null) {\n            continue;\n          }\n          if (sdv.advanceExact(localId)) {\n            final BytesRef bRef = sdv.binaryValue();\n            // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n            if (schemaField.getType() instanceof BoolField) {\n              doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n            } else {\n              doc.addField(fieldName, bRef.utf8ToString());\n            }\n          }\n          break;\n        case SORTED_NUMERIC:\n          final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n          final NumberType type = schemaField.getType().getNumberType();\n          if (numericDv != null) {\n            if (numericDv.advance(localId) == localId) {\n              final List<Object> outValues = new ArrayList<Object>(numericDv.docValueCount());\n              for (int i = 0; i < numericDv.docValueCount(); i++) {\n                long number = numericDv.nextValue();\n                switch (type) {\n                  case INTEGER:\n                    final int raw = (int)number;\n                    if (schemaField.getType() instanceof AbstractEnumField) {\n                      outValues.add(((AbstractEnumField)schemaField.getType()).getEnumMapping().intValueToStringValue(raw));\n                    } else {\n                      outValues.add(raw);\n                    }\n                    break;\n                  case LONG:\n                    outValues.add(number);\n                    break;\n                  case FLOAT:\n                    outValues.add(NumericUtils.sortableIntToFloat((int)number));\n                    break;\n                  case DOUBLE:\n                    outValues.add(NumericUtils.sortableLongToDouble(number));\n                    break;\n                  case DATE:\n                    outValues.add(new Date(number));\n                    break;\n                  default:\n                    throw new AssertionError(\"Unexpected PointType: \" + type);\n                }\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case SORTED_SET:\n          final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n          if (values != null && values.getValueCount() > 0) {\n            if (values.advance(localId) == localId) {\n              final List<Object> outValues = new LinkedList<>();\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                value = values.lookupOrd(ord);\n                outValues.add(schemaField.getType().toObject(schemaField, value));\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case NONE:\n          break;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final List<LeafReaderContext> leafContexts = searcher.getLeafContexts();\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = searcher.getSchema().getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n      FieldInfo fi = searcher.getFieldInfos().fieldInfo(fieldName);\n      if (fi == null) {\n        continue; // Searcher doesn't have info about this field, hence ignore it.\n      }\n      final DocValuesType dvType = fi.getDocValuesType();\n      switch (dvType) {\n        case NUMERIC:\n          final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n          if (ndv == null) {\n            continue;\n          }\n          Long val;\n          if (ndv.advanceExact(localId)) {\n            val = ndv.longValue();\n          } else {\n            continue;\n          }\n          Object newVal = val;\n          if (schemaField.getType().isPointField()) {\n            // TODO: Maybe merge PointField with TrieFields here\n            NumberType type = schemaField.getType().getNumberType();\n            switch (type) {\n              case INTEGER:\n                newVal = val.intValue();\n                break;\n              case LONG:\n                newVal = val.longValue();\n                break;\n              case FLOAT:\n                newVal = Float.intBitsToFloat(val.intValue());\n                break;\n              case DOUBLE:\n                newVal = Double.longBitsToDouble(val);\n                break;\n              case DATE:\n                newVal = new Date(val);\n                break;\n              default:\n                throw new AssertionError(\"Unexpected PointType: \" + type);\n            }\n          } else {\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n          }\n          doc.addField(fieldName, newVal);\n          break;\n        case BINARY:\n          BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n          if (bdv == null) {\n            continue;\n          }\n          BytesRef value;\n          if (bdv.advanceExact(localId)) {\n            value = BytesRef.deepCopyOf(bdv.binaryValue());\n          } else {\n            continue;\n          }\n          doc.addField(fieldName, value);\n          break;\n        case SORTED:\n          SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n          if (sdv == null) {\n            continue;\n          }\n          if (sdv.advanceExact(localId)) {\n            final BytesRef bRef = sdv.binaryValue();\n            // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n            if (schemaField.getType() instanceof BoolField) {\n              doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n            } else {\n              doc.addField(fieldName, bRef.utf8ToString());\n            }\n          }\n          break;\n        case SORTED_NUMERIC:\n          final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n          NumberType type = schemaField.getType().getNumberType();\n          if (numericDv != null) {\n            if (numericDv.advance(localId) == localId) {\n              final List<Object> outValues = new ArrayList<Object>(numericDv.docValueCount());\n              for (int i = 0; i < numericDv.docValueCount(); i++) {\n                long number = numericDv.nextValue();\n                switch (type) {\n                  case INTEGER:\n                    outValues.add((int)number);\n                    break;\n                  case LONG:\n                    outValues.add(number);\n                    break;\n                  case FLOAT:\n                    outValues.add(NumericUtils.sortableIntToFloat((int)number));\n                    break;\n                  case DOUBLE:\n                    outValues.add(NumericUtils.sortableLongToDouble(number));\n                    break;\n                  case DATE:\n                    outValues.add(new Date(number));\n                    break;\n                  default:\n                    throw new AssertionError(\"Unexpected PointType: \" + type);\n                }\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case SORTED_SET:\n          final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n          if (values != null && values.getValueCount() > 0) {\n            if (values.advance(localId) == localId) {\n              final List<Object> outValues = new LinkedList<>();\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                value = values.lookupOrd(ord);\n                outValues.add(schemaField.getType().toObject(schemaField, value));\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case NONE:\n          break;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bf0aa6856a12eff25ab6d79dec11bea9e4031ca2","date":1505775734,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final List<LeafReaderContext> leafContexts = searcher.getLeafContexts();\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = searcher.getSchema().getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues()) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n      FieldInfo fi = searcher.getFieldInfos().fieldInfo(fieldName);\n      if (fi == null) {\n        continue; // Searcher doesn't have info about this field, hence ignore it.\n      }\n      doc.remove(fieldName);\n      final DocValuesType dvType = fi.getDocValuesType();\n      switch (dvType) {\n        case NUMERIC:\n          final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n          if (ndv == null) {\n            continue;\n          }\n          Long val;\n          if (ndv.advanceExact(localId)) {\n            val = ndv.longValue();\n          } else {\n            continue;\n          }\n          Object newVal = val;\n          if (schemaField.getType().isPointField()) {\n            // TODO: Maybe merge PointField with TrieFields here\n            NumberType type = schemaField.getType().getNumberType();\n            switch (type) {\n              case INTEGER:\n                newVal = val.intValue();\n                break;\n              case LONG:\n                newVal = val.longValue();\n                break;\n              case FLOAT:\n                newVal = Float.intBitsToFloat(val.intValue());\n                break;\n              case DOUBLE:\n                newVal = Double.longBitsToDouble(val);\n                break;\n              case DATE:\n                newVal = new Date(val);\n                break;\n              default:\n                throw new AssertionError(\"Unexpected PointType: \" + type);\n            }\n          } else {\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof AbstractEnumField) {\n              newVal = ((AbstractEnumField)schemaField.getType()).getEnumMapping().intValueToStringValue(val.intValue());\n            }\n          }\n          doc.addField(fieldName, newVal);\n          break;\n        case BINARY:\n          BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n          if (bdv == null) {\n            continue;\n          }\n          BytesRef value;\n          if (bdv.advanceExact(localId)) {\n            value = BytesRef.deepCopyOf(bdv.binaryValue());\n          } else {\n            continue;\n          }\n          doc.addField(fieldName, value);\n          break;\n        case SORTED:\n          SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n          if (sdv == null) {\n            continue;\n          }\n          if (sdv.advanceExact(localId)) {\n            final BytesRef bRef = sdv.binaryValue();\n            // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n            if (schemaField.getType() instanceof BoolField) {\n              doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n            } else {\n              doc.addField(fieldName, bRef.utf8ToString());\n            }\n          }\n          break;\n        case SORTED_NUMERIC:\n          final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n          final NumberType type = schemaField.getType().getNumberType();\n          if (numericDv != null) {\n            if (numericDv.advance(localId) == localId) {\n              final List<Object> outValues = new ArrayList<Object>(numericDv.docValueCount());\n              for (int i = 0; i < numericDv.docValueCount(); i++) {\n                long number = numericDv.nextValue();\n                switch (type) {\n                  case INTEGER:\n                    final int raw = (int)number;\n                    if (schemaField.getType() instanceof AbstractEnumField) {\n                      outValues.add(((AbstractEnumField)schemaField.getType()).getEnumMapping().intValueToStringValue(raw));\n                    } else {\n                      outValues.add(raw);\n                    }\n                    break;\n                  case LONG:\n                    outValues.add(number);\n                    break;\n                  case FLOAT:\n                    outValues.add(NumericUtils.sortableIntToFloat((int)number));\n                    break;\n                  case DOUBLE:\n                    outValues.add(NumericUtils.sortableLongToDouble(number));\n                    break;\n                  case DATE:\n                    outValues.add(new Date(number));\n                    break;\n                  default:\n                    throw new AssertionError(\"Unexpected PointType: \" + type);\n                }\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case SORTED_SET:\n          final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n          if (values != null && values.getValueCount() > 0) {\n            if (values.advance(localId) == localId) {\n              final List<Object> outValues = new LinkedList<>();\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                value = values.lookupOrd(ord);\n                outValues.add(schemaField.getType().toObject(schemaField, value));\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case NONE:\n          break;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final List<LeafReaderContext> leafContexts = searcher.getLeafContexts();\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = searcher.getSchema().getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n      FieldInfo fi = searcher.getFieldInfos().fieldInfo(fieldName);\n      if (fi == null) {\n        continue; // Searcher doesn't have info about this field, hence ignore it.\n      }\n      final DocValuesType dvType = fi.getDocValuesType();\n      switch (dvType) {\n        case NUMERIC:\n          final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n          if (ndv == null) {\n            continue;\n          }\n          Long val;\n          if (ndv.advanceExact(localId)) {\n            val = ndv.longValue();\n          } else {\n            continue;\n          }\n          Object newVal = val;\n          if (schemaField.getType().isPointField()) {\n            // TODO: Maybe merge PointField with TrieFields here\n            NumberType type = schemaField.getType().getNumberType();\n            switch (type) {\n              case INTEGER:\n                newVal = val.intValue();\n                break;\n              case LONG:\n                newVal = val.longValue();\n                break;\n              case FLOAT:\n                newVal = Float.intBitsToFloat(val.intValue());\n                break;\n              case DOUBLE:\n                newVal = Double.longBitsToDouble(val);\n                break;\n              case DATE:\n                newVal = new Date(val);\n                break;\n              default:\n                throw new AssertionError(\"Unexpected PointType: \" + type);\n            }\n          } else {\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof AbstractEnumField) {\n              newVal = ((AbstractEnumField)schemaField.getType()).getEnumMapping().intValueToStringValue(val.intValue());\n            }\n          }\n          doc.addField(fieldName, newVal);\n          break;\n        case BINARY:\n          BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n          if (bdv == null) {\n            continue;\n          }\n          BytesRef value;\n          if (bdv.advanceExact(localId)) {\n            value = BytesRef.deepCopyOf(bdv.binaryValue());\n          } else {\n            continue;\n          }\n          doc.addField(fieldName, value);\n          break;\n        case SORTED:\n          SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n          if (sdv == null) {\n            continue;\n          }\n          if (sdv.advanceExact(localId)) {\n            final BytesRef bRef = sdv.binaryValue();\n            // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n            if (schemaField.getType() instanceof BoolField) {\n              doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n            } else {\n              doc.addField(fieldName, bRef.utf8ToString());\n            }\n          }\n          break;\n        case SORTED_NUMERIC:\n          final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n          final NumberType type = schemaField.getType().getNumberType();\n          if (numericDv != null) {\n            if (numericDv.advance(localId) == localId) {\n              final List<Object> outValues = new ArrayList<Object>(numericDv.docValueCount());\n              for (int i = 0; i < numericDv.docValueCount(); i++) {\n                long number = numericDv.nextValue();\n                switch (type) {\n                  case INTEGER:\n                    final int raw = (int)number;\n                    if (schemaField.getType() instanceof AbstractEnumField) {\n                      outValues.add(((AbstractEnumField)schemaField.getType()).getEnumMapping().intValueToStringValue(raw));\n                    } else {\n                      outValues.add(raw);\n                    }\n                    break;\n                  case LONG:\n                    outValues.add(number);\n                    break;\n                  case FLOAT:\n                    outValues.add(NumericUtils.sortableIntToFloat((int)number));\n                    break;\n                  case DOUBLE:\n                    outValues.add(NumericUtils.sortableLongToDouble(number));\n                    break;\n                  case DATE:\n                    outValues.add(new Date(number));\n                    break;\n                  default:\n                    throw new AssertionError(\"Unexpected PointType: \" + type);\n                }\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case SORTED_SET:\n          final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n          if (values != null && values.getValueCount() > 0) {\n            if (values.advance(localId) == localId) {\n              final List<Object> outValues = new LinkedList<>();\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                value = values.lookupOrd(ord);\n                outValues.add(schemaField.getType().toObject(schemaField, value));\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case NONE:\n          break;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04af4a840c8f501ba34e09e382b8f8ace82aa51e","date":1505847466,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final List<LeafReaderContext> leafContexts = searcher.getLeafContexts();\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = searcher.getSchema().getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues()) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n      FieldInfo fi = searcher.getFieldInfos().fieldInfo(fieldName);\n      if (fi == null) {\n        continue; // Searcher doesn't have info about this field, hence ignore it.\n      }\n      doc.remove(fieldName);\n      final DocValuesType dvType = fi.getDocValuesType();\n      switch (dvType) {\n        case NUMERIC:\n          final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n          if (ndv == null) {\n            continue;\n          }\n          Long val;\n          if (ndv.advanceExact(localId)) {\n            val = ndv.longValue();\n          } else {\n            continue;\n          }\n          Object newVal = val;\n          if (schemaField.getType().isPointField()) {\n            // TODO: Maybe merge PointField with TrieFields here\n            NumberType type = schemaField.getType().getNumberType();\n            switch (type) {\n              case INTEGER:\n                newVal = val.intValue();\n                break;\n              case LONG:\n                newVal = val.longValue();\n                break;\n              case FLOAT:\n                newVal = Float.intBitsToFloat(val.intValue());\n                break;\n              case DOUBLE:\n                newVal = Double.longBitsToDouble(val);\n                break;\n              case DATE:\n                newVal = new Date(val);\n                break;\n              default:\n                throw new AssertionError(\"Unexpected PointType: \" + type);\n            }\n          } else {\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof AbstractEnumField) {\n              newVal = ((AbstractEnumField)schemaField.getType()).getEnumMapping().intValueToStringValue(val.intValue());\n            }\n          }\n          doc.addField(fieldName, newVal);\n          break;\n        case BINARY:\n          BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n          if (bdv == null) {\n            continue;\n          }\n          BytesRef value;\n          if (bdv.advanceExact(localId)) {\n            value = BytesRef.deepCopyOf(bdv.binaryValue());\n          } else {\n            continue;\n          }\n          doc.addField(fieldName, value);\n          break;\n        case SORTED:\n          SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n          if (sdv == null) {\n            continue;\n          }\n          if (sdv.advanceExact(localId)) {\n            final BytesRef bRef = sdv.binaryValue();\n            // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n            if (schemaField.getType() instanceof BoolField) {\n              doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n            } else {\n              doc.addField(fieldName, bRef.utf8ToString());\n            }\n          }\n          break;\n        case SORTED_NUMERIC:\n          final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n          final NumberType type = schemaField.getType().getNumberType();\n          if (numericDv != null) {\n            if (numericDv.advance(localId) == localId) {\n              final List<Object> outValues = new ArrayList<Object>(numericDv.docValueCount());\n              for (int i = 0; i < numericDv.docValueCount(); i++) {\n                long number = numericDv.nextValue();\n                switch (type) {\n                  case INTEGER:\n                    final int raw = (int)number;\n                    if (schemaField.getType() instanceof AbstractEnumField) {\n                      outValues.add(((AbstractEnumField)schemaField.getType()).getEnumMapping().intValueToStringValue(raw));\n                    } else {\n                      outValues.add(raw);\n                    }\n                    break;\n                  case LONG:\n                    outValues.add(number);\n                    break;\n                  case FLOAT:\n                    outValues.add(NumericUtils.sortableIntToFloat((int)number));\n                    break;\n                  case DOUBLE:\n                    outValues.add(NumericUtils.sortableLongToDouble(number));\n                    break;\n                  case DATE:\n                    outValues.add(new Date(number));\n                    break;\n                  default:\n                    throw new AssertionError(\"Unexpected PointType: \" + type);\n                }\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case SORTED_SET:\n          final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n          if (values != null && values.getValueCount() > 0) {\n            if (values.advance(localId) == localId) {\n              final List<Object> outValues = new LinkedList<>();\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                value = values.lookupOrd(ord);\n                outValues.add(schemaField.getType().toObject(schemaField, value));\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case NONE:\n          break;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final List<LeafReaderContext> leafContexts = searcher.getLeafContexts();\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = searcher.getSchema().getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n      FieldInfo fi = searcher.getFieldInfos().fieldInfo(fieldName);\n      if (fi == null) {\n        continue; // Searcher doesn't have info about this field, hence ignore it.\n      }\n      final DocValuesType dvType = fi.getDocValuesType();\n      switch (dvType) {\n        case NUMERIC:\n          final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n          if (ndv == null) {\n            continue;\n          }\n          Long val;\n          if (ndv.advanceExact(localId)) {\n            val = ndv.longValue();\n          } else {\n            continue;\n          }\n          Object newVal = val;\n          if (schemaField.getType().isPointField()) {\n            // TODO: Maybe merge PointField with TrieFields here\n            NumberType type = schemaField.getType().getNumberType();\n            switch (type) {\n              case INTEGER:\n                newVal = val.intValue();\n                break;\n              case LONG:\n                newVal = val.longValue();\n                break;\n              case FLOAT:\n                newVal = Float.intBitsToFloat(val.intValue());\n                break;\n              case DOUBLE:\n                newVal = Double.longBitsToDouble(val);\n                break;\n              case DATE:\n                newVal = new Date(val);\n                break;\n              default:\n                throw new AssertionError(\"Unexpected PointType: \" + type);\n            }\n          } else {\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof AbstractEnumField) {\n              newVal = ((AbstractEnumField)schemaField.getType()).getEnumMapping().intValueToStringValue(val.intValue());\n            }\n          }\n          doc.addField(fieldName, newVal);\n          break;\n        case BINARY:\n          BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n          if (bdv == null) {\n            continue;\n          }\n          BytesRef value;\n          if (bdv.advanceExact(localId)) {\n            value = BytesRef.deepCopyOf(bdv.binaryValue());\n          } else {\n            continue;\n          }\n          doc.addField(fieldName, value);\n          break;\n        case SORTED:\n          SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n          if (sdv == null) {\n            continue;\n          }\n          if (sdv.advanceExact(localId)) {\n            final BytesRef bRef = sdv.binaryValue();\n            // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n            if (schemaField.getType() instanceof BoolField) {\n              doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n            } else {\n              doc.addField(fieldName, bRef.utf8ToString());\n            }\n          }\n          break;\n        case SORTED_NUMERIC:\n          final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n          final NumberType type = schemaField.getType().getNumberType();\n          if (numericDv != null) {\n            if (numericDv.advance(localId) == localId) {\n              final List<Object> outValues = new ArrayList<Object>(numericDv.docValueCount());\n              for (int i = 0; i < numericDv.docValueCount(); i++) {\n                long number = numericDv.nextValue();\n                switch (type) {\n                  case INTEGER:\n                    final int raw = (int)number;\n                    if (schemaField.getType() instanceof AbstractEnumField) {\n                      outValues.add(((AbstractEnumField)schemaField.getType()).getEnumMapping().intValueToStringValue(raw));\n                    } else {\n                      outValues.add(raw);\n                    }\n                    break;\n                  case LONG:\n                    outValues.add(number);\n                    break;\n                  case FLOAT:\n                    outValues.add(NumericUtils.sortableIntToFloat((int)number));\n                    break;\n                  case DOUBLE:\n                    outValues.add(NumericUtils.sortableLongToDouble(number));\n                    break;\n                  case DATE:\n                    outValues.add(new Date(number));\n                    break;\n                  default:\n                    throw new AssertionError(\"Unexpected PointType: \" + type);\n                }\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case SORTED_SET:\n          final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n          if (values != null && values.getValueCount() > 0) {\n            if (values.advance(localId) == localId) {\n              final List<Object> outValues = new LinkedList<>();\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                value = values.lookupOrd(ord);\n                outValues.add(schemaField.getType().toObject(schemaField, value));\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case NONE:\n          break;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55ac9ae04c11f9e36330ee2448ef214c4fdbfc79","date":1509089658,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The fields with docValues to populate the document with.\n   *          DocValues fields which do not exist or not decodable will be ignored.\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final List<LeafReaderContext> leafContexts = searcher.getLeafContexts();\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      Object fieldValue = decodeDVField(localId, leafReader, fieldName);\n      if (fieldValue != null) {\n        doc.setField(fieldName, fieldValue);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final List<LeafReaderContext> leafContexts = searcher.getLeafContexts();\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = searcher.getSchema().getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues()) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n      FieldInfo fi = searcher.getFieldInfos().fieldInfo(fieldName);\n      if (fi == null) {\n        continue; // Searcher doesn't have info about this field, hence ignore it.\n      }\n      doc.remove(fieldName);\n      final DocValuesType dvType = fi.getDocValuesType();\n      switch (dvType) {\n        case NUMERIC:\n          final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n          if (ndv == null) {\n            continue;\n          }\n          Long val;\n          if (ndv.advanceExact(localId)) {\n            val = ndv.longValue();\n          } else {\n            continue;\n          }\n          Object newVal = val;\n          if (schemaField.getType().isPointField()) {\n            // TODO: Maybe merge PointField with TrieFields here\n            NumberType type = schemaField.getType().getNumberType();\n            switch (type) {\n              case INTEGER:\n                newVal = val.intValue();\n                break;\n              case LONG:\n                newVal = val.longValue();\n                break;\n              case FLOAT:\n                newVal = Float.intBitsToFloat(val.intValue());\n                break;\n              case DOUBLE:\n                newVal = Double.longBitsToDouble(val);\n                break;\n              case DATE:\n                newVal = new Date(val);\n                break;\n              default:\n                throw new AssertionError(\"Unexpected PointType: \" + type);\n            }\n          } else {\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof AbstractEnumField) {\n              newVal = ((AbstractEnumField)schemaField.getType()).getEnumMapping().intValueToStringValue(val.intValue());\n            }\n          }\n          doc.addField(fieldName, newVal);\n          break;\n        case BINARY:\n          BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n          if (bdv == null) {\n            continue;\n          }\n          BytesRef value;\n          if (bdv.advanceExact(localId)) {\n            value = BytesRef.deepCopyOf(bdv.binaryValue());\n          } else {\n            continue;\n          }\n          doc.addField(fieldName, value);\n          break;\n        case SORTED:\n          SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n          if (sdv == null) {\n            continue;\n          }\n          if (sdv.advanceExact(localId)) {\n            final BytesRef bRef = sdv.binaryValue();\n            // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n            if (schemaField.getType() instanceof BoolField) {\n              doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n            } else {\n              doc.addField(fieldName, bRef.utf8ToString());\n            }\n          }\n          break;\n        case SORTED_NUMERIC:\n          final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n          final NumberType type = schemaField.getType().getNumberType();\n          if (numericDv != null) {\n            if (numericDv.advance(localId) == localId) {\n              final List<Object> outValues = new ArrayList<Object>(numericDv.docValueCount());\n              for (int i = 0; i < numericDv.docValueCount(); i++) {\n                long number = numericDv.nextValue();\n                switch (type) {\n                  case INTEGER:\n                    final int raw = (int)number;\n                    if (schemaField.getType() instanceof AbstractEnumField) {\n                      outValues.add(((AbstractEnumField)schemaField.getType()).getEnumMapping().intValueToStringValue(raw));\n                    } else {\n                      outValues.add(raw);\n                    }\n                    break;\n                  case LONG:\n                    outValues.add(number);\n                    break;\n                  case FLOAT:\n                    outValues.add(NumericUtils.sortableIntToFloat((int)number));\n                    break;\n                  case DOUBLE:\n                    outValues.add(NumericUtils.sortableLongToDouble(number));\n                    break;\n                  case DATE:\n                    outValues.add(new Date(number));\n                    break;\n                  default:\n                    throw new AssertionError(\"Unexpected PointType: \" + type);\n                }\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case SORTED_SET:\n          final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n          if (values != null && values.getValueCount() > 0) {\n            if (values.advance(localId) == localId) {\n              final List<Object> outValues = new LinkedList<>();\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                value = values.lookupOrd(ord);\n                outValues.add(schemaField.getType().toObject(schemaField, value));\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case NONE:\n          break;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"55ac9ae04c11f9e36330ee2448ef214c4fdbfc79":["bf0aa6856a12eff25ab6d79dec11bea9e4031ca2"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["de548de3ce5405595899f548152d4b93ac9eb9cc","54ad8c9e9210e008dc7b8ad5a037ff20879150ea"],"04af4a840c8f501ba34e09e382b8f8ace82aa51e":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","bf0aa6856a12eff25ab6d79dec11bea9e4031ca2"],"de548de3ce5405595899f548152d4b93ac9eb9cc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"bf0aa6856a12eff25ab6d79dec11bea9e4031ca2":["54ad8c9e9210e008dc7b8ad5a037ff20879150ea"],"63a9344cff6a72bc4c1ef080c69e10ad0635b811":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"54ad8c9e9210e008dc7b8ad5a037ff20879150ea":["63a9344cff6a72bc4c1ef080c69e10ad0635b811"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["55ac9ae04c11f9e36330ee2448ef214c4fdbfc79"]},"commit2Childs":{"55ac9ae04c11f9e36330ee2448ef214c4fdbfc79":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["04af4a840c8f501ba34e09e382b8f8ace82aa51e"],"04af4a840c8f501ba34e09e382b8f8ace82aa51e":[],"de548de3ce5405595899f548152d4b93ac9eb9cc":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"bf0aa6856a12eff25ab6d79dec11bea9e4031ca2":["55ac9ae04c11f9e36330ee2448ef214c4fdbfc79","04af4a840c8f501ba34e09e382b8f8ace82aa51e"],"63a9344cff6a72bc4c1ef080c69e10ad0635b811":["54ad8c9e9210e008dc7b8ad5a037ff20879150ea"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["de548de3ce5405595899f548152d4b93ac9eb9cc","63a9344cff6a72bc4c1ef080c69e10ad0635b811"],"54ad8c9e9210e008dc7b8ad5a037ff20879150ea":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","bf0aa6856a12eff25ab6d79dec11bea9e4031ca2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["04af4a840c8f501ba34e09e382b8f8ace82aa51e","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}