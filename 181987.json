{"path":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"/dev/null","sourceNew":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (params.getBool(TermsParams.TERMS, false)) {\n      String lowerStr = params.get(TermsParams.TERMS_LOWER, null);\n      String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n      if (fields != null && fields.length > 0) {\n        NamedList terms = new NamedList();\n        rb.rsp.add(\"terms\", terms);\n        int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n        if (limit < 0) {\n          limit = Integer.MAX_VALUE;\n        }\n        String upperStr = params.get(TermsParams.TERMS_UPPER);\n        boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n        boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n        boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n                          params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n        int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1); // initialize freqmin\n        int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT); // initialize freqmax\n        if (freqmax<0) {\n          freqmax = Integer.MAX_VALUE;\n        }\n        String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n        String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n        Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n        boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n        for (int j = 0; j < fields.length; j++) {\n          String field = StringHelper.intern(fields[j]);\n          FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n          if (ft==null) ft = new StrField();\n\n          // If no lower bound was specified, use the prefix\n          String lower = lowerStr==null ? prefix : (raw ? lowerStr : ft.toInternal(lowerStr));\n          if (lower == null) lower=\"\";\n          String upper = upperStr==null ? null : (raw ? upperStr : ft.toInternal(upperStr));\n\n          Term lowerTerm = new Term(field, lower);\n          Term upperTerm = upper==null ? null : new Term(field, upper);\n          \n          TermEnum termEnum = rb.req.getSearcher().getReader().terms(lowerTerm); //this will be positioned ready to go\n          int i = 0;\n          BoundedTreeSet<CountPair<String, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<String, Integer>>(limit) : null); \n          NamedList fieldTerms = new NamedList();\n          terms.add(field, fieldTerms);\n          Term lowerTestTerm = termEnum.term();\n\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerTestTerm!=null && lowerIncl == false && lowerTestTerm.field() == field  // intern'd comparison\n                  && lowerTestTerm.text().equals(lower)) {\n            termEnum.next();\n          }\n\n          while (i<limit || sort) {\n\n            Term theTerm = termEnum.term();\n\n            // check for a different field, or the end of the index.\n            if (theTerm==null || field != theTerm.field())  // intern'd comparison\n              break;\n\n            String indexedText = theTerm.text();\n\n            // stop if the prefix doesn't match\n            if (prefix != null && !indexedText.startsWith(prefix)) break;\n\n            if (pattern != null && !pattern.matcher(indexedText).matches()) {\n                termEnum.next();\n                continue;\n            }\n\n            if (upperTerm != null) {\n              int upperCmp = theTerm.compareTo(upperTerm);\n              // if we are past the upper term, or equal to it (when don't include upper) then stop.\n              if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n            }\n\n            // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n            int docFreq = termEnum.docFreq();\n            if (docFreq >= freqmin && docFreq <= freqmax) {\n              // add the term to the list\n              String label = raw ? indexedText : ft.indexedToReadable(indexedText);\n              if (sort) {\n                queue.add(new CountPair<String, Integer>(label, docFreq));\n              } else {\n                fieldTerms.add(label, docFreq);\n                i++;\n              }\n            }\n\n            termEnum.next();\n          }\n\n          termEnum.close();\n          \n          if (sort) {\n            for (CountPair<String, Integer> item : queue) {\n              if (i < limit) {\n                fieldTerms.add(item.key, item.val);\n                i++;\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No terms.fl parameter specified\");\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":null,"sourceOld":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (params.getBool(TermsParams.TERMS, false)) {\n      String lowerStr = params.get(TermsParams.TERMS_LOWER, null);\n      String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n      if (fields != null && fields.length > 0) {\n        NamedList terms = new NamedList();\n        rb.rsp.add(\"terms\", terms);\n        int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n        if (limit < 0) {\n          limit = Integer.MAX_VALUE;\n        }\n        String upperStr = params.get(TermsParams.TERMS_UPPER);\n        boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n        boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n        boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n                          params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n        int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1); // initialize freqmin\n        int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT); // initialize freqmax\n        if (freqmax<0) {\n          freqmax = Integer.MAX_VALUE;\n        }\n        String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n        String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n        Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n        boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n        for (int j = 0; j < fields.length; j++) {\n          String field = StringHelper.intern(fields[j]);\n          FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n          if (ft==null) ft = new StrField();\n\n          // If no lower bound was specified, use the prefix\n          String lower = lowerStr==null ? prefix : (raw ? lowerStr : ft.toInternal(lowerStr));\n          if (lower == null) lower=\"\";\n          String upper = upperStr==null ? null : (raw ? upperStr : ft.toInternal(upperStr));\n\n          Term lowerTerm = new Term(field, lower);\n          Term upperTerm = upper==null ? null : new Term(field, upper);\n          \n          TermEnum termEnum = rb.req.getSearcher().getReader().terms(lowerTerm); //this will be positioned ready to go\n          int i = 0;\n          BoundedTreeSet<CountPair<String, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<String, Integer>>(limit) : null); \n          NamedList fieldTerms = new NamedList();\n          terms.add(field, fieldTerms);\n          Term lowerTestTerm = termEnum.term();\n\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerTestTerm!=null && lowerIncl == false && lowerTestTerm.field() == field  // intern'd comparison\n                  && lowerTestTerm.text().equals(lower)) {\n            termEnum.next();\n          }\n\n          while (i<limit || sort) {\n\n            Term theTerm = termEnum.term();\n\n            // check for a different field, or the end of the index.\n            if (theTerm==null || field != theTerm.field())  // intern'd comparison\n              break;\n\n            String indexedText = theTerm.text();\n\n            // stop if the prefix doesn't match\n            if (prefix != null && !indexedText.startsWith(prefix)) break;\n\n            if (pattern != null && !pattern.matcher(indexedText).matches()) {\n                termEnum.next();\n                continue;\n            }\n\n            if (upperTerm != null) {\n              int upperCmp = theTerm.compareTo(upperTerm);\n              // if we are past the upper term, or equal to it (when don't include upper) then stop.\n              if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n            }\n\n            // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n            int docFreq = termEnum.docFreq();\n            if (docFreq >= freqmin && docFreq <= freqmax) {\n              // add the term to the list\n              String label = raw ? indexedText : ft.indexedToReadable(indexedText);\n              if (sort) {\n                queue.add(new CountPair<String, Integer>(label, docFreq));\n              } else {\n                fieldTerms.add(label, docFreq);\n                i++;\n              }\n            }\n\n            termEnum.next();\n          }\n\n          termEnum.close();\n          \n          if (sort) {\n            for (CountPair<String, Integer> item : queue) {\n              if (i < limit) {\n                fieldTerms.add(item.key, item.val);\n                i++;\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No terms.fl parameter specified\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (params.getBool(TermsParams.TERMS, false)) {\n      String lowerStr = params.get(TermsParams.TERMS_LOWER, null);\n      String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n      if (fields != null && fields.length > 0) {\n        NamedList terms = new NamedList();\n        rb.rsp.add(\"terms\", terms);\n        int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n        if (limit < 0) {\n          limit = Integer.MAX_VALUE;\n        }\n        String upperStr = params.get(TermsParams.TERMS_UPPER);\n        boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n        boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n        boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n                          params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n        int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1); // initialize freqmin\n        int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT); // initialize freqmax\n        if (freqmax<0) {\n          freqmax = Integer.MAX_VALUE;\n        }\n        String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n        String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n        Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n        boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n        for (int j = 0; j < fields.length; j++) {\n          String field = StringHelper.intern(fields[j]);\n          FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n          if (ft==null) ft = new StrField();\n\n          // If no lower bound was specified, use the prefix\n          String lower = lowerStr==null ? prefix : (raw ? lowerStr : ft.toInternal(lowerStr));\n          if (lower == null) lower=\"\";\n          String upper = upperStr==null ? null : (raw ? upperStr : ft.toInternal(upperStr));\n\n          Term lowerTerm = new Term(field, lower);\n          Term upperTerm = upper==null ? null : new Term(field, upper);\n          \n          TermEnum termEnum = rb.req.getSearcher().getReader().terms(lowerTerm); //this will be positioned ready to go\n          int i = 0;\n          BoundedTreeSet<CountPair<String, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<String, Integer>>(limit) : null); \n          NamedList fieldTerms = new NamedList();\n          terms.add(field, fieldTerms);\n          Term lowerTestTerm = termEnum.term();\n\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerTestTerm!=null && lowerIncl == false && lowerTestTerm.field() == field  // intern'd comparison\n                  && lowerTestTerm.text().equals(lower)) {\n            termEnum.next();\n          }\n\n          while (i<limit || sort) {\n\n            Term theTerm = termEnum.term();\n\n            // check for a different field, or the end of the index.\n            if (theTerm==null || field != theTerm.field())  // intern'd comparison\n              break;\n\n            String indexedText = theTerm.text();\n\n            // stop if the prefix doesn't match\n            if (prefix != null && !indexedText.startsWith(prefix)) break;\n\n            if (pattern != null && !pattern.matcher(indexedText).matches()) {\n                termEnum.next();\n                continue;\n            }\n\n            if (upperTerm != null) {\n              int upperCmp = theTerm.compareTo(upperTerm);\n              // if we are past the upper term, or equal to it (when don't include upper) then stop.\n              if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n            }\n\n            // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n            int docFreq = termEnum.docFreq();\n            if (docFreq >= freqmin && docFreq <= freqmax) {\n              // add the term to the list\n              String label = raw ? indexedText : ft.indexedToReadable(indexedText);\n              if (sort) {\n                queue.add(new CountPair<String, Integer>(label, docFreq));\n              } else {\n                fieldTerms.add(label, docFreq);\n                i++;\n              }\n            }\n\n            termEnum.next();\n          }\n\n          termEnum.close();\n          \n          if (sort) {\n            for (CountPair<String, Integer> item : queue) {\n              if (i < limit) {\n                fieldTerms.add(item.key, item.val);\n                i++;\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No terms.fl parameter specified\");\n      }\n    }\n  }\n\n","sourceOld":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (params.getBool(TermsParams.TERMS, false)) {\n      String lowerStr = params.get(TermsParams.TERMS_LOWER, null);\n      String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n      if (fields != null && fields.length > 0) {\n        NamedList terms = new NamedList();\n        rb.rsp.add(\"terms\", terms);\n        int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n        if (limit < 0) {\n          limit = Integer.MAX_VALUE;\n        }\n        String upperStr = params.get(TermsParams.TERMS_UPPER);\n        boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n        boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n        boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n                          params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n        int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1); // initialize freqmin\n        int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT); // initialize freqmax\n        if (freqmax<0) {\n          freqmax = Integer.MAX_VALUE;\n        }\n        String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n        String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n        Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n        boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n        for (int j = 0; j < fields.length; j++) {\n          String field = StringHelper.intern(fields[j]);\n          FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n          if (ft==null) ft = new StrField();\n\n          // If no lower bound was specified, use the prefix\n          String lower = lowerStr==null ? prefix : (raw ? lowerStr : ft.toInternal(lowerStr));\n          if (lower == null) lower=\"\";\n          String upper = upperStr==null ? null : (raw ? upperStr : ft.toInternal(upperStr));\n\n          Term lowerTerm = new Term(field, lower);\n          Term upperTerm = upper==null ? null : new Term(field, upper);\n          \n          TermEnum termEnum = rb.req.getSearcher().getReader().terms(lowerTerm); //this will be positioned ready to go\n          int i = 0;\n          BoundedTreeSet<CountPair<String, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<String, Integer>>(limit) : null); \n          NamedList fieldTerms = new NamedList();\n          terms.add(field, fieldTerms);\n          Term lowerTestTerm = termEnum.term();\n\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerTestTerm!=null && lowerIncl == false && lowerTestTerm.field() == field  // intern'd comparison\n                  && lowerTestTerm.text().equals(lower)) {\n            termEnum.next();\n          }\n\n          while (i<limit || sort) {\n\n            Term theTerm = termEnum.term();\n\n            // check for a different field, or the end of the index.\n            if (theTerm==null || field != theTerm.field())  // intern'd comparison\n              break;\n\n            String indexedText = theTerm.text();\n\n            // stop if the prefix doesn't match\n            if (prefix != null && !indexedText.startsWith(prefix)) break;\n\n            if (pattern != null && !pattern.matcher(indexedText).matches()) {\n                termEnum.next();\n                continue;\n            }\n\n            if (upperTerm != null) {\n              int upperCmp = theTerm.compareTo(upperTerm);\n              // if we are past the upper term, or equal to it (when don't include upper) then stop.\n              if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n            }\n\n            // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n            int docFreq = termEnum.docFreq();\n            if (docFreq >= freqmin && docFreq <= freqmax) {\n              // add the term to the list\n              String label = raw ? indexedText : ft.indexedToReadable(indexedText);\n              if (sort) {\n                queue.add(new CountPair<String, Integer>(label, docFreq));\n              } else {\n                fieldTerms.add(label, docFreq);\n                i++;\n              }\n            }\n\n            termEnum.next();\n          }\n\n          termEnum.close();\n          \n          if (sort) {\n            for (CountPair<String, Integer> item : queue) {\n              if (i < limit) {\n                fieldTerms.add(item.key, item.val);\n                i++;\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No terms.fl parameter specified\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da8d55113b689b06716246649de6f62430f15c0","date":1453508340,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"/dev/null","sourceNew":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (params.getBool(TermsParams.TERMS, false)) {\n      String lowerStr = params.get(TermsParams.TERMS_LOWER, null);\n      String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n      if (fields != null && fields.length > 0) {\n        NamedList terms = new NamedList();\n        rb.rsp.add(\"terms\", terms);\n        int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n        if (limit < 0) {\n          limit = Integer.MAX_VALUE;\n        }\n        String upperStr = params.get(TermsParams.TERMS_UPPER);\n        boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n        boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n        boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n                          params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n        int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1); // initialize freqmin\n        int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT); // initialize freqmax\n        if (freqmax<0) {\n          freqmax = Integer.MAX_VALUE;\n        }\n        String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n        String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n        Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n        boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n        for (int j = 0; j < fields.length; j++) {\n          String field = StringHelper.intern(fields[j]);\n          FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n          if (ft==null) ft = new StrField();\n\n          // If no lower bound was specified, use the prefix\n          String lower = lowerStr==null ? prefix : (raw ? lowerStr : ft.toInternal(lowerStr));\n          if (lower == null) lower=\"\";\n          String upper = upperStr==null ? null : (raw ? upperStr : ft.toInternal(upperStr));\n\n          Term lowerTerm = new Term(field, lower);\n          Term upperTerm = upper==null ? null : new Term(field, upper);\n          \n          TermEnum termEnum = rb.req.getSearcher().getReader().terms(lowerTerm); //this will be positioned ready to go\n          int i = 0;\n          BoundedTreeSet<CountPair<String, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<String, Integer>>(limit) : null); \n          NamedList fieldTerms = new NamedList();\n          terms.add(field, fieldTerms);\n          Term lowerTestTerm = termEnum.term();\n\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerTestTerm!=null && lowerIncl == false && lowerTestTerm.field() == field  // intern'd comparison\n                  && lowerTestTerm.text().equals(lower)) {\n            termEnum.next();\n          }\n\n          while (i<limit || sort) {\n\n            Term theTerm = termEnum.term();\n\n            // check for a different field, or the end of the index.\n            if (theTerm==null || field != theTerm.field())  // intern'd comparison\n              break;\n\n            String indexedText = theTerm.text();\n\n            // stop if the prefix doesn't match\n            if (prefix != null && !indexedText.startsWith(prefix)) break;\n\n            if (pattern != null && !pattern.matcher(indexedText).matches()) {\n                termEnum.next();\n                continue;\n            }\n\n            if (upperTerm != null) {\n              int upperCmp = theTerm.compareTo(upperTerm);\n              // if we are past the upper term, or equal to it (when don't include upper) then stop.\n              if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n            }\n\n            // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n            int docFreq = termEnum.docFreq();\n            if (docFreq >= freqmin && docFreq <= freqmax) {\n              // add the term to the list\n              String label = raw ? indexedText : ft.indexedToReadable(indexedText);\n              if (sort) {\n                queue.add(new CountPair<String, Integer>(label, docFreq));\n              } else {\n                fieldTerms.add(label, docFreq);\n                i++;\n              }\n            }\n\n            termEnum.next();\n          }\n\n          termEnum.close();\n          \n          if (sort) {\n            for (CountPair<String, Integer> item : queue) {\n              if (i < limit) {\n                fieldTerms.add(item.key, item.val);\n                i++;\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No terms.fl parameter specified\");\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e7a8029f5e27d48c778b620cdd66b2a8d8370bda","date":1269542306,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (params.getBool(TermsParams.TERMS, false)) {\n      String lowerStr = params.get(TermsParams.TERMS_LOWER, null);\n      String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n      if (fields != null && fields.length > 0) {\n        NamedList terms = new SimpleOrderedMap();\n        rb.rsp.add(\"terms\", terms);\n        int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n        if (limit < 0) {\n          limit = Integer.MAX_VALUE;\n        }\n        String upperStr = params.get(TermsParams.TERMS_UPPER);\n        boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n        boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n        boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n                          params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n        int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1); // initialize freqmin\n        int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT); // initialize freqmax\n        if (freqmax<0) {\n          freqmax = Integer.MAX_VALUE;\n        }\n        String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n        String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n        Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n        boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n        for (int j = 0; j < fields.length; j++) {\n          String field = StringHelper.intern(fields[j]);\n          FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n          if (ft==null) ft = new StrField();\n\n          // If no lower bound was specified, use the prefix\n          String lower = lowerStr==null ? prefix : (raw ? lowerStr : ft.toInternal(lowerStr));\n          if (lower == null) lower=\"\";\n          String upper = upperStr==null ? null : (raw ? upperStr : ft.toInternal(upperStr));\n\n          Term lowerTerm = new Term(field, lower);\n          Term upperTerm = upper==null ? null : new Term(field, upper);\n          \n          TermEnum termEnum = rb.req.getSearcher().getReader().terms(lowerTerm); //this will be positioned ready to go\n          int i = 0;\n          BoundedTreeSet<CountPair<String, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<String, Integer>>(limit) : null); \n          NamedList fieldTerms = new NamedList();\n          terms.add(field, fieldTerms);\n          Term lowerTestTerm = termEnum.term();\n\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerTestTerm!=null && lowerIncl == false && lowerTestTerm.field() == field  // intern'd comparison\n                  && lowerTestTerm.text().equals(lower)) {\n            termEnum.next();\n          }\n\n          while (i<limit || sort) {\n\n            Term theTerm = termEnum.term();\n\n            // check for a different field, or the end of the index.\n            if (theTerm==null || field != theTerm.field())  // intern'd comparison\n              break;\n\n            String indexedText = theTerm.text();\n\n            // stop if the prefix doesn't match\n            if (prefix != null && !indexedText.startsWith(prefix)) break;\n\n            if (pattern != null && !pattern.matcher(indexedText).matches()) {\n                termEnum.next();\n                continue;\n            }\n\n            if (upperTerm != null) {\n              int upperCmp = theTerm.compareTo(upperTerm);\n              // if we are past the upper term, or equal to it (when don't include upper) then stop.\n              if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n            }\n\n            // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n            int docFreq = termEnum.docFreq();\n            if (docFreq >= freqmin && docFreq <= freqmax) {\n              // add the term to the list\n              String label = raw ? indexedText : ft.indexedToReadable(indexedText);\n              if (sort) {\n                queue.add(new CountPair<String, Integer>(label, docFreq));\n              } else {\n                fieldTerms.add(label, docFreq);\n                i++;\n              }\n            }\n\n            termEnum.next();\n          }\n\n          termEnum.close();\n          \n          if (sort) {\n            for (CountPair<String, Integer> item : queue) {\n              if (i < limit) {\n                fieldTerms.add(item.key, item.val);\n                i++;\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No terms.fl parameter specified\");\n      }\n    }\n  }\n\n","sourceOld":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (params.getBool(TermsParams.TERMS, false)) {\n      String lowerStr = params.get(TermsParams.TERMS_LOWER, null);\n      String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n      if (fields != null && fields.length > 0) {\n        NamedList terms = new NamedList();\n        rb.rsp.add(\"terms\", terms);\n        int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n        if (limit < 0) {\n          limit = Integer.MAX_VALUE;\n        }\n        String upperStr = params.get(TermsParams.TERMS_UPPER);\n        boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n        boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n        boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n                          params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n        int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1); // initialize freqmin\n        int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT); // initialize freqmax\n        if (freqmax<0) {\n          freqmax = Integer.MAX_VALUE;\n        }\n        String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n        String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n        Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n        boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n        for (int j = 0; j < fields.length; j++) {\n          String field = StringHelper.intern(fields[j]);\n          FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n          if (ft==null) ft = new StrField();\n\n          // If no lower bound was specified, use the prefix\n          String lower = lowerStr==null ? prefix : (raw ? lowerStr : ft.toInternal(lowerStr));\n          if (lower == null) lower=\"\";\n          String upper = upperStr==null ? null : (raw ? upperStr : ft.toInternal(upperStr));\n\n          Term lowerTerm = new Term(field, lower);\n          Term upperTerm = upper==null ? null : new Term(field, upper);\n          \n          TermEnum termEnum = rb.req.getSearcher().getReader().terms(lowerTerm); //this will be positioned ready to go\n          int i = 0;\n          BoundedTreeSet<CountPair<String, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<String, Integer>>(limit) : null); \n          NamedList fieldTerms = new NamedList();\n          terms.add(field, fieldTerms);\n          Term lowerTestTerm = termEnum.term();\n\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerTestTerm!=null && lowerIncl == false && lowerTestTerm.field() == field  // intern'd comparison\n                  && lowerTestTerm.text().equals(lower)) {\n            termEnum.next();\n          }\n\n          while (i<limit || sort) {\n\n            Term theTerm = termEnum.term();\n\n            // check for a different field, or the end of the index.\n            if (theTerm==null || field != theTerm.field())  // intern'd comparison\n              break;\n\n            String indexedText = theTerm.text();\n\n            // stop if the prefix doesn't match\n            if (prefix != null && !indexedText.startsWith(prefix)) break;\n\n            if (pattern != null && !pattern.matcher(indexedText).matches()) {\n                termEnum.next();\n                continue;\n            }\n\n            if (upperTerm != null) {\n              int upperCmp = theTerm.compareTo(upperTerm);\n              // if we are past the upper term, or equal to it (when don't include upper) then stop.\n              if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n            }\n\n            // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n            int docFreq = termEnum.docFreq();\n            if (docFreq >= freqmin && docFreq <= freqmax) {\n              // add the term to the list\n              String label = raw ? indexedText : ft.indexedToReadable(indexedText);\n              if (sort) {\n                queue.add(new CountPair<String, Integer>(label, docFreq));\n              } else {\n                fieldTerms.add(label, docFreq);\n                i++;\n              }\n            }\n\n            termEnum.next();\n          }\n\n          termEnum.close();\n          \n          if (sort) {\n            for (CountPair<String, Integer> item : queue) {\n              if (i < limit) {\n                fieldTerms.add(item.key, item.val);\n                i++;\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No terms.fl parameter specified\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e03427f33820a2bde791de703292dcdfe2d6bdd6","date":1274819813,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList termsResult = new SimpleOrderedMap();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    SolrIndexReader sr = rb.req.getSearcher().getReader();\n    Fields lfields = MultiFields.getFields(sr);\n\n    for (String field : fields) {\n      NamedList fieldTerms = new NamedList();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seek(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<String, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<String, Integer>>(limit) : null);\n      CharArr external = new CharArr();\n\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          external.reset();\n          ft.indexedToReadable(term, external);\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n\n          // TODO: handle raw somehow\n          if (!externalized) {\n            external.reset();\n            ft.indexedToReadable(term, external);                        \n          }\n\n          String label = external.toString();\n          if (sort) {\n            // TODO: defer conversion to string until the end...\n            // using the label now is a bug since tiebreak will not be in index order\n            queue.add(new CountPair<String, Integer>(label, docFreq));\n          } else {\n            fieldTerms.add(label, docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<String, Integer> item : queue) {\n          if (i >= limit) break;\n          fieldTerms.add(item.key, item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (params.getBool(TermsParams.TERMS, false)) {\n      String lowerStr = params.get(TermsParams.TERMS_LOWER, null);\n      String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n      if (fields != null && fields.length > 0) {\n        NamedList terms = new SimpleOrderedMap();\n        rb.rsp.add(\"terms\", terms);\n        int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n        if (limit < 0) {\n          limit = Integer.MAX_VALUE;\n        }\n        String upperStr = params.get(TermsParams.TERMS_UPPER);\n        boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n        boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n        boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n                          params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n        int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1); // initialize freqmin\n        int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT); // initialize freqmax\n        if (freqmax<0) {\n          freqmax = Integer.MAX_VALUE;\n        }\n        String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n        String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n        Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n        boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n        for (int j = 0; j < fields.length; j++) {\n          String field = StringHelper.intern(fields[j]);\n          FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n          if (ft==null) ft = new StrField();\n\n          // If no lower bound was specified, use the prefix\n          String lower = lowerStr==null ? prefix : (raw ? lowerStr : ft.toInternal(lowerStr));\n          if (lower == null) lower=\"\";\n          String upper = upperStr==null ? null : (raw ? upperStr : ft.toInternal(upperStr));\n\n          Term lowerTerm = new Term(field, lower);\n          Term upperTerm = upper==null ? null : new Term(field, upper);\n          \n          TermEnum termEnum = rb.req.getSearcher().getReader().terms(lowerTerm); //this will be positioned ready to go\n          int i = 0;\n          BoundedTreeSet<CountPair<String, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<String, Integer>>(limit) : null); \n          NamedList fieldTerms = new NamedList();\n          terms.add(field, fieldTerms);\n          Term lowerTestTerm = termEnum.term();\n\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerTestTerm!=null && lowerIncl == false && lowerTestTerm.field() == field  // intern'd comparison\n                  && lowerTestTerm.text().equals(lower)) {\n            termEnum.next();\n          }\n\n          while (i<limit || sort) {\n\n            Term theTerm = termEnum.term();\n\n            // check for a different field, or the end of the index.\n            if (theTerm==null || field != theTerm.field())  // intern'd comparison\n              break;\n\n            String indexedText = theTerm.text();\n\n            // stop if the prefix doesn't match\n            if (prefix != null && !indexedText.startsWith(prefix)) break;\n\n            if (pattern != null && !pattern.matcher(indexedText).matches()) {\n                termEnum.next();\n                continue;\n            }\n\n            if (upperTerm != null) {\n              int upperCmp = theTerm.compareTo(upperTerm);\n              // if we are past the upper term, or equal to it (when don't include upper) then stop.\n              if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n            }\n\n            // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n            int docFreq = termEnum.docFreq();\n            if (docFreq >= freqmin && docFreq <= freqmax) {\n              // add the term to the list\n              String label = raw ? indexedText : ft.indexedToReadable(indexedText);\n              if (sort) {\n                queue.add(new CountPair<String, Integer>(label, docFreq));\n              } else {\n                fieldTerms.add(label, docFreq);\n                i++;\n              }\n            }\n\n            termEnum.next();\n          }\n\n          termEnum.close();\n          \n          if (sort) {\n            for (CountPair<String, Integer> item : queue) {\n              if (i < limit) {\n                fieldTerms.add(item.key, item.val);\n                i++;\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No terms.fl parameter specified\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["8028ab7a24273833d53d35eb160dba5b57283cf5","8028ab7a24273833d53d35eb160dba5b57283cf5","8028ab7a24273833d53d35eb160dba5b57283cf5","a45ddee14ecadf18bc50fff428911687afb4745d","a45ddee14ecadf18bc50fff428911687afb4745d","a45ddee14ecadf18bc50fff428911687afb4745d","7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","79c4ed12556e6c87ce3972fad8b9ae2376ec2c2e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"79c4ed12556e6c87ce3972fad8b9ae2376ec2c2e","date":1274842979,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList termsResult = new SimpleOrderedMap();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    SolrIndexReader sr = rb.req.getSearcher().getReader();\n    Fields lfields = MultiFields.getFields(sr);\n\n    for (String field : fields) {\n      NamedList fieldTerms = new NamedList();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seek(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharArr external = new CharArr();\n\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          external.reset();\n          ft.indexedToReadable(term, external);\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              external.reset();\n              ft.indexedToReadable(term, external);\n            }\n            String label = external.toString();\n            \n\n            fieldTerms.add(label, docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          external.reset();\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList termsResult = new SimpleOrderedMap();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    SolrIndexReader sr = rb.req.getSearcher().getReader();\n    Fields lfields = MultiFields.getFields(sr);\n\n    for (String field : fields) {\n      NamedList fieldTerms = new NamedList();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seek(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<String, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<String, Integer>>(limit) : null);\n      CharArr external = new CharArr();\n\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          external.reset();\n          ft.indexedToReadable(term, external);\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n\n          // TODO: handle raw somehow\n          if (!externalized) {\n            external.reset();\n            ft.indexedToReadable(term, external);                        \n          }\n\n          String label = external.toString();\n          if (sort) {\n            // TODO: defer conversion to string until the end...\n            // using the label now is a bug since tiebreak will not be in index order\n            queue.add(new CountPair<String, Integer>(label, docFreq));\n          } else {\n            fieldTerms.add(label, docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<String, Integer> item : queue) {\n          if (i >= limit) break;\n          fieldTerms.add(item.key, item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":["e03427f33820a2bde791de703292dcdfe2d6bdd6"],"bugIntro":["a45ddee14ecadf18bc50fff428911687afb4745d","a45ddee14ecadf18bc50fff428911687afb4745d","a45ddee14ecadf18bc50fff428911687afb4745d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fba2d2f1d5c0627026d5c26df8daac1ee3a4a0bd","date":1284057378,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList termsResult = new SimpleOrderedMap();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    SolrIndexReader sr = rb.req.getSearcher().getReader();\n    Fields lfields = MultiFields.getFields(sr);\n\n    for (String field : fields) {\n      NamedList fieldTerms = new NamedList();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seek(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharArr external = new CharArr();\n\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          external.reset();\n          ft.indexedToReadable(term, external);\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              external.reset();\n              ft.indexedToReadable(term, external);\n            }\n            String label = external.toString();\n            \n\n            fieldTerms.add(label, docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          external.reset();\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList termsResult = new SimpleOrderedMap();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    SolrIndexReader sr = rb.req.getSearcher().getReader();\n    Fields lfields = MultiFields.getFields(sr);\n\n    for (String field : fields) {\n      NamedList fieldTerms = new NamedList();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seek(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharArr external = new CharArr();\n\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          external.reset();\n          ft.indexedToReadable(term, external);\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              external.reset();\n              ft.indexedToReadable(term, external);\n            }\n            String label = external.toString();\n            \n\n            fieldTerms.add(label, docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          external.reset();\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["8028ab7a24273833d53d35eb160dba5b57283cf5","8028ab7a24273833d53d35eb160dba5b57283cf5","8028ab7a24273833d53d35eb160dba5b57283cf5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList termsResult = new SimpleOrderedMap();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    SolrIndexReader sr = rb.req.getSearcher().getReader();\n    Fields lfields = MultiFields.getFields(sr);\n\n    for (String field : fields) {\n      NamedList fieldTerms = new NamedList();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seek(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharArr external = new CharArr();\n\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          external.reset();\n          ft.indexedToReadable(term, external);\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              external.reset();\n              ft.indexedToReadable(term, external);\n            }\n            String label = external.toString();\n            \n\n            fieldTerms.add(label, docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          external.reset();\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList termsResult = new SimpleOrderedMap();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    SolrIndexReader sr = rb.req.getSearcher().getReader();\n    Fields lfields = MultiFields.getFields(sr);\n\n    for (String field : fields) {\n      NamedList fieldTerms = new NamedList();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seek(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharArr external = new CharArr();\n\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          external.reset();\n          ft.indexedToReadable(term, external);\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              external.reset();\n              ft.indexedToReadable(term, external);\n            }\n            String label = external.toString();\n            \n\n            fieldTerms.add(label, docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          external.reset();\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"755f2f419306d7297c8feee10d1897addf4b2dd0","date":1294442354,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    SolrIndexReader sr = rb.req.getSearcher().getReader();\n    Fields lfields = MultiFields.getFields(sr);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seek(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharArr external = new CharArr();\n\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          external.reset();\n          ft.indexedToReadable(term, external);\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              external.reset();\n              ft.indexedToReadable(term, external);\n            }\n            String label = external.toString();\n            \n\n            fieldTerms.add(label, docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          external.reset();\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList termsResult = new SimpleOrderedMap();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    SolrIndexReader sr = rb.req.getSearcher().getReader();\n    Fields lfields = MultiFields.getFields(sr);\n\n    for (String field : fields) {\n      NamedList fieldTerms = new NamedList();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seek(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharArr external = new CharArr();\n\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          external.reset();\n          ft.indexedToReadable(term, external);\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              external.reset();\n              ft.indexedToReadable(term, external);\n            }\n            String label = external.toString();\n            \n\n            fieldTerms.add(label, docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          external.reset();\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"323f871ffe96b871d8c534a614be60751bb023c2","date":1294820532,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seek(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharArr external = new CharArr();\n\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          external.reset();\n          ft.indexedToReadable(term, external);\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              external.reset();\n              ft.indexedToReadable(term, external);\n            }\n            String label = external.toString();\n            \n\n            fieldTerms.add(label, docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          external.reset();\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    SolrIndexReader sr = rb.req.getSearcher().getReader();\n    Fields lfields = MultiFields.getFields(sr);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seek(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharArr external = new CharArr();\n\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          external.reset();\n          ft.indexedToReadable(term, external);\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              external.reset();\n              ft.indexedToReadable(term, external);\n            }\n            String label = external.toString();\n            \n\n            fieldTerms.add(label, docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          external.reset();\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seek(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharArr external = new CharArr();\n\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          external.reset();\n          ft.indexedToReadable(term, external);\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              external.reset();\n              ft.indexedToReadable(term, external);\n            }\n            String label = external.toString();\n            \n\n            fieldTerms.add(label, docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          external.reset();\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList termsResult = new SimpleOrderedMap();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    SolrIndexReader sr = rb.req.getSearcher().getReader();\n    Fields lfields = MultiFields.getFields(sr);\n\n    for (String field : fields) {\n      NamedList fieldTerms = new NamedList();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seek(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharArr external = new CharArr();\n\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          external.reset();\n          ft.indexedToReadable(term, external);\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              external.reset();\n              ft.indexedToReadable(term, external);\n            }\n            String label = external.toString();\n            \n\n            fieldTerms.add(label, docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          external.reset();\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01","date":1296400215,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seek(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharArr external = new CharArr();\n\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          external.reset();\n          ft.indexedToReadable(term, external);\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              external.reset();\n              ft.indexedToReadable(term, external);\n            }\n            String label = external.toString();\n            \n\n            fieldTerms.add(label, docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          external.reset();\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seek(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharArr external = new CharArr();\n\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          external.reset();\n          ft.indexedToReadable(term, external);\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              external.reset();\n              ft.indexedToReadable(term, external);\n            }\n            String label = external.toString();\n            \n\n            fieldTerms.add(label, docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          external.reset();\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seek(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharArr external = new CharArr();\n\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          external.reset();\n          ft.indexedToReadable(term, external);\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              external.reset();\n              ft.indexedToReadable(term, external);\n            }\n            String label = external.toString();\n            \n\n            fieldTerms.add(label, docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          external.reset();\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList termsResult = new SimpleOrderedMap();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    SolrIndexReader sr = rb.req.getSearcher().getReader();\n    Fields lfields = MultiFields.getFields(sr);\n\n    for (String field : fields) {\n      NamedList fieldTerms = new NamedList();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seek(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharArr external = new CharArr();\n\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          external.reset();\n          ft.indexedToReadable(term, external);\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              external.reset();\n              ft.indexedToReadable(term, external);\n            }\n            String label = external.toString();\n            \n\n            fieldTerms.add(label, docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          external.reset();\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seek(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharArr external = new CharArr();\n\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          external.reset();\n          ft.indexedToReadable(term, external);\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              external.reset();\n              ft.indexedToReadable(term, external);\n            }\n            String label = external.toString();\n            \n\n            fieldTerms.add(label, docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          external.reset();\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seek(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharArr external = new CharArr();\n\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          external.reset();\n          ft.indexedToReadable(term, external);\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              external.reset();\n              ft.indexedToReadable(term, external);\n            }\n            String label = external.toString();\n            \n\n            fieldTerms.add(label, docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          external.reset();\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a1b3a24d5d9b47345473ff564f5cc127a7b526b4","date":1306277076,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seek(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seek(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharArr external = new CharArr();\n\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          external.reset();\n          ft.indexedToReadable(term, external);\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              external.reset();\n              ft.indexedToReadable(term, external);\n            }\n            String label = external.toString();\n            \n\n            fieldTerms.add(label, docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          external.reset();\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["a45ddee14ecadf18bc50fff428911687afb4745d","a45ddee14ecadf18bc50fff428911687afb4745d","a45ddee14ecadf18bc50fff428911687afb4745d","7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seek(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seek(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharArr external = new CharArr();\n\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          external.reset();\n          ft.indexedToReadable(term, external);\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              external.reset();\n              ft.indexedToReadable(term, external);\n            }\n            String label = external.toString();\n            \n\n            fieldTerms.add(label, docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          external.reset();\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2e10cb22a8bdb44339e282925a29182bb2f3174d","date":1306841137,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seek(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seek(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharArr external = new CharArr();\n\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          external.reset();\n          ft.indexedToReadable(term, external);\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              external.reset();\n              ft.indexedToReadable(term, external);\n            }\n            String label = external.toString();\n            \n\n            fieldTerms.add(label, docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          external.reset();\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd9cc9d77712aba3662f24632df7539ab75e3667","date":1309095238,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seek(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seek(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seek(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/TermsComponent#process(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb) throws IOException {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(TermsParams.TERMS, false)) return;\n\n    String[] fields = params.getParams(TermsParams.TERMS_FIELD);\n\n    NamedList<Object> termsResult = new SimpleOrderedMap<Object>();\n    rb.rsp.add(\"terms\", termsResult);\n\n    if (fields == null || fields.length==0) return;\n\n    int limit = params.getInt(TermsParams.TERMS_LIMIT, 10);\n    if (limit < 0) {\n      limit = Integer.MAX_VALUE;\n    }\n\n    String lowerStr = params.get(TermsParams.TERMS_LOWER);\n    String upperStr = params.get(TermsParams.TERMS_UPPER);\n    boolean upperIncl = params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE, false);\n    boolean lowerIncl = params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE, true);\n    boolean sort = !TermsParams.TERMS_SORT_INDEX.equals(\n        params.get(TermsParams.TERMS_SORT, TermsParams.TERMS_SORT_COUNT));\n    int freqmin = params.getInt(TermsParams.TERMS_MINCOUNT, 1);\n    int freqmax = params.getInt(TermsParams.TERMS_MAXCOUNT, UNLIMITED_MAX_COUNT);\n    if (freqmax<0) {\n      freqmax = Integer.MAX_VALUE;\n    }\n    String prefix = params.get(TermsParams.TERMS_PREFIX_STR);\n    String regexp = params.get(TermsParams.TERMS_REGEXP_STR);\n    Pattern pattern = regexp != null ? Pattern.compile(regexp, resolveRegexpFlags(params)) : null;\n\n    boolean raw = params.getBool(TermsParams.TERMS_RAW, false);\n\n\n    final IndexReader indexReader = rb.req.getSearcher().getTopReaderContext().reader;\n    Fields lfields = MultiFields.getFields(indexReader);\n\n    for (String field : fields) {\n      NamedList<Integer> fieldTerms = new NamedList<Integer>();\n      termsResult.add(field, fieldTerms);\n\n      Terms terms = lfields == null ? null : lfields.terms(field);\n      if (terms == null) {\n        // no terms for this field\n        continue;\n      }\n\n      FieldType ft = raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);\n      if (ft==null) ft = new StrField();\n\n      // prefix must currently be text\n      BytesRef prefixBytes = prefix==null ? null : new BytesRef(prefix);\n\n      BytesRef upperBytes = null;\n      if (upperStr != null) {\n        upperBytes = new BytesRef();\n        ft.readableToIndexed(upperStr, upperBytes);\n      }\n\n      BytesRef lowerBytes;\n      if (lowerStr == null) {\n        // If no lower bound was specified, use the prefix\n        lowerBytes = prefixBytes;\n      } else {\n        lowerBytes = new BytesRef();\n        if (raw) {\n          // TODO: how to handle binary? perhaps we don't for \"raw\"... or if the field exists\n          // perhaps we detect if the FieldType is non-character and expect hex if so?\n          lowerBytes = new BytesRef(lowerStr);\n        } else {\n          lowerBytes = new BytesRef();\n          ft.readableToIndexed(lowerStr, lowerBytes);\n        }\n      }\n\n\n     TermsEnum termsEnum = terms.iterator();\n     BytesRef term = null;\n\n      if (lowerBytes != null) {\n        if (termsEnum.seekCeil(lowerBytes, true) == TermsEnum.SeekStatus.END) {\n          termsEnum = null;\n        } else {\n          term = termsEnum.term();\n          //Only advance the enum if we are excluding the lower bound and the lower Term actually matches\n          if (lowerIncl == false && term.equals(lowerBytes)) {\n            term = termsEnum.next();\n          }\n        }\n      } else {\n        // position termsEnum on first term\n        term = termsEnum.next();\n      }\n\n      int i = 0;\n      BoundedTreeSet<CountPair<BytesRef, Integer>> queue = (sort ? new BoundedTreeSet<CountPair<BytesRef, Integer>>(limit) : null);\n      CharsRef external = new CharsRef();\n      while (term != null && (i<limit || sort)) {\n        boolean externalized = false; // did we fill in \"external\" yet for this term?\n\n        // stop if the prefix doesn't match\n        if (prefixBytes != null && !term.startsWith(prefixBytes)) break;\n\n        if (pattern != null) {\n          // indexed text or external text?\n          // TODO: support \"raw\" mode?\n          ft.indexedToReadable(term, external);\n          externalized = true;\n          if (!pattern.matcher(external).matches()) {\n            term = termsEnum.next();\n            continue;\n          }\n        }\n\n        if (upperBytes != null) {\n          int upperCmp = term.compareTo(upperBytes);\n          // if we are past the upper term, or equal to it (when don't include upper) then stop.\n          if (upperCmp>0 || (upperCmp==0 && !upperIncl)) break;\n        }\n\n        // This is a good term in the range.  Check if mincount/maxcount conditions are satisfied.\n        int docFreq = termsEnum.docFreq();\n        if (docFreq >= freqmin && docFreq <= freqmax) {\n          // add the term to the list\n          if (sort) {\n            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));\n          } else {\n\n            // TODO: handle raw somehow\n            if (!externalized) {\n              ft.indexedToReadable(term, external);\n            }\n            fieldTerms.add(external.toString(), docFreq);\n            i++;\n          }\n        }\n\n        term = termsEnum.next();\n      }\n\n      if (sort) {\n        for (CountPair<BytesRef, Integer> item : queue) {\n          if (i >= limit) break;\n          ft.indexedToReadable(item.key, external);          \n          fieldTerms.add(external.toString(), item.val);\n          i++;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"c26f00b574427b55127e869b935845554afde1fa":["fd9cc9d77712aba3662f24632df7539ab75e3667","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["79c4ed12556e6c87ce3972fad8b9ae2376ec2c2e","fba2d2f1d5c0627026d5c26df8daac1ee3a4a0bd"],"e03427f33820a2bde791de703292dcdfe2d6bdd6":["e7a8029f5e27d48c778b620cdd66b2a8d8370bda"],"1da8d55113b689b06716246649de6f62430f15c0":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","ad94625fb8d088209f46650c8097196fec67f00c"],"79c4ed12556e6c87ce3972fad8b9ae2376ec2c2e":["e03427f33820a2bde791de703292dcdfe2d6bdd6"],"fba2d2f1d5c0627026d5c26df8daac1ee3a4a0bd":["79c4ed12556e6c87ce3972fad8b9ae2376ec2c2e"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01","a1b3a24d5d9b47345473ff564f5cc127a7b526b4"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["fba2d2f1d5c0627026d5c26df8daac1ee3a4a0bd","70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ad94625fb8d088209f46650c8097196fec67f00c":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"fd9cc9d77712aba3662f24632df7539ab75e3667":["a1b3a24d5d9b47345473ff564f5cc127a7b526b4"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["868da859b43505d9d2a023bfeae6dd0c795f5295","70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01"],"2e10cb22a8bdb44339e282925a29182bb2f3174d":["29ef99d61cda9641b6250bf9567329a6e65f901d","a1b3a24d5d9b47345473ff564f5cc127a7b526b4"],"70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01":["323f871ffe96b871d8c534a614be60751bb023c2"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"323f871ffe96b871d8c534a614be60751bb023c2":["755f2f419306d7297c8feee10d1897addf4b2dd0"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"2553b00f699380c64959ccb27991289aae87be2e":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","fd9cc9d77712aba3662f24632df7539ab75e3667"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["a1b3a24d5d9b47345473ff564f5cc127a7b526b4","fd9cc9d77712aba3662f24632df7539ab75e3667"],"e7a8029f5e27d48c778b620cdd66b2a8d8370bda":["1da8d55113b689b06716246649de6f62430f15c0"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["2553b00f699380c64959ccb27991289aae87be2e"],"755f2f419306d7297c8feee10d1897addf4b2dd0":["fba2d2f1d5c0627026d5c26df8daac1ee3a4a0bd"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["fd9cc9d77712aba3662f24632df7539ab75e3667"],"a1b3a24d5d9b47345473ff564f5cc127a7b526b4":["70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","323f871ffe96b871d8c534a614be60751bb023c2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["ad94625fb8d088209f46650c8097196fec67f00c"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["868da859b43505d9d2a023bfeae6dd0c795f5295"],"e03427f33820a2bde791de703292dcdfe2d6bdd6":["79c4ed12556e6c87ce3972fad8b9ae2376ec2c2e"],"1da8d55113b689b06716246649de6f62430f15c0":["e7a8029f5e27d48c778b620cdd66b2a8d8370bda"],"79c4ed12556e6c87ce3972fad8b9ae2376ec2c2e":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","fba2d2f1d5c0627026d5c26df8daac1ee3a4a0bd"],"fba2d2f1d5c0627026d5c26df8daac1ee3a4a0bd":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","29ef99d61cda9641b6250bf9567329a6e65f901d","755f2f419306d7297c8feee10d1897addf4b2dd0"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["2553b00f699380c64959ccb27991289aae87be2e"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["2e10cb22a8bdb44339e282925a29182bb2f3174d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"ad94625fb8d088209f46650c8097196fec67f00c":["1da8d55113b689b06716246649de6f62430f15c0"],"fd9cc9d77712aba3662f24632df7539ab75e3667":["c26f00b574427b55127e869b935845554afde1fa","2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","a258fbb26824fd104ed795e5d9033d2d040049ee"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"2e10cb22a8bdb44339e282925a29182bb2f3174d":[],"70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac","a1b3a24d5d9b47345473ff564f5cc127a7b526b4"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"323f871ffe96b871d8c534a614be60751bb023c2":["70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01","868da859b43505d9d2a023bfeae6dd0c795f5295"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["1da8d55113b689b06716246649de6f62430f15c0"],"2553b00f699380c64959ccb27991289aae87be2e":["c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"e7a8029f5e27d48c778b620cdd66b2a8d8370bda":["e03427f33820a2bde791de703292dcdfe2d6bdd6"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"755f2f419306d7297c8feee10d1897addf4b2dd0":["323f871ffe96b871d8c534a614be60751bb023c2"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"a1b3a24d5d9b47345473ff564f5cc127a7b526b4":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","fd9cc9d77712aba3662f24632df7539ab75e3667","2e10cb22a8bdb44339e282925a29182bb2f3174d","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["bde51b089eb7f86171eb3406e38a274743f9b7ac","2e10cb22a8bdb44339e282925a29182bb2f3174d","d083e83f225b11e5fdd900e83d26ddb385b6955c","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}