{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/RoutedAliasCreateCollectionCmd#deleteOldestCollectionsAndUpdateAlias(TimeRoutedAlias,ZkStateReader.AliasesManager,Instant).mjava","commits":[{"id":"3cbd743a4843f513f793670e3ab0e272bf824faf","date":1518149529,"type":0,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/RoutedAliasCreateCollectionCmd#deleteOldestCollectionsAndUpdateAlias(TimeRoutedAlias,ZkStateReader.AliasesManager,Instant).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Deletes some of the oldest collection(s) based on {@link TimeRoutedAlias#getAutoDeleteAgeMath()}. If not present\n   * then does nothing.  Returns non-null results if something was deleted (or if we tried to).\n   * {@code now} is the date from which the math is relative to.\n   */\n  NamedList deleteOldestCollectionsAndUpdateAlias(TimeRoutedAlias timeRoutedAlias,\n                                                  ZkStateReader.AliasesManager aliasesManager,\n                                                  Instant now) throws Exception {\n    final String autoDeleteAgeMathStr = timeRoutedAlias.getAutoDeleteAgeMath();\n    if (autoDeleteAgeMathStr == null) {\n      return null;\n    }\n    final Instant delBefore;\n    try {\n      delBefore = new DateMathParser(Date.from(now), timeRoutedAlias.getTimeZone()).parseMath(autoDeleteAgeMathStr).toInstant();\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e); // note: should not happen by this point\n    }\n\n    String aliasName = timeRoutedAlias.getAliasName();\n\n    Collection<String> collectionsToDelete = new LinkedHashSet<>();\n\n    // First update the alias    (there may be no change to make!)\n    aliasesManager.applyModificationAndExportToZk(curAliases -> {\n      // note: we could re-parse the TimeRoutedAlias object from curAliases but I don't think there's a point to it.\n\n      final List<Map.Entry<Instant, String>> parsedCollections =\n          timeRoutedAlias.parseCollections(curAliases, () -> newAliasMustExistException(aliasName));\n\n      //iterating from newest to oldest, find the first collection that has a time <= \"before\".  We keep this collection\n      // (and all newer to left) but we delete older collections, which are the ones that follow.\n      // This logic will always keep the first collection, which we can't delete.\n      int numToKeep = 0;\n      for (Map.Entry<Instant, String> parsedCollection : parsedCollections) {\n        numToKeep++;\n        final Instant colInstant = parsedCollection.getKey();\n        if (colInstant.isBefore(delBefore) || colInstant.equals(delBefore)) {\n          break;\n        }\n      }\n      if (numToKeep == parsedCollections.size()) {\n        log.debug(\"No old time routed collections to delete.\");\n        return curAliases;\n      }\n\n      final List<String> targetList = curAliases.getCollectionAliasListMap().get(aliasName);\n      // remember to delete these... (oldest to newest)\n      for (int i = targetList.size() - 1; i >= numToKeep; i--) {\n        collectionsToDelete.add(targetList.get(i));\n      }\n      // new alias list has only \"numToKeep\" first items\n      final List<String> collectionsToKeep = targetList.subList(0, numToKeep);\n      final String collectionsToKeepStr = StrUtils.join(collectionsToKeep, ',');\n      return curAliases.cloneWithCollectionAlias(aliasName, collectionsToKeepStr);\n    });\n\n    if (collectionsToDelete.isEmpty()) {\n      return null;\n    }\n\n    log.info(\"Removing old time routed collections: {}\", collectionsToDelete);\n    // Should this be done asynchronously?  If we got \"ASYNC\" then probably.\n    //   It would shorten the time the Overseer holds a lock on the alias name\n    //   (deleting the collections will be done later and not use that lock).\n    //   Don't bother about parallel; it's unusual to have more than 1.\n    // Note we don't throw an exception here under most cases; instead the response will have information about\n    //   how each delete request went, possibly including a failure message.\n    final CollectionsHandler collHandler = ocmh.overseer.getCoreContainer().getCollectionsHandler();\n    NamedList results = new NamedList();\n    for (String collection : collectionsToDelete) {\n      final SolrParams reqParams = CollectionAdminRequest.deleteCollection(collection).getParams();\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      collHandler.handleRequestBody(new LocalSolrQueryRequest(null, reqParams), rsp);\n      results.add(collection, rsp.getValues());\n    }\n    return results;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1b6eb78cb29a08063ed0ed2816d8817ede89fa90","date":1518149772,"type":5,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/MaintainRoutedAliasCmd#deleteOldestCollectionsAndUpdateAlias(TimeRoutedAlias,ZkStateReader.AliasesManager,Instant).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/RoutedAliasCreateCollectionCmd#deleteOldestCollectionsAndUpdateAlias(TimeRoutedAlias,ZkStateReader.AliasesManager,Instant).mjava","sourceNew":"  /**\n   * Deletes some of the oldest collection(s) based on {@link TimeRoutedAlias#getAutoDeleteAgeMath()}. If not present\n   * then does nothing.  Returns non-null results if something was deleted (or if we tried to).\n   * {@code now} is the date from which the math is relative to.\n   */\n  NamedList deleteOldestCollectionsAndUpdateAlias(TimeRoutedAlias timeRoutedAlias,\n                                                  ZkStateReader.AliasesManager aliasesManager,\n                                                  Instant now) throws Exception {\n    final String autoDeleteAgeMathStr = timeRoutedAlias.getAutoDeleteAgeMath();\n    if (autoDeleteAgeMathStr == null) {\n      return null;\n    }\n    final Instant delBefore;\n    try {\n      delBefore = new DateMathParser(Date.from(now), timeRoutedAlias.getTimeZone()).parseMath(autoDeleteAgeMathStr).toInstant();\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e); // note: should not happen by this point\n    }\n\n    String aliasName = timeRoutedAlias.getAliasName();\n\n    Collection<String> collectionsToDelete = new LinkedHashSet<>();\n\n    // First update the alias    (there may be no change to make!)\n    aliasesManager.applyModificationAndExportToZk(curAliases -> {\n      // note: we could re-parse the TimeRoutedAlias object from curAliases but I don't think there's a point to it.\n\n      final List<Map.Entry<Instant, String>> parsedCollections =\n          timeRoutedAlias.parseCollections(curAliases, () -> newAliasMustExistException(aliasName));\n\n      //iterating from newest to oldest, find the first collection that has a time <= \"before\".  We keep this collection\n      // (and all newer to left) but we delete older collections, which are the ones that follow.\n      // This logic will always keep the first collection, which we can't delete.\n      int numToKeep = 0;\n      for (Map.Entry<Instant, String> parsedCollection : parsedCollections) {\n        numToKeep++;\n        final Instant colInstant = parsedCollection.getKey();\n        if (colInstant.isBefore(delBefore) || colInstant.equals(delBefore)) {\n          break;\n        }\n      }\n      if (numToKeep == parsedCollections.size()) {\n        log.debug(\"No old time routed collections to delete.\");\n        return curAliases;\n      }\n\n      final List<String> targetList = curAliases.getCollectionAliasListMap().get(aliasName);\n      // remember to delete these... (oldest to newest)\n      for (int i = targetList.size() - 1; i >= numToKeep; i--) {\n        collectionsToDelete.add(targetList.get(i));\n      }\n      // new alias list has only \"numToKeep\" first items\n      final List<String> collectionsToKeep = targetList.subList(0, numToKeep);\n      final String collectionsToKeepStr = StrUtils.join(collectionsToKeep, ',');\n      return curAliases.cloneWithCollectionAlias(aliasName, collectionsToKeepStr);\n    });\n\n    if (collectionsToDelete.isEmpty()) {\n      return null;\n    }\n\n    log.info(\"Removing old time routed collections: {}\", collectionsToDelete);\n    // Should this be done asynchronously?  If we got \"ASYNC\" then probably.\n    //   It would shorten the time the Overseer holds a lock on the alias name\n    //   (deleting the collections will be done later and not use that lock).\n    //   Don't bother about parallel; it's unusual to have more than 1.\n    // Note we don't throw an exception here under most cases; instead the response will have information about\n    //   how each delete request went, possibly including a failure message.\n    final CollectionsHandler collHandler = ocmh.overseer.getCoreContainer().getCollectionsHandler();\n    NamedList results = new NamedList();\n    for (String collection : collectionsToDelete) {\n      final SolrParams reqParams = CollectionAdminRequest.deleteCollection(collection).getParams();\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      collHandler.handleRequestBody(new LocalSolrQueryRequest(null, reqParams), rsp);\n      results.add(collection, rsp.getValues());\n    }\n    return results;\n  }\n\n","sourceOld":"  /**\n   * Deletes some of the oldest collection(s) based on {@link TimeRoutedAlias#getAutoDeleteAgeMath()}. If not present\n   * then does nothing.  Returns non-null results if something was deleted (or if we tried to).\n   * {@code now} is the date from which the math is relative to.\n   */\n  NamedList deleteOldestCollectionsAndUpdateAlias(TimeRoutedAlias timeRoutedAlias,\n                                                  ZkStateReader.AliasesManager aliasesManager,\n                                                  Instant now) throws Exception {\n    final String autoDeleteAgeMathStr = timeRoutedAlias.getAutoDeleteAgeMath();\n    if (autoDeleteAgeMathStr == null) {\n      return null;\n    }\n    final Instant delBefore;\n    try {\n      delBefore = new DateMathParser(Date.from(now), timeRoutedAlias.getTimeZone()).parseMath(autoDeleteAgeMathStr).toInstant();\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e); // note: should not happen by this point\n    }\n\n    String aliasName = timeRoutedAlias.getAliasName();\n\n    Collection<String> collectionsToDelete = new LinkedHashSet<>();\n\n    // First update the alias    (there may be no change to make!)\n    aliasesManager.applyModificationAndExportToZk(curAliases -> {\n      // note: we could re-parse the TimeRoutedAlias object from curAliases but I don't think there's a point to it.\n\n      final List<Map.Entry<Instant, String>> parsedCollections =\n          timeRoutedAlias.parseCollections(curAliases, () -> newAliasMustExistException(aliasName));\n\n      //iterating from newest to oldest, find the first collection that has a time <= \"before\".  We keep this collection\n      // (and all newer to left) but we delete older collections, which are the ones that follow.\n      // This logic will always keep the first collection, which we can't delete.\n      int numToKeep = 0;\n      for (Map.Entry<Instant, String> parsedCollection : parsedCollections) {\n        numToKeep++;\n        final Instant colInstant = parsedCollection.getKey();\n        if (colInstant.isBefore(delBefore) || colInstant.equals(delBefore)) {\n          break;\n        }\n      }\n      if (numToKeep == parsedCollections.size()) {\n        log.debug(\"No old time routed collections to delete.\");\n        return curAliases;\n      }\n\n      final List<String> targetList = curAliases.getCollectionAliasListMap().get(aliasName);\n      // remember to delete these... (oldest to newest)\n      for (int i = targetList.size() - 1; i >= numToKeep; i--) {\n        collectionsToDelete.add(targetList.get(i));\n      }\n      // new alias list has only \"numToKeep\" first items\n      final List<String> collectionsToKeep = targetList.subList(0, numToKeep);\n      final String collectionsToKeepStr = StrUtils.join(collectionsToKeep, ',');\n      return curAliases.cloneWithCollectionAlias(aliasName, collectionsToKeepStr);\n    });\n\n    if (collectionsToDelete.isEmpty()) {\n      return null;\n    }\n\n    log.info(\"Removing old time routed collections: {}\", collectionsToDelete);\n    // Should this be done asynchronously?  If we got \"ASYNC\" then probably.\n    //   It would shorten the time the Overseer holds a lock on the alias name\n    //   (deleting the collections will be done later and not use that lock).\n    //   Don't bother about parallel; it's unusual to have more than 1.\n    // Note we don't throw an exception here under most cases; instead the response will have information about\n    //   how each delete request went, possibly including a failure message.\n    final CollectionsHandler collHandler = ocmh.overseer.getCoreContainer().getCollectionsHandler();\n    NamedList results = new NamedList();\n    for (String collection : collectionsToDelete) {\n      final SolrParams reqParams = CollectionAdminRequest.deleteCollection(collection).getParams();\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      collHandler.handleRequestBody(new LocalSolrQueryRequest(null, reqParams), rsp);\n      results.add(collection, rsp.getValues());\n    }\n    return results;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3cbd743a4843f513f793670e3ab0e272bf824faf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1b6eb78cb29a08063ed0ed2816d8817ede89fa90":["3cbd743a4843f513f793670e3ab0e272bf824faf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1b6eb78cb29a08063ed0ed2816d8817ede89fa90"]},"commit2Childs":{"3cbd743a4843f513f793670e3ab0e272bf824faf":["1b6eb78cb29a08063ed0ed2816d8817ede89fa90"],"1b6eb78cb29a08063ed0ed2816d8817ede89fa90":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3cbd743a4843f513f793670e3ab0e272bf824faf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}