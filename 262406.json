{"path":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","commits":[{"id":"68c354ba50abc8ed5c5fe98901e61d68f93952bb","date":1479836000,"type":0,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","pathOld":"/dev/null","sourceNew":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    // relevance query should not be a filter\n    qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n    q = qParser.getQuery();\n    assertEquals(3, ((BooleanQuery)q).clauses().size());\n\n    // small filter query should still use BooleanQuery\n    if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n    }\n\n    // large relevancy query should use BooleanQuery\n    // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    q = qParser.getQuery();\n    assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n    // large filter query should use TermsQuery\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(26, ((TermsQuery)q).getTermData().size());\n\n    // large numeric filter query should use TermsQuery (for trie fields)\n    qParser = QParser.getParser(\"foo_i:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(20, ((TermsQuery)q).getTermData().size());\n\n    // a filter() clause inside a relevancy query should be able to use a TermsQuery\n    qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n    if (qq instanceof TermQuery) {\n      qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n    }\n\n    if (qq instanceof FilterQuery) {\n      qq = ((FilterQuery)qq).getQuery();\n    }\n\n    assertEquals(26, ((TermsQuery)qq).getTermData().size());\n\n    // test mixed boolean query, including quotes (which shouldn't matter)\n    qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(4, ((BooleanQuery)q).clauses().size());\n    qq = null;\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      if (qq instanceof TermsQuery) break;\n    }\n    assertEquals(26, ((TermsQuery)qq).getTermData().size());\n\n    req.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"727bb765ff2542275f6d31f67be18d7104bae148","date":1480353976,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","pathOld":"/dev/null","sourceNew":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    // relevance query should not be a filter\n    qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n    q = qParser.getQuery();\n    assertEquals(3, ((BooleanQuery)q).clauses().size());\n\n    // small filter query should still use BooleanQuery\n    if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n    }\n\n    // large relevancy query should use BooleanQuery\n    // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    q = qParser.getQuery();\n    assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n    // large filter query should use TermsQuery\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(26, ((TermsQuery)q).getTermData().size());\n\n    // large numeric filter query should use TermsQuery (for trie fields)\n    qParser = QParser.getParser(\"foo_i:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(20, ((TermsQuery)q).getTermData().size());\n\n    // a filter() clause inside a relevancy query should be able to use a TermsQuery\n    qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n    if (qq instanceof TermQuery) {\n      qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n    }\n\n    if (qq instanceof FilterQuery) {\n      qq = ((FilterQuery)qq).getQuery();\n    }\n\n    assertEquals(26, ((TermsQuery)qq).getTermData().size());\n\n    // test mixed boolean query, including quotes (which shouldn't matter)\n    qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(4, ((BooleanQuery)q).clauses().size());\n    qq = null;\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      if (qq instanceof TermsQuery) break;\n    }\n    assertEquals(26, ((TermsQuery)qq).getTermData().size());\n\n    req.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8d73510b39df24d6b65de48e56f8dccb136b9d01","date":1483971905,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","sourceNew":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    // relevance query should not be a filter\n    qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n    q = qParser.getQuery();\n    assertEquals(3, ((BooleanQuery)q).clauses().size());\n\n    // small filter query should still use BooleanQuery\n    if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n    }\n\n    // large relevancy query should use BooleanQuery\n    // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    q = qParser.getQuery();\n    assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n    // large filter query should use TermsQuery\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n    // large numeric filter query should use TermsQuery (for trie fields)\n    qParser = QParser.getParser(\"foo_i:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n\n    // a filter() clause inside a relevancy query should be able to use a TermsQuery\n    qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n    if (qq instanceof TermQuery) {\n      qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n    }\n\n    if (qq instanceof FilterQuery) {\n      qq = ((FilterQuery)qq).getQuery();\n    }\n\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test mixed boolean query, including quotes (which shouldn't matter)\n    qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(4, ((BooleanQuery)q).clauses().size());\n    qq = null;\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      if (qq instanceof TermInSetQuery) break;\n    }\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    req.close();\n  }\n\n","sourceOld":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    // relevance query should not be a filter\n    qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n    q = qParser.getQuery();\n    assertEquals(3, ((BooleanQuery)q).clauses().size());\n\n    // small filter query should still use BooleanQuery\n    if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n    }\n\n    // large relevancy query should use BooleanQuery\n    // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    q = qParser.getQuery();\n    assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n    // large filter query should use TermsQuery\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(26, ((TermsQuery)q).getTermData().size());\n\n    // large numeric filter query should use TermsQuery (for trie fields)\n    qParser = QParser.getParser(\"foo_i:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(20, ((TermsQuery)q).getTermData().size());\n\n    // a filter() clause inside a relevancy query should be able to use a TermsQuery\n    qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n    if (qq instanceof TermQuery) {\n      qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n    }\n\n    if (qq instanceof FilterQuery) {\n      qq = ((FilterQuery)qq).getQuery();\n    }\n\n    assertEquals(26, ((TermsQuery)qq).getTermData().size());\n\n    // test mixed boolean query, including quotes (which shouldn't matter)\n    qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(4, ((BooleanQuery)q).clauses().size());\n    qq = null;\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      if (qq instanceof TermsQuery) break;\n    }\n    assertEquals(26, ((TermsQuery)qq).getTermData().size());\n\n    req.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","date":1484239864,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","sourceNew":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    // relevance query should not be a filter\n    qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n    q = qParser.getQuery();\n    assertEquals(3, ((BooleanQuery)q).clauses().size());\n\n    // small filter query should still use BooleanQuery\n    if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n    }\n\n    // large relevancy query should use BooleanQuery\n    // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    q = qParser.getQuery();\n    assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n    // large filter query should use TermsQuery\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n    // large numeric filter query should use TermsQuery (for trie fields)\n    qParser = QParser.getParser(\"foo_i:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n\n    // a filter() clause inside a relevancy query should be able to use a TermsQuery\n    qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n    if (qq instanceof TermQuery) {\n      qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n    }\n\n    if (qq instanceof FilterQuery) {\n      qq = ((FilterQuery)qq).getQuery();\n    }\n\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test mixed boolean query, including quotes (which shouldn't matter)\n    qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(4, ((BooleanQuery)q).clauses().size());\n    qq = null;\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      if (qq instanceof TermInSetQuery) break;\n    }\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    req.close();\n  }\n\n","sourceOld":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    // relevance query should not be a filter\n    qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n    q = qParser.getQuery();\n    assertEquals(3, ((BooleanQuery)q).clauses().size());\n\n    // small filter query should still use BooleanQuery\n    if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n    }\n\n    // large relevancy query should use BooleanQuery\n    // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    q = qParser.getQuery();\n    assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n    // large filter query should use TermsQuery\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(26, ((TermsQuery)q).getTermData().size());\n\n    // large numeric filter query should use TermsQuery (for trie fields)\n    qParser = QParser.getParser(\"foo_i:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(20, ((TermsQuery)q).getTermData().size());\n\n    // a filter() clause inside a relevancy query should be able to use a TermsQuery\n    qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n    if (qq instanceof TermQuery) {\n      qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n    }\n\n    if (qq instanceof FilterQuery) {\n      qq = ((FilterQuery)qq).getQuery();\n    }\n\n    assertEquals(26, ((TermsQuery)qq).getTermData().size());\n\n    // test mixed boolean query, including quotes (which shouldn't matter)\n    qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(4, ((BooleanQuery)q).clauses().size());\n    qq = null;\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      if (qq instanceof TermsQuery) break;\n    }\n    assertEquals(26, ((TermsQuery)qq).getTermData().size());\n\n    req.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6f55332d1f28c7d45d2b54a0dcabb29036aecc62","date":1484666402,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","sourceNew":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    // relevance query should not be a filter\n    qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n    q = qParser.getQuery();\n    assertEquals(3, ((BooleanQuery)q).clauses().size());\n\n    // small filter query should still use BooleanQuery\n    if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n    }\n\n    // large relevancy query should use BooleanQuery\n    // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    q = qParser.getQuery();\n    assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n    // large filter query should use TermsQuery\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n    // large numeric filter query should use TermsQuery (for trie fields)\n    qParser = QParser.getParser(\"foo_i:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n\n    // a filter() clause inside a relevancy query should be able to use a TermsQuery\n    qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n    if (qq instanceof TermQuery) {\n      qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n    }\n\n    if (qq instanceof FilterQuery) {\n      qq = ((FilterQuery)qq).getQuery();\n    }\n\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test mixed boolean query, including quotes (which shouldn't matter)\n    qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(4, ((BooleanQuery)q).clauses().size());\n    qq = null;\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      if (qq instanceof TermInSetQuery) break;\n    }\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n    StringBuilder sb = new StringBuilder();\n    for (int i=0; i<17; i++) {\n      char letter = (char)('a'+i);\n      sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n    }\n    qParser = QParser.getParser(sb.toString(), req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n    }\n\n    req.close();\n  }\n\n","sourceOld":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    // relevance query should not be a filter\n    qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n    q = qParser.getQuery();\n    assertEquals(3, ((BooleanQuery)q).clauses().size());\n\n    // small filter query should still use BooleanQuery\n    if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n    }\n\n    // large relevancy query should use BooleanQuery\n    // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    q = qParser.getQuery();\n    assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n    // large filter query should use TermsQuery\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n    // large numeric filter query should use TermsQuery (for trie fields)\n    qParser = QParser.getParser(\"foo_i:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n\n    // a filter() clause inside a relevancy query should be able to use a TermsQuery\n    qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n    if (qq instanceof TermQuery) {\n      qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n    }\n\n    if (qq instanceof FilterQuery) {\n      qq = ((FilterQuery)qq).getQuery();\n    }\n\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test mixed boolean query, including quotes (which shouldn't matter)\n    qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(4, ((BooleanQuery)q).clauses().size());\n    qq = null;\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      if (qq instanceof TermInSetQuery) break;\n    }\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    req.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"302d34f2c66e8d489ee13078305c330cbf67b226","date":1484754357,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","sourceNew":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    // relevance query should not be a filter\n    qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n    q = qParser.getQuery();\n    assertEquals(3, ((BooleanQuery)q).clauses().size());\n\n    // small filter query should still use BooleanQuery\n    if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n    }\n\n    // large relevancy query should use BooleanQuery\n    // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    q = qParser.getQuery();\n    assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n    // large filter query should use TermsQuery\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n    // large numeric filter query should use TermsQuery (for trie fields)\n    qParser = QParser.getParser(\"foo_i:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n\n    // a filter() clause inside a relevancy query should be able to use a TermsQuery\n    qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n    if (qq instanceof TermQuery) {\n      qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n    }\n\n    if (qq instanceof FilterQuery) {\n      qq = ((FilterQuery)qq).getQuery();\n    }\n\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test mixed boolean query, including quotes (which shouldn't matter)\n    qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(4, ((BooleanQuery)q).clauses().size());\n    qq = null;\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      if (qq instanceof TermInSetQuery) break;\n    }\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n    StringBuilder sb = new StringBuilder();\n    for (int i=0; i<17; i++) {\n      char letter = (char)('a'+i);\n      sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n    }\n    qParser = QParser.getParser(sb.toString(), req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n    }\n\n    req.close();\n  }\n\n","sourceOld":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    // relevance query should not be a filter\n    qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n    q = qParser.getQuery();\n    assertEquals(3, ((BooleanQuery)q).clauses().size());\n\n    // small filter query should still use BooleanQuery\n    if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n    }\n\n    // large relevancy query should use BooleanQuery\n    // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    q = qParser.getQuery();\n    assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n    // large filter query should use TermsQuery\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n    // large numeric filter query should use TermsQuery (for trie fields)\n    qParser = QParser.getParser(\"foo_i:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n\n    // a filter() clause inside a relevancy query should be able to use a TermsQuery\n    qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n    if (qq instanceof TermQuery) {\n      qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n    }\n\n    if (qq instanceof FilterQuery) {\n      qq = ((FilterQuery)qq).getQuery();\n    }\n\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test mixed boolean query, including quotes (which shouldn't matter)\n    qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(4, ((BooleanQuery)q).clauses().size());\n    qq = null;\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      if (qq instanceof TermInSetQuery) break;\n    }\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    req.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46dc9ac8b3e748407baaef82453138ff3974480c","date":1484789241,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","sourceNew":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    // relevance query should not be a filter\n    qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n    q = qParser.getQuery();\n    assertEquals(3, ((BooleanQuery)q).clauses().size());\n\n    // small filter query should still use BooleanQuery\n    if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n    }\n\n    // large relevancy query should use BooleanQuery\n    // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    q = qParser.getQuery();\n    assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n    // large filter query should use TermsQuery\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n    // large numeric filter query should use TermsQuery (for trie fields)\n    qParser = QParser.getParser(\"foo_i:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n    \n    // for point fields large filter query should use PointInSetQuery\n    qParser = QParser.getParser(\"foo_pi:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertTrue(q instanceof PointInSetQuery);\n    assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n\n    // a filter() clause inside a relevancy query should be able to use a TermsQuery\n    qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n    if (qq instanceof TermQuery) {\n      qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n    }\n\n    if (qq instanceof FilterQuery) {\n      qq = ((FilterQuery)qq).getQuery();\n    }\n\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test mixed boolean query, including quotes (which shouldn't matter)\n    qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(4, ((BooleanQuery)q).clauses().size());\n    qq = null;\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      if (qq instanceof TermInSetQuery) break;\n    }\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n    StringBuilder sb = new StringBuilder();\n    for (int i=0; i<17; i++) {\n      char letter = (char)('a'+i);\n      sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n    }\n    qParser = QParser.getParser(sb.toString(), req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n    }\n\n    req.close();\n  }\n\n","sourceOld":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    // relevance query should not be a filter\n    qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n    q = qParser.getQuery();\n    assertEquals(3, ((BooleanQuery)q).clauses().size());\n\n    // small filter query should still use BooleanQuery\n    if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n    }\n\n    // large relevancy query should use BooleanQuery\n    // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    q = qParser.getQuery();\n    assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n    // large filter query should use TermsQuery\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n    // large numeric filter query should use TermsQuery (for trie fields)\n    qParser = QParser.getParser(\"foo_i:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n\n    // a filter() clause inside a relevancy query should be able to use a TermsQuery\n    qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n    if (qq instanceof TermQuery) {\n      qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n    }\n\n    if (qq instanceof FilterQuery) {\n      qq = ((FilterQuery)qq).getQuery();\n    }\n\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test mixed boolean query, including quotes (which shouldn't matter)\n    qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(4, ((BooleanQuery)q).clauses().size());\n    qq = null;\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      if (qq instanceof TermInSetQuery) break;\n    }\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n    StringBuilder sb = new StringBuilder();\n    for (int i=0; i<17; i++) {\n      char letter = (char)('a'+i);\n      sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n    }\n    qParser = QParser.getParser(sb.toString(), req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n    }\n\n    req.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"90a682dc1bfd188ef61cc28373c7f5d700b4ac75","date":1485186128,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","sourceNew":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    // relevance query should not be a filter\n    qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n    q = qParser.getQuery();\n    assertEquals(3, ((BooleanQuery)q).clauses().size());\n\n    // small filter query should still use BooleanQuery\n    if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n    }\n\n    // large relevancy query should use BooleanQuery\n    // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    q = qParser.getQuery();\n    assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n    // large filter query should use TermsQuery\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n    // large numeric filter query should use TermsQuery (for trie fields)\n    qParser = QParser.getParser(\"foo_i:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n    \n    // for point fields large filter query should use PointInSetQuery\n    qParser = QParser.getParser(\"foo_pi:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertTrue(q instanceof PointInSetQuery);\n    assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n\n    // a filter() clause inside a relevancy query should be able to use a TermsQuery\n    qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n    if (qq instanceof TermQuery) {\n      qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n    }\n\n    if (qq instanceof FilterQuery) {\n      qq = ((FilterQuery)qq).getQuery();\n    }\n\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test mixed boolean query, including quotes (which shouldn't matter)\n    qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(4, ((BooleanQuery)q).clauses().size());\n    qq = null;\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      if (qq instanceof TermInSetQuery) break;\n    }\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n    StringBuilder sb = new StringBuilder();\n    for (int i=0; i<17; i++) {\n      char letter = (char)('a'+i);\n      sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n    }\n    qParser = QParser.getParser(sb.toString(), req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n    }\n\n    req.close();\n  }\n\n","sourceOld":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    // relevance query should not be a filter\n    qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n    q = qParser.getQuery();\n    assertEquals(3, ((BooleanQuery)q).clauses().size());\n\n    // small filter query should still use BooleanQuery\n    if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n    }\n\n    // large relevancy query should use BooleanQuery\n    // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    q = qParser.getQuery();\n    assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n    // large filter query should use TermsQuery\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n    // large numeric filter query should use TermsQuery (for trie fields)\n    qParser = QParser.getParser(\"foo_i:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n\n    // a filter() clause inside a relevancy query should be able to use a TermsQuery\n    qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n    if (qq instanceof TermQuery) {\n      qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n    }\n\n    if (qq instanceof FilterQuery) {\n      qq = ((FilterQuery)qq).getQuery();\n    }\n\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test mixed boolean query, including quotes (which shouldn't matter)\n    qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(4, ((BooleanQuery)q).clauses().size());\n    qq = null;\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      if (qq instanceof TermInSetQuery) break;\n    }\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n    StringBuilder sb = new StringBuilder();\n    for (int i=0; i<17; i++) {\n      char letter = (char)('a'+i);\n      sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n    }\n    qParser = QParser.getParser(sb.toString(), req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n    }\n\n    req.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"744b111b17d15d490a648eb021bfa240e7f11556","date":1487008069,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","sourceNew":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    // relevance query should not be a filter\n    qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n    q = qParser.getQuery();\n    assertEquals(3, ((BooleanQuery)q).clauses().size());\n\n    // small filter query should still use BooleanQuery\n    if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n    }\n\n    // large relevancy query should use BooleanQuery\n    // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    q = qParser.getQuery();\n    assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n    // large filter query should use TermsQuery\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n    // large numeric filter query should use TermsQuery (for trie fields)\n    qParser = QParser.getParser(\"foo_ti:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n    \n    // for point fields large filter query should use PointInSetQuery\n    qParser = QParser.getParser(\"foo_pi:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertTrue(q instanceof PointInSetQuery);\n    assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n\n    // a filter() clause inside a relevancy query should be able to use a TermsQuery\n    qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n    if (qq instanceof TermQuery) {\n      qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n    }\n\n    if (qq instanceof FilterQuery) {\n      qq = ((FilterQuery)qq).getQuery();\n    }\n\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test mixed boolean query, including quotes (which shouldn't matter)\n    qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(4, ((BooleanQuery)q).clauses().size());\n    qq = null;\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      if (qq instanceof TermInSetQuery) break;\n    }\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n    StringBuilder sb = new StringBuilder();\n    for (int i=0; i<17; i++) {\n      char letter = (char)('a'+i);\n      sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n    }\n    qParser = QParser.getParser(sb.toString(), req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n    }\n\n    req.close();\n  }\n\n","sourceOld":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    // relevance query should not be a filter\n    qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n    q = qParser.getQuery();\n    assertEquals(3, ((BooleanQuery)q).clauses().size());\n\n    // small filter query should still use BooleanQuery\n    if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n    }\n\n    // large relevancy query should use BooleanQuery\n    // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    q = qParser.getQuery();\n    assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n    // large filter query should use TermsQuery\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n    // large numeric filter query should use TermsQuery (for trie fields)\n    qParser = QParser.getParser(\"foo_i:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n    \n    // for point fields large filter query should use PointInSetQuery\n    qParser = QParser.getParser(\"foo_pi:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertTrue(q instanceof PointInSetQuery);\n    assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n\n    // a filter() clause inside a relevancy query should be able to use a TermsQuery\n    qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n    if (qq instanceof TermQuery) {\n      qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n    }\n\n    if (qq instanceof FilterQuery) {\n      qq = ((FilterQuery)qq).getQuery();\n    }\n\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test mixed boolean query, including quotes (which shouldn't matter)\n    qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(4, ((BooleanQuery)q).clauses().size());\n    qq = null;\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      if (qq instanceof TermInSetQuery) break;\n    }\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n    StringBuilder sb = new StringBuilder();\n    for (int i=0; i<17; i++) {\n      char letter = (char)('a'+i);\n      sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n    }\n    qParser = QParser.getParser(sb.toString(), req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n    }\n\n    req.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"022a4de90e0479b604264ca9c2e134c996454ab3","date":1487118265,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","sourceNew":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    // relevance query should not be a filter\n    qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n    q = qParser.getQuery();\n    assertEquals(3, ((BooleanQuery)q).clauses().size());\n\n    // small filter query should still use BooleanQuery\n    if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n    }\n\n    // large relevancy query should use BooleanQuery\n    // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    q = qParser.getQuery();\n    assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n    // large filter query should use TermsQuery\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n    // large numeric filter query should use TermsQuery (for trie fields)\n    qParser = QParser.getParser(\"foo_ti:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n    \n    // for point fields large filter query should use PointInSetQuery\n    qParser = QParser.getParser(\"foo_pi:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertTrue(q instanceof PointInSetQuery);\n    assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n\n    // a filter() clause inside a relevancy query should be able to use a TermsQuery\n    qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n    if (qq instanceof TermQuery) {\n      qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n    }\n\n    if (qq instanceof FilterQuery) {\n      qq = ((FilterQuery)qq).getQuery();\n    }\n\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test mixed boolean query, including quotes (which shouldn't matter)\n    qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(4, ((BooleanQuery)q).clauses().size());\n    qq = null;\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      if (qq instanceof TermInSetQuery) break;\n    }\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n    StringBuilder sb = new StringBuilder();\n    for (int i=0; i<17; i++) {\n      char letter = (char)('a'+i);\n      sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n    }\n    qParser = QParser.getParser(sb.toString(), req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n    }\n\n    req.close();\n  }\n\n","sourceOld":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    // relevance query should not be a filter\n    qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n    q = qParser.getQuery();\n    assertEquals(3, ((BooleanQuery)q).clauses().size());\n\n    // small filter query should still use BooleanQuery\n    if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n    }\n\n    // large relevancy query should use BooleanQuery\n    // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    q = qParser.getQuery();\n    assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n    // large filter query should use TermsQuery\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n    // large numeric filter query should use TermsQuery (for trie fields)\n    qParser = QParser.getParser(\"foo_i:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n    \n    // for point fields large filter query should use PointInSetQuery\n    qParser = QParser.getParser(\"foo_pi:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertTrue(q instanceof PointInSetQuery);\n    assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n\n    // a filter() clause inside a relevancy query should be able to use a TermsQuery\n    qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n    if (qq instanceof TermQuery) {\n      qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n    }\n\n    if (qq instanceof FilterQuery) {\n      qq = ((FilterQuery)qq).getQuery();\n    }\n\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test mixed boolean query, including quotes (which shouldn't matter)\n    qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(4, ((BooleanQuery)q).clauses().size());\n    qq = null;\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      if (qq instanceof TermInSetQuery) break;\n    }\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n    StringBuilder sb = new StringBuilder();\n    for (int i=0; i<17; i++) {\n      char letter = (char)('a'+i);\n      sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n    }\n    qParser = QParser.getParser(sb.toString(), req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n    }\n\n    req.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96","date":1487122334,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","sourceNew":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    // relevance query should not be a filter\n    qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n    q = qParser.getQuery();\n    assertEquals(3, ((BooleanQuery)q).clauses().size());\n\n    // small filter query should still use BooleanQuery\n    if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n    }\n\n    // large relevancy query should use BooleanQuery\n    // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    q = qParser.getQuery();\n    assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n    // large filter query should use TermsQuery\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n    // large numeric filter query should use TermsQuery (for trie fields)\n    qParser = QParser.getParser(\"foo_i:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n    \n    // for point fields large filter query should use PointInSetQuery\n    qParser = QParser.getParser(\"foo_pi:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertTrue(q instanceof PointInSetQuery);\n    assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n\n    // a filter() clause inside a relevancy query should be able to use a TermsQuery\n    qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n    if (qq instanceof TermQuery) {\n      qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n    }\n\n    if (qq instanceof FilterQuery) {\n      qq = ((FilterQuery)qq).getQuery();\n    }\n\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test mixed boolean query, including quotes (which shouldn't matter)\n    qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(4, ((BooleanQuery)q).clauses().size());\n    qq = null;\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      if (qq instanceof TermInSetQuery) break;\n    }\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n    StringBuilder sb = new StringBuilder();\n    for (int i=0; i<17; i++) {\n      char letter = (char)('a'+i);\n      sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n    }\n    qParser = QParser.getParser(sb.toString(), req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n    }\n\n    req.close();\n  }\n\n","sourceOld":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    // relevance query should not be a filter\n    qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n    q = qParser.getQuery();\n    assertEquals(3, ((BooleanQuery)q).clauses().size());\n\n    // small filter query should still use BooleanQuery\n    if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n    }\n\n    // large relevancy query should use BooleanQuery\n    // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    q = qParser.getQuery();\n    assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n    // large filter query should use TermsQuery\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n    // large numeric filter query should use TermsQuery (for trie fields)\n    qParser = QParser.getParser(\"foo_ti:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n    \n    // for point fields large filter query should use PointInSetQuery\n    qParser = QParser.getParser(\"foo_pi:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertTrue(q instanceof PointInSetQuery);\n    assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n\n    // a filter() clause inside a relevancy query should be able to use a TermsQuery\n    qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n    if (qq instanceof TermQuery) {\n      qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n    }\n\n    if (qq instanceof FilterQuery) {\n      qq = ((FilterQuery)qq).getQuery();\n    }\n\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test mixed boolean query, including quotes (which shouldn't matter)\n    qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(4, ((BooleanQuery)q).clauses().size());\n    qq = null;\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      if (qq instanceof TermInSetQuery) break;\n    }\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n    StringBuilder sb = new StringBuilder();\n    for (int i=0; i<17; i++) {\n      char letter = (char)('a'+i);\n      sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n    }\n    qParser = QParser.getParser(sb.toString(), req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n    }\n\n    req.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"897b06b1364bd1f658a8be7591e43f0851458e7f","date":1487123008,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","sourceNew":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    // relevance query should not be a filter\n    qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n    q = qParser.getQuery();\n    assertEquals(3, ((BooleanQuery)q).clauses().size());\n\n    // small filter query should still use BooleanQuery\n    if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n    }\n\n    // large relevancy query should use BooleanQuery\n    // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    q = qParser.getQuery();\n    assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n    // large filter query should use TermsQuery\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n    // large numeric filter query should use TermsQuery (for trie fields)\n    qParser = QParser.getParser(\"foo_ti:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n    \n    // for point fields large filter query should use PointInSetQuery\n    qParser = QParser.getParser(\"foo_pi:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertTrue(q instanceof PointInSetQuery);\n    assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n\n    // a filter() clause inside a relevancy query should be able to use a TermsQuery\n    qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n    if (qq instanceof TermQuery) {\n      qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n    }\n\n    if (qq instanceof FilterQuery) {\n      qq = ((FilterQuery)qq).getQuery();\n    }\n\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test mixed boolean query, including quotes (which shouldn't matter)\n    qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(4, ((BooleanQuery)q).clauses().size());\n    qq = null;\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      if (qq instanceof TermInSetQuery) break;\n    }\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n    StringBuilder sb = new StringBuilder();\n    for (int i=0; i<17; i++) {\n      char letter = (char)('a'+i);\n      sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n    }\n    qParser = QParser.getParser(sb.toString(), req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n    }\n\n    req.close();\n  }\n\n","sourceOld":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    // relevance query should not be a filter\n    qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n    q = qParser.getQuery();\n    assertEquals(3, ((BooleanQuery)q).clauses().size());\n\n    // small filter query should still use BooleanQuery\n    if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n    }\n\n    // large relevancy query should use BooleanQuery\n    // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    q = qParser.getQuery();\n    assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n    // large filter query should use TermsQuery\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n    // large numeric filter query should use TermsQuery (for trie fields)\n    qParser = QParser.getParser(\"foo_i:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n    \n    // for point fields large filter query should use PointInSetQuery\n    qParser = QParser.getParser(\"foo_pi:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertTrue(q instanceof PointInSetQuery);\n    assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n\n    // a filter() clause inside a relevancy query should be able to use a TermsQuery\n    qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n    if (qq instanceof TermQuery) {\n      qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n    }\n\n    if (qq instanceof FilterQuery) {\n      qq = ((FilterQuery)qq).getQuery();\n    }\n\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test mixed boolean query, including quotes (which shouldn't matter)\n    qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(4, ((BooleanQuery)q).clauses().size());\n    qq = null;\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      if (qq instanceof TermInSetQuery) break;\n    }\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n    StringBuilder sb = new StringBuilder();\n    for (int i=0; i<17; i++) {\n      char letter = (char)('a'+i);\n      sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n    }\n    qParser = QParser.getParser(sb.toString(), req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n    }\n\n    req.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e55782fb51a6e9789542818eb2161a3247f39ace","date":1489707707,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","sourceNew":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    Map<String, String> sowFalseParamsMap = new HashMap<>();\n    sowFalseParamsMap.put(\"sow\", \"false\");\n    Map<String, String> sowTrueParamsMap = new HashMap<>();\n    sowTrueParamsMap.put(\"sow\", \"true\");\n    List<MapSolrParams> paramMaps = Arrays.asList\n        (new MapSolrParams(Collections.emptyMap()), // no sow param (i.e. the default sow value) \n         new MapSolrParams(sowFalseParamsMap),\n         new MapSolrParams(sowTrueParamsMap));\n\n    for (MapSolrParams params : paramMaps) {\n      // relevance query should not be a filter\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n\n      // small filter query should still use BooleanQuery\n      if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n        qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n        qParser.setParams(params);\n        qParser.setIsFilter(true); // this may change in the future\n        q = qParser.getQuery();\n        assertEquals(3, ((BooleanQuery) q).clauses().size());\n      }\n\n      // large relevancy query should use BooleanQuery\n      // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n      // large filter query should use TermsQuery\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n      // large numeric filter query should use TermsQuery (for trie fields)\n      qParser = QParser.getParser(\"foo_ti:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n\n      // for point fields large filter query should use PointInSetQuery\n      qParser = QParser.getParser(\"foo_pi:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertTrue(q instanceof PointInSetQuery);\n      assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n\n      // a filter() clause inside a relevancy query should be able to use a TermsQuery\n      qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n      if (qq instanceof TermQuery) {\n        qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n      }\n\n      if (qq instanceof FilterQuery) {\n        qq = ((FilterQuery)qq).getQuery();\n      }\n\n      assertEquals(26, ((TermInSetQuery) qq).getTermData().size());\n\n      // test mixed boolean query, including quotes (which shouldn't matter)\n      qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(4, ((BooleanQuery)q).clauses().size());\n      qq = null;\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        if (qq instanceof TermInSetQuery) break;\n      }\n      assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n      // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<17; i++) {\n        char letter = (char)('a'+i);\n        sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n      }\n      qParser = QParser.getParser(sb.toString(), req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n      }\n    }\n    req.close();\n  }\n\n","sourceOld":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    // relevance query should not be a filter\n    qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n    q = qParser.getQuery();\n    assertEquals(3, ((BooleanQuery)q).clauses().size());\n\n    // small filter query should still use BooleanQuery\n    if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n    }\n\n    // large relevancy query should use BooleanQuery\n    // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    q = qParser.getQuery();\n    assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n    // large filter query should use TermsQuery\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n    // large numeric filter query should use TermsQuery (for trie fields)\n    qParser = QParser.getParser(\"foo_ti:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n    \n    // for point fields large filter query should use PointInSetQuery\n    qParser = QParser.getParser(\"foo_pi:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertTrue(q instanceof PointInSetQuery);\n    assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n\n    // a filter() clause inside a relevancy query should be able to use a TermsQuery\n    qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n    if (qq instanceof TermQuery) {\n      qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n    }\n\n    if (qq instanceof FilterQuery) {\n      qq = ((FilterQuery)qq).getQuery();\n    }\n\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test mixed boolean query, including quotes (which shouldn't matter)\n    qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(4, ((BooleanQuery)q).clauses().size());\n    qq = null;\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      if (qq instanceof TermInSetQuery) break;\n    }\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n    StringBuilder sb = new StringBuilder();\n    for (int i=0; i<17; i++) {\n      char letter = (char)('a'+i);\n      sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n    }\n    qParser = QParser.getParser(sb.toString(), req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n    }\n\n    req.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c03778630c4604270d88c148afb8c7de35b51d3c","date":1490280010,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","sourceNew":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    Map<String, String> sowFalseParamsMap = new HashMap<>();\n    sowFalseParamsMap.put(\"sow\", \"false\");\n    Map<String, String> sowTrueParamsMap = new HashMap<>();\n    sowTrueParamsMap.put(\"sow\", \"true\");\n    List<MapSolrParams> paramMaps = Arrays.asList\n        (new MapSolrParams(Collections.emptyMap()), // no sow param (i.e. the default sow value) \n         new MapSolrParams(sowFalseParamsMap),\n         new MapSolrParams(sowTrueParamsMap));\n\n    for (MapSolrParams params : paramMaps) {\n      // relevance query should not be a filter\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n\n      // small filter query should still use BooleanQuery\n      if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n        qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n        qParser.setParams(params);\n        qParser.setIsFilter(true); // this may change in the future\n        q = qParser.getQuery();\n        assertEquals(3, ((BooleanQuery) q).clauses().size());\n      }\n\n      // large relevancy query should use BooleanQuery\n      // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n      // large filter query should use TermsQuery\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n      // large numeric filter query should use TermsQuery (for trie fields)\n      qParser = QParser.getParser(\"foo_ti:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n\n      // for point fields large filter query should use PointInSetQuery\n      qParser = QParser.getParser(\"foo_pi:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertTrue(q instanceof PointInSetQuery);\n      assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n\n      // a filter() clause inside a relevancy query should be able to use a TermsQuery\n      qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n      if (qq instanceof TermQuery) {\n        qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n      }\n\n      if (qq instanceof FilterQuery) {\n        qq = ((FilterQuery)qq).getQuery();\n      }\n\n      assertEquals(26, ((TermInSetQuery) qq).getTermData().size());\n\n      // test mixed boolean query, including quotes (which shouldn't matter)\n      qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(4, ((BooleanQuery)q).clauses().size());\n      qq = null;\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        if (qq instanceof TermInSetQuery) break;\n      }\n      assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n      // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<17; i++) {\n        char letter = (char)('a'+i);\n        sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n      }\n      qParser = QParser.getParser(sb.toString(), req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n      }\n    }\n    req.close();\n  }\n\n","sourceOld":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    // relevance query should not be a filter\n    qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n    q = qParser.getQuery();\n    assertEquals(3, ((BooleanQuery)q).clauses().size());\n\n    // small filter query should still use BooleanQuery\n    if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n    }\n\n    // large relevancy query should use BooleanQuery\n    // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    q = qParser.getQuery();\n    assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n    // large filter query should use TermsQuery\n    qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n    // large numeric filter query should use TermsQuery (for trie fields)\n    qParser = QParser.getParser(\"foo_ti:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n    \n    // for point fields large filter query should use PointInSetQuery\n    qParser = QParser.getParser(\"foo_pi:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertTrue(q instanceof PointInSetQuery);\n    assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n\n    // a filter() clause inside a relevancy query should be able to use a TermsQuery\n    qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n    if (qq instanceof TermQuery) {\n      qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n    }\n\n    if (qq instanceof FilterQuery) {\n      qq = ((FilterQuery)qq).getQuery();\n    }\n\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test mixed boolean query, including quotes (which shouldn't matter)\n    qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(4, ((BooleanQuery)q).clauses().size());\n    qq = null;\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      if (qq instanceof TermInSetQuery) break;\n    }\n    assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n    // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n    StringBuilder sb = new StringBuilder();\n    for (int i=0; i<17; i++) {\n      char letter = (char)('a'+i);\n      sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n    }\n    qParser = QParser.getParser(sb.toString(), req);\n    qParser.setIsFilter(true); // this may change in the future\n    q = qParser.getQuery();\n    assertEquals(2, ((BooleanQuery)q).clauses().size());\n    for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n      qq = clause.getQuery();\n      assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n    }\n\n    req.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"351efe6fdecf9af62134d37ec2582e4a0331a4dc","date":1498149096,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","sourceNew":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    Map<String, String> sowFalseParamsMap = new HashMap<>();\n    sowFalseParamsMap.put(\"sow\", \"false\");\n    Map<String, String> sowTrueParamsMap = new HashMap<>();\n    sowTrueParamsMap.put(\"sow\", \"true\");\n    List<MapSolrParams> paramMaps = Arrays.asList\n        (new MapSolrParams(Collections.emptyMap()), // no sow param (i.e. the default sow value) \n         new MapSolrParams(sowFalseParamsMap),\n         new MapSolrParams(sowTrueParamsMap));\n\n    for (MapSolrParams params : paramMaps) {\n      // relevance query should not be a filter\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n\n      // small filter query should still use BooleanQuery\n      if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n        qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n        qParser.setParams(params);\n        qParser.setIsFilter(true); // this may change in the future\n        q = qParser.getQuery();\n        assertEquals(3, ((BooleanQuery) q).clauses().size());\n      }\n\n      // large relevancy query should use BooleanQuery\n      // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n      // large filter query should use TermsQuery\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n      // large numeric filter query should use TermsQuery (for trie fields)\n      qParser = QParser.getParser(\"foo_ti:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      if (Boolean.getBoolean(NUMERIC_POINTS_SYSPROP)) {\n        assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n      } else {\n        assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n      }\n\n      // for point fields large filter query should use PointInSetQuery\n      qParser = QParser.getParser(\"foo_pi:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertTrue(q instanceof PointInSetQuery);\n      assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n\n      // a filter() clause inside a relevancy query should be able to use a TermsQuery\n      qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n      if (qq instanceof TermQuery) {\n        qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n      }\n\n      if (qq instanceof FilterQuery) {\n        qq = ((FilterQuery)qq).getQuery();\n      }\n\n      assertEquals(26, ((TermInSetQuery) qq).getTermData().size());\n\n      // test mixed boolean query, including quotes (which shouldn't matter)\n      qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(4, ((BooleanQuery)q).clauses().size());\n      qq = null;\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        if (qq instanceof TermInSetQuery) break;\n      }\n      assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n      // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<17; i++) {\n        char letter = (char)('a'+i);\n        sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n      }\n      qParser = QParser.getParser(sb.toString(), req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n      }\n    }\n    req.close();\n  }\n\n","sourceOld":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    Map<String, String> sowFalseParamsMap = new HashMap<>();\n    sowFalseParamsMap.put(\"sow\", \"false\");\n    Map<String, String> sowTrueParamsMap = new HashMap<>();\n    sowTrueParamsMap.put(\"sow\", \"true\");\n    List<MapSolrParams> paramMaps = Arrays.asList\n        (new MapSolrParams(Collections.emptyMap()), // no sow param (i.e. the default sow value) \n         new MapSolrParams(sowFalseParamsMap),\n         new MapSolrParams(sowTrueParamsMap));\n\n    for (MapSolrParams params : paramMaps) {\n      // relevance query should not be a filter\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n\n      // small filter query should still use BooleanQuery\n      if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n        qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n        qParser.setParams(params);\n        qParser.setIsFilter(true); // this may change in the future\n        q = qParser.getQuery();\n        assertEquals(3, ((BooleanQuery) q).clauses().size());\n      }\n\n      // large relevancy query should use BooleanQuery\n      // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n      // large filter query should use TermsQuery\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n      // large numeric filter query should use TermsQuery (for trie fields)\n      qParser = QParser.getParser(\"foo_ti:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n\n      // for point fields large filter query should use PointInSetQuery\n      qParser = QParser.getParser(\"foo_pi:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertTrue(q instanceof PointInSetQuery);\n      assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n\n      // a filter() clause inside a relevancy query should be able to use a TermsQuery\n      qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n      if (qq instanceof TermQuery) {\n        qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n      }\n\n      if (qq instanceof FilterQuery) {\n        qq = ((FilterQuery)qq).getQuery();\n      }\n\n      assertEquals(26, ((TermInSetQuery) qq).getTermData().size());\n\n      // test mixed boolean query, including quotes (which shouldn't matter)\n      qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(4, ((BooleanQuery)q).clauses().size());\n      qq = null;\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        if (qq instanceof TermInSetQuery) break;\n      }\n      assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n      // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<17; i++) {\n        char letter = (char)('a'+i);\n        sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n      }\n      qParser = QParser.getParser(sb.toString(), req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n      }\n    }\n    req.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","sourceNew":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    Map<String, String> sowFalseParamsMap = new HashMap<>();\n    sowFalseParamsMap.put(\"sow\", \"false\");\n    Map<String, String> sowTrueParamsMap = new HashMap<>();\n    sowTrueParamsMap.put(\"sow\", \"true\");\n    List<MapSolrParams> paramMaps = Arrays.asList\n        (new MapSolrParams(Collections.emptyMap()), // no sow param (i.e. the default sow value) \n         new MapSolrParams(sowFalseParamsMap),\n         new MapSolrParams(sowTrueParamsMap));\n\n    for (MapSolrParams params : paramMaps) {\n      // relevance query should not be a filter\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n\n      // small filter query should still use BooleanQuery\n      if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n        qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n        qParser.setParams(params);\n        qParser.setIsFilter(true); // this may change in the future\n        q = qParser.getQuery();\n        assertEquals(3, ((BooleanQuery) q).clauses().size());\n      }\n\n      // large relevancy query should use BooleanQuery\n      // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n      // large filter query should use TermsQuery\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n      // large numeric filter query should use TermsQuery (for trie fields)\n      qParser = QParser.getParser(\"foo_ti:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      if (Boolean.getBoolean(NUMERIC_POINTS_SYSPROP)) {\n        assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n      } else {\n        assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n      }\n\n      // for point fields large filter query should use PointInSetQuery\n      qParser = QParser.getParser(\"foo_pi:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertTrue(q instanceof PointInSetQuery);\n      assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n\n      // a filter() clause inside a relevancy query should be able to use a TermsQuery\n      qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n      if (qq instanceof TermQuery) {\n        qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n      }\n\n      if (qq instanceof FilterQuery) {\n        qq = ((FilterQuery)qq).getQuery();\n      }\n\n      assertEquals(26, ((TermInSetQuery) qq).getTermData().size());\n\n      // test mixed boolean query, including quotes (which shouldn't matter)\n      qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(4, ((BooleanQuery)q).clauses().size());\n      qq = null;\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        if (qq instanceof TermInSetQuery) break;\n      }\n      assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n      // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<17; i++) {\n        char letter = (char)('a'+i);\n        sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n      }\n      qParser = QParser.getParser(sb.toString(), req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n      }\n    }\n    req.close();\n  }\n\n","sourceOld":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    Map<String, String> sowFalseParamsMap = new HashMap<>();\n    sowFalseParamsMap.put(\"sow\", \"false\");\n    Map<String, String> sowTrueParamsMap = new HashMap<>();\n    sowTrueParamsMap.put(\"sow\", \"true\");\n    List<MapSolrParams> paramMaps = Arrays.asList\n        (new MapSolrParams(Collections.emptyMap()), // no sow param (i.e. the default sow value) \n         new MapSolrParams(sowFalseParamsMap),\n         new MapSolrParams(sowTrueParamsMap));\n\n    for (MapSolrParams params : paramMaps) {\n      // relevance query should not be a filter\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n\n      // small filter query should still use BooleanQuery\n      if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n        qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n        qParser.setParams(params);\n        qParser.setIsFilter(true); // this may change in the future\n        q = qParser.getQuery();\n        assertEquals(3, ((BooleanQuery) q).clauses().size());\n      }\n\n      // large relevancy query should use BooleanQuery\n      // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n      // large filter query should use TermsQuery\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n      // large numeric filter query should use TermsQuery (for trie fields)\n      qParser = QParser.getParser(\"foo_ti:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n\n      // for point fields large filter query should use PointInSetQuery\n      qParser = QParser.getParser(\"foo_pi:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertTrue(q instanceof PointInSetQuery);\n      assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n\n      // a filter() clause inside a relevancy query should be able to use a TermsQuery\n      qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n      if (qq instanceof TermQuery) {\n        qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n      }\n\n      if (qq instanceof FilterQuery) {\n        qq = ((FilterQuery)qq).getQuery();\n      }\n\n      assertEquals(26, ((TermInSetQuery) qq).getTermData().size());\n\n      // test mixed boolean query, including quotes (which shouldn't matter)\n      qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(4, ((BooleanQuery)q).clauses().size());\n      qq = null;\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        if (qq instanceof TermInSetQuery) break;\n      }\n      assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n      // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<17; i++) {\n        char letter = (char)('a'+i);\n        sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n      }\n      qParser = QParser.getParser(sb.toString(), req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n      }\n    }\n    req.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","sourceNew":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    Map<String, String> sowFalseParamsMap = new HashMap<>();\n    sowFalseParamsMap.put(\"sow\", \"false\");\n    Map<String, String> sowTrueParamsMap = new HashMap<>();\n    sowTrueParamsMap.put(\"sow\", \"true\");\n    List<MapSolrParams> paramMaps = Arrays.asList\n        (new MapSolrParams(Collections.emptyMap()), // no sow param (i.e. the default sow value) \n         new MapSolrParams(sowFalseParamsMap),\n         new MapSolrParams(sowTrueParamsMap));\n\n    for (MapSolrParams params : paramMaps) {\n      // relevance query should not be a filter\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n\n      // small filter query should still use BooleanQuery\n      if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n        qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n        qParser.setParams(params);\n        qParser.setIsFilter(true); // this may change in the future\n        q = qParser.getQuery();\n        assertEquals(3, ((BooleanQuery) q).clauses().size());\n      }\n\n      // large relevancy query should use BooleanQuery\n      // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n      // large filter query should use TermsQuery\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n      // large numeric filter query should use TermsQuery (for trie fields)\n      qParser = QParser.getParser(\"foo_ti:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      if (Boolean.getBoolean(NUMERIC_POINTS_SYSPROP)) {\n        assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n      } else {\n        assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n      }\n\n      // for point fields large filter query should use PointInSetQuery\n      qParser = QParser.getParser(\"foo_pi:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertTrue(q instanceof PointInSetQuery);\n      assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n\n      // a filter() clause inside a relevancy query should be able to use a TermsQuery\n      qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n      if (qq instanceof TermQuery) {\n        qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n      }\n\n      if (qq instanceof FilterQuery) {\n        qq = ((FilterQuery)qq).getQuery();\n      }\n\n      assertEquals(26, ((TermInSetQuery) qq).getTermData().size());\n\n      // test mixed boolean query, including quotes (which shouldn't matter)\n      qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(4, ((BooleanQuery)q).clauses().size());\n      qq = null;\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        if (qq instanceof TermInSetQuery) break;\n      }\n      assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n      // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<17; i++) {\n        char letter = (char)('a'+i);\n        sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n      }\n      qParser = QParser.getParser(sb.toString(), req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n      }\n    }\n    req.close();\n  }\n\n","sourceOld":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    Map<String, String> sowFalseParamsMap = new HashMap<>();\n    sowFalseParamsMap.put(\"sow\", \"false\");\n    Map<String, String> sowTrueParamsMap = new HashMap<>();\n    sowTrueParamsMap.put(\"sow\", \"true\");\n    List<MapSolrParams> paramMaps = Arrays.asList\n        (new MapSolrParams(Collections.emptyMap()), // no sow param (i.e. the default sow value) \n         new MapSolrParams(sowFalseParamsMap),\n         new MapSolrParams(sowTrueParamsMap));\n\n    for (MapSolrParams params : paramMaps) {\n      // relevance query should not be a filter\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n\n      // small filter query should still use BooleanQuery\n      if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n        qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n        qParser.setParams(params);\n        qParser.setIsFilter(true); // this may change in the future\n        q = qParser.getQuery();\n        assertEquals(3, ((BooleanQuery) q).clauses().size());\n      }\n\n      // large relevancy query should use BooleanQuery\n      // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n      // large filter query should use TermsQuery\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n      // large numeric filter query should use TermsQuery (for trie fields)\n      qParser = QParser.getParser(\"foo_ti:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n\n      // for point fields large filter query should use PointInSetQuery\n      qParser = QParser.getParser(\"foo_pi:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertTrue(q instanceof PointInSetQuery);\n      assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n\n      // a filter() clause inside a relevancy query should be able to use a TermsQuery\n      qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n      if (qq instanceof TermQuery) {\n        qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n      }\n\n      if (qq instanceof FilterQuery) {\n        qq = ((FilterQuery)qq).getQuery();\n      }\n\n      assertEquals(26, ((TermInSetQuery) qq).getTermData().size());\n\n      // test mixed boolean query, including quotes (which shouldn't matter)\n      qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(4, ((BooleanQuery)q).clauses().size());\n      qq = null;\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        if (qq instanceof TermInSetQuery) break;\n      }\n      assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n      // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<17; i++) {\n        char letter = (char)('a'+i);\n        sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n      }\n      qParser = QParser.getParser(sb.toString(), req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n      }\n    }\n    req.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa31759957c90bbd07c2fa553208a76b0e8dc518","date":1504624674,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","sourceNew":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    Map<String, String> sowFalseParamsMap = new HashMap<>();\n    sowFalseParamsMap.put(\"sow\", \"false\");\n    Map<String, String> sowTrueParamsMap = new HashMap<>();\n    sowTrueParamsMap.put(\"sow\", \"true\");\n    List<MapSolrParams> paramMaps = Arrays.asList\n        (new MapSolrParams(Collections.emptyMap()), // no sow param (i.e. the default sow value) \n         new MapSolrParams(sowFalseParamsMap),\n         new MapSolrParams(sowTrueParamsMap));\n\n    for (MapSolrParams params : paramMaps) {\n      // relevance query should not be a filter\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n\n      // small filter query should still use BooleanQuery\n      if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n        qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n        qParser.setParams(params);\n        qParser.setIsFilter(true); // this may change in the future\n        q = qParser.getQuery();\n        assertEquals(3, ((BooleanQuery) q).clauses().size());\n      }\n\n      // large relevancy query should use BooleanQuery\n      // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n      // large filter query should use TermsQuery\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n      // large numeric filter query should use TermsQuery\n      qParser = QParser.getParser(\"foo_ti:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      if (Boolean.getBoolean(NUMERIC_POINTS_SYSPROP)) {\n        assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n      } else {\n        assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n      }\n\n      // for point fields large filter query should use PointInSetQuery\n      qParser = QParser.getParser(\"foo_pi:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertTrue(q instanceof PointInSetQuery);\n      assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n\n      // a filter() clause inside a relevancy query should be able to use a TermsQuery\n      qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n      if (qq instanceof TermQuery) {\n        qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n      }\n\n      if (qq instanceof FilterQuery) {\n        qq = ((FilterQuery)qq).getQuery();\n      }\n\n      assertEquals(26, ((TermInSetQuery) qq).getTermData().size());\n\n      // test mixed boolean query, including quotes (which shouldn't matter)\n      qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(4, ((BooleanQuery)q).clauses().size());\n      qq = null;\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        if (qq instanceof TermInSetQuery) break;\n      }\n      assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n      // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<17; i++) {\n        char letter = (char)('a'+i);\n        sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n      }\n      qParser = QParser.getParser(sb.toString(), req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n      }\n    }\n    req.close();\n  }\n\n","sourceOld":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    Map<String, String> sowFalseParamsMap = new HashMap<>();\n    sowFalseParamsMap.put(\"sow\", \"false\");\n    Map<String, String> sowTrueParamsMap = new HashMap<>();\n    sowTrueParamsMap.put(\"sow\", \"true\");\n    List<MapSolrParams> paramMaps = Arrays.asList\n        (new MapSolrParams(Collections.emptyMap()), // no sow param (i.e. the default sow value) \n         new MapSolrParams(sowFalseParamsMap),\n         new MapSolrParams(sowTrueParamsMap));\n\n    for (MapSolrParams params : paramMaps) {\n      // relevance query should not be a filter\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n\n      // small filter query should still use BooleanQuery\n      if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n        qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n        qParser.setParams(params);\n        qParser.setIsFilter(true); // this may change in the future\n        q = qParser.getQuery();\n        assertEquals(3, ((BooleanQuery) q).clauses().size());\n      }\n\n      // large relevancy query should use BooleanQuery\n      // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n      // large filter query should use TermsQuery\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n      // large numeric filter query should use TermsQuery (for trie fields)\n      qParser = QParser.getParser(\"foo_ti:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      if (Boolean.getBoolean(NUMERIC_POINTS_SYSPROP)) {\n        assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n      } else {\n        assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n      }\n\n      // for point fields large filter query should use PointInSetQuery\n      qParser = QParser.getParser(\"foo_pi:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertTrue(q instanceof PointInSetQuery);\n      assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n\n      // a filter() clause inside a relevancy query should be able to use a TermsQuery\n      qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n      if (qq instanceof TermQuery) {\n        qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n      }\n\n      if (qq instanceof FilterQuery) {\n        qq = ((FilterQuery)qq).getQuery();\n      }\n\n      assertEquals(26, ((TermInSetQuery) qq).getTermData().size());\n\n      // test mixed boolean query, including quotes (which shouldn't matter)\n      qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(4, ((BooleanQuery)q).clauses().size());\n      qq = null;\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        if (qq instanceof TermInSetQuery) break;\n      }\n      assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n      // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<17; i++) {\n        char letter = (char)('a'+i);\n        sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n      }\n      qParser = QParser.getParser(sb.toString(), req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n      }\n    }\n    req.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b21283ed01203901a7257aa4b7f0a0899c86e56e","date":1504689720,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","sourceNew":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    Map<String, String> sowFalseParamsMap = new HashMap<>();\n    sowFalseParamsMap.put(\"sow\", \"false\");\n    Map<String, String> sowTrueParamsMap = new HashMap<>();\n    sowTrueParamsMap.put(\"sow\", \"true\");\n    List<MapSolrParams> paramMaps = Arrays.asList\n        (new MapSolrParams(Collections.emptyMap()), // no sow param (i.e. the default sow value) \n         new MapSolrParams(sowFalseParamsMap),\n         new MapSolrParams(sowTrueParamsMap));\n\n    for (MapSolrParams params : paramMaps) {\n      // relevance query should not be a filter\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n\n      // small filter query should still use BooleanQuery\n      if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n        qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n        qParser.setParams(params);\n        qParser.setIsFilter(true); // this may change in the future\n        q = qParser.getQuery();\n        assertEquals(3, ((BooleanQuery) q).clauses().size());\n      }\n\n      // large relevancy query should use BooleanQuery\n      // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n      // large filter query should use TermsQuery\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n      // large numeric filter query should use TermsQuery\n      qParser = QParser.getParser(\"foo_ti:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      if (Boolean.getBoolean(NUMERIC_POINTS_SYSPROP)) {\n        assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n      } else {\n        assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n      }\n\n      // for point fields large filter query should use PointInSetQuery\n      qParser = QParser.getParser(\"foo_pi:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertTrue(q instanceof PointInSetQuery);\n      assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n\n      // a filter() clause inside a relevancy query should be able to use a TermsQuery\n      qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n      if (qq instanceof TermQuery) {\n        qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n      }\n\n      if (qq instanceof FilterQuery) {\n        qq = ((FilterQuery)qq).getQuery();\n      }\n\n      assertEquals(26, ((TermInSetQuery) qq).getTermData().size());\n\n      // test mixed boolean query, including quotes (which shouldn't matter)\n      qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(4, ((BooleanQuery)q).clauses().size());\n      qq = null;\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        if (qq instanceof TermInSetQuery) break;\n      }\n      assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n      // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<17; i++) {\n        char letter = (char)('a'+i);\n        sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n      }\n      qParser = QParser.getParser(sb.toString(), req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n      }\n    }\n    req.close();\n  }\n\n","sourceOld":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    Map<String, String> sowFalseParamsMap = new HashMap<>();\n    sowFalseParamsMap.put(\"sow\", \"false\");\n    Map<String, String> sowTrueParamsMap = new HashMap<>();\n    sowTrueParamsMap.put(\"sow\", \"true\");\n    List<MapSolrParams> paramMaps = Arrays.asList\n        (new MapSolrParams(Collections.emptyMap()), // no sow param (i.e. the default sow value) \n         new MapSolrParams(sowFalseParamsMap),\n         new MapSolrParams(sowTrueParamsMap));\n\n    for (MapSolrParams params : paramMaps) {\n      // relevance query should not be a filter\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n\n      // small filter query should still use BooleanQuery\n      if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n        qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n        qParser.setParams(params);\n        qParser.setIsFilter(true); // this may change in the future\n        q = qParser.getQuery();\n        assertEquals(3, ((BooleanQuery) q).clauses().size());\n      }\n\n      // large relevancy query should use BooleanQuery\n      // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n      // large filter query should use TermsQuery\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n      // large numeric filter query should use TermsQuery (for trie fields)\n      qParser = QParser.getParser(\"foo_ti:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      if (Boolean.getBoolean(NUMERIC_POINTS_SYSPROP)) {\n        assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n      } else {\n        assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n      }\n\n      // for point fields large filter query should use PointInSetQuery\n      qParser = QParser.getParser(\"foo_pi:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertTrue(q instanceof PointInSetQuery);\n      assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n\n      // a filter() clause inside a relevancy query should be able to use a TermsQuery\n      qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n      if (qq instanceof TermQuery) {\n        qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n      }\n\n      if (qq instanceof FilterQuery) {\n        qq = ((FilterQuery)qq).getQuery();\n      }\n\n      assertEquals(26, ((TermInSetQuery) qq).getTermData().size());\n\n      // test mixed boolean query, including quotes (which shouldn't matter)\n      qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(4, ((BooleanQuery)q).clauses().size());\n      qq = null;\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        if (qq instanceof TermInSetQuery) break;\n      }\n      assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n      // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<17; i++) {\n        char letter = (char)('a'+i);\n        sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n      }\n      qParser = QParser.getParser(sb.toString(), req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n      }\n    }\n    req.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7","date":1504848000,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","sourceNew":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    Map<String, String> sowFalseParamsMap = new HashMap<>();\n    sowFalseParamsMap.put(\"sow\", \"false\");\n    Map<String, String> sowTrueParamsMap = new HashMap<>();\n    sowTrueParamsMap.put(\"sow\", \"true\");\n    List<MapSolrParams> paramMaps = Arrays.asList\n        (new MapSolrParams(Collections.emptyMap()), // no sow param (i.e. the default sow value) \n         new MapSolrParams(sowFalseParamsMap),\n         new MapSolrParams(sowTrueParamsMap));\n\n    for (MapSolrParams params : paramMaps) {\n      // relevance query should not be a filter\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n\n      // small filter query should still use BooleanQuery\n      if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n        qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n        qParser.setParams(params);\n        qParser.setIsFilter(true); // this may change in the future\n        q = qParser.getQuery();\n        assertEquals(3, ((BooleanQuery) q).clauses().size());\n      }\n\n      // large relevancy query should use BooleanQuery\n      // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n      // large filter query should use TermsQuery\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n      // large numeric filter query should use TermsQuery\n      qParser = QParser.getParser(\"foo_ti:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      if (Boolean.getBoolean(NUMERIC_POINTS_SYSPROP)) {\n        assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n      } else {\n        assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n      }\n\n      // for point fields large filter query should use PointInSetQuery\n      qParser = QParser.getParser(\"foo_pi:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertTrue(q instanceof PointInSetQuery);\n      assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n\n      // a filter() clause inside a relevancy query should be able to use a TermsQuery\n      qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n      if (qq instanceof TermQuery) {\n        qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n      }\n\n      if (qq instanceof FilterQuery) {\n        qq = ((FilterQuery)qq).getQuery();\n      }\n\n      assertEquals(26, ((TermInSetQuery) qq).getTermData().size());\n\n      // test mixed boolean query, including quotes (which shouldn't matter)\n      qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(4, ((BooleanQuery)q).clauses().size());\n      qq = null;\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        if (qq instanceof TermInSetQuery) break;\n      }\n      assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n      // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<17; i++) {\n        char letter = (char)('a'+i);\n        sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n      }\n      qParser = QParser.getParser(sb.toString(), req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n      }\n    }\n    req.close();\n  }\n\n","sourceOld":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    Map<String, String> sowFalseParamsMap = new HashMap<>();\n    sowFalseParamsMap.put(\"sow\", \"false\");\n    Map<String, String> sowTrueParamsMap = new HashMap<>();\n    sowTrueParamsMap.put(\"sow\", \"true\");\n    List<MapSolrParams> paramMaps = Arrays.asList\n        (new MapSolrParams(Collections.emptyMap()), // no sow param (i.e. the default sow value) \n         new MapSolrParams(sowFalseParamsMap),\n         new MapSolrParams(sowTrueParamsMap));\n\n    for (MapSolrParams params : paramMaps) {\n      // relevance query should not be a filter\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n\n      // small filter query should still use BooleanQuery\n      if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n        qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n        qParser.setParams(params);\n        qParser.setIsFilter(true); // this may change in the future\n        q = qParser.getQuery();\n        assertEquals(3, ((BooleanQuery) q).clauses().size());\n      }\n\n      // large relevancy query should use BooleanQuery\n      // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n      // large filter query should use TermsQuery\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n      // large numeric filter query should use TermsQuery (for trie fields)\n      qParser = QParser.getParser(\"foo_ti:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      if (Boolean.getBoolean(NUMERIC_POINTS_SYSPROP)) {\n        assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n      } else {\n        assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n      }\n\n      // for point fields large filter query should use PointInSetQuery\n      qParser = QParser.getParser(\"foo_pi:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertTrue(q instanceof PointInSetQuery);\n      assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n\n      // a filter() clause inside a relevancy query should be able to use a TermsQuery\n      qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n      if (qq instanceof TermQuery) {\n        qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n      }\n\n      if (qq instanceof FilterQuery) {\n        qq = ((FilterQuery)qq).getQuery();\n      }\n\n      assertEquals(26, ((TermInSetQuery) qq).getTermData().size());\n\n      // test mixed boolean query, including quotes (which shouldn't matter)\n      qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(4, ((BooleanQuery)q).clauses().size());\n      qq = null;\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        if (qq instanceof TermInSetQuery) break;\n      }\n      assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n      // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<17; i++) {\n        char letter = (char)('a'+i);\n        sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n      }\n      qParser = QParser.getParser(sb.toString(), req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n      }\n    }\n    req.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"685bd38810c206c93e9058f3c2cfa9827c086c27","date":1505751821,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSolrQueryParser#testAutoTerms().mjava","sourceNew":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    Map<String, String> sowFalseParamsMap = new HashMap<>();\n    sowFalseParamsMap.put(\"sow\", \"false\");\n    Map<String, String> sowTrueParamsMap = new HashMap<>();\n    sowTrueParamsMap.put(\"sow\", \"true\");\n    List<MapSolrParams> paramMaps = Arrays.asList\n        (new MapSolrParams(Collections.emptyMap()), // no sow param (i.e. the default sow value) \n         new MapSolrParams(sowFalseParamsMap),\n         new MapSolrParams(sowTrueParamsMap));\n\n    for (MapSolrParams params : paramMaps) {\n      // relevance query should not be a filter\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n\n      // small filter query should still use BooleanQuery\n      if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n        qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n        qParser.setParams(params);\n        qParser.setIsFilter(true); // this may change in the future\n        q = qParser.getQuery();\n        assertEquals(3, ((BooleanQuery) q).clauses().size());\n      }\n\n      // large relevancy query should use BooleanQuery\n      // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n      // large filter query should use TermsQuery\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n      // large numeric filter query should use TermsQuery\n      qParser = QParser.getParser(\"foo_ti:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      if (Boolean.getBoolean(NUMERIC_POINTS_SYSPROP)) {\n        assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n      } else {\n        assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n      }\n\n      // for point fields large filter query should use PointInSetQuery\n      qParser = QParser.getParser(\"foo_pi:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertTrue(q instanceof PointInSetQuery);\n      assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n\n      // a filter() clause inside a relevancy query should be able to use a TermsQuery\n      qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n      if (qq instanceof TermQuery) {\n        qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n      }\n\n      if (qq instanceof FilterQuery) {\n        qq = ((FilterQuery)qq).getQuery();\n      }\n\n      assertEquals(26, ((TermInSetQuery) qq).getTermData().size());\n\n      // test mixed boolean query, including quotes (which shouldn't matter)\n      qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(4, ((BooleanQuery)q).clauses().size());\n      qq = null;\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        if (qq instanceof TermInSetQuery) break;\n      }\n      assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n      // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<17; i++) {\n        char letter = (char)('a'+i);\n        sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n      }\n      qParser = QParser.getParser(sb.toString(), req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n      }\n    }\n    req.close();\n  }\n\n","sourceOld":"  // automatically use TermsQuery when appropriate\n  @Test\n  public void testAutoTerms() throws Exception {\n    SolrQueryRequest req = req();\n    QParser qParser;\n    Query q,qq;\n\n    Map<String, String> sowFalseParamsMap = new HashMap<>();\n    sowFalseParamsMap.put(\"sow\", \"false\");\n    Map<String, String> sowTrueParamsMap = new HashMap<>();\n    sowTrueParamsMap.put(\"sow\", \"true\");\n    List<MapSolrParams> paramMaps = Arrays.asList\n        (new MapSolrParams(Collections.emptyMap()), // no sow param (i.e. the default sow value) \n         new MapSolrParams(sowFalseParamsMap),\n         new MapSolrParams(sowTrueParamsMap));\n\n    for (MapSolrParams params : paramMaps) {\n      // relevance query should not be a filter\n      qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(3, ((BooleanQuery) q).clauses().size());\n\n      // small filter query should still use BooleanQuery\n      if (QueryParser.TERMS_QUERY_THRESHOLD > 3) {\n        qParser = QParser.getParser(\"foo_s:(a b c)\", req);\n        qParser.setParams(params);\n        qParser.setIsFilter(true); // this may change in the future\n        q = qParser.getQuery();\n        assertEquals(3, ((BooleanQuery) q).clauses().size());\n      }\n\n      // large relevancy query should use BooleanQuery\n      // TODO: we may decide that string fields shouldn't have relevance in the future... change to a text field w/o a stop filter if so\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((BooleanQuery)q).clauses().size());\n\n      // large filter query should use TermsQuery\n      qParser = QParser.getParser(\"foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(26, ((TermInSetQuery)q).getTermData().size());\n\n      // large numeric filter query should use TermsQuery (for trie fields)\n      qParser = QParser.getParser(\"foo_ti:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      if (Boolean.getBoolean(NUMERIC_POINTS_SYSPROP)) {\n        assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n      } else {\n        assertEquals(20, ((TermInSetQuery)q).getTermData().size());\n      }\n\n      // for point fields large filter query should use PointInSetQuery\n      qParser = QParser.getParser(\"foo_pi:(1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertTrue(q instanceof PointInSetQuery);\n      assertEquals(20, ((PointInSetQuery)q).getPackedPoints().size());\n\n      // a filter() clause inside a relevancy query should be able to use a TermsQuery\n      qParser = QParser.getParser(\"foo_s:aaa filter(foo_s:(a b c d e f g h i j k l m n o p q r s t u v w x y z))\", req);\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      qq = ((BooleanQuery)q).clauses().get(0).getQuery();\n      if (qq instanceof TermQuery) {\n        qq = ((BooleanQuery)q).clauses().get(1).getQuery();\n      }\n\n      if (qq instanceof FilterQuery) {\n        qq = ((FilterQuery)qq).getQuery();\n      }\n\n      assertEquals(26, ((TermInSetQuery) qq).getTermData().size());\n\n      // test mixed boolean query, including quotes (which shouldn't matter)\n      qParser = QParser.getParser(\"foo_s:(a +aaa b -bbb c d e f bar_s:(qqq www) g h i j k l m n o p q r s t u v w x y z)\", req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(4, ((BooleanQuery)q).clauses().size());\n      qq = null;\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        if (qq instanceof TermInSetQuery) break;\n      }\n      assertEquals(26, ((TermInSetQuery)qq).getTermData().size());\n\n      // test terms queries of two different fields (LUCENE-7637 changed to require all terms be in the same field)\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<17; i++) {\n        char letter = (char)('a'+i);\n        sb.append(\"foo_s:\" + letter + \" bar_s:\" + letter + \" \");\n      }\n      qParser = QParser.getParser(sb.toString(), req);\n      qParser.setIsFilter(true); // this may change in the future\n      qParser.setParams(params);\n      q = qParser.getQuery();\n      assertEquals(2, ((BooleanQuery)q).clauses().size());\n      for (BooleanClause clause : ((BooleanQuery)q).clauses()) {\n        qq = clause.getQuery();\n        assertEquals(17, ((TermInSetQuery)qq).getTermData().size());\n      }\n    }\n    req.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"351efe6fdecf9af62134d37ec2582e4a0331a4dc":["e55782fb51a6e9789542818eb2161a3247f39ace"],"b21283ed01203901a7257aa4b7f0a0899c86e56e":["28288370235ed02234a64753cdbf0c6ec096304a","aa31759957c90bbd07c2fa553208a76b0e8dc518"],"aa31759957c90bbd07c2fa553208a76b0e8dc518":["28288370235ed02234a64753cdbf0c6ec096304a"],"897b06b1364bd1f658a8be7591e43f0851458e7f":["b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96"],"46dc9ac8b3e748407baaef82453138ff3974480c":["6f55332d1f28c7d45d2b54a0dcabb29036aecc62"],"6f55332d1f28c7d45d2b54a0dcabb29036aecc62":["8d73510b39df24d6b65de48e56f8dccb136b9d01"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":["727bb765ff2542275f6d31f67be18d7104bae148","8d73510b39df24d6b65de48e56f8dccb136b9d01"],"c03778630c4604270d88c148afb8c7de35b51d3c":["897b06b1364bd1f658a8be7591e43f0851458e7f"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["c03778630c4604270d88c148afb8c7de35b51d3c","351efe6fdecf9af62134d37ec2582e4a0331a4dc"],"e55782fb51a6e9789542818eb2161a3247f39ace":["897b06b1364bd1f658a8be7591e43f0851458e7f"],"28288370235ed02234a64753cdbf0c6ec096304a":["e55782fb51a6e9789542818eb2161a3247f39ace","351efe6fdecf9af62134d37ec2582e4a0331a4dc"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":["302d34f2c66e8d489ee13078305c330cbf67b226","46dc9ac8b3e748407baaef82453138ff3974480c"],"302d34f2c66e8d489ee13078305c330cbf67b226":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","6f55332d1f28c7d45d2b54a0dcabb29036aecc62"],"b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96":["022a4de90e0479b604264ca9c2e134c996454ab3"],"685bd38810c206c93e9058f3c2cfa9827c086c27":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"],"022a4de90e0479b604264ca9c2e134c996454ab3":["46dc9ac8b3e748407baaef82453138ff3974480c","744b111b17d15d490a648eb021bfa240e7f11556"],"727bb765ff2542275f6d31f67be18d7104bae148":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","68c354ba50abc8ed5c5fe98901e61d68f93952bb"],"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7":["28288370235ed02234a64753cdbf0c6ec096304a","b21283ed01203901a7257aa4b7f0a0899c86e56e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8d73510b39df24d6b65de48e56f8dccb136b9d01":["68c354ba50abc8ed5c5fe98901e61d68f93952bb"],"744b111b17d15d490a648eb021bfa240e7f11556":["46dc9ac8b3e748407baaef82453138ff3974480c"],"68c354ba50abc8ed5c5fe98901e61d68f93952bb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"]},"commit2Childs":{"351efe6fdecf9af62134d37ec2582e4a0331a4dc":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"b21283ed01203901a7257aa4b7f0a0899c86e56e":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"],"aa31759957c90bbd07c2fa553208a76b0e8dc518":["b21283ed01203901a7257aa4b7f0a0899c86e56e"],"897b06b1364bd1f658a8be7591e43f0851458e7f":["c03778630c4604270d88c148afb8c7de35b51d3c","e55782fb51a6e9789542818eb2161a3247f39ace"],"46dc9ac8b3e748407baaef82453138ff3974480c":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75","022a4de90e0479b604264ca9c2e134c996454ab3","744b111b17d15d490a648eb021bfa240e7f11556"],"6f55332d1f28c7d45d2b54a0dcabb29036aecc62":["46dc9ac8b3e748407baaef82453138ff3974480c","302d34f2c66e8d489ee13078305c330cbf67b226"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":["302d34f2c66e8d489ee13078305c330cbf67b226"],"c03778630c4604270d88c148afb8c7de35b51d3c":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["685bd38810c206c93e9058f3c2cfa9827c086c27"],"e55782fb51a6e9789542818eb2161a3247f39ace":["351efe6fdecf9af62134d37ec2582e4a0331a4dc","28288370235ed02234a64753cdbf0c6ec096304a"],"28288370235ed02234a64753cdbf0c6ec096304a":["b21283ed01203901a7257aa4b7f0a0899c86e56e","aa31759957c90bbd07c2fa553208a76b0e8dc518","104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":[],"302d34f2c66e8d489ee13078305c330cbf67b226":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75"],"b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96":["897b06b1364bd1f658a8be7591e43f0851458e7f"],"685bd38810c206c93e9058f3c2cfa9827c086c27":[],"022a4de90e0479b604264ca9c2e134c996454ab3":["b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96"],"727bb765ff2542275f6d31f67be18d7104bae148":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7"],"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7":["685bd38810c206c93e9058f3c2cfa9827c086c27","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["727bb765ff2542275f6d31f67be18d7104bae148","68c354ba50abc8ed5c5fe98901e61d68f93952bb"],"8d73510b39df24d6b65de48e56f8dccb136b9d01":["6f55332d1f28c7d45d2b54a0dcabb29036aecc62","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7"],"744b111b17d15d490a648eb021bfa240e7f11556":["022a4de90e0479b604264ca9c2e134c996454ab3"],"68c354ba50abc8ed5c5fe98901e61d68f93952bb":["727bb765ff2542275f6d31f67be18d7104bae148","8d73510b39df24d6b65de48e56f8dccb136b9d01"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75","685bd38810c206c93e9058f3c2cfa9827c086c27","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}