{"path":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,DocSet).mjava","commits":[{"id":"92751ba9273251eab6a2e379ec42a1697a32ff96","date":1407954233,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,DocSet).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, DocSet base) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, base, field, multiToken, offset,limit, mincount, missing, sort, prefix);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, base, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["7679cc7d5b465ec8936979698cedf5fdbd71c95c","275f40e1400de0b5ab5e33051ac11e8973813a2c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"52c5280f6286c7546ab75b72c663f7bb1dc10e96","date":1427372570,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,DocSet).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, DocSet base) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, base, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, base, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, DocSet base) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, base, field, multiToken, offset,limit, mincount, missing, sort, prefix);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, base, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,DocSet).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, DocSet base) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, base, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, base, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, DocSet base) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, base, field, multiToken, offset,limit, mincount, missing, sort, prefix);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, base, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa62c79a7afa4d7f22e1f71b883659f3213d7db1","date":1435334422,"type":5,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,DocSet).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, DocSet base) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, base, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, base, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["92751ba9273251eab6a2e379ec42a1697a32ff96","52c5280f6286c7546ab75b72c663f7bb1dc10e96"],"92751ba9273251eab6a2e379ec42a1697a32ff96":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"52c5280f6286c7546ab75b72c663f7bb1dc10e96":["92751ba9273251eab6a2e379ec42a1697a32ff96"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"aa62c79a7afa4d7f22e1f71b883659f3213d7db1":["52c5280f6286c7546ab75b72c663f7bb1dc10e96"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"]},"commit2Childs":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"92751ba9273251eab6a2e379ec42a1697a32ff96":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","52c5280f6286c7546ab75b72c663f7bb1dc10e96"],"52c5280f6286c7546ab75b72c663f7bb1dc10e96":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["92751ba9273251eab6a2e379ec42a1697a32ff96"],"aa62c79a7afa4d7f22e1f71b883659f3213d7db1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}