{"path":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/DefaultSortedSetDocValuesReaderState#DefaultSortedSetDocValuesReaderState(IndexReader,String).mjava","commits":[{"id":"30fc8c22124fdcf9d76449bd2fa04decbe74e2e2","date":1391685460,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/DefaultSortedSetDocValuesReaderState#DefaultSortedSetDocValuesReaderState(IndexReader,String).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesReaderState#SortedSetDocValuesReaderState(IndexReader,String).mjava","sourceNew":"  /** Creates this, pulling doc values from the specified\n   *  field. */\n  public DefaultSortedSetDocValuesReaderState(IndexReader reader, String field) throws IOException {\n    this.field = field;\n    this.origReader = reader;\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    topReader = SlowCompositeReaderWrapper.wrap(reader);\n    SortedSetDocValues dv = topReader.getSortedSetDocValues(field);\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n    BytesRef spare = new BytesRef();\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      dv.lookupOrd(ord, spare);\n      String[] components = FacetsConfig.stringToPath(spare.utf8ToString());\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + Arrays.toString(components) + \" \" + spare.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","sourceOld":"  /** Creates this, pulling doc values from the specified\n   *  field. */\n  public SortedSetDocValuesReaderState(IndexReader reader, String field) throws IOException {\n\n    this.field = field;\n    this.origReader = reader;\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    topReader = SlowCompositeReaderWrapper.wrap(reader);\n    SortedSetDocValues dv = topReader.getSortedSetDocValues(field);\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n    BytesRef spare = new BytesRef();\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      dv.lookupOrd(ord, spare);\n      String[] components = FacetsConfig.stringToPath(spare.utf8ToString());\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + Arrays.toString(components) + \" \" + spare.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf","date":1401983689,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/DefaultSortedSetDocValuesReaderState#DefaultSortedSetDocValuesReaderState(IndexReader,String).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/DefaultSortedSetDocValuesReaderState#DefaultSortedSetDocValuesReaderState(IndexReader,String).mjava","sourceNew":"  /** Creates this, pulling doc values from the specified\n   *  field. */\n  public DefaultSortedSetDocValuesReaderState(IndexReader reader, String field) throws IOException {\n    this.field = field;\n    this.origReader = reader;\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    topReader = SlowCompositeReaderWrapper.wrap(reader);\n    SortedSetDocValues dv = topReader.getSortedSetDocValues(field);\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      final BytesRef term = dv.lookupOrd(ord);\n      String[] components = FacetsConfig.stringToPath(term.utf8ToString());\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + Arrays.toString(components) + \" \" + term.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","sourceOld":"  /** Creates this, pulling doc values from the specified\n   *  field. */\n  public DefaultSortedSetDocValuesReaderState(IndexReader reader, String field) throws IOException {\n    this.field = field;\n    this.origReader = reader;\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    topReader = SlowCompositeReaderWrapper.wrap(reader);\n    SortedSetDocValues dv = topReader.getSortedSetDocValues(field);\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n    BytesRef spare = new BytesRef();\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      dv.lookupOrd(ord, spare);\n      String[] components = FacetsConfig.stringToPath(spare.utf8ToString());\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + Arrays.toString(components) + \" \" + spare.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1","date":1457644139,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/DefaultSortedSetDocValuesReaderState#DefaultSortedSetDocValuesReaderState(IndexReader,String).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/DefaultSortedSetDocValuesReaderState#DefaultSortedSetDocValuesReaderState(IndexReader,String).mjava","sourceNew":"  /** Creates this, pulling doc values from the specified\n   *  field. */\n  public DefaultSortedSetDocValuesReaderState(IndexReader reader, String field) throws IOException {\n    this.field = field;\n    this.origReader = reader;\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    SortedSetDocValues dv = getDocValues();\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      final BytesRef term = dv.lookupOrd(ord);\n      String[] components = FacetsConfig.stringToPath(term.utf8ToString());\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + Arrays.toString(components) + \" \" + term.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","sourceOld":"  /** Creates this, pulling doc values from the specified\n   *  field. */\n  public DefaultSortedSetDocValuesReaderState(IndexReader reader, String field) throws IOException {\n    this.field = field;\n    this.origReader = reader;\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    topReader = SlowCompositeReaderWrapper.wrap(reader);\n    SortedSetDocValues dv = topReader.getSortedSetDocValues(field);\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      final BytesRef term = dv.lookupOrd(ord);\n      String[] components = FacetsConfig.stringToPath(term.utf8ToString());\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + Arrays.toString(components) + \" \" + term.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","bugFix":["9fe35a54e036b5f516cb04b39f3eb96a55812376"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8cfd1df435f04d4287925cca73cf22120f723892","date":1493925365,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/DefaultSortedSetDocValuesReaderState#DefaultSortedSetDocValuesReaderState(IndexReader,String).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/DefaultSortedSetDocValuesReaderState#DefaultSortedSetDocValuesReaderState(IndexReader,String).mjava","sourceNew":"  /** Creates this, pulling doc values from the specified\n   *  field. */\n  public DefaultSortedSetDocValuesReaderState(IndexReader reader, String field) throws IOException {\n    this.field = field;\n    this.reader = reader;\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    SortedSetDocValues dv = getDocValues();\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      final BytesRef term = dv.lookupOrd(ord);\n      String[] components = FacetsConfig.stringToPath(term.utf8ToString());\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + Arrays.toString(components) + \" \" + term.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","sourceOld":"  /** Creates this, pulling doc values from the specified\n   *  field. */\n  public DefaultSortedSetDocValuesReaderState(IndexReader reader, String field) throws IOException {\n    this.field = field;\n    this.origReader = reader;\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    SortedSetDocValues dv = getDocValues();\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      final BytesRef term = dv.lookupOrd(ord);\n      String[] components = FacetsConfig.stringToPath(term.utf8ToString());\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + Arrays.toString(components) + \" \" + term.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/DefaultSortedSetDocValuesReaderState#DefaultSortedSetDocValuesReaderState(IndexReader,String).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/DefaultSortedSetDocValuesReaderState#DefaultSortedSetDocValuesReaderState(IndexReader,String).mjava","sourceNew":"  /** Creates this, pulling doc values from the specified\n   *  field. */\n  public DefaultSortedSetDocValuesReaderState(IndexReader reader, String field) throws IOException {\n    this.field = field;\n    this.reader = reader;\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    SortedSetDocValues dv = getDocValues();\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      final BytesRef term = dv.lookupOrd(ord);\n      String[] components = FacetsConfig.stringToPath(term.utf8ToString());\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + Arrays.toString(components) + \" \" + term.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","sourceOld":"  /** Creates this, pulling doc values from the specified\n   *  field. */\n  public DefaultSortedSetDocValuesReaderState(IndexReader reader, String field) throws IOException {\n    this.field = field;\n    this.origReader = reader;\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    SortedSetDocValues dv = getDocValues();\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      final BytesRef term = dv.lookupOrd(ord);\n      String[] components = FacetsConfig.stringToPath(term.utf8ToString());\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + Arrays.toString(components) + \" \" + term.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8cfd1df435f04d4287925cca73cf22120f723892":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"],"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1":["53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1","8cfd1df435f04d4287925cca73cf22120f723892"],"53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf":["30fc8c22124fdcf9d76449bd2fa04decbe74e2e2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"30fc8c22124fdcf9d76449bd2fa04decbe74e2e2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8cfd1df435f04d4287925cca73cf22120f723892"]},"commit2Childs":{"8cfd1df435f04d4287925cca73cf22120f723892":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1":["8cfd1df435f04d4287925cca73cf22120f723892","e9017cf144952056066919f1ebc7897ff9bd71b1"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["30fc8c22124fdcf9d76449bd2fa04decbe74e2e2"],"30fc8c22124fdcf9d76449bd2fa04decbe74e2e2":["53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}