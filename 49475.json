{"path":"backwards/src/java/org/apache/lucene/index/DocumentsWriter#applyDeletes(IndexReader,int).mjava","commits":[{"id":"480d01e5b0ef8efb136d51670fec297ae5ae2c9c","date":1268821447,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"backwards/src/java/org/apache/lucene/index/DocumentsWriter#applyDeletes(IndexReader,int).mjava","pathOld":"/dev/null","sourceNew":"  // Apply buffered delete terms, queries and docIDs to the\n  // provided reader\n  private final synchronized boolean applyDeletes(IndexReader reader, int docIDStart)\n    throws CorruptIndexException, IOException {\n\n    final int docEnd = docIDStart + reader.maxDoc();\n    boolean any = false;\n\n    // Delete by term\n    TermDocs docs = reader.termDocs();\n    try {\n      for (Entry<Term, BufferedDeletes.Num> entry: deletesFlushed.terms.entrySet()) {\n        Term term = entry.getKey();\n\n        docs.seek(term);\n        int limit = entry.getValue().getNum();\n        while (docs.next()) {\n          int docID = docs.doc();\n          if (docIDStart+docID >= limit)\n            break;\n          reader.deleteDocument(docID);\n          any = true;\n        }\n      }\n    } finally {\n      docs.close();\n    }\n\n    // Delete by docID\n    for (Integer docIdInt : deletesFlushed.docIDs) {\n      int docID = docIdInt.intValue();\n      if (docID >= docIDStart && docID < docEnd) {\n        reader.deleteDocument(docID-docIDStart);\n        any = true;\n      }\n    }\n\n    // Delete by query\n    IndexSearcher searcher = new IndexSearcher(reader);\n    for (Entry<Query, Integer> entry : deletesFlushed.queries.entrySet()) {\n      Query query = entry.getKey();\n      int limit = entry.getValue().intValue();\n      Weight weight = query.weight(searcher);\n      Scorer scorer = weight.scorer(reader, true, false);\n      if (scorer != null) {\n        while(true)  {\n          int doc = scorer.nextDoc();\n          if (((long) docIDStart) + doc >= limit)\n            break;\n          reader.deleteDocument(doc);\n          any = true;\n        }\n      }\n    }\n    searcher.close();\n    return any;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/backwards/src/java/org/apache/lucene/index/DocumentsWriter#applyDeletes(IndexReader,int).mjava","pathOld":"backwards/src/java/org/apache/lucene/index/DocumentsWriter#applyDeletes(IndexReader,int).mjava","sourceNew":"  // Apply buffered delete terms, queries and docIDs to the\n  // provided reader\n  private final synchronized boolean applyDeletes(IndexReader reader, int docIDStart)\n    throws CorruptIndexException, IOException {\n\n    final int docEnd = docIDStart + reader.maxDoc();\n    boolean any = false;\n\n    // Delete by term\n    TermDocs docs = reader.termDocs();\n    try {\n      for (Entry<Term, BufferedDeletes.Num> entry: deletesFlushed.terms.entrySet()) {\n        Term term = entry.getKey();\n\n        docs.seek(term);\n        int limit = entry.getValue().getNum();\n        while (docs.next()) {\n          int docID = docs.doc();\n          if (docIDStart+docID >= limit)\n            break;\n          reader.deleteDocument(docID);\n          any = true;\n        }\n      }\n    } finally {\n      docs.close();\n    }\n\n    // Delete by docID\n    for (Integer docIdInt : deletesFlushed.docIDs) {\n      int docID = docIdInt.intValue();\n      if (docID >= docIDStart && docID < docEnd) {\n        reader.deleteDocument(docID-docIDStart);\n        any = true;\n      }\n    }\n\n    // Delete by query\n    IndexSearcher searcher = new IndexSearcher(reader);\n    for (Entry<Query, Integer> entry : deletesFlushed.queries.entrySet()) {\n      Query query = entry.getKey();\n      int limit = entry.getValue().intValue();\n      Weight weight = query.weight(searcher);\n      Scorer scorer = weight.scorer(reader, true, false);\n      if (scorer != null) {\n        while(true)  {\n          int doc = scorer.nextDoc();\n          if (((long) docIDStart) + doc >= limit)\n            break;\n          reader.deleteDocument(doc);\n          any = true;\n        }\n      }\n    }\n    searcher.close();\n    return any;\n  }\n\n","sourceOld":"  // Apply buffered delete terms, queries and docIDs to the\n  // provided reader\n  private final synchronized boolean applyDeletes(IndexReader reader, int docIDStart)\n    throws CorruptIndexException, IOException {\n\n    final int docEnd = docIDStart + reader.maxDoc();\n    boolean any = false;\n\n    // Delete by term\n    TermDocs docs = reader.termDocs();\n    try {\n      for (Entry<Term, BufferedDeletes.Num> entry: deletesFlushed.terms.entrySet()) {\n        Term term = entry.getKey();\n\n        docs.seek(term);\n        int limit = entry.getValue().getNum();\n        while (docs.next()) {\n          int docID = docs.doc();\n          if (docIDStart+docID >= limit)\n            break;\n          reader.deleteDocument(docID);\n          any = true;\n        }\n      }\n    } finally {\n      docs.close();\n    }\n\n    // Delete by docID\n    for (Integer docIdInt : deletesFlushed.docIDs) {\n      int docID = docIdInt.intValue();\n      if (docID >= docIDStart && docID < docEnd) {\n        reader.deleteDocument(docID-docIDStart);\n        any = true;\n      }\n    }\n\n    // Delete by query\n    IndexSearcher searcher = new IndexSearcher(reader);\n    for (Entry<Query, Integer> entry : deletesFlushed.queries.entrySet()) {\n      Query query = entry.getKey();\n      int limit = entry.getValue().intValue();\n      Weight weight = query.weight(searcher);\n      Scorer scorer = weight.scorer(reader, true, false);\n      if (scorer != null) {\n        while(true)  {\n          int doc = scorer.nextDoc();\n          if (((long) docIDStart) + doc >= limit)\n            break;\n          reader.deleteDocument(doc);\n          any = true;\n        }\n      }\n    }\n    searcher.close();\n    return any;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"480d01e5b0ef8efb136d51670fec297ae5ae2c9c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["480d01e5b0ef8efb136d51670fec297ae5ae2c9c"]},"commit2Childs":{"480d01e5b0ef8efb136d51670fec297ae5ae2c9c":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["480d01e5b0ef8efb136d51670fec297ae5ae2c9c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}