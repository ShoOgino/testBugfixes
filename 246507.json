{"path":"lucene/core/src/java/org/apache/lucene/store/ByteBufferIndexInput#close().mjava","commits":[{"id":"4e5e734869d76c22acfc12bc53ecbfcc1606c2f5","date":1347072117,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/ByteBufferIndexInput#close().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public final void close() throws IOException {\n    try {\n      if (buffers == null) return;\n      \n      // make local copy, then un-set early\n      final ByteBuffer[] bufs = buffers;\n      unsetBuffers();\n      \n      if (isClone) return;\n      \n      // for extra safety unset also all clones' buffers:\n      for (Iterator<ByteBufferIndexInput> it = this.clones.keyIterator(); it.hasNext();) {\n        final ByteBufferIndexInput clone = it.next();\n        assert clone.isClone;\n        clone.unsetBuffers();\n      }\n      this.clones.clear();\n      \n      for (final ByteBuffer b : bufs) {\n        freeBuffer(b);\n      }\n    } finally {\n      unsetBuffers();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["55d81732702acdcf369ac1e8077a9d11a2559f67"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2f9652410ddb993cf1dabc86cde38d16a16c12e0","date":1358983221,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/ByteBufferIndexInput#close().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/ByteBufferIndexInput#close().mjava","sourceNew":"  @Override\n  public final void close() throws IOException {\n    try {\n      if (buffers == null) return;\n      \n      // make local copy, then un-set early\n      final ByteBuffer[] bufs = buffers;\n      unsetBuffers();\n      clones.remove(this);\n      \n      if (isClone) return;\n      \n      // for extra safety unset also all clones' buffers:\n      for (Iterator<ByteBufferIndexInput> it = this.clones.keyIterator(); it.hasNext();) {\n        final ByteBufferIndexInput clone = it.next();\n        assert clone.isClone;\n        clone.unsetBuffers();\n      }\n      this.clones.clear();\n      \n      for (final ByteBuffer b : bufs) {\n        freeBuffer(b);\n      }\n    } finally {\n      unsetBuffers();\n    }\n  }\n\n","sourceOld":"  @Override\n  public final void close() throws IOException {\n    try {\n      if (buffers == null) return;\n      \n      // make local copy, then un-set early\n      final ByteBuffer[] bufs = buffers;\n      unsetBuffers();\n      \n      if (isClone) return;\n      \n      // for extra safety unset also all clones' buffers:\n      for (Iterator<ByteBufferIndexInput> it = this.clones.keyIterator(); it.hasNext();) {\n        final ByteBufferIndexInput clone = it.next();\n        assert clone.isClone;\n        clone.unsetBuffers();\n      }\n      this.clones.clear();\n      \n      for (final ByteBuffer b : bufs) {\n        freeBuffer(b);\n      }\n    } finally {\n      unsetBuffers();\n    }\n  }\n\n","bugFix":null,"bugIntro":["55d81732702acdcf369ac1e8077a9d11a2559f67"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b2d5244a676b83c2d551c3746e8181588ba619e1","date":1359031414,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/ByteBufferIndexInput#close().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/ByteBufferIndexInput#close().mjava","sourceNew":"  @Override\n  public final void close() throws IOException {\n    try {\n      if (buffers == null) return;\n      \n      // make local copy, then un-set early\n      final ByteBuffer[] bufs = buffers;\n      unsetBuffers();\n      clones.remove(this);\n      \n      if (isClone) return;\n      \n      // for extra safety unset also all clones' buffers:\n      for (Iterator<ByteBufferIndexInput> it = this.clones.keyIterator(); it.hasNext();) {\n        final ByteBufferIndexInput clone = it.next();\n        assert clone.isClone;\n        clone.unsetBuffers();\n      }\n      this.clones.clear();\n      \n      for (final ByteBuffer b : bufs) {\n        freeBuffer(b);\n      }\n    } finally {\n      unsetBuffers();\n    }\n  }\n\n","sourceOld":"  @Override\n  public final void close() throws IOException {\n    try {\n      if (buffers == null) return;\n      \n      // make local copy, then un-set early\n      final ByteBuffer[] bufs = buffers;\n      unsetBuffers();\n      \n      if (isClone) return;\n      \n      // for extra safety unset also all clones' buffers:\n      for (Iterator<ByteBufferIndexInput> it = this.clones.keyIterator(); it.hasNext();) {\n        final ByteBufferIndexInput clone = it.next();\n        assert clone.isClone;\n        clone.unsetBuffers();\n      }\n      this.clones.clear();\n      \n      for (final ByteBuffer b : bufs) {\n        freeBuffer(b);\n      }\n    } finally {\n      unsetBuffers();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55d81732702acdcf369ac1e8077a9d11a2559f67","date":1359801354,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/ByteBufferIndexInput#close().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/ByteBufferIndexInput#close().mjava","sourceNew":"  @Override\n  public final void close() throws IOException {\n    try {\n      if (buffers == null) return;\n      \n      // make local copy, then un-set early\n      final ByteBuffer[] bufs = buffers;\n      unsetBuffers();\n      if (clones != null) {\n        clones.remove(this);\n      }\n      \n      if (isClone) return;\n      \n      // for extra safety unset also all clones' buffers:\n      if (clones != null) {\n        for (Iterator<ByteBufferIndexInput> it = this.clones.keyIterator(); it.hasNext();) {\n          final ByteBufferIndexInput clone = it.next();\n          assert clone.isClone;\n          clone.unsetBuffers();\n        }\n        this.clones.clear();\n      }\n      \n      for (final ByteBuffer b : bufs) {\n        freeBuffer(b);\n      }\n    } finally {\n      unsetBuffers();\n    }\n  }\n\n","sourceOld":"  @Override\n  public final void close() throws IOException {\n    try {\n      if (buffers == null) return;\n      \n      // make local copy, then un-set early\n      final ByteBuffer[] bufs = buffers;\n      unsetBuffers();\n      clones.remove(this);\n      \n      if (isClone) return;\n      \n      // for extra safety unset also all clones' buffers:\n      for (Iterator<ByteBufferIndexInput> it = this.clones.keyIterator(); it.hasNext();) {\n        final ByteBufferIndexInput clone = it.next();\n        assert clone.isClone;\n        clone.unsetBuffers();\n      }\n      this.clones.clear();\n      \n      for (final ByteBuffer b : bufs) {\n        freeBuffer(b);\n      }\n    } finally {\n      unsetBuffers();\n    }\n  }\n\n","bugFix":["4e5e734869d76c22acfc12bc53ecbfcc1606c2f5","2f9652410ddb993cf1dabc86cde38d16a16c12e0"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eb97a913498e2387924cb19fb8be9a95daf6f38a","date":1359823388,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/ByteBufferIndexInput#close().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/ByteBufferIndexInput#close().mjava","sourceNew":"  @Override\n  public final void close() throws IOException {\n    try {\n      if (buffers == null) return;\n      \n      // make local copy, then un-set early\n      final ByteBuffer[] bufs = buffers;\n      unsetBuffers();\n      if (clones != null) {\n        clones.remove(this);\n      }\n      \n      if (isClone) return;\n      \n      // for extra safety unset also all clones' buffers:\n      if (clones != null) {\n        for (Iterator<ByteBufferIndexInput> it = this.clones.keyIterator(); it.hasNext();) {\n          final ByteBufferIndexInput clone = it.next();\n          assert clone.isClone;\n          clone.unsetBuffers();\n        }\n        this.clones.clear();\n      }\n      \n      for (final ByteBuffer b : bufs) {\n        freeBuffer(b);\n      }\n    } finally {\n      unsetBuffers();\n    }\n  }\n\n","sourceOld":"  @Override\n  public final void close() throws IOException {\n    try {\n      if (buffers == null) return;\n      \n      // make local copy, then un-set early\n      final ByteBuffer[] bufs = buffers;\n      unsetBuffers();\n      clones.remove(this);\n      \n      if (isClone) return;\n      \n      // for extra safety unset also all clones' buffers:\n      for (Iterator<ByteBufferIndexInput> it = this.clones.keyIterator(); it.hasNext();) {\n        final ByteBufferIndexInput clone = it.next();\n        assert clone.isClone;\n        clone.unsetBuffers();\n      }\n      this.clones.clear();\n      \n      for (final ByteBuffer b : bufs) {\n        freeBuffer(b);\n      }\n    } finally {\n      unsetBuffers();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"71f8255d67554b78ea0a26a5cdb916a759261aab","date":1471024473,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/ByteBufferIndexInput#close().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/ByteBufferIndexInput#close().mjava","sourceNew":"  @Override\n  public final void close() throws IOException {\n    try {\n      if (buffers == null) return;\n      \n      // make local copy, then un-set early\n      final ByteBuffer[] bufs = buffers;\n      unsetBuffers();\n      \n      if (isClone) return;\n      \n      // tell the guard to invalidate and later unmap the bytebuffers (if supported):\n      guard.invalidateAndUnmap(bufs);\n    } finally {\n      unsetBuffers();\n    }\n  }\n\n","sourceOld":"  @Override\n  public final void close() throws IOException {\n    try {\n      if (buffers == null) return;\n      \n      // make local copy, then un-set early\n      final ByteBuffer[] bufs = buffers;\n      unsetBuffers();\n      if (clones != null) {\n        clones.remove(this);\n      }\n      \n      if (isClone) return;\n      \n      // for extra safety unset also all clones' buffers:\n      if (clones != null) {\n        for (Iterator<ByteBufferIndexInput> it = this.clones.keyIterator(); it.hasNext();) {\n          final ByteBufferIndexInput clone = it.next();\n          assert clone.isClone;\n          clone.unsetBuffers();\n        }\n        this.clones.clear();\n      }\n      \n      for (final ByteBuffer b : bufs) {\n        freeBuffer(b);\n      }\n    } finally {\n      unsetBuffers();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6","date":1471496851,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/ByteBufferIndexInput#close().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/ByteBufferIndexInput#close().mjava","sourceNew":"  @Override\n  public final void close() throws IOException {\n    try {\n      if (buffers == null) return;\n      \n      // make local copy, then un-set early\n      final ByteBuffer[] bufs = buffers;\n      unsetBuffers();\n      \n      if (isClone) return;\n      \n      // tell the guard to invalidate and later unmap the bytebuffers (if supported):\n      guard.invalidateAndUnmap(bufs);\n    } finally {\n      unsetBuffers();\n    }\n  }\n\n","sourceOld":"  @Override\n  public final void close() throws IOException {\n    try {\n      if (buffers == null) return;\n      \n      // make local copy, then un-set early\n      final ByteBuffer[] bufs = buffers;\n      unsetBuffers();\n      if (clones != null) {\n        clones.remove(this);\n      }\n      \n      if (isClone) return;\n      \n      // for extra safety unset also all clones' buffers:\n      if (clones != null) {\n        for (Iterator<ByteBufferIndexInput> it = this.clones.keyIterator(); it.hasNext();) {\n          final ByteBufferIndexInput clone = it.next();\n          assert clone.isClone;\n          clone.unsetBuffers();\n        }\n        this.clones.clear();\n      }\n      \n      for (final ByteBuffer b : bufs) {\n        freeBuffer(b);\n      }\n    } finally {\n      unsetBuffers();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"403d05f7f8d69b65659157eff1bc1d2717f04c66","date":1471692961,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/ByteBufferIndexInput#close().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/ByteBufferIndexInput#close().mjava","sourceNew":"  @Override\n  public final void close() throws IOException {\n    try {\n      if (buffers == null) return;\n      \n      // make local copy, then un-set early\n      final ByteBuffer[] bufs = buffers;\n      unsetBuffers();\n      \n      if (isClone) return;\n      \n      // tell the guard to invalidate and later unmap the bytebuffers (if supported):\n      guard.invalidateAndUnmap(bufs);\n    } finally {\n      unsetBuffers();\n    }\n  }\n\n","sourceOld":"  @Override\n  public final void close() throws IOException {\n    try {\n      if (buffers == null) return;\n      \n      // make local copy, then un-set early\n      final ByteBuffer[] bufs = buffers;\n      unsetBuffers();\n      if (clones != null) {\n        clones.remove(this);\n      }\n      \n      if (isClone) return;\n      \n      // for extra safety unset also all clones' buffers:\n      if (clones != null) {\n        for (Iterator<ByteBufferIndexInput> it = this.clones.keyIterator(); it.hasNext();) {\n          final ByteBufferIndexInput clone = it.next();\n          assert clone.isClone;\n          clone.unsetBuffers();\n        }\n        this.clones.clear();\n      }\n      \n      for (final ByteBuffer b : bufs) {\n        freeBuffer(b);\n      }\n    } finally {\n      unsetBuffers();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/ByteBufferIndexInput#close().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/ByteBufferIndexInput#close().mjava","sourceNew":"  @Override\n  public final void close() throws IOException {\n    try {\n      if (buffers == null) return;\n      \n      // make local copy, then un-set early\n      final ByteBuffer[] bufs = buffers;\n      unsetBuffers();\n      \n      if (isClone) return;\n      \n      // tell the guard to invalidate and later unmap the bytebuffers (if supported):\n      guard.invalidateAndUnmap(bufs);\n    } finally {\n      unsetBuffers();\n    }\n  }\n\n","sourceOld":"  @Override\n  public final void close() throws IOException {\n    try {\n      if (buffers == null) return;\n      \n      // make local copy, then un-set early\n      final ByteBuffer[] bufs = buffers;\n      unsetBuffers();\n      if (clones != null) {\n        clones.remove(this);\n      }\n      \n      if (isClone) return;\n      \n      // for extra safety unset also all clones' buffers:\n      if (clones != null) {\n        for (Iterator<ByteBufferIndexInput> it = this.clones.keyIterator(); it.hasNext();) {\n          final ByteBufferIndexInput clone = it.next();\n          assert clone.isClone;\n          clone.unsetBuffers();\n        }\n        this.clones.clear();\n      }\n      \n      for (final ByteBuffer b : bufs) {\n        freeBuffer(b);\n      }\n    } finally {\n      unsetBuffers();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"403d05f7f8d69b65659157eff1bc1d2717f04c66":["55d81732702acdcf369ac1e8077a9d11a2559f67","2c8bedceb91e64a3f0e831450058fc4a76d2c0a6"],"4e5e734869d76c22acfc12bc53ecbfcc1606c2f5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"eb97a913498e2387924cb19fb8be9a95daf6f38a":["b2d5244a676b83c2d551c3746e8181588ba619e1","55d81732702acdcf369ac1e8077a9d11a2559f67"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2f9652410ddb993cf1dabc86cde38d16a16c12e0":["4e5e734869d76c22acfc12bc53ecbfcc1606c2f5"],"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6":["55d81732702acdcf369ac1e8077a9d11a2559f67","71f8255d67554b78ea0a26a5cdb916a759261aab"],"71f8255d67554b78ea0a26a5cdb916a759261aab":["55d81732702acdcf369ac1e8077a9d11a2559f67"],"55d81732702acdcf369ac1e8077a9d11a2559f67":["2f9652410ddb993cf1dabc86cde38d16a16c12e0"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["55d81732702acdcf369ac1e8077a9d11a2559f67","403d05f7f8d69b65659157eff1bc1d2717f04c66"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"b2d5244a676b83c2d551c3746e8181588ba619e1":["4e5e734869d76c22acfc12bc53ecbfcc1606c2f5","2f9652410ddb993cf1dabc86cde38d16a16c12e0"]},"commit2Childs":{"403d05f7f8d69b65659157eff1bc1d2717f04c66":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4e5e734869d76c22acfc12bc53ecbfcc1606c2f5":["2f9652410ddb993cf1dabc86cde38d16a16c12e0","b2d5244a676b83c2d551c3746e8181588ba619e1"],"eb97a913498e2387924cb19fb8be9a95daf6f38a":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4e5e734869d76c22acfc12bc53ecbfcc1606c2f5"],"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"2f9652410ddb993cf1dabc86cde38d16a16c12e0":["55d81732702acdcf369ac1e8077a9d11a2559f67","b2d5244a676b83c2d551c3746e8181588ba619e1"],"71f8255d67554b78ea0a26a5cdb916a759261aab":["2c8bedceb91e64a3f0e831450058fc4a76d2c0a6"],"55d81732702acdcf369ac1e8077a9d11a2559f67":["403d05f7f8d69b65659157eff1bc1d2717f04c66","eb97a913498e2387924cb19fb8be9a95daf6f38a","2c8bedceb91e64a3f0e831450058fc4a76d2c0a6","71f8255d67554b78ea0a26a5cdb916a759261aab","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"b2d5244a676b83c2d551c3746e8181588ba619e1":["eb97a913498e2387924cb19fb8be9a95daf6f38a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["eb97a913498e2387924cb19fb8be9a95daf6f38a","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}