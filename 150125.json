{"path":"solr/core/src/test/org/apache/solr/TestRandomFaceting#getExpectationForSortByCount(ModifiableSolrParams,List[String]).mjava","commits":[{"id":"39342cb658ac11dfcbf4459807fb00eb9ada0218","date":1472876688,"type":0,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomFaceting#getExpectationForSortByCount(ModifiableSolrParams,List[String]).mjava","pathOld":"/dev/null","sourceNew":"  /** if facet.exists=true with facet.sort=counts,\n   * it should return all values with 1 hits ordered by label index\n   * then all vals with 0 , and then missing count with null label,\n   * in the implementation below they are called three stratas \n   * */\n  private String getExpectationForSortByCount( ModifiableSolrParams params, List<String> methods) throws Exception {\n    String indexSortedResponse = getIndexSortedAllFacetValues(params, methods);\n    \n    return transformFacetFields(indexSortedResponse, e -> {\n      List<Object> facetSortedByIndex = (List<Object>) e.getValue();\n      Map<Integer,List<Object>> stratas = new HashMap<Integer,List<Object>>(){\n        @Override // poor man multimap, I won't do that anymore, I swear.\n        public List<Object> get(Object key) {\n          if (!containsKey(key)) {\n            put((Integer) key, new ArrayList<>());\n          }\n          return super.get(key);\n        }\n      };\n      \n      for (Iterator iterator = facetSortedByIndex.iterator(); iterator.hasNext();) {\n        Object label = (Object) iterator.next();\n        Long count = (Long) iterator.next();\n        final Integer strata;\n        if (label==null) { // missing (here \"stratas\" seems like overengineering )\n          strata = null;\n        }else {\n          if (count>0) {\n            count = 1L; // capping here \n            strata = 1; // non-zero count become zero\n          } else {\n            strata = 0; // zero-count\n          }\n        }\n        final List<Object> facet = stratas.get(strata);\n        facet.add(label);\n        facet.add(count);\n      }\n      List stratified =new ArrayList<>();\n      for(Integer s : new Integer[]{1, 0}) { // non-zero capped to one goes first, zeroes go then\n        stratified.addAll(stratas.get(s));\n      }// cropping them now\n      int offset=params.getInt(\"facet.offset\", 0) * 2;\n      int end = offset + params.getInt(\"facet.limit\", 100) * 2 ;\n      int fromIndex = offset > stratified.size() ?  stratified.size() : offset;\n      stratified = stratified.subList(fromIndex, \n               end > stratified.size() ?  stratified.size() : end);\n      \n      if (params.getInt(\"facet.limit\", 100)>0) { /// limit=0 omits even miss count\n        stratified.addAll(stratas.get(null));\n      }\n      facetSortedByIndex.clear();\n      facetSortedByIndex.addAll(stratified);\n    });\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["7679cc7d5b465ec8936979698cedf5fdbd71c95c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bc8f206328a706450934717bec7ccc22ad166fc0","date":1473142172,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomFaceting#getExpectationForSortByCount(ModifiableSolrParams,List[String]).mjava","pathOld":"/dev/null","sourceNew":"  /** if facet.exists=true with facet.sort=counts,\n   * it should return all values with 1 hits ordered by label index\n   * then all vals with 0 , and then missing count with null label,\n   * in the implementation below they are called three stratas \n   * */\n  private String getExpectationForSortByCount( ModifiableSolrParams params, List<String> methods) throws Exception {\n    String indexSortedResponse = getIndexSortedAllFacetValues(params, methods);\n    \n    return transformFacetFields(indexSortedResponse, e -> {\n      List<Object> facetSortedByIndex = (List<Object>) e.getValue();\n      Map<Integer,List<Object>> stratas = new HashMap<Integer,List<Object>>(){\n        @Override // poor man multimap, I won't do that anymore, I swear.\n        public List<Object> get(Object key) {\n          if (!containsKey(key)) {\n            put((Integer) key, new ArrayList<>());\n          }\n          return super.get(key);\n        }\n      };\n      \n      for (Iterator iterator = facetSortedByIndex.iterator(); iterator.hasNext();) {\n        Object label = (Object) iterator.next();\n        Long count = (Long) iterator.next();\n        final Integer strata;\n        if (label==null) { // missing (here \"stratas\" seems like overengineering )\n          strata = null;\n        }else {\n          if (count>0) {\n            count = 1L; // capping here \n            strata = 1; // non-zero count become zero\n          } else {\n            strata = 0; // zero-count\n          }\n        }\n        final List<Object> facet = stratas.get(strata);\n        facet.add(label);\n        facet.add(count);\n      }\n      List stratified =new ArrayList<>();\n      for(Integer s : new Integer[]{1, 0}) { // non-zero capped to one goes first, zeroes go then\n        stratified.addAll(stratas.get(s));\n      }// cropping them now\n      int offset=params.getInt(\"facet.offset\", 0) * 2;\n      int end = offset + params.getInt(\"facet.limit\", 100) * 2 ;\n      int fromIndex = offset > stratified.size() ?  stratified.size() : offset;\n      stratified = stratified.subList(fromIndex, \n               end > stratified.size() ?  stratified.size() : end);\n      \n      if (params.getInt(\"facet.limit\", 100)>0) { /// limit=0 omits even miss count\n        stratified.addAll(stratas.get(null));\n      }\n      facetSortedByIndex.clear();\n      facetSortedByIndex.addAll(stratified);\n    });\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"89424def13674ea17829b41c5883c54ecc31a132","date":1473767373,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomFaceting#getExpectationForSortByCount(ModifiableSolrParams,List[String]).mjava","pathOld":"/dev/null","sourceNew":"  /** if facet.exists=true with facet.sort=counts,\n   * it should return all values with 1 hits ordered by label index\n   * then all vals with 0 , and then missing count with null label,\n   * in the implementation below they are called three stratas \n   * */\n  private String getExpectationForSortByCount( ModifiableSolrParams params, List<String> methods) throws Exception {\n    String indexSortedResponse = getIndexSortedAllFacetValues(params, methods);\n    \n    return transformFacetFields(indexSortedResponse, e -> {\n      List<Object> facetSortedByIndex = (List<Object>) e.getValue();\n      Map<Integer,List<Object>> stratas = new HashMap<Integer,List<Object>>(){\n        @Override // poor man multimap, I won't do that anymore, I swear.\n        public List<Object> get(Object key) {\n          if (!containsKey(key)) {\n            put((Integer) key, new ArrayList<>());\n          }\n          return super.get(key);\n        }\n      };\n      \n      for (Iterator iterator = facetSortedByIndex.iterator(); iterator.hasNext();) {\n        Object label = (Object) iterator.next();\n        Long count = (Long) iterator.next();\n        final Integer strata;\n        if (label==null) { // missing (here \"stratas\" seems like overengineering )\n          strata = null;\n        }else {\n          if (count>0) {\n            count = 1L; // capping here \n            strata = 1; // non-zero count become zero\n          } else {\n            strata = 0; // zero-count\n          }\n        }\n        final List<Object> facet = stratas.get(strata);\n        facet.add(label);\n        facet.add(count);\n      }\n      List stratified =new ArrayList<>();\n      for(Integer s : new Integer[]{1, 0}) { // non-zero capped to one goes first, zeroes go then\n        stratified.addAll(stratas.get(s));\n      }// cropping them now\n      int offset=params.getInt(\"facet.offset\", 0) * 2;\n      int end = offset + params.getInt(\"facet.limit\", 100) * 2 ;\n      int fromIndex = offset > stratified.size() ?  stratified.size() : offset;\n      stratified = stratified.subList(fromIndex, \n               end > stratified.size() ?  stratified.size() : end);\n      \n      if (params.getInt(\"facet.limit\", 100)>0) { /// limit=0 omits even miss count\n        stratified.addAll(stratas.get(null));\n      }\n      facetSortedByIndex.clear();\n      facetSortedByIndex.addAll(stratified);\n    });\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomFaceting#getExpectationForSortByCount(ModifiableSolrParams,List[String]).mjava","pathOld":"/dev/null","sourceNew":"  /** if facet.exists=true with facet.sort=counts,\n   * it should return all values with 1 hits ordered by label index\n   * then all vals with 0 , and then missing count with null label,\n   * in the implementation below they are called three stratas \n   * */\n  private String getExpectationForSortByCount( ModifiableSolrParams params, List<String> methods) throws Exception {\n    String indexSortedResponse = getIndexSortedAllFacetValues(params, methods);\n    \n    return transformFacetFields(indexSortedResponse, e -> {\n      List<Object> facetSortedByIndex = (List<Object>) e.getValue();\n      Map<Integer,List<Object>> stratas = new HashMap<Integer,List<Object>>(){\n        @Override // poor man multimap, I won't do that anymore, I swear.\n        public List<Object> get(Object key) {\n          if (!containsKey(key)) {\n            put((Integer) key, new ArrayList<>());\n          }\n          return super.get(key);\n        }\n      };\n      \n      for (Iterator iterator = facetSortedByIndex.iterator(); iterator.hasNext();) {\n        Object label = (Object) iterator.next();\n        Long count = (Long) iterator.next();\n        final Integer strata;\n        if (label==null) { // missing (here \"stratas\" seems like overengineering )\n          strata = null;\n        }else {\n          if (count>0) {\n            count = 1L; // capping here \n            strata = 1; // non-zero count become zero\n          } else {\n            strata = 0; // zero-count\n          }\n        }\n        final List<Object> facet = stratas.get(strata);\n        facet.add(label);\n        facet.add(count);\n      }\n      List stratified =new ArrayList<>();\n      for(Integer s : new Integer[]{1, 0}) { // non-zero capped to one goes first, zeroes go then\n        stratified.addAll(stratas.get(s));\n      }// cropping them now\n      int offset=params.getInt(\"facet.offset\", 0) * 2;\n      int end = offset + params.getInt(\"facet.limit\", 100) * 2 ;\n      int fromIndex = offset > stratified.size() ?  stratified.size() : offset;\n      stratified = stratified.subList(fromIndex, \n               end > stratified.size() ?  stratified.size() : end);\n      \n      if (params.getInt(\"facet.limit\", 100)>0) { /// limit=0 omits even miss count\n        stratified.addAll(stratas.get(null));\n      }\n      facetSortedByIndex.clear();\n      facetSortedByIndex.addAll(stratified);\n    });\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomFaceting#getExpectationForSortByCount(ModifiableSolrParams,List[String]).mjava","pathOld":"/dev/null","sourceNew":"  /** if facet.exists=true with facet.sort=counts,\n   * it should return all values with 1 hits ordered by label index\n   * then all vals with 0 , and then missing count with null label,\n   * in the implementation below they are called three stratas \n   * */\n  private String getExpectationForSortByCount( ModifiableSolrParams params, List<String> methods) throws Exception {\n    String indexSortedResponse = getIndexSortedAllFacetValues(params, methods);\n    \n    return transformFacetFields(indexSortedResponse, e -> {\n      List<Object> facetSortedByIndex = (List<Object>) e.getValue();\n      Map<Integer,List<Object>> stratas = new HashMap<Integer,List<Object>>(){\n        @Override // poor man multimap, I won't do that anymore, I swear.\n        public List<Object> get(Object key) {\n          if (!containsKey(key)) {\n            put((Integer) key, new ArrayList<>());\n          }\n          return super.get(key);\n        }\n      };\n      \n      for (Iterator iterator = facetSortedByIndex.iterator(); iterator.hasNext();) {\n        Object label = (Object) iterator.next();\n        Long count = (Long) iterator.next();\n        final Integer strata;\n        if (label==null) { // missing (here \"stratas\" seems like overengineering )\n          strata = null;\n        }else {\n          if (count>0) {\n            count = 1L; // capping here \n            strata = 1; // non-zero count become zero\n          } else {\n            strata = 0; // zero-count\n          }\n        }\n        final List<Object> facet = stratas.get(strata);\n        facet.add(label);\n        facet.add(count);\n      }\n      List stratified =new ArrayList<>();\n      for(Integer s : new Integer[]{1, 0}) { // non-zero capped to one goes first, zeroes go then\n        stratified.addAll(stratas.get(s));\n      }// cropping them now\n      int offset=params.getInt(\"facet.offset\", 0) * 2;\n      int end = offset + params.getInt(\"facet.limit\", 100) * 2 ;\n      int fromIndex = offset > stratified.size() ?  stratified.size() : offset;\n      stratified = stratified.subList(fromIndex, \n               end > stratified.size() ?  stratified.size() : end);\n      \n      if (params.getInt(\"facet.limit\", 100)>0) { /// limit=0 omits even miss count\n        stratified.addAll(stratas.get(null));\n      }\n      facetSortedByIndex.clear();\n      facetSortedByIndex.addAll(stratified);\n    });\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7679cc7d5b465ec8936979698cedf5fdbd71c95c","date":1566227764,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomFaceting#getExpectationForSortByCount(ModifiableSolrParams,List[String]).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestRandomFaceting#getExpectationForSortByCount(ModifiableSolrParams,List[String]).mjava","sourceNew":"  /** if facet.exists=true with facet.sort=counts,\n   * it should return all values with 1 hits ordered by label index\n   * then all vals with 0 , and then missing count with null label,\n   * in the implementation below they are called three stratas \n   * */\n  private String getExpectationForSortByCount( ModifiableSolrParams params, List<String> methods) throws Exception {\n    String indexSortedResponse = getIndexSortedAllFacetValues(params, methods);\n    \n    return transformFacetFields(indexSortedResponse, e -> {\n      List<Object> facetSortedByIndex = (List<Object>) e.getValue();\n      Map<Integer,List<Object>> stratas = new HashMap<Integer,List<Object>>(){\n        @Override // poor man multimap, I won't do that anymore, I swear.\n        public List<Object> get(Object key) {\n          if (!containsKey(key)) {\n            put((Integer) key, new ArrayList<>());\n          }\n          return super.get(key);\n        }\n      };\n      \n      for (Iterator iterator = facetSortedByIndex.iterator(); iterator.hasNext();) {\n        Object label = (Object) iterator.next();\n        Long count = (Long) iterator.next();\n        final Integer strata;\n        if (label==null) { // missing (here \"stratas\" seems like overengineering )\n          strata = null;\n        }else {\n          if (count>0) {\n            count = 1L; // capping here \n            strata = 1; // non-zero count become zero\n          } else {\n            strata = 0; // zero-count\n          }\n        }\n        final List<Object> facet = stratas.get(strata);\n        facet.add(label);\n        facet.add(count);\n      }\n      List stratified =new ArrayList<>();\n      for(Integer s : new Integer[]{1, 0}) { // non-zero capped to one goes first, zeroes go then\n        stratified.addAll(stratas.get(s));\n      }// cropping them now\n      int offset=params.getInt(\"facet.offset\", 0) * 2;\n      int end = offset + params.getInt(\"facet.limit\", 100) * 2 ;\n      int fromIndex = offset > stratified.size() ?  stratified.size() : offset;\n      stratified = stratified.subList(fromIndex, \n               end > stratified.size() ?  stratified.size() : end);\n\n      stratified.addAll(stratas.get(null));\n\n      facetSortedByIndex.clear();\n      facetSortedByIndex.addAll(stratified);\n    });\n  }\n\n","sourceOld":"  /** if facet.exists=true with facet.sort=counts,\n   * it should return all values with 1 hits ordered by label index\n   * then all vals with 0 , and then missing count with null label,\n   * in the implementation below they are called three stratas \n   * */\n  private String getExpectationForSortByCount( ModifiableSolrParams params, List<String> methods) throws Exception {\n    String indexSortedResponse = getIndexSortedAllFacetValues(params, methods);\n    \n    return transformFacetFields(indexSortedResponse, e -> {\n      List<Object> facetSortedByIndex = (List<Object>) e.getValue();\n      Map<Integer,List<Object>> stratas = new HashMap<Integer,List<Object>>(){\n        @Override // poor man multimap, I won't do that anymore, I swear.\n        public List<Object> get(Object key) {\n          if (!containsKey(key)) {\n            put((Integer) key, new ArrayList<>());\n          }\n          return super.get(key);\n        }\n      };\n      \n      for (Iterator iterator = facetSortedByIndex.iterator(); iterator.hasNext();) {\n        Object label = (Object) iterator.next();\n        Long count = (Long) iterator.next();\n        final Integer strata;\n        if (label==null) { // missing (here \"stratas\" seems like overengineering )\n          strata = null;\n        }else {\n          if (count>0) {\n            count = 1L; // capping here \n            strata = 1; // non-zero count become zero\n          } else {\n            strata = 0; // zero-count\n          }\n        }\n        final List<Object> facet = stratas.get(strata);\n        facet.add(label);\n        facet.add(count);\n      }\n      List stratified =new ArrayList<>();\n      for(Integer s : new Integer[]{1, 0}) { // non-zero capped to one goes first, zeroes go then\n        stratified.addAll(stratas.get(s));\n      }// cropping them now\n      int offset=params.getInt(\"facet.offset\", 0) * 2;\n      int end = offset + params.getInt(\"facet.limit\", 100) * 2 ;\n      int fromIndex = offset > stratified.size() ?  stratified.size() : offset;\n      stratified = stratified.subList(fromIndex, \n               end > stratified.size() ?  stratified.size() : end);\n      \n      if (params.getInt(\"facet.limit\", 100)>0) { /// limit=0 omits even miss count\n        stratified.addAll(stratas.get(null));\n      }\n      facetSortedByIndex.clear();\n      facetSortedByIndex.addAll(stratified);\n    });\n  }\n\n","bugFix":["39342cb658ac11dfcbf4459807fb00eb9ada0218"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e98520789adb1d5ad05afb4956eca0944a929688","date":1592430701,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestRandomFaceting#getExpectationForSortByCount(ModifiableSolrParams,List[String]).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestRandomFaceting#getExpectationForSortByCount(ModifiableSolrParams,List[String]).mjava","sourceNew":"  /** if facet.exists=true with facet.sort=counts,\n   * it should return all values with 1 hits ordered by label index\n   * then all vals with 0 , and then missing count with null label,\n   * in the implementation below they are called three stratas \n   * */\n  @SuppressWarnings({\"unchecked\"})\n  private String getExpectationForSortByCount( ModifiableSolrParams params, List<String> methods) throws Exception {\n    String indexSortedResponse = getIndexSortedAllFacetValues(params, methods);\n    \n    return transformFacetFields(indexSortedResponse, e -> {\n      List<Object> facetSortedByIndex = (List<Object>) e.getValue();\n      Map<Integer,List<Object>> stratas = new HashMap<Integer,List<Object>>(){\n        @Override // poor man multimap, I won't do that anymore, I swear.\n        public List<Object> get(Object key) {\n          if (!containsKey(key)) {\n            put((Integer) key, new ArrayList<>());\n          }\n          return super.get(key);\n        }\n      };\n      \n      for (@SuppressWarnings({\"rawtypes\"})Iterator iterator = facetSortedByIndex.iterator(); iterator.hasNext();) {\n        Object label = iterator.next();\n        Long count = (Long) iterator.next();\n        final Integer strata;\n        if (label==null) { // missing (here \"stratas\" seems like overengineering )\n          strata = null;\n        }else {\n          if (count>0) {\n            count = 1L; // capping here \n            strata = 1; // non-zero count become zero\n          } else {\n            strata = 0; // zero-count\n          }\n        }\n        final List<Object> facet = stratas.get(strata);\n        facet.add(label);\n        facet.add(count);\n      }\n      @SuppressWarnings({\"rawtypes\"})\n      List stratified =new ArrayList<>();\n      for(Integer s : new Integer[]{1, 0}) { // non-zero capped to one goes first, zeroes go then\n        stratified.addAll(stratas.get(s));\n      }// cropping them now\n      int offset=params.getInt(\"facet.offset\", 0) * 2;\n      int end = offset + params.getInt(\"facet.limit\", 100) * 2 ;\n      int fromIndex = offset > stratified.size() ?  stratified.size() : offset;\n      stratified = stratified.subList(fromIndex, \n               end > stratified.size() ?  stratified.size() : end);\n\n      stratified.addAll(stratas.get(null));\n\n      facetSortedByIndex.clear();\n      facetSortedByIndex.addAll(stratified);\n    });\n  }\n\n","sourceOld":"  /** if facet.exists=true with facet.sort=counts,\n   * it should return all values with 1 hits ordered by label index\n   * then all vals with 0 , and then missing count with null label,\n   * in the implementation below they are called three stratas \n   * */\n  private String getExpectationForSortByCount( ModifiableSolrParams params, List<String> methods) throws Exception {\n    String indexSortedResponse = getIndexSortedAllFacetValues(params, methods);\n    \n    return transformFacetFields(indexSortedResponse, e -> {\n      List<Object> facetSortedByIndex = (List<Object>) e.getValue();\n      Map<Integer,List<Object>> stratas = new HashMap<Integer,List<Object>>(){\n        @Override // poor man multimap, I won't do that anymore, I swear.\n        public List<Object> get(Object key) {\n          if (!containsKey(key)) {\n            put((Integer) key, new ArrayList<>());\n          }\n          return super.get(key);\n        }\n      };\n      \n      for (Iterator iterator = facetSortedByIndex.iterator(); iterator.hasNext();) {\n        Object label = (Object) iterator.next();\n        Long count = (Long) iterator.next();\n        final Integer strata;\n        if (label==null) { // missing (here \"stratas\" seems like overengineering )\n          strata = null;\n        }else {\n          if (count>0) {\n            count = 1L; // capping here \n            strata = 1; // non-zero count become zero\n          } else {\n            strata = 0; // zero-count\n          }\n        }\n        final List<Object> facet = stratas.get(strata);\n        facet.add(label);\n        facet.add(count);\n      }\n      List stratified =new ArrayList<>();\n      for(Integer s : new Integer[]{1, 0}) { // non-zero capped to one goes first, zeroes go then\n        stratified.addAll(stratas.get(s));\n      }// cropping them now\n      int offset=params.getInt(\"facet.offset\", 0) * 2;\n      int end = offset + params.getInt(\"facet.limit\", 100) * 2 ;\n      int fromIndex = offset > stratified.size() ?  stratified.size() : offset;\n      stratified = stratified.subList(fromIndex, \n               end > stratified.size() ?  stratified.size() : end);\n\n      stratified.addAll(stratas.get(null));\n\n      facetSortedByIndex.clear();\n      facetSortedByIndex.addAll(stratified);\n    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7679cc7d5b465ec8936979698cedf5fdbd71c95c":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","89424def13674ea17829b41c5883c54ecc31a132"],"bc8f206328a706450934717bec7ccc22ad166fc0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","39342cb658ac11dfcbf4459807fb00eb9ada0218"],"39342cb658ac11dfcbf4459807fb00eb9ada0218":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e98520789adb1d5ad05afb4956eca0944a929688"],"e98520789adb1d5ad05afb4956eca0944a929688":["7679cc7d5b465ec8936979698cedf5fdbd71c95c"],"89424def13674ea17829b41c5883c54ecc31a132":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","bc8f206328a706450934717bec7ccc22ad166fc0"]},"commit2Childs":{"7679cc7d5b465ec8936979698cedf5fdbd71c95c":["e98520789adb1d5ad05afb4956eca0944a929688"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["7679cc7d5b465ec8936979698cedf5fdbd71c95c","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","bc8f206328a706450934717bec7ccc22ad166fc0","39342cb658ac11dfcbf4459807fb00eb9ada0218","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","89424def13674ea17829b41c5883c54ecc31a132"],"bc8f206328a706450934717bec7ccc22ad166fc0":["89424def13674ea17829b41c5883c54ecc31a132"],"39342cb658ac11dfcbf4459807fb00eb9ada0218":["bc8f206328a706450934717bec7ccc22ad166fc0"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"89424def13674ea17829b41c5883c54ecc31a132":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"e98520789adb1d5ad05afb4956eca0944a929688":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}