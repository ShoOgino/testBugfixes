{"path":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testMergeExceptionIsTragic().mjava","commits":[{"id":"d9e22bdf0692bfa61e342b04a6ac7078670c1e16","date":1436866730,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testMergeExceptionIsTragic().mjava","pathOld":"/dev/null","sourceNew":"  public void testMergeExceptionIsTragic() throws Exception {\n    MockDirectoryWrapper dir = newMockDirectory();\n    final AtomicBoolean didFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n        \n        @Override\n        public void eval(MockDirectoryWrapper dir) throws IOException {\n          if (random().nextInt(10) != 0) {\n            return;\n          }\n          if (didFail.get()) {\n            // Already failed\n            return;\n          }\n          StackTraceElement[] trace = Thread.currentThread().getStackTrace();\n          \n          for (int i = 0; i < trace.length; i++) {\n            if (\"merge\".equals(trace[i].getMethodName())) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: now fail; thread=\" + Thread.currentThread().getName() + \" exc:\");\n                new Throwable().printStackTrace(System.out);\n              }\n              didFail.set(true);\n              throw new FakeIOException();\n            }\n          }\n        }\n      });\n\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    MergeScheduler ms = iwc.getMergeScheduler();\n    if (ms instanceof ConcurrentMergeScheduler) {\n      ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n\n    while (true) {\n      try {\n        Document doc = new Document();\n        doc.add(newStringField(\"field\", \"string\", Field.Store.NO));\n        w.addDocument(doc);\n        if (random().nextInt(10) == 7) {\n          // Flush new segment:\n          DirectoryReader.open(w, true).close();\n        }\n      } catch (AlreadyClosedException ace) {\n        // OK: e.g. CMS hit the exc in BG thread and closed the writer\n        break;\n      } catch (FakeIOException fioe) {\n        // OK: e.g. SMS hit the exception\n        break;\n      }\n    }\n\n    assertNotNull(w.getTragicException());\n    assertFalse(w.isOpen());\n    assertTrue(didFail.get());\n\n    if (ms instanceof ConcurrentMergeScheduler) {\n      // Sneaky: CMS's merge thread will be concurrently rolling back IW due\n      // to the tragedy, with this main thread, so we have to wait here\n      // to ensure the rollback has finished, else MDW still sees open files:\n      ((ConcurrentMergeScheduler) ms).sync();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d19286a1d9d5ef1e34294f4926188d5233ad81b8","date":1449048345,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testMergeExceptionIsTragic().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testMergeExceptionIsTragic().mjava","sourceNew":"  public void testMergeExceptionIsTragic() throws Exception {\n    MockDirectoryWrapper dir = newMockDirectory();\n    final AtomicBoolean didFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n        \n        @Override\n        public void eval(MockDirectoryWrapper dir) throws IOException {\n          if (random().nextInt(10) != 0) {\n            return;\n          }\n          if (didFail.get()) {\n            // Already failed\n            return;\n          }\n          StackTraceElement[] trace = Thread.currentThread().getStackTrace();\n          \n          for (int i = 0; i < trace.length; i++) {\n            if (\"merge\".equals(trace[i].getMethodName())) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: now fail; thread=\" + Thread.currentThread().getName() + \" exc:\");\n                new Throwable().printStackTrace(System.out);\n              }\n              didFail.set(true);\n              throw new FakeIOException();\n            }\n          }\n        }\n      });\n\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    MergePolicy mp = iwc.getMergePolicy();\n    if (mp instanceof TieredMergePolicy) {\n      TieredMergePolicy tmp = (TieredMergePolicy) mp;\n      if (tmp.getMaxMergedSegmentMB() < 0.2) {\n        tmp.setMaxMergedSegmentMB(0.2);\n      }\n    }\n    MergeScheduler ms = iwc.getMergeScheduler();\n    if (ms instanceof ConcurrentMergeScheduler) {\n      ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n\n    while (true) {\n      try {\n        Document doc = new Document();\n        doc.add(newStringField(\"field\", \"string\", Field.Store.NO));\n        w.addDocument(doc);\n        if (random().nextInt(10) == 7) {\n          // Flush new segment:\n          DirectoryReader.open(w, true).close();\n        }\n      } catch (AlreadyClosedException ace) {\n        // OK: e.g. CMS hit the exc in BG thread and closed the writer\n        break;\n      } catch (FakeIOException fioe) {\n        // OK: e.g. SMS hit the exception\n        break;\n      }\n    }\n\n    assertNotNull(w.getTragicException());\n    assertFalse(w.isOpen());\n    assertTrue(didFail.get());\n\n    if (ms instanceof ConcurrentMergeScheduler) {\n      // Sneaky: CMS's merge thread will be concurrently rolling back IW due\n      // to the tragedy, with this main thread, so we have to wait here\n      // to ensure the rollback has finished, else MDW still sees open files:\n      ((ConcurrentMergeScheduler) ms).sync();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testMergeExceptionIsTragic() throws Exception {\n    MockDirectoryWrapper dir = newMockDirectory();\n    final AtomicBoolean didFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n        \n        @Override\n        public void eval(MockDirectoryWrapper dir) throws IOException {\n          if (random().nextInt(10) != 0) {\n            return;\n          }\n          if (didFail.get()) {\n            // Already failed\n            return;\n          }\n          StackTraceElement[] trace = Thread.currentThread().getStackTrace();\n          \n          for (int i = 0; i < trace.length; i++) {\n            if (\"merge\".equals(trace[i].getMethodName())) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: now fail; thread=\" + Thread.currentThread().getName() + \" exc:\");\n                new Throwable().printStackTrace(System.out);\n              }\n              didFail.set(true);\n              throw new FakeIOException();\n            }\n          }\n        }\n      });\n\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    MergeScheduler ms = iwc.getMergeScheduler();\n    if (ms instanceof ConcurrentMergeScheduler) {\n      ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n\n    while (true) {\n      try {\n        Document doc = new Document();\n        doc.add(newStringField(\"field\", \"string\", Field.Store.NO));\n        w.addDocument(doc);\n        if (random().nextInt(10) == 7) {\n          // Flush new segment:\n          DirectoryReader.open(w, true).close();\n        }\n      } catch (AlreadyClosedException ace) {\n        // OK: e.g. CMS hit the exc in BG thread and closed the writer\n        break;\n      } catch (FakeIOException fioe) {\n        // OK: e.g. SMS hit the exception\n        break;\n      }\n    }\n\n    assertNotNull(w.getTragicException());\n    assertFalse(w.isOpen());\n    assertTrue(didFail.get());\n\n    if (ms instanceof ConcurrentMergeScheduler) {\n      // Sneaky: CMS's merge thread will be concurrently rolling back IW due\n      // to the tragedy, with this main thread, so we have to wait here\n      // to ensure the rollback has finished, else MDW still sees open files:\n      ((ConcurrentMergeScheduler) ms).sync();\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a1862266772deb28cdcb7d996b64d2177022687","date":1453077824,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testMergeExceptionIsTragic().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testMergeExceptionIsTragic().mjava","sourceNew":"  public void testMergeExceptionIsTragic() throws Exception {\n    MockDirectoryWrapper dir = newMockDirectory();\n    final AtomicBoolean didFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n        \n        @Override\n        public void eval(MockDirectoryWrapper dir) throws IOException {\n          if (random().nextInt(10) != 0) {\n            return;\n          }\n          if (didFail.get()) {\n            // Already failed\n            return;\n          }\n          StackTraceElement[] trace = Thread.currentThread().getStackTrace();\n          \n          for (int i = 0; i < trace.length; i++) {\n            if (\"merge\".equals(trace[i].getMethodName())) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: now fail; thread=\" + Thread.currentThread().getName() + \" exc:\");\n                new Throwable().printStackTrace(System.out);\n              }\n              didFail.set(true);\n              throw new FakeIOException();\n            }\n          }\n        }\n      });\n\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    MergePolicy mp = iwc.getMergePolicy();\n    if (mp instanceof TieredMergePolicy) {\n      TieredMergePolicy tmp = (TieredMergePolicy) mp;\n      if (tmp.getMaxMergedSegmentMB() < 0.2) {\n        tmp.setMaxMergedSegmentMB(0.2);\n      }\n    }\n    MergeScheduler ms = iwc.getMergeScheduler();\n    if (ms instanceof ConcurrentMergeScheduler) {\n      ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n\n    while (true) {\n      try {\n        Document doc = new Document();\n        doc.add(newStringField(\"field\", \"string\", Field.Store.NO));\n        w.addDocument(doc);\n        if (random().nextInt(10) == 7) {\n          // Flush new segment:\n          DirectoryReader.open(w).close();\n        }\n      } catch (AlreadyClosedException ace) {\n        // OK: e.g. CMS hit the exc in BG thread and closed the writer\n        break;\n      } catch (FakeIOException fioe) {\n        // OK: e.g. SMS hit the exception\n        break;\n      }\n    }\n\n    assertNotNull(w.getTragicException());\n    assertFalse(w.isOpen());\n    assertTrue(didFail.get());\n\n    if (ms instanceof ConcurrentMergeScheduler) {\n      // Sneaky: CMS's merge thread will be concurrently rolling back IW due\n      // to the tragedy, with this main thread, so we have to wait here\n      // to ensure the rollback has finished, else MDW still sees open files:\n      ((ConcurrentMergeScheduler) ms).sync();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testMergeExceptionIsTragic() throws Exception {\n    MockDirectoryWrapper dir = newMockDirectory();\n    final AtomicBoolean didFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n        \n        @Override\n        public void eval(MockDirectoryWrapper dir) throws IOException {\n          if (random().nextInt(10) != 0) {\n            return;\n          }\n          if (didFail.get()) {\n            // Already failed\n            return;\n          }\n          StackTraceElement[] trace = Thread.currentThread().getStackTrace();\n          \n          for (int i = 0; i < trace.length; i++) {\n            if (\"merge\".equals(trace[i].getMethodName())) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: now fail; thread=\" + Thread.currentThread().getName() + \" exc:\");\n                new Throwable().printStackTrace(System.out);\n              }\n              didFail.set(true);\n              throw new FakeIOException();\n            }\n          }\n        }\n      });\n\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    MergePolicy mp = iwc.getMergePolicy();\n    if (mp instanceof TieredMergePolicy) {\n      TieredMergePolicy tmp = (TieredMergePolicy) mp;\n      if (tmp.getMaxMergedSegmentMB() < 0.2) {\n        tmp.setMaxMergedSegmentMB(0.2);\n      }\n    }\n    MergeScheduler ms = iwc.getMergeScheduler();\n    if (ms instanceof ConcurrentMergeScheduler) {\n      ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n\n    while (true) {\n      try {\n        Document doc = new Document();\n        doc.add(newStringField(\"field\", \"string\", Field.Store.NO));\n        w.addDocument(doc);\n        if (random().nextInt(10) == 7) {\n          // Flush new segment:\n          DirectoryReader.open(w, true).close();\n        }\n      } catch (AlreadyClosedException ace) {\n        // OK: e.g. CMS hit the exc in BG thread and closed the writer\n        break;\n      } catch (FakeIOException fioe) {\n        // OK: e.g. SMS hit the exception\n        break;\n      }\n    }\n\n    assertNotNull(w.getTragicException());\n    assertFalse(w.isOpen());\n    assertTrue(didFail.get());\n\n    if (ms instanceof ConcurrentMergeScheduler) {\n      // Sneaky: CMS's merge thread will be concurrently rolling back IW due\n      // to the tragedy, with this main thread, so we have to wait here\n      // to ensure the rollback has finished, else MDW still sees open files:\n      ((ConcurrentMergeScheduler) ms).sync();\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2916966cc9815e973c01452a0d76c98c5e0d0926","date":1577444040,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testMergeExceptionIsTragic().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testMergeExceptionIsTragic().mjava","sourceNew":"  public void testMergeExceptionIsTragic() throws Exception {\n    MockDirectoryWrapper dir = newMockDirectory();\n    final AtomicBoolean didFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n        \n        @Override\n        public void eval(MockDirectoryWrapper dir) throws IOException {\n          if (random().nextInt(10) != 0) {\n            return;\n          }\n          if (didFail.get()) {\n            // Already failed\n            return;\n          }\n\n          if (callStackContainsAnyOf(\"merge\")) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: now fail; thread=\" + Thread.currentThread().getName() + \" exc:\");\n              new Throwable().printStackTrace(System.out);\n            }\n            didFail.set(true);\n            throw new FakeIOException();\n          }\n        }\n      });\n\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    MergePolicy mp = iwc.getMergePolicy();\n    if (mp instanceof TieredMergePolicy) {\n      TieredMergePolicy tmp = (TieredMergePolicy) mp;\n      if (tmp.getMaxMergedSegmentMB() < 0.2) {\n        tmp.setMaxMergedSegmentMB(0.2);\n      }\n    }\n    MergeScheduler ms = iwc.getMergeScheduler();\n    if (ms instanceof ConcurrentMergeScheduler) {\n      ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n\n    while (true) {\n      try {\n        Document doc = new Document();\n        doc.add(newStringField(\"field\", \"string\", Field.Store.NO));\n        w.addDocument(doc);\n        if (random().nextInt(10) == 7) {\n          // Flush new segment:\n          DirectoryReader.open(w).close();\n        }\n      } catch (AlreadyClosedException ace) {\n        // OK: e.g. CMS hit the exc in BG thread and closed the writer\n        break;\n      } catch (FakeIOException fioe) {\n        // OK: e.g. SMS hit the exception\n        break;\n      }\n    }\n\n    assertNotNull(w.getTragicException());\n    assertFalse(w.isOpen());\n    assertTrue(didFail.get());\n\n    if (ms instanceof ConcurrentMergeScheduler) {\n      // Sneaky: CMS's merge thread will be concurrently rolling back IW due\n      // to the tragedy, with this main thread, so we have to wait here\n      // to ensure the rollback has finished, else MDW still sees open files:\n      ((ConcurrentMergeScheduler) ms).sync();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testMergeExceptionIsTragic() throws Exception {\n    MockDirectoryWrapper dir = newMockDirectory();\n    final AtomicBoolean didFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n        \n        @Override\n        public void eval(MockDirectoryWrapper dir) throws IOException {\n          if (random().nextInt(10) != 0) {\n            return;\n          }\n          if (didFail.get()) {\n            // Already failed\n            return;\n          }\n          StackTraceElement[] trace = Thread.currentThread().getStackTrace();\n          \n          for (int i = 0; i < trace.length; i++) {\n            if (\"merge\".equals(trace[i].getMethodName())) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: now fail; thread=\" + Thread.currentThread().getName() + \" exc:\");\n                new Throwable().printStackTrace(System.out);\n              }\n              didFail.set(true);\n              throw new FakeIOException();\n            }\n          }\n        }\n      });\n\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    MergePolicy mp = iwc.getMergePolicy();\n    if (mp instanceof TieredMergePolicy) {\n      TieredMergePolicy tmp = (TieredMergePolicy) mp;\n      if (tmp.getMaxMergedSegmentMB() < 0.2) {\n        tmp.setMaxMergedSegmentMB(0.2);\n      }\n    }\n    MergeScheduler ms = iwc.getMergeScheduler();\n    if (ms instanceof ConcurrentMergeScheduler) {\n      ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n\n    while (true) {\n      try {\n        Document doc = new Document();\n        doc.add(newStringField(\"field\", \"string\", Field.Store.NO));\n        w.addDocument(doc);\n        if (random().nextInt(10) == 7) {\n          // Flush new segment:\n          DirectoryReader.open(w).close();\n        }\n      } catch (AlreadyClosedException ace) {\n        // OK: e.g. CMS hit the exc in BG thread and closed the writer\n        break;\n      } catch (FakeIOException fioe) {\n        // OK: e.g. SMS hit the exception\n        break;\n      }\n    }\n\n    assertNotNull(w.getTragicException());\n    assertFalse(w.isOpen());\n    assertTrue(didFail.get());\n\n    if (ms instanceof ConcurrentMergeScheduler) {\n      // Sneaky: CMS's merge thread will be concurrently rolling back IW due\n      // to the tragedy, with this main thread, so we have to wait here\n      // to ensure the rollback has finished, else MDW still sees open files:\n      ((ConcurrentMergeScheduler) ms).sync();\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"94ec73c5617c177b1d81ddfe04bbff1d08fccecc","date":1577456244,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testMergeExceptionIsTragic().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testMergeExceptionIsTragic().mjava","sourceNew":"  public void testMergeExceptionIsTragic() throws Exception {\n    MockDirectoryWrapper dir = newMockDirectory();\n    final AtomicBoolean didFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n        \n        @Override\n        public void eval(MockDirectoryWrapper dir) throws IOException {\n          if (random().nextInt(10) != 0) {\n            return;\n          }\n          if (didFail.get()) {\n            // Already failed\n            return;\n          }\n\n          if (callStackContainsAnyOf(\"merge\")) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: now fail; thread=\" + Thread.currentThread().getName() + \" exc:\");\n              new Throwable().printStackTrace(System.out);\n            }\n            didFail.set(true);\n            throw new FakeIOException();\n          }\n        }\n      });\n\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    MergePolicy mp = iwc.getMergePolicy();\n    if (mp instanceof TieredMergePolicy) {\n      TieredMergePolicy tmp = (TieredMergePolicy) mp;\n      if (tmp.getMaxMergedSegmentMB() < 0.2) {\n        tmp.setMaxMergedSegmentMB(0.2);\n      }\n    }\n    MergeScheduler ms = iwc.getMergeScheduler();\n    if (ms instanceof ConcurrentMergeScheduler) {\n      ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n\n    while (true) {\n      try {\n        Document doc = new Document();\n        doc.add(newStringField(\"field\", \"string\", Field.Store.NO));\n        w.addDocument(doc);\n        if (random().nextInt(10) == 7) {\n          // Flush new segment:\n          DirectoryReader.open(w).close();\n        }\n      } catch (AlreadyClosedException ace) {\n        // OK: e.g. CMS hit the exc in BG thread and closed the writer\n        break;\n      } catch (FakeIOException fioe) {\n        // OK: e.g. SMS hit the exception\n        break;\n      }\n    }\n\n    assertNotNull(w.getTragicException());\n    assertFalse(w.isOpen());\n    assertTrue(didFail.get());\n\n    if (ms instanceof ConcurrentMergeScheduler) {\n      // Sneaky: CMS's merge thread will be concurrently rolling back IW due\n      // to the tragedy, with this main thread, so we have to wait here\n      // to ensure the rollback has finished, else MDW still sees open files:\n      ((ConcurrentMergeScheduler) ms).sync();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testMergeExceptionIsTragic() throws Exception {\n    MockDirectoryWrapper dir = newMockDirectory();\n    final AtomicBoolean didFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n        \n        @Override\n        public void eval(MockDirectoryWrapper dir) throws IOException {\n          if (random().nextInt(10) != 0) {\n            return;\n          }\n          if (didFail.get()) {\n            // Already failed\n            return;\n          }\n          StackTraceElement[] trace = Thread.currentThread().getStackTrace();\n          \n          for (int i = 0; i < trace.length; i++) {\n            if (\"merge\".equals(trace[i].getMethodName())) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: now fail; thread=\" + Thread.currentThread().getName() + \" exc:\");\n                new Throwable().printStackTrace(System.out);\n              }\n              didFail.set(true);\n              throw new FakeIOException();\n            }\n          }\n        }\n      });\n\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    MergePolicy mp = iwc.getMergePolicy();\n    if (mp instanceof TieredMergePolicy) {\n      TieredMergePolicy tmp = (TieredMergePolicy) mp;\n      if (tmp.getMaxMergedSegmentMB() < 0.2) {\n        tmp.setMaxMergedSegmentMB(0.2);\n      }\n    }\n    MergeScheduler ms = iwc.getMergeScheduler();\n    if (ms instanceof ConcurrentMergeScheduler) {\n      ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n\n    while (true) {\n      try {\n        Document doc = new Document();\n        doc.add(newStringField(\"field\", \"string\", Field.Store.NO));\n        w.addDocument(doc);\n        if (random().nextInt(10) == 7) {\n          // Flush new segment:\n          DirectoryReader.open(w).close();\n        }\n      } catch (AlreadyClosedException ace) {\n        // OK: e.g. CMS hit the exc in BG thread and closed the writer\n        break;\n      } catch (FakeIOException fioe) {\n        // OK: e.g. SMS hit the exception\n        break;\n      }\n    }\n\n    assertNotNull(w.getTragicException());\n    assertFalse(w.isOpen());\n    assertTrue(didFail.get());\n\n    if (ms instanceof ConcurrentMergeScheduler) {\n      // Sneaky: CMS's merge thread will be concurrently rolling back IW due\n      // to the tragedy, with this main thread, so we have to wait here\n      // to ensure the rollback has finished, else MDW still sees open files:\n      ((ConcurrentMergeScheduler) ms).sync();\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57c6c784f777a2cc8fa014507ea129526822714d","date":1579733373,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testMergeExceptionIsTragic().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testMergeExceptionIsTragic().mjava","sourceNew":"  // TODO: can be super slow in pathological cases (merge config?)\n  @Nightly\n  public void testMergeExceptionIsTragic() throws Exception {\n    MockDirectoryWrapper dir = newMockDirectory();\n    final AtomicBoolean didFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n        \n        @Override\n        public void eval(MockDirectoryWrapper dir) throws IOException {\n          if (random().nextInt(10) != 0) {\n            return;\n          }\n          if (didFail.get()) {\n            // Already failed\n            return;\n          }\n\n          if (callStackContainsAnyOf(\"merge\")) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: now fail; thread=\" + Thread.currentThread().getName() + \" exc:\");\n              new Throwable().printStackTrace(System.out);\n            }\n            didFail.set(true);\n            throw new FakeIOException();\n          }\n        }\n      });\n\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    MergePolicy mp = iwc.getMergePolicy();\n    if (mp instanceof TieredMergePolicy) {\n      TieredMergePolicy tmp = (TieredMergePolicy) mp;\n      if (tmp.getMaxMergedSegmentMB() < 0.2) {\n        tmp.setMaxMergedSegmentMB(0.2);\n      }\n    }\n    MergeScheduler ms = iwc.getMergeScheduler();\n    if (ms instanceof ConcurrentMergeScheduler) {\n      ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n\n    while (true) {\n      try {\n        Document doc = new Document();\n        doc.add(newStringField(\"field\", \"string\", Field.Store.NO));\n        w.addDocument(doc);\n        if (random().nextInt(10) == 7) {\n          // Flush new segment:\n          DirectoryReader.open(w).close();\n        }\n      } catch (AlreadyClosedException ace) {\n        // OK: e.g. CMS hit the exc in BG thread and closed the writer\n        break;\n      } catch (FakeIOException fioe) {\n        // OK: e.g. SMS hit the exception\n        break;\n      }\n    }\n\n    assertNotNull(w.getTragicException());\n    assertFalse(w.isOpen());\n    assertTrue(didFail.get());\n\n    if (ms instanceof ConcurrentMergeScheduler) {\n      // Sneaky: CMS's merge thread will be concurrently rolling back IW due\n      // to the tragedy, with this main thread, so we have to wait here\n      // to ensure the rollback has finished, else MDW still sees open files:\n      ((ConcurrentMergeScheduler) ms).sync();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testMergeExceptionIsTragic() throws Exception {\n    MockDirectoryWrapper dir = newMockDirectory();\n    final AtomicBoolean didFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n        \n        @Override\n        public void eval(MockDirectoryWrapper dir) throws IOException {\n          if (random().nextInt(10) != 0) {\n            return;\n          }\n          if (didFail.get()) {\n            // Already failed\n            return;\n          }\n\n          if (callStackContainsAnyOf(\"merge\")) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: now fail; thread=\" + Thread.currentThread().getName() + \" exc:\");\n              new Throwable().printStackTrace(System.out);\n            }\n            didFail.set(true);\n            throw new FakeIOException();\n          }\n        }\n      });\n\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    MergePolicy mp = iwc.getMergePolicy();\n    if (mp instanceof TieredMergePolicy) {\n      TieredMergePolicy tmp = (TieredMergePolicy) mp;\n      if (tmp.getMaxMergedSegmentMB() < 0.2) {\n        tmp.setMaxMergedSegmentMB(0.2);\n      }\n    }\n    MergeScheduler ms = iwc.getMergeScheduler();\n    if (ms instanceof ConcurrentMergeScheduler) {\n      ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n    }\n    IndexWriter w = new IndexWriter(dir, iwc);\n\n    while (true) {\n      try {\n        Document doc = new Document();\n        doc.add(newStringField(\"field\", \"string\", Field.Store.NO));\n        w.addDocument(doc);\n        if (random().nextInt(10) == 7) {\n          // Flush new segment:\n          DirectoryReader.open(w).close();\n        }\n      } catch (AlreadyClosedException ace) {\n        // OK: e.g. CMS hit the exc in BG thread and closed the writer\n        break;\n      } catch (FakeIOException fioe) {\n        // OK: e.g. SMS hit the exception\n        break;\n      }\n    }\n\n    assertNotNull(w.getTragicException());\n    assertFalse(w.isOpen());\n    assertTrue(didFail.get());\n\n    if (ms instanceof ConcurrentMergeScheduler) {\n      // Sneaky: CMS's merge thread will be concurrently rolling back IW due\n      // to the tragedy, with this main thread, so we have to wait here\n      // to ensure the rollback has finished, else MDW still sees open files:\n      ((ConcurrentMergeScheduler) ms).sync();\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"57c6c784f777a2cc8fa014507ea129526822714d":["2916966cc9815e973c01452a0d76c98c5e0d0926"],"d9e22bdf0692bfa61e342b04a6ac7078670c1e16":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2a1862266772deb28cdcb7d996b64d2177022687":["d19286a1d9d5ef1e34294f4926188d5233ad81b8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2916966cc9815e973c01452a0d76c98c5e0d0926":["2a1862266772deb28cdcb7d996b64d2177022687"],"d19286a1d9d5ef1e34294f4926188d5233ad81b8":["d9e22bdf0692bfa61e342b04a6ac7078670c1e16"],"94ec73c5617c177b1d81ddfe04bbff1d08fccecc":["2a1862266772deb28cdcb7d996b64d2177022687","2916966cc9815e973c01452a0d76c98c5e0d0926"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["57c6c784f777a2cc8fa014507ea129526822714d"]},"commit2Childs":{"57c6c784f777a2cc8fa014507ea129526822714d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d9e22bdf0692bfa61e342b04a6ac7078670c1e16":["d19286a1d9d5ef1e34294f4926188d5233ad81b8"],"2a1862266772deb28cdcb7d996b64d2177022687":["2916966cc9815e973c01452a0d76c98c5e0d0926","94ec73c5617c177b1d81ddfe04bbff1d08fccecc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d9e22bdf0692bfa61e342b04a6ac7078670c1e16"],"2916966cc9815e973c01452a0d76c98c5e0d0926":["57c6c784f777a2cc8fa014507ea129526822714d","94ec73c5617c177b1d81ddfe04bbff1d08fccecc"],"d19286a1d9d5ef1e34294f4926188d5233ad81b8":["2a1862266772deb28cdcb7d996b64d2177022687"],"94ec73c5617c177b1d81ddfe04bbff1d08fccecc":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["94ec73c5617c177b1d81ddfe04bbff1d08fccecc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}