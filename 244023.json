{"path":"solr/core/src/java/org/apache/solr/rest/RestManager.Registry#registerManagedResource(String,Class[#-extends-ManagedResource],ManagedResourceObserver).mjava","commits":[{"id":"afb6bf9ce227ab6aac5068547e286ecc958b8b9d","date":1394661169,"type":0,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/rest/RestManager.Registry#registerManagedResource(String,Class[#-extends-ManagedResource],ManagedResourceObserver).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Register the need to use a ManagedResource; this method is typically called\n     * by a Solr component during core initialization to register itself as an \n     * observer of a specific type of ManagedResource. As many Solr components may\n     * share the same ManagedResource, this method only serves to associate the\n     * observer with an endpoint and implementation class. The actual construction\n     * of the ManagedResource and loading of data from storage occurs later once\n     * the RestManager is fully initialized.\n     * @param resourceId - An endpoint in the Rest API to manage the resource; must\n     * start with /config and /schema.\n     * @param implClass - Class that implements ManagedResource.\n     * @param observer - Solr component that needs to know when the data being managed\n     * by the ManagedResource is loaded, such as a TokenFilter.\n     */\n    public synchronized void registerManagedResource(String resourceId, \n        Class<? extends ManagedResource> implClass, ManagedResourceObserver observer) {\n      \n      if (resourceId == null)\n        throw new IllegalArgumentException(\n            \"Must provide a non-null resourceId to register a ManagedResource!\");\n\n      Matcher resourceIdValidator = resourceIdRegex.matcher(resourceId);\n      if (!resourceIdValidator.matches()) {\n        String errMsg = String.format(Locale.ROOT,\n            \"Invalid resourceId '%s'; must start with %s or %s.\",\n            resourceId, CONFIG_BASE_PATH, SCHEMA_BASE_PATH);\n        throw new SolrException(ErrorCode.SERVER_ERROR, errMsg);        \n      }\n         \n      // protect reserved REST API endpoints from being used by another\n      Matcher reservedEndpointsMatcher = reservedEndpointsPattern.matcher(resourceId);\n      if (reservedEndpointsMatcher.matches()) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            reservedEndpointsMatcher.group(1)\n            + \" is a reserved endpoint used by the Solr REST API!\");\n      }\n\n      // IMPORTANT: this code should assume there is no RestManager at this point\n      \n      // it's ok to re-register the same class for an existing path\n      ManagedResourceRegistration reg = registered.get(resourceId);\n      if (reg != null) {\n        if (!reg.implClass.equals(implClass)) {\n          String errMsg = String.format(Locale.ROOT,\n              \"REST API path %s already registered to instances of %s\",\n              resourceId, reg.implClass.getName());\n          throw new SolrException(ErrorCode.SERVER_ERROR, errMsg);          \n        } \n        \n        if (observer != null) {\n          reg.observers.add(observer);\n          log.info(\"Added observer of type {} to existing ManagedResource {}\", \n              observer.getClass().getName(), resourceId);\n        }\n      } else {\n        registered.put(resourceId, \n            new ManagedResourceRegistration(resourceId, implClass, observer));\n        log.info(\"Registered ManagedResource impl {} for path {}\", \n            implClass.getName(), resourceId);\n      }\n    }    \n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bdf16ebe435fc9daea90a73b8683ff001c6d3523","date":1409931231,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/rest/RestManager.Registry#registerManagedResource(String,Class[#-extends-ManagedResource],ManagedResourceObserver).mjava","pathOld":"solr/core/src/java/org/apache/solr/rest/RestManager.Registry#registerManagedResource(String,Class[#-extends-ManagedResource],ManagedResourceObserver).mjava","sourceNew":"    /**\n     * Register the need to use a ManagedResource; this method is typically called\n     * by a Solr component during core initialization to register itself as an \n     * observer of a specific type of ManagedResource. As many Solr components may\n     * share the same ManagedResource, this method only serves to associate the\n     * observer with an endpoint and implementation class. The actual construction\n     * of the ManagedResource and loading of data from storage occurs later once\n     * the RestManager is fully initialized.\n     * @param resourceId - An endpoint in the Rest API to manage the resource; must\n     * start with /config and /schema.\n     * @param implClass - Class that implements ManagedResource.\n     * @param observer - Solr component that needs to know when the data being managed\n     * by the ManagedResource is loaded, such as a TokenFilter.\n     */\n    public synchronized void registerManagedResource(String resourceId, \n        Class<? extends ManagedResource> implClass, ManagedResourceObserver observer) {\n      \n      if (resourceId == null)\n        throw new IllegalArgumentException(\n            \"Must provide a non-null resourceId to register a ManagedResource!\");\n\n      Matcher resourceIdValidator = resourceIdRegex.matcher(resourceId);\n      if (!resourceIdValidator.matches()) {\n        String errMsg = String.format(Locale.ROOT,\n            \"Invalid resourceId '%s'; must start with %s or %s.\",\n            resourceId, CONFIG_BASE_PATH, SCHEMA_BASE_PATH);\n        throw new SolrException(ErrorCode.SERVER_ERROR, errMsg);        \n      }\n         \n      // protect reserved REST API endpoints from being used by another\n      Matcher reservedEndpointsMatcher = reservedEndpointsPattern.matcher(resourceId);\n      if (reservedEndpointsMatcher.matches()) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            reservedEndpointsMatcher.group(1)\n            + \" is a reserved endpoint used by the Solr REST API!\");\n      }\n\n      // IMPORTANT: this code should assume there is no RestManager at this point\n      \n      // it's ok to re-register the same class for an existing path\n      ManagedResourceRegistration reg = registered.get(resourceId);\n      if (reg != null) {\n        if (!reg.implClass.equals(implClass)) {\n          String errMsg = String.format(Locale.ROOT,\n              \"REST API path %s already registered to instances of %s\",\n              resourceId, reg.implClass.getName());\n          throw new SolrException(ErrorCode.SERVER_ERROR, errMsg);          \n        } \n        \n        if (observer != null) {\n          reg.observers.add(observer);\n          log.info(\"Added observer of type {} to existing ManagedResource {}\", \n              observer.getClass().getName(), resourceId);\n        }\n      } else {\n        registered.put(resourceId, \n            new ManagedResourceRegistration(resourceId, implClass, observer));\n        log.info(\"Registered ManagedResource impl {} for path {}\", \n            implClass.getName(), resourceId);\n      }\n      \n      // there may be a RestManager, in which case, we want to add this new ManagedResource immediately\n      if (initializedRestManager != null) {\n        initializedRestManager.addRegisteredResource(registered.get(resourceId));\n      }\n    }    \n\n","sourceOld":"    /**\n     * Register the need to use a ManagedResource; this method is typically called\n     * by a Solr component during core initialization to register itself as an \n     * observer of a specific type of ManagedResource. As many Solr components may\n     * share the same ManagedResource, this method only serves to associate the\n     * observer with an endpoint and implementation class. The actual construction\n     * of the ManagedResource and loading of data from storage occurs later once\n     * the RestManager is fully initialized.\n     * @param resourceId - An endpoint in the Rest API to manage the resource; must\n     * start with /config and /schema.\n     * @param implClass - Class that implements ManagedResource.\n     * @param observer - Solr component that needs to know when the data being managed\n     * by the ManagedResource is loaded, such as a TokenFilter.\n     */\n    public synchronized void registerManagedResource(String resourceId, \n        Class<? extends ManagedResource> implClass, ManagedResourceObserver observer) {\n      \n      if (resourceId == null)\n        throw new IllegalArgumentException(\n            \"Must provide a non-null resourceId to register a ManagedResource!\");\n\n      Matcher resourceIdValidator = resourceIdRegex.matcher(resourceId);\n      if (!resourceIdValidator.matches()) {\n        String errMsg = String.format(Locale.ROOT,\n            \"Invalid resourceId '%s'; must start with %s or %s.\",\n            resourceId, CONFIG_BASE_PATH, SCHEMA_BASE_PATH);\n        throw new SolrException(ErrorCode.SERVER_ERROR, errMsg);        \n      }\n         \n      // protect reserved REST API endpoints from being used by another\n      Matcher reservedEndpointsMatcher = reservedEndpointsPattern.matcher(resourceId);\n      if (reservedEndpointsMatcher.matches()) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            reservedEndpointsMatcher.group(1)\n            + \" is a reserved endpoint used by the Solr REST API!\");\n      }\n\n      // IMPORTANT: this code should assume there is no RestManager at this point\n      \n      // it's ok to re-register the same class for an existing path\n      ManagedResourceRegistration reg = registered.get(resourceId);\n      if (reg != null) {\n        if (!reg.implClass.equals(implClass)) {\n          String errMsg = String.format(Locale.ROOT,\n              \"REST API path %s already registered to instances of %s\",\n              resourceId, reg.implClass.getName());\n          throw new SolrException(ErrorCode.SERVER_ERROR, errMsg);          \n        } \n        \n        if (observer != null) {\n          reg.observers.add(observer);\n          log.info(\"Added observer of type {} to existing ManagedResource {}\", \n              observer.getClass().getName(), resourceId);\n        }\n      } else {\n        registered.put(resourceId, \n            new ManagedResourceRegistration(resourceId, implClass, observer));\n        log.info(\"Registered ManagedResource impl {} for path {}\", \n            implClass.getName(), resourceId);\n      }\n    }    \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"858c0f62e7b20002e4d94702c510512fb6292988","date":1417427955,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/rest/RestManager.Registry#registerManagedResource(String,Class[#-extends-ManagedResource],ManagedResourceObserver).mjava","pathOld":"solr/core/src/java/org/apache/solr/rest/RestManager.Registry#registerManagedResource(String,Class[#-extends-ManagedResource],ManagedResourceObserver).mjava","sourceNew":"    /**\n     * Register the need to use a ManagedResource; this method is typically called\n     * by a Solr component during core initialization to register itself as an \n     * observer of a specific type of ManagedResource. As many Solr components may\n     * share the same ManagedResource, this method only serves to associate the\n     * observer with an endpoint and implementation class. The actual construction\n     * of the ManagedResource and loading of data from storage occurs later once\n     * the RestManager is fully initialized.\n     * @param resourceId - An endpoint in the Rest API to manage the resource; must\n     * start with /config and /schema.\n     * @param implClass - Class that implements ManagedResource.\n     * @param observer - Solr component that needs to know when the data being managed\n     * by the ManagedResource is loaded, such as a TokenFilter.\n     */\n    public synchronized void registerManagedResource(String resourceId, \n        Class<? extends ManagedResource> implClass, ManagedResourceObserver observer) {\n      \n      if (resourceId == null)\n        throw new IllegalArgumentException(\n            \"Must provide a non-null resourceId to register a ManagedResource!\");\n\n      Matcher resourceIdValidator = resourceIdRegex.matcher(resourceId);\n      if (!resourceIdValidator.matches()) {\n        String errMsg = String.format(Locale.ROOT,\n            \"Invalid resourceId '%s'; must start with  %s.\",\n            resourceId,  SCHEMA_BASE_PATH);\n        throw new SolrException(ErrorCode.SERVER_ERROR, errMsg);        \n      }\n         \n      // protect reserved REST API endpoints from being used by another\n      Matcher reservedEndpointsMatcher = reservedEndpointsPattern.matcher(resourceId);\n      if (reservedEndpointsMatcher.matches()) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            reservedEndpointsMatcher.group(1)\n            + \" is a reserved endpoint used by the Solr REST API!\");\n      }\n\n      // IMPORTANT: this code should assume there is no RestManager at this point\n      \n      // it's ok to re-register the same class for an existing path\n      ManagedResourceRegistration reg = registered.get(resourceId);\n      if (reg != null) {\n        if (!reg.implClass.equals(implClass)) {\n          String errMsg = String.format(Locale.ROOT,\n              \"REST API path %s already registered to instances of %s\",\n              resourceId, reg.implClass.getName());\n          throw new SolrException(ErrorCode.SERVER_ERROR, errMsg);          \n        } \n        \n        if (observer != null) {\n          reg.observers.add(observer);\n          log.info(\"Added observer of type {} to existing ManagedResource {}\", \n              observer.getClass().getName(), resourceId);\n        }\n      } else {\n        registered.put(resourceId, \n            new ManagedResourceRegistration(resourceId, implClass, observer));\n        log.info(\"Registered ManagedResource impl {} for path {}\", \n            implClass.getName(), resourceId);\n      }\n      \n      // there may be a RestManager, in which case, we want to add this new ManagedResource immediately\n      if (initializedRestManager != null) {\n        initializedRestManager.addRegisteredResource(registered.get(resourceId));\n      }\n    }    \n\n","sourceOld":"    /**\n     * Register the need to use a ManagedResource; this method is typically called\n     * by a Solr component during core initialization to register itself as an \n     * observer of a specific type of ManagedResource. As many Solr components may\n     * share the same ManagedResource, this method only serves to associate the\n     * observer with an endpoint and implementation class. The actual construction\n     * of the ManagedResource and loading of data from storage occurs later once\n     * the RestManager is fully initialized.\n     * @param resourceId - An endpoint in the Rest API to manage the resource; must\n     * start with /config and /schema.\n     * @param implClass - Class that implements ManagedResource.\n     * @param observer - Solr component that needs to know when the data being managed\n     * by the ManagedResource is loaded, such as a TokenFilter.\n     */\n    public synchronized void registerManagedResource(String resourceId, \n        Class<? extends ManagedResource> implClass, ManagedResourceObserver observer) {\n      \n      if (resourceId == null)\n        throw new IllegalArgumentException(\n            \"Must provide a non-null resourceId to register a ManagedResource!\");\n\n      Matcher resourceIdValidator = resourceIdRegex.matcher(resourceId);\n      if (!resourceIdValidator.matches()) {\n        String errMsg = String.format(Locale.ROOT,\n            \"Invalid resourceId '%s'; must start with %s or %s.\",\n            resourceId, CONFIG_BASE_PATH, SCHEMA_BASE_PATH);\n        throw new SolrException(ErrorCode.SERVER_ERROR, errMsg);        \n      }\n         \n      // protect reserved REST API endpoints from being used by another\n      Matcher reservedEndpointsMatcher = reservedEndpointsPattern.matcher(resourceId);\n      if (reservedEndpointsMatcher.matches()) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            reservedEndpointsMatcher.group(1)\n            + \" is a reserved endpoint used by the Solr REST API!\");\n      }\n\n      // IMPORTANT: this code should assume there is no RestManager at this point\n      \n      // it's ok to re-register the same class for an existing path\n      ManagedResourceRegistration reg = registered.get(resourceId);\n      if (reg != null) {\n        if (!reg.implClass.equals(implClass)) {\n          String errMsg = String.format(Locale.ROOT,\n              \"REST API path %s already registered to instances of %s\",\n              resourceId, reg.implClass.getName());\n          throw new SolrException(ErrorCode.SERVER_ERROR, errMsg);          \n        } \n        \n        if (observer != null) {\n          reg.observers.add(observer);\n          log.info(\"Added observer of type {} to existing ManagedResource {}\", \n              observer.getClass().getName(), resourceId);\n        }\n      } else {\n        registered.put(resourceId, \n            new ManagedResourceRegistration(resourceId, implClass, observer));\n        log.info(\"Registered ManagedResource impl {} for path {}\", \n            implClass.getName(), resourceId);\n      }\n      \n      // there may be a RestManager, in which case, we want to add this new ManagedResource immediately\n      if (initializedRestManager != null) {\n        initializedRestManager.addRegisteredResource(registered.get(resourceId));\n      }\n    }    \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"716cfb7876e1d813737493c55157adc5883673ae","date":1568392527,"type":3,"author":"Thomas Wöckinger","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/rest/RestManager.Registry#registerManagedResource(String,Class[#-extends-ManagedResource],ManagedResourceObserver).mjava","pathOld":"solr/core/src/java/org/apache/solr/rest/RestManager.Registry#registerManagedResource(String,Class[#-extends-ManagedResource],ManagedResourceObserver).mjava","sourceNew":"    /**\n     * Register the need to use a ManagedResource; this method is typically called\n     * by a Solr component during core initialization to register itself as an \n     * observer of a specific type of ManagedResource. As many Solr components may\n     * share the same ManagedResource, this method only serves to associate the\n     * observer with an endpoint and implementation class. The actual construction\n     * of the ManagedResource and loading of data from storage occurs later once\n     * the RestManager is fully initialized.\n     * @param resourceId - An endpoint in the Rest API to manage the resource; must\n     * start with /config and /schema.\n     * @param implClass - Class that implements ManagedResource.\n     * @param observer - Solr component that needs to know when the data being managed\n     * by the ManagedResource is loaded, such as a TokenFilter.\n     */\n    public synchronized void registerManagedResource(String resourceId, \n        Class<? extends ManagedResource> implClass, ManagedResourceObserver observer) {\n      \n      if (resourceId == null)\n        throw new IllegalArgumentException(\n            \"Must provide a non-null resourceId to register a ManagedResource!\");\n\n      Matcher resourceIdValidator = resourceIdRegex.matcher(resourceId);\n      if (!resourceIdValidator.matches()) {\n        String errMsg = String.format(Locale.ROOT,\n            \"Invalid resourceId '%s'; must start with  %s.\",\n            resourceId,  SCHEMA_BASE_PATH);\n        throw new SolrException(ErrorCode.SERVER_ERROR, errMsg);        \n      }\n         \n      // protect reserved REST API endpoints from being used by another\n      Matcher reservedEndpointsMatcher = reservedEndpointsPattern.matcher(resourceId);\n      if (reservedEndpointsMatcher.matches()) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            reservedEndpointsMatcher.group(1)\n            + \" is a reserved endpoint used by the Solr REST API!\");\n      }\n\n      // IMPORTANT: this code should assume there is no RestManager at this point\n      \n      // it's ok to re-register the same class for an existing path\n      ManagedResourceRegistration reg = registered.get(resourceId);\n      if (reg != null) {\n        if (!reg.implClass.equals(implClass)) {\n          String errMsg = String.format(Locale.ROOT,\n              \"REST API path %s already registered to instances of %s\",\n              resourceId, reg.implClass.getName());\n          throw new SolrException(ErrorCode.SERVER_ERROR, errMsg);          \n        } \n        \n        if (observer != null) {\n          reg.observers.add(observer);\n          log.info(\"Added observer of type {} to existing ManagedResource {}\", \n              observer.getClass().getName(), resourceId);\n        }\n      } else {\n        registered.put(resourceId, \n            new ManagedResourceRegistration(resourceId, implClass, observer));\n        log.info(\"Registered ManagedResource impl {} for path {}\", \n            implClass.getName(), resourceId);\n      }\n      \n      // there may be a RestManager, in which case, we want to add this new ManagedResource immediately\n      if (initializedRestManager != null && initializedRestManager.getManagedResourceOrNull(resourceId) == null) {\n        initializedRestManager.addRegisteredResource(registered.get(resourceId));\n      }\n    }    \n\n","sourceOld":"    /**\n     * Register the need to use a ManagedResource; this method is typically called\n     * by a Solr component during core initialization to register itself as an \n     * observer of a specific type of ManagedResource. As many Solr components may\n     * share the same ManagedResource, this method only serves to associate the\n     * observer with an endpoint and implementation class. The actual construction\n     * of the ManagedResource and loading of data from storage occurs later once\n     * the RestManager is fully initialized.\n     * @param resourceId - An endpoint in the Rest API to manage the resource; must\n     * start with /config and /schema.\n     * @param implClass - Class that implements ManagedResource.\n     * @param observer - Solr component that needs to know when the data being managed\n     * by the ManagedResource is loaded, such as a TokenFilter.\n     */\n    public synchronized void registerManagedResource(String resourceId, \n        Class<? extends ManagedResource> implClass, ManagedResourceObserver observer) {\n      \n      if (resourceId == null)\n        throw new IllegalArgumentException(\n            \"Must provide a non-null resourceId to register a ManagedResource!\");\n\n      Matcher resourceIdValidator = resourceIdRegex.matcher(resourceId);\n      if (!resourceIdValidator.matches()) {\n        String errMsg = String.format(Locale.ROOT,\n            \"Invalid resourceId '%s'; must start with  %s.\",\n            resourceId,  SCHEMA_BASE_PATH);\n        throw new SolrException(ErrorCode.SERVER_ERROR, errMsg);        \n      }\n         \n      // protect reserved REST API endpoints from being used by another\n      Matcher reservedEndpointsMatcher = reservedEndpointsPattern.matcher(resourceId);\n      if (reservedEndpointsMatcher.matches()) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            reservedEndpointsMatcher.group(1)\n            + \" is a reserved endpoint used by the Solr REST API!\");\n      }\n\n      // IMPORTANT: this code should assume there is no RestManager at this point\n      \n      // it's ok to re-register the same class for an existing path\n      ManagedResourceRegistration reg = registered.get(resourceId);\n      if (reg != null) {\n        if (!reg.implClass.equals(implClass)) {\n          String errMsg = String.format(Locale.ROOT,\n              \"REST API path %s already registered to instances of %s\",\n              resourceId, reg.implClass.getName());\n          throw new SolrException(ErrorCode.SERVER_ERROR, errMsg);          \n        } \n        \n        if (observer != null) {\n          reg.observers.add(observer);\n          log.info(\"Added observer of type {} to existing ManagedResource {}\", \n              observer.getClass().getName(), resourceId);\n        }\n      } else {\n        registered.put(resourceId, \n            new ManagedResourceRegistration(resourceId, implClass, observer));\n        log.info(\"Registered ManagedResource impl {} for path {}\", \n            implClass.getName(), resourceId);\n      }\n      \n      // there may be a RestManager, in which case, we want to add this new ManagedResource immediately\n      if (initializedRestManager != null) {\n        initializedRestManager.addRegisteredResource(registered.get(resourceId));\n      }\n    }    \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"140be51d03394488536f4aacedace29f9b318347","date":1587170432,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/rest/RestManager.Registry#registerManagedResource(String,Class[#-extends-ManagedResource],ManagedResourceObserver).mjava","pathOld":"solr/core/src/java/org/apache/solr/rest/RestManager.Registry#registerManagedResource(String,Class[#-extends-ManagedResource],ManagedResourceObserver).mjava","sourceNew":"    /**\n     * Register the need to use a ManagedResource; this method is typically called\n     * by a Solr component during core initialization to register itself as an \n     * observer of a specific type of ManagedResource. As many Solr components may\n     * share the same ManagedResource, this method only serves to associate the\n     * observer with an endpoint and implementation class. The actual construction\n     * of the ManagedResource and loading of data from storage occurs later once\n     * the RestManager is fully initialized.\n     * @param resourceId - An endpoint in the Rest API to manage the resource; must\n     * start with /config and /schema.\n     * @param implClass - Class that implements ManagedResource.\n     * @param observer - Solr component that needs to know when the data being managed\n     * by the ManagedResource is loaded, such as a TokenFilter.\n     */\n    public synchronized void registerManagedResource(String resourceId, \n        Class<? extends ManagedResource> implClass, ManagedResourceObserver observer) {\n      \n      if (resourceId == null)\n        throw new IllegalArgumentException(\n            \"Must provide a non-null resourceId to register a ManagedResource!\");\n\n      Matcher resourceIdValidator = resourceIdRegex.matcher(resourceId);\n      if (!resourceIdValidator.matches()) {\n        String errMsg = String.format(Locale.ROOT,\n            \"Invalid resourceId '%s'; must start with  %s.\",\n            resourceId,  SCHEMA_BASE_PATH);\n        throw new SolrException(ErrorCode.SERVER_ERROR, errMsg);        \n      }\n         \n      // protect reserved REST API endpoints from being used by another\n      Matcher reservedEndpointsMatcher = reservedEndpointsPattern.matcher(resourceId);\n      if (reservedEndpointsMatcher.matches()) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            reservedEndpointsMatcher.group(1)\n            + \" is a reserved endpoint used by the Solr REST API!\");\n      }\n\n      // IMPORTANT: this code should assume there is no RestManager at this point\n      \n      // it's ok to re-register the same class for an existing path\n      ManagedResourceRegistration reg = registered.get(resourceId);\n      if (reg != null) {\n        if (!reg.implClass.equals(implClass)) {\n          String errMsg = String.format(Locale.ROOT,\n              \"REST API path %s already registered to instances of %s\",\n              resourceId, reg.implClass.getName());\n          throw new SolrException(ErrorCode.SERVER_ERROR, errMsg);          \n        } \n        \n        if (observer != null) {\n          reg.observers.add(observer);\n          if (log.isInfoEnabled()) {\n            log.info(\"Added observer of type {} to existing ManagedResource {}\",\n                observer.getClass().getName(), resourceId);\n          }\n        }\n      } else {\n        registered.put(resourceId, \n            new ManagedResourceRegistration(resourceId, implClass, observer));\n        if (log.isInfoEnabled()) {\n          log.info(\"Registered ManagedResource impl {} for path {}\", implClass.getName(), resourceId);\n        }\n      }\n      \n      // there may be a RestManager, in which case, we want to add this new ManagedResource immediately\n      if (initializedRestManager != null && initializedRestManager.getManagedResourceOrNull(resourceId) == null) {\n        initializedRestManager.addRegisteredResource(registered.get(resourceId));\n      }\n    }    \n\n","sourceOld":"    /**\n     * Register the need to use a ManagedResource; this method is typically called\n     * by a Solr component during core initialization to register itself as an \n     * observer of a specific type of ManagedResource. As many Solr components may\n     * share the same ManagedResource, this method only serves to associate the\n     * observer with an endpoint and implementation class. The actual construction\n     * of the ManagedResource and loading of data from storage occurs later once\n     * the RestManager is fully initialized.\n     * @param resourceId - An endpoint in the Rest API to manage the resource; must\n     * start with /config and /schema.\n     * @param implClass - Class that implements ManagedResource.\n     * @param observer - Solr component that needs to know when the data being managed\n     * by the ManagedResource is loaded, such as a TokenFilter.\n     */\n    public synchronized void registerManagedResource(String resourceId, \n        Class<? extends ManagedResource> implClass, ManagedResourceObserver observer) {\n      \n      if (resourceId == null)\n        throw new IllegalArgumentException(\n            \"Must provide a non-null resourceId to register a ManagedResource!\");\n\n      Matcher resourceIdValidator = resourceIdRegex.matcher(resourceId);\n      if (!resourceIdValidator.matches()) {\n        String errMsg = String.format(Locale.ROOT,\n            \"Invalid resourceId '%s'; must start with  %s.\",\n            resourceId,  SCHEMA_BASE_PATH);\n        throw new SolrException(ErrorCode.SERVER_ERROR, errMsg);        \n      }\n         \n      // protect reserved REST API endpoints from being used by another\n      Matcher reservedEndpointsMatcher = reservedEndpointsPattern.matcher(resourceId);\n      if (reservedEndpointsMatcher.matches()) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            reservedEndpointsMatcher.group(1)\n            + \" is a reserved endpoint used by the Solr REST API!\");\n      }\n\n      // IMPORTANT: this code should assume there is no RestManager at this point\n      \n      // it's ok to re-register the same class for an existing path\n      ManagedResourceRegistration reg = registered.get(resourceId);\n      if (reg != null) {\n        if (!reg.implClass.equals(implClass)) {\n          String errMsg = String.format(Locale.ROOT,\n              \"REST API path %s already registered to instances of %s\",\n              resourceId, reg.implClass.getName());\n          throw new SolrException(ErrorCode.SERVER_ERROR, errMsg);          \n        } \n        \n        if (observer != null) {\n          reg.observers.add(observer);\n          log.info(\"Added observer of type {} to existing ManagedResource {}\", \n              observer.getClass().getName(), resourceId);\n        }\n      } else {\n        registered.put(resourceId, \n            new ManagedResourceRegistration(resourceId, implClass, observer));\n        log.info(\"Registered ManagedResource impl {} for path {}\", \n            implClass.getName(), resourceId);\n      }\n      \n      // there may be a RestManager, in which case, we want to add this new ManagedResource immediately\n      if (initializedRestManager != null && initializedRestManager.getManagedResourceOrNull(resourceId) == null) {\n        initializedRestManager.addRegisteredResource(registered.get(resourceId));\n      }\n    }    \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89fd5bce15c8e0ca1b10c9988cff9fdcc88c152b","date":1601832109,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/rest/RestManager.Registry#registerManagedResource(String,Class[#-extends-ManagedResource],ManagedResourceObserver).mjava","pathOld":"solr/core/src/java/org/apache/solr/rest/RestManager.Registry#registerManagedResource(String,Class[#-extends-ManagedResource],ManagedResourceObserver).mjava","sourceNew":"    /**\n     * Register the need to use a ManagedResource; this method is typically called\n     * by a Solr component during core initialization to register itself as an \n     * observer of a specific type of ManagedResource. As many Solr components may\n     * share the same ManagedResource, this method only serves to associate the\n     * observer with an endpoint and implementation class. The actual construction\n     * of the ManagedResource and loading of data from storage occurs later once\n     * the RestManager is fully initialized.\n     * @param resourceId - An endpoint in the Rest API to manage the resource; must\n     * start with /config and /schema.\n     * @param implClass - Class that implements ManagedResource.\n     * @param observer - Solr component that needs to know when the data being managed\n     * by the ManagedResource is loaded, such as a TokenFilter.\n     */\n    public synchronized void registerManagedResource(String resourceId, \n        Class<? extends ManagedResource> implClass, ManagedResourceObserver observer) {\n      \n      if (resourceId == null)\n        throw new IllegalArgumentException(\n            \"Must provide a non-null resourceId to register a ManagedResource!\");\n\n      Matcher resourceIdValidator = resourceIdRegex.matcher(resourceId);\n      if (!resourceIdValidator.matches()) {\n        String errMsg = String.format(Locale.ROOT,\n            \"Invalid resourceId '%s'; must start with  %s.\",\n            resourceId,  SCHEMA_BASE_PATH);\n        throw new SolrException(ErrorCode.SERVER_ERROR, errMsg);        \n      }\n         \n      // protect reserved REST API endpoints from being used by another\n      Matcher reservedEndpointsMatcher = reservedEndpointsPattern.matcher(resourceId);\n      if (reservedEndpointsMatcher.matches()) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            reservedEndpointsMatcher.group(1)\n            + \" is a reserved endpoint used by the Solr REST API!\");\n      }\n\n      // IMPORTANT: this code should assume there is no RestManager at this point\n      \n      // it's ok to re-register the same class for an existing path\n      ManagedResourceRegistration reg = registered.get(resourceId);\n      if (reg != null) {\n        if (!implClass.equals(reg.implClass)) {\n          String errMsg = String.format(Locale.ROOT,\n              \"REST API path %s already registered to instances of %s\",\n              resourceId, reg.implClass.getName());\n          throw new SolrException(ErrorCode.SERVER_ERROR, errMsg);          \n        } \n        \n        if (observer != null) {\n          reg.observers.add(observer);\n          if (log.isInfoEnabled()) {\n            log.info(\"Added observer of type {} to existing ManagedResource {}\",\n                observer.getClass().getName(), resourceId);\n          }\n        }\n      } else {\n        registered.put(resourceId, \n            new ManagedResourceRegistration(resourceId, implClass, observer));\n        if (log.isInfoEnabled()) {\n          log.info(\"Registered ManagedResource impl {} for path {}\", implClass.getName(), resourceId);\n        }\n      }\n      \n      // there may be a RestManager, in which case, we want to add this new ManagedResource immediately\n      if (initializedRestManager != null && initializedRestManager.getManagedResourceOrNull(resourceId) == null) {\n        initializedRestManager.addRegisteredResource(registered.get(resourceId));\n      }\n    }    \n\n","sourceOld":"    /**\n     * Register the need to use a ManagedResource; this method is typically called\n     * by a Solr component during core initialization to register itself as an \n     * observer of a specific type of ManagedResource. As many Solr components may\n     * share the same ManagedResource, this method only serves to associate the\n     * observer with an endpoint and implementation class. The actual construction\n     * of the ManagedResource and loading of data from storage occurs later once\n     * the RestManager is fully initialized.\n     * @param resourceId - An endpoint in the Rest API to manage the resource; must\n     * start with /config and /schema.\n     * @param implClass - Class that implements ManagedResource.\n     * @param observer - Solr component that needs to know when the data being managed\n     * by the ManagedResource is loaded, such as a TokenFilter.\n     */\n    public synchronized void registerManagedResource(String resourceId, \n        Class<? extends ManagedResource> implClass, ManagedResourceObserver observer) {\n      \n      if (resourceId == null)\n        throw new IllegalArgumentException(\n            \"Must provide a non-null resourceId to register a ManagedResource!\");\n\n      Matcher resourceIdValidator = resourceIdRegex.matcher(resourceId);\n      if (!resourceIdValidator.matches()) {\n        String errMsg = String.format(Locale.ROOT,\n            \"Invalid resourceId '%s'; must start with  %s.\",\n            resourceId,  SCHEMA_BASE_PATH);\n        throw new SolrException(ErrorCode.SERVER_ERROR, errMsg);        \n      }\n         \n      // protect reserved REST API endpoints from being used by another\n      Matcher reservedEndpointsMatcher = reservedEndpointsPattern.matcher(resourceId);\n      if (reservedEndpointsMatcher.matches()) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            reservedEndpointsMatcher.group(1)\n            + \" is a reserved endpoint used by the Solr REST API!\");\n      }\n\n      // IMPORTANT: this code should assume there is no RestManager at this point\n      \n      // it's ok to re-register the same class for an existing path\n      ManagedResourceRegistration reg = registered.get(resourceId);\n      if (reg != null) {\n        if (!reg.implClass.equals(implClass)) {\n          String errMsg = String.format(Locale.ROOT,\n              \"REST API path %s already registered to instances of %s\",\n              resourceId, reg.implClass.getName());\n          throw new SolrException(ErrorCode.SERVER_ERROR, errMsg);          \n        } \n        \n        if (observer != null) {\n          reg.observers.add(observer);\n          if (log.isInfoEnabled()) {\n            log.info(\"Added observer of type {} to existing ManagedResource {}\",\n                observer.getClass().getName(), resourceId);\n          }\n        }\n      } else {\n        registered.put(resourceId, \n            new ManagedResourceRegistration(resourceId, implClass, observer));\n        if (log.isInfoEnabled()) {\n          log.info(\"Registered ManagedResource impl {} for path {}\", implClass.getName(), resourceId);\n        }\n      }\n      \n      // there may be a RestManager, in which case, we want to add this new ManagedResource immediately\n      if (initializedRestManager != null && initializedRestManager.getManagedResourceOrNull(resourceId) == null) {\n        initializedRestManager.addRegisteredResource(registered.get(resourceId));\n      }\n    }    \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"89fd5bce15c8e0ca1b10c9988cff9fdcc88c152b":["140be51d03394488536f4aacedace29f9b318347"],"716cfb7876e1d813737493c55157adc5883673ae":["858c0f62e7b20002e4d94702c510512fb6292988"],"afb6bf9ce227ab6aac5068547e286ecc958b8b9d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"140be51d03394488536f4aacedace29f9b318347":["716cfb7876e1d813737493c55157adc5883673ae"],"858c0f62e7b20002e4d94702c510512fb6292988":["bdf16ebe435fc9daea90a73b8683ff001c6d3523"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["89fd5bce15c8e0ca1b10c9988cff9fdcc88c152b"],"bdf16ebe435fc9daea90a73b8683ff001c6d3523":["afb6bf9ce227ab6aac5068547e286ecc958b8b9d"]},"commit2Childs":{"89fd5bce15c8e0ca1b10c9988cff9fdcc88c152b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"716cfb7876e1d813737493c55157adc5883673ae":["140be51d03394488536f4aacedace29f9b318347"],"afb6bf9ce227ab6aac5068547e286ecc958b8b9d":["bdf16ebe435fc9daea90a73b8683ff001c6d3523"],"140be51d03394488536f4aacedace29f9b318347":["89fd5bce15c8e0ca1b10c9988cff9fdcc88c152b"],"858c0f62e7b20002e4d94702c510512fb6292988":["716cfb7876e1d813737493c55157adc5883673ae"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["afb6bf9ce227ab6aac5068547e286ecc958b8b9d"],"bdf16ebe435fc9daea90a73b8683ff001c6d3523":["858c0f62e7b20002e4d94702c510512fb6292988"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}