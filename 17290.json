{"path":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#run().mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#run().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public void run() {\n      try {\n\n        uhandler.core.log.warn(\"Starting log replay \" + translog + \" active=\"+activeLog + \"starting pos=\" + recoveryInfo.positionOfStart);\n\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(DistributedUpdateProcessor.SEEN_LEADER, true);\n        SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core, params);\n        SolrQueryResponse rsp = new SolrQueryResponse();\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        // TODO: use the standard request factory?  We won't get any custom configuration instantiating this way.\n        RunUpdateProcessorFactory runFac = new RunUpdateProcessorFactory();\n        DistributedUpdateProcessorFactory magicFac = new DistributedUpdateProcessorFactory();\n        runFac.init(new NamedList());\n        magicFac.init(new NamedList());\n\n        UpdateRequestProcessor proc = magicFac.getInstance(req, rsp, runFac.getInstance(req, rsp, null));\n\n        long commitVersion = 0;\n\n        for(;;) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (InterruptedException e) {\n            SolrException.log(log,e);\n          } catch (IOException e) {\n            SolrException.log(log,e);\n          } catch (Throwable e) {\n            SolrException.log(log,e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List)o;\n\n            int oper = (Integer)entry.get(0);\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD:\n              {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE:\n              {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY:\n              {\n                recoveryInfo.deleteByQuery++;\n                String query = (String)entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT:\n              {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              log.error(\"Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            log.warn(\"IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (Throwable ex) {\n            recoveryInfo.errors++;\n            log.warn(\"Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          log.error(\"Replay exception: final commit.\", ex);\n        }\n        \n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n          translog.writeCommit(cmd);\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          log.error(\"Replay exception: finish()\", ex);\n        }\n\n        tlogReader.close();\n        translog.decref();\n\n      } catch (Throwable e) {\n        recoveryInfo.errors++;\n        SolrException.log(log,e);\n      } finally {\n        // change the state while updates are still blocked to prevent races\n        state = State.ACTIVE;\n        if (finishing) {\n          versionInfo.unblockUpdates();\n        }\n      }\n\n      log.warn(\"Ending log replay \" + tlogReader);\n\n      if (testing_logReplayFinishHook != null) testing_logReplayFinishHook.run();\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["a6378064655e76cd7b908b1cab4ce425b384b508","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#run().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public void run() {\n      try {\n\n        uhandler.core.log.warn(\"Starting log replay \" + translog + \" active=\"+activeLog + \"starting pos=\" + recoveryInfo.positionOfStart);\n\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(DistributedUpdateProcessor.SEEN_LEADER, true);\n        SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core, params);\n        SolrQueryResponse rsp = new SolrQueryResponse();\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        // TODO: use the standard request factory?  We won't get any custom configuration instantiating this way.\n        RunUpdateProcessorFactory runFac = new RunUpdateProcessorFactory();\n        DistributedUpdateProcessorFactory magicFac = new DistributedUpdateProcessorFactory();\n        runFac.init(new NamedList());\n        magicFac.init(new NamedList());\n\n        UpdateRequestProcessor proc = magicFac.getInstance(req, rsp, runFac.getInstance(req, rsp, null));\n\n        long commitVersion = 0;\n\n        for(;;) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (InterruptedException e) {\n            SolrException.log(log,e);\n          } catch (IOException e) {\n            SolrException.log(log,e);\n          } catch (Throwable e) {\n            SolrException.log(log,e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List)o;\n\n            int oper = (Integer)entry.get(0);\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD:\n              {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE:\n              {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY:\n              {\n                recoveryInfo.deleteByQuery++;\n                String query = (String)entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT:\n              {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              log.error(\"Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            log.warn(\"IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (Throwable ex) {\n            recoveryInfo.errors++;\n            log.warn(\"Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          log.error(\"Replay exception: final commit.\", ex);\n        }\n        \n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n          translog.writeCommit(cmd);\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          log.error(\"Replay exception: finish()\", ex);\n        }\n\n        tlogReader.close();\n        translog.decref();\n\n      } catch (Throwable e) {\n        recoveryInfo.errors++;\n        SolrException.log(log,e);\n      } finally {\n        // change the state while updates are still blocked to prevent races\n        state = State.ACTIVE;\n        if (finishing) {\n          versionInfo.unblockUpdates();\n        }\n      }\n\n      log.warn(\"Ending log replay \" + tlogReader);\n\n      if (testing_logReplayFinishHook != null) testing_logReplayFinishHook.run();\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#run().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public void run() {\n      try {\n\n        uhandler.core.log.warn(\"Starting log replay \" + translog + \" active=\"+activeLog + \"starting pos=\" + recoveryInfo.positionOfStart);\n\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(DistributedUpdateProcessor.SEEN_LEADER, true);\n        SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core, params);\n        SolrQueryResponse rsp = new SolrQueryResponse();\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        // TODO: use the standard request factory?  We won't get any custom configuration instantiating this way.\n        RunUpdateProcessorFactory runFac = new RunUpdateProcessorFactory();\n        DistributedUpdateProcessorFactory magicFac = new DistributedUpdateProcessorFactory();\n        runFac.init(new NamedList());\n        magicFac.init(new NamedList());\n\n        UpdateRequestProcessor proc = magicFac.getInstance(req, rsp, runFac.getInstance(req, rsp, null));\n\n        long commitVersion = 0;\n\n        for(;;) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (InterruptedException e) {\n            SolrException.log(log,e);\n          } catch (IOException e) {\n            SolrException.log(log,e);\n          } catch (Throwable e) {\n            SolrException.log(log,e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List)o;\n\n            int oper = (Integer)entry.get(0);\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD:\n              {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE:\n              {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY:\n              {\n                recoveryInfo.deleteByQuery++;\n                String query = (String)entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT:\n              {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              log.error(\"Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            log.warn(\"IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (Throwable ex) {\n            recoveryInfo.errors++;\n            log.warn(\"Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          log.error(\"Replay exception: final commit.\", ex);\n        }\n        \n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n          translog.writeCommit(cmd);\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          log.error(\"Replay exception: finish()\", ex);\n        }\n\n        tlogReader.close();\n        translog.decref();\n\n      } catch (Throwable e) {\n        recoveryInfo.errors++;\n        SolrException.log(log,e);\n      } finally {\n        // change the state while updates are still blocked to prevent races\n        state = State.ACTIVE;\n        if (finishing) {\n          versionInfo.unblockUpdates();\n        }\n      }\n\n      log.warn(\"Ending log replay \" + tlogReader);\n\n      if (testing_logReplayFinishHook != null) testing_logReplayFinishHook.run();\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a122d9b5dc04db9ac592cff9887c6991154abf4","date":1330373721,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#run().mjava","sourceNew":"    @Override\n    public void run() {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(DistributedUpdateProcessor.SEEN_LEADER, true);\n      SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core, params);\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));    // setting request info will help logging\n\n      try {\n\n        loglog.warn(\"Starting log replay \" + translog + \" active=\"+activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        // TODO: use the standard request factory?  We won't get any custom configuration instantiating this way.\n        RunUpdateProcessorFactory runFac = new RunUpdateProcessorFactory();\n        DistributedUpdateProcessorFactory magicFac = new DistributedUpdateProcessorFactory();\n        runFac.init(new NamedList());\n        magicFac.init(new NamedList());\n\n        UpdateRequestProcessor proc = magicFac.getInstance(req, rsp, runFac.getInstance(req, rsp, null));\n\n        long commitVersion = 0;\n\n        for(;;) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (InterruptedException e) {\n            SolrException.log(log,e);\n          } catch (IOException e) {\n            SolrException.log(log,e);\n          } catch (Throwable e) {\n            SolrException.log(log,e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List)o;\n\n            int oper = (Integer)entry.get(0);\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD:\n              {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" +  cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE:\n              {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY:\n              {\n                recoveryInfo.deleteByQuery++;\n                String query = (String)entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT:\n              {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (Throwable ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" +  cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n        \n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n          translog.writeCommit(cmd);\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n        tlogReader.close();\n        translog.decref();\n\n      } catch (Throwable e) {\n        recoveryInfo.errors++;\n        SolrException.log(log,e);\n      } finally {\n        // change the state while updates are still blocked to prevent races\n        state = State.ACTIVE;\n        if (finishing) {\n          versionInfo.unblockUpdates();\n        }\n      }\n\n      loglog.warn(\"Ending log replay \" + tlogReader + \" recoveryInfo=\" + recoveryInfo);\n\n      if (testing_logReplayFinishHook != null) testing_logReplayFinishHook.run();\n\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      try {\n\n        uhandler.core.log.warn(\"Starting log replay \" + translog + \" active=\"+activeLog + \"starting pos=\" + recoveryInfo.positionOfStart);\n\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(DistributedUpdateProcessor.SEEN_LEADER, true);\n        SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core, params);\n        SolrQueryResponse rsp = new SolrQueryResponse();\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        // TODO: use the standard request factory?  We won't get any custom configuration instantiating this way.\n        RunUpdateProcessorFactory runFac = new RunUpdateProcessorFactory();\n        DistributedUpdateProcessorFactory magicFac = new DistributedUpdateProcessorFactory();\n        runFac.init(new NamedList());\n        magicFac.init(new NamedList());\n\n        UpdateRequestProcessor proc = magicFac.getInstance(req, rsp, runFac.getInstance(req, rsp, null));\n\n        long commitVersion = 0;\n\n        for(;;) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (InterruptedException e) {\n            SolrException.log(log,e);\n          } catch (IOException e) {\n            SolrException.log(log,e);\n          } catch (Throwable e) {\n            SolrException.log(log,e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List)o;\n\n            int oper = (Integer)entry.get(0);\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD:\n              {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE:\n              {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY:\n              {\n                recoveryInfo.deleteByQuery++;\n                String query = (String)entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT:\n              {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              log.error(\"Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            log.warn(\"IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (Throwable ex) {\n            recoveryInfo.errors++;\n            log.warn(\"Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          log.error(\"Replay exception: final commit.\", ex);\n        }\n        \n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n          translog.writeCommit(cmd);\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          log.error(\"Replay exception: finish()\", ex);\n        }\n\n        tlogReader.close();\n        translog.decref();\n\n      } catch (Throwable e) {\n        recoveryInfo.errors++;\n        SolrException.log(log,e);\n      } finally {\n        // change the state while updates are still blocked to prevent races\n        state = State.ACTIVE;\n        if (finishing) {\n          versionInfo.unblockUpdates();\n        }\n      }\n\n      log.warn(\"Ending log replay \" + tlogReader);\n\n      if (testing_logReplayFinishHook != null) testing_logReplayFinishHook.run();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1a9e81d464930e5664da049442e2630d4b9b00d5","date":1330726364,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#run().mjava","sourceNew":"    @Override\n    public void run() {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(DistributedUpdateProcessor.SEEN_LEADER, true);\n      req = new LocalSolrQueryRequest(uhandler.core, params);\n      rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));    // setting request info will help logging\n\n      try {\n        for (TransactionLog translog : translogs) {\n          doReplay(translog);\n        }\n      } catch (Throwable e) {\n        recoveryInfo.errors++;\n        SolrException.log(log,e);\n      } finally {\n        // change the state while updates are still blocked to prevent races\n        state = State.ACTIVE;\n        if (finishing) {\n          versionInfo.unblockUpdates();\n        }\n      }\n\n      loglog.warn(\"Log replay finished. recoveryInfo=\" + recoveryInfo);\n\n      if (testing_logReplayFinishHook != null) testing_logReplayFinishHook.run();\n\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(DistributedUpdateProcessor.SEEN_LEADER, true);\n      SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core, params);\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));    // setting request info will help logging\n\n      try {\n\n        loglog.warn(\"Starting log replay \" + translog + \" active=\"+activeLog + \" starting pos=\" + recoveryInfo.positionOfStart);\n\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        // TODO: use the standard request factory?  We won't get any custom configuration instantiating this way.\n        RunUpdateProcessorFactory runFac = new RunUpdateProcessorFactory();\n        DistributedUpdateProcessorFactory magicFac = new DistributedUpdateProcessorFactory();\n        runFac.init(new NamedList());\n        magicFac.init(new NamedList());\n\n        UpdateRequestProcessor proc = magicFac.getInstance(req, rsp, runFac.getInstance(req, rsp, null));\n\n        long commitVersion = 0;\n\n        for(;;) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (InterruptedException e) {\n            SolrException.log(log,e);\n          } catch (IOException e) {\n            SolrException.log(log,e);\n          } catch (Throwable e) {\n            SolrException.log(log,e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List)o;\n\n            int oper = (Integer)entry.get(0);\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD:\n              {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"add \" +  cmd);\n\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE:\n              {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"delete \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY:\n              {\n                recoveryInfo.deleteByQuery++;\n                String query = (String)entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                if (debug) log.debug(\"deleteByQuery \" +  cmd);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT:\n              {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              loglog.error(\"REPLAY_ERR: Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REYPLAY_ERR: IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (Throwable ex) {\n            recoveryInfo.errors++;\n            loglog.warn(\"REPLAY_ERR: Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          if (debug) log.debug(\"commit \" +  cmd);\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: final commit.\", ex);\n        }\n        \n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n          translog.writeCommit(cmd);\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          loglog.error(\"Replay exception: finish()\", ex);\n        }\n\n        tlogReader.close();\n        translog.decref();\n\n      } catch (Throwable e) {\n        recoveryInfo.errors++;\n        SolrException.log(log,e);\n      } finally {\n        // change the state while updates are still blocked to prevent races\n        state = State.ACTIVE;\n        if (finishing) {\n          versionInfo.unblockUpdates();\n        }\n      }\n\n      loglog.warn(\"Ending log replay \" + tlogReader + \" recoveryInfo=\" + recoveryInfo);\n\n      if (testing_logReplayFinishHook != null) testing_logReplayFinishHook.run();\n\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n","bugFix":null,"bugIntro":["6198e18a87837d41cdd5df8c554e124619d99e4c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#run().mjava","sourceNew":"    @Override\n    public void run() {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(DistributedUpdateProcessor.SEEN_LEADER, true);\n      req = new LocalSolrQueryRequest(uhandler.core, params);\n      rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));    // setting request info will help logging\n\n      try {\n        for (TransactionLog translog : translogs) {\n          doReplay(translog);\n        }\n      } catch (Throwable e) {\n        recoveryInfo.errors++;\n        SolrException.log(log,e);\n      } finally {\n        // change the state while updates are still blocked to prevent races\n        state = State.ACTIVE;\n        if (finishing) {\n          versionInfo.unblockUpdates();\n        }\n      }\n\n      loglog.warn(\"Log replay finished. recoveryInfo=\" + recoveryInfo);\n\n      if (testing_logReplayFinishHook != null) testing_logReplayFinishHook.run();\n\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      try {\n\n        uhandler.core.log.warn(\"Starting log replay \" + translog + \" active=\"+activeLog + \"starting pos=\" + recoveryInfo.positionOfStart);\n\n        tlogReader = translog.getReader(recoveryInfo.positionOfStart);\n\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(DistributedUpdateProcessor.SEEN_LEADER, true);\n        SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core, params);\n        SolrQueryResponse rsp = new SolrQueryResponse();\n\n        // NOTE: we don't currently handle a core reload during recovery.  This would cause the core\n        // to change underneath us.\n\n        // TODO: use the standard request factory?  We won't get any custom configuration instantiating this way.\n        RunUpdateProcessorFactory runFac = new RunUpdateProcessorFactory();\n        DistributedUpdateProcessorFactory magicFac = new DistributedUpdateProcessorFactory();\n        runFac.init(new NamedList());\n        magicFac.init(new NamedList());\n\n        UpdateRequestProcessor proc = magicFac.getInstance(req, rsp, runFac.getInstance(req, rsp, null));\n\n        long commitVersion = 0;\n\n        for(;;) {\n          Object o = null;\n          if (cancelApplyBufferUpdate) break;\n          try {\n            if (testing_logReplayHook != null) testing_logReplayHook.run();\n            o = null;\n            o = tlogReader.next();\n            if (o == null && activeLog) {\n              if (!finishing) {\n                // block to prevent new adds, but don't immediately unlock since\n                // we could be starved from ever completing recovery.  Only unlock\n                // after we've finished this recovery.\n                // NOTE: our own updates won't be blocked since the thread holding a write lock can\n                // lock a read lock.\n                versionInfo.blockUpdates();\n                finishing = true;\n                o = tlogReader.next();\n              } else {\n                // we had previously blocked updates, so this \"null\" from the log is final.\n\n                // Wait until our final commit to change the state and unlock.\n                // This is only so no new updates are written to the current log file, and is\n                // only an issue if we crash before the commit (and we are paying attention\n                // to incomplete log files).\n                //\n                // versionInfo.unblockUpdates();\n              }\n            }\n          } catch (InterruptedException e) {\n            SolrException.log(log,e);\n          } catch (IOException e) {\n            SolrException.log(log,e);\n          } catch (Throwable e) {\n            SolrException.log(log,e);\n          }\n\n          if (o == null) break;\n\n          try {\n\n            // should currently be a List<Oper,Ver,Doc/Id>\n            List entry = (List)o;\n\n            int oper = (Integer)entry.get(0);\n            long version = (Long) entry.get(1);\n\n            switch (oper) {\n              case UpdateLog.ADD:\n              {\n                recoveryInfo.adds++;\n                // byte[] idBytes = (byte[]) entry.get(2);\n                SolrInputDocument sdoc = (SolrInputDocument)entry.get(entry.size()-1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                // cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                proc.processAdd(cmd);\n                break;\n              }\n              case UpdateLog.DELETE:\n              {\n                recoveryInfo.deletes++;\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY:\n              {\n                recoveryInfo.deleteByQuery++;\n                String query = (String)entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);\n                proc.processDelete(cmd);\n                break;\n              }\n\n              case UpdateLog.COMMIT:\n              {\n                commitVersion = version;\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n            }\n\n            if (rsp.getException() != null) {\n              log.error(\"Exception replaying log\", rsp.getException());\n              throw rsp.getException();\n            }\n          } catch (IOException ex) {\n            recoveryInfo.errors++;\n            log.warn(\"IOException reading log\", ex);\n            // could be caused by an incomplete flush if recovering from log\n          } catch (ClassCastException cl) {\n            recoveryInfo.errors++;\n            log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n            // would be caused by a corrupt transaction log\n          } catch (Throwable ex) {\n            recoveryInfo.errors++;\n            log.warn(\"Exception replaying log\", ex);\n            // something wrong with the request?\n          }\n        }\n\n        CommitUpdateCommand cmd = new CommitUpdateCommand(req, false);\n        cmd.setVersion(commitVersion);\n        cmd.softCommit = false;\n        cmd.waitSearcher = true;\n        cmd.setFlags(UpdateCommand.REPLAY);\n        try {\n          uhandler.commit(cmd);          // this should cause a commit to be added to the incomplete log and avoid it being replayed again after a restart.\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          log.error(\"Replay exception: final commit.\", ex);\n        }\n        \n        if (!activeLog) {\n          // if we are replaying an old tlog file, we need to add a commit to the end\n          // so we don't replay it again if we restart right after.\n          translog.writeCommit(cmd);\n        }\n\n        try {\n          proc.finish();\n        } catch (IOException ex) {\n          recoveryInfo.errors++;\n          log.error(\"Replay exception: finish()\", ex);\n        }\n\n        tlogReader.close();\n        translog.decref();\n\n      } catch (Throwable e) {\n        recoveryInfo.errors++;\n        SolrException.log(log,e);\n      } finally {\n        // change the state while updates are still blocked to prevent races\n        state = State.ACTIVE;\n        if (finishing) {\n          versionInfo.unblockUpdates();\n        }\n      }\n\n      log.warn(\"Ending log replay \" + tlogReader);\n\n      if (testing_logReplayFinishHook != null) testing_logReplayFinishHook.run();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e2fe35ac47f8f51356d6c1724455d18f31c94fae","date":1337966698,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#run().mjava","sourceNew":"    @Override\n    public void run() {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(DISTRIB_UPDATE_PARAM, FROMLEADER.toString());\n      req = new LocalSolrQueryRequest(uhandler.core, params);\n      rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));    // setting request info will help logging\n\n      try {\n        for (TransactionLog translog : translogs) {\n          doReplay(translog);\n        }\n      } catch (Throwable e) {\n        recoveryInfo.errors++;\n        SolrException.log(log,e);\n      } finally {\n        // change the state while updates are still blocked to prevent races\n        state = State.ACTIVE;\n        if (finishing) {\n          versionInfo.unblockUpdates();\n        }\n      }\n\n      loglog.warn(\"Log replay finished. recoveryInfo=\" + recoveryInfo);\n\n      if (testing_logReplayFinishHook != null) testing_logReplayFinishHook.run();\n\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(DistributedUpdateProcessor.SEEN_LEADER, true);\n      req = new LocalSolrQueryRequest(uhandler.core, params);\n      rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));    // setting request info will help logging\n\n      try {\n        for (TransactionLog translog : translogs) {\n          doReplay(translog);\n        }\n      } catch (Throwable e) {\n        recoveryInfo.errors++;\n        SolrException.log(log,e);\n      } finally {\n        // change the state while updates are still blocked to prevent races\n        state = State.ACTIVE;\n        if (finishing) {\n          versionInfo.unblockUpdates();\n        }\n      }\n\n      loglog.warn(\"Log replay finished. recoveryInfo=\" + recoveryInfo);\n\n      if (testing_logReplayFinishHook != null) testing_logReplayFinishHook.run();\n\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a6378064655e76cd7b908b1cab4ce425b384b508","date":1347656715,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#run().mjava","sourceNew":"    @Override\n    public void run() {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(DISTRIB_UPDATE_PARAM, FROMLEADER.toString());\n      params.set(DistributedUpdateProcessor.LOG_REPLAY, \"true\");\n      req = new LocalSolrQueryRequest(uhandler.core, params);\n      rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));    // setting request info will help logging\n\n      try {\n        for (TransactionLog translog : translogs) {\n          doReplay(translog);\n        }\n      } catch (SolrException e) {\n        if (e.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n          SolrException.log(log, e);\n          recoveryInfo.failed = true;\n        } else {\n          recoveryInfo.errors++;\n          SolrException.log(log, e);\n        }\n      } catch (Throwable e) {\n        recoveryInfo.errors++;\n        SolrException.log(log, e);\n      } finally {\n        // change the state while updates are still blocked to prevent races\n        state = State.ACTIVE;\n        if (finishing) {\n          versionInfo.unblockUpdates();\n        }\n      }\n\n      loglog.warn(\"Log replay finished. recoveryInfo=\" + recoveryInfo);\n\n      if (testing_logReplayFinishHook != null) testing_logReplayFinishHook.run();\n\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(DISTRIB_UPDATE_PARAM, FROMLEADER.toString());\n      req = new LocalSolrQueryRequest(uhandler.core, params);\n      rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));    // setting request info will help logging\n\n      try {\n        for (TransactionLog translog : translogs) {\n          doReplay(translog);\n        }\n      } catch (Throwable e) {\n        recoveryInfo.errors++;\n        SolrException.log(log,e);\n      } finally {\n        // change the state while updates are still blocked to prevent races\n        state = State.ACTIVE;\n        if (finishing) {\n          versionInfo.unblockUpdates();\n        }\n      }\n\n      loglog.warn(\"Log replay finished. recoveryInfo=\" + recoveryInfo);\n\n      if (testing_logReplayFinishHook != null) testing_logReplayFinishHook.run();\n\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6198e18a87837d41cdd5df8c554e124619d99e4c","date":1368737399,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#run().mjava","sourceNew":"    @Override\n    public void run() {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(DISTRIB_UPDATE_PARAM, FROMLEADER.toString());\n      params.set(DistributedUpdateProcessor.LOG_REPLAY, \"true\");\n      req = new LocalSolrQueryRequest(uhandler.core, params);\n      rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));    // setting request info will help logging\n\n      try {\n        for(;;) {\n          TransactionLog translog = translogs.pollFirst();\n          if (translog == null) break;\n          doReplay(translog);\n        }\n      } catch (SolrException e) {\n        if (e.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n          SolrException.log(log, e);\n          recoveryInfo.failed = true;\n        } else {\n          recoveryInfo.errors++;\n          SolrException.log(log, e);\n        }\n      } catch (Throwable e) {\n        recoveryInfo.errors++;\n        SolrException.log(log, e);\n      } finally {\n        // change the state while updates are still blocked to prevent races\n        state = State.ACTIVE;\n        if (finishing) {\n          versionInfo.unblockUpdates();\n        }\n\n        // clean up in case we hit some unexpected exception and didn't get\n        // to more transaction logs\n        for (TransactionLog translog : translogs) {\n          log.error(\"ERROR: didn't get to recover from tlog \" + translog);\n          translog.decref();\n        }\n      }\n\n      loglog.warn(\"Log replay finished. recoveryInfo=\" + recoveryInfo);\n\n      if (testing_logReplayFinishHook != null) testing_logReplayFinishHook.run();\n\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(DISTRIB_UPDATE_PARAM, FROMLEADER.toString());\n      params.set(DistributedUpdateProcessor.LOG_REPLAY, \"true\");\n      req = new LocalSolrQueryRequest(uhandler.core, params);\n      rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));    // setting request info will help logging\n\n      try {\n        for (TransactionLog translog : translogs) {\n          doReplay(translog);\n        }\n      } catch (SolrException e) {\n        if (e.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n          SolrException.log(log, e);\n          recoveryInfo.failed = true;\n        } else {\n          recoveryInfo.errors++;\n          SolrException.log(log, e);\n        }\n      } catch (Throwable e) {\n        recoveryInfo.errors++;\n        SolrException.log(log, e);\n      } finally {\n        // change the state while updates are still blocked to prevent races\n        state = State.ACTIVE;\n        if (finishing) {\n          versionInfo.unblockUpdates();\n        }\n      }\n\n      loglog.warn(\"Log replay finished. recoveryInfo=\" + recoveryInfo);\n\n      if (testing_logReplayFinishHook != null) testing_logReplayFinishHook.run();\n\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n","bugFix":["1a9e81d464930e5664da049442e2630d4b9b00d5"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","date":1389633998,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#run().mjava","sourceNew":"    @Override\n    public void run() {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(DISTRIB_UPDATE_PARAM, FROMLEADER.toString());\n      params.set(DistributedUpdateProcessor.LOG_REPLAY, \"true\");\n      req = new LocalSolrQueryRequest(uhandler.core, params);\n      rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));    // setting request info will help logging\n\n      try {\n        for(;;) {\n          TransactionLog translog = translogs.pollFirst();\n          if (translog == null) break;\n          doReplay(translog);\n        }\n      } catch (SolrException e) {\n        if (e.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n          SolrException.log(log, e);\n          recoveryInfo.failed = true;\n        } else {\n          recoveryInfo.errors++;\n          SolrException.log(log, e);\n        }\n      } catch (Exception e) {\n        recoveryInfo.errors++;\n        SolrException.log(log, e);\n      } finally {\n        // change the state while updates are still blocked to prevent races\n        state = State.ACTIVE;\n        if (finishing) {\n          versionInfo.unblockUpdates();\n        }\n\n        // clean up in case we hit some unexpected exception and didn't get\n        // to more transaction logs\n        for (TransactionLog translog : translogs) {\n          log.error(\"ERROR: didn't get to recover from tlog \" + translog);\n          translog.decref();\n        }\n      }\n\n      loglog.warn(\"Log replay finished. recoveryInfo=\" + recoveryInfo);\n\n      if (testing_logReplayFinishHook != null) testing_logReplayFinishHook.run();\n\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(DISTRIB_UPDATE_PARAM, FROMLEADER.toString());\n      params.set(DistributedUpdateProcessor.LOG_REPLAY, \"true\");\n      req = new LocalSolrQueryRequest(uhandler.core, params);\n      rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));    // setting request info will help logging\n\n      try {\n        for(;;) {\n          TransactionLog translog = translogs.pollFirst();\n          if (translog == null) break;\n          doReplay(translog);\n        }\n      } catch (SolrException e) {\n        if (e.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n          SolrException.log(log, e);\n          recoveryInfo.failed = true;\n        } else {\n          recoveryInfo.errors++;\n          SolrException.log(log, e);\n        }\n      } catch (Throwable e) {\n        recoveryInfo.errors++;\n        SolrException.log(log, e);\n      } finally {\n        // change the state while updates are still blocked to prevent races\n        state = State.ACTIVE;\n        if (finishing) {\n          versionInfo.unblockUpdates();\n        }\n\n        // clean up in case we hit some unexpected exception and didn't get\n        // to more transaction logs\n        for (TransactionLog translog : translogs) {\n          log.error(\"ERROR: didn't get to recover from tlog \" + translog);\n          translog.decref();\n        }\n      }\n\n      loglog.warn(\"Log replay finished. recoveryInfo=\" + recoveryInfo);\n\n      if (testing_logReplayFinishHook != null) testing_logReplayFinishHook.run();\n\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"773a737806859660d4756f710adc0ad53e05f9d5","date":1432140757,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#run().mjava","sourceNew":"    @Override\n    public void run() {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(DISTRIB_UPDATE_PARAM, FROMLEADER.toString());\n      params.set(DistributedUpdateProcessor.LOG_REPLAY, \"true\");\n      req = new LocalSolrQueryRequest(uhandler.core, params);\n      rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));    // setting request info will help logging\n\n      try {\n        for(;;) {\n          TransactionLog translog = translogs.pollFirst();\n          if (translog == null) break;\n          doReplay(translog);\n        }\n      } catch (SolrException e) {\n        if (e.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n          SolrException.log(log, e);\n          recoveryInfo.failed = true;\n        } else {\n          recoveryInfo.errors++;\n          SolrException.log(log, e);\n        }\n      } catch (Exception e) {\n        recoveryInfo.errors++;\n        SolrException.log(log, e);\n      } finally {\n        // change the state while updates are still blocked to prevent races\n        state = State.ACTIVE;\n        if (finishing) {\n\n          // after replay, update the max from the index\n          log.info(\"Re-computing max version from index after log re-play.\");\n          maxVersionFromIndex = null;\n          getMaxVersionFromIndex();\n\n          versionInfo.unblockUpdates();\n        }\n\n        // clean up in case we hit some unexpected exception and didn't get\n        // to more transaction logs\n        for (TransactionLog translog : translogs) {\n          log.error(\"ERROR: didn't get to recover from tlog \" + translog);\n          translog.decref();\n        }\n      }\n\n      loglog.warn(\"Log replay finished. recoveryInfo=\" + recoveryInfo);\n\n      if (testing_logReplayFinishHook != null) testing_logReplayFinishHook.run();\n\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(DISTRIB_UPDATE_PARAM, FROMLEADER.toString());\n      params.set(DistributedUpdateProcessor.LOG_REPLAY, \"true\");\n      req = new LocalSolrQueryRequest(uhandler.core, params);\n      rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));    // setting request info will help logging\n\n      try {\n        for(;;) {\n          TransactionLog translog = translogs.pollFirst();\n          if (translog == null) break;\n          doReplay(translog);\n        }\n      } catch (SolrException e) {\n        if (e.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n          SolrException.log(log, e);\n          recoveryInfo.failed = true;\n        } else {\n          recoveryInfo.errors++;\n          SolrException.log(log, e);\n        }\n      } catch (Exception e) {\n        recoveryInfo.errors++;\n        SolrException.log(log, e);\n      } finally {\n        // change the state while updates are still blocked to prevent races\n        state = State.ACTIVE;\n        if (finishing) {\n          versionInfo.unblockUpdates();\n        }\n\n        // clean up in case we hit some unexpected exception and didn't get\n        // to more transaction logs\n        for (TransactionLog translog : translogs) {\n          log.error(\"ERROR: didn't get to recover from tlog \" + translog);\n          translog.decref();\n        }\n      }\n\n      loglog.warn(\"Log replay finished. recoveryInfo=\" + recoveryInfo);\n\n      if (testing_logReplayFinishHook != null) testing_logReplayFinishHook.run();\n\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"defa11d88d50ec356d5e7428f1ebc89623e840ac","date":1527653148,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#run().mjava","sourceNew":"    @Override\n    public void run() {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(DISTRIB_UPDATE_PARAM, FROMLEADER.toString());\n      params.set(DistributedUpdateProcessor.LOG_REPLAY, \"true\");\n      req = new LocalSolrQueryRequest(uhandler.core, params);\n      rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));    // setting request info will help logging\n\n      try {\n        for (; ; ) {\n          TransactionLog translog = translogs.pollFirst();\n          if (translog == null) break;\n          doReplay(translog);\n        }\n      } catch (SolrException e) {\n        if (e.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n          SolrException.log(log, e);\n          recoveryInfo.failed = true;\n        } else {\n          recoveryInfo.errors++;\n          SolrException.log(log, e);\n        }\n      } catch (Exception e) {\n        recoveryInfo.errors++;\n        SolrException.log(log, e);\n      } finally {\n        // change the state while updates are still blocked to prevent races\n        state = State.ACTIVE;\n        if (finishing) {\n\n          // after replay, update the max from the index\n          log.info(\"Re-computing max version from index after log re-play.\");\n          maxVersionFromIndex = null;\n          getMaxVersionFromIndex();\n\n          versionInfo.unblockUpdates();\n        }\n\n        // clean up in case we hit some unexpected exception and didn't get\n        // to more transaction logs\n        for (TransactionLog translog : translogs) {\n          log.error(\"ERROR: didn't get to recover from tlog \" + translog);\n          translog.decref();\n        }\n      }\n\n      loglog.warn(\"Log replay finished. recoveryInfo=\" + recoveryInfo);\n\n      if (testing_logReplayFinishHook != null) testing_logReplayFinishHook.run();\n\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(DISTRIB_UPDATE_PARAM, FROMLEADER.toString());\n      params.set(DistributedUpdateProcessor.LOG_REPLAY, \"true\");\n      req = new LocalSolrQueryRequest(uhandler.core, params);\n      rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));    // setting request info will help logging\n\n      try {\n        for(;;) {\n          TransactionLog translog = translogs.pollFirst();\n          if (translog == null) break;\n          doReplay(translog);\n        }\n      } catch (SolrException e) {\n        if (e.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n          SolrException.log(log, e);\n          recoveryInfo.failed = true;\n        } else {\n          recoveryInfo.errors++;\n          SolrException.log(log, e);\n        }\n      } catch (Exception e) {\n        recoveryInfo.errors++;\n        SolrException.log(log, e);\n      } finally {\n        // change the state while updates are still blocked to prevent races\n        state = State.ACTIVE;\n        if (finishing) {\n\n          // after replay, update the max from the index\n          log.info(\"Re-computing max version from index after log re-play.\");\n          maxVersionFromIndex = null;\n          getMaxVersionFromIndex();\n\n          versionInfo.unblockUpdates();\n        }\n\n        // clean up in case we hit some unexpected exception and didn't get\n        // to more transaction logs\n        for (TransactionLog translog : translogs) {\n          log.error(\"ERROR: didn't get to recover from tlog \" + translog);\n          translog.decref();\n        }\n      }\n\n      loglog.warn(\"Log replay finished. recoveryInfo=\" + recoveryInfo);\n\n      if (testing_logReplayFinishHook != null) testing_logReplayFinishHook.run();\n\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"740d649f013f07efbeb73ca854f106c60166e7c0","date":1587431295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.LogReplayer#run().mjava","sourceNew":"    @Override\n    public void run() {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(DISTRIB_UPDATE_PARAM, FROMLEADER.toString());\n      params.set(DistributedUpdateProcessor.LOG_REPLAY, \"true\");\n      req = new LocalSolrQueryRequest(uhandler.core, params);\n      rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));    // setting request info will help logging\n\n      try {\n        for (; ; ) {\n          TransactionLog translog = translogs.pollFirst();\n          if (translog == null) break;\n          doReplay(translog);\n        }\n      } catch (SolrException e) {\n        if (e.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n          SolrException.log(log, e);\n          recoveryInfo.failed = true;\n        } else {\n          recoveryInfo.errors++;\n          SolrException.log(log, e);\n        }\n      } catch (Exception e) {\n        recoveryInfo.errors++;\n        SolrException.log(log, e);\n      } finally {\n        // change the state while updates are still blocked to prevent races\n        state = State.ACTIVE;\n        if (finishing) {\n\n          // after replay, update the max from the index\n          log.info(\"Re-computing max version from index after log re-play.\");\n          maxVersionFromIndex = null;\n          getMaxVersionFromIndex();\n\n          versionInfo.unblockUpdates();\n        }\n\n        // clean up in case we hit some unexpected exception and didn't get\n        // to more transaction logs\n        for (TransactionLog translog : translogs) {\n          log.error(\"ERROR: didn't get to recover from tlog {}\", translog);\n          translog.decref();\n        }\n      }\n\n      loglog.warn(\"Log replay finished. recoveryInfo={}\", recoveryInfo);\n\n      if (testing_logReplayFinishHook != null) testing_logReplayFinishHook.run();\n\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(DISTRIB_UPDATE_PARAM, FROMLEADER.toString());\n      params.set(DistributedUpdateProcessor.LOG_REPLAY, \"true\");\n      req = new LocalSolrQueryRequest(uhandler.core, params);\n      rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));    // setting request info will help logging\n\n      try {\n        for (; ; ) {\n          TransactionLog translog = translogs.pollFirst();\n          if (translog == null) break;\n          doReplay(translog);\n        }\n      } catch (SolrException e) {\n        if (e.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {\n          SolrException.log(log, e);\n          recoveryInfo.failed = true;\n        } else {\n          recoveryInfo.errors++;\n          SolrException.log(log, e);\n        }\n      } catch (Exception e) {\n        recoveryInfo.errors++;\n        SolrException.log(log, e);\n      } finally {\n        // change the state while updates are still blocked to prevent races\n        state = State.ACTIVE;\n        if (finishing) {\n\n          // after replay, update the max from the index\n          log.info(\"Re-computing max version from index after log re-play.\");\n          maxVersionFromIndex = null;\n          getMaxVersionFromIndex();\n\n          versionInfo.unblockUpdates();\n        }\n\n        // clean up in case we hit some unexpected exception and didn't get\n        // to more transaction logs\n        for (TransactionLog translog : translogs) {\n          log.error(\"ERROR: didn't get to recover from tlog \" + translog);\n          translog.decref();\n        }\n      }\n\n      loglog.warn(\"Log replay finished. recoveryInfo=\" + recoveryInfo);\n\n      if (testing_logReplayFinishHook != null) testing_logReplayFinishHook.run();\n\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"740d649f013f07efbeb73ca854f106c60166e7c0":["defa11d88d50ec356d5e7428f1ebc89623e840ac"],"defa11d88d50ec356d5e7428f1ebc89623e840ac":["773a737806859660d4756f710adc0ad53e05f9d5"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","1a9e81d464930e5664da049442e2630d4b9b00d5"],"1a9e81d464930e5664da049442e2630d4b9b00d5":["2a122d9b5dc04db9ac592cff9887c6991154abf4"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"6198e18a87837d41cdd5df8c554e124619d99e4c":["a6378064655e76cd7b908b1cab4ce425b384b508"],"a6378064655e76cd7b908b1cab4ce425b384b508":["e2fe35ac47f8f51356d6c1724455d18f31c94fae"],"773a737806859660d4756f710adc0ad53e05f9d5":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2a122d9b5dc04db9ac592cff9887c6991154abf4":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["6198e18a87837d41cdd5df8c554e124619d99e4c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["740d649f013f07efbeb73ca854f106c60166e7c0"],"e2fe35ac47f8f51356d6c1724455d18f31c94fae":["1a9e81d464930e5664da049442e2630d4b9b00d5"]},"commit2Childs":{"740d649f013f07efbeb73ca854f106c60166e7c0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"defa11d88d50ec356d5e7428f1ebc89623e840ac":["740d649f013f07efbeb73ca854f106c60166e7c0"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"1a9e81d464930e5664da049442e2630d4b9b00d5":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","e2fe35ac47f8f51356d6c1724455d18f31c94fae"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"6198e18a87837d41cdd5df8c554e124619d99e4c":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"a6378064655e76cd7b908b1cab4ce425b384b508":["6198e18a87837d41cdd5df8c554e124619d99e4c"],"773a737806859660d4756f710adc0ad53e05f9d5":["defa11d88d50ec356d5e7428f1ebc89623e840ac"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","2a122d9b5dc04db9ac592cff9887c6991154abf4"],"2a122d9b5dc04db9ac592cff9887c6991154abf4":["1a9e81d464930e5664da049442e2630d4b9b00d5"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["773a737806859660d4756f710adc0ad53e05f9d5"],"e2fe35ac47f8f51356d6c1724455d18f31c94fae":["a6378064655e76cd7b908b1cab4ce425b384b508"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}