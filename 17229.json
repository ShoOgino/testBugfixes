{"path":"solr/core/src/test/org/apache/solr/cloud/NestedShardedAtomicUpdateTest#doRootShardRoutingTest().mjava","commits":[{"id":"07749612bed4eb54dd05255c1434c301133310c1","date":1554879779,"type":0,"author":"Moshe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/NestedShardedAtomicUpdateTest#doRootShardRoutingTest().mjava","pathOld":"/dev/null","sourceNew":"  public void doRootShardRoutingTest() throws Exception {\n    assertEquals(4, cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getSlices().size());\n    final String[] ids = {\"3\", \"4\", \"5\", \"6\"};\n\n    assertEquals(\"size of ids to index should be the same as the number of clients\", clients.size(), ids.length);\n    // for now,  we know how ranges will be distributed to shards.\n    // may have to look it up in clusterstate if that assumption changes.\n\n    SolrInputDocument doc = sdoc(\"id\", \"1\", \"level_s\", \"root\");\n\n    final SolrParams params = params(\"wt\", \"json\", \"_route_\", \"1\");\n\n    int which = (params.get(\"_route_\").hashCode() & 0x7fffffff) % clients.size();\n    SolrClient aClient = clients.get(which);\n\n    indexDoc(aClient, params, doc);\n\n    doc = sdoc(\"id\", \"1\", \"children\", map(\"add\", sdocs(sdoc(\"id\", \"2\", \"level_s\", \"child\"))));\n\n    indexDoc(aClient, params, doc);\n\n    for(int idIndex = 0; idIndex < ids.length; ++idIndex) {\n\n      doc = sdoc(\"id\", \"2\", \"grandChildren\", map(\"add\", sdocs(sdoc(\"id\", ids[idIndex], \"level_s\", \"grand_child\"))));\n\n      indexDocAndRandomlyCommit(getRandomSolrClient(), params, doc);\n\n      doc = sdoc(\"id\", \"3\", \"inplace_updatable_int\", map(\"inc\", \"1\"));\n\n      indexDocAndRandomlyCommit(getRandomSolrClient(), params, doc);\n\n      // assert RTG request respects _route_ param\n      QueryResponse routeRsp = getRandomSolrClient().query(params(\"qt\",\"/get\", \"id\",\"2\", \"_route_\", \"1\"));\n      SolrDocument results = (SolrDocument) routeRsp.getResponse().get(\"doc\");\n      assertNotNull(\"RTG should find doc because _route_ was set to the root documents' ID\", results);\n      assertEquals(\"2\", results.getFieldValue(\"id\"));\n\n      // assert all docs are indexed under the same root\n      getRandomSolrClient().commit();\n      assertEquals(0, getRandomSolrClient().query(params(\"q\", \"-_root_:1\")).getResults().size());\n\n      // assert all docs are indexed inside the same block\n      QueryResponse rsp = getRandomSolrClient().query(params(\"qt\",\"/get\", \"id\",\"1\", \"fl\", \"*, [child]\"));\n      SolrDocument val = (SolrDocument) rsp.getResponse().get(\"doc\");\n      assertEquals(\"1\", val.getFieldValue(\"id\"));\n      List<SolrDocument> children = (List) val.getFieldValues(\"children\");\n      assertEquals(1, children.size());\n      SolrDocument childDoc = children.get(0);\n      assertEquals(\"2\", childDoc.getFieldValue(\"id\"));\n      List<SolrDocument> grandChildren = (List) childDoc.getFieldValues(\"grandChildren\");\n      assertEquals(idIndex + 1, grandChildren.size());\n      SolrDocument grandChild = grandChildren.get(0);\n      assertEquals(idIndex + 1, grandChild.getFirstValue(\"inplace_updatable_int\"));\n      assertEquals(\"3\", grandChild.getFieldValue(\"id\"));\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa2585c33d5d66a1c837c312221eb55ddb3c4300","date":1592493170,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/NestedShardedAtomicUpdateTest#doRootShardRoutingTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/NestedShardedAtomicUpdateTest#doRootShardRoutingTest().mjava","sourceNew":"  public void doRootShardRoutingTest() throws Exception {\n    assertEquals(4, cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getSlices().size());\n    final String[] ids = {\"3\", \"4\", \"5\", \"6\"};\n\n    assertEquals(\"size of ids to index should be the same as the number of clients\", clients.size(), ids.length);\n    // for now,  we know how ranges will be distributed to shards.\n    // may have to look it up in clusterstate if that assumption changes.\n\n    SolrInputDocument doc = sdoc(\"id\", \"1\", \"level_s\", \"root\");\n\n    final SolrParams params = params(\"wt\", \"json\", \"_route_\", \"1\");\n\n    int which = (params.get(\"_route_\").hashCode() & 0x7fffffff) % clients.size();\n    SolrClient aClient = clients.get(which);\n\n    indexDoc(aClient, params, doc);\n\n    doc = sdoc(\"id\", \"1\", \"children\", map(\"add\", sdocs(sdoc(\"id\", \"2\", \"level_s\", \"child\"))));\n\n    indexDoc(aClient, params, doc);\n\n    for(int idIndex = 0; idIndex < ids.length; ++idIndex) {\n\n      doc = sdoc(\"id\", \"2\", \"grandChildren\", map(\"add\", sdocs(sdoc(\"id\", ids[idIndex], \"level_s\", \"grand_child\"))));\n\n      indexDocAndRandomlyCommit(getRandomSolrClient(), params, doc);\n\n      doc = sdoc(\"id\", \"3\", \"inplace_updatable_int\", map(\"inc\", \"1\"));\n\n      indexDocAndRandomlyCommit(getRandomSolrClient(), params, doc);\n\n      // assert RTG request respects _route_ param\n      QueryResponse routeRsp = getRandomSolrClient().query(params(\"qt\",\"/get\", \"id\",\"2\", \"_route_\", \"1\"));\n      SolrDocument results = (SolrDocument) routeRsp.getResponse().get(\"doc\");\n      assertNotNull(\"RTG should find doc because _route_ was set to the root documents' ID\", results);\n      assertEquals(\"2\", results.getFieldValue(\"id\"));\n\n      // assert all docs are indexed under the same root\n      getRandomSolrClient().commit();\n      assertEquals(0, getRandomSolrClient().query(params(\"q\", \"-_root_:1\")).getResults().size());\n\n      // assert all docs are indexed inside the same block\n      QueryResponse rsp = getRandomSolrClient().query(params(\"qt\",\"/get\", \"id\",\"1\", \"fl\", \"*, [child]\"));\n      SolrDocument val = (SolrDocument) rsp.getResponse().get(\"doc\");\n      assertEquals(\"1\", val.getFieldValue(\"id\"));\n      @SuppressWarnings({\"unchecked\"})\n      List<SolrDocument> children = (List) val.getFieldValues(\"children\");\n      assertEquals(1, children.size());\n      SolrDocument childDoc = children.get(0);\n      assertEquals(\"2\", childDoc.getFieldValue(\"id\"));\n      @SuppressWarnings({\"unchecked\"})\n      List<SolrDocument> grandChildren = (List) childDoc.getFieldValues(\"grandChildren\");\n      assertEquals(idIndex + 1, grandChildren.size());\n      SolrDocument grandChild = grandChildren.get(0);\n      assertEquals(idIndex + 1, grandChild.getFirstValue(\"inplace_updatable_int\"));\n      assertEquals(\"3\", grandChild.getFieldValue(\"id\"));\n    }\n  }\n\n","sourceOld":"  public void doRootShardRoutingTest() throws Exception {\n    assertEquals(4, cloudClient.getZkStateReader().getClusterState().getCollection(DEFAULT_COLLECTION).getSlices().size());\n    final String[] ids = {\"3\", \"4\", \"5\", \"6\"};\n\n    assertEquals(\"size of ids to index should be the same as the number of clients\", clients.size(), ids.length);\n    // for now,  we know how ranges will be distributed to shards.\n    // may have to look it up in clusterstate if that assumption changes.\n\n    SolrInputDocument doc = sdoc(\"id\", \"1\", \"level_s\", \"root\");\n\n    final SolrParams params = params(\"wt\", \"json\", \"_route_\", \"1\");\n\n    int which = (params.get(\"_route_\").hashCode() & 0x7fffffff) % clients.size();\n    SolrClient aClient = clients.get(which);\n\n    indexDoc(aClient, params, doc);\n\n    doc = sdoc(\"id\", \"1\", \"children\", map(\"add\", sdocs(sdoc(\"id\", \"2\", \"level_s\", \"child\"))));\n\n    indexDoc(aClient, params, doc);\n\n    for(int idIndex = 0; idIndex < ids.length; ++idIndex) {\n\n      doc = sdoc(\"id\", \"2\", \"grandChildren\", map(\"add\", sdocs(sdoc(\"id\", ids[idIndex], \"level_s\", \"grand_child\"))));\n\n      indexDocAndRandomlyCommit(getRandomSolrClient(), params, doc);\n\n      doc = sdoc(\"id\", \"3\", \"inplace_updatable_int\", map(\"inc\", \"1\"));\n\n      indexDocAndRandomlyCommit(getRandomSolrClient(), params, doc);\n\n      // assert RTG request respects _route_ param\n      QueryResponse routeRsp = getRandomSolrClient().query(params(\"qt\",\"/get\", \"id\",\"2\", \"_route_\", \"1\"));\n      SolrDocument results = (SolrDocument) routeRsp.getResponse().get(\"doc\");\n      assertNotNull(\"RTG should find doc because _route_ was set to the root documents' ID\", results);\n      assertEquals(\"2\", results.getFieldValue(\"id\"));\n\n      // assert all docs are indexed under the same root\n      getRandomSolrClient().commit();\n      assertEquals(0, getRandomSolrClient().query(params(\"q\", \"-_root_:1\")).getResults().size());\n\n      // assert all docs are indexed inside the same block\n      QueryResponse rsp = getRandomSolrClient().query(params(\"qt\",\"/get\", \"id\",\"1\", \"fl\", \"*, [child]\"));\n      SolrDocument val = (SolrDocument) rsp.getResponse().get(\"doc\");\n      assertEquals(\"1\", val.getFieldValue(\"id\"));\n      List<SolrDocument> children = (List) val.getFieldValues(\"children\");\n      assertEquals(1, children.size());\n      SolrDocument childDoc = children.get(0);\n      assertEquals(\"2\", childDoc.getFieldValue(\"id\"));\n      List<SolrDocument> grandChildren = (List) childDoc.getFieldValues(\"grandChildren\");\n      assertEquals(idIndex + 1, grandChildren.size());\n      SolrDocument grandChild = grandChildren.get(0);\n      assertEquals(idIndex + 1, grandChild.getFirstValue(\"inplace_updatable_int\"));\n      assertEquals(\"3\", grandChild.getFieldValue(\"id\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["07749612bed4eb54dd05255c1434c301133310c1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"07749612bed4eb54dd05255c1434c301133310c1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"]},"commit2Childs":{"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["07749612bed4eb54dd05255c1434c301133310c1"],"07749612bed4eb54dd05255c1434c301133310c1":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}