{"path":"solr/contrib/clustering/src/main/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/contrib/clustering/src/main/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n    this.controller.init(initAttributes);\n\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/contrib/clustering/src/main/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":null,"sourceOld":"  @Override\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n    this.controller.init(initAttributes);\n\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/contrib/clustering/src/main/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"contrib/clustering/src/main/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n    this.controller.init(initAttributes);\n\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n    this.controller.init(initAttributes);\n\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da8d55113b689b06716246649de6f62430f15c0","date":1453508340,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/contrib/clustering/src/main/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n    this.controller.init(initAttributes);\n\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"88d9ad003cdcb52d92d2f6cfc5abbd1e2ef9d4fb","date":1282573440,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"solr/contrib/clustering/src/main/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/main/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n    \n    // Customize the language model factory. The implementation we provide here\n    // is included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factory relies on if needed.\n    initAttributes.put(\"PreprocessingPipeline.languageModelFactory\",\n      new LuceneLanguageModelFactory());\n    this.controller.init(initAttributes);\n\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n    this.controller.init(initAttributes);\n\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/contrib/clustering/src/main/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/main/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n    \n    // Customize the language model factory. The implementation we provide here\n    // is included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factory relies on if needed.\n    initAttributes.put(\"PreprocessingPipeline.languageModelFactory\",\n      new LuceneLanguageModelFactory());\n    this.controller.init(initAttributes);\n\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n    this.controller.init(initAttributes);\n\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"731f67e712cf1ff8c40442917175a13e2dfebc7c","date":1295136778,"type":3,"author":"Koji Sekiguchi","isMerge":false,"pathNew":"solr/contrib/clustering/src/main/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/main/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n    \n    // Customize the language model factory. The implementation we provide here\n    // is included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factory relies on if needed.\n    initAttributes.put(\"PreprocessingPipeline.languageModelFactory\",\n      LuceneLanguageModelFactory.class);\n    this.controller.init(initAttributes);\n\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n    \n    // Customize the language model factory. The implementation we provide here\n    // is included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factory relies on if needed.\n    initAttributes.put(\"PreprocessingPipeline.languageModelFactory\",\n      new LuceneLanguageModelFactory());\n    this.controller.init(initAttributes);\n\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"16843358872ed92ba92888ab99df297550b9a36a","date":1295144724,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/contrib/clustering/src/main/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/main/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n    \n    // Customize the language model factory. The implementation we provide here\n    // is included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factory relies on if needed.\n    initAttributes.put(\"PreprocessingPipeline.languageModelFactory\",\n      LuceneLanguageModelFactory.class);\n    this.controller.init(initAttributes);\n\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n    \n    // Customize the language model factory. The implementation we provide here\n    // is included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factory relies on if needed.\n    initAttributes.put(\"PreprocessingPipeline.languageModelFactory\",\n      new LuceneLanguageModelFactory());\n    this.controller.init(initAttributes);\n\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/contrib/clustering/src/main/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/main/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n    \n    // Customize the language model factory. The implementation we provide here\n    // is included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factory relies on if needed.\n    initAttributes.put(\"PreprocessingPipeline.languageModelFactory\",\n      LuceneLanguageModelFactory.class);\n    this.controller.init(initAttributes);\n\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n    \n    // Customize the language model factory. The implementation we provide here\n    // is included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factory relies on if needed.\n    initAttributes.put(\"PreprocessingPipeline.languageModelFactory\",\n      new LuceneLanguageModelFactory());\n    this.controller.init(initAttributes);\n\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"017c035439201490351b0f5f3d33a393c6c24551","date":1305551986,"type":3,"author":"Stanisław Osiński","isMerge":false,"pathNew":"solr/contrib/clustering/src/main/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/main/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"\t@Override\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n\t\tBasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes)\n\t\t\t\t.stemmerFactory(LuceneCarrot2StemmerFactory.class)\n\t\t\t\t.tokenizerFactory(LuceneCarrot2TokenizerFactory.class)\n\t\t\t\t.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n\n\t\t// Pass the schema to SolrStopwordsCarrot2LexicalDataFactory.\n\t\tinitAttributes.put(\"solrIndexSchema\", core.getSchema());\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n        .resourceLookup(new ResourceLookup(new IResourceLocator() {\n          @Override\n          public IResource[] getAll(final String resource) {\n            final SolrResourceLoader resourceLoader = core.getResourceLoader();\n            final String carrot2ResourcesDir = resourceLoader.getConfigDir()\n                + initParams.get(CarrotParams.LEXICAL_RESOURCES_DIR, CARROT_RESOURCES_PREFIX);\n            try {\n              log.debug(\"Looking for \" + resource + \" in \"\n                  + carrot2ResourcesDir);\n              final InputStream resourceStream = resourceLoader\n                  .openResource(carrot2ResourcesDir + \"/\" + resource);\n\n              log.info(resource + \" loaded from \" + carrot2ResourcesDir);\n              final IResource foundResource = new IResource() {\n                @Override\n                public InputStream open() throws IOException {\n                  return resourceStream;\n                }\n              };\n              return new IResource[] { foundResource };\n            } catch (RuntimeException e) {\n              // No way to distinguish if the resource was found but failed\n              // to load or wasn't found at all, so we simply fall back\n              // to Carrot2 defaults here by returning an empty locations array.\n              log.debug(resource + \" not found in \" + carrot2ResourcesDir\n                  + \". Using the default \" + resource + \" from Carrot JAR.\");\n              return new IResource[] {};\n            }\n          }\n        },\n\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    this.controller.init(initAttributes);\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n    \n    // Customize the language model factory. The implementation we provide here\n    // is included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factory relies on if needed.\n    initAttributes.put(\"PreprocessingPipeline.languageModelFactory\",\n      LuceneLanguageModelFactory.class);\n    this.controller.init(initAttributes);\n\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":["f9fddef147e9702c85a51239935df11e5338bfbf","f9fddef147e9702c85a51239935df11e5338bfbf"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c3a8a449466c1ff7ce2274fe73dab487256964b4","date":1305735867,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/contrib/clustering/src/main/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/main/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"\t@Override\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n\t\tBasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes)\n\t\t\t\t.stemmerFactory(LuceneCarrot2StemmerFactory.class)\n\t\t\t\t.tokenizerFactory(LuceneCarrot2TokenizerFactory.class)\n\t\t\t\t.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n\n\t\t// Pass the schema to SolrStopwordsCarrot2LexicalDataFactory.\n\t\tinitAttributes.put(\"solrIndexSchema\", core.getSchema());\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n        .resourceLookup(new ResourceLookup(new IResourceLocator() {\n          @Override\n          public IResource[] getAll(final String resource) {\n            final SolrResourceLoader resourceLoader = core.getResourceLoader();\n            final String carrot2ResourcesDir = resourceLoader.getConfigDir()\n                + initParams.get(CarrotParams.LEXICAL_RESOURCES_DIR, CARROT_RESOURCES_PREFIX);\n            try {\n              log.debug(\"Looking for \" + resource + \" in \"\n                  + carrot2ResourcesDir);\n              final InputStream resourceStream = resourceLoader\n                  .openResource(carrot2ResourcesDir + \"/\" + resource);\n\n              log.info(resource + \" loaded from \" + carrot2ResourcesDir);\n              final IResource foundResource = new IResource() {\n                @Override\n                public InputStream open() throws IOException {\n                  return resourceStream;\n                }\n              };\n              return new IResource[] { foundResource };\n            } catch (RuntimeException e) {\n              // No way to distinguish if the resource was found but failed\n              // to load or wasn't found at all, so we simply fall back\n              // to Carrot2 defaults here by returning an empty locations array.\n              log.debug(resource + \" not found in \" + carrot2ResourcesDir\n                  + \". Using the default \" + resource + \" from Carrot JAR.\");\n              return new IResource[] {};\n            }\n          }\n        },\n\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    this.controller.init(initAttributes);\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n    \n    // Customize the language model factory. The implementation we provide here\n    // is included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factory relies on if needed.\n    initAttributes.put(\"PreprocessingPipeline.languageModelFactory\",\n      LuceneLanguageModelFactory.class);\n    this.controller.init(initAttributes);\n\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/contrib/clustering/src/main/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/main/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"\t@Override\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n\t\tBasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes)\n\t\t\t\t.stemmerFactory(LuceneCarrot2StemmerFactory.class)\n\t\t\t\t.tokenizerFactory(LuceneCarrot2TokenizerFactory.class)\n\t\t\t\t.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n\n\t\t// Pass the schema to SolrStopwordsCarrot2LexicalDataFactory.\n\t\tinitAttributes.put(\"solrIndexSchema\", core.getSchema());\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n        .resourceLookup(new ResourceLookup(new IResourceLocator() {\n          @Override\n          public IResource[] getAll(final String resource) {\n            final SolrResourceLoader resourceLoader = core.getResourceLoader();\n            final String carrot2ResourcesDir = resourceLoader.getConfigDir()\n                + initParams.get(CarrotParams.LEXICAL_RESOURCES_DIR, CARROT_RESOURCES_PREFIX);\n            try {\n              log.debug(\"Looking for \" + resource + \" in \"\n                  + carrot2ResourcesDir);\n              final InputStream resourceStream = resourceLoader\n                  .openResource(carrot2ResourcesDir + \"/\" + resource);\n\n              log.info(resource + \" loaded from \" + carrot2ResourcesDir);\n              final IResource foundResource = new IResource() {\n                @Override\n                public InputStream open() throws IOException {\n                  return resourceStream;\n                }\n              };\n              return new IResource[] { foundResource };\n            } catch (RuntimeException e) {\n              // No way to distinguish if the resource was found but failed\n              // to load or wasn't found at all, so we simply fall back\n              // to Carrot2 defaults here by returning an empty locations array.\n              log.debug(resource + \" not found in \" + carrot2ResourcesDir\n                  + \". Using the default \" + resource + \" from Carrot JAR.\");\n              return new IResource[] {};\n            }\n          }\n        },\n\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    this.controller.init(initAttributes);\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n    \n    // Customize the language model factory. The implementation we provide here\n    // is included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factory relies on if needed.\n    initAttributes.put(\"PreprocessingPipeline.languageModelFactory\",\n      LuceneLanguageModelFactory.class);\n    this.controller.init(initAttributes);\n\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/main/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"\t@Override\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n\t\tBasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes)\n\t\t\t\t.stemmerFactory(LuceneCarrot2StemmerFactory.class)\n\t\t\t\t.tokenizerFactory(LuceneCarrot2TokenizerFactory.class)\n\t\t\t\t.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n\n\t\t// Pass the schema to SolrStopwordsCarrot2LexicalDataFactory.\n\t\tinitAttributes.put(\"solrIndexSchema\", core.getSchema());\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n        .resourceLookup(new ResourceLookup(new IResourceLocator() {\n          @Override\n          public IResource[] getAll(final String resource) {\n            final SolrResourceLoader resourceLoader = core.getResourceLoader();\n            final String carrot2ResourcesDir = resourceLoader.getConfigDir()\n                + initParams.get(CarrotParams.LEXICAL_RESOURCES_DIR, CARROT_RESOURCES_PREFIX);\n            try {\n              log.debug(\"Looking for \" + resource + \" in \"\n                  + carrot2ResourcesDir);\n              final InputStream resourceStream = resourceLoader\n                  .openResource(carrot2ResourcesDir + \"/\" + resource);\n\n              log.info(resource + \" loaded from \" + carrot2ResourcesDir);\n              final IResource foundResource = new IResource() {\n                @Override\n                public InputStream open() throws IOException {\n                  return resourceStream;\n                }\n              };\n              return new IResource[] { foundResource };\n            } catch (RuntimeException e) {\n              // No way to distinguish if the resource was found but failed\n              // to load or wasn't found at all, so we simply fall back\n              // to Carrot2 defaults here by returning an empty locations array.\n              log.debug(resource + \" not found in \" + carrot2ResourcesDir\n                  + \". Using the default \" + resource + \" from Carrot JAR.\");\n              return new IResource[] {};\n            }\n          }\n        },\n\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    this.controller.init(initAttributes);\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","sourceOld":"\t@Override\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n\t\tBasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes)\n\t\t\t\t.stemmerFactory(LuceneCarrot2StemmerFactory.class)\n\t\t\t\t.tokenizerFactory(LuceneCarrot2TokenizerFactory.class)\n\t\t\t\t.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n\n\t\t// Pass the schema to SolrStopwordsCarrot2LexicalDataFactory.\n\t\tinitAttributes.put(\"solrIndexSchema\", core.getSchema());\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n        .resourceLookup(new ResourceLookup(new IResourceLocator() {\n          @Override\n          public IResource[] getAll(final String resource) {\n            final SolrResourceLoader resourceLoader = core.getResourceLoader();\n            final String carrot2ResourcesDir = resourceLoader.getConfigDir()\n                + initParams.get(CarrotParams.LEXICAL_RESOURCES_DIR, CARROT_RESOURCES_PREFIX);\n            try {\n              log.debug(\"Looking for \" + resource + \" in \"\n                  + carrot2ResourcesDir);\n              final InputStream resourceStream = resourceLoader\n                  .openResource(carrot2ResourcesDir + \"/\" + resource);\n\n              log.info(resource + \" loaded from \" + carrot2ResourcesDir);\n              final IResource foundResource = new IResource() {\n                @Override\n                public InputStream open() throws IOException {\n                  return resourceStream;\n                }\n              };\n              return new IResource[] { foundResource };\n            } catch (RuntimeException e) {\n              // No way to distinguish if the resource was found but failed\n              // to load or wasn't found at all, so we simply fall back\n              // to Carrot2 defaults here by returning an empty locations array.\n              log.debug(resource + \" not found in \" + carrot2ResourcesDir\n                  + \". Using the default \" + resource + \" from Carrot JAR.\");\n              return new IResource[] {};\n            }\n          }\n        },\n\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    this.controller.init(initAttributes);\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/main/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"\t@Override\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n\t\tBasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes)\n\t\t\t\t.stemmerFactory(LuceneCarrot2StemmerFactory.class)\n\t\t\t\t.tokenizerFactory(LuceneCarrot2TokenizerFactory.class)\n\t\t\t\t.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n\n\t\t// Pass the schema to SolrStopwordsCarrot2LexicalDataFactory.\n\t\tinitAttributes.put(\"solrIndexSchema\", core.getSchema());\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n        .resourceLookup(new ResourceLookup(new IResourceLocator() {\n          @Override\n          public IResource[] getAll(final String resource) {\n            final SolrResourceLoader resourceLoader = core.getResourceLoader();\n            final String carrot2ResourcesDir = resourceLoader.getConfigDir()\n                + initParams.get(CarrotParams.LEXICAL_RESOURCES_DIR, CARROT_RESOURCES_PREFIX);\n            try {\n              log.debug(\"Looking for \" + resource + \" in \"\n                  + carrot2ResourcesDir);\n              final InputStream resourceStream = resourceLoader\n                  .openResource(carrot2ResourcesDir + \"/\" + resource);\n\n              log.info(resource + \" loaded from \" + carrot2ResourcesDir);\n              final IResource foundResource = new IResource() {\n                @Override\n                public InputStream open() throws IOException {\n                  return resourceStream;\n                }\n              };\n              return new IResource[] { foundResource };\n            } catch (RuntimeException e) {\n              // No way to distinguish if the resource was found but failed\n              // to load or wasn't found at all, so we simply fall back\n              // to Carrot2 defaults here by returning an empty locations array.\n              log.debug(resource + \" not found in \" + carrot2ResourcesDir\n                  + \". Using the default \" + resource + \" from Carrot JAR.\");\n              return new IResource[] {};\n            }\n          }\n        },\n\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    this.controller.init(initAttributes);\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","sourceOld":"\t@Override\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n\t\tBasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes)\n\t\t\t\t.stemmerFactory(LuceneCarrot2StemmerFactory.class)\n\t\t\t\t.tokenizerFactory(LuceneCarrot2TokenizerFactory.class)\n\t\t\t\t.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n\n\t\t// Pass the schema to SolrStopwordsCarrot2LexicalDataFactory.\n\t\tinitAttributes.put(\"solrIndexSchema\", core.getSchema());\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n        .resourceLookup(new ResourceLookup(new IResourceLocator() {\n          @Override\n          public IResource[] getAll(final String resource) {\n            final SolrResourceLoader resourceLoader = core.getResourceLoader();\n            final String carrot2ResourcesDir = resourceLoader.getConfigDir()\n                + initParams.get(CarrotParams.LEXICAL_RESOURCES_DIR, CARROT_RESOURCES_PREFIX);\n            try {\n              log.debug(\"Looking for \" + resource + \" in \"\n                  + carrot2ResourcesDir);\n              final InputStream resourceStream = resourceLoader\n                  .openResource(carrot2ResourcesDir + \"/\" + resource);\n\n              log.info(resource + \" loaded from \" + carrot2ResourcesDir);\n              final IResource foundResource = new IResource() {\n                @Override\n                public InputStream open() throws IOException {\n                  return resourceStream;\n                }\n              };\n              return new IResource[] { foundResource };\n            } catch (RuntimeException e) {\n              // No way to distinguish if the resource was found but failed\n              // to load or wasn't found at all, so we simply fall back\n              // to Carrot2 defaults here by returning an empty locations array.\n              log.debug(resource + \" not found in \" + carrot2ResourcesDir\n                  + \". Using the default \" + resource + \" from Carrot JAR.\");\n              return new IResource[] {};\n            }\n          }\n        },\n\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    this.controller.init(initAttributes);\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"017c035439201490351b0f5f3d33a393c6c24551":["731f67e712cf1ff8c40442917175a13e2dfebc7c"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"c26f00b574427b55127e869b935845554afde1fa":["017c035439201490351b0f5f3d33a393c6c24551","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"16843358872ed92ba92888ab99df297550b9a36a":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","731f67e712cf1ff8c40442917175a13e2dfebc7c"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["1da8d55113b689b06716246649de6f62430f15c0","88d9ad003cdcb52d92d2f6cfc5abbd1e2ef9d4fb"],"731f67e712cf1ff8c40442917175a13e2dfebc7c":["88d9ad003cdcb52d92d2f6cfc5abbd1e2ef9d4fb"],"88d9ad003cdcb52d92d2f6cfc5abbd1e2ef9d4fb":["1da8d55113b689b06716246649de6f62430f15c0"],"1da8d55113b689b06716246649de6f62430f15c0":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","ad94625fb8d088209f46650c8097196fec67f00c"],"c3a8a449466c1ff7ce2274fe73dab487256964b4":["29ef99d61cda9641b6250bf9567329a6e65f901d","017c035439201490351b0f5f3d33a393c6c24551"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["a3776dccca01c11e7046323cfad46a3b4a471233","017c035439201490351b0f5f3d33a393c6c24551"],"a3776dccca01c11e7046323cfad46a3b4a471233":["731f67e712cf1ff8c40442917175a13e2dfebc7c","017c035439201490351b0f5f3d33a393c6c24551"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["88d9ad003cdcb52d92d2f6cfc5abbd1e2ef9d4fb","731f67e712cf1ff8c40442917175a13e2dfebc7c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ad94625fb8d088209f46650c8097196fec67f00c":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"017c035439201490351b0f5f3d33a393c6c24551":["c26f00b574427b55127e869b935845554afde1fa","c3a8a449466c1ff7ce2274fe73dab487256964b4","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","a3776dccca01c11e7046323cfad46a3b4a471233"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["1da8d55113b689b06716246649de6f62430f15c0"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["ad94625fb8d088209f46650c8097196fec67f00c"],"16843358872ed92ba92888ab99df297550b9a36a":[],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["16843358872ed92ba92888ab99df297550b9a36a"],"731f67e712cf1ff8c40442917175a13e2dfebc7c":["017c035439201490351b0f5f3d33a393c6c24551","16843358872ed92ba92888ab99df297550b9a36a","a3776dccca01c11e7046323cfad46a3b4a471233","29ef99d61cda9641b6250bf9567329a6e65f901d"],"88d9ad003cdcb52d92d2f6cfc5abbd1e2ef9d4fb":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","731f67e712cf1ff8c40442917175a13e2dfebc7c","29ef99d61cda9641b6250bf9567329a6e65f901d"],"1da8d55113b689b06716246649de6f62430f15c0":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","88d9ad003cdcb52d92d2f6cfc5abbd1e2ef9d4fb"],"c3a8a449466c1ff7ce2274fe73dab487256964b4":[],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["c26f00b574427b55127e869b935845554afde1fa"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["c3a8a449466c1ff7ce2274fe73dab487256964b4"],"a3776dccca01c11e7046323cfad46a3b4a471233":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"ad94625fb8d088209f46650c8097196fec67f00c":["1da8d55113b689b06716246649de6f62430f15c0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["16843358872ed92ba92888ab99df297550b9a36a","c3a8a449466c1ff7ce2274fe73dab487256964b4","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}