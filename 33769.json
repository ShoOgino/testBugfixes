{"path":"src/java/org/apache/lucene/index/IndexWriter#copyExternalSegments().mjava","commits":[{"id":"b1405362241b561f5590ff4a87d5d6e173bcd9cf","date":1190107634,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#copyExternalSegments().mjava","pathOld":"/dev/null","sourceNew":"  /* If any of our segments are using a directory != ours\n   * then copy them over.  Currently this is only used by\n   * addIndexesNoOptimize(). */\n  private synchronized void copyExternalSegments() throws CorruptIndexException, IOException {\n    final int numSegments = segmentInfos.size();\n    for(int i=0;i<numSegments;i++) {\n      SegmentInfo info = segmentInfos.info(i);\n      if (info.dir != directory) {\n        MergePolicy.OneMerge merge = new MergePolicy.OneMerge(segmentInfos.range(i, 1+i), info.getUseCompoundFile());\n        if (registerMerge(merge)) {\n          pendingMerges.remove(merge);\n          runningMerges.add(merge);\n          merge(merge);\n        } else\n          // This means there is a bug in the\n          // MergeScheduler.  MergeSchedulers in general are\n          // not allowed to run a merge involving segments\n          // external to this IndexWriter's directory in the\n          // background because this would put the index\n          // into an inconsistent state (where segmentInfos\n          // has been written with such external segments\n          // that an IndexReader would fail to load).\n          throw new MergePolicy.MergeException(\"segment \\\"\" + info.name + \" exists in external directory yet the MergeScheduler executed the merge in a separate thread\");\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["dbb18b6a222f2507f22fab7cc7eed06658d59772"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0feb10cdc38728e18bd11f49da14b22e9141bcdc","date":1201897345,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#copyExternalSegments().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#copyExternalSegments().mjava","sourceNew":"  /* If any of our segments are using a directory != ours\n   * then copy them over.  Currently this is only used by\n   * addIndexesNoOptimize(). */\n  private synchronized void copyExternalSegments() throws CorruptIndexException, IOException {\n    final int numSegments = segmentInfos.size();\n    for(int i=0;i<numSegments;i++) {\n      SegmentInfo info = segmentInfos.info(i);\n      if (info.dir != directory) {\n        MergePolicy.OneMerge merge = new MergePolicy.OneMerge(segmentInfos.range(i, 1+i), info.getUseCompoundFile());\n        if (registerMerge(merge)) {\n          pendingMerges.remove(merge);\n          runningMerges.add(merge);\n          merge(merge);\n        } else\n          // This means there is a bug in the\n          // MergeScheduler.  MergeSchedulers in general are\n          // not allowed to run a merge involving segments\n          // external to this IndexWriter's directory in the\n          // background because this would put the index\n          // into an inconsistent state (where segmentInfos\n          // has been written with such external segments\n          // that an IndexReader would fail to load).\n          throw new MergePolicy.MergeException(\"segment \\\"\" + info.name + \" exists in external directory yet the MergeScheduler executed the merge in a separate thread\",\n                                               directory);\n      }\n    }\n  }\n\n","sourceOld":"  /* If any of our segments are using a directory != ours\n   * then copy them over.  Currently this is only used by\n   * addIndexesNoOptimize(). */\n  private synchronized void copyExternalSegments() throws CorruptIndexException, IOException {\n    final int numSegments = segmentInfos.size();\n    for(int i=0;i<numSegments;i++) {\n      SegmentInfo info = segmentInfos.info(i);\n      if (info.dir != directory) {\n        MergePolicy.OneMerge merge = new MergePolicy.OneMerge(segmentInfos.range(i, 1+i), info.getUseCompoundFile());\n        if (registerMerge(merge)) {\n          pendingMerges.remove(merge);\n          runningMerges.add(merge);\n          merge(merge);\n        } else\n          // This means there is a bug in the\n          // MergeScheduler.  MergeSchedulers in general are\n          // not allowed to run a merge involving segments\n          // external to this IndexWriter's directory in the\n          // background because this would put the index\n          // into an inconsistent state (where segmentInfos\n          // has been written with such external segments\n          // that an IndexReader would fail to load).\n          throw new MergePolicy.MergeException(\"segment \\\"\" + info.name + \" exists in external directory yet the MergeScheduler executed the merge in a separate thread\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dbb18b6a222f2507f22fab7cc7eed06658d59772","date":1204804366,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#copyExternalSegments().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#copyExternalSegments().mjava","sourceNew":"  /* If any of our segments are using a directory != ours\n   * then copy them over.  Currently this is only used by\n   * addIndexesNoOptimize(). */\n  private void copyExternalSegments() throws CorruptIndexException, IOException {\n    while(true) {\n      SegmentInfo info = null;\n      MergePolicy.OneMerge merge = null;\n      synchronized(this) {\n        final int numSegments = segmentInfos.size();\n        for(int i=0;i<numSegments;i++) {\n          info = segmentInfos.info(i);\n          if (info.dir != directory) {\n            merge = new MergePolicy.OneMerge(segmentInfos.range(i, 1+i), info.getUseCompoundFile());\n            break;\n          }\n        }\n      }\n\n      if (merge != null) {\n        if (registerMerge(merge)) {\n          pendingMerges.remove(merge);\n          runningMerges.add(merge);\n          merge(merge);\n        } else\n          // This means there is a bug in the\n          // MergeScheduler.  MergeSchedulers in general are\n          // not allowed to run a merge involving segments\n          // external to this IndexWriter's directory in the\n          // background because this would put the index\n          // into an inconsistent state (where segmentInfos\n          // has been written with such external segments\n          // that an IndexReader would fail to load).\n          throw new MergePolicy.MergeException(\"segment \\\"\" + info.name + \" exists in external directory yet the MergeScheduler executed the merge in a separate thread\",\n                                               directory);\n      } else\n        // No more external segments\n        break;\n    }\n  }\n\n","sourceOld":"  /* If any of our segments are using a directory != ours\n   * then copy them over.  Currently this is only used by\n   * addIndexesNoOptimize(). */\n  private synchronized void copyExternalSegments() throws CorruptIndexException, IOException {\n    final int numSegments = segmentInfos.size();\n    for(int i=0;i<numSegments;i++) {\n      SegmentInfo info = segmentInfos.info(i);\n      if (info.dir != directory) {\n        MergePolicy.OneMerge merge = new MergePolicy.OneMerge(segmentInfos.range(i, 1+i), info.getUseCompoundFile());\n        if (registerMerge(merge)) {\n          pendingMerges.remove(merge);\n          runningMerges.add(merge);\n          merge(merge);\n        } else\n          // This means there is a bug in the\n          // MergeScheduler.  MergeSchedulers in general are\n          // not allowed to run a merge involving segments\n          // external to this IndexWriter's directory in the\n          // background because this would put the index\n          // into an inconsistent state (where segmentInfos\n          // has been written with such external segments\n          // that an IndexReader would fail to load).\n          throw new MergePolicy.MergeException(\"segment \\\"\" + info.name + \" exists in external directory yet the MergeScheduler executed the merge in a separate thread\",\n                                               directory);\n      }\n    }\n  }\n\n","bugFix":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56454c8024f29ab494bb7c6b9934104c4a2c7b55","date":1208979441,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#copyExternalSegments().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#copyExternalSegments().mjava","sourceNew":"  /* If any of our segments are using a directory != ours\n   * then copy them over.  Currently this is only used by\n   * addIndexesNoOptimize(). */\n  private void copyExternalSegments() throws CorruptIndexException, IOException {\n\n    boolean any = false;\n\n    while(true) {\n      SegmentInfo info = null;\n      MergePolicy.OneMerge merge = null;\n      synchronized(this) {\n        final int numSegments = segmentInfos.size();\n        for(int i=0;i<numSegments;i++) {\n          info = segmentInfos.info(i);\n          if (info.dir != directory) {\n            merge = new MergePolicy.OneMerge(segmentInfos.range(i, 1+i), info.getUseCompoundFile());\n            break;\n          }\n        }\n      }\n\n      if (merge != null) {\n        if (registerMerge(merge)) {\n          pendingMerges.remove(merge);\n          runningMerges.add(merge);\n          any = true;\n          merge(merge);\n        } else\n          // This means there is a bug in the\n          // MergeScheduler.  MergeSchedulers in general are\n          // not allowed to run a merge involving segments\n          // external to this IndexWriter's directory in the\n          // background because this would put the index\n          // into an inconsistent state (where segmentInfos\n          // has been written with such external segments\n          // that an IndexReader would fail to load).\n          throw new MergePolicy.MergeException(\"segment \\\"\" + info.name + \" exists in external directory yet the MergeScheduler executed the merge in a separate thread\",\n                                               directory);\n      } else\n        // No more external segments\n        break;\n    }\n\n    if (any)\n      // Sometimes, on copying an external segment over,\n      // more merges may become necessary:\n      mergeScheduler.merge(this);\n  }\n\n","sourceOld":"  /* If any of our segments are using a directory != ours\n   * then copy them over.  Currently this is only used by\n   * addIndexesNoOptimize(). */\n  private void copyExternalSegments() throws CorruptIndexException, IOException {\n    while(true) {\n      SegmentInfo info = null;\n      MergePolicy.OneMerge merge = null;\n      synchronized(this) {\n        final int numSegments = segmentInfos.size();\n        for(int i=0;i<numSegments;i++) {\n          info = segmentInfos.info(i);\n          if (info.dir != directory) {\n            merge = new MergePolicy.OneMerge(segmentInfos.range(i, 1+i), info.getUseCompoundFile());\n            break;\n          }\n        }\n      }\n\n      if (merge != null) {\n        if (registerMerge(merge)) {\n          pendingMerges.remove(merge);\n          runningMerges.add(merge);\n          merge(merge);\n        } else\n          // This means there is a bug in the\n          // MergeScheduler.  MergeSchedulers in general are\n          // not allowed to run a merge involving segments\n          // external to this IndexWriter's directory in the\n          // background because this would put the index\n          // into an inconsistent state (where segmentInfos\n          // has been written with such external segments\n          // that an IndexReader would fail to load).\n          throw new MergePolicy.MergeException(\"segment \\\"\" + info.name + \" exists in external directory yet the MergeScheduler executed the merge in a separate thread\",\n                                               directory);\n      } else\n        // No more external segments\n        break;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2586f96f60332eb97ecd2934b0763791462568b2","date":1220116589,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/index/IndexWriter#copyExternalSegments().mjava","sourceNew":null,"sourceOld":"  /* If any of our segments are using a directory != ours\n   * then copy them over.  Currently this is only used by\n   * addIndexesNoOptimize(). */\n  private void copyExternalSegments() throws CorruptIndexException, IOException {\n\n    boolean any = false;\n\n    while(true) {\n      SegmentInfo info = null;\n      MergePolicy.OneMerge merge = null;\n      synchronized(this) {\n        final int numSegments = segmentInfos.size();\n        for(int i=0;i<numSegments;i++) {\n          info = segmentInfos.info(i);\n          if (info.dir != directory) {\n            merge = new MergePolicy.OneMerge(segmentInfos.range(i, 1+i), info.getUseCompoundFile());\n            break;\n          }\n        }\n      }\n\n      if (merge != null) {\n        if (registerMerge(merge)) {\n          pendingMerges.remove(merge);\n          runningMerges.add(merge);\n          any = true;\n          merge(merge);\n        } else\n          // This means there is a bug in the\n          // MergeScheduler.  MergeSchedulers in general are\n          // not allowed to run a merge involving segments\n          // external to this IndexWriter's directory in the\n          // background because this would put the index\n          // into an inconsistent state (where segmentInfos\n          // has been written with such external segments\n          // that an IndexReader would fail to load).\n          throw new MergePolicy.MergeException(\"segment \\\"\" + info.name + \" exists in external directory yet the MergeScheduler executed the merge in a separate thread\",\n                                               directory);\n      } else\n        // No more external segments\n        break;\n    }\n\n    if (any)\n      // Sometimes, on copying an external segment over,\n      // more merges may become necessary:\n      mergeScheduler.merge(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"56454c8024f29ab494bb7c6b9934104c4a2c7b55":["dbb18b6a222f2507f22fab7cc7eed06658d59772"],"dbb18b6a222f2507f22fab7cc7eed06658d59772":["0feb10cdc38728e18bd11f49da14b22e9141bcdc"],"b1405362241b561f5590ff4a87d5d6e173bcd9cf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2586f96f60332eb97ecd2934b0763791462568b2":["56454c8024f29ab494bb7c6b9934104c4a2c7b55"],"0feb10cdc38728e18bd11f49da14b22e9141bcdc":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2586f96f60332eb97ecd2934b0763791462568b2"]},"commit2Childs":{"56454c8024f29ab494bb7c6b9934104c4a2c7b55":["2586f96f60332eb97ecd2934b0763791462568b2"],"dbb18b6a222f2507f22fab7cc7eed06658d59772":["56454c8024f29ab494bb7c6b9934104c4a2c7b55"],"b1405362241b561f5590ff4a87d5d6e173bcd9cf":["0feb10cdc38728e18bd11f49da14b22e9141bcdc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"2586f96f60332eb97ecd2934b0763791462568b2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0feb10cdc38728e18bd11f49da14b22e9141bcdc":["dbb18b6a222f2507f22fab7cc7eed06658d59772"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}