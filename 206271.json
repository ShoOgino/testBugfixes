{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.FullLinearCrossingEdgeIterator#matches(Edge).mjava","commits":[{"id":"1e7090fb56105afb6515b6506724359c32ec7639","date":1521211434,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.FullLinearCrossingEdgeIterator#matches(Edge).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      final GeoPoint[] crossingPoints = plane.findCrossings(planetModel, edge.plane, bound, edge.startPlane, edge.endPlane);\n      if (crossingPoints != null) {\n        // We need to handle the endpoint case, which is quite tricky.\n        for (final GeoPoint crossingPoint : crossingPoints) {\n          countCrossingPoint(crossingPoint, edge);\n        }\n      }\n      return true;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["affd6585e0a92f8483e2f9dd579c1927505c7377"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8b879b14da40ab73551b75835099a61e622a83d3","date":1522406622,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.FullLinearCrossingEdgeIterator#matches(Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.FullLinearCrossingEdgeIterator#matches(Edge).mjava","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // This should precisely mirror what is in DualCrossingIterator, but without the dual crossings.\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] planeCrossings = plane.findIntersections(planetModel, edge.plane, bound, edge.startPlane, edge.endPlane);\n      if (planeCrossings != null && planeCrossings.length == 0) {\n        // No actual crossing\n        return true;\n      }\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      final GeoPoint[] aboveCrossings = abovePlane.findCrossings(planetModel, edge.plane, bound, edge.startPlane, edge.endPlane);\n      final GeoPoint[] belowCrossings = belowPlane.findCrossings(planetModel, edge.plane, bound, edge.startPlane, edge.endPlane);\n      \n      if (aboveCrossings != null) {\n        aboveCrossingCount += aboveCrossings.length;\n      }\n      if (belowCrossings != null) {\n        belowCrossingCount += belowCrossings.length;\n      }\n\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      final GeoPoint[] crossingPoints = plane.findCrossings(planetModel, edge.plane, bound, edge.startPlane, edge.endPlane);\n      if (crossingPoints != null) {\n        // We need to handle the endpoint case, which is quite tricky.\n        for (final GeoPoint crossingPoint : crossingPoints) {\n          countCrossingPoint(crossingPoint, edge);\n        }\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"65d6841593942b33f59f72a2448d918225940311","date":1523319192,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.FullLinearCrossingEdgeIterator#matches(Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.FullLinearCrossingEdgeIterator#matches(Edge).mjava","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // This should precisely mirror what is in DualCrossingIterator, but without the dual crossings.\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] planeCrossings = plane.findIntersections(planetModel, edge.plane, bound, edge.startPlane, edge.endPlane);\n      if (planeCrossings != null && planeCrossings.length == 0) {\n        // Sometimes on the hairy edge an intersection will be missed.  This check finds those.\n        if (!plane.evaluateIsZero(edge.startPoint) && !plane.evaluateIsZero(edge.endPoint)) {\n          return true;\n        }\n      }\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      final GeoPoint[] aboveCrossings = abovePlane.findCrossings(planetModel, edge.plane, bound, edge.startPlane, edge.endPlane);\n      final GeoPoint[] belowCrossings = belowPlane.findCrossings(planetModel, edge.plane, bound, edge.startPlane, edge.endPlane);\n      \n      if (aboveCrossings != null) {\n        aboveCrossingCount += aboveCrossings.length;\n      }\n      if (belowCrossings != null) {\n        belowCrossingCount += belowCrossings.length;\n      }\n\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // This should precisely mirror what is in DualCrossingIterator, but without the dual crossings.\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] planeCrossings = plane.findIntersections(planetModel, edge.plane, bound, edge.startPlane, edge.endPlane);\n      if (planeCrossings != null && planeCrossings.length == 0) {\n        // No actual crossing\n        return true;\n      }\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      final GeoPoint[] aboveCrossings = abovePlane.findCrossings(planetModel, edge.plane, bound, edge.startPlane, edge.endPlane);\n      final GeoPoint[] belowCrossings = belowPlane.findCrossings(planetModel, edge.plane, bound, edge.startPlane, edge.endPlane);\n      \n      if (aboveCrossings != null) {\n        aboveCrossingCount += aboveCrossings.length;\n      }\n      if (belowCrossings != null) {\n        belowCrossingCount += belowCrossings.length;\n      }\n\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1cf8d8275024d808d6f5e5a1a07e8fa2b010706a","date":1523373040,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.FullLinearCrossingEdgeIterator#matches(Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.FullLinearCrossingEdgeIterator#matches(Edge).mjava","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // This should precisely mirror what is in DualCrossingIterator, but without the dual crossings.\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] planeCrossings = plane.findIntersections(planetModel, edge.plane, bound, edge.startPlane, edge.endPlane);\n      if (planeCrossings != null && planeCrossings.length == 0) {\n        // Sometimes on the hairy edge an intersection will be missed.  This check finds those.\n        if (!plane.evaluateIsZero(edge.startPoint) && !plane.evaluateIsZero(edge.endPoint)) {\n          return true;\n        }\n      }\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      final GeoPoint[] aboveCrossings = computeCrossings(abovePlane, edge, bound);\n      final GeoPoint[] belowCrossings = computeCrossings(belowPlane, edge, bound);\n      \n      if (aboveCrossings != null) {\n        aboveCrossingCount += aboveCrossings.length;\n      }\n      if (belowCrossings != null) {\n        belowCrossingCount += belowCrossings.length;\n      }\n\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // This should precisely mirror what is in DualCrossingIterator, but without the dual crossings.\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] planeCrossings = plane.findIntersections(planetModel, edge.plane, bound, edge.startPlane, edge.endPlane);\n      if (planeCrossings != null && planeCrossings.length == 0) {\n        // Sometimes on the hairy edge an intersection will be missed.  This check finds those.\n        if (!plane.evaluateIsZero(edge.startPoint) && !plane.evaluateIsZero(edge.endPoint)) {\n          return true;\n        }\n      }\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      final GeoPoint[] aboveCrossings = abovePlane.findCrossings(planetModel, edge.plane, bound, edge.startPlane, edge.endPlane);\n      final GeoPoint[] belowCrossings = belowPlane.findCrossings(planetModel, edge.plane, bound, edge.startPlane, edge.endPlane);\n      \n      if (aboveCrossings != null) {\n        aboveCrossingCount += aboveCrossings.length;\n      }\n      if (belowCrossings != null) {\n        belowCrossingCount += belowCrossings.length;\n      }\n\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d564e0296db7f80d73dd62b17710f61c85f38c50","date":1523483630,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.FullLinearCrossingEdgeIterator#matches(Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.FullLinearCrossingEdgeIterator#matches(Edge).mjava","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // This should precisely mirror what is in DualCrossingIterator, but without the dual crossings.\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] planeCrossings = plane.findIntersections(planetModel, edge.plane, bound, edge.startPlane, edge.endPlane);\n      if (planeCrossings != null && planeCrossings.length == 0) {\n        // Sometimes on the hairy edge an intersection will be missed.  This check finds those.\n        if (!plane.evaluateIsZero(edge.startPoint) && !plane.evaluateIsZero(edge.endPoint)) {\n          return true;\n        }\n      }\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      aboveCrossingCount += countCrossings(edge, abovePlane, bound);\n      belowCrossingCount += countCrossings(edge, belowPlane, bound);\n\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // This should precisely mirror what is in DualCrossingIterator, but without the dual crossings.\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] planeCrossings = plane.findIntersections(planetModel, edge.plane, bound, edge.startPlane, edge.endPlane);\n      if (planeCrossings != null && planeCrossings.length == 0) {\n        // Sometimes on the hairy edge an intersection will be missed.  This check finds those.\n        if (!plane.evaluateIsZero(edge.startPoint) && !plane.evaluateIsZero(edge.endPoint)) {\n          return true;\n        }\n      }\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      final GeoPoint[] aboveCrossings = computeCrossings(abovePlane, edge, bound);\n      final GeoPoint[] belowCrossings = computeCrossings(belowPlane, edge, bound);\n      \n      if (aboveCrossings != null) {\n        aboveCrossingCount += aboveCrossings.length;\n      }\n      if (belowCrossings != null) {\n        belowCrossingCount += belowCrossings.length;\n      }\n\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"affd6585e0a92f8483e2f9dd579c1927505c7377","date":1523947544,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.FullLinearCrossingEdgeIterator#matches(Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.FullLinearCrossingEdgeIterator#matches(Edge).mjava","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge.\n      if (edge.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // This should precisely mirror what is in DualCrossingIterator, but without the dual crossings.\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] planeCrossings = plane.findIntersections(planetModel, edge.plane, bound, edge.startPlane, edge.endPlane);\n      if (planeCrossings != null && planeCrossings.length == 0) {\n        // Sometimes on the hairy edge an intersection will be missed.  This check finds those.\n        if (!plane.evaluateIsZero(edge.startPoint) && !plane.evaluateIsZero(edge.endPoint)) {\n          return true;\n        }\n      }\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      aboveCrossingCount += countCrossings(edge, abovePlane, bound);\n      belowCrossingCount += countCrossings(edge, belowPlane, bound);\n\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // This should precisely mirror what is in DualCrossingIterator, but without the dual crossings.\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] planeCrossings = plane.findIntersections(planetModel, edge.plane, bound, edge.startPlane, edge.endPlane);\n      if (planeCrossings != null && planeCrossings.length == 0) {\n        // Sometimes on the hairy edge an intersection will be missed.  This check finds those.\n        if (!plane.evaluateIsZero(edge.startPoint) && !plane.evaluateIsZero(edge.endPoint)) {\n          return true;\n        }\n      }\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      aboveCrossingCount += countCrossings(edge, abovePlane, bound);\n      belowCrossingCount += countCrossings(edge, belowPlane, bound);\n\n      return true;\n    }\n\n","bugFix":["1e7090fb56105afb6515b6506724359c32ec7639"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d1ddb4f16cfdfa4f6fa9349fb90d48b0f1e6f040","date":1524832766,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.FullLinearCrossingEdgeIterator#matches(Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.FullLinearCrossingEdgeIterator#matches(Edge).mjava","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      //System.out.println(\" Edge [\"+edge.startPoint+\" --> \"+edge.endPoint+\"] potentially crosses travel plane \"+plane);\n      // Early exit if the point is on the edge.\n      if (edge.isWithin(thePointX, thePointY, thePointZ)) {\n        //System.out.println(\"  Point is on the edge; in-set\");\n        return false;\n      }\n      \n      // This should precisely mirror what is in DualCrossingIterator, but without the dual crossings.\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] planeCrossings = plane.findIntersections(planetModel, edge.plane, bound, edge.startPlane, edge.endPlane);\n      if (planeCrossings != null && planeCrossings.length == 0) {\n        // Sometimes on the hairy edge an intersection will be missed.  This check finds those.\n        if (!plane.evaluateIsZero(edge.startPoint) && !plane.evaluateIsZero(edge.endPoint)) {\n          return true;\n        }\n      }\n\n      //System.out.println(\"  Edge [\"+edge.startPoint+\" --> \"+edge.endPoint+\"] intersects travel plane \"+plane);\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      aboveCrossingCount += countCrossings(edge, abovePlane, bound);\n      belowCrossingCount += countCrossings(edge, belowPlane, bound);\n\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge.\n      if (edge.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // This should precisely mirror what is in DualCrossingIterator, but without the dual crossings.\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] planeCrossings = plane.findIntersections(planetModel, edge.plane, bound, edge.startPlane, edge.endPlane);\n      if (planeCrossings != null && planeCrossings.length == 0) {\n        // Sometimes on the hairy edge an intersection will be missed.  This check finds those.\n        if (!plane.evaluateIsZero(edge.startPoint) && !plane.evaluateIsZero(edge.endPoint)) {\n          return true;\n        }\n      }\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      aboveCrossingCount += countCrossings(edge, abovePlane, bound);\n      belowCrossingCount += countCrossings(edge, belowPlane, bound);\n\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e456381ade0a256838cbf558702284e345c8d3d6","date":1524920804,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.FullLinearCrossingEdgeIterator#matches(Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.FullLinearCrossingEdgeIterator#matches(Edge).mjava","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      //System.out.println(\" Edge [\"+edge.startPoint+\" --> \"+edge.endPoint+\"] potentially crosses travel plane \"+plane);\n      // Early exit if the point is on the edge.\n      if (edge.isWithin(thePointX, thePointY, thePointZ)) {\n        //System.out.println(\"  Point is on the edge; in-set\");\n        onEdge = true;\n        return false;\n      }\n      \n      // This should precisely mirror what is in DualCrossingIterator, but without the dual crossings.\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] planeCrossings = plane.findIntersections(planetModel, edge.plane, bound, edge.startPlane, edge.endPlane);\n      if (planeCrossings != null && planeCrossings.length == 0) {\n        // Sometimes on the hairy edge an intersection will be missed.  This check finds those.\n        if (!plane.evaluateIsZero(edge.startPoint) && !plane.evaluateIsZero(edge.endPoint)) {\n          return true;\n        }\n      }\n\n      //System.out.println(\"  Edge intersects travel plane \"+plane);\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      final int aboveCrossings = countCrossings(edge, abovePlane, bound);\n      aboveCrossingCount += aboveCrossings;\n      final int belowCrossings = countCrossings(edge, belowPlane, bound);\n      belowCrossingCount += belowCrossings;\n      //System.out.println(\"  Above crossings = \"+aboveCrossings+\"; below crossings = \"+belowCrossings);\n\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean matches(final Edge edge) {\n      //System.out.println(\" Edge [\"+edge.startPoint+\" --> \"+edge.endPoint+\"] potentially crosses travel plane \"+plane);\n      // Early exit if the point is on the edge.\n      if (edge.isWithin(thePointX, thePointY, thePointZ)) {\n        //System.out.println(\"  Point is on the edge; in-set\");\n        return false;\n      }\n      \n      // This should precisely mirror what is in DualCrossingIterator, but without the dual crossings.\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] planeCrossings = plane.findIntersections(planetModel, edge.plane, bound, edge.startPlane, edge.endPlane);\n      if (planeCrossings != null && planeCrossings.length == 0) {\n        // Sometimes on the hairy edge an intersection will be missed.  This check finds those.\n        if (!plane.evaluateIsZero(edge.startPoint) && !plane.evaluateIsZero(edge.endPoint)) {\n          return true;\n        }\n      }\n\n      //System.out.println(\"  Edge [\"+edge.startPoint+\" --> \"+edge.endPoint+\"] intersects travel plane \"+plane);\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      aboveCrossingCount += countCrossings(edge, abovePlane, bound);\n      belowCrossingCount += countCrossings(edge, belowPlane, bound);\n\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1cf8d8275024d808d6f5e5a1a07e8fa2b010706a":["65d6841593942b33f59f72a2448d918225940311"],"8b879b14da40ab73551b75835099a61e622a83d3":["1e7090fb56105afb6515b6506724359c32ec7639"],"1e7090fb56105afb6515b6506724359c32ec7639":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e456381ade0a256838cbf558702284e345c8d3d6":["d1ddb4f16cfdfa4f6fa9349fb90d48b0f1e6f040"],"d564e0296db7f80d73dd62b17710f61c85f38c50":["1cf8d8275024d808d6f5e5a1a07e8fa2b010706a"],"65d6841593942b33f59f72a2448d918225940311":["8b879b14da40ab73551b75835099a61e622a83d3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d1ddb4f16cfdfa4f6fa9349fb90d48b0f1e6f040":["affd6585e0a92f8483e2f9dd579c1927505c7377"],"affd6585e0a92f8483e2f9dd579c1927505c7377":["d564e0296db7f80d73dd62b17710f61c85f38c50"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e456381ade0a256838cbf558702284e345c8d3d6"]},"commit2Childs":{"1cf8d8275024d808d6f5e5a1a07e8fa2b010706a":["d564e0296db7f80d73dd62b17710f61c85f38c50"],"8b879b14da40ab73551b75835099a61e622a83d3":["65d6841593942b33f59f72a2448d918225940311"],"1e7090fb56105afb6515b6506724359c32ec7639":["8b879b14da40ab73551b75835099a61e622a83d3"],"e456381ade0a256838cbf558702284e345c8d3d6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d564e0296db7f80d73dd62b17710f61c85f38c50":["affd6585e0a92f8483e2f9dd579c1927505c7377"],"65d6841593942b33f59f72a2448d918225940311":["1cf8d8275024d808d6f5e5a1a07e8fa2b010706a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1e7090fb56105afb6515b6506724359c32ec7639"],"d1ddb4f16cfdfa4f6fa9349fb90d48b0f1e6f040":["e456381ade0a256838cbf558702284e345c8d3d6"],"affd6585e0a92f8483e2f9dd579c1927505c7377":["d1ddb4f16cfdfa4f6fa9349fb90d48b0f1e6f040"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}