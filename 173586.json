{"path":"lucene/spatial/src/java/org/apache/lucene/spatial/vector/DistanceValueSource#getValues(Map,AtomicReaderContext).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/vector/DistanceValueSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"modules/spatial/src/java/org/apache/lucene/spatial/vector/DistanceValueSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  /**\n   * Returns the FunctionValues used by the function query.\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n\n    final double[] ptX = FieldCache.DEFAULT.getDoubles(reader, fields.getFieldNameX(), true);\n    final double[] ptY = FieldCache.DEFAULT.getDoubles(reader, fields.getFieldNameY(), true);\n    final Bits validX =  FieldCache.DEFAULT.getDocsWithField(reader, fields.getFieldNameX());\n    final Bits validY =  FieldCache.DEFAULT.getDocsWithField(reader, fields.getFieldNameY());\n\n    return new FunctionValues() {\n      @Override\n      public float floatVal(int doc) {\n        return (float) doubleVal(doc);\n      }\n\n      @Override\n      public double doubleVal(int doc) {\n        // make sure it has minX and area\n        if (validX.get(doc) && validY.get(doc)) {\n          PointImpl pt = new PointImpl( ptX[doc],  ptY[doc] );\n          return calculator.distance(from, pt);\n        }\n        return 0;\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns the FunctionValues used by the function query.\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n\n    final double[] ptX = FieldCache.DEFAULT.getDoubles(reader, fields.getFieldNameX(), true);\n    final double[] ptY = FieldCache.DEFAULT.getDoubles(reader, fields.getFieldNameY(), true);\n    final Bits validX =  FieldCache.DEFAULT.getDocsWithField(reader, fields.getFieldNameX());\n    final Bits validY =  FieldCache.DEFAULT.getDocsWithField(reader, fields.getFieldNameY());\n\n    return new FunctionValues() {\n      @Override\n      public float floatVal(int doc) {\n        return (float) doubleVal(doc);\n      }\n\n      @Override\n      public double doubleVal(int doc) {\n        // make sure it has minX and area\n        if (validX.get(doc) && validY.get(doc)) {\n          PointImpl pt = new PointImpl( ptX[doc],  ptY[doc] );\n          return calculator.distance(from, pt);\n        }\n        return 0;\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9c327517edf97b94827c01757fbf21e0ca625eb7","date":1341211669,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/vector/DistanceValueSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/vector/DistanceValueSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  /**\n   * Returns the FunctionValues used by the function query.\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n\n    final double[] ptX = FieldCache.DEFAULT.getDoubles(reader, fields.getFieldNameX(), true);\n    final double[] ptY = FieldCache.DEFAULT.getDoubles(reader, fields.getFieldNameY(), true);\n    final Bits validX =  FieldCache.DEFAULT.getDocsWithField(reader, fields.getFieldNameX());\n    final Bits validY =  FieldCache.DEFAULT.getDocsWithField(reader, fields.getFieldNameY());\n\n    return new FunctionValues() {\n      @Override\n      public float floatVal(int doc) {\n        return (float) doubleVal(doc);\n      }\n\n      @Override\n      public double doubleVal(int doc) {\n        // make sure it has minX and area\n        if (validX.get(doc) && validY.get(doc)) {\n          return calculator.distance(from, ptX[doc], ptY[doc]);\n        }\n        return 0;\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns the FunctionValues used by the function query.\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n\n    final double[] ptX = FieldCache.DEFAULT.getDoubles(reader, fields.getFieldNameX(), true);\n    final double[] ptY = FieldCache.DEFAULT.getDoubles(reader, fields.getFieldNameY(), true);\n    final Bits validX =  FieldCache.DEFAULT.getDocsWithField(reader, fields.getFieldNameX());\n    final Bits validY =  FieldCache.DEFAULT.getDocsWithField(reader, fields.getFieldNameY());\n\n    return new FunctionValues() {\n      @Override\n      public float floatVal(int doc) {\n        return (float) doubleVal(doc);\n      }\n\n      @Override\n      public double doubleVal(int doc) {\n        // make sure it has minX and area\n        if (validX.get(doc) && validY.get(doc)) {\n          PointImpl pt = new PointImpl( ptX[doc],  ptY[doc] );\n          return calculator.distance(from, pt);\n        }\n        return 0;\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0415a016b37e58a017fed0a91234f733ab359971","date":1341458183,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/vector/DistanceValueSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/vector/DistanceValueSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  /**\n   * Returns the FunctionValues used by the function query.\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n\n    final double[] ptX = FieldCache.DEFAULT.getDoubles(reader, strategy.getFieldNameX(), true);\n    final double[] ptY = FieldCache.DEFAULT.getDoubles(reader, strategy.getFieldNameY(), true);\n    final Bits validX =  FieldCache.DEFAULT.getDocsWithField(reader, strategy.getFieldNameX());\n    final Bits validY =  FieldCache.DEFAULT.getDocsWithField(reader, strategy.getFieldNameY());\n\n    return new FunctionValues() {\n      @Override\n      public float floatVal(int doc) {\n        return (float) doubleVal(doc);\n      }\n\n      @Override\n      public double doubleVal(int doc) {\n        // make sure it has minX and area\n        if (validX.get(doc) && validY.get(doc)) {\n          return calculator.distance(from, ptX[doc], ptY[doc]);\n        }\n        return 0;\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns the FunctionValues used by the function query.\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n\n    final double[] ptX = FieldCache.DEFAULT.getDoubles(reader, fields.getFieldNameX(), true);\n    final double[] ptY = FieldCache.DEFAULT.getDoubles(reader, fields.getFieldNameY(), true);\n    final Bits validX =  FieldCache.DEFAULT.getDocsWithField(reader, fields.getFieldNameX());\n    final Bits validY =  FieldCache.DEFAULT.getDocsWithField(reader, fields.getFieldNameY());\n\n    return new FunctionValues() {\n      @Override\n      public float floatVal(int doc) {\n        return (float) doubleVal(doc);\n      }\n\n      @Override\n      public double doubleVal(int doc) {\n        // make sure it has minX and area\n        if (validX.get(doc) && validY.get(doc)) {\n          return calculator.distance(from, ptX[doc], ptY[doc]);\n        }\n        return 0;\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/vector/DistanceValueSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/vector/DistanceValueSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  /**\n   * Returns the FunctionValues used by the function query.\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n\n    final double[] ptX = FieldCache.DEFAULT.getDoubles(reader, strategy.getFieldNameX(), true);\n    final double[] ptY = FieldCache.DEFAULT.getDoubles(reader, strategy.getFieldNameY(), true);\n    final Bits validX =  FieldCache.DEFAULT.getDocsWithField(reader, strategy.getFieldNameX());\n    final Bits validY =  FieldCache.DEFAULT.getDocsWithField(reader, strategy.getFieldNameY());\n\n    return new FunctionValues() {\n      @Override\n      public float floatVal(int doc) {\n        return (float) doubleVal(doc);\n      }\n\n      @Override\n      public double doubleVal(int doc) {\n        // make sure it has minX and area\n        if (validX.get(doc) && validY.get(doc)) {\n          return calculator.distance(from, ptX[doc], ptY[doc]);\n        }\n        return 0;\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns the FunctionValues used by the function query.\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n\n    final double[] ptX = FieldCache.DEFAULT.getDoubles(reader, fields.getFieldNameX(), true);\n    final double[] ptY = FieldCache.DEFAULT.getDoubles(reader, fields.getFieldNameY(), true);\n    final Bits validX =  FieldCache.DEFAULT.getDocsWithField(reader, fields.getFieldNameX());\n    final Bits validY =  FieldCache.DEFAULT.getDocsWithField(reader, fields.getFieldNameY());\n\n    return new FunctionValues() {\n      @Override\n      public float floatVal(int doc) {\n        return (float) doubleVal(doc);\n      }\n\n      @Override\n      public double doubleVal(int doc) {\n        // make sure it has minX and area\n        if (validX.get(doc) && validY.get(doc)) {\n          PointImpl pt = new PointImpl( ptX[doc],  ptY[doc] );\n          return calculator.distance(from, pt);\n        }\n        return 0;\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28bce66b0b769a7827b1f4df30b3f50a2ed6c355","date":1347720564,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/vector/DistanceValueSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/vector/DistanceValueSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  /**\n   * Returns the FunctionValues used by the function query.\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n\n    final double[] ptX = FieldCache.DEFAULT.getDoubles(reader, strategy.getFieldNameX(), true);\n    final double[] ptY = FieldCache.DEFAULT.getDoubles(reader, strategy.getFieldNameY(), true);\n    final Bits validX =  FieldCache.DEFAULT.getDocsWithField(reader, strategy.getFieldNameX());\n    final Bits validY =  FieldCache.DEFAULT.getDocsWithField(reader, strategy.getFieldNameY());\n\n    return new FunctionValues() {\n\n      private final Point from = DistanceValueSource.this.from;\n      private final DistanceCalculator calculator = strategy.getSpatialContext().getDistCalc();\n      private final double nullValue = (strategy.getSpatialContext().isGeo() ? 180 : Double.MAX_VALUE);\n\n      @Override\n      public float floatVal(int doc) {\n        return (float) doubleVal(doc);\n      }\n\n      @Override\n      public double doubleVal(int doc) {\n        // make sure it has minX and area\n        if (validX.get(doc)) {\n          assert validY.get(doc);\n          return calculator.distance(from, ptX[doc], ptY[doc]);\n        }\n        return nullValue;\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns the FunctionValues used by the function query.\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n\n    final double[] ptX = FieldCache.DEFAULT.getDoubles(reader, strategy.getFieldNameX(), true);\n    final double[] ptY = FieldCache.DEFAULT.getDoubles(reader, strategy.getFieldNameY(), true);\n    final Bits validX =  FieldCache.DEFAULT.getDocsWithField(reader, strategy.getFieldNameX());\n    final Bits validY =  FieldCache.DEFAULT.getDocsWithField(reader, strategy.getFieldNameY());\n\n    return new FunctionValues() {\n      @Override\n      public float floatVal(int doc) {\n        return (float) doubleVal(doc);\n      }\n\n      @Override\n      public double doubleVal(int doc) {\n        // make sure it has minX and area\n        if (validX.get(doc) && validY.get(doc)) {\n          return calculator.distance(from, ptX[doc], ptY[doc]);\n        }\n        return 0;\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"34a3cb4eb36d5e20abde21f4d8fe5442588e7e03","date":1353235561,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/vector/DistanceValueSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/vector/DistanceValueSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  /**\n   * Returns the FunctionValues used by the function query.\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n\n    final FieldCache.Doubles ptX = FieldCache.DEFAULT.getDoubles(reader, strategy.getFieldNameX(), true);\n    final FieldCache.Doubles ptY = FieldCache.DEFAULT.getDoubles(reader, strategy.getFieldNameY(), true);\n    final Bits validX =  FieldCache.DEFAULT.getDocsWithField(reader, strategy.getFieldNameX());\n    final Bits validY =  FieldCache.DEFAULT.getDocsWithField(reader, strategy.getFieldNameY());\n\n    return new FunctionValues() {\n\n      private final Point from = DistanceValueSource.this.from;\n      private final DistanceCalculator calculator = strategy.getSpatialContext().getDistCalc();\n      private final double nullValue = (strategy.getSpatialContext().isGeo() ? 180 : Double.MAX_VALUE);\n\n      @Override\n      public float floatVal(int doc) {\n        return (float) doubleVal(doc);\n      }\n\n      @Override\n      public double doubleVal(int doc) {\n        // make sure it has minX and area\n        if (validX.get(doc)) {\n          assert validY.get(doc);\n          return calculator.distance(from, ptX.get(doc), ptY.get(doc));\n        }\n        return nullValue;\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns the FunctionValues used by the function query.\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n\n    final double[] ptX = FieldCache.DEFAULT.getDoubles(reader, strategy.getFieldNameX(), true);\n    final double[] ptY = FieldCache.DEFAULT.getDoubles(reader, strategy.getFieldNameY(), true);\n    final Bits validX =  FieldCache.DEFAULT.getDocsWithField(reader, strategy.getFieldNameX());\n    final Bits validY =  FieldCache.DEFAULT.getDocsWithField(reader, strategy.getFieldNameY());\n\n    return new FunctionValues() {\n\n      private final Point from = DistanceValueSource.this.from;\n      private final DistanceCalculator calculator = strategy.getSpatialContext().getDistCalc();\n      private final double nullValue = (strategy.getSpatialContext().isGeo() ? 180 : Double.MAX_VALUE);\n\n      @Override\n      public float floatVal(int doc) {\n        return (float) doubleVal(doc);\n      }\n\n      @Override\n      public double doubleVal(int doc) {\n        // make sure it has minX and area\n        if (validX.get(doc)) {\n          assert validY.get(doc);\n          return calculator.distance(from, ptX[doc], ptY[doc]);\n        }\n        return nullValue;\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/vector/DistanceValueSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/vector/DistanceValueSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  /**\n   * Returns the FunctionValues used by the function query.\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n\n    final FieldCache.Doubles ptX = FieldCache.DEFAULT.getDoubles(reader, strategy.getFieldNameX(), true);\n    final FieldCache.Doubles ptY = FieldCache.DEFAULT.getDoubles(reader, strategy.getFieldNameY(), true);\n    final Bits validX =  FieldCache.DEFAULT.getDocsWithField(reader, strategy.getFieldNameX());\n    final Bits validY =  FieldCache.DEFAULT.getDocsWithField(reader, strategy.getFieldNameY());\n\n    return new FunctionValues() {\n\n      private final Point from = DistanceValueSource.this.from;\n      private final DistanceCalculator calculator = strategy.getSpatialContext().getDistCalc();\n      private final double nullValue = (strategy.getSpatialContext().isGeo() ? 180 : Double.MAX_VALUE);\n\n      @Override\n      public float floatVal(int doc) {\n        return (float) doubleVal(doc);\n      }\n\n      @Override\n      public double doubleVal(int doc) {\n        // make sure it has minX and area\n        if (validX.get(doc)) {\n          assert validY.get(doc);\n          return calculator.distance(from, ptX.get(doc), ptY.get(doc));\n        }\n        return nullValue;\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns the FunctionValues used by the function query.\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n\n    final double[] ptX = FieldCache.DEFAULT.getDoubles(reader, strategy.getFieldNameX(), true);\n    final double[] ptY = FieldCache.DEFAULT.getDoubles(reader, strategy.getFieldNameY(), true);\n    final Bits validX =  FieldCache.DEFAULT.getDocsWithField(reader, strategy.getFieldNameX());\n    final Bits validY =  FieldCache.DEFAULT.getDocsWithField(reader, strategy.getFieldNameY());\n\n    return new FunctionValues() {\n\n      private final Point from = DistanceValueSource.this.from;\n      private final DistanceCalculator calculator = strategy.getSpatialContext().getDistCalc();\n      private final double nullValue = (strategy.getSpatialContext().isGeo() ? 180 : Double.MAX_VALUE);\n\n      @Override\n      public float floatVal(int doc) {\n        return (float) doubleVal(doc);\n      }\n\n      @Override\n      public double doubleVal(int doc) {\n        // make sure it has minX and area\n        if (validX.get(doc)) {\n          assert validY.get(doc);\n          return calculator.distance(from, ptX[doc], ptY[doc]);\n        }\n        return nullValue;\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","bugFix":["9c327517edf97b94827c01757fbf21e0ca625eb7","0415a016b37e58a017fed0a91234f733ab359971"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db81fe5f1911f062c87abbb053871c166d57d849","date":1374686410,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/vector/DistanceValueSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/vector/DistanceValueSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  /**\n   * Returns the FunctionValues used by the function query.\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n\n    final FieldCache.Doubles ptX = FieldCache.DEFAULT.getDoubles(reader, strategy.getFieldNameX(), true);\n    final FieldCache.Doubles ptY = FieldCache.DEFAULT.getDoubles(reader, strategy.getFieldNameY(), true);\n    final Bits validX =  FieldCache.DEFAULT.getDocsWithField(reader, strategy.getFieldNameX());\n    final Bits validY =  FieldCache.DEFAULT.getDocsWithField(reader, strategy.getFieldNameY());\n\n    return new FunctionValues() {\n\n      private final Point from = DistanceValueSource.this.from;\n      private final DistanceCalculator calculator = strategy.getSpatialContext().getDistCalc();\n      private final double nullValue =\n          (strategy.getSpatialContext().isGeo() ? 180 * multiplier : Double.MAX_VALUE);\n\n      @Override\n      public float floatVal(int doc) {\n        return (float) doubleVal(doc);\n      }\n\n      @Override\n      public double doubleVal(int doc) {\n        // make sure it has minX and area\n        if (validX.get(doc)) {\n          assert validY.get(doc);\n          return calculator.distance(from, ptX.get(doc), ptY.get(doc)) * multiplier;\n        }\n        return nullValue;\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns the FunctionValues used by the function query.\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n\n    final FieldCache.Doubles ptX = FieldCache.DEFAULT.getDoubles(reader, strategy.getFieldNameX(), true);\n    final FieldCache.Doubles ptY = FieldCache.DEFAULT.getDoubles(reader, strategy.getFieldNameY(), true);\n    final Bits validX =  FieldCache.DEFAULT.getDocsWithField(reader, strategy.getFieldNameX());\n    final Bits validY =  FieldCache.DEFAULT.getDocsWithField(reader, strategy.getFieldNameY());\n\n    return new FunctionValues() {\n\n      private final Point from = DistanceValueSource.this.from;\n      private final DistanceCalculator calculator = strategy.getSpatialContext().getDistCalc();\n      private final double nullValue = (strategy.getSpatialContext().isGeo() ? 180 : Double.MAX_VALUE);\n\n      @Override\n      public float floatVal(int doc) {\n        return (float) doubleVal(doc);\n      }\n\n      @Override\n      public double doubleVal(int doc) {\n        // make sure it has minX and area\n        if (validX.get(doc)) {\n          assert validY.get(doc);\n          return calculator.distance(from, ptX.get(doc), ptY.get(doc));\n        }\n        return nullValue;\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/vector/DistanceValueSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/vector/DistanceValueSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  /**\n   * Returns the FunctionValues used by the function query.\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n\n    final FieldCache.Doubles ptX = FieldCache.DEFAULT.getDoubles(reader, strategy.getFieldNameX(), true);\n    final FieldCache.Doubles ptY = FieldCache.DEFAULT.getDoubles(reader, strategy.getFieldNameY(), true);\n    final Bits validX =  FieldCache.DEFAULT.getDocsWithField(reader, strategy.getFieldNameX());\n    final Bits validY =  FieldCache.DEFAULT.getDocsWithField(reader, strategy.getFieldNameY());\n\n    return new FunctionValues() {\n\n      private final Point from = DistanceValueSource.this.from;\n      private final DistanceCalculator calculator = strategy.getSpatialContext().getDistCalc();\n      private final double nullValue =\n          (strategy.getSpatialContext().isGeo() ? 180 * multiplier : Double.MAX_VALUE);\n\n      @Override\n      public float floatVal(int doc) {\n        return (float) doubleVal(doc);\n      }\n\n      @Override\n      public double doubleVal(int doc) {\n        // make sure it has minX and area\n        if (validX.get(doc)) {\n          assert validY.get(doc);\n          return calculator.distance(from, ptX.get(doc), ptY.get(doc)) * multiplier;\n        }\n        return nullValue;\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns the FunctionValues used by the function query.\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n\n    final FieldCache.Doubles ptX = FieldCache.DEFAULT.getDoubles(reader, strategy.getFieldNameX(), true);\n    final FieldCache.Doubles ptY = FieldCache.DEFAULT.getDoubles(reader, strategy.getFieldNameY(), true);\n    final Bits validX =  FieldCache.DEFAULT.getDocsWithField(reader, strategy.getFieldNameX());\n    final Bits validY =  FieldCache.DEFAULT.getDocsWithField(reader, strategy.getFieldNameY());\n\n    return new FunctionValues() {\n\n      private final Point from = DistanceValueSource.this.from;\n      private final DistanceCalculator calculator = strategy.getSpatialContext().getDistCalc();\n      private final double nullValue = (strategy.getSpatialContext().isGeo() ? 180 : Double.MAX_VALUE);\n\n      @Override\n      public float floatVal(int doc) {\n        return (float) doubleVal(doc);\n      }\n\n      @Override\n      public double doubleVal(int doc) {\n        // make sure it has minX and area\n        if (validX.get(doc)) {\n          assert validY.get(doc);\n          return calculator.distance(from, ptX.get(doc), ptY.get(doc));\n        }\n        return nullValue;\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c","date":1399816179,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/vector/DistanceValueSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/vector/DistanceValueSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  /**\n   * Returns the FunctionValues used by the function query.\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n\n    final NumericDocValues ptX = DocValues.getNumeric(reader, strategy.getFieldNameX());\n    final NumericDocValues ptY = DocValues.getNumeric(reader, strategy.getFieldNameY());\n    final Bits validX =  DocValues.getDocsWithField(reader, strategy.getFieldNameX());\n    final Bits validY =  DocValues.getDocsWithField(reader, strategy.getFieldNameY());\n\n    return new FunctionValues() {\n\n      private final Point from = DistanceValueSource.this.from;\n      private final DistanceCalculator calculator = strategy.getSpatialContext().getDistCalc();\n      private final double nullValue =\n          (strategy.getSpatialContext().isGeo() ? 180 * multiplier : Double.MAX_VALUE);\n\n      @Override\n      public float floatVal(int doc) {\n        return (float) doubleVal(doc);\n      }\n\n      @Override\n      public double doubleVal(int doc) {\n        // make sure it has minX and area\n        if (validX.get(doc)) {\n          assert validY.get(doc);\n          return calculator.distance(from, Double.longBitsToDouble(ptX.get(doc)), Double.longBitsToDouble(ptY.get(doc))) * multiplier;\n        }\n        return nullValue;\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns the FunctionValues used by the function query.\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n\n    final FieldCache.Doubles ptX = FieldCache.DEFAULT.getDoubles(reader, strategy.getFieldNameX(), true);\n    final FieldCache.Doubles ptY = FieldCache.DEFAULT.getDoubles(reader, strategy.getFieldNameY(), true);\n    final Bits validX =  FieldCache.DEFAULT.getDocsWithField(reader, strategy.getFieldNameX());\n    final Bits validY =  FieldCache.DEFAULT.getDocsWithField(reader, strategy.getFieldNameY());\n\n    return new FunctionValues() {\n\n      private final Point from = DistanceValueSource.this.from;\n      private final DistanceCalculator calculator = strategy.getSpatialContext().getDistCalc();\n      private final double nullValue =\n          (strategy.getSpatialContext().isGeo() ? 180 * multiplier : Double.MAX_VALUE);\n\n      @Override\n      public float floatVal(int doc) {\n        return (float) doubleVal(doc);\n      }\n\n      @Override\n      public double doubleVal(int doc) {\n        // make sure it has minX and area\n        if (validX.get(doc)) {\n          assert validY.get(doc);\n          return calculator.distance(from, ptX.get(doc), ptY.get(doc)) * multiplier;\n        }\n        return nullValue;\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93dd449115a9247533e44bab47e8429e5dccbc6d","date":1400258396,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/vector/DistanceValueSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/vector/DistanceValueSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  /**\n   * Returns the FunctionValues used by the function query.\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n\n    final NumericDocValues ptX = DocValues.getNumeric(reader, strategy.getFieldNameX());\n    final NumericDocValues ptY = DocValues.getNumeric(reader, strategy.getFieldNameY());\n    final Bits validX =  DocValues.getDocsWithField(reader, strategy.getFieldNameX());\n    final Bits validY =  DocValues.getDocsWithField(reader, strategy.getFieldNameY());\n\n    return new FunctionValues() {\n\n      private final Point from = DistanceValueSource.this.from;\n      private final DistanceCalculator calculator = strategy.getSpatialContext().getDistCalc();\n      private final double nullValue =\n          (strategy.getSpatialContext().isGeo() ? 180 * multiplier : Double.MAX_VALUE);\n\n      @Override\n      public float floatVal(int doc) {\n        return (float) doubleVal(doc);\n      }\n\n      @Override\n      public double doubleVal(int doc) {\n        // make sure it has minX and area\n        if (validX.get(doc)) {\n          assert validY.get(doc);\n          return calculator.distance(from, Double.longBitsToDouble(ptX.get(doc)), Double.longBitsToDouble(ptY.get(doc))) * multiplier;\n        }\n        return nullValue;\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns the FunctionValues used by the function query.\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n\n    final FieldCache.Doubles ptX = FieldCache.DEFAULT.getDoubles(reader, strategy.getFieldNameX(), true);\n    final FieldCache.Doubles ptY = FieldCache.DEFAULT.getDoubles(reader, strategy.getFieldNameY(), true);\n    final Bits validX =  FieldCache.DEFAULT.getDocsWithField(reader, strategy.getFieldNameX());\n    final Bits validY =  FieldCache.DEFAULT.getDocsWithField(reader, strategy.getFieldNameY());\n\n    return new FunctionValues() {\n\n      private final Point from = DistanceValueSource.this.from;\n      private final DistanceCalculator calculator = strategy.getSpatialContext().getDistCalc();\n      private final double nullValue =\n          (strategy.getSpatialContext().isGeo() ? 180 * multiplier : Double.MAX_VALUE);\n\n      @Override\n      public float floatVal(int doc) {\n        return (float) doubleVal(doc);\n      }\n\n      @Override\n      public double doubleVal(int doc) {\n        // make sure it has minX and area\n        if (validX.get(doc)) {\n          assert validY.get(doc);\n          return calculator.distance(from, ptX.get(doc), ptY.get(doc)) * multiplier;\n        }\n        return nullValue;\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/vector/DistanceValueSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/vector/DistanceValueSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  /**\n   * Returns the FunctionValues used by the function query.\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n\n    final NumericDocValues ptX = DocValues.getNumeric(reader, strategy.getFieldNameX());\n    final NumericDocValues ptY = DocValues.getNumeric(reader, strategy.getFieldNameY());\n    final Bits validX =  DocValues.getDocsWithField(reader, strategy.getFieldNameX());\n    final Bits validY =  DocValues.getDocsWithField(reader, strategy.getFieldNameY());\n\n    return new FunctionValues() {\n\n      private final Point from = DistanceValueSource.this.from;\n      private final DistanceCalculator calculator = strategy.getSpatialContext().getDistCalc();\n      private final double nullValue =\n          (strategy.getSpatialContext().isGeo() ? 180 * multiplier : Double.MAX_VALUE);\n\n      @Override\n      public float floatVal(int doc) {\n        return (float) doubleVal(doc);\n      }\n\n      @Override\n      public double doubleVal(int doc) {\n        // make sure it has minX and area\n        if (validX.get(doc)) {\n          assert validY.get(doc);\n          return calculator.distance(from, Double.longBitsToDouble(ptX.get(doc)), Double.longBitsToDouble(ptY.get(doc))) * multiplier;\n        }\n        return nullValue;\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns the FunctionValues used by the function query.\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n\n    final FieldCache.Doubles ptX = FieldCache.DEFAULT.getDoubles(reader, strategy.getFieldNameX(), true);\n    final FieldCache.Doubles ptY = FieldCache.DEFAULT.getDoubles(reader, strategy.getFieldNameY(), true);\n    final Bits validX =  FieldCache.DEFAULT.getDocsWithField(reader, strategy.getFieldNameX());\n    final Bits validY =  FieldCache.DEFAULT.getDocsWithField(reader, strategy.getFieldNameY());\n\n    return new FunctionValues() {\n\n      private final Point from = DistanceValueSource.this.from;\n      private final DistanceCalculator calculator = strategy.getSpatialContext().getDistCalc();\n      private final double nullValue =\n          (strategy.getSpatialContext().isGeo() ? 180 * multiplier : Double.MAX_VALUE);\n\n      @Override\n      public float floatVal(int doc) {\n        return (float) doubleVal(doc);\n      }\n\n      @Override\n      public double doubleVal(int doc) {\n        // make sure it has minX and area\n        if (validX.get(doc)) {\n          assert validY.get(doc);\n          return calculator.distance(from, ptX.get(doc), ptY.get(doc)) * multiplier;\n        }\n        return nullValue;\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":4,"author":"Ryan Ernst","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/vector/DistanceValueSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":null,"sourceOld":"  /**\n   * Returns the FunctionValues used by the function query.\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n\n    final NumericDocValues ptX = DocValues.getNumeric(reader, strategy.getFieldNameX());\n    final NumericDocValues ptY = DocValues.getNumeric(reader, strategy.getFieldNameY());\n    final Bits validX =  DocValues.getDocsWithField(reader, strategy.getFieldNameX());\n    final Bits validY =  DocValues.getDocsWithField(reader, strategy.getFieldNameY());\n\n    return new FunctionValues() {\n\n      private final Point from = DistanceValueSource.this.from;\n      private final DistanceCalculator calculator = strategy.getSpatialContext().getDistCalc();\n      private final double nullValue =\n          (strategy.getSpatialContext().isGeo() ? 180 * multiplier : Double.MAX_VALUE);\n\n      @Override\n      public float floatVal(int doc) {\n        return (float) doubleVal(doc);\n      }\n\n      @Override\n      public double doubleVal(int doc) {\n        // make sure it has minX and area\n        if (validX.get(doc)) {\n          assert validY.get(doc);\n          return calculator.distance(from, Double.longBitsToDouble(ptX.get(doc)), Double.longBitsToDouble(ptY.get(doc))) * multiplier;\n        }\n        return nullValue;\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0415a016b37e58a017fed0a91234f733ab359971":["9c327517edf97b94827c01757fbf21e0ca625eb7"],"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c":["db81fe5f1911f062c87abbb053871c166d57d849"],"56572ec06f1407c066d6b7399413178b33176cd8":["db81fe5f1911f062c87abbb053871c166d57d849","93dd449115a9247533e44bab47e8429e5dccbc6d"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9c327517edf97b94827c01757fbf21e0ca625eb7":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["28bce66b0b769a7827b1f4df30b3f50a2ed6c355","34a3cb4eb36d5e20abde21f4d8fe5442588e7e03"],"34a3cb4eb36d5e20abde21f4d8fe5442588e7e03":["28bce66b0b769a7827b1f4df30b3f50a2ed6c355"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["db81fe5f1911f062c87abbb053871c166d57d849","b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["b89678825b68eccaf09e6ab71675fc0b0af1e099","0415a016b37e58a017fed0a91234f733ab359971"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"28bce66b0b769a7827b1f4df30b3f50a2ed6c355":["0415a016b37e58a017fed0a91234f733ab359971"],"db81fe5f1911f062c87abbb053871c166d57d849":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c9fb5f46e264daf5ba3860defe623a89d202dd87"]},"commit2Childs":{"0415a016b37e58a017fed0a91234f733ab359971":["fe33227f6805edab2036cbb80645cc4e2d1fa424","28bce66b0b769a7827b1f4df30b3f50a2ed6c355"],"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"56572ec06f1407c066d6b7399413178b33176cd8":[],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["9c327517edf97b94827c01757fbf21e0ca625eb7","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"9c327517edf97b94827c01757fbf21e0ca625eb7":["0415a016b37e58a017fed0a91234f733ab359971"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","db81fe5f1911f062c87abbb053871c166d57d849"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["56572ec06f1407c066d6b7399413178b33176cd8","c9fb5f46e264daf5ba3860defe623a89d202dd87"],"34a3cb4eb36d5e20abde21f4d8fe5442588e7e03":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"28bce66b0b769a7827b1f4df30b3f50a2ed6c355":["d4d69c535930b5cce125cff868d40f6373dc27d4","34a3cb4eb36d5e20abde21f4d8fe5442588e7e03"],"db81fe5f1911f062c87abbb053871c166d57d849":["b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c","56572ec06f1407c066d6b7399413178b33176cd8","93dd449115a9247533e44bab47e8429e5dccbc6d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["56572ec06f1407c066d6b7399413178b33176cd8","fe33227f6805edab2036cbb80645cc4e2d1fa424","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}