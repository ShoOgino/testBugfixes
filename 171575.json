{"path":"solr/core/src/test/org/apache/solr/search/facet/SpatialHeatmapFacetsTest#testJsonFacets().mjava","commits":[{"id":"2ab027bdfe663227636ccbeda13ae82add302939","date":1529980633,"type":0,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/SpatialHeatmapFacetsTest#testJsonFacets().mjava","pathOld":"/dev/null","sourceNew":"  /** Tests JSON Facet module implementation of heatmaps. */\n  @SuppressWarnings(\"unchecked\")\n  @Test\n  public void testJsonFacets() throws Exception {\n    /*\n    THIS IS THE MOSTLY SAME CODE as above with tweaks to request it using the JSON Facet approach.\n      Near-duplication is sad; not clear if one test doing both is better -- would be awkward\n     */\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrParams baseParams = params(\"q\", \"*:*\", \"rows\", \"0\");\n\n    final String testBox = \"[\\\"50 50\\\" TO \\\"180 90\\\"]\";//top-right somewhere on edge (whatever)\n\n    // ------ Index data\n\n    index(\"id\", \"0\", FIELD, \"ENVELOPE(100, 120, 80, 40)\");// on right side\n    index(\"id\", \"1\", FIELD, \"ENVELOPE(-120, -110, 80, 20)\");// on left side (outside heatmap)\n    index(\"id\", \"3\", FIELD, \"POINT(70 60)\");//just left of BOX 0\n    index(\"id\", \"4\", FIELD, \"POINT(91 89)\");//just outside box 0 (above it) near pole,\n\n    commit();\n\n    //----- Test gridLevel derivation\n    try {\n      query(params(baseParams, \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'\" + testBox + \"', distErr:0}}\"));\n      fail();\n    } catch (SolrException e) {\n      assertEquals(SolrException.ErrorCode.BAD_REQUEST.code, e.code());\n    }\n    try {\n      query(params(baseParams, \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'\" + testBox + \"', distErrPct:0}}\"));\n      fail();\n    } catch (SolrException e) {\n      assertEquals(SolrException.ErrorCode.BAD_REQUEST.code, e.code());\n    }\n    // Monkeying with these params changes the gridLevel in different directions. We don't test the exact\n    // computation here; that's not _that_ relevant, and is Lucene spatial's job (not Solr) any way.\n    assertEquals(7, getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'\" + testBox + \"'}}\"))).get(\"gridLevel\"));//default\n    assertEquals(3, getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'\" + testBox + \"', gridLevel:3}}\"))).get(\"gridLevel\"));\n    assertEquals(2, getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'\" + testBox + \"', distErr:100}}\"))).get(\"gridLevel\"));\n    //TODO test impact of distance units\n    assertEquals(9, getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'\" + testBox + \"', distErrPct:0.05}}\"))).get(\"gridLevel\"));\n    assertEquals(6, getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", distErrPct:0.10}}\"))).get(\"gridLevel\"));\n\n    // ----- Search\n    // this test simply has some 0's, nulls, 1's and a 2 in there.\n    NamedList hmObj = getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \" geom:'[\\\"50 20\\\" TO \\\"180 90\\\"]', gridLevel:4}}\")));\n    List<List<Integer>> counts = (List<List<Integer>>) hmObj.get(\"counts_ints2D\");\n    List<List<Integer>> expectedCounts1 = Arrays.asList(\n        Arrays.asList(0, 0, 2, 1, 0, 0),\n        Arrays.asList(0, 0, 1, 1, 0, 0),\n        Arrays.asList(0, 1, 1, 1, 0, 0),\n        Arrays.asList(0, 0, 1, 1, 0, 0),\n        Arrays.asList(0, 0, 1, 1, 0, 0),\n        null,\n        null\n    );\n    assertEquals( expectedCounts1, counts);\n\n    // now this time we add a filter query and exclude it\n    QueryResponse response = query(params(baseParams,\n        \"fq\", \"{!tag=excludeme}id:0\", // filter to only be id:0\n        \"json.facet\", \"{f1:{type:heatmap, excludeTags:['excludeme'], f:\" + FIELD + \", geom:'[\\\"50 20\\\" TO \\\"180 90\\\"]', gridLevel:4}}\"));\n\n    assertEquals(1, response.getResults().getNumFound());// because of our 'fq'\n    hmObj = getHmObj(response);\n    counts = (List<List<Integer>>) hmObj.get(\"counts_ints2D\");\n    assertEquals( expectedCounts1, counts);\n\n    {\n      // impractical example but nonetheless encloses the points of both doc3 and doc4 (both of which are points)\n      final String jsonHeatmap = \"facet:{hm:{type:heatmap, f:\" + FIELD + \", geom:'MULTIPOINT(70 60, 91 89)', distErrPct:0.2}}\";\n      response = query(params(baseParams,\n          \"json.facet\", \"{\" +\n              \"q1:{type:query, q:'id:3', \" + jsonHeatmap + \" }, \" +\n              \"q2:{type:query, q:'id:4', \" + jsonHeatmap + \" } \" +\n              \"}\"));\n      {\n        final NamedList q1Res = (NamedList) response.getResponse().findRecursive(\"facets\", \"q1\");\n        assertEquals(\"1\", q1Res.get(\"count\").toString());\n        final NamedList q2Res = (NamedList) response.getResponse().findRecursive(\"facets\", \"q2\");\n        assertEquals(\"1\", q2Res.get(\"count\").toString());\n        // essentially, these will differ only in the heatmap counts but otherwise will be the same\n        assertNotNull(compare(q1Res, q2Res, flags, handle));\n      }\n    }\n\n    // test using a circle input shape\n    hmObj = getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'BUFFER(POINT(110 40), 7)', gridLevel:7}}\")));\n    counts = (List<List<Integer>>) hmObj.get(\"counts_ints2D\");\n    assertEquals(\n        Arrays.asList(\n            Arrays.asList(0, 1, 1, 1, 1, 1, 1, 0),//curved; we have a 0\n            Arrays.asList(0, 1, 1, 1, 1, 1, 1, 0),//curved; we have a 0\n            Arrays.asList(0, 1, 1, 1, 1, 1, 1, 0),//curved; we have a 0\n            Arrays.asList(1, 1, 1, 1, 1, 1, 1, 1),\n            Arrays.asList(1, 1, 1, 1, 1, 1, 1, 1),\n            Arrays.asList(1, 1, 1, 1, 1, 1, 1, 1),\n            null, null, null, null, null//no data here (below edge of rect 0)\n        ),\n        counts\n    );\n\n    // Search in no-where ville and get null counts\n    assertNull(getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'ENVELOPE(0, 10, -80, -90)'}}\"))).get(\"counts_ints2D\"));\n\n    Object v = getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", format:png }}\"))).get(\"counts_png\");\n    assertTrue(v instanceof byte[]);\n    //simply test we can read the image\n    assertNotNull(FacetHeatmap.PngHelper.readImage((byte[]) v));\n    //good enough for this test method\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":0,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/SpatialHeatmapFacetsTest#testJsonFacets().mjava","pathOld":"/dev/null","sourceNew":"  /** Tests JSON Facet module implementation of heatmaps. */\n  @SuppressWarnings(\"unchecked\")\n  @Test\n  public void testJsonFacets() throws Exception {\n    /*\n    THIS IS THE MOSTLY SAME CODE as above with tweaks to request it using the JSON Facet approach.\n      Near-duplication is sad; not clear if one test doing both is better -- would be awkward\n     */\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrParams baseParams = params(\"q\", \"*:*\", \"rows\", \"0\");\n\n    final String testBox = \"[\\\"50 50\\\" TO \\\"180 90\\\"]\";//top-right somewhere on edge (whatever)\n\n    // ------ Index data\n\n    index(\"id\", \"0\", FIELD, \"ENVELOPE(100, 120, 80, 40)\");// on right side\n    index(\"id\", \"1\", FIELD, \"ENVELOPE(-120, -110, 80, 20)\");// on left side (outside heatmap)\n    index(\"id\", \"3\", FIELD, \"POINT(70 60)\");//just left of BOX 0\n    index(\"id\", \"4\", FIELD, \"POINT(91 89)\");//just outside box 0 (above it) near pole,\n\n    commit();\n\n    //----- Test gridLevel derivation\n    try {\n      query(params(baseParams, \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'\" + testBox + \"', distErr:0}}\"));\n      fail();\n    } catch (SolrException e) {\n      assertEquals(SolrException.ErrorCode.BAD_REQUEST.code, e.code());\n    }\n    try {\n      query(params(baseParams, \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'\" + testBox + \"', distErrPct:0}}\"));\n      fail();\n    } catch (SolrException e) {\n      assertEquals(SolrException.ErrorCode.BAD_REQUEST.code, e.code());\n    }\n    // Monkeying with these params changes the gridLevel in different directions. We don't test the exact\n    // computation here; that's not _that_ relevant, and is Lucene spatial's job (not Solr) any way.\n    assertEquals(7, getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'\" + testBox + \"'}}\"))).get(\"gridLevel\"));//default\n    assertEquals(3, getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'\" + testBox + \"', gridLevel:3}}\"))).get(\"gridLevel\"));\n    assertEquals(2, getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'\" + testBox + \"', distErr:100}}\"))).get(\"gridLevel\"));\n    //TODO test impact of distance units\n    assertEquals(9, getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'\" + testBox + \"', distErrPct:0.05}}\"))).get(\"gridLevel\"));\n    assertEquals(6, getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", distErrPct:0.10}}\"))).get(\"gridLevel\"));\n\n    // ----- Search\n    // this test simply has some 0's, nulls, 1's and a 2 in there.\n    NamedList hmObj = getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \" geom:'[\\\"50 20\\\" TO \\\"180 90\\\"]', gridLevel:4}}\")));\n    List<List<Integer>> counts = (List<List<Integer>>) hmObj.get(\"counts_ints2D\");\n    List<List<Integer>> expectedCounts1 = Arrays.asList(\n        Arrays.asList(0, 0, 2, 1, 0, 0),\n        Arrays.asList(0, 0, 1, 1, 0, 0),\n        Arrays.asList(0, 1, 1, 1, 0, 0),\n        Arrays.asList(0, 0, 1, 1, 0, 0),\n        Arrays.asList(0, 0, 1, 1, 0, 0),\n        null,\n        null\n    );\n    assertEquals( expectedCounts1, counts);\n\n    // now this time we add a filter query and exclude it\n    QueryResponse response = query(params(baseParams,\n        \"fq\", \"{!tag=excludeme}id:0\", // filter to only be id:0\n        \"json.facet\", \"{f1:{type:heatmap, excludeTags:['excludeme'], f:\" + FIELD + \", geom:'[\\\"50 20\\\" TO \\\"180 90\\\"]', gridLevel:4}}\"));\n\n    assertEquals(1, response.getResults().getNumFound());// because of our 'fq'\n    hmObj = getHmObj(response);\n    counts = (List<List<Integer>>) hmObj.get(\"counts_ints2D\");\n    assertEquals( expectedCounts1, counts);\n\n    {\n      // impractical example but nonetheless encloses the points of both doc3 and doc4 (both of which are points)\n      final String jsonHeatmap = \"facet:{hm:{type:heatmap, f:\" + FIELD + \", geom:'MULTIPOINT(70 60, 91 89)', distErrPct:0.2}}\";\n      response = query(params(baseParams,\n          \"json.facet\", \"{\" +\n              \"q1:{type:query, q:'id:3', \" + jsonHeatmap + \" }, \" +\n              \"q2:{type:query, q:'id:4', \" + jsonHeatmap + \" } \" +\n              \"}\"));\n      {\n        final NamedList q1Res = (NamedList) response.getResponse().findRecursive(\"facets\", \"q1\");\n        assertEquals(\"1\", q1Res.get(\"count\").toString());\n        final NamedList q2Res = (NamedList) response.getResponse().findRecursive(\"facets\", \"q2\");\n        assertEquals(\"1\", q2Res.get(\"count\").toString());\n        // essentially, these will differ only in the heatmap counts but otherwise will be the same\n        assertNotNull(compare(q1Res, q2Res, flags, handle));\n      }\n    }\n\n    // test using a circle input shape\n    hmObj = getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'BUFFER(POINT(110 40), 7)', gridLevel:7}}\")));\n    counts = (List<List<Integer>>) hmObj.get(\"counts_ints2D\");\n    assertEquals(\n        Arrays.asList(\n            Arrays.asList(0, 1, 1, 1, 1, 1, 1, 0),//curved; we have a 0\n            Arrays.asList(0, 1, 1, 1, 1, 1, 1, 0),//curved; we have a 0\n            Arrays.asList(0, 1, 1, 1, 1, 1, 1, 0),//curved; we have a 0\n            Arrays.asList(1, 1, 1, 1, 1, 1, 1, 1),\n            Arrays.asList(1, 1, 1, 1, 1, 1, 1, 1),\n            Arrays.asList(1, 1, 1, 1, 1, 1, 1, 1),\n            null, null, null, null, null//no data here (below edge of rect 0)\n        ),\n        counts\n    );\n\n    // Search in no-where ville and get null counts\n    assertNull(getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'ENVELOPE(0, 10, -80, -90)'}}\"))).get(\"counts_ints2D\"));\n\n    Object v = getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", format:png }}\"))).get(\"counts_png\");\n    assertTrue(v instanceof byte[]);\n    //simply test we can read the image\n    assertNotNull(FacetHeatmap.PngHelper.readImage((byte[]) v));\n    //good enough for this test method\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":0,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/SpatialHeatmapFacetsTest#testJsonFacets().mjava","pathOld":"/dev/null","sourceNew":"  /** Tests JSON Facet module implementation of heatmaps. */\n  @SuppressWarnings(\"unchecked\")\n  @Test\n  public void testJsonFacets() throws Exception {\n    /*\n    THIS IS THE MOSTLY SAME CODE as above with tweaks to request it using the JSON Facet approach.\n      Near-duplication is sad; not clear if one test doing both is better -- would be awkward\n     */\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrParams baseParams = params(\"q\", \"*:*\", \"rows\", \"0\");\n\n    final String testBox = \"[\\\"50 50\\\" TO \\\"180 90\\\"]\";//top-right somewhere on edge (whatever)\n\n    // ------ Index data\n\n    index(\"id\", \"0\", FIELD, \"ENVELOPE(100, 120, 80, 40)\");// on right side\n    index(\"id\", \"1\", FIELD, \"ENVELOPE(-120, -110, 80, 20)\");// on left side (outside heatmap)\n    index(\"id\", \"3\", FIELD, \"POINT(70 60)\");//just left of BOX 0\n    index(\"id\", \"4\", FIELD, \"POINT(91 89)\");//just outside box 0 (above it) near pole,\n\n    commit();\n\n    //----- Test gridLevel derivation\n    try {\n      query(params(baseParams, \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'\" + testBox + \"', distErr:0}}\"));\n      fail();\n    } catch (SolrException e) {\n      assertEquals(SolrException.ErrorCode.BAD_REQUEST.code, e.code());\n    }\n    try {\n      query(params(baseParams, \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'\" + testBox + \"', distErrPct:0}}\"));\n      fail();\n    } catch (SolrException e) {\n      assertEquals(SolrException.ErrorCode.BAD_REQUEST.code, e.code());\n    }\n    // Monkeying with these params changes the gridLevel in different directions. We don't test the exact\n    // computation here; that's not _that_ relevant, and is Lucene spatial's job (not Solr) any way.\n    assertEquals(7, getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'\" + testBox + \"'}}\"))).get(\"gridLevel\"));//default\n    assertEquals(3, getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'\" + testBox + \"', gridLevel:3}}\"))).get(\"gridLevel\"));\n    assertEquals(2, getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'\" + testBox + \"', distErr:100}}\"))).get(\"gridLevel\"));\n    //TODO test impact of distance units\n    assertEquals(9, getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'\" + testBox + \"', distErrPct:0.05}}\"))).get(\"gridLevel\"));\n    assertEquals(6, getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", distErrPct:0.10}}\"))).get(\"gridLevel\"));\n\n    // ----- Search\n    // this test simply has some 0's, nulls, 1's and a 2 in there.\n    NamedList hmObj = getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \" geom:'[\\\"50 20\\\" TO \\\"180 90\\\"]', gridLevel:4}}\")));\n    List<List<Integer>> counts = (List<List<Integer>>) hmObj.get(\"counts_ints2D\");\n    List<List<Integer>> expectedCounts1 = Arrays.asList(\n        Arrays.asList(0, 0, 2, 1, 0, 0),\n        Arrays.asList(0, 0, 1, 1, 0, 0),\n        Arrays.asList(0, 1, 1, 1, 0, 0),\n        Arrays.asList(0, 0, 1, 1, 0, 0),\n        Arrays.asList(0, 0, 1, 1, 0, 0),\n        null,\n        null\n    );\n    assertEquals( expectedCounts1, counts);\n\n    // now this time we add a filter query and exclude it\n    QueryResponse response = query(params(baseParams,\n        \"fq\", \"{!tag=excludeme}id:0\", // filter to only be id:0\n        \"json.facet\", \"{f1:{type:heatmap, excludeTags:['excludeme'], f:\" + FIELD + \", geom:'[\\\"50 20\\\" TO \\\"180 90\\\"]', gridLevel:4}}\"));\n\n    assertEquals(1, response.getResults().getNumFound());// because of our 'fq'\n    hmObj = getHmObj(response);\n    counts = (List<List<Integer>>) hmObj.get(\"counts_ints2D\");\n    assertEquals( expectedCounts1, counts);\n\n    {\n      // impractical example but nonetheless encloses the points of both doc3 and doc4 (both of which are points)\n      final String jsonHeatmap = \"facet:{hm:{type:heatmap, f:\" + FIELD + \", geom:'MULTIPOINT(70 60, 91 89)', distErrPct:0.2}}\";\n      response = query(params(baseParams,\n          \"json.facet\", \"{\" +\n              \"q1:{type:query, q:'id:3', \" + jsonHeatmap + \" }, \" +\n              \"q2:{type:query, q:'id:4', \" + jsonHeatmap + \" } \" +\n              \"}\"));\n      {\n        final NamedList q1Res = (NamedList) response.getResponse().findRecursive(\"facets\", \"q1\");\n        assertEquals(\"1\", q1Res.get(\"count\").toString());\n        final NamedList q2Res = (NamedList) response.getResponse().findRecursive(\"facets\", \"q2\");\n        assertEquals(\"1\", q2Res.get(\"count\").toString());\n        // essentially, these will differ only in the heatmap counts but otherwise will be the same\n        assertNotNull(compare(q1Res, q2Res, flags, handle));\n      }\n    }\n\n    // test using a circle input shape\n    hmObj = getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'BUFFER(POINT(110 40), 7)', gridLevel:7}}\")));\n    counts = (List<List<Integer>>) hmObj.get(\"counts_ints2D\");\n    assertEquals(\n        Arrays.asList(\n            Arrays.asList(0, 1, 1, 1, 1, 1, 1, 0),//curved; we have a 0\n            Arrays.asList(0, 1, 1, 1, 1, 1, 1, 0),//curved; we have a 0\n            Arrays.asList(0, 1, 1, 1, 1, 1, 1, 0),//curved; we have a 0\n            Arrays.asList(1, 1, 1, 1, 1, 1, 1, 1),\n            Arrays.asList(1, 1, 1, 1, 1, 1, 1, 1),\n            Arrays.asList(1, 1, 1, 1, 1, 1, 1, 1),\n            null, null, null, null, null//no data here (below edge of rect 0)\n        ),\n        counts\n    );\n\n    // Search in no-where ville and get null counts\n    assertNull(getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'ENVELOPE(0, 10, -80, -90)'}}\"))).get(\"counts_ints2D\"));\n\n    Object v = getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", format:png }}\"))).get(\"counts_png\");\n    assertTrue(v instanceof byte[]);\n    //simply test we can read the image\n    assertNotNull(FacetHeatmap.PngHelper.readImage((byte[]) v));\n    //good enough for this test method\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e98520789adb1d5ad05afb4956eca0944a929688","date":1592430701,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/SpatialHeatmapFacetsTest#testJsonFacets().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/SpatialHeatmapFacetsTest#testJsonFacets().mjava","sourceNew":"  /** Tests JSON Facet module implementation of heatmaps. */\n  @SuppressWarnings(\"unchecked\")\n  @Test\n  public void testJsonFacets() throws Exception {\n    /*\n    THIS IS THE MOSTLY SAME CODE as above with tweaks to request it using the JSON Facet approach.\n      Near-duplication is sad; not clear if one test doing both is better -- would be awkward\n     */\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrParams baseParams = params(\"q\", \"*:*\", \"rows\", \"0\");\n\n    final String testBox = \"[\\\"50 50\\\" TO \\\"180 90\\\"]\";//top-right somewhere on edge (whatever)\n\n    // ------ Index data\n\n    index(\"id\", \"0\", FIELD, \"ENVELOPE(100, 120, 80, 40)\");// on right side\n    index(\"id\", \"1\", FIELD, \"ENVELOPE(-120, -110, 80, 20)\");// on left side (outside heatmap)\n    index(\"id\", \"3\", FIELD, \"POINT(70 60)\");//just left of BOX 0\n    index(\"id\", \"4\", FIELD, \"POINT(91 89)\");//just outside box 0 (above it) near pole,\n\n    commit();\n\n    //----- Test gridLevel derivation\n    try {\n      query(params(baseParams, \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'\" + testBox + \"', distErr:0}}\"));\n      fail();\n    } catch (SolrException e) {\n      assertEquals(SolrException.ErrorCode.BAD_REQUEST.code, e.code());\n    }\n    try {\n      query(params(baseParams, \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'\" + testBox + \"', distErrPct:0}}\"));\n      fail();\n    } catch (SolrException e) {\n      assertEquals(SolrException.ErrorCode.BAD_REQUEST.code, e.code());\n    }\n    // Monkeying with these params changes the gridLevel in different directions. We don't test the exact\n    // computation here; that's not _that_ relevant, and is Lucene spatial's job (not Solr) any way.\n    assertEquals(7, getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'\" + testBox + \"'}}\"))).get(\"gridLevel\"));//default\n    assertEquals(3, getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'\" + testBox + \"', gridLevel:3}}\"))).get(\"gridLevel\"));\n    assertEquals(2, getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'\" + testBox + \"', distErr:100}}\"))).get(\"gridLevel\"));\n    //TODO test impact of distance units\n    assertEquals(9, getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'\" + testBox + \"', distErrPct:0.05}}\"))).get(\"gridLevel\"));\n    assertEquals(6, getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", distErrPct:0.10}}\"))).get(\"gridLevel\"));\n\n    // ----- Search\n    // this test simply has some 0's, nulls, 1's and a 2 in there.\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList hmObj = getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \" geom:'[\\\"50 20\\\" TO \\\"180 90\\\"]', gridLevel:4}}\")));\n    List<List<Integer>> counts = (List<List<Integer>>) hmObj.get(\"counts_ints2D\");\n    List<List<Integer>> expectedCounts1 = Arrays.asList(\n        Arrays.asList(0, 0, 2, 1, 0, 0),\n        Arrays.asList(0, 0, 1, 1, 0, 0),\n        Arrays.asList(0, 1, 1, 1, 0, 0),\n        Arrays.asList(0, 0, 1, 1, 0, 0),\n        Arrays.asList(0, 0, 1, 1, 0, 0),\n        null,\n        null\n    );\n    assertEquals( expectedCounts1, counts);\n\n    // now this time we add a filter query and exclude it\n    QueryResponse response = query(params(baseParams,\n        \"fq\", \"{!tag=excludeme}id:0\", // filter to only be id:0\n        \"json.facet\", \"{f1:{type:heatmap, excludeTags:['excludeme'], f:\" + FIELD + \", geom:'[\\\"50 20\\\" TO \\\"180 90\\\"]', gridLevel:4}}\"));\n\n    assertEquals(1, response.getResults().getNumFound());// because of our 'fq'\n    hmObj = getHmObj(response);\n    counts = (List<List<Integer>>) hmObj.get(\"counts_ints2D\");\n    assertEquals( expectedCounts1, counts);\n\n    {\n      // impractical example but nonetheless encloses the points of both doc3 and doc4 (both of which are points)\n      final String jsonHeatmap = \"facet:{hm:{type:heatmap, f:\" + FIELD + \", geom:'MULTIPOINT(70 60, 91 89)', distErrPct:0.2}}\";\n      response = query(params(baseParams,\n          \"json.facet\", \"{\" +\n              \"q1:{type:query, q:'id:3', \" + jsonHeatmap + \" }, \" +\n              \"q2:{type:query, q:'id:4', \" + jsonHeatmap + \" } \" +\n              \"}\"));\n      {\n        @SuppressWarnings({\"rawtypes\"})\n        final NamedList q1Res = (NamedList) response.getResponse().findRecursive(\"facets\", \"q1\");\n        assertEquals(\"1\", q1Res.get(\"count\").toString());\n        @SuppressWarnings({\"rawtypes\"})\n        final NamedList q2Res = (NamedList) response.getResponse().findRecursive(\"facets\", \"q2\");\n        assertEquals(\"1\", q2Res.get(\"count\").toString());\n        // essentially, these will differ only in the heatmap counts but otherwise will be the same\n        assertNotNull(compare(q1Res, q2Res, flags, handle));\n      }\n    }\n\n    // test using a circle input shape\n    hmObj = getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'BUFFER(POINT(110 40), 7)', gridLevel:7}}\")));\n    counts = (List<List<Integer>>) hmObj.get(\"counts_ints2D\");\n    assertEquals(\n        Arrays.asList(\n            Arrays.asList(0, 1, 1, 1, 1, 1, 1, 0),//curved; we have a 0\n            Arrays.asList(0, 1, 1, 1, 1, 1, 1, 0),//curved; we have a 0\n            Arrays.asList(0, 1, 1, 1, 1, 1, 1, 0),//curved; we have a 0\n            Arrays.asList(1, 1, 1, 1, 1, 1, 1, 1),\n            Arrays.asList(1, 1, 1, 1, 1, 1, 1, 1),\n            Arrays.asList(1, 1, 1, 1, 1, 1, 1, 1),\n            null, null, null, null, null//no data here (below edge of rect 0)\n        ),\n        counts\n    );\n\n    // Search in no-where ville and get null counts\n    assertNull(getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'ENVELOPE(0, 10, -80, -90)'}}\"))).get(\"counts_ints2D\"));\n\n    Object v = getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", format:png }}\"))).get(\"counts_png\");\n    assertTrue(v instanceof byte[]);\n    //simply test we can read the image\n    assertNotNull(FacetHeatmap.PngHelper.readImage((byte[]) v));\n    //good enough for this test method\n  }\n\n","sourceOld":"  /** Tests JSON Facet module implementation of heatmaps. */\n  @SuppressWarnings(\"unchecked\")\n  @Test\n  public void testJsonFacets() throws Exception {\n    /*\n    THIS IS THE MOSTLY SAME CODE as above with tweaks to request it using the JSON Facet approach.\n      Near-duplication is sad; not clear if one test doing both is better -- would be awkward\n     */\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrParams baseParams = params(\"q\", \"*:*\", \"rows\", \"0\");\n\n    final String testBox = \"[\\\"50 50\\\" TO \\\"180 90\\\"]\";//top-right somewhere on edge (whatever)\n\n    // ------ Index data\n\n    index(\"id\", \"0\", FIELD, \"ENVELOPE(100, 120, 80, 40)\");// on right side\n    index(\"id\", \"1\", FIELD, \"ENVELOPE(-120, -110, 80, 20)\");// on left side (outside heatmap)\n    index(\"id\", \"3\", FIELD, \"POINT(70 60)\");//just left of BOX 0\n    index(\"id\", \"4\", FIELD, \"POINT(91 89)\");//just outside box 0 (above it) near pole,\n\n    commit();\n\n    //----- Test gridLevel derivation\n    try {\n      query(params(baseParams, \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'\" + testBox + \"', distErr:0}}\"));\n      fail();\n    } catch (SolrException e) {\n      assertEquals(SolrException.ErrorCode.BAD_REQUEST.code, e.code());\n    }\n    try {\n      query(params(baseParams, \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'\" + testBox + \"', distErrPct:0}}\"));\n      fail();\n    } catch (SolrException e) {\n      assertEquals(SolrException.ErrorCode.BAD_REQUEST.code, e.code());\n    }\n    // Monkeying with these params changes the gridLevel in different directions. We don't test the exact\n    // computation here; that's not _that_ relevant, and is Lucene spatial's job (not Solr) any way.\n    assertEquals(7, getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'\" + testBox + \"'}}\"))).get(\"gridLevel\"));//default\n    assertEquals(3, getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'\" + testBox + \"', gridLevel:3}}\"))).get(\"gridLevel\"));\n    assertEquals(2, getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'\" + testBox + \"', distErr:100}}\"))).get(\"gridLevel\"));\n    //TODO test impact of distance units\n    assertEquals(9, getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'\" + testBox + \"', distErrPct:0.05}}\"))).get(\"gridLevel\"));\n    assertEquals(6, getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", distErrPct:0.10}}\"))).get(\"gridLevel\"));\n\n    // ----- Search\n    // this test simply has some 0's, nulls, 1's and a 2 in there.\n    NamedList hmObj = getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \" geom:'[\\\"50 20\\\" TO \\\"180 90\\\"]', gridLevel:4}}\")));\n    List<List<Integer>> counts = (List<List<Integer>>) hmObj.get(\"counts_ints2D\");\n    List<List<Integer>> expectedCounts1 = Arrays.asList(\n        Arrays.asList(0, 0, 2, 1, 0, 0),\n        Arrays.asList(0, 0, 1, 1, 0, 0),\n        Arrays.asList(0, 1, 1, 1, 0, 0),\n        Arrays.asList(0, 0, 1, 1, 0, 0),\n        Arrays.asList(0, 0, 1, 1, 0, 0),\n        null,\n        null\n    );\n    assertEquals( expectedCounts1, counts);\n\n    // now this time we add a filter query and exclude it\n    QueryResponse response = query(params(baseParams,\n        \"fq\", \"{!tag=excludeme}id:0\", // filter to only be id:0\n        \"json.facet\", \"{f1:{type:heatmap, excludeTags:['excludeme'], f:\" + FIELD + \", geom:'[\\\"50 20\\\" TO \\\"180 90\\\"]', gridLevel:4}}\"));\n\n    assertEquals(1, response.getResults().getNumFound());// because of our 'fq'\n    hmObj = getHmObj(response);\n    counts = (List<List<Integer>>) hmObj.get(\"counts_ints2D\");\n    assertEquals( expectedCounts1, counts);\n\n    {\n      // impractical example but nonetheless encloses the points of both doc3 and doc4 (both of which are points)\n      final String jsonHeatmap = \"facet:{hm:{type:heatmap, f:\" + FIELD + \", geom:'MULTIPOINT(70 60, 91 89)', distErrPct:0.2}}\";\n      response = query(params(baseParams,\n          \"json.facet\", \"{\" +\n              \"q1:{type:query, q:'id:3', \" + jsonHeatmap + \" }, \" +\n              \"q2:{type:query, q:'id:4', \" + jsonHeatmap + \" } \" +\n              \"}\"));\n      {\n        final NamedList q1Res = (NamedList) response.getResponse().findRecursive(\"facets\", \"q1\");\n        assertEquals(\"1\", q1Res.get(\"count\").toString());\n        final NamedList q2Res = (NamedList) response.getResponse().findRecursive(\"facets\", \"q2\");\n        assertEquals(\"1\", q2Res.get(\"count\").toString());\n        // essentially, these will differ only in the heatmap counts but otherwise will be the same\n        assertNotNull(compare(q1Res, q2Res, flags, handle));\n      }\n    }\n\n    // test using a circle input shape\n    hmObj = getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'BUFFER(POINT(110 40), 7)', gridLevel:7}}\")));\n    counts = (List<List<Integer>>) hmObj.get(\"counts_ints2D\");\n    assertEquals(\n        Arrays.asList(\n            Arrays.asList(0, 1, 1, 1, 1, 1, 1, 0),//curved; we have a 0\n            Arrays.asList(0, 1, 1, 1, 1, 1, 1, 0),//curved; we have a 0\n            Arrays.asList(0, 1, 1, 1, 1, 1, 1, 0),//curved; we have a 0\n            Arrays.asList(1, 1, 1, 1, 1, 1, 1, 1),\n            Arrays.asList(1, 1, 1, 1, 1, 1, 1, 1),\n            Arrays.asList(1, 1, 1, 1, 1, 1, 1, 1),\n            null, null, null, null, null//no data here (below edge of rect 0)\n        ),\n        counts\n    );\n\n    // Search in no-where ville and get null counts\n    assertNull(getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", geom:'ENVELOPE(0, 10, -80, -90)'}}\"))).get(\"counts_ints2D\"));\n\n    Object v = getHmObj(query(params(baseParams,\n        \"json.facet\", \"{f1:{type:heatmap, f:\" + FIELD + \", format:png }}\"))).get(\"counts_png\");\n    assertTrue(v instanceof byte[]);\n    //simply test we can read the image\n    assertNotNull(FacetHeatmap.PngHelper.readImage((byte[]) v));\n    //good enough for this test method\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2ab027bdfe663227636ccbeda13ae82add302939":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2ab027bdfe663227636ccbeda13ae82add302939"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e98520789adb1d5ad05afb4956eca0944a929688"],"e98520789adb1d5ad05afb4956eca0944a929688":["2ab027bdfe663227636ccbeda13ae82add302939"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2ab027bdfe663227636ccbeda13ae82add302939"]},"commit2Childs":{"2ab027bdfe663227636ccbeda13ae82add302939":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","e98520789adb1d5ad05afb4956eca0944a929688","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2ab027bdfe663227636ccbeda13ae82add302939","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"e98520789adb1d5ad05afb4956eca0944a929688":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}