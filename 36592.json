{"path":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","commits":[{"id":"d5151046764fb8d9662e02d6c5381b2adb69f96d","date":1216394962,"type":1,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    synchronized (SolrCore.class) {\n      coreDescriptor = cd;\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data/\");\n\n      dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      highlighter = createHighlighter(\n    \t\t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n      );\n      highlighter.initalize( solrConfig );\n\n      final CountDownLatch latch = new CountDownLatch(1);\n\n      try {\n        // cause the executor to stall so firstSearcher events won't fire\n        // until after inform() has been called for all components.\n        // searchExecutor must be single-threaded for this to work\n        searcherExecutor.submit(new Callable() {\n          public Object call() throws Exception {\n            latch.await();\n            return null;\n          }\n        });\n\n        // Open the searcher *before* the update handler so we don't end up opening\n        // one in the middle.\n        // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n\n        // Finally tell anyone who wants to know\n        loader.inform( loader );\n        loader.inform( this );\n\n      } catch (IOException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n      } finally {\n        // allow firstSearcher events to fire\n        latch.countDown();\n      }\n    } // end synchronized\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data/\");\n\n      dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      highlighter = createHighlighter(\n    \t\t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n      );\n      highlighter.initalize( solrConfig );\n\n      final CountDownLatch latch = new CountDownLatch(1);\n\n      try {\n        // cause the executor to stall so firstSearcher events won't fire\n        // until after inform() has been called for all components.\n        // searchExecutor must be single-threaded for this to work\n        searcherExecutor.submit(new Callable() {\n          public Object call() throws Exception {\n            latch.await();\n            return null;\n          }\n        });\n\n        // Open the searcher *before* the update handler so we don't end up opening\n        // one in the middle.\n        // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n\n        // Finally tell anyone who wants to know\n        loader.inform( loader );\n        loader.inform( this );\n\n      } catch (IOException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n      } finally {\n        // allow firstSearcher events to fire\n        latch.countDown();\n      }\n    } // end synchronized\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d656bfb8102419b4568f368a9606efc4f059912e","date":1217031644,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    synchronized (SolrCore.class) {\n      coreDescriptor = cd;\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data/\");\n\n      dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      highlighter = createHighlighter(\n    \t\t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n      );\n      highlighter.initalize( solrConfig );\n\n      final CountDownLatch latch = new CountDownLatch(1);\n\n      try {\n        // cause the executor to stall so firstSearcher events won't fire\n        // until after inform() has been called for all components.\n        // searchExecutor must be single-threaded for this to work\n        searcherExecutor.submit(new Callable() {\n          public Object call() throws Exception {\n            latch.await();\n            return null;\n          }\n        });\n\n        // Open the searcher *before* the update handler so we don't end up opening\n        // one in the middle.\n        // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n\n        // Finally tell anyone who wants to know\n        loader.inform( loader );\n        loader.inform( this );\n\n      } catch (IOException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n      } finally {\n        // allow firstSearcher events to fire\n        latch.countDown();\n      }\n    } // end synchronized\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    synchronized (SolrCore.class) {\n      coreDescriptor = cd;\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data/\");\n\n      dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      highlighter = createHighlighter(\n    \t\t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n      );\n      highlighter.initalize( solrConfig );\n\n      final CountDownLatch latch = new CountDownLatch(1);\n\n      try {\n        // cause the executor to stall so firstSearcher events won't fire\n        // until after inform() has been called for all components.\n        // searchExecutor must be single-threaded for this to work\n        searcherExecutor.submit(new Callable() {\n          public Object call() throws Exception {\n            latch.await();\n            return null;\n          }\n        });\n\n        // Open the searcher *before* the update handler so we don't end up opening\n        // one in the middle.\n        // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n\n        // Finally tell anyone who wants to know\n        loader.inform( loader );\n        loader.inform( this );\n\n      } catch (IOException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n      } finally {\n        // allow firstSearcher events to fire\n        latch.countDown();\n      }\n    } // end synchronized\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6ec2a01e62b7b206d9466aafaf04d8a9d6aee77b","date":1217355237,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    synchronized (SolrCore.class) {\n      coreDescriptor = cd;\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data/\");\n\n      dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n      \n      //Initialize JMX\n      if (config.jmxConfig.enabled) {\n        infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n      } else  {\n        log.info(\"JMX monitoring not detected for core: \" + name);\n        infoRegistry = new LinkedHashMap<String, SolrInfoMBean>();\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      highlighter = createHighlighter(\n    \t\t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n      );\n      highlighter.initalize( solrConfig );\n\n      final CountDownLatch latch = new CountDownLatch(1);\n\n      try {\n        // cause the executor to stall so firstSearcher events won't fire\n        // until after inform() has been called for all components.\n        // searchExecutor must be single-threaded for this to work\n        searcherExecutor.submit(new Callable() {\n          public Object call() throws Exception {\n            latch.await();\n            return null;\n          }\n        });\n\n        // Open the searcher *before* the update handler so we don't end up opening\n        // one in the middle.\n        // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n        infoRegistry.put(\"updateHandler\", updateHandler);\n\n        // Finally tell anyone who wants to know\n        loader.inform( loader );\n        loader.inform( this );\n\n      } catch (IOException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n      } finally {\n        // allow firstSearcher events to fire\n        latch.countDown();\n      }\n    } // end synchronized\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    synchronized (SolrCore.class) {\n      coreDescriptor = cd;\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data/\");\n\n      dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      highlighter = createHighlighter(\n    \t\t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n      );\n      highlighter.initalize( solrConfig );\n\n      final CountDownLatch latch = new CountDownLatch(1);\n\n      try {\n        // cause the executor to stall so firstSearcher events won't fire\n        // until after inform() has been called for all components.\n        // searchExecutor must be single-threaded for this to work\n        searcherExecutor.submit(new Callable() {\n          public Object call() throws Exception {\n            latch.await();\n            return null;\n          }\n        });\n\n        // Open the searcher *before* the update handler so we don't end up opening\n        // one in the middle.\n        // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n\n        // Finally tell anyone who wants to know\n        loader.inform( loader );\n        loader.inform( this );\n\n      } catch (IOException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n      } finally {\n        // allow firstSearcher events to fire\n        latch.countDown();\n      }\n    } // end synchronized\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04ec3320f0c14445c62d0eeff30995f8704138b7","date":1218250215,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    synchronized (SolrCore.class) {\n      coreDescriptor = cd;\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data/\");\n\n      dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n      \n      //Initialize JMX\n      if (config.jmxConfig.enabled) {\n        infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n      } else  {\n        log.info(\"JMX monitoring not detected for core: \" + name);\n        infoRegistry = new LinkedHashMap<String, SolrInfoMBean>();\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      highlighter = createHighlighter(\n    \t\t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n      );\n      highlighter.initalize( solrConfig );\n      \n      // Handle things that should eventually go away\n      initDeprecatedSupport();\n\n      final CountDownLatch latch = new CountDownLatch(1);\n\n      try {\n        // cause the executor to stall so firstSearcher events won't fire\n        // until after inform() has been called for all components.\n        // searchExecutor must be single-threaded for this to work\n        searcherExecutor.submit(new Callable() {\n          public Object call() throws Exception {\n            latch.await();\n            return null;\n          }\n        });\n\n        // Open the searcher *before* the update handler so we don't end up opening\n        // one in the middle.\n        // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n        infoRegistry.put(\"updateHandler\", updateHandler);\n\n        // Finally tell anyone who wants to know\n        loader.inform( loader );\n        loader.inform( this );\n\n      } catch (IOException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n      } finally {\n        // allow firstSearcher events to fire\n        latch.countDown();\n      }\n    } // end synchronized\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    synchronized (SolrCore.class) {\n      coreDescriptor = cd;\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data/\");\n\n      dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n      \n      //Initialize JMX\n      if (config.jmxConfig.enabled) {\n        infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n      } else  {\n        log.info(\"JMX monitoring not detected for core: \" + name);\n        infoRegistry = new LinkedHashMap<String, SolrInfoMBean>();\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      highlighter = createHighlighter(\n    \t\t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n      );\n      highlighter.initalize( solrConfig );\n\n      final CountDownLatch latch = new CountDownLatch(1);\n\n      try {\n        // cause the executor to stall so firstSearcher events won't fire\n        // until after inform() has been called for all components.\n        // searchExecutor must be single-threaded for this to work\n        searcherExecutor.submit(new Callable() {\n          public Object call() throws Exception {\n            latch.await();\n            return null;\n          }\n        });\n\n        // Open the searcher *before* the update handler so we don't end up opening\n        // one in the middle.\n        // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n        infoRegistry.put(\"updateHandler\", updateHandler);\n\n        // Finally tell anyone who wants to know\n        loader.inform( loader );\n        loader.inform( this );\n\n      } catch (IOException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n      } finally {\n        // allow firstSearcher events to fire\n        latch.countDown();\n      }\n    } // end synchronized\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c28792ff7d1774c306e16afbd44ded91a417049b","date":1219072108,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    synchronized (SolrCore.class) {\n      coreDescriptor = cd;\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data/\");\n\n      dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n      \n      //Initialize JMX\n      if (config.jmxConfig.enabled) {\n        infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n      } else  {\n        log.info(\"JMX monitoring not detected for core: \" + name);\n        infoRegistry = new LinkedHashMap<String, SolrInfoMBean>();\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      highlighter = createHighlighter(\n    \t\t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n      );\n      highlighter.initalize( solrConfig );\n      \n      // Handle things that should eventually go away\n      initDeprecatedSupport();\n\n      final CountDownLatch latch = new CountDownLatch(1);\n\n      try {\n        // cause the executor to stall so firstSearcher events won't fire\n        // until after inform() has been called for all components.\n        // searchExecutor must be single-threaded for this to work\n        searcherExecutor.submit(new Callable() {\n          public Object call() throws Exception {\n            latch.await();\n            return null;\n          }\n        });\n\n        // Open the searcher *before* the update handler so we don't end up opening\n        // one in the middle.\n        // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n        infoRegistry.put(\"updateHandler\", updateHandler);\n\n        // Finally tell anyone who wants to know\n        loader.inform( loader );\n        loader.inform( this );\n\n      } catch (IOException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n      } finally {\n        // allow firstSearcher events to fire\n        latch.countDown();\n      }\n    } // end synchronized\n\n    infoRegistry.put(\"core\", this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    synchronized (SolrCore.class) {\n      coreDescriptor = cd;\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data/\");\n\n      dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n      \n      //Initialize JMX\n      if (config.jmxConfig.enabled) {\n        infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n      } else  {\n        log.info(\"JMX monitoring not detected for core: \" + name);\n        infoRegistry = new LinkedHashMap<String, SolrInfoMBean>();\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      highlighter = createHighlighter(\n    \t\t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n      );\n      highlighter.initalize( solrConfig );\n      \n      // Handle things that should eventually go away\n      initDeprecatedSupport();\n\n      final CountDownLatch latch = new CountDownLatch(1);\n\n      try {\n        // cause the executor to stall so firstSearcher events won't fire\n        // until after inform() has been called for all components.\n        // searchExecutor must be single-threaded for this to work\n        searcherExecutor.submit(new Callable() {\n          public Object call() throws Exception {\n            latch.await();\n            return null;\n          }\n        });\n\n        // Open the searcher *before* the update handler so we don't end up opening\n        // one in the middle.\n        // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n        infoRegistry.put(\"updateHandler\", updateHandler);\n\n        // Finally tell anyone who wants to know\n        loader.inform( loader );\n        loader.inform( this );\n\n      } catch (IOException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n      } finally {\n        // allow firstSearcher events to fire\n        latch.countDown();\n      }\n    } // end synchronized\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"97fc5a00245e9b31c118c53df88b1376237ea87b","date":1222659461,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    synchronized (SolrCore.class) {\n      coreDescriptor = cd;\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data/\");\n\n      dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n      \n      //Initialize JMX\n      if (config.jmxConfig.enabled) {\n        infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n      } else  {\n        log.info(\"JMX monitoring not detected for core: \" + name);\n        infoRegistry = new LinkedHashMap<String, SolrInfoMBean>();\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n\n      initDeletionPolicy();\n\n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      highlighter = createHighlighter(\n    \t\t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n      );\n      highlighter.initalize( solrConfig );\n      \n      // Handle things that should eventually go away\n      initDeprecatedSupport();\n\n      final CountDownLatch latch = new CountDownLatch(1);\n\n      try {\n        // cause the executor to stall so firstSearcher events won't fire\n        // until after inform() has been called for all components.\n        // searchExecutor must be single-threaded for this to work\n        searcherExecutor.submit(new Callable() {\n          public Object call() throws Exception {\n            latch.await();\n            return null;\n          }\n        });\n\n        // Open the searcher *before* the update handler so we don't end up opening\n        // one in the middle.\n        // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n        infoRegistry.put(\"updateHandler\", updateHandler);\n\n        // Finally tell anyone who wants to know\n        loader.inform( loader );\n        loader.inform( this );\n\n      } catch (IOException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n      } finally {\n        // allow firstSearcher events to fire\n        latch.countDown();\n      }\n    } // end synchronized\n\n    infoRegistry.put(\"core\", this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    synchronized (SolrCore.class) {\n      coreDescriptor = cd;\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data/\");\n\n      dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n      \n      //Initialize JMX\n      if (config.jmxConfig.enabled) {\n        infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n      } else  {\n        log.info(\"JMX monitoring not detected for core: \" + name);\n        infoRegistry = new LinkedHashMap<String, SolrInfoMBean>();\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      highlighter = createHighlighter(\n    \t\t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n      );\n      highlighter.initalize( solrConfig );\n      \n      // Handle things that should eventually go away\n      initDeprecatedSupport();\n\n      final CountDownLatch latch = new CountDownLatch(1);\n\n      try {\n        // cause the executor to stall so firstSearcher events won't fire\n        // until after inform() has been called for all components.\n        // searchExecutor must be single-threaded for this to work\n        searcherExecutor.submit(new Callable() {\n          public Object call() throws Exception {\n            latch.await();\n            return null;\n          }\n        });\n\n        // Open the searcher *before* the update handler so we don't end up opening\n        // one in the middle.\n        // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n        infoRegistry.put(\"updateHandler\", updateHandler);\n\n        // Finally tell anyone who wants to know\n        loader.inform( loader );\n        loader.inform( this );\n\n      } catch (IOException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n      } finally {\n        // allow firstSearcher events to fire\n        latch.countDown();\n      }\n    } // end synchronized\n\n    infoRegistry.put(\"core\", this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c90f01e1c0f11ee52212ab38c6d4393b3be8a646","date":1223059437,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    synchronized (SolrCore.class) {\n      coreDescriptor = cd;\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data/\");\n\n      dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n      \n      //Initialize JMX\n      if (config.jmxConfig.enabled) {\n        infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n      } else  {\n        log.info(\"JMX monitoring not detected for core: \" + name);\n        infoRegistry = new LinkedHashMap<String, SolrInfoMBean>();\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n\n      initDeletionPolicy();\n\n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      highlighter = createHighlighter(\n    \t\t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n      );\n      highlighter.initalize( solrConfig );\n      \n      // Handle things that should eventually go away\n      initDeprecatedSupport();\n\n      final CountDownLatch latch = new CountDownLatch(1);\n\n      try {\n        // cause the executor to stall so firstSearcher events won't fire\n        // until after inform() has been called for all components.\n        // searchExecutor must be single-threaded for this to work\n        searcherExecutor.submit(new Callable() {\n          public Object call() throws Exception {\n            latch.await();\n            return null;\n          }\n        });\n\n        // Open the searcher *before* the update handler so we don't end up opening\n        // one in the middle.\n        // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler2.class.getName())\n        );\n\n        infoRegistry.put(\"updateHandler\", updateHandler);\n\n        // Finally tell anyone who wants to know\n        loader.inform( loader );\n        loader.inform( this );\n\n      } catch (IOException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n      } finally {\n        // allow firstSearcher events to fire\n        latch.countDown();\n      }\n    } // end synchronized\n\n    infoRegistry.put(\"core\", this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    synchronized (SolrCore.class) {\n      coreDescriptor = cd;\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data/\");\n\n      dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n      \n      //Initialize JMX\n      if (config.jmxConfig.enabled) {\n        infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n      } else  {\n        log.info(\"JMX monitoring not detected for core: \" + name);\n        infoRegistry = new LinkedHashMap<String, SolrInfoMBean>();\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n\n      initDeletionPolicy();\n\n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      highlighter = createHighlighter(\n    \t\t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n      );\n      highlighter.initalize( solrConfig );\n      \n      // Handle things that should eventually go away\n      initDeprecatedSupport();\n\n      final CountDownLatch latch = new CountDownLatch(1);\n\n      try {\n        // cause the executor to stall so firstSearcher events won't fire\n        // until after inform() has been called for all components.\n        // searchExecutor must be single-threaded for this to work\n        searcherExecutor.submit(new Callable() {\n          public Object call() throws Exception {\n            latch.await();\n            return null;\n          }\n        });\n\n        // Open the searcher *before* the update handler so we don't end up opening\n        // one in the middle.\n        // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n        infoRegistry.put(\"updateHandler\", updateHandler);\n\n        // Finally tell anyone who wants to know\n        loader.inform( loader );\n        loader.inform( this );\n\n      } catch (IOException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n      } finally {\n        // allow firstSearcher events to fire\n        latch.countDown();\n      }\n    } // end synchronized\n\n    infoRegistry.put(\"core\", this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f84bbba5f51b88ff0d565e8c37f35dc8fe564d93","date":1229519447,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    synchronized (SolrCore.class) {\n      coreDescriptor = cd;\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data/\");\n\n      dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n      \n      //Initialize JMX\n      if (config.jmxConfig.enabled) {\n        infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n      } else  {\n        log.info(\"JMX monitoring not detected for core: \" + name);\n        infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n\n      initDeletionPolicy();\n\n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      highlighter = createHighlighter(\n    \t\t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n      );\n      highlighter.initalize( solrConfig );\n      \n      // Handle things that should eventually go away\n      initDeprecatedSupport();\n\n      final CountDownLatch latch = new CountDownLatch(1);\n\n      try {\n        // cause the executor to stall so firstSearcher events won't fire\n        // until after inform() has been called for all components.\n        // searchExecutor must be single-threaded for this to work\n        searcherExecutor.submit(new Callable() {\n          public Object call() throws Exception {\n            latch.await();\n            return null;\n          }\n        });\n\n        // Open the searcher *before* the update handler so we don't end up opening\n        // one in the middle.\n        // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler2.class.getName())\n        );\n\n        infoRegistry.put(\"updateHandler\", updateHandler);\n\n        // Finally tell anyone who wants to know\n        loader.inform( loader );\n        loader.inform( this );\n\n      } catch (IOException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n      } finally {\n        // allow firstSearcher events to fire\n        latch.countDown();\n      }\n    } // end synchronized\n\n    infoRegistry.put(\"core\", this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    synchronized (SolrCore.class) {\n      coreDescriptor = cd;\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data/\");\n\n      dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n      \n      //Initialize JMX\n      if (config.jmxConfig.enabled) {\n        infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n      } else  {\n        log.info(\"JMX monitoring not detected for core: \" + name);\n        infoRegistry = new LinkedHashMap<String, SolrInfoMBean>();\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n\n      initDeletionPolicy();\n\n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      highlighter = createHighlighter(\n    \t\t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n      );\n      highlighter.initalize( solrConfig );\n      \n      // Handle things that should eventually go away\n      initDeprecatedSupport();\n\n      final CountDownLatch latch = new CountDownLatch(1);\n\n      try {\n        // cause the executor to stall so firstSearcher events won't fire\n        // until after inform() has been called for all components.\n        // searchExecutor must be single-threaded for this to work\n        searcherExecutor.submit(new Callable() {\n          public Object call() throws Exception {\n            latch.await();\n            return null;\n          }\n        });\n\n        // Open the searcher *before* the update handler so we don't end up opening\n        // one in the middle.\n        // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler2.class.getName())\n        );\n\n        infoRegistry.put(\"updateHandler\", updateHandler);\n\n        // Finally tell anyone who wants to know\n        loader.inform( loader );\n        loader.inform( this );\n\n      } catch (IOException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n      } finally {\n        // allow firstSearcher events to fire\n        latch.countDown();\n      }\n    } // end synchronized\n\n    infoRegistry.put(\"core\", this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5231549ca15f43ec84ff65b78dffc6d239adf007","date":1233912291,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    synchronized (SolrCore.class) {\n      coreDescriptor = cd;\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",cd.getDataDir());\n\n      dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n      \n      //Initialize JMX\n      if (config.jmxConfig.enabled) {\n        infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n      } else  {\n        log.info(\"JMX monitoring not detected for core: \" + name);\n        infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n\n      initDeletionPolicy();\n\n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      highlighter = createHighlighter(\n    \t\t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n      );\n      highlighter.initalize( solrConfig );\n      \n      // Handle things that should eventually go away\n      initDeprecatedSupport();\n\n      final CountDownLatch latch = new CountDownLatch(1);\n\n      try {\n        // cause the executor to stall so firstSearcher events won't fire\n        // until after inform() has been called for all components.\n        // searchExecutor must be single-threaded for this to work\n        searcherExecutor.submit(new Callable() {\n          public Object call() throws Exception {\n            latch.await();\n            return null;\n          }\n        });\n\n        // Open the searcher *before* the update handler so we don't end up opening\n        // one in the middle.\n        // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler2.class.getName())\n        );\n\n        infoRegistry.put(\"updateHandler\", updateHandler);\n\n        // Finally tell anyone who wants to know\n        loader.inform( loader );\n        loader.inform( this );\n\n      } catch (IOException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n      } finally {\n        // allow firstSearcher events to fire\n        latch.countDown();\n      }\n    } // end synchronized\n\n    infoRegistry.put(\"core\", this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    synchronized (SolrCore.class) {\n      coreDescriptor = cd;\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data/\");\n\n      dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n      \n      //Initialize JMX\n      if (config.jmxConfig.enabled) {\n        infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n      } else  {\n        log.info(\"JMX monitoring not detected for core: \" + name);\n        infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n\n      initDeletionPolicy();\n\n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      highlighter = createHighlighter(\n    \t\t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n      );\n      highlighter.initalize( solrConfig );\n      \n      // Handle things that should eventually go away\n      initDeprecatedSupport();\n\n      final CountDownLatch latch = new CountDownLatch(1);\n\n      try {\n        // cause the executor to stall so firstSearcher events won't fire\n        // until after inform() has been called for all components.\n        // searchExecutor must be single-threaded for this to work\n        searcherExecutor.submit(new Callable() {\n          public Object call() throws Exception {\n            latch.await();\n            return null;\n          }\n        });\n\n        // Open the searcher *before* the update handler so we don't end up opening\n        // one in the middle.\n        // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler2.class.getName())\n        );\n\n        infoRegistry.put(\"updateHandler\", updateHandler);\n\n        // Finally tell anyone who wants to know\n        loader.inform( loader );\n        loader.inform( this );\n\n      } catch (IOException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n      } finally {\n        // allow firstSearcher events to fire\n        latch.countDown();\n      }\n    } // end synchronized\n\n    infoRegistry.put(\"core\", this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0df4c5cd5eaf4742b3a39587e6de21a372bcb6fc","date":1240392310,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    SolrResourceLoader loader = config.getResourceLoader();\n    if (dataDir == null)\n      dataDir = config.get(\"dataDir\",cd.getDataDir());\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n    booleanQueryMaxClauseCount();\n  \n    parseListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents( config );\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n  \n    highlighter = createHighlighter(\n    \t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n    );\n    highlighter.initalize( solrConfig );\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n  \n      updateHandler = createUpdateHandler(\n        solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler2.class.getName())\n      );\n\n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      loader.inform( loader );\n      loader.inform( this );\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    synchronized (SolrCore.class) {\n      coreDescriptor = cd;\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",cd.getDataDir());\n\n      dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n      \n      //Initialize JMX\n      if (config.jmxConfig.enabled) {\n        infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n      } else  {\n        log.info(\"JMX monitoring not detected for core: \" + name);\n        infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n\n      initDeletionPolicy();\n\n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      highlighter = createHighlighter(\n    \t\t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n      );\n      highlighter.initalize( solrConfig );\n      \n      // Handle things that should eventually go away\n      initDeprecatedSupport();\n\n      final CountDownLatch latch = new CountDownLatch(1);\n\n      try {\n        // cause the executor to stall so firstSearcher events won't fire\n        // until after inform() has been called for all components.\n        // searchExecutor must be single-threaded for this to work\n        searcherExecutor.submit(new Callable() {\n          public Object call() throws Exception {\n            latch.await();\n            return null;\n          }\n        });\n\n        // Open the searcher *before* the update handler so we don't end up opening\n        // one in the middle.\n        // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler2.class.getName())\n        );\n\n        infoRegistry.put(\"updateHandler\", updateHandler);\n\n        // Finally tell anyone who wants to know\n        loader.inform( loader );\n        loader.inform( this );\n\n      } catch (IOException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n      } finally {\n        // allow firstSearcher events to fire\n        latch.countDown();\n      }\n    } // end synchronized\n\n    infoRegistry.put(\"core\", this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"656ba78dd2c0e88d11623fc5bceca3ea217ce0b3","date":1244100008,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    SolrResourceLoader loader = config.getResourceLoader();\n    if (dataDir == null)\n      dataDir = config.get(\"dataDir\",cd.getDataDir());\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    parseListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents( config );\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n  \n    highlighter = createHighlighter(\n    \t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n    );\n    highlighter.initalize( solrConfig );\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n  \n      updateHandler = createUpdateHandler(\n        solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler2.class.getName())\n      );\n\n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      loader.inform( loader );\n      loader.inform( this );\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    SolrResourceLoader loader = config.getResourceLoader();\n    if (dataDir == null)\n      dataDir = config.get(\"dataDir\",cd.getDataDir());\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n    booleanQueryMaxClauseCount();\n  \n    parseListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents( config );\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n  \n    highlighter = createHighlighter(\n    \t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n    );\n    highlighter.initalize( solrConfig );\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n  \n      updateHandler = createUpdateHandler(\n        solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler2.class.getName())\n      );\n\n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      loader.inform( loader );\n      loader.inform( this );\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6af9d3dcf0f33c88d1363e243ab89fb68c0ffdb","date":1244526657,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null)\n      dataDir = config.get(\"dataDir\",cd.getDataDir());\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    parseListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n  \n    highlighter = createHighlighter(\n    \t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n    );\n    highlighter.initalize( solrConfig );\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    SolrResourceLoader loader = config.getResourceLoader();\n    if (dataDir == null)\n      dataDir = config.get(\"dataDir\",cd.getDataDir());\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    parseListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents( config );\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n  \n    highlighter = createHighlighter(\n    \t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n    );\n    highlighter.initalize( solrConfig );\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n  \n      updateHandler = createUpdateHandler(\n        solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler2.class.getName())\n      );\n\n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      loader.inform( loader );\n      loader.inform( this );\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n  }\n\n","bugFix":null,"bugIntro":["48d548a14602be2584dd07e610109753923812e2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e5d451f04bea3df3123dd3c3c2df8010d0f90c23","date":1244615057,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null)\n      dataDir = config.get(\"dataDir\",cd.getDataDir());\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    parseListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n    String highLightClass = solrConfig.getHighLghtingClass();\n  \n    highlighter = createHighlighter(highLightClass == null? DefaultSolrHighlighter.class.getName() : highLightClass);\n    highlighter.initalize( solrConfig );\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null)\n      dataDir = config.get(\"dataDir\",cd.getDataDir());\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    parseListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n  \n    highlighter = createHighlighter(\n    \t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n    );\n    highlighter.initalize( solrConfig );\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c07ddbc5edafff8b6ae1fd5994ca8084dcbdf4c1","date":1245994464,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      dataDir =  config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    parseListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n    String highLightClass = solrConfig.getHighLghtingClass();\n  \n    highlighter = createHighlighter(highLightClass == null? DefaultSolrHighlighter.class.getName() : highLightClass);\n    highlighter.initalize( solrConfig );\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null)\n      dataDir = config.get(\"dataDir\",cd.getDataDir());\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    parseListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n    String highLightClass = solrConfig.getHighLghtingClass();\n  \n    highlighter = createHighlighter(highLightClass == null? DefaultSolrHighlighter.class.getName() : highLightClass);\n    highlighter.initalize( solrConfig );\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"28a016ae2abf4934515e45810192aa4350e3092b","date":1252309557,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      dataDir =  config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n    String highLightClass = solrConfig.getHighLghtingClass();\n  \n    highlighter = createHighlighter(highLightClass == null? DefaultSolrHighlighter.class.getName() : highLightClass);\n    highlighter.initalize( solrConfig );\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      dataDir =  config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    parseListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n    String highLightClass = solrConfig.getHighLghtingClass();\n  \n    highlighter = createHighlighter(highLightClass == null? DefaultSolrHighlighter.class.getName() : highLightClass);\n    highlighter.initalize( solrConfig );\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d65be9efd1a01c467bd685fd63511b92311257f5","date":1253066235,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      dataDir =  config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n    String highLightClass = solrConfig.getHighLghtingClass();\n  \n    highlighter = createHighlighter(highLightClass == null? DefaultSolrHighlighter.class.getName() : highLightClass);\n    highlighter.initalize( solrConfig );\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );\n      //register any SolrInfoMBeans\n      resourceLoader.inform(infoRegistry);\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      dataDir =  config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n    String highLightClass = solrConfig.getHighLghtingClass();\n  \n    highlighter = createHighlighter(highLightClass == null? DefaultSolrHighlighter.class.getName() : highLightClass);\n    highlighter.initalize( solrConfig );\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b6036b7cd3ea2bcc0e2a9530a27c6c4b98805ebc","date":1253460658,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      dataDir =  config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n    String highLightClass = solrConfig.getHighLghtingClass();\n  \n    highlighter = createHighlighter(highLightClass == null? DefaultSolrHighlighter.class.getName() : highLightClass);\n    highlighter.initalize( solrConfig );\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      dataDir =  config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n    String highLightClass = solrConfig.getHighLghtingClass();\n  \n    highlighter = createHighlighter(highLightClass == null? DefaultSolrHighlighter.class.getName() : highLightClass);\n    highlighter.initalize( solrConfig );\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );\n      //register any SolrInfoMBeans\n      resourceLoader.inform(infoRegistry);\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae2d1b1882412cb224513ad453e3bc316a99118a","date":1253535818,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      dataDir =  config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n    highlighter = initHighLighter();\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      dataDir =  config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n    String highLightClass = solrConfig.getHighLghtingClass();\n  \n    highlighter = createHighlighter(highLightClass == null? DefaultSolrHighlighter.class.getName() : highLightClass);\n    highlighter.initalize( solrConfig );\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"efde1ddfc9d0125b5cccad6d1130f34fa0b33d61","date":1253593710,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      dataDir =  config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n    highlighter = initHighLighter();\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      dataDir =  config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n    highlighter = initHighLighter();\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8626034838b30f3e0a62b18992eb6227c04ec80b","date":1253824556,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      dataDir =  config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n    highlighter = initHighLighter();\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      dataDir =  config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n    highlighter = initHighLighter();\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5df1793b9dbc0f17ba1d1dddb8a15748fdc3aaf3","date":1263013040,"type":3,"author":"Koji Sekiguchi","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      dataDir =  config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n    highlighter = initHighlighter();\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      dataDir =  config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n    highlighter = initHighLighter();\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bad78684057afb0e5b908d6cebf7fb606a8b3b03","date":1263548630,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      dataDir =  config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      dataDir =  config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n    highlighter = initHighlighter();\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      dataDir =  config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      dataDir =  config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n\n    this.searchComponents = loadSearchComponents();\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      updateHandler = createUpdateHandler(updateHandlerClass == null ?  DirectUpdateHandler2.class.getName():updateHandlerClass); \n      infoRegistry.put(\"updateHandler\", updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );\n      instance = this;   // set singleton for backwards compatibility\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"ae2d1b1882412cb224513ad453e3bc316a99118a":["b6036b7cd3ea2bcc0e2a9530a27c6c4b98805ebc"],"d65be9efd1a01c467bd685fd63511b92311257f5":["28a016ae2abf4934515e45810192aa4350e3092b"],"d5151046764fb8d9662e02d6c5381b2adb69f96d":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"e5d451f04bea3df3123dd3c3c2df8010d0f90c23":["a6af9d3dcf0f33c88d1363e243ab89fb68c0ffdb"],"d656bfb8102419b4568f368a9606efc4f059912e":["d5151046764fb8d9662e02d6c5381b2adb69f96d"],"04ec3320f0c14445c62d0eeff30995f8704138b7":["6ec2a01e62b7b206d9466aafaf04d8a9d6aee77b"],"f84bbba5f51b88ff0d565e8c37f35dc8fe564d93":["c90f01e1c0f11ee52212ab38c6d4393b3be8a646"],"97fc5a00245e9b31c118c53df88b1376237ea87b":["c28792ff7d1774c306e16afbd44ded91a417049b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6ec2a01e62b7b206d9466aafaf04d8a9d6aee77b":["d656bfb8102419b4568f368a9606efc4f059912e"],"ad94625fb8d088209f46650c8097196fec67f00c":["bad78684057afb0e5b908d6cebf7fb606a8b3b03"],"656ba78dd2c0e88d11623fc5bceca3ea217ce0b3":["0df4c5cd5eaf4742b3a39587e6de21a372bcb6fc"],"c07ddbc5edafff8b6ae1fd5994ca8084dcbdf4c1":["e5d451f04bea3df3123dd3c3c2df8010d0f90c23"],"c28792ff7d1774c306e16afbd44ded91a417049b":["04ec3320f0c14445c62d0eeff30995f8704138b7"],"5231549ca15f43ec84ff65b78dffc6d239adf007":["f84bbba5f51b88ff0d565e8c37f35dc8fe564d93"],"5df1793b9dbc0f17ba1d1dddb8a15748fdc3aaf3":["8626034838b30f3e0a62b18992eb6227c04ec80b"],"efde1ddfc9d0125b5cccad6d1130f34fa0b33d61":["ae2d1b1882412cb224513ad453e3bc316a99118a"],"b6036b7cd3ea2bcc0e2a9530a27c6c4b98805ebc":["d65be9efd1a01c467bd685fd63511b92311257f5"],"c90f01e1c0f11ee52212ab38c6d4393b3be8a646":["97fc5a00245e9b31c118c53df88b1376237ea87b"],"a6af9d3dcf0f33c88d1363e243ab89fb68c0ffdb":["656ba78dd2c0e88d11623fc5bceca3ea217ce0b3"],"0df4c5cd5eaf4742b3a39587e6de21a372bcb6fc":["5231549ca15f43ec84ff65b78dffc6d239adf007"],"bad78684057afb0e5b908d6cebf7fb606a8b3b03":["5df1793b9dbc0f17ba1d1dddb8a15748fdc3aaf3"],"8626034838b30f3e0a62b18992eb6227c04ec80b":["efde1ddfc9d0125b5cccad6d1130f34fa0b33d61"],"28a016ae2abf4934515e45810192aa4350e3092b":["c07ddbc5edafff8b6ae1fd5994ca8084dcbdf4c1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"ae2d1b1882412cb224513ad453e3bc316a99118a":["efde1ddfc9d0125b5cccad6d1130f34fa0b33d61"],"d65be9efd1a01c467bd685fd63511b92311257f5":["b6036b7cd3ea2bcc0e2a9530a27c6c4b98805ebc"],"d5151046764fb8d9662e02d6c5381b2adb69f96d":["d656bfb8102419b4568f368a9606efc4f059912e"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["d5151046764fb8d9662e02d6c5381b2adb69f96d"],"e5d451f04bea3df3123dd3c3c2df8010d0f90c23":["c07ddbc5edafff8b6ae1fd5994ca8084dcbdf4c1"],"d656bfb8102419b4568f368a9606efc4f059912e":["6ec2a01e62b7b206d9466aafaf04d8a9d6aee77b"],"04ec3320f0c14445c62d0eeff30995f8704138b7":["c28792ff7d1774c306e16afbd44ded91a417049b"],"f84bbba5f51b88ff0d565e8c37f35dc8fe564d93":["5231549ca15f43ec84ff65b78dffc6d239adf007"],"97fc5a00245e9b31c118c53df88b1376237ea87b":["c90f01e1c0f11ee52212ab38c6d4393b3be8a646"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6ec2a01e62b7b206d9466aafaf04d8a9d6aee77b":["04ec3320f0c14445c62d0eeff30995f8704138b7"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"656ba78dd2c0e88d11623fc5bceca3ea217ce0b3":["a6af9d3dcf0f33c88d1363e243ab89fb68c0ffdb"],"c28792ff7d1774c306e16afbd44ded91a417049b":["97fc5a00245e9b31c118c53df88b1376237ea87b"],"c07ddbc5edafff8b6ae1fd5994ca8084dcbdf4c1":["28a016ae2abf4934515e45810192aa4350e3092b"],"5231549ca15f43ec84ff65b78dffc6d239adf007":["0df4c5cd5eaf4742b3a39587e6de21a372bcb6fc"],"5df1793b9dbc0f17ba1d1dddb8a15748fdc3aaf3":["bad78684057afb0e5b908d6cebf7fb606a8b3b03"],"efde1ddfc9d0125b5cccad6d1130f34fa0b33d61":["8626034838b30f3e0a62b18992eb6227c04ec80b"],"b6036b7cd3ea2bcc0e2a9530a27c6c4b98805ebc":["ae2d1b1882412cb224513ad453e3bc316a99118a"],"c90f01e1c0f11ee52212ab38c6d4393b3be8a646":["f84bbba5f51b88ff0d565e8c37f35dc8fe564d93"],"a6af9d3dcf0f33c88d1363e243ab89fb68c0ffdb":["e5d451f04bea3df3123dd3c3c2df8010d0f90c23"],"0df4c5cd5eaf4742b3a39587e6de21a372bcb6fc":["656ba78dd2c0e88d11623fc5bceca3ea217ce0b3"],"bad78684057afb0e5b908d6cebf7fb606a8b3b03":["ad94625fb8d088209f46650c8097196fec67f00c"],"8626034838b30f3e0a62b18992eb6227c04ec80b":["5df1793b9dbc0f17ba1d1dddb8a15748fdc3aaf3"],"28a016ae2abf4934515e45810192aa4350e3092b":["d65be9efd1a01c467bd685fd63511b92311257f5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}