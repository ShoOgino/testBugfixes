{"path":"solr/core/src/java/org/apache/solr/search/facet/RelatednessAgg.BucketData#externalize(boolean).mjava","commits":[{"id":"2c705a0d590cf911e7c942df49563ca2ea176e22","date":1526916174,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/RelatednessAgg.BucketData#externalize(boolean).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * @see SlotAcc#getValue\n     * @see Merger#getMergedResult\n     */\n    public SimpleOrderedMap externalize(final boolean isShardRequest) {\n      SimpleOrderedMap result = new SimpleOrderedMap<Number>();\n      \n      if (isShardRequest) {\n        result.add(FG_COUNT, fg_count);\n        result.add(BG_COUNT, bg_count);\n        // NOTE: sizes will be the same for every slot...\n        // TODO: it would be nice to put them directly in the parent facet, instead of every bucket,\n        // in order to reduce the size of the response.\n        result.add(FG_SIZE, fg_size); \n        result.add(BG_SIZE, bg_size);\n      } else {\n        // there's no need to bother computing these when returning results *to* a shard coordinator\n        // only useful to external clients \n        result.add(RELATEDNESS, this.getRelatedness());\n        result.add(FG_POP, roundTo5Digits((double) fg_count / bg_size)); // yes, BACKGROUND size is intentional\n        result.add(BG_POP, roundTo5Digits((double) bg_count / bg_size));\n      }\n      \n      return result;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["22d2c45da6e47ff0ada29a8f98566b76f0b278de"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"42009f1fefcc8f4d9e07b158e9415cbd6ca7247c","date":1532538390,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/RelatednessAgg.BucketData#externalize(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/RelatednessAgg.BucketData#externalize(boolean).mjava","sourceNew":"    /**\n     * @see SlotAcc#getValue\n     * @see Merger#getMergedResult\n     */\n    public SimpleOrderedMap externalize(final boolean isShardRequest) {\n      SimpleOrderedMap result = new SimpleOrderedMap<Number>();\n      \n      if (isShardRequest) {\n        result.add(FG_COUNT, fg_count);\n        result.add(BG_COUNT, bg_count);\n        // NOTE: sizes will be the same for every slot...\n        // TODO: it would be nice to put them directly in the parent facet, instead of every bucket,\n        // in order to reduce the size of the response.\n        result.add(FG_SIZE, fg_size); \n        result.add(BG_SIZE, bg_size);\n      } else {\n        // there's no need to bother computing these when returning results *to* a shard coordinator\n        // only useful to external clients \n        result.add(RELATEDNESS, this.getRelatedness());\n        result.add(FG_POP, this.getForegroundPopularity());\n        result.add(BG_POP, this.getBackgroundPopularity());\n      }\n      \n      return result;\n    }\n\n","sourceOld":"    /**\n     * @see SlotAcc#getValue\n     * @see Merger#getMergedResult\n     */\n    public SimpleOrderedMap externalize(final boolean isShardRequest) {\n      SimpleOrderedMap result = new SimpleOrderedMap<Number>();\n      \n      if (isShardRequest) {\n        result.add(FG_COUNT, fg_count);\n        result.add(BG_COUNT, bg_count);\n        // NOTE: sizes will be the same for every slot...\n        // TODO: it would be nice to put them directly in the parent facet, instead of every bucket,\n        // in order to reduce the size of the response.\n        result.add(FG_SIZE, fg_size); \n        result.add(BG_SIZE, bg_size);\n      } else {\n        // there's no need to bother computing these when returning results *to* a shard coordinator\n        // only useful to external clients \n        result.add(RELATEDNESS, this.getRelatedness());\n        result.add(FG_POP, roundTo5Digits((double) fg_count / bg_size)); // yes, BACKGROUND size is intentional\n        result.add(BG_POP, roundTo5Digits((double) bg_count / bg_size));\n      }\n      \n      return result;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a56a9893014b284af4d1af451e6c02e7ffdf5b6e","date":1590065972,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/RelatednessAgg.BucketData#externalize(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/RelatednessAgg.BucketData#externalize(boolean).mjava","sourceNew":"    /**\n     * @see SlotAcc#getValue\n     * @see Merger#getMergedResult\n     */\n\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public SimpleOrderedMap externalize(final boolean isShardRequest) {\n      SimpleOrderedMap result = new SimpleOrderedMap<Number>();\n      \n      if (isShardRequest) {\n        result.add(FG_COUNT, fg_count);\n        result.add(BG_COUNT, bg_count);\n        // NOTE: sizes will be the same for every slot...\n        // TODO: it would be nice to put them directly in the parent facet, instead of every bucket,\n        // in order to reduce the size of the response.\n        result.add(FG_SIZE, fg_size); \n        result.add(BG_SIZE, bg_size);\n      } else {\n        // there's no need to bother computing these when returning results *to* a shard coordinator\n        // only useful to external clients \n        result.add(RELATEDNESS, this.getRelatedness());\n        result.add(FG_POP, this.getForegroundPopularity());\n        result.add(BG_POP, this.getBackgroundPopularity());\n      }\n      \n      return result;\n    }\n\n","sourceOld":"    /**\n     * @see SlotAcc#getValue\n     * @see Merger#getMergedResult\n     */\n    public SimpleOrderedMap externalize(final boolean isShardRequest) {\n      SimpleOrderedMap result = new SimpleOrderedMap<Number>();\n      \n      if (isShardRequest) {\n        result.add(FG_COUNT, fg_count);\n        result.add(BG_COUNT, bg_count);\n        // NOTE: sizes will be the same for every slot...\n        // TODO: it would be nice to put them directly in the parent facet, instead of every bucket,\n        // in order to reduce the size of the response.\n        result.add(FG_SIZE, fg_size); \n        result.add(BG_SIZE, bg_size);\n      } else {\n        // there's no need to bother computing these when returning results *to* a shard coordinator\n        // only useful to external clients \n        result.add(RELATEDNESS, this.getRelatedness());\n        result.add(FG_POP, this.getForegroundPopularity());\n        result.add(BG_POP, this.getBackgroundPopularity());\n      }\n      \n      return result;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"22d2c45da6e47ff0ada29a8f98566b76f0b278de","date":1591372739,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/RelatednessAgg.BucketData#externalize(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/RelatednessAgg.BucketData#externalize(boolean).mjava","sourceNew":"    /**\n     * @see SlotAcc#getValue\n     * @see Merger#getMergedResult\n     */\n\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public SimpleOrderedMap externalize(final boolean isShardRequest) {\n      SimpleOrderedMap result = new SimpleOrderedMap<Number>();\n\n      // if counts are non-zero, then this bucket must not be implied\n      assert 0 == fg_count || ! implied : \"Implied bucket has non-zero fg_count\";\n      assert 0 == bg_count || ! implied : \"Implied bucket has non-zero bg_count\";\n      \n      if (isShardRequest) {\n        // shard responses must include size info, but don't need the derived stats\n        //\n        // NOTE: sizes will be the same for every slot...\n        // TODO: it would be nice to put them directly in the parent facet, instead of every bucket,\n        // in order to reduce the size of the response.\n        result.add(FG_SIZE, fg_size); \n        result.add(BG_SIZE, bg_size);\n        \n        if (implied) {\n          // for an implied bucket on this shard, we don't need to bother returning the (empty)\n          // counts, just the flag explaining that this bucket is (locally) implied...\n          result.add(IMPLIED_KEY, Boolean.TRUE);\n        } else {\n          result.add(FG_COUNT, fg_count); \n          result.add(BG_COUNT, bg_count);\n        }\n      } else {\n        if (implied) {\n          // When returning results to an external client, any bucket still 'implied' shouldn't return\n          // any results at all.\n          // (practically speaking this should only happen for the 'allBuckets' bucket\n          return null;\n        }\n\n        // there's no need to bother computing these when returning results *to* a shard coordinator\n        // only useful to external clients \n        result.add(RELATEDNESS, this.getRelatedness());\n        result.add(FG_POP, this.getForegroundPopularity());\n        result.add(BG_POP, this.getBackgroundPopularity());\n      }\n      \n      return result;\n    }\n\n","sourceOld":"    /**\n     * @see SlotAcc#getValue\n     * @see Merger#getMergedResult\n     */\n\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public SimpleOrderedMap externalize(final boolean isShardRequest) {\n      SimpleOrderedMap result = new SimpleOrderedMap<Number>();\n      \n      if (isShardRequest) {\n        result.add(FG_COUNT, fg_count);\n        result.add(BG_COUNT, bg_count);\n        // NOTE: sizes will be the same for every slot...\n        // TODO: it would be nice to put them directly in the parent facet, instead of every bucket,\n        // in order to reduce the size of the response.\n        result.add(FG_SIZE, fg_size); \n        result.add(BG_SIZE, bg_size);\n      } else {\n        // there's no need to bother computing these when returning results *to* a shard coordinator\n        // only useful to external clients \n        result.add(RELATEDNESS, this.getRelatedness());\n        result.add(FG_POP, this.getForegroundPopularity());\n        result.add(BG_POP, this.getBackgroundPopularity());\n      }\n      \n      return result;\n    }\n\n","bugFix":["2c705a0d590cf911e7c942df49563ca2ea176e22"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2c705a0d590cf911e7c942df49563ca2ea176e22":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"22d2c45da6e47ff0ada29a8f98566b76f0b278de":["a56a9893014b284af4d1af451e6c02e7ffdf5b6e"],"a56a9893014b284af4d1af451e6c02e7ffdf5b6e":["42009f1fefcc8f4d9e07b158e9415cbd6ca7247c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"42009f1fefcc8f4d9e07b158e9415cbd6ca7247c":["2c705a0d590cf911e7c942df49563ca2ea176e22"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["22d2c45da6e47ff0ada29a8f98566b76f0b278de"]},"commit2Childs":{"2c705a0d590cf911e7c942df49563ca2ea176e22":["42009f1fefcc8f4d9e07b158e9415cbd6ca7247c"],"22d2c45da6e47ff0ada29a8f98566b76f0b278de":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a56a9893014b284af4d1af451e6c02e7ffdf5b6e":["22d2c45da6e47ff0ada29a8f98566b76f0b278de"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2c705a0d590cf911e7c942df49563ca2ea176e22"],"42009f1fefcc8f4d9e07b158e9415cbd6ca7247c":["a56a9893014b284af4d1af451e6c02e7ffdf5b6e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}