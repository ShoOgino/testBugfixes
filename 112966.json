{"path":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#resortSlots(Slot[]).mjava","commits":[{"id":"94ce69d020f939568b84a1dbbfbd11bfd9907b73","date":1543618146,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#resortSlots(Slot[]).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Helper method that resorts the slots (if needed).\n   * \n   * @return a SlotAcc that should be used {@link SlotAcc#setValues} on the final buckets via \n   *    {@link Slot#resortSlotNum} or null if no special SlotAcc was needed (ie: no resorting, or resorting \n   *    on something already known/collected)\n   */\n  private SlotAcc resortSlots(Slot[] slots) throws IOException {\n    if (null == this.resort) {\n      return null; // Nothing to do.\n    }\n    assert ! fcontext.isShard();\n\n    // NOTE: getMultiplier() is confusing and weird and ment for use in PriorityQueue.lessThan,\n    // so it's backwards from what you'd expect in a Comparator...\n    final int resortMul = -1 * resort.sortDirection.getMultiplier();\n    \n    SlotAcc resortAcc = getTrivialSortingSlotAcc(this.resort);\n    if (null != resortAcc) {\n      // resorting on count or index is rare (and not particularly useful) but if someone chooses to do\n      // either of these we don't need to re-collect ... instead just re-sort the slots based on\n      // the previously collected values using the originally collected slot numbers...\n      if (resortAcc.equals(countAcc)) {\n        final Comparator<Slot> comparator = null != indexOrderAcc ?\n          (new Comparator<Slot>() {\n            public int compare(Slot x, Slot y) {\n              final int cmp = resortMul * countAcc.compare(x.slot, y.slot);\n              return  cmp != 0 ? cmp : indexOrderAcc.compare(x.slot, y.slot);\n            }\n          })\n          : (new Comparator<Slot>() {\n            public int compare(Slot x, Slot y) {\n              final int cmp = resortMul * countAcc.compare(x.slot, y.slot);\n              return  cmp != 0 ? cmp : Integer.compare(x.slot, y.slot);\n            }\n          });\n        Arrays.sort(slots, comparator);\n        return null;\n      }\n      if (resortAcc.equals(indexOrderAcc)) {\n        // obviously indexOrderAcc is not null, and no need for a fancy tie breaker...\n        Arrays.sort(slots, new Comparator<Slot>() {\n          public int compare(Slot x, Slot y) {\n            return resortMul * indexOrderAcc.compare(x.slot, y.slot);\n          }\n        });\n        return null;\n      }\n      // nothing else should be possible\n      assert false : \"trivial resort isn't count or index: \" + this.resort;\n    }\n\n    assert null == resortAcc;\n    for (SlotAcc acc : otherAccs) {\n      if (acc.key.equals(this.resort.sortVariable)) {\n        resortAcc = acc;\n        break;\n      }\n    }\n    // TODO: what if resortAcc is still null, ie: bad input? ... throw an error?  (see SOLR-13022)\n    // looks like equivilent sort code path silently ignores sorting if sortVariable isn't in accMap...\n    // ...and we get a deffered NPE when trying to collect.\n    assert null != resortAcc;\n    \n    final SlotAcc acc = resortAcc;\n    \n    // reset resortAcc to be (just) big enough for all the slots we care about...\n    acc.reset();\n    acc.resize(new FlatteningResizer(slots.length));\n    \n    // give each existing Slot a new resortSlotNum and let the resortAcc collect it...\n    for (int slotNum = 0; slotNum < slots.length; slotNum++) {\n      Slot slot = slots[slotNum];\n      slot.resortSlotNum = slotNum;\n      \n      assert null != slot.bucketFilter : \"null filter for slot=\" +slot.bucketVal;\n      \n      final DocSet subDomain = fcontext.searcher.getDocSet(slot.bucketFilter, fcontext.base);\n      acc.collect(subDomain, slotNum, s -> { return new SlotContext(slot.bucketFilter); } );\n    }\n    \n    // now resort all the Slots according to the new collected values...\n    final Comparator<Slot> comparator = null != indexOrderAcc ?\n      (new Comparator<Slot>() {\n        public int compare(Slot x, Slot y) {\n          final int cmp = resortMul * acc.compare(x.resortSlotNum, y.resortSlotNum);\n          return  cmp != 0 ? cmp : indexOrderAcc.compare(x.slot, y.slot);\n        }\n      })\n      : (new Comparator<Slot>() {\n        public int compare(Slot x, Slot y) {\n          final int cmp = resortMul * acc.compare(x.resortSlotNum, y.resortSlotNum);\n          return  cmp != 0 ? cmp : Integer.compare(x.slot, y.slot);\n        }\n      });\n    Arrays.sort(slots, comparator);\n    return acc;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"94ce69d020f939568b84a1dbbfbd11bfd9907b73":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["94ce69d020f939568b84a1dbbfbd11bfd9907b73"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["94ce69d020f939568b84a1dbbfbd11bfd9907b73"],"94ce69d020f939568b84a1dbbfbd11bfd9907b73":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}