{"path":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,MultiDocValues.OrdinalMap).mjava","commits":[{"id":"9359ad4a5596673c3154ffa1133458f00e124234","date":1428012026,"type":0,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,MultiDocValues.OrdinalMap).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * A query time join using global ordinals over a dedicated join field.\n   *\n   * This join has certain restrictions and requirements:\n   * 1) A document can only refer to one other document. (but can be referred by one or more documents)\n   * 2) Documents on each side of the join must be distinguishable. Typically this can be done by adding an extra field\n   *    that identifies the \"from\" and \"to\" side and then the fromQuery and toQuery must take the this into account.\n   * 3) There must be a single sorted doc values join field used by both the \"from\" and \"to\" documents. This join field\n   *    should store the join values as UTF-8 strings.\n   * 4) An ordinal map must be provided that is created on top of the join field.\n   *\n   * @param joinField   The {@link org.apache.lucene.index.SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      MultiDocValues.OrdinalMap ordinalMap) throws IOException {\n    IndexReader indexReader = searcher.getIndexReader();\n    int numSegments = indexReader.leaves().size();\n    final long valueCount;\n    if (numSegments == 0) {\n      return new MatchNoDocsQuery();\n    } else if (numSegments == 1) {\n      // No need to use the ordinal map, because there is just one segment.\n      ordinalMap = null;\n      LeafReader leafReader = searcher.getIndexReader().leaves().get(0).reader();\n      SortedDocValues joinSortedDocValues = leafReader.getSortedDocValues(joinField);\n      if (joinSortedDocValues != null) {\n        valueCount = joinSortedDocValues.getValueCount();\n      } else {\n        return new MatchNoDocsQuery();\n      }\n    } else {\n      if (ordinalMap == null) {\n        throw new IllegalArgumentException(\"OrdinalMap is required, because there is more than 1 segment\");\n      }\n      valueCount = ordinalMap.getValueCount();\n    }\n\n    Query rewrittenFromQuery = searcher.rewrite(fromQuery);\n    if (scoreMode == ScoreMode.None) {\n      GlobalOrdinalsCollector globalOrdinalsCollector = new GlobalOrdinalsCollector(joinField, ordinalMap, valueCount);\n      searcher.search(fromQuery, globalOrdinalsCollector);\n      return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, toQuery, rewrittenFromQuery, indexReader);\n    }\n\n    GlobalOrdinalsWithScoreCollector globalOrdinalsWithScoreCollector;\n    switch (scoreMode) {\n      case Total:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Sum(joinField, ordinalMap, valueCount);\n        break;\n      case Max:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Max(joinField, ordinalMap, valueCount);\n        break;\n      case Avg:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Avg(joinField, ordinalMap, valueCount);\n        break;\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n    searcher.search(fromQuery, globalOrdinalsWithScoreCollector);\n    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, joinField, ordinalMap, toQuery, rewrittenFromQuery, indexReader);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","date":1428091986,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,MultiDocValues.OrdinalMap).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * A query time join using global ordinals over a dedicated join field.\n   *\n   * This join has certain restrictions and requirements:\n   * 1) A document can only refer to one other document. (but can be referred by one or more documents)\n   * 2) Documents on each side of the join must be distinguishable. Typically this can be done by adding an extra field\n   *    that identifies the \"from\" and \"to\" side and then the fromQuery and toQuery must take the this into account.\n   * 3) There must be a single sorted doc values join field used by both the \"from\" and \"to\" documents. This join field\n   *    should store the join values as UTF-8 strings.\n   * 4) An ordinal map must be provided that is created on top of the join field.\n   *\n   * @param joinField   The {@link org.apache.lucene.index.SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      MultiDocValues.OrdinalMap ordinalMap) throws IOException {\n    IndexReader indexReader = searcher.getIndexReader();\n    int numSegments = indexReader.leaves().size();\n    final long valueCount;\n    if (numSegments == 0) {\n      return new MatchNoDocsQuery();\n    } else if (numSegments == 1) {\n      // No need to use the ordinal map, because there is just one segment.\n      ordinalMap = null;\n      LeafReader leafReader = searcher.getIndexReader().leaves().get(0).reader();\n      SortedDocValues joinSortedDocValues = leafReader.getSortedDocValues(joinField);\n      if (joinSortedDocValues != null) {\n        valueCount = joinSortedDocValues.getValueCount();\n      } else {\n        return new MatchNoDocsQuery();\n      }\n    } else {\n      if (ordinalMap == null) {\n        throw new IllegalArgumentException(\"OrdinalMap is required, because there is more than 1 segment\");\n      }\n      valueCount = ordinalMap.getValueCount();\n    }\n\n    Query rewrittenFromQuery = searcher.rewrite(fromQuery);\n    if (scoreMode == ScoreMode.None) {\n      GlobalOrdinalsCollector globalOrdinalsCollector = new GlobalOrdinalsCollector(joinField, ordinalMap, valueCount);\n      searcher.search(fromQuery, globalOrdinalsCollector);\n      return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, toQuery, rewrittenFromQuery, indexReader);\n    }\n\n    GlobalOrdinalsWithScoreCollector globalOrdinalsWithScoreCollector;\n    switch (scoreMode) {\n      case Total:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Sum(joinField, ordinalMap, valueCount);\n        break;\n      case Max:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Max(joinField, ordinalMap, valueCount);\n        break;\n      case Avg:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Avg(joinField, ordinalMap, valueCount);\n        break;\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n    searcher.search(fromQuery, globalOrdinalsWithScoreCollector);\n    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, joinField, ordinalMap, toQuery, rewrittenFromQuery, indexReader);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe4b37941dda041ab19456b15412aacb9c657a26","date":1429449253,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,MultiDocValues.OrdinalMap).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,MultiDocValues.OrdinalMap).mjava","sourceNew":"  /**\n   * A query time join using global ordinals over a dedicated join field.\n   *\n   * This join has certain restrictions and requirements:\n   * 1) A document can only refer to one other document. (but can be referred by one or more documents)\n   * 2) Documents on each side of the join must be distinguishable. Typically this can be done by adding an extra field\n   *    that identifies the \"from\" and \"to\" side and then the fromQuery and toQuery must take the this into account.\n   * 3) There must be a single sorted doc values join field used by both the \"from\" and \"to\" documents. This join field\n   *    should store the join values as UTF-8 strings.\n   * 4) An ordinal map must be provided that is created on top of the join field.\n   *\n   * @param joinField   The {@link org.apache.lucene.index.SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      MultiDocValues.OrdinalMap ordinalMap) throws IOException {\n    IndexReader indexReader = searcher.getIndexReader();\n    int numSegments = indexReader.leaves().size();\n    final long valueCount;\n    if (numSegments == 0) {\n      return new MatchNoDocsQuery();\n    } else if (numSegments == 1) {\n      // No need to use the ordinal map, because there is just one segment.\n      ordinalMap = null;\n      LeafReader leafReader = searcher.getIndexReader().leaves().get(0).reader();\n      SortedDocValues joinSortedDocValues = leafReader.getSortedDocValues(joinField);\n      if (joinSortedDocValues != null) {\n        valueCount = joinSortedDocValues.getValueCount();\n      } else {\n        return new MatchNoDocsQuery();\n      }\n    } else {\n      if (ordinalMap == null) {\n        throw new IllegalArgumentException(\"OrdinalMap is required, because there is more than 1 segment\");\n      }\n      valueCount = ordinalMap.getValueCount();\n    }\n\n    final Query rewrittenFromQuery = searcher.rewrite(fromQuery);\n    if (scoreMode == ScoreMode.None) {\n      GlobalOrdinalsCollector globalOrdinalsCollector = new GlobalOrdinalsCollector(joinField, ordinalMap, valueCount);\n      searcher.search(rewrittenFromQuery, globalOrdinalsCollector);\n      return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, toQuery, rewrittenFromQuery, indexReader);\n    }\n\n    GlobalOrdinalsWithScoreCollector globalOrdinalsWithScoreCollector;\n    switch (scoreMode) {\n      case Total:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Sum(joinField, ordinalMap, valueCount);\n        break;\n      case Min:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Min(joinField, ordinalMap, valueCount);\n        break;\n      case Max:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Max(joinField, ordinalMap, valueCount);\n        break;\n      case Avg:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Avg(joinField, ordinalMap, valueCount);\n        break;\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n    searcher.search(rewrittenFromQuery, globalOrdinalsWithScoreCollector);\n    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, joinField, ordinalMap, toQuery, rewrittenFromQuery, indexReader);\n  }\n\n","sourceOld":"  /**\n   * A query time join using global ordinals over a dedicated join field.\n   *\n   * This join has certain restrictions and requirements:\n   * 1) A document can only refer to one other document. (but can be referred by one or more documents)\n   * 2) Documents on each side of the join must be distinguishable. Typically this can be done by adding an extra field\n   *    that identifies the \"from\" and \"to\" side and then the fromQuery and toQuery must take the this into account.\n   * 3) There must be a single sorted doc values join field used by both the \"from\" and \"to\" documents. This join field\n   *    should store the join values as UTF-8 strings.\n   * 4) An ordinal map must be provided that is created on top of the join field.\n   *\n   * @param joinField   The {@link org.apache.lucene.index.SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      MultiDocValues.OrdinalMap ordinalMap) throws IOException {\n    IndexReader indexReader = searcher.getIndexReader();\n    int numSegments = indexReader.leaves().size();\n    final long valueCount;\n    if (numSegments == 0) {\n      return new MatchNoDocsQuery();\n    } else if (numSegments == 1) {\n      // No need to use the ordinal map, because there is just one segment.\n      ordinalMap = null;\n      LeafReader leafReader = searcher.getIndexReader().leaves().get(0).reader();\n      SortedDocValues joinSortedDocValues = leafReader.getSortedDocValues(joinField);\n      if (joinSortedDocValues != null) {\n        valueCount = joinSortedDocValues.getValueCount();\n      } else {\n        return new MatchNoDocsQuery();\n      }\n    } else {\n      if (ordinalMap == null) {\n        throw new IllegalArgumentException(\"OrdinalMap is required, because there is more than 1 segment\");\n      }\n      valueCount = ordinalMap.getValueCount();\n    }\n\n    Query rewrittenFromQuery = searcher.rewrite(fromQuery);\n    if (scoreMode == ScoreMode.None) {\n      GlobalOrdinalsCollector globalOrdinalsCollector = new GlobalOrdinalsCollector(joinField, ordinalMap, valueCount);\n      searcher.search(fromQuery, globalOrdinalsCollector);\n      return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, toQuery, rewrittenFromQuery, indexReader);\n    }\n\n    GlobalOrdinalsWithScoreCollector globalOrdinalsWithScoreCollector;\n    switch (scoreMode) {\n      case Total:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Sum(joinField, ordinalMap, valueCount);\n        break;\n      case Max:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Max(joinField, ordinalMap, valueCount);\n        break;\n      case Avg:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Avg(joinField, ordinalMap, valueCount);\n        break;\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n    searcher.search(fromQuery, globalOrdinalsWithScoreCollector);\n    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, joinField, ordinalMap, toQuery, rewrittenFromQuery, indexReader);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9a8ccb9d7a971a53ccd8bc3d8230590bca107c51","date":1431446228,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,MultiDocValues.OrdinalMap).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,MultiDocValues.OrdinalMap).mjava","sourceNew":"  /**\n   * Delegates to {@link #createJoinQuery(String, Query, Query, IndexSearcher, ScoreMode, MultiDocValues.OrdinalMap, int, int)},\n   * but disables the min and max filtering.\n   *\n   * @param joinField   The {@link SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      MultiDocValues.OrdinalMap ordinalMap) throws IOException {\n    return createJoinQuery(joinField, fromQuery, toQuery, searcher, scoreMode, ordinalMap, 0, Integer.MAX_VALUE);\n  }\n\n","sourceOld":"  /**\n   * A query time join using global ordinals over a dedicated join field.\n   *\n   * This join has certain restrictions and requirements:\n   * 1) A document can only refer to one other document. (but can be referred by one or more documents)\n   * 2) Documents on each side of the join must be distinguishable. Typically this can be done by adding an extra field\n   *    that identifies the \"from\" and \"to\" side and then the fromQuery and toQuery must take the this into account.\n   * 3) There must be a single sorted doc values join field used by both the \"from\" and \"to\" documents. This join field\n   *    should store the join values as UTF-8 strings.\n   * 4) An ordinal map must be provided that is created on top of the join field.\n   *\n   * @param joinField   The {@link org.apache.lucene.index.SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      MultiDocValues.OrdinalMap ordinalMap) throws IOException {\n    IndexReader indexReader = searcher.getIndexReader();\n    int numSegments = indexReader.leaves().size();\n    final long valueCount;\n    if (numSegments == 0) {\n      return new MatchNoDocsQuery();\n    } else if (numSegments == 1) {\n      // No need to use the ordinal map, because there is just one segment.\n      ordinalMap = null;\n      LeafReader leafReader = searcher.getIndexReader().leaves().get(0).reader();\n      SortedDocValues joinSortedDocValues = leafReader.getSortedDocValues(joinField);\n      if (joinSortedDocValues != null) {\n        valueCount = joinSortedDocValues.getValueCount();\n      } else {\n        return new MatchNoDocsQuery();\n      }\n    } else {\n      if (ordinalMap == null) {\n        throw new IllegalArgumentException(\"OrdinalMap is required, because there is more than 1 segment\");\n      }\n      valueCount = ordinalMap.getValueCount();\n    }\n\n    final Query rewrittenFromQuery = searcher.rewrite(fromQuery);\n    if (scoreMode == ScoreMode.None) {\n      GlobalOrdinalsCollector globalOrdinalsCollector = new GlobalOrdinalsCollector(joinField, ordinalMap, valueCount);\n      searcher.search(rewrittenFromQuery, globalOrdinalsCollector);\n      return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, toQuery, rewrittenFromQuery, indexReader);\n    }\n\n    GlobalOrdinalsWithScoreCollector globalOrdinalsWithScoreCollector;\n    switch (scoreMode) {\n      case Total:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Sum(joinField, ordinalMap, valueCount);\n        break;\n      case Min:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Min(joinField, ordinalMap, valueCount);\n        break;\n      case Max:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Max(joinField, ordinalMap, valueCount);\n        break;\n      case Avg:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Avg(joinField, ordinalMap, valueCount);\n        break;\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n    searcher.search(rewrittenFromQuery, globalOrdinalsWithScoreCollector);\n    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, joinField, ordinalMap, toQuery, rewrittenFromQuery, indexReader);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"957c610636f393a85a38f1af670540028db13e6b","date":1500044517,"type":5,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,OrdinalMap).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,MultiDocValues.OrdinalMap).mjava","sourceNew":"  /**\n   * Delegates to {@link #createJoinQuery(String, Query, Query, IndexSearcher, ScoreMode, OrdinalMap, int, int)},\n   * but disables the min and max filtering.\n   *\n   * @param joinField   The {@link SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      OrdinalMap ordinalMap) throws IOException {\n    return createJoinQuery(joinField, fromQuery, toQuery, searcher, scoreMode, ordinalMap, 0, Integer.MAX_VALUE);\n  }\n\n","sourceOld":"  /**\n   * Delegates to {@link #createJoinQuery(String, Query, Query, IndexSearcher, ScoreMode, MultiDocValues.OrdinalMap, int, int)},\n   * but disables the min and max filtering.\n   *\n   * @param joinField   The {@link SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      MultiDocValues.OrdinalMap ordinalMap) throws IOException {\n    return createJoinQuery(joinField, fromQuery, toQuery, searcher, scoreMode, ordinalMap, 0, Integer.MAX_VALUE);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aaf90fc29510e72665ac7934f34c3d1c25efad64","date":1500354819,"type":5,"author":"Cao Manh Dat","isMerge":true,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,OrdinalMap).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,MultiDocValues.OrdinalMap).mjava","sourceNew":"  /**\n   * Delegates to {@link #createJoinQuery(String, Query, Query, IndexSearcher, ScoreMode, OrdinalMap, int, int)},\n   * but disables the min and max filtering.\n   *\n   * @param joinField   The {@link SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      OrdinalMap ordinalMap) throws IOException {\n    return createJoinQuery(joinField, fromQuery, toQuery, searcher, scoreMode, ordinalMap, 0, Integer.MAX_VALUE);\n  }\n\n","sourceOld":"  /**\n   * Delegates to {@link #createJoinQuery(String, Query, Query, IndexSearcher, ScoreMode, MultiDocValues.OrdinalMap, int, int)},\n   * but disables the min and max filtering.\n   *\n   * @param joinField   The {@link SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      MultiDocValues.OrdinalMap ordinalMap) throws IOException {\n    return createJoinQuery(joinField, fromQuery, toQuery, searcher, scoreMode, ordinalMap, 0, Integer.MAX_VALUE);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"957c610636f393a85a38f1af670540028db13e6b":["9a8ccb9d7a971a53ccd8bc3d8230590bca107c51"],"9359ad4a5596673c3154ffa1133458f00e124234":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"aaf90fc29510e72665ac7934f34c3d1c25efad64":["9a8ccb9d7a971a53ccd8bc3d8230590bca107c51","957c610636f393a85a38f1af670540028db13e6b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9359ad4a5596673c3154ffa1133458f00e124234"],"fe4b37941dda041ab19456b15412aacb9c657a26":["9359ad4a5596673c3154ffa1133458f00e124234"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["957c610636f393a85a38f1af670540028db13e6b"],"9a8ccb9d7a971a53ccd8bc3d8230590bca107c51":["fe4b37941dda041ab19456b15412aacb9c657a26"]},"commit2Childs":{"957c610636f393a85a38f1af670540028db13e6b":["aaf90fc29510e72665ac7934f34c3d1c25efad64","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9359ad4a5596673c3154ffa1133458f00e124234":["6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","fe4b37941dda041ab19456b15412aacb9c657a26"],"aaf90fc29510e72665ac7934f34c3d1c25efad64":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9359ad4a5596673c3154ffa1133458f00e124234","6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c"],"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c":[],"fe4b37941dda041ab19456b15412aacb9c657a26":["9a8ccb9d7a971a53ccd8bc3d8230590bca107c51"],"9a8ccb9d7a971a53ccd8bc3d8230590bca107c51":["957c610636f393a85a38f1af670540028db13e6b","aaf90fc29510e72665ac7934f34c3d1c25efad64"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aaf90fc29510e72665ac7934f34c3d1c25efad64","6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}