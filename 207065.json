{"path":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#getCollectionStates().mjava","commits":[{"id":"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5","date":1556572478,"type":1,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#getCollectionStates().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#getCollectionStates().mjava","sourceNew":"  // this method uses a simple cache in collectionsStatesRef. Operations that modify\n  // cluster state should always reset this cache so that the changes become visible\n  private Map<String, DocCollection> getCollectionStates() throws IOException, InterruptedException {\n    lock.lockInterruptibly();\n    try {\n      Map<String, DocCollection> collectionStates = collectionsStatesRef.get();\n      if (collectionStates != null) {\n        return collectionStates;\n      }\n      collectionsStatesRef.set(null);\n      log.debug(\"** creating new collection states, currentVersion={}\", clusterStateVersion);\n      Map<String, Map<String, Map<String, Replica>>> collMap = new HashMap<>();\n      nodeReplicaMap.forEach((n, replicas) -> {\n          synchronized (replicas) {\n            replicas.forEach(ri -> {\n                Map<String, Object> props;\n                synchronized (ri) {\n                  props = new HashMap<>(ri.getVariables());\n                }\n                props.put(ZkStateReader.NODE_NAME_PROP, n);\n                props.put(ZkStateReader.CORE_NAME_PROP, ri.getCore());\n                props.put(ZkStateReader.REPLICA_TYPE, ri.getType().toString());\n                props.put(ZkStateReader.STATE_PROP, ri.getState().toString());\n                Replica r = new Replica(ri.getName(), props);\n                collMap.computeIfAbsent(ri.getCollection(), c -> new HashMap<>())\n                  .computeIfAbsent(ri.getShard(), s -> new HashMap<>())\n                  .put(ri.getName(), r);\n              });\n          }\n        });\n\n      // add empty slices\n      sliceProperties.forEach((c, perSliceProps) -> {\n        perSliceProps.forEach((slice, props) -> {\n          collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>()).computeIfAbsent(slice, s -> new ConcurrentHashMap<>());\n        });\n      });\n      // add empty collections\n      collProperties.keySet().forEach(c -> {\n        collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>());\n      });\n\n      Map<String, DocCollection> res = new HashMap<>();\n      collMap.forEach((coll, shards) -> {\n        Map<String, Slice> slices = new HashMap<>();\n        shards.forEach((s, replicas) -> {\n          Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll, c -> new ConcurrentHashMap<>()).computeIfAbsent(s, sl -> new ConcurrentHashMap<>());\n          Slice slice = new Slice(s, replicas, sliceProps);\n          slices.put(s, slice);\n        });\n        Map<String, Object> collProps = collProperties.computeIfAbsent(coll, c -> new ConcurrentHashMap<>());\n        Map<String, Object> routerProp = (Map<String, Object>) collProps.getOrDefault(DocCollection.DOC_ROUTER, Collections.singletonMap(\"name\", DocRouter.DEFAULT_NAME));\n        DocRouter router = DocRouter.getDocRouter((String)routerProp.getOrDefault(\"name\", DocRouter.DEFAULT_NAME));\n        DocCollection dc = new DocCollection(coll, slices, collProps, router, clusterStateVersion, ZkStateReader.CLUSTER_STATE);\n        res.put(coll, dc);\n      });\n      saveClusterState(new ClusterState(clusterStateVersion, liveNodes.get(), res));\n      collectionsStatesRef.set(res);\n      return res;\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  // this method uses a simple cache in collectionsStatesRef. Operations that modify\n  // cluster state should always reset this cache so that the changes become visible\n  private Map<String, DocCollection> getCollectionStates() throws IOException, InterruptedException {\n    lock.lockInterruptibly();\n    try {\n      Map<String, DocCollection> collectionStates = collectionsStatesRef.get();\n      if (collectionStates != null) {\n        return collectionStates;\n      }\n      collectionsStatesRef.set(null);\n      log.debug(\"** creating new collection states, currentVersion={}\", clusterStateVersion);\n      Map<String, Map<String, Map<String, Replica>>> collMap = new HashMap<>();\n      nodeReplicaMap.forEach((n, replicas) -> {\n          synchronized (replicas) {\n            replicas.forEach(ri -> {\n                Map<String, Object> props;\n                synchronized (ri) {\n                  props = new HashMap<>(ri.getVariables());\n                }\n                props.put(ZkStateReader.NODE_NAME_PROP, n);\n                props.put(ZkStateReader.CORE_NAME_PROP, ri.getCore());\n                props.put(ZkStateReader.REPLICA_TYPE, ri.getType().toString());\n                props.put(ZkStateReader.STATE_PROP, ri.getState().toString());\n                Replica r = new Replica(ri.getName(), props);\n                collMap.computeIfAbsent(ri.getCollection(), c -> new HashMap<>())\n                  .computeIfAbsent(ri.getShard(), s -> new HashMap<>())\n                  .put(ri.getName(), r);\n              });\n          }\n        });\n\n      // add empty slices\n      sliceProperties.forEach((c, perSliceProps) -> {\n        perSliceProps.forEach((slice, props) -> {\n          collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>()).computeIfAbsent(slice, s -> new ConcurrentHashMap<>());\n        });\n      });\n      // add empty collections\n      collProperties.keySet().forEach(c -> {\n        collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>());\n      });\n\n      Map<String, DocCollection> res = new HashMap<>();\n      collMap.forEach((coll, shards) -> {\n        Map<String, Slice> slices = new HashMap<>();\n        shards.forEach((s, replicas) -> {\n          Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll, c -> new ConcurrentHashMap<>()).computeIfAbsent(s, sl -> new ConcurrentHashMap<>());\n          Slice slice = new Slice(s, replicas, sliceProps);\n          slices.put(s, slice);\n        });\n        Map<String, Object> collProps = collProperties.computeIfAbsent(coll, c -> new ConcurrentHashMap<>());\n        Map<String, Object> routerProp = (Map<String, Object>) collProps.getOrDefault(DocCollection.DOC_ROUTER, Collections.singletonMap(\"name\", DocRouter.DEFAULT_NAME));\n        DocRouter router = DocRouter.getDocRouter((String)routerProp.getOrDefault(\"name\", DocRouter.DEFAULT_NAME));\n        DocCollection dc = new DocCollection(coll, slices, collProps, router, clusterStateVersion, ZkStateReader.CLUSTER_STATE);\n        res.put(coll, dc);\n      });\n      saveClusterState(new ClusterState(clusterStateVersion, liveNodes.get(), res));\n      collectionsStatesRef.set(res);\n      return res;\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6681d02f2302c363be938426e68f8dfd090cc1bf","date":1575339019,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#getCollectionStates().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#getCollectionStates().mjava","sourceNew":"  // this method uses a simple cache in collectionsStatesRef. Operations that modify\n  // cluster state should always reset this cache so that the changes become visible\n  private Map<String, DocCollection> getCollectionStates() throws IOException, InterruptedException {\n    lock.lockInterruptibly();\n    try {\n      Map<String, DocCollection> collectionStates = collectionsStatesRef.get();\n      if (collectionStates != null) {\n        return collectionStates;\n      }\n      collectionsStatesRef.set(null);\n      log.debug(\"** creating new collection states, currentVersion={}\", clusterStateVersion);\n      Map<String, Map<String, Map<String, Replica>>> collMap = new HashMap<>();\n      nodeReplicaMap.forEach((n, replicas) -> {\n          synchronized (replicas) {\n            replicas.forEach(ri -> {\n                Map<String, Object> props;\n                synchronized (ri) {\n                  props = new HashMap<>(ri.getVariables());\n                }\n                props.put(ZkStateReader.NODE_NAME_PROP, n);\n                props.put(ZkStateReader.CORE_NAME_PROP, ri.getCore());\n                props.put(ZkStateReader.REPLICA_TYPE, ri.getType().toString());\n                props.put(ZkStateReader.STATE_PROP, ri.getState().toString());\n                Replica r = new Replica(ri.getName(), props, ri.getCollection(), ri.getShard());\n                collMap.computeIfAbsent(ri.getCollection(), c -> new HashMap<>())\n                  .computeIfAbsent(ri.getShard(), s -> new HashMap<>())\n                  .put(ri.getName(), r);\n              });\n          }\n        });\n\n      // add empty slices\n      sliceProperties.forEach((c, perSliceProps) -> {\n        perSliceProps.forEach((slice, props) -> {\n          collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>()).computeIfAbsent(slice, s -> new ConcurrentHashMap<>());\n        });\n      });\n      // add empty collections\n      collProperties.keySet().forEach(c -> {\n        collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>());\n      });\n\n      Map<String, DocCollection> res = new HashMap<>();\n      collMap.forEach((coll, shards) -> {\n        Map<String, Slice> slices = new HashMap<>();\n        shards.forEach((s, replicas) -> {\n          Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll, c -> new ConcurrentHashMap<>()).computeIfAbsent(s, sl -> new ConcurrentHashMap<>());\n          Slice slice = new Slice(s, replicas, sliceProps, coll);\n          slices.put(s, slice);\n        });\n        Map<String, Object> collProps = collProperties.computeIfAbsent(coll, c -> new ConcurrentHashMap<>());\n        Map<String, Object> routerProp = (Map<String, Object>) collProps.getOrDefault(DocCollection.DOC_ROUTER, Collections.singletonMap(\"name\", DocRouter.DEFAULT_NAME));\n        DocRouter router = DocRouter.getDocRouter((String)routerProp.getOrDefault(\"name\", DocRouter.DEFAULT_NAME));\n        DocCollection dc = new DocCollection(coll, slices, collProps, router, clusterStateVersion, ZkStateReader.CLUSTER_STATE);\n        res.put(coll, dc);\n      });\n      saveClusterState(new ClusterState(clusterStateVersion, liveNodes.get(), res));\n      collectionsStatesRef.set(res);\n      return res;\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  // this method uses a simple cache in collectionsStatesRef. Operations that modify\n  // cluster state should always reset this cache so that the changes become visible\n  private Map<String, DocCollection> getCollectionStates() throws IOException, InterruptedException {\n    lock.lockInterruptibly();\n    try {\n      Map<String, DocCollection> collectionStates = collectionsStatesRef.get();\n      if (collectionStates != null) {\n        return collectionStates;\n      }\n      collectionsStatesRef.set(null);\n      log.debug(\"** creating new collection states, currentVersion={}\", clusterStateVersion);\n      Map<String, Map<String, Map<String, Replica>>> collMap = new HashMap<>();\n      nodeReplicaMap.forEach((n, replicas) -> {\n          synchronized (replicas) {\n            replicas.forEach(ri -> {\n                Map<String, Object> props;\n                synchronized (ri) {\n                  props = new HashMap<>(ri.getVariables());\n                }\n                props.put(ZkStateReader.NODE_NAME_PROP, n);\n                props.put(ZkStateReader.CORE_NAME_PROP, ri.getCore());\n                props.put(ZkStateReader.REPLICA_TYPE, ri.getType().toString());\n                props.put(ZkStateReader.STATE_PROP, ri.getState().toString());\n                Replica r = new Replica(ri.getName(), props);\n                collMap.computeIfAbsent(ri.getCollection(), c -> new HashMap<>())\n                  .computeIfAbsent(ri.getShard(), s -> new HashMap<>())\n                  .put(ri.getName(), r);\n              });\n          }\n        });\n\n      // add empty slices\n      sliceProperties.forEach((c, perSliceProps) -> {\n        perSliceProps.forEach((slice, props) -> {\n          collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>()).computeIfAbsent(slice, s -> new ConcurrentHashMap<>());\n        });\n      });\n      // add empty collections\n      collProperties.keySet().forEach(c -> {\n        collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>());\n      });\n\n      Map<String, DocCollection> res = new HashMap<>();\n      collMap.forEach((coll, shards) -> {\n        Map<String, Slice> slices = new HashMap<>();\n        shards.forEach((s, replicas) -> {\n          Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll, c -> new ConcurrentHashMap<>()).computeIfAbsent(s, sl -> new ConcurrentHashMap<>());\n          Slice slice = new Slice(s, replicas, sliceProps);\n          slices.put(s, slice);\n        });\n        Map<String, Object> collProps = collProperties.computeIfAbsent(coll, c -> new ConcurrentHashMap<>());\n        Map<String, Object> routerProp = (Map<String, Object>) collProps.getOrDefault(DocCollection.DOC_ROUTER, Collections.singletonMap(\"name\", DocRouter.DEFAULT_NAME));\n        DocRouter router = DocRouter.getDocRouter((String)routerProp.getOrDefault(\"name\", DocRouter.DEFAULT_NAME));\n        DocCollection dc = new DocCollection(coll, slices, collProps, router, clusterStateVersion, ZkStateReader.CLUSTER_STATE);\n        res.put(coll, dc);\n      });\n      saveClusterState(new ClusterState(clusterStateVersion, liveNodes.get(), res));\n      collectionsStatesRef.set(res);\n      return res;\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3aa683bba99315838c968fefedf3d74f44aa993","date":1575395112,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#getCollectionStates().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#getCollectionStates().mjava","sourceNew":"  // this method uses a simple cache in collectionsStatesRef. Operations that modify\n  // cluster state should always reset this cache so that the changes become visible\n  private Map<String, DocCollection> getCollectionStates() throws IOException, InterruptedException {\n    lock.lockInterruptibly();\n    try {\n      Map<String, DocCollection> collectionStates = collectionsStatesRef.get();\n      if (collectionStates != null) {\n        return collectionStates;\n      }\n      collectionsStatesRef.set(null);\n      log.debug(\"** creating new collection states, currentVersion={}\", clusterStateVersion);\n      Map<String, Map<String, Map<String, Replica>>> collMap = new HashMap<>();\n      nodeReplicaMap.forEach((n, replicas) -> {\n          synchronized (replicas) {\n            replicas.forEach(ri -> {\n                Map<String, Object> props;\n                synchronized (ri) {\n                  props = new HashMap<>(ri.getVariables());\n                }\n                props.put(ZkStateReader.NODE_NAME_PROP, n);\n                props.put(ZkStateReader.CORE_NAME_PROP, ri.getCore());\n                props.put(ZkStateReader.REPLICA_TYPE, ri.getType().toString());\n                props.put(ZkStateReader.STATE_PROP, ri.getState().toString());\n                Replica r = new Replica(ri.getName(), props, ri.getCollection(), ri.getShard());\n                collMap.computeIfAbsent(ri.getCollection(), c -> new HashMap<>())\n                  .computeIfAbsent(ri.getShard(), s -> new HashMap<>())\n                  .put(ri.getName(), r);\n              });\n          }\n        });\n\n      // add empty slices\n      sliceProperties.forEach((c, perSliceProps) -> {\n        perSliceProps.forEach((slice, props) -> {\n          collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>()).computeIfAbsent(slice, s -> new ConcurrentHashMap<>());\n        });\n      });\n      // add empty collections\n      collProperties.keySet().forEach(c -> {\n        collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>());\n      });\n\n      Map<String, DocCollection> res = new HashMap<>();\n      collMap.forEach((coll, shards) -> {\n        Map<String, Slice> slices = new HashMap<>();\n        shards.forEach((s, replicas) -> {\n          Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll, c -> new ConcurrentHashMap<>()).computeIfAbsent(s, sl -> new ConcurrentHashMap<>());\n          Slice slice = new Slice(s, replicas, sliceProps, coll);\n          slices.put(s, slice);\n        });\n        Map<String, Object> collProps = collProperties.computeIfAbsent(coll, c -> new ConcurrentHashMap<>());\n        Map<String, Object> routerProp = (Map<String, Object>) collProps.getOrDefault(DocCollection.DOC_ROUTER, Collections.singletonMap(\"name\", DocRouter.DEFAULT_NAME));\n        DocRouter router = DocRouter.getDocRouter((String)routerProp.getOrDefault(\"name\", DocRouter.DEFAULT_NAME));\n        DocCollection dc = new DocCollection(coll, slices, collProps, router, clusterStateVersion, ZkStateReader.CLUSTER_STATE);\n        res.put(coll, dc);\n      });\n      saveClusterState(new ClusterState(clusterStateVersion, liveNodes.get(), res));\n      collectionsStatesRef.set(res);\n      return res;\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  // this method uses a simple cache in collectionsStatesRef. Operations that modify\n  // cluster state should always reset this cache so that the changes become visible\n  private Map<String, DocCollection> getCollectionStates() throws IOException, InterruptedException {\n    lock.lockInterruptibly();\n    try {\n      Map<String, DocCollection> collectionStates = collectionsStatesRef.get();\n      if (collectionStates != null) {\n        return collectionStates;\n      }\n      collectionsStatesRef.set(null);\n      log.debug(\"** creating new collection states, currentVersion={}\", clusterStateVersion);\n      Map<String, Map<String, Map<String, Replica>>> collMap = new HashMap<>();\n      nodeReplicaMap.forEach((n, replicas) -> {\n          synchronized (replicas) {\n            replicas.forEach(ri -> {\n                Map<String, Object> props;\n                synchronized (ri) {\n                  props = new HashMap<>(ri.getVariables());\n                }\n                props.put(ZkStateReader.NODE_NAME_PROP, n);\n                props.put(ZkStateReader.CORE_NAME_PROP, ri.getCore());\n                props.put(ZkStateReader.REPLICA_TYPE, ri.getType().toString());\n                props.put(ZkStateReader.STATE_PROP, ri.getState().toString());\n                Replica r = new Replica(ri.getName(), props);\n                collMap.computeIfAbsent(ri.getCollection(), c -> new HashMap<>())\n                  .computeIfAbsent(ri.getShard(), s -> new HashMap<>())\n                  .put(ri.getName(), r);\n              });\n          }\n        });\n\n      // add empty slices\n      sliceProperties.forEach((c, perSliceProps) -> {\n        perSliceProps.forEach((slice, props) -> {\n          collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>()).computeIfAbsent(slice, s -> new ConcurrentHashMap<>());\n        });\n      });\n      // add empty collections\n      collProperties.keySet().forEach(c -> {\n        collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>());\n      });\n\n      Map<String, DocCollection> res = new HashMap<>();\n      collMap.forEach((coll, shards) -> {\n        Map<String, Slice> slices = new HashMap<>();\n        shards.forEach((s, replicas) -> {\n          Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll, c -> new ConcurrentHashMap<>()).computeIfAbsent(s, sl -> new ConcurrentHashMap<>());\n          Slice slice = new Slice(s, replicas, sliceProps);\n          slices.put(s, slice);\n        });\n        Map<String, Object> collProps = collProperties.computeIfAbsent(coll, c -> new ConcurrentHashMap<>());\n        Map<String, Object> routerProp = (Map<String, Object>) collProps.getOrDefault(DocCollection.DOC_ROUTER, Collections.singletonMap(\"name\", DocRouter.DEFAULT_NAME));\n        DocRouter router = DocRouter.getDocRouter((String)routerProp.getOrDefault(\"name\", DocRouter.DEFAULT_NAME));\n        DocCollection dc = new DocCollection(coll, slices, collProps, router, clusterStateVersion, ZkStateReader.CLUSTER_STATE);\n        res.put(coll, dc);\n      });\n      saveClusterState(new ClusterState(clusterStateVersion, liveNodes.get(), res));\n      collectionsStatesRef.set(res);\n      return res;\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eb7a329be123e1f46f9d78d74f6d23f33ec81b0a","date":1589907167,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#getCollectionStates().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#getCollectionStates().mjava","sourceNew":"  private Map<String, DocCollection> getCollectionStates() throws IOException, InterruptedException {\n    lock.lockInterruptibly();\n    try {\n      Map<String, DocCollection> collectionStates = new HashMap<>();\n      collectionsStatesRef.forEach((name, cached) -> {\n        try {\n          collectionStates.put(name, cached.getColl());\n        } catch (Exception e) {\n          throw new RuntimeException(\"error building collection \" + name + \" state\", e);\n        }\n      });\n      return collectionStates;\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  // this method uses a simple cache in collectionsStatesRef. Operations that modify\n  // cluster state should always reset this cache so that the changes become visible\n  private Map<String, DocCollection> getCollectionStates() throws IOException, InterruptedException {\n    lock.lockInterruptibly();\n    try {\n      Map<String, DocCollection> collectionStates = collectionsStatesRef.get();\n      if (collectionStates != null) {\n        return collectionStates;\n      }\n      collectionsStatesRef.set(null);\n      log.debug(\"** creating new collection states, currentVersion={}\", clusterStateVersion);\n      Map<String, Map<String, Map<String, Replica>>> collMap = new HashMap<>();\n      nodeReplicaMap.forEach((n, replicas) -> {\n          synchronized (replicas) {\n            replicas.forEach(ri -> {\n                Map<String, Object> props;\n                synchronized (ri) {\n                  props = new HashMap<>(ri.getVariables());\n                }\n                props.put(ZkStateReader.NODE_NAME_PROP, n);\n                props.put(ZkStateReader.CORE_NAME_PROP, ri.getCore());\n                props.put(ZkStateReader.REPLICA_TYPE, ri.getType().toString());\n                props.put(ZkStateReader.STATE_PROP, ri.getState().toString());\n                Replica r = new Replica(ri.getName(), props, ri.getCollection(), ri.getShard());\n                collMap.computeIfAbsent(ri.getCollection(), c -> new HashMap<>())\n                  .computeIfAbsent(ri.getShard(), s -> new HashMap<>())\n                  .put(ri.getName(), r);\n              });\n          }\n        });\n\n      // add empty slices\n      sliceProperties.forEach((c, perSliceProps) -> {\n        perSliceProps.forEach((slice, props) -> {\n          collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>()).computeIfAbsent(slice, s -> new ConcurrentHashMap<>());\n        });\n      });\n      // add empty collections\n      collProperties.keySet().forEach(c -> {\n        collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>());\n      });\n\n      Map<String, DocCollection> res = new HashMap<>();\n      collMap.forEach((coll, shards) -> {\n        Map<String, Slice> slices = new HashMap<>();\n        shards.forEach((s, replicas) -> {\n          Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll, c -> new ConcurrentHashMap<>()).computeIfAbsent(s, sl -> new ConcurrentHashMap<>());\n          Slice slice = new Slice(s, replicas, sliceProps, coll);\n          slices.put(s, slice);\n        });\n        Map<String, Object> collProps = collProperties.computeIfAbsent(coll, c -> new ConcurrentHashMap<>());\n        Map<String, Object> routerProp = (Map<String, Object>) collProps.getOrDefault(DocCollection.DOC_ROUTER, Collections.singletonMap(\"name\", DocRouter.DEFAULT_NAME));\n        DocRouter router = DocRouter.getDocRouter((String)routerProp.getOrDefault(\"name\", DocRouter.DEFAULT_NAME));\n        DocCollection dc = new DocCollection(coll, slices, collProps, router, clusterStateVersion, ZkStateReader.CLUSTER_STATE);\n        res.put(coll, dc);\n      });\n      saveClusterState(new ClusterState(clusterStateVersion, liveNodes.get(), res));\n      collectionsStatesRef.set(res);\n      return res;\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#getCollectionStates().mjava","sourceNew":null,"sourceOld":"  private Map<String, DocCollection> getCollectionStates() throws IOException, InterruptedException {\n    lock.lockInterruptibly();\n    try {\n      Map<String, DocCollection> collectionStates = new HashMap<>();\n      collectionsStatesRef.forEach((name, cached) -> {\n        try {\n          collectionStates.put(name, cached.getColl());\n        } catch (Exception e) {\n          throw new RuntimeException(\"error building collection \" + name + \" state\", e);\n        }\n      });\n      return collectionStates;\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3aa683bba99315838c968fefedf3d74f44aa993":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5","6681d02f2302c363be938426e68f8dfd090cc1bf"],"3f504512a03d978990cbff30db0522b354e846db":["eb7a329be123e1f46f9d78d74f6d23f33ec81b0a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"eb7a329be123e1f46f9d78d74f6d23f33ec81b0a":["6681d02f2302c363be938426e68f8dfd090cc1bf"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"],"6681d02f2302c363be938426e68f8dfd090cc1bf":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"]},"commit2Childs":{"d3aa683bba99315838c968fefedf3d74f44aa993":[],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["d3aa683bba99315838c968fefedf3d74f44aa993","6681d02f2302c363be938426e68f8dfd090cc1bf"],"eb7a329be123e1f46f9d78d74f6d23f33ec81b0a":["3f504512a03d978990cbff30db0522b354e846db"],"6681d02f2302c363be938426e68f8dfd090cc1bf":["d3aa683bba99315838c968fefedf3d74f44aa993","eb7a329be123e1f46f9d78d74f6d23f33ec81b0a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3aa683bba99315838c968fefedf3d74f44aa993","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}