{"path":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#sort(String).mjava","commits":[{"id":"867e3d9153fb761456b54a9dcce566e1545c5ef6","date":1444903098,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#sort(String).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Sort input to a new temp file, returning its name.\n   */\n  public String sort(String inputFileName) throws IOException {\n    \n    sortInfo = new SortInfo();\n    sortInfo.totalTime = System.currentTimeMillis();\n\n    List<String> segments = new ArrayList<>();\n\n    // So we can remove any partially written temp files on exception:\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n\n    boolean success = false;\n    try (ByteSequencesReader is = new ByteSequencesReader(dir.openInput(inputFileName, IOContext.READONCE))) {\n\n      int lineCount;\n      while ((lineCount = readPartition(is)) > 0) {\n        segments.add(sortPartition(trackingDir));\n        sortInfo.tempMergeFiles++;\n        sortInfo.lineCount += lineCount;\n\n        // Handle intermediate merges.\n        if (segments.size() == maxTempFiles) {\n          mergePartitions(trackingDir, segments);\n        }\n      }\n\n      // Merge the partitions to the output file with a priority queue.\n      if (segments.size() > 1) {     \n        mergePartitions(trackingDir, segments);\n      }\n\n      String result;\n      if (segments.isEmpty()) {\n        try (IndexOutput out = trackingDir.createTempOutput(tempFileNamePrefix, \"sort\", IOContext.DEFAULT)) {\n          result = out.getName();\n        }\n      } else {\n        result = segments.get(0);\n      }\n\n      // We should be explicitly removing all intermediate files ourselves unless there is an exception:\n      assert trackingDir.getCreatedFiles().size() == 1 && trackingDir.getCreatedFiles().contains(result);\n\n      sortInfo.totalTime = (System.currentTimeMillis() - sortInfo.totalTime); \n      success = true;\n\n      return result;\n\n    } finally {\n      if (success == false) {\n        IOUtils.deleteFilesIgnoringExceptions(trackingDir, trackingDir.getCreatedFiles());\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["9ce0dc549cffe574c5e49b654c95a60713e0453c","2b84d416bbd661ae4b2a28d103bdfccb851e00de"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e3ce1ef883d26aa73919aa2d53991726e96caa13","date":1445421402,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#sort(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#sort(String).mjava","sourceNew":"  /** \n   * Sort input to a new temp file, returning its name.\n   */\n  public String sort(String inputFileName) throws IOException {\n    \n    sortInfo = new SortInfo();\n    sortInfo.totalTime = System.currentTimeMillis();\n\n    List<String> segments = new ArrayList<>();\n\n    // So we can remove any partially written temp files on exception:\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n\n    boolean success = false;\n    try (ByteSequencesReader is = getReader(dir.openInput(inputFileName, IOContext.READONCE))) {\n\n      int lineCount;\n      while ((lineCount = readPartition(is)) > 0) {\n        segments.add(sortPartition(trackingDir));\n        sortInfo.tempMergeFiles++;\n        sortInfo.lineCount += lineCount;\n\n        // Handle intermediate merges.\n        if (segments.size() == maxTempFiles) {\n          mergePartitions(trackingDir, segments);\n        }\n      }\n\n      // Merge the partitions to the output file with a priority queue.\n      if (segments.size() > 1) {     \n        mergePartitions(trackingDir, segments);\n      }\n\n      String result;\n      if (segments.isEmpty()) {\n        try (IndexOutput out = trackingDir.createTempOutput(tempFileNamePrefix, \"sort\", IOContext.DEFAULT)) {\n          result = out.getName();\n        }\n      } else {\n        result = segments.get(0);\n      }\n\n      // We should be explicitly removing all intermediate files ourselves unless there is an exception:\n      assert trackingDir.getCreatedFiles().size() == 1 && trackingDir.getCreatedFiles().contains(result);\n\n      sortInfo.totalTime = (System.currentTimeMillis() - sortInfo.totalTime); \n      success = true;\n\n      return result;\n\n    } finally {\n      if (success == false) {\n        IOUtils.deleteFilesIgnoringExceptions(trackingDir, trackingDir.getCreatedFiles());\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Sort input to a new temp file, returning its name.\n   */\n  public String sort(String inputFileName) throws IOException {\n    \n    sortInfo = new SortInfo();\n    sortInfo.totalTime = System.currentTimeMillis();\n\n    List<String> segments = new ArrayList<>();\n\n    // So we can remove any partially written temp files on exception:\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n\n    boolean success = false;\n    try (ByteSequencesReader is = new ByteSequencesReader(dir.openInput(inputFileName, IOContext.READONCE))) {\n\n      int lineCount;\n      while ((lineCount = readPartition(is)) > 0) {\n        segments.add(sortPartition(trackingDir));\n        sortInfo.tempMergeFiles++;\n        sortInfo.lineCount += lineCount;\n\n        // Handle intermediate merges.\n        if (segments.size() == maxTempFiles) {\n          mergePartitions(trackingDir, segments);\n        }\n      }\n\n      // Merge the partitions to the output file with a priority queue.\n      if (segments.size() > 1) {     \n        mergePartitions(trackingDir, segments);\n      }\n\n      String result;\n      if (segments.isEmpty()) {\n        try (IndexOutput out = trackingDir.createTempOutput(tempFileNamePrefix, \"sort\", IOContext.DEFAULT)) {\n          result = out.getName();\n        }\n      } else {\n        result = segments.get(0);\n      }\n\n      // We should be explicitly removing all intermediate files ourselves unless there is an exception:\n      assert trackingDir.getCreatedFiles().size() == 1 && trackingDir.getCreatedFiles().contains(result);\n\n      sortInfo.totalTime = (System.currentTimeMillis() - sortInfo.totalTime); \n      success = true;\n\n      return result;\n\n    } finally {\n      if (success == false) {\n        IOUtils.deleteFilesIgnoringExceptions(trackingDir, trackingDir.getCreatedFiles());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2b84d416bbd661ae4b2a28d103bdfccb851e00de","date":1458041762,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#sort(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#sort(String).mjava","sourceNew":"  /** \n   * Sort input to a new temp file, returning its name.\n   */\n  public String sort(String inputFileName) throws IOException {\n    \n    sortInfo = new SortInfo();\n    sortInfo.totalTime = System.currentTimeMillis();\n\n    List<String> segments = new ArrayList<>();\n    int[] levelCounts = new int[1];\n\n    // So we can remove any partially written temp files on exception:\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n\n    boolean success = false;\n    try (ByteSequencesReader is = getReader(dir.openInput(inputFileName, IOContext.READONCE))) {\n\n      int lineCount;\n      while ((lineCount = readPartition(is)) > 0) {\n        segments.add(sortPartition(trackingDir));\n        sortInfo.tempMergeFiles++;\n        sortInfo.lineCount += lineCount;\n        levelCounts[0]++;\n\n        // Handle intermediate merges; we need a while loop to \"cascade\" the merge when necessary:\n        int mergeLevel = 0;\n        while (levelCounts[mergeLevel] == maxTempFiles) {\n          mergePartitions(trackingDir, segments);\n          if (mergeLevel+2 > levelCounts.length) {\n            levelCounts = ArrayUtil.grow(levelCounts, mergeLevel+2);\n          }\n          levelCounts[mergeLevel+1]++;\n          levelCounts[mergeLevel] = 0;\n          mergeLevel++;\n        }\n      }\n      \n      // TODO: we shouldn't have to do this?  Can't we return a merged reader to\n      // the caller, who often consumes the result just once, instead?\n\n      // Merge all partitions down to 1 (basically a forceMerge(1)):\n      while (segments.size() > 1) {     \n        mergePartitions(trackingDir, segments);\n      }\n\n      String result;\n      if (segments.isEmpty()) {\n        try (IndexOutput out = trackingDir.createTempOutput(tempFileNamePrefix, \"sort\", IOContext.DEFAULT)) {\n          result = out.getName();\n        }\n      } else {\n        result = segments.get(0);\n      }\n\n      // We should be explicitly removing all intermediate files ourselves unless there is an exception:\n      assert trackingDir.getCreatedFiles().size() == 1 && trackingDir.getCreatedFiles().contains(result);\n\n      sortInfo.totalTime = (System.currentTimeMillis() - sortInfo.totalTime); \n      success = true;\n\n      return result;\n\n    } finally {\n      if (success == false) {\n        IOUtils.deleteFilesIgnoringExceptions(trackingDir, trackingDir.getCreatedFiles());\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Sort input to a new temp file, returning its name.\n   */\n  public String sort(String inputFileName) throws IOException {\n    \n    sortInfo = new SortInfo();\n    sortInfo.totalTime = System.currentTimeMillis();\n\n    List<String> segments = new ArrayList<>();\n\n    // So we can remove any partially written temp files on exception:\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n\n    boolean success = false;\n    try (ByteSequencesReader is = getReader(dir.openInput(inputFileName, IOContext.READONCE))) {\n\n      int lineCount;\n      while ((lineCount = readPartition(is)) > 0) {\n        segments.add(sortPartition(trackingDir));\n        sortInfo.tempMergeFiles++;\n        sortInfo.lineCount += lineCount;\n\n        // Handle intermediate merges.\n        if (segments.size() == maxTempFiles) {\n          mergePartitions(trackingDir, segments);\n        }\n      }\n\n      // Merge the partitions to the output file with a priority queue.\n      if (segments.size() > 1) {     \n        mergePartitions(trackingDir, segments);\n      }\n\n      String result;\n      if (segments.isEmpty()) {\n        try (IndexOutput out = trackingDir.createTempOutput(tempFileNamePrefix, \"sort\", IOContext.DEFAULT)) {\n          result = out.getName();\n        }\n      } else {\n        result = segments.get(0);\n      }\n\n      // We should be explicitly removing all intermediate files ourselves unless there is an exception:\n      assert trackingDir.getCreatedFiles().size() == 1 && trackingDir.getCreatedFiles().contains(result);\n\n      sortInfo.totalTime = (System.currentTimeMillis() - sortInfo.totalTime); \n      success = true;\n\n      return result;\n\n    } finally {\n      if (success == false) {\n        IOUtils.deleteFilesIgnoringExceptions(trackingDir, trackingDir.getCreatedFiles());\n      }\n    }\n  }\n\n","bugFix":["867e3d9153fb761456b54a9dcce566e1545c5ef6"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"950b7a6881d14da782b60444c11295e3ec50d41a","date":1458379095,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#sort(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#sort(String).mjava","sourceNew":"  /** \n   * Sort input to a new temp file, returning its name.\n   */\n  public String sort(String inputFileName) throws IOException {\n    \n    sortInfo = new SortInfo();\n    sortInfo.totalTime = System.currentTimeMillis();\n\n    List<String> segments = new ArrayList<>();\n    int[] levelCounts = new int[1];\n\n    // So we can remove any partially written temp files on exception:\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n\n    boolean success = false;\n    try (ByteSequencesReader is = getReader(dir.openChecksumInput(inputFileName, IOContext.READONCE), inputFileName)) {\n      int lineCount;\n      while ((lineCount = readPartition(is)) > 0) {\n        segments.add(sortPartition(trackingDir));\n        sortInfo.tempMergeFiles++;\n        sortInfo.lineCount += lineCount;\n        levelCounts[0]++;\n\n        // Handle intermediate merges; we need a while loop to \"cascade\" the merge when necessary:\n        int mergeLevel = 0;\n        while (levelCounts[mergeLevel] == maxTempFiles) {\n          mergePartitions(trackingDir, segments);\n          if (mergeLevel+2 > levelCounts.length) {\n            levelCounts = ArrayUtil.grow(levelCounts, mergeLevel+2);\n          }\n          levelCounts[mergeLevel+1]++;\n          levelCounts[mergeLevel] = 0;\n          mergeLevel++;\n        }\n      }\n      \n      // TODO: we shouldn't have to do this?  Can't we return a merged reader to\n      // the caller, who often consumes the result just once, instead?\n\n      // Merge all partitions down to 1 (basically a forceMerge(1)):\n      while (segments.size() > 1) {     \n        mergePartitions(trackingDir, segments);\n      }\n\n      String result;\n      if (segments.isEmpty()) {\n        try (IndexOutput out = trackingDir.createTempOutput(tempFileNamePrefix, \"sort\", IOContext.DEFAULT)) {\n          // Write empty file footer\n          CodecUtil.writeFooter(out);\n          result = out.getName();\n        }\n      } else {\n        result = segments.get(0);\n      }\n\n      // We should be explicitly removing all intermediate files ourselves unless there is an exception:\n      assert trackingDir.getCreatedFiles().size() == 1 && trackingDir.getCreatedFiles().contains(result);\n\n      sortInfo.totalTime = (System.currentTimeMillis() - sortInfo.totalTime); \n\n      CodecUtil.checkFooter(is.in);\n\n      success = true;\n\n      return result;\n\n    } finally {\n      if (success == false) {\n        IOUtils.deleteFilesIgnoringExceptions(trackingDir, trackingDir.getCreatedFiles());\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Sort input to a new temp file, returning its name.\n   */\n  public String sort(String inputFileName) throws IOException {\n    \n    sortInfo = new SortInfo();\n    sortInfo.totalTime = System.currentTimeMillis();\n\n    List<String> segments = new ArrayList<>();\n    int[] levelCounts = new int[1];\n\n    // So we can remove any partially written temp files on exception:\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n\n    boolean success = false;\n    try (ByteSequencesReader is = getReader(dir.openInput(inputFileName, IOContext.READONCE))) {\n\n      int lineCount;\n      while ((lineCount = readPartition(is)) > 0) {\n        segments.add(sortPartition(trackingDir));\n        sortInfo.tempMergeFiles++;\n        sortInfo.lineCount += lineCount;\n        levelCounts[0]++;\n\n        // Handle intermediate merges; we need a while loop to \"cascade\" the merge when necessary:\n        int mergeLevel = 0;\n        while (levelCounts[mergeLevel] == maxTempFiles) {\n          mergePartitions(trackingDir, segments);\n          if (mergeLevel+2 > levelCounts.length) {\n            levelCounts = ArrayUtil.grow(levelCounts, mergeLevel+2);\n          }\n          levelCounts[mergeLevel+1]++;\n          levelCounts[mergeLevel] = 0;\n          mergeLevel++;\n        }\n      }\n      \n      // TODO: we shouldn't have to do this?  Can't we return a merged reader to\n      // the caller, who often consumes the result just once, instead?\n\n      // Merge all partitions down to 1 (basically a forceMerge(1)):\n      while (segments.size() > 1) {     \n        mergePartitions(trackingDir, segments);\n      }\n\n      String result;\n      if (segments.isEmpty()) {\n        try (IndexOutput out = trackingDir.createTempOutput(tempFileNamePrefix, \"sort\", IOContext.DEFAULT)) {\n          result = out.getName();\n        }\n      } else {\n        result = segments.get(0);\n      }\n\n      // We should be explicitly removing all intermediate files ourselves unless there is an exception:\n      assert trackingDir.getCreatedFiles().size() == 1 && trackingDir.getCreatedFiles().contains(result);\n\n      sortInfo.totalTime = (System.currentTimeMillis() - sortInfo.totalTime); \n      success = true;\n\n      return result;\n\n    } finally {\n      if (success == false) {\n        IOUtils.deleteFilesIgnoringExceptions(trackingDir, trackingDir.getCreatedFiles());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ee52259641568741fbc6ecc51284431e2a36475c","date":1459331525,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#sort(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#sort(String).mjava","sourceNew":"  /** \n   * Sort input to a new temp file, returning its name.\n   */\n  public String sort(String inputFileName) throws IOException {\n    \n    sortInfo = new SortInfo();\n    sortInfo.totalTime = System.currentTimeMillis();\n\n    List<String> segments = new ArrayList<>();\n    int[] levelCounts = new int[1];\n\n    // So we can remove any partially written temp files on exception:\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n\n    boolean success = false;\n    try (ByteSequencesReader is = getReader(dir.openChecksumInput(inputFileName, IOContext.READONCE), inputFileName)) {\n      int lineCount;\n      while ((lineCount = readPartition(is)) > 0) {\n        segments.add(sortPartition(trackingDir));\n        sortInfo.tempMergeFiles++;\n        sortInfo.lineCount += lineCount;\n        levelCounts[0]++;\n\n        // Handle intermediate merges; we need a while loop to \"cascade\" the merge when necessary:\n        int mergeLevel = 0;\n        while (levelCounts[mergeLevel] == maxTempFiles) {\n          mergePartitions(trackingDir, segments);\n          if (mergeLevel+2 > levelCounts.length) {\n            levelCounts = ArrayUtil.grow(levelCounts, mergeLevel+2);\n          }\n          levelCounts[mergeLevel+1]++;\n          levelCounts[mergeLevel] = 0;\n          mergeLevel++;\n        }\n      }\n      \n      // TODO: we shouldn't have to do this?  Can't we return a merged reader to\n      // the caller, who often consumes the result just once, instead?\n\n      // Merge all partitions down to 1 (basically a forceMerge(1)):\n      while (segments.size() > 1) {     \n        mergePartitions(trackingDir, segments);\n      }\n\n      String result;\n      if (segments.isEmpty()) {\n        try (IndexOutput out = trackingDir.createTempOutput(tempFileNamePrefix, \"sort\", IOContext.DEFAULT)) {\n          // Write empty file footer\n          CodecUtil.writeFooter(out);\n          result = out.getName();\n        }\n      } else {\n        result = segments.get(0);\n      }\n\n      // We should be explicitly removing all intermediate files ourselves unless there is an exception:\n      assert trackingDir.getCreatedFiles().size() == 1 && trackingDir.getCreatedFiles().contains(result);\n\n      sortInfo.totalTime = System.currentTimeMillis() - sortInfo.totalTime; \n\n      CodecUtil.checkFooter(is.in);\n\n      success = true;\n\n      return result;\n\n    } finally {\n      if (success == false) {\n        IOUtils.deleteFilesIgnoringExceptions(trackingDir, trackingDir.getCreatedFiles());\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Sort input to a new temp file, returning its name.\n   */\n  public String sort(String inputFileName) throws IOException {\n    \n    sortInfo = new SortInfo();\n    sortInfo.totalTime = System.currentTimeMillis();\n\n    List<String> segments = new ArrayList<>();\n    int[] levelCounts = new int[1];\n\n    // So we can remove any partially written temp files on exception:\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n\n    boolean success = false;\n    try (ByteSequencesReader is = getReader(dir.openChecksumInput(inputFileName, IOContext.READONCE), inputFileName)) {\n      int lineCount;\n      while ((lineCount = readPartition(is)) > 0) {\n        segments.add(sortPartition(trackingDir));\n        sortInfo.tempMergeFiles++;\n        sortInfo.lineCount += lineCount;\n        levelCounts[0]++;\n\n        // Handle intermediate merges; we need a while loop to \"cascade\" the merge when necessary:\n        int mergeLevel = 0;\n        while (levelCounts[mergeLevel] == maxTempFiles) {\n          mergePartitions(trackingDir, segments);\n          if (mergeLevel+2 > levelCounts.length) {\n            levelCounts = ArrayUtil.grow(levelCounts, mergeLevel+2);\n          }\n          levelCounts[mergeLevel+1]++;\n          levelCounts[mergeLevel] = 0;\n          mergeLevel++;\n        }\n      }\n      \n      // TODO: we shouldn't have to do this?  Can't we return a merged reader to\n      // the caller, who often consumes the result just once, instead?\n\n      // Merge all partitions down to 1 (basically a forceMerge(1)):\n      while (segments.size() > 1) {     \n        mergePartitions(trackingDir, segments);\n      }\n\n      String result;\n      if (segments.isEmpty()) {\n        try (IndexOutput out = trackingDir.createTempOutput(tempFileNamePrefix, \"sort\", IOContext.DEFAULT)) {\n          // Write empty file footer\n          CodecUtil.writeFooter(out);\n          result = out.getName();\n        }\n      } else {\n        result = segments.get(0);\n      }\n\n      // We should be explicitly removing all intermediate files ourselves unless there is an exception:\n      assert trackingDir.getCreatedFiles().size() == 1 && trackingDir.getCreatedFiles().contains(result);\n\n      sortInfo.totalTime = (System.currentTimeMillis() - sortInfo.totalTime); \n\n      CodecUtil.checkFooter(is.in);\n\n      success = true;\n\n      return result;\n\n    } finally {\n      if (success == false) {\n        IOUtils.deleteFilesIgnoringExceptions(trackingDir, trackingDir.getCreatedFiles());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9ce0dc549cffe574c5e49b654c95a60713e0453c","date":1492031850,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#sort(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#sort(String).mjava","sourceNew":"  /** \n   * Sort input to a new temp file, returning its name.\n   */\n  public String sort(String inputFileName) throws IOException {\n    \n    sortInfo = new SortInfo();\n    sortInfo.totalTime = System.currentTimeMillis();\n\n    List<String> segments = new ArrayList<>();\n    int[] levelCounts = new int[1];\n\n    // So we can remove any partially written temp files on exception:\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n\n    boolean success = false;\n    boolean[] isExhausted = new boolean[1];\n    try (ByteSequencesReader is = getReader(dir.openChecksumInput(inputFileName, IOContext.READONCE), inputFileName)) {\n      while (isExhausted[0] == false) {\n        int lineCount = readPartition(is, isExhausted);\n        if (lineCount == 0) {\n          assert isExhausted[0];\n          break;\n        }\n        segments.add(sortPartition(trackingDir));\n        sortInfo.tempMergeFiles++;\n        sortInfo.lineCount += lineCount;\n        levelCounts[0]++;\n\n        // Handle intermediate merges; we need a while loop to \"cascade\" the merge when necessary:\n        int mergeLevel = 0;\n        while (levelCounts[mergeLevel] == maxTempFiles) {\n          mergePartitions(trackingDir, segments);\n          if (mergeLevel+2 > levelCounts.length) {\n            levelCounts = ArrayUtil.grow(levelCounts, mergeLevel+2);\n          }\n          levelCounts[mergeLevel+1]++;\n          levelCounts[mergeLevel] = 0;\n          mergeLevel++;\n        }\n      }\n      \n      // TODO: we shouldn't have to do this?  Can't we return a merged reader to\n      // the caller, who often consumes the result just once, instead?\n\n      // Merge all partitions down to 1 (basically a forceMerge(1)):\n      while (segments.size() > 1) {     \n        mergePartitions(trackingDir, segments);\n      }\n\n      String result;\n      if (segments.isEmpty()) {\n        try (IndexOutput out = trackingDir.createTempOutput(tempFileNamePrefix, \"sort\", IOContext.DEFAULT)) {\n          // Write empty file footer\n          CodecUtil.writeFooter(out);\n          result = out.getName();\n        }\n      } else {\n        result = segments.get(0);\n      }\n\n      // We should be explicitly removing all intermediate files ourselves unless there is an exception:\n      assert trackingDir.getCreatedFiles().size() == 1 && trackingDir.getCreatedFiles().contains(result);\n\n      sortInfo.totalTime = System.currentTimeMillis() - sortInfo.totalTime; \n\n      CodecUtil.checkFooter(is.in);\n\n      success = true;\n\n      return result;\n\n    } finally {\n      if (success == false) {\n        IOUtils.deleteFilesIgnoringExceptions(trackingDir, trackingDir.getCreatedFiles());\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Sort input to a new temp file, returning its name.\n   */\n  public String sort(String inputFileName) throws IOException {\n    \n    sortInfo = new SortInfo();\n    sortInfo.totalTime = System.currentTimeMillis();\n\n    List<String> segments = new ArrayList<>();\n    int[] levelCounts = new int[1];\n\n    // So we can remove any partially written temp files on exception:\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n\n    boolean success = false;\n    try (ByteSequencesReader is = getReader(dir.openChecksumInput(inputFileName, IOContext.READONCE), inputFileName)) {\n      int lineCount;\n      while ((lineCount = readPartition(is)) > 0) {\n        segments.add(sortPartition(trackingDir));\n        sortInfo.tempMergeFiles++;\n        sortInfo.lineCount += lineCount;\n        levelCounts[0]++;\n\n        // Handle intermediate merges; we need a while loop to \"cascade\" the merge when necessary:\n        int mergeLevel = 0;\n        while (levelCounts[mergeLevel] == maxTempFiles) {\n          mergePartitions(trackingDir, segments);\n          if (mergeLevel+2 > levelCounts.length) {\n            levelCounts = ArrayUtil.grow(levelCounts, mergeLevel+2);\n          }\n          levelCounts[mergeLevel+1]++;\n          levelCounts[mergeLevel] = 0;\n          mergeLevel++;\n        }\n      }\n      \n      // TODO: we shouldn't have to do this?  Can't we return a merged reader to\n      // the caller, who often consumes the result just once, instead?\n\n      // Merge all partitions down to 1 (basically a forceMerge(1)):\n      while (segments.size() > 1) {     \n        mergePartitions(trackingDir, segments);\n      }\n\n      String result;\n      if (segments.isEmpty()) {\n        try (IndexOutput out = trackingDir.createTempOutput(tempFileNamePrefix, \"sort\", IOContext.DEFAULT)) {\n          // Write empty file footer\n          CodecUtil.writeFooter(out);\n          result = out.getName();\n        }\n      } else {\n        result = segments.get(0);\n      }\n\n      // We should be explicitly removing all intermediate files ourselves unless there is an exception:\n      assert trackingDir.getCreatedFiles().size() == 1 && trackingDir.getCreatedFiles().contains(result);\n\n      sortInfo.totalTime = System.currentTimeMillis() - sortInfo.totalTime; \n\n      CodecUtil.checkFooter(is.in);\n\n      success = true;\n\n      return result;\n\n    } finally {\n      if (success == false) {\n        IOUtils.deleteFilesIgnoringExceptions(trackingDir, trackingDir.getCreatedFiles());\n      }\n    }\n  }\n\n","bugFix":["867e3d9153fb761456b54a9dcce566e1545c5ef6"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"62e7e8f89cb6b0283f3f5d6c0945453b73f09d45","date":1492172132,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#sort(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#sort(String).mjava","sourceNew":"  /** \n   * Sort input to a new temp file, returning its name.\n   */\n  public String sort(String inputFileName) throws IOException {\n    \n    sortInfo = new SortInfo();\n    sortInfo.totalTime = System.currentTimeMillis();\n\n    List<PartitionAndCount> segments = new ArrayList<>();\n    int[] levelCounts = new int[1];\n\n    // So we can remove any partially written temp files on exception:\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n\n    boolean success = false;\n    boolean[] isExhausted = new boolean[1];\n    try (ByteSequencesReader is = getReader(dir.openChecksumInput(inputFileName, IOContext.READONCE), inputFileName)) {\n      while (isExhausted[0] == false) {\n        int lineCount = readPartition(is, isExhausted);\n        if (lineCount == 0) {\n          assert isExhausted[0];\n          break;\n        }\n        segments.add(sortPartition(trackingDir, lineCount));\n        sortInfo.tempMergeFiles++;\n        sortInfo.lineCount += lineCount;\n        levelCounts[0]++;\n\n        // Handle intermediate merges; we need a while loop to \"cascade\" the merge when necessary:\n        int mergeLevel = 0;\n        while (levelCounts[mergeLevel] == maxTempFiles) {\n          mergePartitions(trackingDir, segments);\n          if (mergeLevel+2 > levelCounts.length) {\n            levelCounts = ArrayUtil.grow(levelCounts, mergeLevel+2);\n          }\n          levelCounts[mergeLevel+1]++;\n          levelCounts[mergeLevel] = 0;\n          mergeLevel++;\n        }\n      }\n      \n      // TODO: we shouldn't have to do this?  Can't we return a merged reader to\n      // the caller, who often consumes the result just once, instead?\n\n      // Merge all partitions down to 1 (basically a forceMerge(1)):\n      while (segments.size() > 1) {     \n        mergePartitions(trackingDir, segments);\n      }\n\n      String result;\n      if (segments.isEmpty()) {\n        try (IndexOutput out = trackingDir.createTempOutput(tempFileNamePrefix, \"sort\", IOContext.DEFAULT)) {\n          // Write empty file footer\n          CodecUtil.writeFooter(out);\n          result = out.getName();\n        }\n      } else {\n        result = segments.get(0).fileName;\n      }\n\n      // We should be explicitly removing all intermediate files ourselves unless there is an exception:\n      assert trackingDir.getCreatedFiles().size() == 1 && trackingDir.getCreatedFiles().contains(result);\n\n      sortInfo.totalTime = System.currentTimeMillis() - sortInfo.totalTime; \n\n      CodecUtil.checkFooter(is.in);\n\n      success = true;\n\n      return result;\n\n    } finally {\n      if (success == false) {\n        IOUtils.deleteFilesIgnoringExceptions(trackingDir, trackingDir.getCreatedFiles());\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Sort input to a new temp file, returning its name.\n   */\n  public String sort(String inputFileName) throws IOException {\n    \n    sortInfo = new SortInfo();\n    sortInfo.totalTime = System.currentTimeMillis();\n\n    List<String> segments = new ArrayList<>();\n    int[] levelCounts = new int[1];\n\n    // So we can remove any partially written temp files on exception:\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n\n    boolean success = false;\n    boolean[] isExhausted = new boolean[1];\n    try (ByteSequencesReader is = getReader(dir.openChecksumInput(inputFileName, IOContext.READONCE), inputFileName)) {\n      while (isExhausted[0] == false) {\n        int lineCount = readPartition(is, isExhausted);\n        if (lineCount == 0) {\n          assert isExhausted[0];\n          break;\n        }\n        segments.add(sortPartition(trackingDir));\n        sortInfo.tempMergeFiles++;\n        sortInfo.lineCount += lineCount;\n        levelCounts[0]++;\n\n        // Handle intermediate merges; we need a while loop to \"cascade\" the merge when necessary:\n        int mergeLevel = 0;\n        while (levelCounts[mergeLevel] == maxTempFiles) {\n          mergePartitions(trackingDir, segments);\n          if (mergeLevel+2 > levelCounts.length) {\n            levelCounts = ArrayUtil.grow(levelCounts, mergeLevel+2);\n          }\n          levelCounts[mergeLevel+1]++;\n          levelCounts[mergeLevel] = 0;\n          mergeLevel++;\n        }\n      }\n      \n      // TODO: we shouldn't have to do this?  Can't we return a merged reader to\n      // the caller, who often consumes the result just once, instead?\n\n      // Merge all partitions down to 1 (basically a forceMerge(1)):\n      while (segments.size() > 1) {     \n        mergePartitions(trackingDir, segments);\n      }\n\n      String result;\n      if (segments.isEmpty()) {\n        try (IndexOutput out = trackingDir.createTempOutput(tempFileNamePrefix, \"sort\", IOContext.DEFAULT)) {\n          // Write empty file footer\n          CodecUtil.writeFooter(out);\n          result = out.getName();\n        }\n      } else {\n        result = segments.get(0);\n      }\n\n      // We should be explicitly removing all intermediate files ourselves unless there is an exception:\n      assert trackingDir.getCreatedFiles().size() == 1 && trackingDir.getCreatedFiles().contains(result);\n\n      sortInfo.totalTime = System.currentTimeMillis() - sortInfo.totalTime; \n\n      CodecUtil.checkFooter(is.in);\n\n      success = true;\n\n      return result;\n\n    } finally {\n      if (success == false) {\n        IOUtils.deleteFilesIgnoringExceptions(trackingDir, trackingDir.getCreatedFiles());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#sort(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#sort(String).mjava","sourceNew":"  /** \n   * Sort input to a new temp file, returning its name.\n   */\n  public String sort(String inputFileName) throws IOException {\n    \n    sortInfo = new SortInfo();\n    sortInfo.totalTime = System.currentTimeMillis();\n\n    List<PartitionAndCount> segments = new ArrayList<>();\n    int[] levelCounts = new int[1];\n\n    // So we can remove any partially written temp files on exception:\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n\n    boolean success = false;\n    boolean[] isExhausted = new boolean[1];\n    try (ByteSequencesReader is = getReader(dir.openChecksumInput(inputFileName, IOContext.READONCE), inputFileName)) {\n      while (isExhausted[0] == false) {\n        int lineCount = readPartition(is, isExhausted);\n        if (lineCount == 0) {\n          assert isExhausted[0];\n          break;\n        }\n        segments.add(sortPartition(trackingDir, lineCount));\n        sortInfo.tempMergeFiles++;\n        sortInfo.lineCount += lineCount;\n        levelCounts[0]++;\n\n        // Handle intermediate merges; we need a while loop to \"cascade\" the merge when necessary:\n        int mergeLevel = 0;\n        while (levelCounts[mergeLevel] == maxTempFiles) {\n          mergePartitions(trackingDir, segments);\n          if (mergeLevel+2 > levelCounts.length) {\n            levelCounts = ArrayUtil.grow(levelCounts, mergeLevel+2);\n          }\n          levelCounts[mergeLevel+1]++;\n          levelCounts[mergeLevel] = 0;\n          mergeLevel++;\n        }\n      }\n      \n      // TODO: we shouldn't have to do this?  Can't we return a merged reader to\n      // the caller, who often consumes the result just once, instead?\n\n      // Merge all partitions down to 1 (basically a forceMerge(1)):\n      while (segments.size() > 1) {     \n        mergePartitions(trackingDir, segments);\n      }\n\n      String result;\n      if (segments.isEmpty()) {\n        try (IndexOutput out = trackingDir.createTempOutput(tempFileNamePrefix, \"sort\", IOContext.DEFAULT)) {\n          // Write empty file footer\n          CodecUtil.writeFooter(out);\n          result = out.getName();\n        }\n      } else {\n        result = segments.get(0).fileName;\n      }\n\n      // We should be explicitly removing all intermediate files ourselves unless there is an exception:\n      assert trackingDir.getCreatedFiles().size() == 1 && trackingDir.getCreatedFiles().contains(result);\n\n      sortInfo.totalTime = System.currentTimeMillis() - sortInfo.totalTime; \n\n      CodecUtil.checkFooter(is.in);\n\n      success = true;\n\n      return result;\n\n    } finally {\n      if (success == false) {\n        IOUtils.deleteFilesIgnoringExceptions(trackingDir, trackingDir.getCreatedFiles());\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Sort input to a new temp file, returning its name.\n   */\n  public String sort(String inputFileName) throws IOException {\n    \n    sortInfo = new SortInfo();\n    sortInfo.totalTime = System.currentTimeMillis();\n\n    List<String> segments = new ArrayList<>();\n    int[] levelCounts = new int[1];\n\n    // So we can remove any partially written temp files on exception:\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n\n    boolean success = false;\n    try (ByteSequencesReader is = getReader(dir.openChecksumInput(inputFileName, IOContext.READONCE), inputFileName)) {\n      int lineCount;\n      while ((lineCount = readPartition(is)) > 0) {\n        segments.add(sortPartition(trackingDir));\n        sortInfo.tempMergeFiles++;\n        sortInfo.lineCount += lineCount;\n        levelCounts[0]++;\n\n        // Handle intermediate merges; we need a while loop to \"cascade\" the merge when necessary:\n        int mergeLevel = 0;\n        while (levelCounts[mergeLevel] == maxTempFiles) {\n          mergePartitions(trackingDir, segments);\n          if (mergeLevel+2 > levelCounts.length) {\n            levelCounts = ArrayUtil.grow(levelCounts, mergeLevel+2);\n          }\n          levelCounts[mergeLevel+1]++;\n          levelCounts[mergeLevel] = 0;\n          mergeLevel++;\n        }\n      }\n      \n      // TODO: we shouldn't have to do this?  Can't we return a merged reader to\n      // the caller, who often consumes the result just once, instead?\n\n      // Merge all partitions down to 1 (basically a forceMerge(1)):\n      while (segments.size() > 1) {     \n        mergePartitions(trackingDir, segments);\n      }\n\n      String result;\n      if (segments.isEmpty()) {\n        try (IndexOutput out = trackingDir.createTempOutput(tempFileNamePrefix, \"sort\", IOContext.DEFAULT)) {\n          // Write empty file footer\n          CodecUtil.writeFooter(out);\n          result = out.getName();\n        }\n      } else {\n        result = segments.get(0);\n      }\n\n      // We should be explicitly removing all intermediate files ourselves unless there is an exception:\n      assert trackingDir.getCreatedFiles().size() == 1 && trackingDir.getCreatedFiles().contains(result);\n\n      sortInfo.totalTime = System.currentTimeMillis() - sortInfo.totalTime; \n\n      CodecUtil.checkFooter(is.in);\n\n      success = true;\n\n      return result;\n\n    } finally {\n      if (success == false) {\n        IOUtils.deleteFilesIgnoringExceptions(trackingDir, trackingDir.getCreatedFiles());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dcb0432bcb41451b41e9aaaabe99f5d208258fe","date":1493203108,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#sort(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#sort(String).mjava","sourceNew":"  /** \n   * Sort input to a new temp file, returning its name.\n   */\n  public String sort(String inputFileName) throws IOException {\n    \n    sortInfo = new SortInfo();\n    long startMS = System.currentTimeMillis();\n\n    List<Future<Partition>> segments = new ArrayList<>();\n    int[] levelCounts = new int[1];\n\n    // So we can remove any partially written temp files on exception:\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n\n    boolean success = false;\n    try (ByteSequencesReader is = getReader(dir.openChecksumInput(inputFileName, IOContext.READONCE), inputFileName)) {\n      while (true) {\n        Partition part = readPartition(is);\n        if (part.count == 0) {\n          assert part.exhausted;\n          break;\n        }\n\n        Callable<Partition> job = new SortPartitionTask(trackingDir, part);\n\n        segments.add(exec.submit(job));\n        sortInfo.tempMergeFiles++;\n        sortInfo.lineCount += part.count;\n        levelCounts[0]++;\n\n        // Handle intermediate merges; we need a while loop to \"cascade\" the merge when necessary:\n        int mergeLevel = 0;\n        while (levelCounts[mergeLevel] == maxTempFiles) {\n          mergePartitions(trackingDir, segments);\n          if (mergeLevel+2 > levelCounts.length) {\n            levelCounts = ArrayUtil.grow(levelCounts, mergeLevel+2);\n          }\n          levelCounts[mergeLevel+1]++;\n          levelCounts[mergeLevel] = 0;\n          mergeLevel++;\n        }\n\n        if (part.exhausted) {\n          break;\n        }\n      }\n      \n      // TODO: we shouldn't have to do this?  Can't we return a merged reader to\n      // the caller, who often consumes the result just once, instead?\n\n      // Merge all partitions down to 1 (basically a forceMerge(1)):\n      while (segments.size() > 1) {     \n        mergePartitions(trackingDir, segments);\n      }\n\n      String result;\n      if (segments.isEmpty()) {\n        try (IndexOutput out = trackingDir.createTempOutput(tempFileNamePrefix, \"sort\", IOContext.DEFAULT)) {\n          // Write empty file footer\n          CodecUtil.writeFooter(out);\n          result = out.getName();\n        }\n      } else {\n        try {\n          result = segments.get(0).get().fileName;\n        } catch (InterruptedException ie) {\n          throw new ThreadInterruptedException(ie);\n        } catch (ExecutionException ee) {\n          IOUtils.reThrow(ee.getCause());\n\n          // dead code but javac disagrees:\n          result = null;\n        }\n      }\n\n      // We should be explicitly removing all intermediate files ourselves unless there is an exception:\n      assert trackingDir.getCreatedFiles().size() == 1 && trackingDir.getCreatedFiles().contains(result);\n\n      sortInfo.totalTimeMS = System.currentTimeMillis() - startMS;\n\n      CodecUtil.checkFooter(is.in);\n\n      success = true;\n\n      return result;\n\n    } catch (InterruptedException ie) {\n      throw new ThreadInterruptedException(ie);\n    } finally {\n      if (success == false) {\n        IOUtils.deleteFilesIgnoringExceptions(trackingDir, trackingDir.getCreatedFiles());\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Sort input to a new temp file, returning its name.\n   */\n  public String sort(String inputFileName) throws IOException {\n    \n    sortInfo = new SortInfo();\n    sortInfo.totalTime = System.currentTimeMillis();\n\n    List<PartitionAndCount> segments = new ArrayList<>();\n    int[] levelCounts = new int[1];\n\n    // So we can remove any partially written temp files on exception:\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n\n    boolean success = false;\n    boolean[] isExhausted = new boolean[1];\n    try (ByteSequencesReader is = getReader(dir.openChecksumInput(inputFileName, IOContext.READONCE), inputFileName)) {\n      while (isExhausted[0] == false) {\n        int lineCount = readPartition(is, isExhausted);\n        if (lineCount == 0) {\n          assert isExhausted[0];\n          break;\n        }\n        segments.add(sortPartition(trackingDir, lineCount));\n        sortInfo.tempMergeFiles++;\n        sortInfo.lineCount += lineCount;\n        levelCounts[0]++;\n\n        // Handle intermediate merges; we need a while loop to \"cascade\" the merge when necessary:\n        int mergeLevel = 0;\n        while (levelCounts[mergeLevel] == maxTempFiles) {\n          mergePartitions(trackingDir, segments);\n          if (mergeLevel+2 > levelCounts.length) {\n            levelCounts = ArrayUtil.grow(levelCounts, mergeLevel+2);\n          }\n          levelCounts[mergeLevel+1]++;\n          levelCounts[mergeLevel] = 0;\n          mergeLevel++;\n        }\n      }\n      \n      // TODO: we shouldn't have to do this?  Can't we return a merged reader to\n      // the caller, who often consumes the result just once, instead?\n\n      // Merge all partitions down to 1 (basically a forceMerge(1)):\n      while (segments.size() > 1) {     \n        mergePartitions(trackingDir, segments);\n      }\n\n      String result;\n      if (segments.isEmpty()) {\n        try (IndexOutput out = trackingDir.createTempOutput(tempFileNamePrefix, \"sort\", IOContext.DEFAULT)) {\n          // Write empty file footer\n          CodecUtil.writeFooter(out);\n          result = out.getName();\n        }\n      } else {\n        result = segments.get(0).fileName;\n      }\n\n      // We should be explicitly removing all intermediate files ourselves unless there is an exception:\n      assert trackingDir.getCreatedFiles().size() == 1 && trackingDir.getCreatedFiles().contains(result);\n\n      sortInfo.totalTime = System.currentTimeMillis() - sortInfo.totalTime; \n\n      CodecUtil.checkFooter(is.in);\n\n      success = true;\n\n      return result;\n\n    } finally {\n      if (success == false) {\n        IOUtils.deleteFilesIgnoringExceptions(trackingDir, trackingDir.getCreatedFiles());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36a23c6fa37610e466602f47f4ddf1e7a8e702e5","date":1493213774,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#sort(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#sort(String).mjava","sourceNew":"  /** \n   * Sort input to a new temp file, returning its name.\n   */\n  public String sort(String inputFileName) throws IOException {\n    \n    sortInfo = new SortInfo();\n    long startMS = System.currentTimeMillis();\n\n    List<Future<Partition>> segments = new ArrayList<>();\n    int[] levelCounts = new int[1];\n\n    // So we can remove any partially written temp files on exception:\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n\n    boolean success = false;\n    try (ByteSequencesReader is = getReader(dir.openChecksumInput(inputFileName, IOContext.READONCE), inputFileName)) {\n      while (true) {\n        Partition part = readPartition(is);\n        if (part.count == 0) {\n          if (partitionsInRAM != null) {\n            partitionsInRAM.release();\n          }\n          assert part.exhausted;\n          break;\n        }\n\n        Callable<Partition> job = new SortPartitionTask(trackingDir, part);\n\n        segments.add(exec.submit(job));\n        sortInfo.tempMergeFiles++;\n        sortInfo.lineCount += part.count;\n        levelCounts[0]++;\n\n        // Handle intermediate merges; we need a while loop to \"cascade\" the merge when necessary:\n        int mergeLevel = 0;\n        while (levelCounts[mergeLevel] == maxTempFiles) {\n          mergePartitions(trackingDir, segments);\n          if (mergeLevel+2 > levelCounts.length) {\n            levelCounts = ArrayUtil.grow(levelCounts, mergeLevel+2);\n          }\n          levelCounts[mergeLevel+1]++;\n          levelCounts[mergeLevel] = 0;\n          mergeLevel++;\n        }\n\n        if (part.exhausted) {\n          break;\n        }\n      }\n      \n      // TODO: we shouldn't have to do this?  Can't we return a merged reader to\n      // the caller, who often consumes the result just once, instead?\n\n      // Merge all partitions down to 1 (basically a forceMerge(1)):\n      while (segments.size() > 1) {     \n        mergePartitions(trackingDir, segments);\n      }\n\n      String result;\n      if (segments.isEmpty()) {\n        try (IndexOutput out = trackingDir.createTempOutput(tempFileNamePrefix, \"sort\", IOContext.DEFAULT)) {\n          // Write empty file footer\n          CodecUtil.writeFooter(out);\n          result = out.getName();\n        }\n      } else {\n        result = getPartition(segments.get(0)).fileName;\n      }\n\n      // We should be explicitly removing all intermediate files ourselves unless there is an exception:\n      assert trackingDir.getCreatedFiles().size() == 1 && trackingDir.getCreatedFiles().contains(result);\n\n      sortInfo.totalTimeMS = System.currentTimeMillis() - startMS;\n\n      CodecUtil.checkFooter(is.in);\n\n      success = true;\n\n      return result;\n\n    } catch (InterruptedException ie) {\n      throw new ThreadInterruptedException(ie);\n    } finally {\n      if (success == false) {\n        IOUtils.deleteFilesIgnoringExceptions(trackingDir, trackingDir.getCreatedFiles());\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Sort input to a new temp file, returning its name.\n   */\n  public String sort(String inputFileName) throws IOException {\n    \n    sortInfo = new SortInfo();\n    long startMS = System.currentTimeMillis();\n\n    List<Future<Partition>> segments = new ArrayList<>();\n    int[] levelCounts = new int[1];\n\n    // So we can remove any partially written temp files on exception:\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n\n    boolean success = false;\n    try (ByteSequencesReader is = getReader(dir.openChecksumInput(inputFileName, IOContext.READONCE), inputFileName)) {\n      while (true) {\n        Partition part = readPartition(is);\n        if (part.count == 0) {\n          assert part.exhausted;\n          break;\n        }\n\n        Callable<Partition> job = new SortPartitionTask(trackingDir, part);\n\n        segments.add(exec.submit(job));\n        sortInfo.tempMergeFiles++;\n        sortInfo.lineCount += part.count;\n        levelCounts[0]++;\n\n        // Handle intermediate merges; we need a while loop to \"cascade\" the merge when necessary:\n        int mergeLevel = 0;\n        while (levelCounts[mergeLevel] == maxTempFiles) {\n          mergePartitions(trackingDir, segments);\n          if (mergeLevel+2 > levelCounts.length) {\n            levelCounts = ArrayUtil.grow(levelCounts, mergeLevel+2);\n          }\n          levelCounts[mergeLevel+1]++;\n          levelCounts[mergeLevel] = 0;\n          mergeLevel++;\n        }\n\n        if (part.exhausted) {\n          break;\n        }\n      }\n      \n      // TODO: we shouldn't have to do this?  Can't we return a merged reader to\n      // the caller, who often consumes the result just once, instead?\n\n      // Merge all partitions down to 1 (basically a forceMerge(1)):\n      while (segments.size() > 1) {     \n        mergePartitions(trackingDir, segments);\n      }\n\n      String result;\n      if (segments.isEmpty()) {\n        try (IndexOutput out = trackingDir.createTempOutput(tempFileNamePrefix, \"sort\", IOContext.DEFAULT)) {\n          // Write empty file footer\n          CodecUtil.writeFooter(out);\n          result = out.getName();\n        }\n      } else {\n        try {\n          result = segments.get(0).get().fileName;\n        } catch (InterruptedException ie) {\n          throw new ThreadInterruptedException(ie);\n        } catch (ExecutionException ee) {\n          IOUtils.reThrow(ee.getCause());\n\n          // dead code but javac disagrees:\n          result = null;\n        }\n      }\n\n      // We should be explicitly removing all intermediate files ourselves unless there is an exception:\n      assert trackingDir.getCreatedFiles().size() == 1 && trackingDir.getCreatedFiles().contains(result);\n\n      sortInfo.totalTimeMS = System.currentTimeMillis() - startMS;\n\n      CodecUtil.checkFooter(is.in);\n\n      success = true;\n\n      return result;\n\n    } catch (InterruptedException ie) {\n      throw new ThreadInterruptedException(ie);\n    } finally {\n      if (success == false) {\n        IOUtils.deleteFilesIgnoringExceptions(trackingDir, trackingDir.getCreatedFiles());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#sort(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#sort(String).mjava","sourceNew":"  /** \n   * Sort input to a new temp file, returning its name.\n   */\n  public String sort(String inputFileName) throws IOException {\n    \n    sortInfo = new SortInfo();\n    long startMS = System.currentTimeMillis();\n\n    List<Future<Partition>> segments = new ArrayList<>();\n    int[] levelCounts = new int[1];\n\n    // So we can remove any partially written temp files on exception:\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n\n    boolean success = false;\n    try (ByteSequencesReader is = getReader(dir.openChecksumInput(inputFileName, IOContext.READONCE), inputFileName)) {\n      while (true) {\n        Partition part = readPartition(is);\n        if (part.count == 0) {\n          if (partitionsInRAM != null) {\n            partitionsInRAM.release();\n          }\n          assert part.exhausted;\n          break;\n        }\n\n        Callable<Partition> job = new SortPartitionTask(trackingDir, part);\n\n        segments.add(exec.submit(job));\n        sortInfo.tempMergeFiles++;\n        sortInfo.lineCount += part.count;\n        levelCounts[0]++;\n\n        // Handle intermediate merges; we need a while loop to \"cascade\" the merge when necessary:\n        int mergeLevel = 0;\n        while (levelCounts[mergeLevel] == maxTempFiles) {\n          mergePartitions(trackingDir, segments);\n          if (mergeLevel+2 > levelCounts.length) {\n            levelCounts = ArrayUtil.grow(levelCounts, mergeLevel+2);\n          }\n          levelCounts[mergeLevel+1]++;\n          levelCounts[mergeLevel] = 0;\n          mergeLevel++;\n        }\n\n        if (part.exhausted) {\n          break;\n        }\n      }\n      \n      // TODO: we shouldn't have to do this?  Can't we return a merged reader to\n      // the caller, who often consumes the result just once, instead?\n\n      // Merge all partitions down to 1 (basically a forceMerge(1)):\n      while (segments.size() > 1) {     \n        mergePartitions(trackingDir, segments);\n      }\n\n      String result;\n      if (segments.isEmpty()) {\n        try (IndexOutput out = trackingDir.createTempOutput(tempFileNamePrefix, \"sort\", IOContext.DEFAULT)) {\n          // Write empty file footer\n          CodecUtil.writeFooter(out);\n          result = out.getName();\n        }\n      } else {\n        result = getPartition(segments.get(0)).fileName;\n      }\n\n      // We should be explicitly removing all intermediate files ourselves unless there is an exception:\n      assert trackingDir.getCreatedFiles().size() == 1 && trackingDir.getCreatedFiles().contains(result);\n\n      sortInfo.totalTimeMS = System.currentTimeMillis() - startMS;\n\n      CodecUtil.checkFooter(is.in);\n\n      success = true;\n\n      return result;\n\n    } catch (InterruptedException ie) {\n      throw new ThreadInterruptedException(ie);\n    } finally {\n      if (success == false) {\n        IOUtils.deleteFilesIgnoringExceptions(trackingDir, trackingDir.getCreatedFiles());\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Sort input to a new temp file, returning its name.\n   */\n  public String sort(String inputFileName) throws IOException {\n    \n    sortInfo = new SortInfo();\n    sortInfo.totalTime = System.currentTimeMillis();\n\n    List<PartitionAndCount> segments = new ArrayList<>();\n    int[] levelCounts = new int[1];\n\n    // So we can remove any partially written temp files on exception:\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n\n    boolean success = false;\n    boolean[] isExhausted = new boolean[1];\n    try (ByteSequencesReader is = getReader(dir.openChecksumInput(inputFileName, IOContext.READONCE), inputFileName)) {\n      while (isExhausted[0] == false) {\n        int lineCount = readPartition(is, isExhausted);\n        if (lineCount == 0) {\n          assert isExhausted[0];\n          break;\n        }\n        segments.add(sortPartition(trackingDir, lineCount));\n        sortInfo.tempMergeFiles++;\n        sortInfo.lineCount += lineCount;\n        levelCounts[0]++;\n\n        // Handle intermediate merges; we need a while loop to \"cascade\" the merge when necessary:\n        int mergeLevel = 0;\n        while (levelCounts[mergeLevel] == maxTempFiles) {\n          mergePartitions(trackingDir, segments);\n          if (mergeLevel+2 > levelCounts.length) {\n            levelCounts = ArrayUtil.grow(levelCounts, mergeLevel+2);\n          }\n          levelCounts[mergeLevel+1]++;\n          levelCounts[mergeLevel] = 0;\n          mergeLevel++;\n        }\n      }\n      \n      // TODO: we shouldn't have to do this?  Can't we return a merged reader to\n      // the caller, who often consumes the result just once, instead?\n\n      // Merge all partitions down to 1 (basically a forceMerge(1)):\n      while (segments.size() > 1) {     \n        mergePartitions(trackingDir, segments);\n      }\n\n      String result;\n      if (segments.isEmpty()) {\n        try (IndexOutput out = trackingDir.createTempOutput(tempFileNamePrefix, \"sort\", IOContext.DEFAULT)) {\n          // Write empty file footer\n          CodecUtil.writeFooter(out);\n          result = out.getName();\n        }\n      } else {\n        result = segments.get(0).fileName;\n      }\n\n      // We should be explicitly removing all intermediate files ourselves unless there is an exception:\n      assert trackingDir.getCreatedFiles().size() == 1 && trackingDir.getCreatedFiles().contains(result);\n\n      sortInfo.totalTime = System.currentTimeMillis() - sortInfo.totalTime; \n\n      CodecUtil.checkFooter(is.in);\n\n      success = true;\n\n      return result;\n\n    } finally {\n      if (success == false) {\n        IOUtils.deleteFilesIgnoringExceptions(trackingDir, trackingDir.getCreatedFiles());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["ee52259641568741fbc6ecc51284431e2a36475c"],"e3ce1ef883d26aa73919aa2d53991726e96caa13":["867e3d9153fb761456b54a9dcce566e1545c5ef6"],"36a23c6fa37610e466602f47f4ddf1e7a8e702e5":["7dcb0432bcb41451b41e9aaaabe99f5d208258fe"],"2b84d416bbd661ae4b2a28d103bdfccb851e00de":["e3ce1ef883d26aa73919aa2d53991726e96caa13"],"7dcb0432bcb41451b41e9aaaabe99f5d208258fe":["62e7e8f89cb6b0283f3f5d6c0945453b73f09d45"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","36a23c6fa37610e466602f47f4ddf1e7a8e702e5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ee52259641568741fbc6ecc51284431e2a36475c":["950b7a6881d14da782b60444c11295e3ec50d41a"],"9ce0dc549cffe574c5e49b654c95a60713e0453c":["ee52259641568741fbc6ecc51284431e2a36475c"],"950b7a6881d14da782b60444c11295e3ec50d41a":["2b84d416bbd661ae4b2a28d103bdfccb851e00de"],"62e7e8f89cb6b0283f3f5d6c0945453b73f09d45":["9ce0dc549cffe574c5e49b654c95a60713e0453c"],"867e3d9153fb761456b54a9dcce566e1545c5ef6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["36a23c6fa37610e466602f47f4ddf1e7a8e702e5"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"e3ce1ef883d26aa73919aa2d53991726e96caa13":["2b84d416bbd661ae4b2a28d103bdfccb851e00de"],"36a23c6fa37610e466602f47f4ddf1e7a8e702e5":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2b84d416bbd661ae4b2a28d103bdfccb851e00de":["950b7a6881d14da782b60444c11295e3ec50d41a"],"7dcb0432bcb41451b41e9aaaabe99f5d208258fe":["36a23c6fa37610e466602f47f4ddf1e7a8e702e5"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["867e3d9153fb761456b54a9dcce566e1545c5ef6"],"ee52259641568741fbc6ecc51284431e2a36475c":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","9ce0dc549cffe574c5e49b654c95a60713e0453c"],"950b7a6881d14da782b60444c11295e3ec50d41a":["ee52259641568741fbc6ecc51284431e2a36475c"],"9ce0dc549cffe574c5e49b654c95a60713e0453c":["62e7e8f89cb6b0283f3f5d6c0945453b73f09d45"],"867e3d9153fb761456b54a9dcce566e1545c5ef6":["e3ce1ef883d26aa73919aa2d53991726e96caa13"],"62e7e8f89cb6b0283f3f5d6c0945453b73f09d45":["7dcb0432bcb41451b41e9aaaabe99f5d208258fe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}