{"path":"contrib/spatial/src/java/org/apache/lucene/spatial/tier/BoundaryBoxFilter#bits(IndexReader).mjava","commits":[{"id":"04a4a94db1eb59c8583adb166acfe686a031bedc","date":1230622637,"type":0,"author":"Ryan McKinley","isMerge":false,"pathNew":"contrib/spatial/src/java/org/apache/lucene/spatial/tier/BoundaryBoxFilter#bits(IndexReader).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Returns a BitSet with true for documents which should be\n   * permitted in search results, and false for those that should\n   * not.\n   */\n  @Override\n  public BitSet bits(IndexReader reader) throws IOException {\n    long start = System.currentTimeMillis();\n    \n    BitSet bits = new BitSet(reader.maxDoc());\n    TermEnum enumerator =\n        (null != lowerTerm\n         ? reader.terms(new Term(fieldName, lowerTerm))\n         : reader.terms(new Term(fieldName,\"\")));\n    \n    //coords = new HashMap(enumerator.docFreq());\n    \n    try {\n      if (enumerator.term() == null) {\n        return bits;\n      }\n      \n      boolean checkLower = false;\n      if (!includeLower) // make adjustments to set to exclusive\n        checkLower = true;\n  \n      TermDocs termDocs = reader.termDocs();\n      try {          \n        do {\n          Term term = enumerator.term();\n          if (term != null && term.field().equals(fieldName)) {\n            if (!checkLower || null==lowerTerm || term.text().compareTo(lowerTerm) > 0) {\n              checkLower = false;\n              if (upperTerm != null) {\n                int compare = upperTerm.compareTo(term.text());\n                // if beyond the upper term, or is exclusive and\n                // this is equal to the upper term, break out \n                if ((compare < 0) ||\n                  (!includeUpper && compare==0)) {\n                  break;\n                }\n              }\n              // we have a good term, find the docs \n              termDocs.seek(enumerator.term());\n              while (termDocs.next()) {\n                bits.set(termDocs.doc());\n              }\n            }\n          } \n          else {\n            break;\n          }\n        }\n        while (enumerator.next());    \n      } \n      finally {\n        termDocs.close();\n      }\n    } \n    finally {\n      enumerator.close();\n    }\n\n    long end = System.currentTimeMillis();\n    log.info(\"BoundaryBox Time Taken: \"+ (end - start));\n    return bits;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d41c10b9c61bc826acd344f499e062fb46bc42ae","date":1249408917,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/spatial/src/java/org/apache/lucene/spatial/tier/BoundaryBoxFilter#getDocIdSet(IndexReader).mjava","pathOld":"contrib/spatial/src/java/org/apache/lucene/spatial/tier/BoundaryBoxFilter#bits(IndexReader).mjava","sourceNew":"  /**\n   * Returns a DocIdSet with true for documents which should be\n   * permitted in search results, and false for those that should\n   * not.\n   */\n  @Override\n  public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n    long start = System.currentTimeMillis();\n    \n    OpenBitSet bits = new OpenBitSet(reader.maxDoc());\n    TermEnum enumerator =\n        (null != lowerTerm\n         ? reader.terms(new Term(fieldName, lowerTerm))\n         : reader.terms(new Term(fieldName,\"\")));\n    \n    //coords = new HashMap(enumerator.docFreq());\n    \n    try {\n      if (enumerator.term() == null) {\n        return bits;\n      }\n      \n      boolean checkLower = false;\n      if (!includeLower) // make adjustments to set to exclusive\n        checkLower = true;\n  \n      TermDocs termDocs = reader.termDocs();\n      try {          \n        do {\n          Term term = enumerator.term();\n          if (term != null && term.field().equals(fieldName)) {\n            if (!checkLower || null==lowerTerm || term.text().compareTo(lowerTerm) > 0) {\n              checkLower = false;\n              if (upperTerm != null) {\n                int compare = upperTerm.compareTo(term.text());\n                // if beyond the upper term, or is exclusive and\n                // this is equal to the upper term, break out \n                if ((compare < 0) ||\n                  (!includeUpper && compare==0)) {\n                  break;\n                }\n              }\n              // we have a good term, find the docs \n              termDocs.seek(enumerator.term());\n              while (termDocs.next()) {\n                bits.fastSet(termDocs.doc());\n              }\n            }\n          } \n          else {\n            break;\n          }\n        }\n        while (enumerator.next());    \n      } \n      finally {\n        termDocs.close();\n      }\n    } \n    finally {\n      enumerator.close();\n    }\n\n    long end = System.currentTimeMillis();\n    log.info(\"BoundaryBox Time Taken: \"+ (end - start));\n    return bits;\n  }\n\n","sourceOld":"  /**\n   * Returns a BitSet with true for documents which should be\n   * permitted in search results, and false for those that should\n   * not.\n   */\n  @Override\n  public BitSet bits(IndexReader reader) throws IOException {\n    long start = System.currentTimeMillis();\n    \n    BitSet bits = new BitSet(reader.maxDoc());\n    TermEnum enumerator =\n        (null != lowerTerm\n         ? reader.terms(new Term(fieldName, lowerTerm))\n         : reader.terms(new Term(fieldName,\"\")));\n    \n    //coords = new HashMap(enumerator.docFreq());\n    \n    try {\n      if (enumerator.term() == null) {\n        return bits;\n      }\n      \n      boolean checkLower = false;\n      if (!includeLower) // make adjustments to set to exclusive\n        checkLower = true;\n  \n      TermDocs termDocs = reader.termDocs();\n      try {          \n        do {\n          Term term = enumerator.term();\n          if (term != null && term.field().equals(fieldName)) {\n            if (!checkLower || null==lowerTerm || term.text().compareTo(lowerTerm) > 0) {\n              checkLower = false;\n              if (upperTerm != null) {\n                int compare = upperTerm.compareTo(term.text());\n                // if beyond the upper term, or is exclusive and\n                // this is equal to the upper term, break out \n                if ((compare < 0) ||\n                  (!includeUpper && compare==0)) {\n                  break;\n                }\n              }\n              // we have a good term, find the docs \n              termDocs.seek(enumerator.term());\n              while (termDocs.next()) {\n                bits.set(termDocs.doc());\n              }\n            }\n          } \n          else {\n            break;\n          }\n        }\n        while (enumerator.next());    \n      } \n      finally {\n        termDocs.close();\n      }\n    } \n    finally {\n      enumerator.close();\n    }\n\n    long end = System.currentTimeMillis();\n    log.info(\"BoundaryBox Time Taken: \"+ (end - start));\n    return bits;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"04a4a94db1eb59c8583adb166acfe686a031bedc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d41c10b9c61bc826acd344f499e062fb46bc42ae":["04a4a94db1eb59c8583adb166acfe686a031bedc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d41c10b9c61bc826acd344f499e062fb46bc42ae"]},"commit2Childs":{"04a4a94db1eb59c8583adb166acfe686a031bedc":["d41c10b9c61bc826acd344f499e062fb46bc42ae"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["04a4a94db1eb59c8583adb166acfe686a031bedc"],"d41c10b9c61bc826acd344f499e062fb46bc42ae":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}