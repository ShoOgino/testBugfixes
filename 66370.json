{"path":"solr/core/src/java/org/apache/solr/request/IntervalFacets#getCountNumeric().mjava","commits":[{"id":"84b24f47dd3dfa4e2396cd6f819a35445b0a53fd","date":1406137403,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/IntervalFacets#getCountNumeric().mjava","pathOld":"/dev/null","sourceNew":"  private void getCountNumeric() throws IOException {\n    final FieldType ft = schemaField.getType();\n    final String fieldName = schemaField.getName();\n    final NumericType numericType = ft.getNumericType();\n    if (numericType == null) {\n      throw new IllegalStateException();\n    }\n    final List<AtomicReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    final Iterator<AtomicReaderContext> ctxIt = leaves.iterator();\n    AtomicReaderContext ctx = null;\n    NumericDocValues longs = null;\n    Bits docsWithField = null;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n        switch (numericType) {\n          case LONG:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case INT:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case FLOAT:\n            final NumericDocValues floats = DocValues.getNumeric(ctx.reader(), fieldName);\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new NumericDocValues() {\n              @Override\n              public long get(int docID) {\n                long bits = floats.get(docID);\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          case DOUBLE:\n            final NumericDocValues doubles = DocValues.getNumeric(ctx.reader(), fieldName);\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new NumericDocValues() {\n              @Override\n              public long get(int docID) {\n                long bits = doubles.get(docID);\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          default:\n            throw new AssertionError();\n        }\n        docsWithField = DocValues.getDocsWithField(ctx.reader(), schemaField.getName());\n      }\n      long v = longs.get(doc - ctx.docBase);\n      if (v != 0 || docsWithField.get(doc - ctx.docBase)) {\n        accumIntervalWithValue(v);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/IntervalFacets#getCountNumeric().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/IntervalFacets#getCountNumeric().mjava","sourceNew":"  private void getCountNumeric() throws IOException {\n    final FieldType ft = schemaField.getType();\n    final String fieldName = schemaField.getName();\n    final NumericType numericType = ft.getNumericType();\n    if (numericType == null) {\n      throw new IllegalStateException();\n    }\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    final Iterator<LeafReaderContext> ctxIt = leaves.iterator();\n    LeafReaderContext ctx = null;\n    NumericDocValues longs = null;\n    Bits docsWithField = null;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n        switch (numericType) {\n          case LONG:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case INT:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case FLOAT:\n            final NumericDocValues floats = DocValues.getNumeric(ctx.reader(), fieldName);\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new NumericDocValues() {\n              @Override\n              public long get(int docID) {\n                long bits = floats.get(docID);\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          case DOUBLE:\n            final NumericDocValues doubles = DocValues.getNumeric(ctx.reader(), fieldName);\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new NumericDocValues() {\n              @Override\n              public long get(int docID) {\n                long bits = doubles.get(docID);\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          default:\n            throw new AssertionError();\n        }\n        docsWithField = DocValues.getDocsWithField(ctx.reader(), schemaField.getName());\n      }\n      long v = longs.get(doc - ctx.docBase);\n      if (v != 0 || docsWithField.get(doc - ctx.docBase)) {\n        accumIntervalWithValue(v);\n      }\n    }\n  }\n\n","sourceOld":"  private void getCountNumeric() throws IOException {\n    final FieldType ft = schemaField.getType();\n    final String fieldName = schemaField.getName();\n    final NumericType numericType = ft.getNumericType();\n    if (numericType == null) {\n      throw new IllegalStateException();\n    }\n    final List<AtomicReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    final Iterator<AtomicReaderContext> ctxIt = leaves.iterator();\n    AtomicReaderContext ctx = null;\n    NumericDocValues longs = null;\n    Bits docsWithField = null;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n        switch (numericType) {\n          case LONG:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case INT:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case FLOAT:\n            final NumericDocValues floats = DocValues.getNumeric(ctx.reader(), fieldName);\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new NumericDocValues() {\n              @Override\n              public long get(int docID) {\n                long bits = floats.get(docID);\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          case DOUBLE:\n            final NumericDocValues doubles = DocValues.getNumeric(ctx.reader(), fieldName);\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new NumericDocValues() {\n              @Override\n              public long get(int docID) {\n                long bits = doubles.get(docID);\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          default:\n            throw new AssertionError();\n        }\n        docsWithField = DocValues.getDocsWithField(ctx.reader(), schemaField.getName());\n      }\n      long v = longs.get(doc - ctx.docBase);\n      if (v != 0 || docsWithField.get(doc - ctx.docBase)) {\n        accumIntervalWithValue(v);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"770342641f7b505eaa8dccdc666158bff2419109","date":1449868421,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/IntervalFacets#getCountNumeric().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/IntervalFacets#getCountNumeric().mjava","sourceNew":"  private void getCountNumeric() throws IOException {\n    final FieldType ft = schemaField.getType();\n    final String fieldName = schemaField.getName();\n    final LegacyNumericType numericType = ft.getNumericType();\n    if (numericType == null) {\n      throw new IllegalStateException();\n    }\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    final Iterator<LeafReaderContext> ctxIt = leaves.iterator();\n    LeafReaderContext ctx = null;\n    NumericDocValues longs = null;\n    Bits docsWithField = null;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n        switch (numericType) {\n          case LONG:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case INT:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case FLOAT:\n            final NumericDocValues floats = DocValues.getNumeric(ctx.reader(), fieldName);\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new NumericDocValues() {\n              @Override\n              public long get(int docID) {\n                long bits = floats.get(docID);\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          case DOUBLE:\n            final NumericDocValues doubles = DocValues.getNumeric(ctx.reader(), fieldName);\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new NumericDocValues() {\n              @Override\n              public long get(int docID) {\n                long bits = doubles.get(docID);\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          default:\n            throw new AssertionError();\n        }\n        docsWithField = DocValues.getDocsWithField(ctx.reader(), schemaField.getName());\n      }\n      long v = longs.get(doc - ctx.docBase);\n      if (v != 0 || docsWithField.get(doc - ctx.docBase)) {\n        accumIntervalWithValue(v);\n      }\n    }\n  }\n\n","sourceOld":"  private void getCountNumeric() throws IOException {\n    final FieldType ft = schemaField.getType();\n    final String fieldName = schemaField.getName();\n    final NumericType numericType = ft.getNumericType();\n    if (numericType == null) {\n      throw new IllegalStateException();\n    }\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    final Iterator<LeafReaderContext> ctxIt = leaves.iterator();\n    LeafReaderContext ctx = null;\n    NumericDocValues longs = null;\n    Bits docsWithField = null;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n        switch (numericType) {\n          case LONG:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case INT:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case FLOAT:\n            final NumericDocValues floats = DocValues.getNumeric(ctx.reader(), fieldName);\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new NumericDocValues() {\n              @Override\n              public long get(int docID) {\n                long bits = floats.get(docID);\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          case DOUBLE:\n            final NumericDocValues doubles = DocValues.getNumeric(ctx.reader(), fieldName);\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new NumericDocValues() {\n              @Override\n              public long get(int docID) {\n                long bits = doubles.get(docID);\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          default:\n            throw new AssertionError();\n        }\n        docsWithField = DocValues.getDocsWithField(ctx.reader(), schemaField.getName());\n      }\n      long v = longs.get(doc - ctx.docBase);\n      if (v != 0 || docsWithField.get(doc - ctx.docBase)) {\n        accumIntervalWithValue(v);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6652c74b2358a0b13223817a6a793bf1c9d0749d","date":1474465301,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/IntervalFacets#getCountNumeric().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/IntervalFacets#getCountNumeric().mjava","sourceNew":"  private void getCountNumeric() throws IOException {\n    final FieldType ft = schemaField.getType();\n    final String fieldName = schemaField.getName();\n    final LegacyNumericType numericType = ft.getNumericType();\n    if (numericType == null) {\n      throw new IllegalStateException();\n    }\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    final Iterator<LeafReaderContext> ctxIt = leaves.iterator();\n    LeafReaderContext ctx = null;\n    NumericDocValues longs = null;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n        switch (numericType) {\n          case LONG:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case INT:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case FLOAT:\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new FilterNumericDocValues(DocValues.getNumeric(ctx.reader(), fieldName)) {\n              @Override\n              public long longValue() {\n                long bits = super.longValue();\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          case DOUBLE:\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new FilterNumericDocValues(DocValues.getNumeric(ctx.reader(), fieldName)) {\n              @Override\n              public long longValue() {\n                long bits = super.longValue();\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          default:\n            throw new AssertionError();\n        }\n      }\n      int valuesDocID = longs.docID();\n      if (valuesDocID < doc - ctx.docBase) {\n        valuesDocID = longs.advance(doc - ctx.docBase);\n      }\n      if (valuesDocID == doc - ctx.docBase) {\n        accumIntervalWithValue(longs.longValue());\n      }\n    }\n  }\n\n","sourceOld":"  private void getCountNumeric() throws IOException {\n    final FieldType ft = schemaField.getType();\n    final String fieldName = schemaField.getName();\n    final LegacyNumericType numericType = ft.getNumericType();\n    if (numericType == null) {\n      throw new IllegalStateException();\n    }\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    final Iterator<LeafReaderContext> ctxIt = leaves.iterator();\n    LeafReaderContext ctx = null;\n    NumericDocValues longs = null;\n    Bits docsWithField = null;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n        switch (numericType) {\n          case LONG:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case INT:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case FLOAT:\n            final NumericDocValues floats = DocValues.getNumeric(ctx.reader(), fieldName);\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new NumericDocValues() {\n              @Override\n              public long get(int docID) {\n                long bits = floats.get(docID);\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          case DOUBLE:\n            final NumericDocValues doubles = DocValues.getNumeric(ctx.reader(), fieldName);\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new NumericDocValues() {\n              @Override\n              public long get(int docID) {\n                long bits = doubles.get(docID);\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          default:\n            throw new AssertionError();\n        }\n        docsWithField = DocValues.getDocsWithField(ctx.reader(), schemaField.getName());\n      }\n      long v = longs.get(doc - ctx.docBase);\n      if (v != 0 || docsWithField.get(doc - ctx.docBase)) {\n        accumIntervalWithValue(v);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/IntervalFacets#getCountNumeric().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/IntervalFacets#getCountNumeric().mjava","sourceNew":"  private void getCountNumeric() throws IOException {\n    final FieldType ft = schemaField.getType();\n    final String fieldName = schemaField.getName();\n    final LegacyNumericType numericType = ft.getNumericType();\n    if (numericType == null) {\n      throw new IllegalStateException();\n    }\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    final Iterator<LeafReaderContext> ctxIt = leaves.iterator();\n    LeafReaderContext ctx = null;\n    NumericDocValues longs = null;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n        switch (numericType) {\n          case LONG:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case INT:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case FLOAT:\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new FilterNumericDocValues(DocValues.getNumeric(ctx.reader(), fieldName)) {\n              @Override\n              public long longValue() {\n                long bits = super.longValue();\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          case DOUBLE:\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new FilterNumericDocValues(DocValues.getNumeric(ctx.reader(), fieldName)) {\n              @Override\n              public long longValue() {\n                long bits = super.longValue();\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          default:\n            throw new AssertionError();\n        }\n      }\n      int valuesDocID = longs.docID();\n      if (valuesDocID < doc - ctx.docBase) {\n        valuesDocID = longs.advance(doc - ctx.docBase);\n      }\n      if (valuesDocID == doc - ctx.docBase) {\n        accumIntervalWithValue(longs.longValue());\n      }\n    }\n  }\n\n","sourceOld":"  private void getCountNumeric() throws IOException {\n    final FieldType ft = schemaField.getType();\n    final String fieldName = schemaField.getName();\n    final LegacyNumericType numericType = ft.getNumericType();\n    if (numericType == null) {\n      throw new IllegalStateException();\n    }\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    final Iterator<LeafReaderContext> ctxIt = leaves.iterator();\n    LeafReaderContext ctx = null;\n    NumericDocValues longs = null;\n    Bits docsWithField = null;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n        switch (numericType) {\n          case LONG:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case INT:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case FLOAT:\n            final NumericDocValues floats = DocValues.getNumeric(ctx.reader(), fieldName);\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new NumericDocValues() {\n              @Override\n              public long get(int docID) {\n                long bits = floats.get(docID);\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          case DOUBLE:\n            final NumericDocValues doubles = DocValues.getNumeric(ctx.reader(), fieldName);\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new NumericDocValues() {\n              @Override\n              public long get(int docID) {\n                long bits = doubles.get(docID);\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          default:\n            throw new AssertionError();\n        }\n        docsWithField = DocValues.getDocsWithField(ctx.reader(), schemaField.getName());\n      }\n      long v = longs.get(doc - ctx.docBase);\n      if (v != 0 || docsWithField.get(doc - ctx.docBase)) {\n        accumIntervalWithValue(v);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5d217880fb207e1a26143863d06cf461c7cabeec","date":1475691535,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/IntervalFacets#getCountNumeric().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/IntervalFacets#getCountNumeric().mjava","sourceNew":"  private void getCountNumeric() throws IOException {\n    final FieldType ft = schemaField.getType();\n    final String fieldName = schemaField.getName();\n    final LegacyNumericType numericType = ft.getNumericType();\n    if (numericType == null) {\n      throw new IllegalStateException();\n    }\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    final Iterator<LeafReaderContext> ctxIt = leaves.iterator();\n    LeafReaderContext ctx = null;\n    NumericDocValues longs = null;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n        switch (numericType) {\n          case LONG:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case INT:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case FLOAT:\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new FilterNumericDocValues(DocValues.getNumeric(ctx.reader(), fieldName)) {\n              @Override\n              public long longValue() throws IOException {\n                long bits = super.longValue();\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          case DOUBLE:\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new FilterNumericDocValues(DocValues.getNumeric(ctx.reader(), fieldName)) {\n              @Override\n              public long longValue() throws IOException {\n                long bits = super.longValue();\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          default:\n            throw new AssertionError();\n        }\n      }\n      int valuesDocID = longs.docID();\n      if (valuesDocID < doc - ctx.docBase) {\n        valuesDocID = longs.advance(doc - ctx.docBase);\n      }\n      if (valuesDocID == doc - ctx.docBase) {\n        accumIntervalWithValue(longs.longValue());\n      }\n    }\n  }\n\n","sourceOld":"  private void getCountNumeric() throws IOException {\n    final FieldType ft = schemaField.getType();\n    final String fieldName = schemaField.getName();\n    final LegacyNumericType numericType = ft.getNumericType();\n    if (numericType == null) {\n      throw new IllegalStateException();\n    }\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    final Iterator<LeafReaderContext> ctxIt = leaves.iterator();\n    LeafReaderContext ctx = null;\n    NumericDocValues longs = null;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n        switch (numericType) {\n          case LONG:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case INT:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case FLOAT:\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new FilterNumericDocValues(DocValues.getNumeric(ctx.reader(), fieldName)) {\n              @Override\n              public long longValue() {\n                long bits = super.longValue();\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          case DOUBLE:\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new FilterNumericDocValues(DocValues.getNumeric(ctx.reader(), fieldName)) {\n              @Override\n              public long longValue() {\n                long bits = super.longValue();\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          default:\n            throw new AssertionError();\n        }\n      }\n      int valuesDocID = longs.docID();\n      if (valuesDocID < doc - ctx.docBase) {\n        valuesDocID = longs.advance(doc - ctx.docBase);\n      }\n      if (valuesDocID == doc - ctx.docBase) {\n        accumIntervalWithValue(longs.longValue());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/IntervalFacets#getCountNumeric().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/IntervalFacets#getCountNumeric().mjava","sourceNew":"  private void getCountNumeric() throws IOException {\n    final FieldType ft = schemaField.getType();\n    final String fieldName = schemaField.getName();\n    final LegacyNumericType numericType = ft.getNumericType();\n    if (numericType == null) {\n      throw new IllegalStateException();\n    }\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    final Iterator<LeafReaderContext> ctxIt = leaves.iterator();\n    LeafReaderContext ctx = null;\n    NumericDocValues longs = null;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n        switch (numericType) {\n          case LONG:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case INT:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case FLOAT:\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new FilterNumericDocValues(DocValues.getNumeric(ctx.reader(), fieldName)) {\n              @Override\n              public long longValue() throws IOException {\n                long bits = super.longValue();\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          case DOUBLE:\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new FilterNumericDocValues(DocValues.getNumeric(ctx.reader(), fieldName)) {\n              @Override\n              public long longValue() throws IOException {\n                long bits = super.longValue();\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          default:\n            throw new AssertionError();\n        }\n      }\n      int valuesDocID = longs.docID();\n      if (valuesDocID < doc - ctx.docBase) {\n        valuesDocID = longs.advance(doc - ctx.docBase);\n      }\n      if (valuesDocID == doc - ctx.docBase) {\n        accumIntervalWithValue(longs.longValue());\n      }\n    }\n  }\n\n","sourceOld":"  private void getCountNumeric() throws IOException {\n    final FieldType ft = schemaField.getType();\n    final String fieldName = schemaField.getName();\n    final LegacyNumericType numericType = ft.getNumericType();\n    if (numericType == null) {\n      throw new IllegalStateException();\n    }\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    final Iterator<LeafReaderContext> ctxIt = leaves.iterator();\n    LeafReaderContext ctx = null;\n    NumericDocValues longs = null;\n    Bits docsWithField = null;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n        switch (numericType) {\n          case LONG:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case INT:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case FLOAT:\n            final NumericDocValues floats = DocValues.getNumeric(ctx.reader(), fieldName);\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new NumericDocValues() {\n              @Override\n              public long get(int docID) {\n                long bits = floats.get(docID);\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          case DOUBLE:\n            final NumericDocValues doubles = DocValues.getNumeric(ctx.reader(), fieldName);\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new NumericDocValues() {\n              @Override\n              public long get(int docID) {\n                long bits = doubles.get(docID);\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          default:\n            throw new AssertionError();\n        }\n        docsWithField = DocValues.getDocsWithField(ctx.reader(), schemaField.getName());\n      }\n      long v = longs.get(doc - ctx.docBase);\n      if (v != 0 || docsWithField.get(doc - ctx.docBase)) {\n        accumIntervalWithValue(v);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d81baa64023bbb9b43f6d929ee168b105940d30","date":1486492702,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/IntervalFacets#getCountNumeric().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/IntervalFacets#getCountNumeric().mjava","sourceNew":"  private void getCountNumeric() throws IOException {\n    final FieldType ft = schemaField.getType();\n    final String fieldName = schemaField.getName();\n    final NumberType numericType = ft.getNumberType();\n    if (numericType == null) {\n      throw new IllegalStateException();\n    }\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    final Iterator<LeafReaderContext> ctxIt = leaves.iterator();\n    LeafReaderContext ctx = null;\n    NumericDocValues longs = null;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n        switch (numericType) {\n          case LONG:\n          case DATE:\n          case INTEGER:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case FLOAT:\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new FilterNumericDocValues(DocValues.getNumeric(ctx.reader(), fieldName)) {\n              @Override\n              public long longValue() throws IOException {\n                long bits = super.longValue();\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          case DOUBLE:\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new FilterNumericDocValues(DocValues.getNumeric(ctx.reader(), fieldName)) {\n              @Override\n              public long longValue() throws IOException {\n                long bits = super.longValue();\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          default:\n            throw new AssertionError();\n        }\n      }\n      int valuesDocID = longs.docID();\n      if (valuesDocID < doc - ctx.docBase) {\n        valuesDocID = longs.advance(doc - ctx.docBase);\n      }\n      if (valuesDocID == doc - ctx.docBase) {\n        accumIntervalWithValue(longs.longValue());\n      }\n    }\n  }\n\n","sourceOld":"  private void getCountNumeric() throws IOException {\n    final FieldType ft = schemaField.getType();\n    final String fieldName = schemaField.getName();\n    final LegacyNumericType numericType = ft.getNumericType();\n    if (numericType == null) {\n      throw new IllegalStateException();\n    }\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    final Iterator<LeafReaderContext> ctxIt = leaves.iterator();\n    LeafReaderContext ctx = null;\n    NumericDocValues longs = null;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n        switch (numericType) {\n          case LONG:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case INT:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case FLOAT:\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new FilterNumericDocValues(DocValues.getNumeric(ctx.reader(), fieldName)) {\n              @Override\n              public long longValue() throws IOException {\n                long bits = super.longValue();\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          case DOUBLE:\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new FilterNumericDocValues(DocValues.getNumeric(ctx.reader(), fieldName)) {\n              @Override\n              public long longValue() throws IOException {\n                long bits = super.longValue();\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          default:\n            throw new AssertionError();\n        }\n      }\n      int valuesDocID = longs.docID();\n      if (valuesDocID < doc - ctx.docBase) {\n        valuesDocID = longs.advance(doc - ctx.docBase);\n      }\n      if (valuesDocID == doc - ctx.docBase) {\n        accumIntervalWithValue(longs.longValue());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0a64ffcef6ae839baf314a48817008c796b053d","date":1499974056,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/IntervalFacets#getCountNumeric().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/IntervalFacets#getCountNumeric().mjava","sourceNew":"  private void getCountNumeric() throws IOException {\n    final FieldType ft = schemaField.getType();\n    final String fieldName = schemaField.getName();\n    final NumberType numericType = ft.getNumberType();\n    if (numericType == null) {\n      throw new IllegalStateException();\n    }\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    final Iterator<LeafReaderContext> ctxIt = leaves.iterator();\n    LeafReaderContext ctx = null;\n    NumericDocValues longs = null;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n        switch (numericType) {\n          case LONG:\n          case DATE:\n          case INTEGER:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case FLOAT:\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new FilterNumericDocValues(DocValues.getNumeric(ctx.reader(), fieldName)) {\n              @Override\n              public long longValue() throws IOException {\n                return NumericUtils.sortableFloatBits((int)super.longValue());\n              }\n            };\n            break;\n          case DOUBLE:\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new FilterNumericDocValues(DocValues.getNumeric(ctx.reader(), fieldName)) {\n              @Override\n              public long longValue() throws IOException {\n               return NumericUtils.sortableDoubleBits(super.longValue());\n              }\n            };\n            break;\n          default:\n            throw new AssertionError();\n        }\n      }\n      int valuesDocID = longs.docID();\n      if (valuesDocID < doc - ctx.docBase) {\n        valuesDocID = longs.advance(doc - ctx.docBase);\n      }\n      if (valuesDocID == doc - ctx.docBase) {\n        accumIntervalWithValue(longs.longValue());\n      }\n    }\n  }\n\n","sourceOld":"  private void getCountNumeric() throws IOException {\n    final FieldType ft = schemaField.getType();\n    final String fieldName = schemaField.getName();\n    final NumberType numericType = ft.getNumberType();\n    if (numericType == null) {\n      throw new IllegalStateException();\n    }\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    final Iterator<LeafReaderContext> ctxIt = leaves.iterator();\n    LeafReaderContext ctx = null;\n    NumericDocValues longs = null;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n        switch (numericType) {\n          case LONG:\n          case DATE:\n          case INTEGER:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case FLOAT:\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new FilterNumericDocValues(DocValues.getNumeric(ctx.reader(), fieldName)) {\n              @Override\n              public long longValue() throws IOException {\n                long bits = super.longValue();\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          case DOUBLE:\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new FilterNumericDocValues(DocValues.getNumeric(ctx.reader(), fieldName)) {\n              @Override\n              public long longValue() throws IOException {\n                long bits = super.longValue();\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          default:\n            throw new AssertionError();\n        }\n      }\n      int valuesDocID = longs.docID();\n      if (valuesDocID < doc - ctx.docBase) {\n        valuesDocID = longs.advance(doc - ctx.docBase);\n      }\n      if (valuesDocID == doc - ctx.docBase) {\n        accumIntervalWithValue(longs.longValue());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aaf90fc29510e72665ac7934f34c3d1c25efad64","date":1500354819,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/IntervalFacets#getCountNumeric().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/IntervalFacets#getCountNumeric().mjava","sourceNew":"  private void getCountNumeric() throws IOException {\n    final FieldType ft = schemaField.getType();\n    final String fieldName = schemaField.getName();\n    final NumberType numericType = ft.getNumberType();\n    if (numericType == null) {\n      throw new IllegalStateException();\n    }\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    final Iterator<LeafReaderContext> ctxIt = leaves.iterator();\n    LeafReaderContext ctx = null;\n    NumericDocValues longs = null;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n        switch (numericType) {\n          case LONG:\n          case DATE:\n          case INTEGER:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case FLOAT:\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new FilterNumericDocValues(DocValues.getNumeric(ctx.reader(), fieldName)) {\n              @Override\n              public long longValue() throws IOException {\n                return NumericUtils.sortableFloatBits((int)super.longValue());\n              }\n            };\n            break;\n          case DOUBLE:\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new FilterNumericDocValues(DocValues.getNumeric(ctx.reader(), fieldName)) {\n              @Override\n              public long longValue() throws IOException {\n               return NumericUtils.sortableDoubleBits(super.longValue());\n              }\n            };\n            break;\n          default:\n            throw new AssertionError();\n        }\n      }\n      int valuesDocID = longs.docID();\n      if (valuesDocID < doc - ctx.docBase) {\n        valuesDocID = longs.advance(doc - ctx.docBase);\n      }\n      if (valuesDocID == doc - ctx.docBase) {\n        accumIntervalWithValue(longs.longValue());\n      }\n    }\n  }\n\n","sourceOld":"  private void getCountNumeric() throws IOException {\n    final FieldType ft = schemaField.getType();\n    final String fieldName = schemaField.getName();\n    final NumberType numericType = ft.getNumberType();\n    if (numericType == null) {\n      throw new IllegalStateException();\n    }\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    final Iterator<LeafReaderContext> ctxIt = leaves.iterator();\n    LeafReaderContext ctx = null;\n    NumericDocValues longs = null;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n        switch (numericType) {\n          case LONG:\n          case DATE:\n          case INTEGER:\n            longs = DocValues.getNumeric(ctx.reader(), fieldName);\n            break;\n          case FLOAT:\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new FilterNumericDocValues(DocValues.getNumeric(ctx.reader(), fieldName)) {\n              @Override\n              public long longValue() throws IOException {\n                long bits = super.longValue();\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          case DOUBLE:\n            // TODO: this bit flipping should probably be moved to tie-break in the PQ comparator\n            longs = new FilterNumericDocValues(DocValues.getNumeric(ctx.reader(), fieldName)) {\n              @Override\n              public long longValue() throws IOException {\n                long bits = super.longValue();\n                if (bits < 0) bits ^= 0x7fffffffffffffffL;\n                return bits;\n              }\n            };\n            break;\n          default:\n            throw new AssertionError();\n        }\n      }\n      int valuesDocID = longs.docID();\n      if (valuesDocID < doc - ctx.docBase) {\n        valuesDocID = longs.advance(doc - ctx.docBase);\n      }\n      if (valuesDocID == doc - ctx.docBase) {\n        accumIntervalWithValue(longs.longValue());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3d81baa64023bbb9b43f6d929ee168b105940d30":["5d217880fb207e1a26143863d06cf461c7cabeec"],"aaf90fc29510e72665ac7934f34c3d1c25efad64":["3d81baa64023bbb9b43f6d929ee168b105940d30","d0a64ffcef6ae839baf314a48817008c796b053d"],"d0a64ffcef6ae839baf314a48817008c796b053d":["3d81baa64023bbb9b43f6d929ee168b105940d30"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["770342641f7b505eaa8dccdc666158bff2419109","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["770342641f7b505eaa8dccdc666158bff2419109"],"5d217880fb207e1a26143863d06cf461c7cabeec":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"84b24f47dd3dfa4e2396cd6f819a35445b0a53fd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"770342641f7b505eaa8dccdc666158bff2419109":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["84b24f47dd3dfa4e2396cd6f819a35445b0a53fd"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["770342641f7b505eaa8dccdc666158bff2419109","5d217880fb207e1a26143863d06cf461c7cabeec"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d0a64ffcef6ae839baf314a48817008c796b053d"]},"commit2Childs":{"3d81baa64023bbb9b43f6d929ee168b105940d30":["aaf90fc29510e72665ac7934f34c3d1c25efad64","d0a64ffcef6ae839baf314a48817008c796b053d"],"aaf90fc29510e72665ac7934f34c3d1c25efad64":[],"d0a64ffcef6ae839baf314a48817008c796b053d":["aaf90fc29510e72665ac7934f34c3d1c25efad64","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["84b24f47dd3dfa4e2396cd6f819a35445b0a53fd"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["5d217880fb207e1a26143863d06cf461c7cabeec"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"5d217880fb207e1a26143863d06cf461c7cabeec":["3d81baa64023bbb9b43f6d929ee168b105940d30","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"84b24f47dd3dfa4e2396cd6f819a35445b0a53fd":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"770342641f7b505eaa8dccdc666158bff2419109":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","6652c74b2358a0b13223817a6a793bf1c9d0749d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["770342641f7b505eaa8dccdc666158bff2419109"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aaf90fc29510e72665ac7934f34c3d1c25efad64","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}