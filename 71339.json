{"path":"lucene/facet/src/test/org/apache/lucene/facet/simple/TestSimpleDrillSideways#verifyEquals(String[][],IndexSearcher,SimpleTestFacetResult,SimpleDrillSidewaysResult,Map[String,Float],boolean).mjava","commits":[{"id":"19f5022544a8fc895776356d1b35a4b46d05945c","date":1385063323,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/simple/TestSimpleDrillSideways#verifyEquals(String[][],IndexSearcher,SimpleTestFacetResult,SimpleDrillSidewaysResult,Map[String,Float],boolean).mjava","pathOld":"/dev/null","sourceNew":"  void verifyEquals(String[][] dimValues, IndexSearcher s, SimpleTestFacetResult expected,\n                    SimpleDrillSidewaysResult actual, Map<String,Float> scores, boolean isSortedSetDV) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for(int i=0;i<expected.hits.size();i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id,\n                   s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      int topN = random().nextBoolean() ? dimValues[dim].length : _TestUtil.nextInt(random(), 1, dimValues[dim].length);\n      SimpleFacetResult fr = actual.facets.getTopChildren(topN, \"dim\"+dim);\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim + \" topN=\" + topN + \" (vs \" + dimValues[dim].length + \" unique values)\");\n        System.out.println(\"      actual\");\n      }\n\n      int idx = 0;\n      Map<String,Integer> actualValues = new HashMap<String,Integer>();\n\n      if (fr != null) {\n        for(LabelAndValue labelValue : fr.labelValues) {\n          actualValues.put(labelValue.label, labelValue.value.intValue());\n          if (VERBOSE) {\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(labelValue.label) + \": \" + labelValue.value);\n            idx++;\n          }\n        }\n      }\n\n      if (topN < dimValues[dim].length) {\n        int[] topNIDs = getTopNOrds(expected.counts[dim], dimValues[dim], topN);\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (sorted)\");\n          for(int i=0;i<topNIDs.length;i++) {\n            int expectedOrd = topNIDs[i];\n            String value = dimValues[dim][expectedOrd];\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][expectedOrd]);\n            idx++;\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"      topN=\" + topN + \" expectedTopN=\" + topNIDs.length);\n        }\n\n        if (fr != null) {\n          assertEquals(topNIDs.length, fr.labelValues.length);\n        } else {\n          assertEquals(0, topNIDs.length);\n        }\n        for(int i=0;i<topNIDs.length;i++) {\n          int expectedOrd = topNIDs[i];\n          assertEquals(expected.counts[dim][expectedOrd], fr.labelValues[i].value.intValue());\n          if (isSortedSetDV) {\n            // Tie-break facet labels are only in unicode\n            // order with SortedSetDVFacets:\n            assertEquals(\"value @ idx=\" + i, dimValues[dim][expectedOrd], fr.labelValues[i].label);\n          }\n        }\n      } else {\n\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (unsorted)\");\n          for(int i=0;i<dimValues[dim].length;i++) {\n            String value = dimValues[dim][i];\n            if (expected.counts[dim][i] != 0) {\n              System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n              idx++;\n            } \n          }\n        }\n\n        int setCount = 0;\n        for(int i=0;i<dimValues[dim].length;i++) {\n          String value = dimValues[dim][i];\n          if (expected.counts[dim][i] != 0) {\n            assertTrue(actualValues.containsKey(value));\n            assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n            setCount++;\n          } else {\n            assertFalse(actualValues.containsKey(value));\n          }\n        }\n        assertEquals(setCount, actualValues.size());\n      }\n\n      // nocommit if we add this to SimpleFR then re-enable this:\n      // assertEquals(\"dim=\" + dim, expected.uniqueCounts[dim], fr.getNumValidDescendants());\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"21d36d0db865f7b84026b447bec653469a6e66df","date":1385495602,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#verifyEquals(String[][],IndexSearcher,TestFacetResult,DrillSidewaysResult,Map[String,Float],boolean).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/simple/TestSimpleDrillSideways#verifyEquals(String[][],IndexSearcher,SimpleTestFacetResult,SimpleDrillSidewaysResult,Map[String,Float],boolean).mjava","sourceNew":"  void verifyEquals(String[][] dimValues, IndexSearcher s, TestFacetResult expected,\n                    DrillSidewaysResult actual, Map<String,Float> scores, boolean isSortedSetDV) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for(int i=0;i<expected.hits.size();i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id,\n                   s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      int topN = random().nextBoolean() ? dimValues[dim].length : _TestUtil.nextInt(random(), 1, dimValues[dim].length);\n      FacetResult fr = actual.facets.getTopChildren(topN, \"dim\"+dim);\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim + \" topN=\" + topN + \" (vs \" + dimValues[dim].length + \" unique values)\");\n        System.out.println(\"      actual\");\n      }\n\n      int idx = 0;\n      Map<String,Integer> actualValues = new HashMap<String,Integer>();\n\n      if (fr != null) {\n        for(LabelAndValue labelValue : fr.labelValues) {\n          actualValues.put(labelValue.label, labelValue.value.intValue());\n          if (VERBOSE) {\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(labelValue.label) + \": \" + labelValue.value);\n            idx++;\n          }\n        }\n      }\n\n      if (topN < dimValues[dim].length) {\n        int[] topNIDs = getTopNOrds(expected.counts[dim], dimValues[dim], topN);\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (sorted)\");\n          for(int i=0;i<topNIDs.length;i++) {\n            int expectedOrd = topNIDs[i];\n            String value = dimValues[dim][expectedOrd];\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][expectedOrd]);\n            idx++;\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"      topN=\" + topN + \" expectedTopN=\" + topNIDs.length);\n        }\n\n        if (fr != null) {\n          assertEquals(topNIDs.length, fr.labelValues.length);\n        } else {\n          assertEquals(0, topNIDs.length);\n        }\n        for(int i=0;i<topNIDs.length;i++) {\n          int expectedOrd = topNIDs[i];\n          assertEquals(expected.counts[dim][expectedOrd], fr.labelValues[i].value.intValue());\n          if (isSortedSetDV) {\n            // Tie-break facet labels are only in unicode\n            // order with SortedSetDVFacets:\n            assertEquals(\"value @ idx=\" + i, dimValues[dim][expectedOrd], fr.labelValues[i].label);\n          }\n        }\n      } else {\n\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (unsorted)\");\n          for(int i=0;i<dimValues[dim].length;i++) {\n            String value = dimValues[dim][i];\n            if (expected.counts[dim][i] != 0) {\n              System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n              idx++;\n            } \n          }\n        }\n\n        int setCount = 0;\n        for(int i=0;i<dimValues[dim].length;i++) {\n          String value = dimValues[dim][i];\n          if (expected.counts[dim][i] != 0) {\n            assertTrue(actualValues.containsKey(value));\n            assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n            setCount++;\n          } else {\n            assertFalse(actualValues.containsKey(value));\n          }\n        }\n        assertEquals(setCount, actualValues.size());\n      }\n\n      // nocommit if we add this to FR then re-enable this:\n      // assertEquals(\"dim=\" + dim, expected.uniqueCounts[dim], fr.getNumValidDescendants());\n    }\n  }\n\n","sourceOld":"  void verifyEquals(String[][] dimValues, IndexSearcher s, SimpleTestFacetResult expected,\n                    SimpleDrillSidewaysResult actual, Map<String,Float> scores, boolean isSortedSetDV) throws Exception {\n    if (VERBOSE) {\n      System.out.println(\"  verify totHits=\" + expected.hits.size());\n    }\n    assertEquals(expected.hits.size(), actual.hits.totalHits);\n    assertEquals(expected.hits.size(), actual.hits.scoreDocs.length);\n    for(int i=0;i<expected.hits.size();i++) {\n      if (VERBOSE) {\n        System.out.println(\"    hit \" + i + \" expected=\" + expected.hits.get(i).id);\n      }\n      assertEquals(expected.hits.get(i).id,\n                   s.doc(actual.hits.scoreDocs[i].doc).get(\"id\"));\n      // Score should be IDENTICAL:\n      assertEquals(scores.get(expected.hits.get(i).id), actual.hits.scoreDocs[i].score, 0.0f);\n    }\n\n    for(int dim=0;dim<expected.counts.length;dim++) {\n      int topN = random().nextBoolean() ? dimValues[dim].length : _TestUtil.nextInt(random(), 1, dimValues[dim].length);\n      SimpleFacetResult fr = actual.facets.getTopChildren(topN, \"dim\"+dim);\n      if (VERBOSE) {\n        System.out.println(\"    dim\" + dim + \" topN=\" + topN + \" (vs \" + dimValues[dim].length + \" unique values)\");\n        System.out.println(\"      actual\");\n      }\n\n      int idx = 0;\n      Map<String,Integer> actualValues = new HashMap<String,Integer>();\n\n      if (fr != null) {\n        for(LabelAndValue labelValue : fr.labelValues) {\n          actualValues.put(labelValue.label, labelValue.value.intValue());\n          if (VERBOSE) {\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(labelValue.label) + \": \" + labelValue.value);\n            idx++;\n          }\n        }\n      }\n\n      if (topN < dimValues[dim].length) {\n        int[] topNIDs = getTopNOrds(expected.counts[dim], dimValues[dim], topN);\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (sorted)\");\n          for(int i=0;i<topNIDs.length;i++) {\n            int expectedOrd = topNIDs[i];\n            String value = dimValues[dim][expectedOrd];\n            System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][expectedOrd]);\n            idx++;\n          }\n        }\n        if (VERBOSE) {\n          System.out.println(\"      topN=\" + topN + \" expectedTopN=\" + topNIDs.length);\n        }\n\n        if (fr != null) {\n          assertEquals(topNIDs.length, fr.labelValues.length);\n        } else {\n          assertEquals(0, topNIDs.length);\n        }\n        for(int i=0;i<topNIDs.length;i++) {\n          int expectedOrd = topNIDs[i];\n          assertEquals(expected.counts[dim][expectedOrd], fr.labelValues[i].value.intValue());\n          if (isSortedSetDV) {\n            // Tie-break facet labels are only in unicode\n            // order with SortedSetDVFacets:\n            assertEquals(\"value @ idx=\" + i, dimValues[dim][expectedOrd], fr.labelValues[i].label);\n          }\n        }\n      } else {\n\n        if (VERBOSE) {\n          idx = 0;\n          System.out.println(\"      expected (unsorted)\");\n          for(int i=0;i<dimValues[dim].length;i++) {\n            String value = dimValues[dim][i];\n            if (expected.counts[dim][i] != 0) {\n              System.out.println(\"        \" + idx + \": \" + new BytesRef(value) + \": \" + expected.counts[dim][i]);\n              idx++;\n            } \n          }\n        }\n\n        int setCount = 0;\n        for(int i=0;i<dimValues[dim].length;i++) {\n          String value = dimValues[dim][i];\n          if (expected.counts[dim][i] != 0) {\n            assertTrue(actualValues.containsKey(value));\n            assertEquals(expected.counts[dim][i], actualValues.get(value).intValue());\n            setCount++;\n          } else {\n            assertFalse(actualValues.containsKey(value));\n          }\n        }\n        assertEquals(setCount, actualValues.size());\n      }\n\n      // nocommit if we add this to SimpleFR then re-enable this:\n      // assertEquals(\"dim=\" + dim, expected.uniqueCounts[dim], fr.getNumValidDescendants());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"19f5022544a8fc895776356d1b35a4b46d05945c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"21d36d0db865f7b84026b447bec653469a6e66df":["19f5022544a8fc895776356d1b35a4b46d05945c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"19f5022544a8fc895776356d1b35a4b46d05945c":["21d36d0db865f7b84026b447bec653469a6e66df"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["19f5022544a8fc895776356d1b35a4b46d05945c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"21d36d0db865f7b84026b447bec653469a6e66df":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["21d36d0db865f7b84026b447bec653469a6e66df","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}