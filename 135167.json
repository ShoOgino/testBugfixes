{"path":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteReplicaFromClusterState(String).mjava","commits":[{"id":"28ba172425e443e0f08a49de6d73586c418d7251","date":1523970991,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteReplicaFromClusterState(String).mjava","pathOld":"/dev/null","sourceNew":"  public void deleteReplicaFromClusterState(String legacyCloud) throws Exception {\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, legacyCloud).process(cluster.getSolrClient());\n    final String collectionName = \"deleteFromClusterState_\"+legacyCloud;\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 3)\n        .process(cluster.getSolrClient());\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"1\"));\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\"));\n    cluster.getSolrClient().commit(collectionName);\n\n    Slice shard = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica replica = getRandomReplica(shard);\n    JettySolrRunner replicaJetty = cluster.getReplicaJetty(replica);\n    ZkStateReaderAccessor accessor = new ZkStateReaderAccessor(replicaJetty.getCoreContainer().getZkController().getZkStateReader());\n    Set<CollectionStateWatcher> watchers = accessor.getStateWatchers(collectionName);\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n        ZkStateReader.CORE_NAME_PROP, replica.getCoreName(),\n        ZkStateReader.NODE_NAME_PROP, replica.getNodeName(),\n        ZkStateReader.COLLECTION_PROP, collectionName,\n        ZkStateReader.CORE_NODE_NAME_PROP, replica.getName(),\n        ZkStateReader.BASE_URL_PROP, replica.getBaseUrl());\n    Overseer.getStateUpdateQueue(cluster.getZkClient()).offer(Utils.toJSON(m));\n\n    waitForState(\"Timeout waiting for replica get deleted\", collectionName,\n        (liveNodes, collectionState) -> collectionState.getSlice(\"shard1\").getReplicas().size() == 2);\n\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Waiting for replica get unloaded\", () ->\n        replicaJetty.getCoreContainer().getCoreDescriptor(replica.getCoreName()) == null\n    );\n    // the core no longer watch collection state since it was removed\n    timeOut = new TimeOut(60, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Waiting for watcher get removed\", () ->\n        watchers.size() - 1 == accessor.getStateWatchers(collectionName).size()\n    );\n\n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteReplicaFromClusterState(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteReplicaFromClusterState(String).mjava","sourceNew":"  private void deleteReplicaFromClusterState(String legacyCloud) throws Exception {\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, legacyCloud).process(cluster.getSolrClient());\n    final String collectionName = \"deleteFromClusterState_\"+legacyCloud;\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 3)\n        .process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(collectionName, 1, 3);\n    \n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"1\"));\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\"));\n    cluster.getSolrClient().commit(collectionName);\n\n    Slice shard = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica replica = getRandomReplica(shard);\n    JettySolrRunner replicaJetty = cluster.getReplicaJetty(replica);\n    ZkStateReaderAccessor accessor = new ZkStateReaderAccessor(replicaJetty.getCoreContainer().getZkController().getZkStateReader());\n    Set<CollectionStateWatcher> watchers = accessor.getStateWatchers(collectionName);\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n        ZkStateReader.CORE_NAME_PROP, replica.getCoreName(),\n        ZkStateReader.NODE_NAME_PROP, replica.getNodeName(),\n        ZkStateReader.COLLECTION_PROP, collectionName,\n        ZkStateReader.CORE_NODE_NAME_PROP, replica.getName(),\n        ZkStateReader.BASE_URL_PROP, replica.getBaseUrl());\n\n    cluster.getOpenOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n\n    waitForState(\"Timeout waiting for replica get deleted\", collectionName,\n        (liveNodes, collectionState) -> collectionState.getSlice(\"shard1\").getReplicas().size() == 2);\n\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Waiting for replica get unloaded\", () ->\n        replicaJetty.getCoreContainer().getCoreDescriptor(replica.getCoreName()) == null\n    );\n    // the core no longer watch collection state since it was removed\n    timeOut = new TimeOut(60, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Waiting for watcher get removed\", () ->\n        watchers.size() - 1 == accessor.getStateWatchers(collectionName).size()\n    );\n\n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","sourceOld":"  public void deleteReplicaFromClusterState(String legacyCloud) throws Exception {\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, legacyCloud).process(cluster.getSolrClient());\n    final String collectionName = \"deleteFromClusterState_\"+legacyCloud;\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 3)\n        .process(cluster.getSolrClient());\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"1\"));\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\"));\n    cluster.getSolrClient().commit(collectionName);\n\n    Slice shard = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica replica = getRandomReplica(shard);\n    JettySolrRunner replicaJetty = cluster.getReplicaJetty(replica);\n    ZkStateReaderAccessor accessor = new ZkStateReaderAccessor(replicaJetty.getCoreContainer().getZkController().getZkStateReader());\n    Set<CollectionStateWatcher> watchers = accessor.getStateWatchers(collectionName);\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n        ZkStateReader.CORE_NAME_PROP, replica.getCoreName(),\n        ZkStateReader.NODE_NAME_PROP, replica.getNodeName(),\n        ZkStateReader.COLLECTION_PROP, collectionName,\n        ZkStateReader.CORE_NODE_NAME_PROP, replica.getName(),\n        ZkStateReader.BASE_URL_PROP, replica.getBaseUrl());\n    Overseer.getStateUpdateQueue(cluster.getZkClient()).offer(Utils.toJSON(m));\n\n    waitForState(\"Timeout waiting for replica get deleted\", collectionName,\n        (liveNodes, collectionState) -> collectionState.getSlice(\"shard1\").getReplicas().size() == 2);\n\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Waiting for replica get unloaded\", () ->\n        replicaJetty.getCoreContainer().getCoreDescriptor(replica.getCoreName()) == null\n    );\n    // the core no longer watch collection state since it was removed\n    timeOut = new TimeOut(60, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Waiting for watcher get removed\", () ->\n        watchers.size() - 1 == accessor.getStateWatchers(collectionName).size()\n    );\n\n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","bugFix":["28ba172425e443e0f08a49de6d73586c418d7251"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b366e7dd3172289251a86be96031af4002cd19c","date":1560790783,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteReplicaFromClusterState(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteReplicaFromClusterState(String).mjava","sourceNew":"  private void deleteReplicaFromClusterState(String legacyCloud) throws Exception {\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, legacyCloud).process(cluster.getSolrClient());\n    final String collectionName = \"deleteFromClusterState_\"+legacyCloud;\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 3)\n        .process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(collectionName, 1, 3);\n    \n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"1\"));\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\"));\n    cluster.getSolrClient().commit(collectionName);\n\n    Slice shard = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica replica = getRandomReplica(shard);\n    JettySolrRunner replicaJetty = cluster.getReplicaJetty(replica);\n    ZkStateReaderAccessor accessor = new ZkStateReaderAccessor(replicaJetty.getCoreContainer().getZkController().getZkStateReader());\n    Set<DocCollectionWatcher> watchers = accessor.getStateWatchers(collectionName);\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n        ZkStateReader.CORE_NAME_PROP, replica.getCoreName(),\n        ZkStateReader.NODE_NAME_PROP, replica.getNodeName(),\n        ZkStateReader.COLLECTION_PROP, collectionName,\n        ZkStateReader.CORE_NODE_NAME_PROP, replica.getName(),\n        ZkStateReader.BASE_URL_PROP, replica.getBaseUrl());\n\n    cluster.getOpenOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n\n    waitForState(\"Timeout waiting for replica get deleted\", collectionName,\n        (liveNodes, collectionState) -> collectionState.getSlice(\"shard1\").getReplicas().size() == 2);\n\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Waiting for replica get unloaded\", () ->\n        replicaJetty.getCoreContainer().getCoreDescriptor(replica.getCoreName()) == null\n    );\n    // the core no longer watch collection state since it was removed\n    timeOut = new TimeOut(60, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Waiting for watcher get removed\", () ->\n        watchers.size() - 1 == accessor.getStateWatchers(collectionName).size()\n    );\n\n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","sourceOld":"  private void deleteReplicaFromClusterState(String legacyCloud) throws Exception {\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, legacyCloud).process(cluster.getSolrClient());\n    final String collectionName = \"deleteFromClusterState_\"+legacyCloud;\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 3)\n        .process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(collectionName, 1, 3);\n    \n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"1\"));\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\"));\n    cluster.getSolrClient().commit(collectionName);\n\n    Slice shard = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica replica = getRandomReplica(shard);\n    JettySolrRunner replicaJetty = cluster.getReplicaJetty(replica);\n    ZkStateReaderAccessor accessor = new ZkStateReaderAccessor(replicaJetty.getCoreContainer().getZkController().getZkStateReader());\n    Set<CollectionStateWatcher> watchers = accessor.getStateWatchers(collectionName);\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n        ZkStateReader.CORE_NAME_PROP, replica.getCoreName(),\n        ZkStateReader.NODE_NAME_PROP, replica.getNodeName(),\n        ZkStateReader.COLLECTION_PROP, collectionName,\n        ZkStateReader.CORE_NODE_NAME_PROP, replica.getName(),\n        ZkStateReader.BASE_URL_PROP, replica.getBaseUrl());\n\n    cluster.getOpenOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n\n    waitForState(\"Timeout waiting for replica get deleted\", collectionName,\n        (liveNodes, collectionState) -> collectionState.getSlice(\"shard1\").getReplicas().size() == 2);\n\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Waiting for replica get unloaded\", () ->\n        replicaJetty.getCoreContainer().getCoreDescriptor(replica.getCoreName()) == null\n    );\n    // the core no longer watch collection state since it was removed\n    timeOut = new TimeOut(60, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Waiting for watcher get removed\", () ->\n        watchers.size() - 1 == accessor.getStateWatchers(collectionName).size()\n    );\n\n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0d38e0eaeb5a3c858d8d4892a6961883aabf161","date":1563030169,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteReplicaFromClusterState(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteReplicaFromClusterState(String).mjava","sourceNew":"  private void deleteReplicaFromClusterState(String legacyCloud) throws Exception {\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, legacyCloud).process(cluster.getSolrClient());\n    final String collectionName = \"deleteFromClusterState_\"+legacyCloud;\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 3)\n        .process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(collectionName, 1, 3);\n    \n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"1\"));\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\"));\n    cluster.getSolrClient().commit(collectionName);\n\n    cluster.waitForActiveCollection(collectionName, 1, 3);\n\n    Slice shard = getCollectionState(collectionName).getSlice(\"shard1\");\n\n    // don't choose the leader to shutdown, it just complicates things unneccessarily\n    Replica replica = getRandomReplica(shard, (r) ->\n                                       ( r.getState() == Replica.State.ACTIVE &&\n                                         ! r.equals(shard.getLeader())));\n    \n    JettySolrRunner replicaJetty = cluster.getReplicaJetty(replica);\n    ZkStateReaderAccessor accessor = new ZkStateReaderAccessor(replicaJetty.getCoreContainer().getZkController().getZkStateReader());\n\n    final long preDeleteWatcherCount = countUnloadCoreOnDeletedWatchers\n      (accessor.getStateWatchers(collectionName));\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n        ZkStateReader.CORE_NAME_PROP, replica.getCoreName(),\n        ZkStateReader.NODE_NAME_PROP, replica.getNodeName(),\n        ZkStateReader.COLLECTION_PROP, collectionName,\n        ZkStateReader.CORE_NODE_NAME_PROP, replica.getName(),\n        ZkStateReader.BASE_URL_PROP, replica.getBaseUrl());\n\n    cluster.getOpenOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n\n    waitForState(\"Timeout waiting for replica get deleted\", collectionName,\n        (liveNodes, collectionState) -> collectionState.getSlice(\"shard1\").getReplicas().size() == 2);\n\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Waiting for replica get unloaded\", () ->\n        replicaJetty.getCoreContainer().getCoreDescriptor(replica.getCoreName()) == null\n    );\n    \n    // the core should no longer have a watch collection state since it was removed\n    timeOut = new TimeOut(60, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Waiting for core's watcher to be removed\", () -> {\n        final long postDeleteWatcherCount = countUnloadCoreOnDeletedWatchers\n          (accessor.getStateWatchers(collectionName));\n        log.info(\"preDeleteWatcherCount={} vs postDeleteWatcherCount={}\",\n                 preDeleteWatcherCount, postDeleteWatcherCount);\n        return (preDeleteWatcherCount - 1L == postDeleteWatcherCount);\n      });\n    \n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","sourceOld":"  private void deleteReplicaFromClusterState(String legacyCloud) throws Exception {\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, legacyCloud).process(cluster.getSolrClient());\n    final String collectionName = \"deleteFromClusterState_\"+legacyCloud;\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 3)\n        .process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(collectionName, 1, 3);\n    \n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"1\"));\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\"));\n    cluster.getSolrClient().commit(collectionName);\n\n    Slice shard = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica replica = getRandomReplica(shard);\n    JettySolrRunner replicaJetty = cluster.getReplicaJetty(replica);\n    ZkStateReaderAccessor accessor = new ZkStateReaderAccessor(replicaJetty.getCoreContainer().getZkController().getZkStateReader());\n    Set<DocCollectionWatcher> watchers = accessor.getStateWatchers(collectionName);\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n        ZkStateReader.CORE_NAME_PROP, replica.getCoreName(),\n        ZkStateReader.NODE_NAME_PROP, replica.getNodeName(),\n        ZkStateReader.COLLECTION_PROP, collectionName,\n        ZkStateReader.CORE_NODE_NAME_PROP, replica.getName(),\n        ZkStateReader.BASE_URL_PROP, replica.getBaseUrl());\n\n    cluster.getOpenOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n\n    waitForState(\"Timeout waiting for replica get deleted\", collectionName,\n        (liveNodes, collectionState) -> collectionState.getSlice(\"shard1\").getReplicas().size() == 2);\n\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Waiting for replica get unloaded\", () ->\n        replicaJetty.getCoreContainer().getCoreDescriptor(replica.getCoreName()) == null\n    );\n    // the core no longer watch collection state since it was removed\n    timeOut = new TimeOut(60, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Waiting for watcher get removed\", () ->\n        watchers.size() - 1 == accessor.getStateWatchers(collectionName).size()\n    );\n\n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ad9c35f926b4bf8da0336d1300efc709c8d5a56","date":1591729157,"type":4,"author":"murblanc","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#deleteReplicaFromClusterState(String).mjava","sourceNew":null,"sourceOld":"  private void deleteReplicaFromClusterState(String legacyCloud) throws Exception {\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, legacyCloud).process(cluster.getSolrClient());\n    final String collectionName = \"deleteFromClusterState_\"+legacyCloud;\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 3)\n        .process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(collectionName, 1, 3);\n    \n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"1\"));\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\"));\n    cluster.getSolrClient().commit(collectionName);\n\n    cluster.waitForActiveCollection(collectionName, 1, 3);\n\n    Slice shard = getCollectionState(collectionName).getSlice(\"shard1\");\n\n    // don't choose the leader to shutdown, it just complicates things unneccessarily\n    Replica replica = getRandomReplica(shard, (r) ->\n                                       ( r.getState() == Replica.State.ACTIVE &&\n                                         ! r.equals(shard.getLeader())));\n    \n    JettySolrRunner replicaJetty = cluster.getReplicaJetty(replica);\n    ZkStateReaderAccessor accessor = new ZkStateReaderAccessor(replicaJetty.getCoreContainer().getZkController().getZkStateReader());\n\n    final long preDeleteWatcherCount = countUnloadCoreOnDeletedWatchers\n      (accessor.getStateWatchers(collectionName));\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n        ZkStateReader.CORE_NAME_PROP, replica.getCoreName(),\n        ZkStateReader.NODE_NAME_PROP, replica.getNodeName(),\n        ZkStateReader.COLLECTION_PROP, collectionName,\n        ZkStateReader.CORE_NODE_NAME_PROP, replica.getName(),\n        ZkStateReader.BASE_URL_PROP, replica.getBaseUrl());\n\n    cluster.getOpenOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n\n    waitForState(\"Timeout waiting for replica get deleted\", collectionName,\n        (liveNodes, collectionState) -> collectionState.getSlice(\"shard1\").getReplicas().size() == 2);\n\n    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Waiting for replica get unloaded\", () ->\n        replicaJetty.getCoreContainer().getCoreDescriptor(replica.getCoreName()) == null\n    );\n    \n    // the core should no longer have a watch collection state since it was removed\n    timeOut = new TimeOut(60, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Waiting for core's watcher to be removed\", () -> {\n        final long postDeleteWatcherCount = countUnloadCoreOnDeletedWatchers\n          (accessor.getStateWatchers(collectionName));\n        log.info(\"preDeleteWatcherCount={} vs postDeleteWatcherCount={}\",\n                 preDeleteWatcherCount, postDeleteWatcherCount);\n        return (preDeleteWatcherCount - 1L == postDeleteWatcherCount);\n      });\n    \n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["d0d38e0eaeb5a3c858d8d4892a6961883aabf161"],"d0d38e0eaeb5a3c858d8d4892a6961883aabf161":["7b366e7dd3172289251a86be96031af4002cd19c"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["28ba172425e443e0f08a49de6d73586c418d7251"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7b366e7dd3172289251a86be96031af4002cd19c":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"28ba172425e443e0f08a49de6d73586c418d7251":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"]},"commit2Childs":{"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d0d38e0eaeb5a3c858d8d4892a6961883aabf161":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["7b366e7dd3172289251a86be96031af4002cd19c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["28ba172425e443e0f08a49de6d73586c418d7251"],"7b366e7dd3172289251a86be96031af4002cd19c":["d0d38e0eaeb5a3c858d8d4892a6961883aabf161"],"28ba172425e443e0f08a49de6d73586c418d7251":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}