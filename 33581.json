{"path":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestUTF8TaxonomyWriterCache#testRandom().mjava","commits":[{"id":"2ae0982c0457fa3cfe0cda93a327c573fbe6f874","date":1507039114,"type":1,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestUTF8TaxonomyWriterCache#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCompactLabelToOrdinal#testL2O().mjava","sourceNew":"  public void testRandom() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    UTF8TaxonomyWriterCache cache = new UTF8TaxonomyWriterCache();\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    Set<String> uniqueValuesSet = new HashSet<>();\n    while (uniqueValuesSet.size() < numUniqueValues) {\n      int numParts = TestUtil.nextInt(random(), 1, 5);\n      StringBuilder b = new StringBuilder();\n      for (int i=0;i<numParts;i++) {\n          String part = null;\n          while (true) {\n            part = TestUtil.randomRealisticUnicodeString(random(), 16);\n            part = part.replace(\"/\", \"\");\n            if (part.length() > 0) {\n              break;\n            }\n          }\n\n          if (i > 0) {\n            b.append('/');\n          }\n          b.append(part);\n      }\n      uniqueValuesSet.add(b.toString());\n    }\n    String[] uniqueValues = uniqueValuesSet.toArray(new String[0]);\n\n    int ordUpto = 0;\n    for (int i = 0; i < n; i++) {\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = cache.get(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = ordUpto++;\n        map.addLabel(label, ord1);\n        cache.put(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = cache.get(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testL2O() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    CompactLabelToOrdinal compact = new CompactLabelToOrdinal(2000000, 0.15f, 3);\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    String[] uniqueValues = new String[numUniqueValues];\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    for (int i = 0; i < numUniqueValues;) {\n      random.nextBytes(buffer);\n      int size = 1 + random.nextInt(buffer.length);\n\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      uniqueValues[i] = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      // we cannot have empty path components, so eliminate all prefix as well\n      // as middle consecutive delimiter chars.\n      uniqueValues[i] = uniqueValues[i].replaceAll(\"/+\", \"/\");\n      if (uniqueValues[i].startsWith(\"/\")) {\n        uniqueValues[i] = uniqueValues[i].substring(1);\n      }\n      if (uniqueValues[i].indexOf(CompactLabelToOrdinal.TERMINATOR_CHAR) == -1) {\n        i++;\n      }\n    }\n\n    Path tmpDir = createTempDir(\"testLableToOrdinal\");\n    Path f = tmpDir.resolve(\"CompactLabelToOrdinalTest.tmp\");\n    int flushInterval = 10;\n\n    for (int i = 0; i < n; i++) {\n      if (i > 0 && i % flushInterval == 0) {\n        compact.flush(f);    \n        compact = CompactLabelToOrdinal.open(f, 0.15f, 3);\n        Files.delete(f);\n        if (flushInterval < (n / 10)) {\n          flushInterval *= 10;\n        }\n      }\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = compact.getNextOrdinal();\n        map.addLabel(label, ord1);\n        compact.addLabel(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"10b1c9af2d877ca8d718a359a4e5b285fe33b6f7","date":1509555533,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestUTF8TaxonomyWriterCache#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestUTF8TaxonomyWriterCache#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    UTF8TaxonomyWriterCache cache = new UTF8TaxonomyWriterCache();\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    Set<String> uniqueValuesSet = new HashSet<>();\n    while (uniqueValuesSet.size() < numUniqueValues) {\n      int numParts = TestUtil.nextInt(random(), 1, 5);\n      StringBuilder b = new StringBuilder();\n      for (int i=0;i<numParts;i++) {\n        String part = null;\n        while (true) {\n          part = TestUtil.randomRealisticUnicodeString(random(), 16);\n          part = part.replace(\"/\", \"\");\n          if (part.length() > 0) {\n            break;\n          }\n        }\n\n        if (i > 0) {\n          b.append('/');\n        }\n        b.append(part);\n      }\n      uniqueValuesSet.add(b.toString());\n    }\n    String[] uniqueValues = uniqueValuesSet.toArray(new String[0]);\n\n    int ordUpto = 0;\n    for (int i = 0; i < n; i++) {\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = cache.get(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = ordUpto++;\n        map.addLabel(label, ord1);\n        cache.put(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = cache.get(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    UTF8TaxonomyWriterCache cache = new UTF8TaxonomyWriterCache();\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    Set<String> uniqueValuesSet = new HashSet<>();\n    while (uniqueValuesSet.size() < numUniqueValues) {\n      int numParts = TestUtil.nextInt(random(), 1, 5);\n      StringBuilder b = new StringBuilder();\n      for (int i=0;i<numParts;i++) {\n          String part = null;\n          while (true) {\n            part = TestUtil.randomRealisticUnicodeString(random(), 16);\n            part = part.replace(\"/\", \"\");\n            if (part.length() > 0) {\n              break;\n            }\n          }\n\n          if (i > 0) {\n            b.append('/');\n          }\n          b.append(part);\n      }\n      uniqueValuesSet.add(b.toString());\n    }\n    String[] uniqueValues = uniqueValuesSet.toArray(new String[0]);\n\n    int ordUpto = 0;\n    for (int i = 0; i < n; i++) {\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = cache.get(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = ordUpto++;\n        map.addLabel(label, ord1);\n        cache.put(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = cache.get(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f65fd14fae96cef54e47a1dd64e0066022091316","date":1530687993,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestUTF8TaxonomyWriterCache#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestUTF8TaxonomyWriterCache#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    UTF8TaxonomyWriterCache cache = new UTF8TaxonomyWriterCache();\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    Random random = random();\n    Set<String> uniqueValuesSet = new HashSet<>();\n    while (uniqueValuesSet.size() < numUniqueValues) {\n      int numParts = TestUtil.nextInt(random(), 1, 5);\n      StringBuilder b = new StringBuilder();\n      for (int i=0;i<numParts;i++) {\n        String part = null;\n        while (true) {\n          part = TestUtil.randomRealisticUnicodeString(random(), 16);\n          part = part.replace(\"/\", \"\");\n          if (part.length() > 0) {\n            break;\n          }\n        }\n\n        if (i > 0) {\n          b.append('/');\n        }\n        b.append(part);\n      }\n      uniqueValuesSet.add(b.toString());\n    }\n    String[] uniqueValues = uniqueValuesSet.toArray(new String[0]);\n\n    int ordUpto = 0;\n    for (int i = 0; i < n; i++) {\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = cache.get(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = ordUpto++;\n        map.addLabel(label, ord1);\n        cache.put(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = cache.get(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    UTF8TaxonomyWriterCache cache = new UTF8TaxonomyWriterCache();\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    Set<String> uniqueValuesSet = new HashSet<>();\n    while (uniqueValuesSet.size() < numUniqueValues) {\n      int numParts = TestUtil.nextInt(random(), 1, 5);\n      StringBuilder b = new StringBuilder();\n      for (int i=0;i<numParts;i++) {\n        String part = null;\n        while (true) {\n          part = TestUtil.randomRealisticUnicodeString(random(), 16);\n          part = part.replace(\"/\", \"\");\n          if (part.length() > 0) {\n            break;\n          }\n        }\n\n        if (i > 0) {\n          b.append('/');\n        }\n        b.append(part);\n      }\n      uniqueValuesSet.add(b.toString());\n    }\n    String[] uniqueValues = uniqueValuesSet.toArray(new String[0]);\n\n    int ordUpto = 0;\n    for (int i = 0; i < n; i++) {\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = cache.get(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = ordUpto++;\n        map.addLabel(label, ord1);\n        cache.put(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = cache.get(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","bugFix":["2ae0982c0457fa3cfe0cda93a327c573fbe6f874"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestUTF8TaxonomyWriterCache#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestUTF8TaxonomyWriterCache#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    UTF8TaxonomyWriterCache cache = new UTF8TaxonomyWriterCache();\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    Random random = random();\n    Set<String> uniqueValuesSet = new HashSet<>();\n    while (uniqueValuesSet.size() < numUniqueValues) {\n      int numParts = TestUtil.nextInt(random(), 1, 5);\n      StringBuilder b = new StringBuilder();\n      for (int i=0;i<numParts;i++) {\n        String part = null;\n        while (true) {\n          part = TestUtil.randomRealisticUnicodeString(random(), 16);\n          part = part.replace(\"/\", \"\");\n          if (part.length() > 0) {\n            break;\n          }\n        }\n\n        if (i > 0) {\n          b.append('/');\n        }\n        b.append(part);\n      }\n      uniqueValuesSet.add(b.toString());\n    }\n    String[] uniqueValues = uniqueValuesSet.toArray(new String[0]);\n\n    int ordUpto = 0;\n    for (int i = 0; i < n; i++) {\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = cache.get(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = ordUpto++;\n        map.addLabel(label, ord1);\n        cache.put(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = cache.get(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    UTF8TaxonomyWriterCache cache = new UTF8TaxonomyWriterCache();\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    Set<String> uniqueValuesSet = new HashSet<>();\n    while (uniqueValuesSet.size() < numUniqueValues) {\n      int numParts = TestUtil.nextInt(random(), 1, 5);\n      StringBuilder b = new StringBuilder();\n      for (int i=0;i<numParts;i++) {\n        String part = null;\n        while (true) {\n          part = TestUtil.randomRealisticUnicodeString(random(), 16);\n          part = part.replace(\"/\", \"\");\n          if (part.length() > 0) {\n            break;\n          }\n        }\n\n        if (i > 0) {\n          b.append('/');\n        }\n        b.append(part);\n      }\n      uniqueValuesSet.add(b.toString());\n    }\n    String[] uniqueValues = uniqueValuesSet.toArray(new String[0]);\n\n    int ordUpto = 0;\n    for (int i = 0; i < n; i++) {\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = cache.get(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = ordUpto++;\n        map.addLabel(label, ord1);\n        cache.put(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = cache.get(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestUTF8TaxonomyWriterCache#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestUTF8TaxonomyWriterCache#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    UTF8TaxonomyWriterCache cache = new UTF8TaxonomyWriterCache();\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    Random random = random();\n    Set<String> uniqueValuesSet = new HashSet<>();\n    while (uniqueValuesSet.size() < numUniqueValues) {\n      int numParts = TestUtil.nextInt(random(), 1, 5);\n      StringBuilder b = new StringBuilder();\n      for (int i=0;i<numParts;i++) {\n        String part = null;\n        while (true) {\n          part = TestUtil.randomRealisticUnicodeString(random(), 16);\n          part = part.replace(\"/\", \"\");\n          if (part.length() > 0) {\n            break;\n          }\n        }\n\n        if (i > 0) {\n          b.append('/');\n        }\n        b.append(part);\n      }\n      uniqueValuesSet.add(b.toString());\n    }\n    String[] uniqueValues = uniqueValuesSet.toArray(new String[0]);\n\n    int ordUpto = 0;\n    for (int i = 0; i < n; i++) {\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = cache.get(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = ordUpto++;\n        map.addLabel(label, ord1);\n        cache.put(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = cache.get(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    UTF8TaxonomyWriterCache cache = new UTF8TaxonomyWriterCache();\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    Set<String> uniqueValuesSet = new HashSet<>();\n    while (uniqueValuesSet.size() < numUniqueValues) {\n      int numParts = TestUtil.nextInt(random(), 1, 5);\n      StringBuilder b = new StringBuilder();\n      for (int i=0;i<numParts;i++) {\n        String part = null;\n        while (true) {\n          part = TestUtil.randomRealisticUnicodeString(random(), 16);\n          part = part.replace(\"/\", \"\");\n          if (part.length() > 0) {\n            break;\n          }\n        }\n\n        if (i > 0) {\n          b.append('/');\n        }\n        b.append(part);\n      }\n      uniqueValuesSet.add(b.toString());\n    }\n    String[] uniqueValues = uniqueValuesSet.toArray(new String[0]);\n\n    int ordUpto = 0;\n    for (int i = 0; i < n; i++) {\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = cache.get(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = ordUpto++;\n        map.addLabel(label, ord1);\n        cache.put(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = cache.get(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2ae0982c0457fa3cfe0cda93a327c573fbe6f874":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["10b1c9af2d877ca8d718a359a4e5b285fe33b6f7","f65fd14fae96cef54e47a1dd64e0066022091316"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f65fd14fae96cef54e47a1dd64e0066022091316":["10b1c9af2d877ca8d718a359a4e5b285fe33b6f7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f65fd14fae96cef54e47a1dd64e0066022091316"],"10b1c9af2d877ca8d718a359a4e5b285fe33b6f7":["2ae0982c0457fa3cfe0cda93a327c573fbe6f874"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["10b1c9af2d877ca8d718a359a4e5b285fe33b6f7","f65fd14fae96cef54e47a1dd64e0066022091316"]},"commit2Childs":{"2ae0982c0457fa3cfe0cda93a327c573fbe6f874":["10b1c9af2d877ca8d718a359a4e5b285fe33b6f7"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2ae0982c0457fa3cfe0cda93a327c573fbe6f874"],"f65fd14fae96cef54e47a1dd64e0066022091316":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"10b1c9af2d877ca8d718a359a4e5b285fe33b6f7":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","f65fd14fae96cef54e47a1dd64e0066022091316","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}