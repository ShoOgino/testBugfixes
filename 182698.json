{"path":"lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.FieldReader.IntersectEnum.Frame#load(BytesRef).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.FieldReader.IntersectEnum.Frame#load(BytesRef).mjava","pathOld":"lucene/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.FieldReader.IntersectEnum.Frame#load(BytesRef).mjava","sourceNew":"        void load(BytesRef frameIndexData) throws IOException {\n\n          // if (DEBUG) System.out.println(\"    load fp=\" + fp + \" fpOrig=\" + fpOrig + \" frameIndexData=\" + frameIndexData + \" trans=\" + (transitions.length != 0 ? transitions[0] : \"n/a\" + \" state=\" + state));\n\n          if (frameIndexData != null && transitions.length != 0) {\n            // Floor frame\n            if (floorData.length < frameIndexData.length) {\n              this.floorData = new byte[ArrayUtil.oversize(frameIndexData.length, 1)];\n            }\n            System.arraycopy(frameIndexData.bytes, frameIndexData.offset, floorData, 0, frameIndexData.length);\n            floorDataReader.reset(floorData, 0, frameIndexData.length);\n            // Skip first long -- has redundant fp, hasTerms\n            // flag, isFloor flag\n            final long code = floorDataReader.readVLong();\n            if ((code & BlockTreeTermsWriter.OUTPUT_FLAG_IS_FLOOR) != 0) {\n              numFollowFloorBlocks = floorDataReader.readVInt();\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n              // if (DEBUG) System.out.println(\"    numFollowFloorBlocks=\" + numFollowFloorBlocks + \" nextFloorLabel=\" + nextFloorLabel);\n\n              // If current state is accept, we must process\n              // first block in case it has empty suffix:\n              if (!runAutomaton.isAccept(state)) {\n                // Maybe skip floor blocks:\n                while (numFollowFloorBlocks != 0 && nextFloorLabel <= transitions[0].getMin()) {\n                  fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n                  numFollowFloorBlocks--;\n                  // if (DEBUG) System.out.println(\"    skip floor block!  nextFloorLabel=\" + (char) nextFloorLabel + \" vs target=\" + (char) transitions[0].getMin() + \" newFP=\" + fp + \" numFollowFloorBlocks=\" + numFollowFloorBlocks);\n                  if (numFollowFloorBlocks != 0) {\n                    nextFloorLabel = floorDataReader.readByte() & 0xff;\n                  } else {\n                    nextFloorLabel = 256;\n                  }\n                }\n              }\n            }\n          }\n\n          in.seek(fp);\n          int code = in.readVInt();\n          entCount = code >>> 1;\n          assert entCount > 0;\n          isLastInFloor = (code & 1) != 0;\n\n          // term suffixes:\n          code = in.readVInt();\n          isLeafBlock = (code & 1) != 0;\n          int numBytes = code >>> 1;\n          // if (DEBUG) System.out.println(\"      entCount=\" + entCount + \" lastInFloor?=\" + isLastInFloor + \" leafBlock?=\" + isLeafBlock + \" numSuffixBytes=\" + numBytes);\n          if (suffixBytes.length < numBytes) {\n            suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n          }\n          in.readBytes(suffixBytes, 0, numBytes);\n          suffixesReader.reset(suffixBytes, 0, numBytes);\n\n          // stats\n          numBytes = in.readVInt();\n          if (statBytes.length < numBytes) {\n            statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n          }\n          in.readBytes(statBytes, 0, numBytes);\n          statsReader.reset(statBytes, 0, numBytes);\n          metaDataUpto = 0;\n\n          termState.termBlockOrd = 0;\n          nextEnt = 0;\n          \n          postingsReader.readTermsBlock(in, fieldInfo, termState);\n\n          if (!isLastInFloor) {\n            // Sub-blocks of a single floor block are always\n            // written one after another -- tail recurse:\n            fpEnd = in.getFilePointer();\n          }\n        }\n\n","sourceOld":"        void load(BytesRef frameIndexData) throws IOException {\n\n          // if (DEBUG) System.out.println(\"    load fp=\" + fp + \" fpOrig=\" + fpOrig + \" frameIndexData=\" + frameIndexData + \" trans=\" + (transitions.length != 0 ? transitions[0] : \"n/a\" + \" state=\" + state));\n\n          if (frameIndexData != null && transitions.length != 0) {\n            // Floor frame\n            if (floorData.length < frameIndexData.length) {\n              this.floorData = new byte[ArrayUtil.oversize(frameIndexData.length, 1)];\n            }\n            System.arraycopy(frameIndexData.bytes, frameIndexData.offset, floorData, 0, frameIndexData.length);\n            floorDataReader.reset(floorData, 0, frameIndexData.length);\n            // Skip first long -- has redundant fp, hasTerms\n            // flag, isFloor flag\n            final long code = floorDataReader.readVLong();\n            if ((code & BlockTreeTermsWriter.OUTPUT_FLAG_IS_FLOOR) != 0) {\n              numFollowFloorBlocks = floorDataReader.readVInt();\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n              // if (DEBUG) System.out.println(\"    numFollowFloorBlocks=\" + numFollowFloorBlocks + \" nextFloorLabel=\" + nextFloorLabel);\n\n              // If current state is accept, we must process\n              // first block in case it has empty suffix:\n              if (!runAutomaton.isAccept(state)) {\n                // Maybe skip floor blocks:\n                while (numFollowFloorBlocks != 0 && nextFloorLabel <= transitions[0].getMin()) {\n                  fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n                  numFollowFloorBlocks--;\n                  // if (DEBUG) System.out.println(\"    skip floor block!  nextFloorLabel=\" + (char) nextFloorLabel + \" vs target=\" + (char) transitions[0].getMin() + \" newFP=\" + fp + \" numFollowFloorBlocks=\" + numFollowFloorBlocks);\n                  if (numFollowFloorBlocks != 0) {\n                    nextFloorLabel = floorDataReader.readByte() & 0xff;\n                  } else {\n                    nextFloorLabel = 256;\n                  }\n                }\n              }\n            }\n          }\n\n          in.seek(fp);\n          int code = in.readVInt();\n          entCount = code >>> 1;\n          assert entCount > 0;\n          isLastInFloor = (code & 1) != 0;\n\n          // term suffixes:\n          code = in.readVInt();\n          isLeafBlock = (code & 1) != 0;\n          int numBytes = code >>> 1;\n          // if (DEBUG) System.out.println(\"      entCount=\" + entCount + \" lastInFloor?=\" + isLastInFloor + \" leafBlock?=\" + isLeafBlock + \" numSuffixBytes=\" + numBytes);\n          if (suffixBytes.length < numBytes) {\n            suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n          }\n          in.readBytes(suffixBytes, 0, numBytes);\n          suffixesReader.reset(suffixBytes, 0, numBytes);\n\n          // stats\n          numBytes = in.readVInt();\n          if (statBytes.length < numBytes) {\n            statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n          }\n          in.readBytes(statBytes, 0, numBytes);\n          statsReader.reset(statBytes, 0, numBytes);\n          metaDataUpto = 0;\n\n          termState.termBlockOrd = 0;\n          nextEnt = 0;\n          \n          postingsReader.readTermsBlock(in, fieldInfo, termState);\n\n          if (!isLastInFloor) {\n            // Sub-blocks of a single floor block are always\n            // written one after another -- tail recurse:\n            fpEnd = in.getFilePointer();\n          }\n        }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1a88d7b0899b7d22dcbd4cf8ca35d9ec9850ab98","date":1377268487,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.FieldReader.IntersectEnum.Frame#load(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.FieldReader.IntersectEnum.Frame#load(BytesRef).mjava","sourceNew":"        void load(BytesRef frameIndexData) throws IOException {\n\n          // if (DEBUG) System.out.println(\"    load fp=\" + fp + \" fpOrig=\" + fpOrig + \" frameIndexData=\" + frameIndexData + \" trans=\" + (transitions.length != 0 ? transitions[0] : \"n/a\" + \" state=\" + state));\n\n          if (frameIndexData != null && transitions.length != 0) {\n            // Floor frame\n            if (floorData.length < frameIndexData.length) {\n              this.floorData = new byte[ArrayUtil.oversize(frameIndexData.length, 1)];\n            }\n            System.arraycopy(frameIndexData.bytes, frameIndexData.offset, floorData, 0, frameIndexData.length);\n            floorDataReader.reset(floorData, 0, frameIndexData.length);\n            // Skip first long -- has redundant fp, hasTerms\n            // flag, isFloor flag\n            final long code = floorDataReader.readVLong();\n            if ((code & BlockTreeTermsWriter.OUTPUT_FLAG_IS_FLOOR) != 0) {\n              numFollowFloorBlocks = floorDataReader.readVInt();\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n              // if (DEBUG) System.out.println(\"    numFollowFloorBlocks=\" + numFollowFloorBlocks + \" nextFloorLabel=\" + nextFloorLabel);\n\n              // If current state is accept, we must process\n              // first block in case it has empty suffix:\n              if (!runAutomaton.isAccept(state)) {\n                // Maybe skip floor blocks:\n                while (numFollowFloorBlocks != 0 && nextFloorLabel <= transitions[0].getMin()) {\n                  fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n                  numFollowFloorBlocks--;\n                  // if (DEBUG) System.out.println(\"    skip floor block!  nextFloorLabel=\" + (char) nextFloorLabel + \" vs target=\" + (char) transitions[0].getMin() + \" newFP=\" + fp + \" numFollowFloorBlocks=\" + numFollowFloorBlocks);\n                  if (numFollowFloorBlocks != 0) {\n                    nextFloorLabel = floorDataReader.readByte() & 0xff;\n                  } else {\n                    nextFloorLabel = 256;\n                  }\n                }\n              }\n            }\n          }\n\n          in.seek(fp);\n          int code = in.readVInt();\n          entCount = code >>> 1;\n          assert entCount > 0;\n          isLastInFloor = (code & 1) != 0;\n\n          // term suffixes:\n          code = in.readVInt();\n          isLeafBlock = (code & 1) != 0;\n          int numBytes = code >>> 1;\n          // if (DEBUG) System.out.println(\"      entCount=\" + entCount + \" lastInFloor?=\" + isLastInFloor + \" leafBlock?=\" + isLeafBlock + \" numSuffixBytes=\" + numBytes);\n          if (suffixBytes.length < numBytes) {\n            suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n          }\n          in.readBytes(suffixBytes, 0, numBytes);\n          suffixesReader.reset(suffixBytes, 0, numBytes);\n\n          // stats\n          numBytes = in.readVInt();\n          if (statBytes.length < numBytes) {\n            statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n          }\n          in.readBytes(statBytes, 0, numBytes);\n          statsReader.reset(statBytes, 0, numBytes);\n          metaDataUpto = 0;\n\n          termState.termBlockOrd = 0;\n          nextEnt = 0;\n         \n          // metadata\n          numBytes = in.readVInt();\n          if (bytes == null) {\n            bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n            bytesReader = new ByteArrayDataInput();\n          } else if (bytes.length < numBytes) {\n            bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n          }\n          in.readBytes(bytes, 0, numBytes);\n          bytesReader.reset(bytes, 0, numBytes);\n\n          if (!isLastInFloor) {\n            // Sub-blocks of a single floor block are always\n            // written one after another -- tail recurse:\n            fpEnd = in.getFilePointer();\n          }\n        }\n\n","sourceOld":"        void load(BytesRef frameIndexData) throws IOException {\n\n          // if (DEBUG) System.out.println(\"    load fp=\" + fp + \" fpOrig=\" + fpOrig + \" frameIndexData=\" + frameIndexData + \" trans=\" + (transitions.length != 0 ? transitions[0] : \"n/a\" + \" state=\" + state));\n\n          if (frameIndexData != null && transitions.length != 0) {\n            // Floor frame\n            if (floorData.length < frameIndexData.length) {\n              this.floorData = new byte[ArrayUtil.oversize(frameIndexData.length, 1)];\n            }\n            System.arraycopy(frameIndexData.bytes, frameIndexData.offset, floorData, 0, frameIndexData.length);\n            floorDataReader.reset(floorData, 0, frameIndexData.length);\n            // Skip first long -- has redundant fp, hasTerms\n            // flag, isFloor flag\n            final long code = floorDataReader.readVLong();\n            if ((code & BlockTreeTermsWriter.OUTPUT_FLAG_IS_FLOOR) != 0) {\n              numFollowFloorBlocks = floorDataReader.readVInt();\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n              // if (DEBUG) System.out.println(\"    numFollowFloorBlocks=\" + numFollowFloorBlocks + \" nextFloorLabel=\" + nextFloorLabel);\n\n              // If current state is accept, we must process\n              // first block in case it has empty suffix:\n              if (!runAutomaton.isAccept(state)) {\n                // Maybe skip floor blocks:\n                while (numFollowFloorBlocks != 0 && nextFloorLabel <= transitions[0].getMin()) {\n                  fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n                  numFollowFloorBlocks--;\n                  // if (DEBUG) System.out.println(\"    skip floor block!  nextFloorLabel=\" + (char) nextFloorLabel + \" vs target=\" + (char) transitions[0].getMin() + \" newFP=\" + fp + \" numFollowFloorBlocks=\" + numFollowFloorBlocks);\n                  if (numFollowFloorBlocks != 0) {\n                    nextFloorLabel = floorDataReader.readByte() & 0xff;\n                  } else {\n                    nextFloorLabel = 256;\n                  }\n                }\n              }\n            }\n          }\n\n          in.seek(fp);\n          int code = in.readVInt();\n          entCount = code >>> 1;\n          assert entCount > 0;\n          isLastInFloor = (code & 1) != 0;\n\n          // term suffixes:\n          code = in.readVInt();\n          isLeafBlock = (code & 1) != 0;\n          int numBytes = code >>> 1;\n          // if (DEBUG) System.out.println(\"      entCount=\" + entCount + \" lastInFloor?=\" + isLastInFloor + \" leafBlock?=\" + isLeafBlock + \" numSuffixBytes=\" + numBytes);\n          if (suffixBytes.length < numBytes) {\n            suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n          }\n          in.readBytes(suffixBytes, 0, numBytes);\n          suffixesReader.reset(suffixBytes, 0, numBytes);\n\n          // stats\n          numBytes = in.readVInt();\n          if (statBytes.length < numBytes) {\n            statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n          }\n          in.readBytes(statBytes, 0, numBytes);\n          statsReader.reset(statBytes, 0, numBytes);\n          metaDataUpto = 0;\n\n          termState.termBlockOrd = 0;\n          nextEnt = 0;\n          \n          postingsReader.readTermsBlock(in, fieldInfo, termState);\n\n          if (!isLastInFloor) {\n            // Sub-blocks of a single floor block are always\n            // written one after another -- tail recurse:\n            fpEnd = in.getFilePointer();\n          }\n        }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2f948dd442d23baa6cbb28daf77c8db78b351329","date":1378742876,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.FieldReader.IntersectEnum.Frame#load(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.FieldReader.IntersectEnum.Frame#load(BytesRef).mjava","sourceNew":"        void load(BytesRef frameIndexData) throws IOException {\n\n          // if (DEBUG) System.out.println(\"    load fp=\" + fp + \" fpOrig=\" + fpOrig + \" frameIndexData=\" + frameIndexData + \" trans=\" + (transitions.length != 0 ? transitions[0] : \"n/a\" + \" state=\" + state));\n\n          if (frameIndexData != null && transitions.length != 0) {\n            // Floor frame\n            if (floorData.length < frameIndexData.length) {\n              this.floorData = new byte[ArrayUtil.oversize(frameIndexData.length, 1)];\n            }\n            System.arraycopy(frameIndexData.bytes, frameIndexData.offset, floorData, 0, frameIndexData.length);\n            floorDataReader.reset(floorData, 0, frameIndexData.length);\n            // Skip first long -- has redundant fp, hasTerms\n            // flag, isFloor flag\n            final long code = floorDataReader.readVLong();\n            if ((code & BlockTreeTermsWriter.OUTPUT_FLAG_IS_FLOOR) != 0) {\n              numFollowFloorBlocks = floorDataReader.readVInt();\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n              // if (DEBUG) System.out.println(\"    numFollowFloorBlocks=\" + numFollowFloorBlocks + \" nextFloorLabel=\" + nextFloorLabel);\n\n              // If current state is accept, we must process\n              // first block in case it has empty suffix:\n              if (!runAutomaton.isAccept(state)) {\n                // Maybe skip floor blocks:\n                while (numFollowFloorBlocks != 0 && nextFloorLabel <= transitions[0].getMin()) {\n                  fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n                  numFollowFloorBlocks--;\n                  // if (DEBUG) System.out.println(\"    skip floor block!  nextFloorLabel=\" + (char) nextFloorLabel + \" vs target=\" + (char) transitions[0].getMin() + \" newFP=\" + fp + \" numFollowFloorBlocks=\" + numFollowFloorBlocks);\n                  if (numFollowFloorBlocks != 0) {\n                    nextFloorLabel = floorDataReader.readByte() & 0xff;\n                  } else {\n                    nextFloorLabel = 256;\n                  }\n                }\n              }\n            }\n          }\n\n          in.seek(fp);\n          int code = in.readVInt();\n          entCount = code >>> 1;\n          assert entCount > 0;\n          isLastInFloor = (code & 1) != 0;\n\n          // term suffixes:\n          code = in.readVInt();\n          isLeafBlock = (code & 1) != 0;\n          int numBytes = code >>> 1;\n          // if (DEBUG) System.out.println(\"      entCount=\" + entCount + \" lastInFloor?=\" + isLastInFloor + \" leafBlock?=\" + isLeafBlock + \" numSuffixBytes=\" + numBytes);\n          if (suffixBytes.length < numBytes) {\n            suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n          }\n          in.readBytes(suffixBytes, 0, numBytes);\n          suffixesReader.reset(suffixBytes, 0, numBytes);\n\n          // stats\n          numBytes = in.readVInt();\n          if (statBytes.length < numBytes) {\n            statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n          }\n          in.readBytes(statBytes, 0, numBytes);\n          statsReader.reset(statBytes, 0, numBytes);\n          metaDataUpto = 0;\n\n          termState.termBlockOrd = 0;\n          nextEnt = 0;\n         \n          // metadata\n          numBytes = in.readVInt();\n          if (bytes == null) {\n            bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n            bytesReader = new ByteArrayDataInput();\n          } else if (bytes.length < numBytes) {\n            bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n          }\n          in.readBytes(bytes, 0, numBytes);\n          bytesReader.reset(bytes, 0, numBytes);\n\n          if (!isLastInFloor) {\n            // Sub-blocks of a single floor block are always\n            // written one after another -- tail recurse:\n            fpEnd = in.getFilePointer();\n          }\n        }\n\n","sourceOld":"        void load(BytesRef frameIndexData) throws IOException {\n\n          // if (DEBUG) System.out.println(\"    load fp=\" + fp + \" fpOrig=\" + fpOrig + \" frameIndexData=\" + frameIndexData + \" trans=\" + (transitions.length != 0 ? transitions[0] : \"n/a\" + \" state=\" + state));\n\n          if (frameIndexData != null && transitions.length != 0) {\n            // Floor frame\n            if (floorData.length < frameIndexData.length) {\n              this.floorData = new byte[ArrayUtil.oversize(frameIndexData.length, 1)];\n            }\n            System.arraycopy(frameIndexData.bytes, frameIndexData.offset, floorData, 0, frameIndexData.length);\n            floorDataReader.reset(floorData, 0, frameIndexData.length);\n            // Skip first long -- has redundant fp, hasTerms\n            // flag, isFloor flag\n            final long code = floorDataReader.readVLong();\n            if ((code & BlockTreeTermsWriter.OUTPUT_FLAG_IS_FLOOR) != 0) {\n              numFollowFloorBlocks = floorDataReader.readVInt();\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n              // if (DEBUG) System.out.println(\"    numFollowFloorBlocks=\" + numFollowFloorBlocks + \" nextFloorLabel=\" + nextFloorLabel);\n\n              // If current state is accept, we must process\n              // first block in case it has empty suffix:\n              if (!runAutomaton.isAccept(state)) {\n                // Maybe skip floor blocks:\n                while (numFollowFloorBlocks != 0 && nextFloorLabel <= transitions[0].getMin()) {\n                  fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n                  numFollowFloorBlocks--;\n                  // if (DEBUG) System.out.println(\"    skip floor block!  nextFloorLabel=\" + (char) nextFloorLabel + \" vs target=\" + (char) transitions[0].getMin() + \" newFP=\" + fp + \" numFollowFloorBlocks=\" + numFollowFloorBlocks);\n                  if (numFollowFloorBlocks != 0) {\n                    nextFloorLabel = floorDataReader.readByte() & 0xff;\n                  } else {\n                    nextFloorLabel = 256;\n                  }\n                }\n              }\n            }\n          }\n\n          in.seek(fp);\n          int code = in.readVInt();\n          entCount = code >>> 1;\n          assert entCount > 0;\n          isLastInFloor = (code & 1) != 0;\n\n          // term suffixes:\n          code = in.readVInt();\n          isLeafBlock = (code & 1) != 0;\n          int numBytes = code >>> 1;\n          // if (DEBUG) System.out.println(\"      entCount=\" + entCount + \" lastInFloor?=\" + isLastInFloor + \" leafBlock?=\" + isLeafBlock + \" numSuffixBytes=\" + numBytes);\n          if (suffixBytes.length < numBytes) {\n            suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n          }\n          in.readBytes(suffixBytes, 0, numBytes);\n          suffixesReader.reset(suffixBytes, 0, numBytes);\n\n          // stats\n          numBytes = in.readVInt();\n          if (statBytes.length < numBytes) {\n            statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n          }\n          in.readBytes(statBytes, 0, numBytes);\n          statsReader.reset(statBytes, 0, numBytes);\n          metaDataUpto = 0;\n\n          termState.termBlockOrd = 0;\n          nextEnt = 0;\n          \n          postingsReader.readTermsBlock(in, fieldInfo, termState);\n\n          if (!isLastInFloor) {\n            // Sub-blocks of a single floor block are always\n            // written one after another -- tail recurse:\n            fpEnd = in.getFilePointer();\n          }\n        }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ad80176d91a6f70fe93880e43dfd697dc4e63ed","date":1400176913,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsReader.FieldReader.IntersectEnum.Frame#load(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.FieldReader.IntersectEnum.Frame#load(BytesRef).mjava","sourceNew":"        void load(BytesRef frameIndexData) throws IOException {\n\n          // if (DEBUG) System.out.println(\"    load fp=\" + fp + \" fpOrig=\" + fpOrig + \" frameIndexData=\" + frameIndexData + \" trans=\" + (transitions.length != 0 ? transitions[0] : \"n/a\" + \" state=\" + state));\n\n          if (frameIndexData != null && transitions.length != 0) {\n            // Floor frame\n            if (floorData.length < frameIndexData.length) {\n              this.floorData = new byte[ArrayUtil.oversize(frameIndexData.length, 1)];\n            }\n            System.arraycopy(frameIndexData.bytes, frameIndexData.offset, floorData, 0, frameIndexData.length);\n            floorDataReader.reset(floorData, 0, frameIndexData.length);\n            // Skip first long -- has redundant fp, hasTerms\n            // flag, isFloor flag\n            final long code = floorDataReader.readVLong();\n            if ((code & BlockTreeTermsWriter.OUTPUT_FLAG_IS_FLOOR) != 0) {\n              numFollowFloorBlocks = floorDataReader.readVInt();\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n              // if (DEBUG) System.out.println(\"    numFollowFloorBlocks=\" + numFollowFloorBlocks + \" nextFloorLabel=\" + nextFloorLabel);\n\n              // If current state is accept, we must process\n              // first block in case it has empty suffix:\n              if (!runAutomaton.isAccept(state)) {\n                // Maybe skip floor blocks:\n                while (numFollowFloorBlocks != 0 && nextFloorLabel <= transitions[0].getMin()) {\n                  fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n                  numFollowFloorBlocks--;\n                  // if (DEBUG) System.out.println(\"    skip floor block!  nextFloorLabel=\" + (char) nextFloorLabel + \" vs target=\" + (char) transitions[0].getMin() + \" newFP=\" + fp + \" numFollowFloorBlocks=\" + numFollowFloorBlocks);\n                  if (numFollowFloorBlocks != 0) {\n                    nextFloorLabel = floorDataReader.readByte() & 0xff;\n                  } else {\n                    nextFloorLabel = 256;\n                  }\n                }\n              }\n            }\n          }\n\n          in.seek(fp);\n          int code = in.readVInt();\n          entCount = code >>> 1;\n          assert entCount > 0;\n          isLastInFloor = (code & 1) != 0;\n\n          // term suffixes:\n          code = in.readVInt();\n          isLeafBlock = (code & 1) != 0;\n          int numBytes = code >>> 1;\n          // if (DEBUG) System.out.println(\"      entCount=\" + entCount + \" lastInFloor?=\" + isLastInFloor + \" leafBlock?=\" + isLeafBlock + \" numSuffixBytes=\" + numBytes);\n          if (suffixBytes.length < numBytes) {\n            suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n          }\n          in.readBytes(suffixBytes, 0, numBytes);\n          suffixesReader.reset(suffixBytes, 0, numBytes);\n\n          // stats\n          numBytes = in.readVInt();\n          if (statBytes.length < numBytes) {\n            statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n          }\n          in.readBytes(statBytes, 0, numBytes);\n          statsReader.reset(statBytes, 0, numBytes);\n          metaDataUpto = 0;\n\n          termState.termBlockOrd = 0;\n          nextEnt = 0;\n         \n          // metadata\n          numBytes = in.readVInt();\n          if (bytes == null) {\n            bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n            bytesReader = new ByteArrayDataInput();\n          } else if (bytes.length < numBytes) {\n            bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n          }\n          in.readBytes(bytes, 0, numBytes);\n          bytesReader.reset(bytes, 0, numBytes);\n\n          if (!isLastInFloor) {\n            // Sub-blocks of a single floor block are always\n            // written one after another -- tail recurse:\n            fpEnd = in.getFilePointer();\n          }\n        }\n\n","sourceOld":"        void load(BytesRef frameIndexData) throws IOException {\n\n          // if (DEBUG) System.out.println(\"    load fp=\" + fp + \" fpOrig=\" + fpOrig + \" frameIndexData=\" + frameIndexData + \" trans=\" + (transitions.length != 0 ? transitions[0] : \"n/a\" + \" state=\" + state));\n\n          if (frameIndexData != null && transitions.length != 0) {\n            // Floor frame\n            if (floorData.length < frameIndexData.length) {\n              this.floorData = new byte[ArrayUtil.oversize(frameIndexData.length, 1)];\n            }\n            System.arraycopy(frameIndexData.bytes, frameIndexData.offset, floorData, 0, frameIndexData.length);\n            floorDataReader.reset(floorData, 0, frameIndexData.length);\n            // Skip first long -- has redundant fp, hasTerms\n            // flag, isFloor flag\n            final long code = floorDataReader.readVLong();\n            if ((code & BlockTreeTermsWriter.OUTPUT_FLAG_IS_FLOOR) != 0) {\n              numFollowFloorBlocks = floorDataReader.readVInt();\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n              // if (DEBUG) System.out.println(\"    numFollowFloorBlocks=\" + numFollowFloorBlocks + \" nextFloorLabel=\" + nextFloorLabel);\n\n              // If current state is accept, we must process\n              // first block in case it has empty suffix:\n              if (!runAutomaton.isAccept(state)) {\n                // Maybe skip floor blocks:\n                while (numFollowFloorBlocks != 0 && nextFloorLabel <= transitions[0].getMin()) {\n                  fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n                  numFollowFloorBlocks--;\n                  // if (DEBUG) System.out.println(\"    skip floor block!  nextFloorLabel=\" + (char) nextFloorLabel + \" vs target=\" + (char) transitions[0].getMin() + \" newFP=\" + fp + \" numFollowFloorBlocks=\" + numFollowFloorBlocks);\n                  if (numFollowFloorBlocks != 0) {\n                    nextFloorLabel = floorDataReader.readByte() & 0xff;\n                  } else {\n                    nextFloorLabel = 256;\n                  }\n                }\n              }\n            }\n          }\n\n          in.seek(fp);\n          int code = in.readVInt();\n          entCount = code >>> 1;\n          assert entCount > 0;\n          isLastInFloor = (code & 1) != 0;\n\n          // term suffixes:\n          code = in.readVInt();\n          isLeafBlock = (code & 1) != 0;\n          int numBytes = code >>> 1;\n          // if (DEBUG) System.out.println(\"      entCount=\" + entCount + \" lastInFloor?=\" + isLastInFloor + \" leafBlock?=\" + isLeafBlock + \" numSuffixBytes=\" + numBytes);\n          if (suffixBytes.length < numBytes) {\n            suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n          }\n          in.readBytes(suffixBytes, 0, numBytes);\n          suffixesReader.reset(suffixBytes, 0, numBytes);\n\n          // stats\n          numBytes = in.readVInt();\n          if (statBytes.length < numBytes) {\n            statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n          }\n          in.readBytes(statBytes, 0, numBytes);\n          statsReader.reset(statBytes, 0, numBytes);\n          metaDataUpto = 0;\n\n          termState.termBlockOrd = 0;\n          nextEnt = 0;\n         \n          // metadata\n          numBytes = in.readVInt();\n          if (bytes == null) {\n            bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n            bytesReader = new ByteArrayDataInput();\n          } else if (bytes.length < numBytes) {\n            bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n          }\n          in.readBytes(bytes, 0, numBytes);\n          bytesReader.reset(bytes, 0, numBytes);\n\n          if (!isLastInFloor) {\n            // Sub-blocks of a single floor block are always\n            // written one after another -- tail recurse:\n            fpEnd = in.getFilePointer();\n          }\n        }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d637064d608752565d4f9f41b2497dfdfdde50e","date":1400798123,"type":4,"author":"Michael McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.FieldReader.IntersectEnum.Frame#load(BytesRef).mjava","sourceNew":null,"sourceOld":"        void load(BytesRef frameIndexData) throws IOException {\n\n          // if (DEBUG) System.out.println(\"    load fp=\" + fp + \" fpOrig=\" + fpOrig + \" frameIndexData=\" + frameIndexData + \" trans=\" + (transitions.length != 0 ? transitions[0] : \"n/a\" + \" state=\" + state));\n\n          if (frameIndexData != null && transitions.length != 0) {\n            // Floor frame\n            if (floorData.length < frameIndexData.length) {\n              this.floorData = new byte[ArrayUtil.oversize(frameIndexData.length, 1)];\n            }\n            System.arraycopy(frameIndexData.bytes, frameIndexData.offset, floorData, 0, frameIndexData.length);\n            floorDataReader.reset(floorData, 0, frameIndexData.length);\n            // Skip first long -- has redundant fp, hasTerms\n            // flag, isFloor flag\n            final long code = floorDataReader.readVLong();\n            if ((code & BlockTreeTermsWriter.OUTPUT_FLAG_IS_FLOOR) != 0) {\n              numFollowFloorBlocks = floorDataReader.readVInt();\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n              // if (DEBUG) System.out.println(\"    numFollowFloorBlocks=\" + numFollowFloorBlocks + \" nextFloorLabel=\" + nextFloorLabel);\n\n              // If current state is accept, we must process\n              // first block in case it has empty suffix:\n              if (!runAutomaton.isAccept(state)) {\n                // Maybe skip floor blocks:\n                while (numFollowFloorBlocks != 0 && nextFloorLabel <= transitions[0].getMin()) {\n                  fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n                  numFollowFloorBlocks--;\n                  // if (DEBUG) System.out.println(\"    skip floor block!  nextFloorLabel=\" + (char) nextFloorLabel + \" vs target=\" + (char) transitions[0].getMin() + \" newFP=\" + fp + \" numFollowFloorBlocks=\" + numFollowFloorBlocks);\n                  if (numFollowFloorBlocks != 0) {\n                    nextFloorLabel = floorDataReader.readByte() & 0xff;\n                  } else {\n                    nextFloorLabel = 256;\n                  }\n                }\n              }\n            }\n          }\n\n          in.seek(fp);\n          int code = in.readVInt();\n          entCount = code >>> 1;\n          assert entCount > 0;\n          isLastInFloor = (code & 1) != 0;\n\n          // term suffixes:\n          code = in.readVInt();\n          isLeafBlock = (code & 1) != 0;\n          int numBytes = code >>> 1;\n          // if (DEBUG) System.out.println(\"      entCount=\" + entCount + \" lastInFloor?=\" + isLastInFloor + \" leafBlock?=\" + isLeafBlock + \" numSuffixBytes=\" + numBytes);\n          if (suffixBytes.length < numBytes) {\n            suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n          }\n          in.readBytes(suffixBytes, 0, numBytes);\n          suffixesReader.reset(suffixBytes, 0, numBytes);\n\n          // stats\n          numBytes = in.readVInt();\n          if (statBytes.length < numBytes) {\n            statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n          }\n          in.readBytes(statBytes, 0, numBytes);\n          statsReader.reset(statBytes, 0, numBytes);\n          metaDataUpto = 0;\n\n          termState.termBlockOrd = 0;\n          nextEnt = 0;\n         \n          // metadata\n          numBytes = in.readVInt();\n          if (bytes == null) {\n            bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n            bytesReader = new ByteArrayDataInput();\n          } else if (bytes.length < numBytes) {\n            bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n          }\n          in.readBytes(bytes, 0, numBytes);\n          bytesReader.reset(bytes, 0, numBytes);\n\n          if (!isLastInFloor) {\n            // Sub-blocks of a single floor block are always\n            // written one after another -- tail recurse:\n            fpEnd = in.getFilePointer();\n          }\n        }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1a88d7b0899b7d22dcbd4cf8ca35d9ec9850ab98":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"4d637064d608752565d4f9f41b2497dfdfdde50e":["2f948dd442d23baa6cbb28daf77c8db78b351329","5ad80176d91a6f70fe93880e43dfd697dc4e63ed"],"5ad80176d91a6f70fe93880e43dfd697dc4e63ed":["2f948dd442d23baa6cbb28daf77c8db78b351329"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2f948dd442d23baa6cbb28daf77c8db78b351329":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","1a88d7b0899b7d22dcbd4cf8ca35d9ec9850ab98"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4d637064d608752565d4f9f41b2497dfdfdde50e"]},"commit2Childs":{"1a88d7b0899b7d22dcbd4cf8ca35d9ec9850ab98":["2f948dd442d23baa6cbb28daf77c8db78b351329"],"4d637064d608752565d4f9f41b2497dfdfdde50e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5ad80176d91a6f70fe93880e43dfd697dc4e63ed":["4d637064d608752565d4f9f41b2497dfdfdde50e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["1a88d7b0899b7d22dcbd4cf8ca35d9ec9850ab98","2f948dd442d23baa6cbb28daf77c8db78b351329"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"2f948dd442d23baa6cbb28daf77c8db78b351329":["4d637064d608752565d4f9f41b2497dfdfdde50e","5ad80176d91a6f70fe93880e43dfd697dc4e63ed"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}