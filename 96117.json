{"path":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestSolrEntityProcessorUnit#testMultiThread().mjava","commits":[{"id":"cea5f7a2e31566bda38c740c37affa52b0e9c46e","date":1323436632,"type":0,"author":"Martijn van Groningen","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestSolrEntityProcessorUnit#testMultiThread().mjava","pathOld":"/dev/null","sourceNew":"  public void testMultiThread() {\n    int numThreads = 5;\n    int numDocs = 40;\n    String[][][] docs = generateDocs(numDocs);\n    final MockSolrEntityProcessor entityProcessor = new MockSolrEntityProcessor(docs, 25);\n    \n    final Map<String,Map<String,Object>> rowList = new HashMap<String,Map<String,Object>>();\n    final CountDownLatch latch = new CountDownLatch(numThreads);\n    for (int i = 0; i < numThreads; i++) {\n      Runnable runnable = new Runnable() {\n        public void run() {\n          try {\n            while (true) {\n              Map<String,Object> row;\n              synchronized (entityProcessor) {\n                row = entityProcessor.nextRow();\n              }\n              if (row == null) {\n                break;\n              }\n              rowList.put(row.get(ID).toString(), row);\n            }\n          } finally {\n            latch.countDown();\n          }\n        }\n      };\n      \n      new ThreadPoolExecutor(0, Integer.MAX_VALUE, 5, TimeUnit.SECONDS,\n          new SynchronousQueue<Runnable>()).execute(runnable);\n    }\n    \n    try {\n      latch.await();\n    } catch (InterruptedException e) {\n      LOG.error(e.getMessage(), e);\n    }\n    \n    assertEquals(numDocs, rowList.size());\n    \n    for (String[][] expectedDoc : docs) {\n      Map<String,Object> row = rowList.get(expectedDoc[0][1]);\n      assertNotNull(row);\n      int i = 0;\n      for (Entry<String,Object> entry : row.entrySet()) {\n        assertEquals(expectedDoc[i][0], entry.getKey());\n        assertEquals(expectedDoc[i][1], entry.getValue());\n        i++;\n      }\n      rowList.remove(expectedDoc[0][1]);\n    }\n    \n    assertEquals(0, rowList.size());\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","date":1323437438,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestSolrEntityProcessorUnit#testMultiThread().mjava","pathOld":"/dev/null","sourceNew":"  public void testMultiThread() {\n    int numThreads = 5;\n    int numDocs = 40;\n    String[][][] docs = generateDocs(numDocs);\n    final MockSolrEntityProcessor entityProcessor = new MockSolrEntityProcessor(docs, 25);\n    \n    final Map<String,Map<String,Object>> rowList = new HashMap<String,Map<String,Object>>();\n    final CountDownLatch latch = new CountDownLatch(numThreads);\n    for (int i = 0; i < numThreads; i++) {\n      Runnable runnable = new Runnable() {\n        public void run() {\n          try {\n            while (true) {\n              Map<String,Object> row;\n              synchronized (entityProcessor) {\n                row = entityProcessor.nextRow();\n              }\n              if (row == null) {\n                break;\n              }\n              rowList.put(row.get(ID).toString(), row);\n            }\n          } finally {\n            latch.countDown();\n          }\n        }\n      };\n      \n      new ThreadPoolExecutor(0, Integer.MAX_VALUE, 5, TimeUnit.SECONDS,\n          new SynchronousQueue<Runnable>()).execute(runnable);\n    }\n    \n    try {\n      latch.await();\n    } catch (InterruptedException e) {\n      LOG.error(e.getMessage(), e);\n    }\n    \n    assertEquals(numDocs, rowList.size());\n    \n    for (String[][] expectedDoc : docs) {\n      Map<String,Object> row = rowList.get(expectedDoc[0][1]);\n      assertNotNull(row);\n      int i = 0;\n      for (Entry<String,Object> entry : row.entrySet()) {\n        assertEquals(expectedDoc[i][0], entry.getKey());\n        assertEquals(expectedDoc[i][1], entry.getValue());\n        i++;\n      }\n      rowList.remove(expectedDoc[0][1]);\n    }\n    \n    assertEquals(0, rowList.size());\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cdb62ae894642b07cf3f21eb09dc5d85f4a0a4b8","date":1324129595,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestSolrEntityProcessorUnit#testMultiThread().mjava","pathOld":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestSolrEntityProcessorUnit#testMultiThread().mjava","sourceNew":"  public void testMultiThread() throws Exception {\n    int numThreads = 5;\n    int numDocs = 40;\n    List<Doc> docs = generateUniqueDocs(numDocs);\n    final MockSolrEntityProcessor entityProcessor = new MockSolrEntityProcessor(docs, 25);\n    ThreadPoolExecutor executor = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 5, TimeUnit.SECONDS,\n          new SynchronousQueue<Runnable>());\n\n    final Map<String, Map<String, Object>> rowList = new LinkedHashMap<String, Map<String, Object>>();\n    final CountDownLatch latch = new CountDownLatch(numThreads);\n    final AtomicInteger errorCount = new AtomicInteger();\n    for (int i = 0; i < numThreads; i++) {\n      Runnable runnable = new Runnable() {\n        public void run() {\n          try {\n            while (true) {\n              synchronized (entityProcessor) {\n                Map<String, Object> row = entityProcessor.nextRow();\n                if (row == null) {\n                  break;\n                }\n                rowList.put(row.get(ID).toString(), row);\n              }\n            }\n          } catch (Throwable t) {\n            errorCount.incrementAndGet();\n            LOG.error(\"Error in thread\", t);\n          } finally {\n            latch.countDown();\n          }\n        }\n      };\n      executor.execute(runnable);\n    }\n\n    latch.await();\n    assertEquals(0, errorCount.get());\n    assertEquals(numDocs, rowList.size());\n\n    for (Doc expectedDoc : docs) {\n      String id = (String) expectedDoc.getFirstValue(\"id\");\n      Map<String, Object> row = rowList.get(id);\n      assertNotNull(id + \" shouldn't yield null\", row);\n      assertEquals(2, row.size());\n      assertEquals(expectedDoc.id, row.get(\"id\"));\n      assertEquals(expectedDoc.getValues(\"description\"), row.get(\"description\"));\n      rowList.remove(id);\n    }\n\n    assertEquals(0, rowList.size());\n    executor.shutdown();\n  }\n\n","sourceOld":"  public void testMultiThread() {\n    int numThreads = 5;\n    int numDocs = 40;\n    String[][][] docs = generateDocs(numDocs);\n    final MockSolrEntityProcessor entityProcessor = new MockSolrEntityProcessor(docs, 25);\n    \n    final Map<String,Map<String,Object>> rowList = new HashMap<String,Map<String,Object>>();\n    final CountDownLatch latch = new CountDownLatch(numThreads);\n    for (int i = 0; i < numThreads; i++) {\n      Runnable runnable = new Runnable() {\n        public void run() {\n          try {\n            while (true) {\n              Map<String,Object> row;\n              synchronized (entityProcessor) {\n                row = entityProcessor.nextRow();\n              }\n              if (row == null) {\n                break;\n              }\n              rowList.put(row.get(ID).toString(), row);\n            }\n          } finally {\n            latch.countDown();\n          }\n        }\n      };\n      \n      new ThreadPoolExecutor(0, Integer.MAX_VALUE, 5, TimeUnit.SECONDS,\n          new SynchronousQueue<Runnable>()).execute(runnable);\n    }\n    \n    try {\n      latch.await();\n    } catch (InterruptedException e) {\n      LOG.error(e.getMessage(), e);\n    }\n    \n    assertEquals(numDocs, rowList.size());\n    \n    for (String[][] expectedDoc : docs) {\n      Map<String,Object> row = rowList.get(expectedDoc[0][1]);\n      assertNotNull(row);\n      int i = 0;\n      for (Entry<String,Object> entry : row.entrySet()) {\n        assertEquals(expectedDoc[i][0], entry.getKey());\n        assertEquals(expectedDoc[i][1], entry.getValue());\n        i++;\n      }\n      rowList.remove(expectedDoc[0][1]);\n    }\n    \n    assertEquals(0, rowList.size());\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b84e23a1c994ea309896dd9424563e0092f3607","date":1332774278,"type":4,"author":"James Dyer","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestSolrEntityProcessorUnit#testMultiThread().mjava","sourceNew":null,"sourceOld":"  public void testMultiThread() throws Exception {\n    int numThreads = 5;\n    int numDocs = 40;\n    List<Doc> docs = generateUniqueDocs(numDocs);\n    final MockSolrEntityProcessor entityProcessor = new MockSolrEntityProcessor(docs, 25);\n    ThreadPoolExecutor executor = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 5, TimeUnit.SECONDS,\n          new SynchronousQueue<Runnable>());\n\n    final Map<String, Map<String, Object>> rowList = new LinkedHashMap<String, Map<String, Object>>();\n    final CountDownLatch latch = new CountDownLatch(numThreads);\n    final AtomicInteger errorCount = new AtomicInteger();\n    for (int i = 0; i < numThreads; i++) {\n      Runnable runnable = new Runnable() {\n        public void run() {\n          try {\n            while (true) {\n              synchronized (entityProcessor) {\n                Map<String, Object> row = entityProcessor.nextRow();\n                if (row == null) {\n                  break;\n                }\n                rowList.put(row.get(ID).toString(), row);\n              }\n            }\n          } catch (Throwable t) {\n            errorCount.incrementAndGet();\n            LOG.error(\"Error in thread\", t);\n          } finally {\n            latch.countDown();\n          }\n        }\n      };\n      executor.execute(runnable);\n    }\n\n    latch.await();\n    assertEquals(0, errorCount.get());\n    assertEquals(numDocs, rowList.size());\n\n    for (Doc expectedDoc : docs) {\n      String id = (String) expectedDoc.getFirstValue(\"id\");\n      Map<String, Object> row = rowList.get(id);\n      assertNotNull(id + \" shouldn't yield null\", row);\n      assertEquals(2, row.size());\n      assertEquals(expectedDoc.id, row.get(\"id\"));\n      assertEquals(expectedDoc.getValues(\"description\"), row.get(\"description\"));\n      rowList.remove(id);\n    }\n\n    assertEquals(0, rowList.size());\n    executor.shutdown();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4b84e23a1c994ea309896dd9424563e0092f3607":["cdb62ae894642b07cf3f21eb09dc5d85f4a0a4b8"],"cdb62ae894642b07cf3f21eb09dc5d85f4a0a4b8":["cea5f7a2e31566bda38c740c37affa52b0e9c46e"],"cea5f7a2e31566bda38c740c37affa52b0e9c46e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","cea5f7a2e31566bda38c740c37affa52b0e9c46e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4b84e23a1c994ea309896dd9424563e0092f3607"]},"commit2Childs":{"4b84e23a1c994ea309896dd9424563e0092f3607":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cdb62ae894642b07cf3f21eb09dc5d85f4a0a4b8":["4b84e23a1c994ea309896dd9424563e0092f3607"],"cea5f7a2e31566bda38c740c37affa52b0e9c46e":["cdb62ae894642b07cf3f21eb09dc5d85f4a0a4b8","ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00"],"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cea5f7a2e31566bda38c740c37affa52b0e9c46e","ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}