{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","sourceNew":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws MergePolicy.MergeAbortedException, IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.abort();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentInfo info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        return false;\n      }\n      if (info.dir != directory) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentInfo info : mergingSegments) {\n        builder.append(info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentInfo info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + info);\n      }\n      mergingSegments.add(info);\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","sourceOld":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws MergePolicy.MergeAbortedException, IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.abort();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentInfo info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        return false;\n      }\n      if (info.dir != directory) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentInfo info : mergingSegments) {\n        builder.append(info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentInfo info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + info);\n      }\n      mergingSegments.add(info);\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9d153abcf92dc5329d98571a8c3035df9bd80648","date":1337702630,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","sourceNew":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws MergePolicy.MergeAbortedException, IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.abort();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentInfoPerCommit info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        return false;\n      }\n      if (info.info.dir != directory) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentInfoPerCommit info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentInfoPerCommit info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + info);\n      }\n      mergingSegments.add(info);\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","sourceOld":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws MergePolicy.MergeAbortedException, IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.abort();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentInfo info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        return false;\n      }\n      if (info.dir != directory) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentInfo info : mergingSegments) {\n        builder.append(info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentInfo info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + info);\n      }\n      mergingSegments.add(info);\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","sourceNew":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws MergePolicy.MergeAbortedException, IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.abort();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentInfoPerCommit info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        return false;\n      }\n      if (info.info.dir != directory) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentInfoPerCommit info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentInfoPerCommit info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + info);\n      }\n      mergingSegments.add(info);\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","sourceOld":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws MergePolicy.MergeAbortedException, IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.abort();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentInfo info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        return false;\n      }\n      if (info.dir != directory) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentInfo info : mergingSegments) {\n        builder.append(info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentInfo info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + info);\n      }\n      mergingSegments.add(info);\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"19b128c23e9f1b66a9f8518e95ec99fd965d0bb7","date":1338503231,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","sourceNew":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws MergePolicy.MergeAbortedException, IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.abort();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentInfoPerCommit info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        return false;\n      }\n      if (info.info.dir != directory) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentInfoPerCommit info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentInfoPerCommit info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + segString(info));\n      }\n      mergingSegments.add(info);\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","sourceOld":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws MergePolicy.MergeAbortedException, IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.abort();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentInfoPerCommit info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        return false;\n      }\n      if (info.info.dir != directory) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentInfoPerCommit info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentInfoPerCommit info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + info);\n      }\n      mergingSegments.add(info);\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","sourceNew":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.abort();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentInfoPerCommit info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        return false;\n      }\n      if (info.info.dir != directory) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentInfoPerCommit info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentInfoPerCommit info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + segString(info));\n      }\n      mergingSegments.add(info);\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","sourceOld":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws MergePolicy.MergeAbortedException, IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.abort();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentInfoPerCommit info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        return false;\n      }\n      if (info.info.dir != directory) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentInfoPerCommit info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentInfoPerCommit info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + segString(info));\n      }\n      mergingSegments.add(info);\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","bugFix":["01e5948db9a07144112d2f08f28ca2e3cd880348"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","sourceNew":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.abort();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentInfoPerCommit info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        return false;\n      }\n      if (info.info.dir != directory) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentInfoPerCommit info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentInfoPerCommit info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + segString(info));\n      }\n      mergingSegments.add(info);\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","sourceOld":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws MergePolicy.MergeAbortedException, IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.abort();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentInfoPerCommit info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        return false;\n      }\n      if (info.info.dir != directory) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentInfoPerCommit info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentInfoPerCommit info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + segString(info));\n      }\n      mergingSegments.add(info);\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"12902f5338f8f32630888035a9d5d2ff910f8b07","date":1349718075,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","sourceNew":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.abort();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentInfoPerCommit info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" is already marked for merge\");\n        }\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" does not exist in live infos\");\n        }\n        return false;\n      }\n      if (info.info.dir != directory) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentInfoPerCommit info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentInfoPerCommit info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + segString(info));\n      }\n      mergingSegments.add(info);\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","sourceOld":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.abort();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentInfoPerCommit info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        return false;\n      }\n      if (info.info.dir != directory) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentInfoPerCommit info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentInfoPerCommit info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + segString(info));\n      }\n      mergingSegments.add(info);\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06698263c5125d11a04df79637e84372de4ac797","date":1361452578,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","sourceNew":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.abort();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentInfoPerCommit info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" is already marked for merge\");\n        }\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" does not exist in live infos\");\n        }\n        return false;\n      }\n      if (info.info.dir != directory) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentInfoPerCommit info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentInfoPerCommit info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + segString(info));\n      }\n      mergingSegments.add(info);\n    }\n\n    assert merge.estimatedMergeBytes == 0;\n    assert merge.totalMergeBytes == 0;\n    for(SegmentInfoPerCommit info : merge.segments) {\n      if (info.info.getDocCount() > 0) {\n        final int delCount = numDeletedDocs(info);\n        assert delCount <= info.info.getDocCount();\n        final double delRatio = ((double) delCount)/info.info.getDocCount();\n        merge.estimatedMergeBytes += info.sizeInBytes() * (1.0 - delRatio);\n        merge.totalMergeBytes += info.sizeInBytes();\n      }\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","sourceOld":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.abort();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentInfoPerCommit info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" is already marked for merge\");\n        }\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" does not exist in live infos\");\n        }\n        return false;\n      }\n      if (info.info.dir != directory) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentInfoPerCommit info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentInfoPerCommit info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + segString(info));\n      }\n      mergingSegments.add(info);\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","date":1383367127,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","sourceNew":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.abort();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" is already marked for merge\");\n        }\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" does not exist in live infos\");\n        }\n        return false;\n      }\n      if (info.info.dir != directory) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentCommitInfo info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentCommitInfo info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + segString(info));\n      }\n      mergingSegments.add(info);\n    }\n\n    assert merge.estimatedMergeBytes == 0;\n    assert merge.totalMergeBytes == 0;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (info.info.getDocCount() > 0) {\n        final int delCount = numDeletedDocs(info);\n        assert delCount <= info.info.getDocCount();\n        final double delRatio = ((double) delCount)/info.info.getDocCount();\n        merge.estimatedMergeBytes += info.sizeInBytes() * (1.0 - delRatio);\n        merge.totalMergeBytes += info.sizeInBytes();\n      }\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","sourceOld":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.abort();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentInfoPerCommit info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" is already marked for merge\");\n        }\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" does not exist in live infos\");\n        }\n        return false;\n      }\n      if (info.info.dir != directory) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentInfoPerCommit info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentInfoPerCommit info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + segString(info));\n      }\n      mergingSegments.add(info);\n    }\n\n    assert merge.estimatedMergeBytes == 0;\n    assert merge.totalMergeBytes == 0;\n    for(SegmentInfoPerCommit info : merge.segments) {\n      if (info.info.getDocCount() > 0) {\n        final int delCount = numDeletedDocs(info);\n        assert delCount <= info.info.getDocCount();\n        final double delRatio = ((double) delCount)/info.info.getDocCount();\n        merge.estimatedMergeBytes += info.sizeInBytes() * (1.0 - delRatio);\n        merge.totalMergeBytes += info.sizeInBytes();\n      }\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5faf65b6692f15cca0f87bf8666c87899afc619f","date":1420468108,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","sourceNew":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.rateLimiter.setAbort();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" is already marked for merge\");\n        }\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" does not exist in live infos\");\n        }\n        return false;\n      }\n      if (info.info.dir != directory) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentCommitInfo info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentCommitInfo info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + segString(info));\n      }\n      mergingSegments.add(info);\n    }\n\n    assert merge.estimatedMergeBytes == 0;\n    assert merge.totalMergeBytes == 0;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (info.info.getDocCount() > 0) {\n        final int delCount = numDeletedDocs(info);\n        assert delCount <= info.info.getDocCount();\n        final double delRatio = ((double) delCount)/info.info.getDocCount();\n        merge.estimatedMergeBytes += info.sizeInBytes() * (1.0 - delRatio);\n        merge.totalMergeBytes += info.sizeInBytes();\n      }\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","sourceOld":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.abort();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" is already marked for merge\");\n        }\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" does not exist in live infos\");\n        }\n        return false;\n      }\n      if (info.info.dir != directory) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentCommitInfo info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentCommitInfo info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + segString(info));\n      }\n      mergingSegments.add(info);\n    }\n\n    assert merge.estimatedMergeBytes == 0;\n    assert merge.totalMergeBytes == 0;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (info.info.getDocCount() > 0) {\n        final int delCount = numDeletedDocs(info);\n        assert delCount <= info.info.getDocCount();\n        final double delRatio = ((double) delCount)/info.info.getDocCount();\n        merge.estimatedMergeBytes += info.sizeInBytes() * (1.0 - delRatio);\n        merge.totalMergeBytes += info.sizeInBytes();\n      }\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0267c69e2456a3477a1ad785723f2135da3117e","date":1425317087,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","sourceNew":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.rateLimiter.setAbort();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" is already marked for merge\");\n        }\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" does not exist in live infos\");\n        }\n        return false;\n      }\n      if (info.info.dir != directory) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentCommitInfo info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentCommitInfo info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + segString(info));\n      }\n      mergingSegments.add(info);\n    }\n\n    assert merge.estimatedMergeBytes == 0;\n    assert merge.totalMergeBytes == 0;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (info.info.maxDoc() > 0) {\n        final int delCount = numDeletedDocs(info);\n        assert delCount <= info.info.maxDoc();\n        final double delRatio = ((double) delCount)/info.info.maxDoc();\n        merge.estimatedMergeBytes += info.sizeInBytes() * (1.0 - delRatio);\n        merge.totalMergeBytes += info.sizeInBytes();\n      }\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","sourceOld":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.rateLimiter.setAbort();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" is already marked for merge\");\n        }\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" does not exist in live infos\");\n        }\n        return false;\n      }\n      if (info.info.dir != directory) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentCommitInfo info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentCommitInfo info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + segString(info));\n      }\n      mergingSegments.add(info);\n    }\n\n    assert merge.estimatedMergeBytes == 0;\n    assert merge.totalMergeBytes == 0;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (info.info.getDocCount() > 0) {\n        final int delCount = numDeletedDocs(info);\n        assert delCount <= info.info.getDocCount();\n        final double delRatio = ((double) delCount)/info.info.getDocCount();\n        merge.estimatedMergeBytes += info.sizeInBytes() * (1.0 - delRatio);\n        merge.totalMergeBytes += info.sizeInBytes();\n      }\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b06445ae1731e049327712db0454e5643ca9b7fe","date":1425329139,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","sourceNew":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.rateLimiter.setAbort();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" is already marked for merge\");\n        }\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" does not exist in live infos\");\n        }\n        return false;\n      }\n      if (info.info.dir != directory) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentCommitInfo info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentCommitInfo info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + segString(info));\n      }\n      mergingSegments.add(info);\n    }\n\n    assert merge.estimatedMergeBytes == 0;\n    assert merge.totalMergeBytes == 0;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (info.info.maxDoc() > 0) {\n        final int delCount = numDeletedDocs(info);\n        assert delCount <= info.info.maxDoc();\n        final double delRatio = ((double) delCount)/info.info.maxDoc();\n        merge.estimatedMergeBytes += info.sizeInBytes() * (1.0 - delRatio);\n        merge.totalMergeBytes += info.sizeInBytes();\n      }\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","sourceOld":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.rateLimiter.setAbort();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" is already marked for merge\");\n        }\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" does not exist in live infos\");\n        }\n        return false;\n      }\n      if (info.info.dir != directory) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentCommitInfo info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentCommitInfo info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + segString(info));\n      }\n      mergingSegments.add(info);\n    }\n\n    assert merge.estimatedMergeBytes == 0;\n    assert merge.totalMergeBytes == 0;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (info.info.getDocCount() > 0) {\n        final int delCount = numDeletedDocs(info);\n        assert delCount <= info.info.getDocCount();\n        final double delRatio = ((double) delCount)/info.info.getDocCount();\n        merge.estimatedMergeBytes += info.sizeInBytes() * (1.0 - delRatio);\n        merge.totalMergeBytes += info.sizeInBytes();\n      }\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","sourceNew":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.rateLimiter.setAbort();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" is already marked for merge\");\n        }\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" does not exist in live infos\");\n        }\n        return false;\n      }\n      if (info.info.dir != directory) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentCommitInfo info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentCommitInfo info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + segString(info));\n      }\n      mergingSegments.add(info);\n    }\n\n    assert merge.estimatedMergeBytes == 0;\n    assert merge.totalMergeBytes == 0;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (info.info.maxDoc() > 0) {\n        final int delCount = numDeletedDocs(info);\n        assert delCount <= info.info.maxDoc();\n        final double delRatio = ((double) delCount)/info.info.maxDoc();\n        merge.estimatedMergeBytes += info.sizeInBytes() * (1.0 - delRatio);\n        merge.totalMergeBytes += info.sizeInBytes();\n      }\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","sourceOld":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.rateLimiter.setAbort();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" is already marked for merge\");\n        }\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" does not exist in live infos\");\n        }\n        return false;\n      }\n      if (info.info.dir != directory) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentCommitInfo info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentCommitInfo info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + segString(info));\n      }\n      mergingSegments.add(info);\n    }\n\n    assert merge.estimatedMergeBytes == 0;\n    assert merge.totalMergeBytes == 0;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (info.info.getDocCount() > 0) {\n        final int delCount = numDeletedDocs(info);\n        assert delCount <= info.info.getDocCount();\n        final double delRatio = ((double) delCount)/info.info.getDocCount();\n        merge.estimatedMergeBytes += info.sizeInBytes() * (1.0 - delRatio);\n        merge.totalMergeBytes += info.sizeInBytes();\n      }\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"618635065f043788c9e034f96ca5cd5cea1b4592","date":1433442044,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","sourceNew":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.rateLimiter.setAbort();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" is already marked for merge\");\n        }\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" does not exist in live infos\");\n        }\n        return false;\n      }\n      if (info.info.dir != directoryOrig) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentCommitInfo info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentCommitInfo info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + segString(info));\n      }\n      mergingSegments.add(info);\n    }\n\n    assert merge.estimatedMergeBytes == 0;\n    assert merge.totalMergeBytes == 0;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (info.info.maxDoc() > 0) {\n        final int delCount = numDeletedDocs(info);\n        assert delCount <= info.info.maxDoc();\n        final double delRatio = ((double) delCount)/info.info.maxDoc();\n        merge.estimatedMergeBytes += info.sizeInBytes() * (1.0 - delRatio);\n        merge.totalMergeBytes += info.sizeInBytes();\n      }\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","sourceOld":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.rateLimiter.setAbort();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" is already marked for merge\");\n        }\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" does not exist in live infos\");\n        }\n        return false;\n      }\n      if (info.info.dir != directory) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentCommitInfo info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentCommitInfo info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + segString(info));\n      }\n      mergingSegments.add(info);\n    }\n\n    assert merge.estimatedMergeBytes == 0;\n    assert merge.totalMergeBytes == 0;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (info.info.maxDoc() > 0) {\n        final int delCount = numDeletedDocs(info);\n        assert delCount <= info.info.maxDoc();\n        final double delRatio = ((double) delCount)/info.info.maxDoc();\n        merge.estimatedMergeBytes += info.sizeInBytes() * (1.0 - delRatio);\n        merge.totalMergeBytes += info.sizeInBytes();\n      }\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1ee9437ba5a8297220428d48a6bb823d1fcd57b","date":1489137809,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","sourceNew":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.setAborted();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" is already marked for merge\");\n        }\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" does not exist in live infos\");\n        }\n        return false;\n      }\n      if (info.info.dir != directoryOrig) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentCommitInfo info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentCommitInfo info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + segString(info));\n      }\n      mergingSegments.add(info);\n    }\n\n    assert merge.estimatedMergeBytes == 0;\n    assert merge.totalMergeBytes == 0;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (info.info.maxDoc() > 0) {\n        final int delCount = numDeletedDocs(info);\n        assert delCount <= info.info.maxDoc();\n        final double delRatio = ((double) delCount)/info.info.maxDoc();\n        merge.estimatedMergeBytes += info.sizeInBytes() * (1.0 - delRatio);\n        merge.totalMergeBytes += info.sizeInBytes();\n      }\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","sourceOld":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.rateLimiter.setAbort();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" is already marked for merge\");\n        }\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" does not exist in live infos\");\n        }\n        return false;\n      }\n      if (info.info.dir != directoryOrig) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentCommitInfo info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentCommitInfo info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + segString(info));\n      }\n      mergingSegments.add(info);\n    }\n\n    assert merge.estimatedMergeBytes == 0;\n    assert merge.totalMergeBytes == 0;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (info.info.maxDoc() > 0) {\n        final int delCount = numDeletedDocs(info);\n        assert delCount <= info.info.maxDoc();\n        final double delRatio = ((double) delCount)/info.info.maxDoc();\n        merge.estimatedMergeBytes += info.sizeInBytes() * (1.0 - delRatio);\n        merge.totalMergeBytes += info.sizeInBytes();\n      }\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2","date":1588002560,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","sourceNew":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  private synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.setAborted();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" is already marked for merge\");\n        }\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" does not exist in live infos\");\n        }\n        return false;\n      }\n      if (info.info.dir != directoryOrig) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentCommitInfo info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentCommitInfo info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + segString(info));\n      }\n      mergingSegments.add(info);\n    }\n\n    assert merge.estimatedMergeBytes == 0;\n    assert merge.totalMergeBytes == 0;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (info.info.maxDoc() > 0) {\n        final int delCount = numDeletedDocs(info);\n        assert delCount <= info.info.maxDoc();\n        final double delRatio = ((double) delCount)/info.info.maxDoc();\n        merge.estimatedMergeBytes += info.sizeInBytes() * (1.0 - delRatio);\n        merge.totalMergeBytes += info.sizeInBytes();\n      }\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","sourceOld":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.setAborted();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" is already marked for merge\");\n        }\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" does not exist in live infos\");\n        }\n        return false;\n      }\n      if (info.info.dir != directoryOrig) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentCommitInfo info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentCommitInfo info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + segString(info));\n      }\n      mergingSegments.add(info);\n    }\n\n    assert merge.estimatedMergeBytes == 0;\n    assert merge.totalMergeBytes == 0;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (info.info.maxDoc() > 0) {\n        final int delCount = numDeletedDocs(info);\n        assert delCount <= info.info.maxDoc();\n        final double delRatio = ((double) delCount)/info.info.maxDoc();\n        merge.estimatedMergeBytes += info.sizeInBytes() * (1.0 - delRatio);\n        merge.totalMergeBytes += info.sizeInBytes();\n      }\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c2a23476693f2bd9a4b44cc3187c429a2e21dac2","date":1593289545,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","sourceNew":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  private synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      abortOneMerge(merge);\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" is already marked for merge\");\n        }\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" does not exist in live infos\");\n        }\n        return false;\n      }\n      if (info.info.dir != directoryOrig) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentCommitInfo info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentCommitInfo info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + segString(info));\n      }\n      mergingSegments.add(info);\n    }\n\n    assert merge.estimatedMergeBytes == 0;\n    assert merge.totalMergeBytes == 0;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (info.info.maxDoc() > 0) {\n        final int delCount = numDeletedDocs(info);\n        assert delCount <= info.info.maxDoc();\n        final double delRatio = ((double) delCount)/info.info.maxDoc();\n        merge.estimatedMergeBytes += info.sizeInBytes() * (1.0 - delRatio);\n        merge.totalMergeBytes += info.sizeInBytes();\n      }\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","sourceOld":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  private synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      merge.setAborted();\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" is already marked for merge\");\n        }\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" does not exist in live infos\");\n        }\n        return false;\n      }\n      if (info.info.dir != directoryOrig) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentCommitInfo info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentCommitInfo info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + segString(info));\n      }\n      mergingSegments.add(info);\n    }\n\n    assert merge.estimatedMergeBytes == 0;\n    assert merge.totalMergeBytes == 0;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (info.info.maxDoc() > 0) {\n        final int delCount = numDeletedDocs(info);\n        assert delCount <= info.info.maxDoc();\n        final double delRatio = ((double) delCount)/info.info.maxDoc();\n        merge.estimatedMergeBytes += info.sizeInBytes() * (1.0 - delRatio);\n        merge.totalMergeBytes += info.sizeInBytes();\n      }\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a775b68a26e2d19d1b5f16cd18a3bc8df738a302","date":1598253342,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","sourceNew":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  private synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (merges.areEnabled() == false) {\n      abortOneMerge(merge);\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" is already marked for merge\");\n        }\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" does not exist in live infos\");\n        }\n        return false;\n      }\n      if (info.info.dir != directoryOrig) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentCommitInfo info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentCommitInfo info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + segString(info));\n      }\n      mergingSegments.add(info);\n    }\n\n    assert merge.estimatedMergeBytes == 0;\n    assert merge.totalMergeBytes == 0;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (info.info.maxDoc() > 0) {\n        final int delCount = numDeletedDocs(info);\n        assert delCount <= info.info.maxDoc();\n        final double delRatio = ((double) delCount)/info.info.maxDoc();\n        merge.estimatedMergeBytes += info.sizeInBytes() * (1.0 - delRatio);\n        merge.totalMergeBytes += info.sizeInBytes();\n      }\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","sourceOld":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  private synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (stopMerges) {\n      abortOneMerge(merge);\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" is already marked for merge\");\n        }\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" does not exist in live infos\");\n        }\n        return false;\n      }\n      if (info.info.dir != directoryOrig) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentCommitInfo info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentCommitInfo info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + segString(info));\n      }\n      mergingSegments.add(info);\n    }\n\n    assert merge.estimatedMergeBytes == 0;\n    assert merge.totalMergeBytes == 0;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (info.info.maxDoc() > 0) {\n        final int delCount = numDeletedDocs(info);\n        assert delCount <= info.info.maxDoc();\n        final double delRatio = ((double) delCount)/info.info.maxDoc();\n        merge.estimatedMergeBytes += info.sizeInBytes() * (1.0 - delRatio);\n        merge.totalMergeBytes += info.sizeInBytes();\n      }\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9f94c392daa8f5708186bede16c84eafad4cdd2","date":1599578873,"type":3,"author":"Mike Drob","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#registerMerge(MergePolicy.OneMerge).mjava","sourceNew":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  private synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (merges.areEnabled() == false) {\n      abortOneMerge(merge);\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" is already marked for merge\");\n        }\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" does not exist in live infos\");\n        }\n        return false;\n      }\n      if (info.info.dir != directoryOrig) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentCommitInfo info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentCommitInfo info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + segString(info));\n      }\n      mergingSegments.add(info);\n    }\n\n    assert merge.estimatedMergeBytes == 0;\n    assert merge.totalMergeBytes == 0;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (info.info.maxDoc() > 0) {\n        final int delCount = numDeletedDocs(info);\n        assert delCount <= info.info.maxDoc();\n        final double delRatio = ((double) delCount)/info.info.maxDoc();\n        merge.estimatedMergeBytes += (long) (info.sizeInBytes() * (1.0 - delRatio));\n        merge.totalMergeBytes += info.sizeInBytes();\n      }\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","sourceOld":"  /** Checks whether this merge involves any segments\n   *  already participating in a merge.  If not, this merge\n   *  is \"registered\", meaning we record that its segments\n   *  are now participating in a merge, and true is\n   *  returned.  Else (the merge conflicts) false is\n   *  returned. */\n  private synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    if (merge.registerDone) {\n      return true;\n    }\n    assert merge.segments.size() > 0;\n\n    if (merges.areEnabled() == false) {\n      abortOneMerge(merge);\n      throw new MergePolicy.MergeAbortedException(\"merge is aborted: \" + segString(merge.segments));\n    }\n\n    boolean isExternal = false;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (mergingSegments.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" is already marked for merge\");\n        }\n        return false;\n      }\n      if (!segmentInfos.contains(info)) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"reject merge \" + segString(merge.segments) + \": segment \" + segString(info) + \" does not exist in live infos\");\n        }\n        return false;\n      }\n      if (info.info.dir != directoryOrig) {\n        isExternal = true;\n      }\n      if (segmentsToMerge.containsKey(info)) {\n        merge.maxNumSegments = mergeMaxNumSegments;\n      }\n    }\n\n    ensureValidMerge(merge);\n\n    pendingMerges.add(merge);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"add merge to pendingMerges: \" + segString(merge.segments) + \" [total \" + pendingMerges.size() + \" pending]\");\n    }\n\n    merge.mergeGen = mergeGen;\n    merge.isExternal = isExternal;\n\n    // OK it does not conflict; now record that this merge\n    // is running (while synchronized) to avoid race\n    // condition where two conflicting merges from different\n    // threads, start\n    if (infoStream.isEnabled(\"IW\")) {\n      StringBuilder builder = new StringBuilder(\"registerMerge merging= [\");\n      for (SegmentCommitInfo info : mergingSegments) {\n        builder.append(info.info.name).append(\", \");  \n      }\n      builder.append(\"]\");\n      // don't call mergingSegments.toString() could lead to ConcurrentModException\n      // since merge updates the segments FieldInfos\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", builder.toString());  \n      }\n    }\n    for(SegmentCommitInfo info : merge.segments) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"registerMerge info=\" + segString(info));\n      }\n      mergingSegments.add(info);\n    }\n\n    assert merge.estimatedMergeBytes == 0;\n    assert merge.totalMergeBytes == 0;\n    for(SegmentCommitInfo info : merge.segments) {\n      if (info.info.maxDoc() > 0) {\n        final int delCount = numDeletedDocs(info);\n        assert delCount <= info.info.maxDoc();\n        final double delRatio = ((double) delCount)/info.info.maxDoc();\n        merge.estimatedMergeBytes += info.sizeInBytes() * (1.0 - delRatio);\n        merge.totalMergeBytes += info.sizeInBytes();\n      }\n    }\n\n    // Merge is now registered\n    merge.registerDone = true;\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["06698263c5125d11a04df79637e84372de4ac797"],"c9f94c392daa8f5708186bede16c84eafad4cdd2":["a775b68a26e2d19d1b5f16cd18a3bc8df738a302"],"06698263c5125d11a04df79637e84372de4ac797":["12902f5338f8f32630888035a9d5d2ff910f8b07"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a775b68a26e2d19d1b5f16cd18a3bc8df738a302":["c2a23476693f2bd9a4b44cc3187c429a2e21dac2"],"b0267c69e2456a3477a1ad785723f2135da3117e":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"9d153abcf92dc5329d98571a8c3035df9bd80648":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"c1ee9437ba5a8297220428d48a6bb823d1fcd57b":["618635065f043788c9e034f96ca5cd5cea1b4592"],"618635065f043788c9e034f96ca5cd5cea1b4592":["b0267c69e2456a3477a1ad785723f2135da3117e"],"c2a23476693f2bd9a4b44cc3187c429a2e21dac2":["8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["5faf65b6692f15cca0f87bf8666c87899afc619f","b0267c69e2456a3477a1ad785723f2135da3117e"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","9d153abcf92dc5329d98571a8c3035df9bd80648"],"b06445ae1731e049327712db0454e5643ca9b7fe":["5faf65b6692f15cca0f87bf8666c87899afc619f","b0267c69e2456a3477a1ad785723f2135da3117e"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["19b128c23e9f1b66a9f8518e95ec99fd965d0bb7","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2":["c1ee9437ba5a8297220428d48a6bb823d1fcd57b"],"19b128c23e9f1b66a9f8518e95ec99fd965d0bb7":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["19b128c23e9f1b66a9f8518e95ec99fd965d0bb7"],"12902f5338f8f32630888035a9d5d2ff910f8b07":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c9f94c392daa8f5708186bede16c84eafad4cdd2"]},"commit2Childs":{"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"c9f94c392daa8f5708186bede16c84eafad4cdd2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"06698263c5125d11a04df79637e84372de4ac797":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["9d153abcf92dc5329d98571a8c3035df9bd80648","615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"a775b68a26e2d19d1b5f16cd18a3bc8df738a302":["c9f94c392daa8f5708186bede16c84eafad4cdd2"],"b0267c69e2456a3477a1ad785723f2135da3117e":["618635065f043788c9e034f96ca5cd5cea1b4592","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe"],"9d153abcf92dc5329d98571a8c3035df9bd80648":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"c1ee9437ba5a8297220428d48a6bb823d1fcd57b":["8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2"],"618635065f043788c9e034f96ca5cd5cea1b4592":["c1ee9437ba5a8297220428d48a6bb823d1fcd57b"],"c2a23476693f2bd9a4b44cc3187c429a2e21dac2":["a775b68a26e2d19d1b5f16cd18a3bc8df738a302"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["19b128c23e9f1b66a9f8518e95ec99fd965d0bb7"],"b06445ae1731e049327712db0454e5643ca9b7fe":[],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2":["c2a23476693f2bd9a4b44cc3187c429a2e21dac2"],"19b128c23e9f1b66a9f8518e95ec99fd965d0bb7":["fe33227f6805edab2036cbb80645cc4e2d1fa424","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["b0267c69e2456a3477a1ad785723f2135da3117e","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["fe33227f6805edab2036cbb80645cc4e2d1fa424","12902f5338f8f32630888035a9d5d2ff910f8b07"],"12902f5338f8f32630888035a9d5d2ff910f8b07":["06698263c5125d11a04df79637e84372de4ac797"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}