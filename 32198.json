{"path":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","commits":[{"id":"819937dbf00e42db24a95dd95454773e968b164f","date":1397424778,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"/dev/null","sourceNew":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getNodeName()));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1fc56848da7b3f927bb9840e8aedf09ee11cede1","date":1424871235,"type":4,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":null,"sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getNodeName()));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":4,"author":"Ryan Ernst","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":null,"sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getNodeName()));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["819937dbf00e42db24a95dd95454773e968b164f","1fc56848da7b3f927bb9840e8aedf09ee11cede1"],"1fc56848da7b3f927bb9840e8aedf09ee11cede1":["819937dbf00e42db24a95dd95454773e968b164f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"819937dbf00e42db24a95dd95454773e968b164f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1fc56848da7b3f927bb9840e8aedf09ee11cede1"]},"commit2Childs":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"1fc56848da7b3f927bb9840e8aedf09ee11cede1":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["819937dbf00e42db24a95dd95454773e968b164f"],"819937dbf00e42db24a95dd95454773e968b164f":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","1fc56848da7b3f927bb9840e8aedf09ee11cede1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}