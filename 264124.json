{"path":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetField#queuePivotRefinementRequests(PivotFacet).mjava","commits":[{"id":"92751ba9273251eab6a2e379ec42a1697a32ff96","date":1407954233,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetField#queuePivotRefinementRequests(PivotFacet).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * A recursive method for determining which {@link PivotFacetValue}s need to be\n   * refined for this pivot.\n   *\n   * @see PivotFacet#queuePivotRefinementRequests\n   */\n  public void queuePivotRefinementRequests(PivotFacet pf) {\n    \n    if (needRefinementAtThisLevel && ! valueCollection.getExplicitValuesList().isEmpty()) {\n\n      if (FacetParams.FACET_SORT_COUNT.equals(facetFieldSort)) {\n        // we only need to things that are currently in our limit,\n        // or might be in our limit if we get increased counts from shards that\n        // didn't include this value the first time\n        final int indexOfCountThreshold \n          = Math.min(valueCollection.getExplicitValuesListSize(), \n                     facetFieldOffset + facetFieldLimit) - 1;\n        final int countThreshold = valueCollection.getAt(indexOfCountThreshold).getCount();\n        \n        int positionInResults = 0;\n        \n        for (PivotFacetValue value : valueCollection.getExplicitValuesList()) {\n          if (positionInResults <= indexOfCountThreshold) {\n            // This element is within the top results, so we need to get information \n            // from all of the shards.\n            processDefiniteCandidateElement(pf, value);\n          } else {\n            // This element is not within the top results, but may still need to be refined.\n            processPossibleCandidateElement(pf, value, countThreshold);\n          }\n          \n          positionInResults++;\n        }\n      } else { // FACET_SORT_INDEX\n        // everything needs refined to see what the per-shard mincount excluded\n        for (PivotFacetValue value : valueCollection.getExplicitValuesList()) {\n          processDefiniteCandidateElement(pf, value);\n        }\n      }\n\n      needRefinementAtThisLevel = false;\n    }\n      \n    if ( pf.isRefinementsRequired() ) {\n      // if any refinements are needed, then we need to stop and wait to\n      // see how the picture may change before drilling down to child pivot fields \n      return;\n    } else {\n      // Since outstanding requests have been filled, then we can drill down \n      // to the next deeper level and check it.\n      refineNextLevelOfFacets(pf);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["b6785b4fe22e78ff9bb8afd2d475325cfc1e006c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b6785b4fe22e78ff9bb8afd2d475325cfc1e006c","date":1438054340,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetField#queuePivotRefinementRequests(PivotFacet).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetField#queuePivotRefinementRequests(PivotFacet).mjava","sourceNew":"  /** \n   * A recursive method for determining which {@link PivotFacetValue}s need to be\n   * refined for this pivot.\n   *\n   * @see PivotFacet#queuePivotRefinementRequests\n   */\n  public void queuePivotRefinementRequests(PivotFacet pf) {\n    \n    if (needRefinementAtThisLevel) {\n\n      if (0 < facetFieldMinimumCount) {\n        // missing is always a candidate for refinement if at least one shard met the minimum\n        PivotFacetValue missing = valueCollection.getMissingValue();\n        if (null != missing) {\n          processDefiniteCandidateElement(pf, valueCollection.getMissingValue());\n        }\n      }\n\n      if (! valueCollection.getExplicitValuesList().isEmpty()) {\n\n        if (FacetParams.FACET_SORT_COUNT.equals(facetFieldSort)) {\n          // we only need to things that are currently in our limit,\n          // or might be in our limit if we get increased counts from shards that\n          // didn't include this value the first time\n          final int indexOfCountThreshold \n            = Math.min(valueCollection.getExplicitValuesListSize(), \n                       facetFieldOffset + facetFieldLimit) - 1;\n          final int countThreshold = valueCollection.getAt(indexOfCountThreshold).getCount();\n          \n          int positionInResults = 0;\n          \n          for (PivotFacetValue value : valueCollection.getExplicitValuesList()) {\n            if (positionInResults <= indexOfCountThreshold) {\n              // This element is within the top results, so we need to get information \n              // from all of the shards.\n              processDefiniteCandidateElement(pf, value);\n            } else {\n              // This element is not within the top results, but may still need to be refined.\n              processPossibleCandidateElement(pf, value, countThreshold);\n            }\n            \n            positionInResults++;\n          }\n        } else { // FACET_SORT_INDEX\n          // everything needs refined to see what the per-shard mincount excluded\n          for (PivotFacetValue value : valueCollection.getExplicitValuesList()) {\n            processDefiniteCandidateElement(pf, value);\n          }\n        }\n      }\n\n      needRefinementAtThisLevel = false;\n    }\n      \n    if ( pf.isRefinementsRequired() ) {\n      // if any refinements are needed, then we need to stop and wait to\n      // see how the picture may change before drilling down to child pivot fields \n      return;\n    } else {\n      // Since outstanding requests have been filled, then we can drill down \n      // to the next deeper level and check it.\n      refineNextLevelOfFacets(pf);\n    }\n  }\n\n","sourceOld":"  /** \n   * A recursive method for determining which {@link PivotFacetValue}s need to be\n   * refined for this pivot.\n   *\n   * @see PivotFacet#queuePivotRefinementRequests\n   */\n  public void queuePivotRefinementRequests(PivotFacet pf) {\n    \n    if (needRefinementAtThisLevel && ! valueCollection.getExplicitValuesList().isEmpty()) {\n\n      if (FacetParams.FACET_SORT_COUNT.equals(facetFieldSort)) {\n        // we only need to things that are currently in our limit,\n        // or might be in our limit if we get increased counts from shards that\n        // didn't include this value the first time\n        final int indexOfCountThreshold \n          = Math.min(valueCollection.getExplicitValuesListSize(), \n                     facetFieldOffset + facetFieldLimit) - 1;\n        final int countThreshold = valueCollection.getAt(indexOfCountThreshold).getCount();\n        \n        int positionInResults = 0;\n        \n        for (PivotFacetValue value : valueCollection.getExplicitValuesList()) {\n          if (positionInResults <= indexOfCountThreshold) {\n            // This element is within the top results, so we need to get information \n            // from all of the shards.\n            processDefiniteCandidateElement(pf, value);\n          } else {\n            // This element is not within the top results, but may still need to be refined.\n            processPossibleCandidateElement(pf, value, countThreshold);\n          }\n          \n          positionInResults++;\n        }\n      } else { // FACET_SORT_INDEX\n        // everything needs refined to see what the per-shard mincount excluded\n        for (PivotFacetValue value : valueCollection.getExplicitValuesList()) {\n          processDefiniteCandidateElement(pf, value);\n        }\n      }\n\n      needRefinementAtThisLevel = false;\n    }\n      \n    if ( pf.isRefinementsRequired() ) {\n      // if any refinements are needed, then we need to stop and wait to\n      // see how the picture may change before drilling down to child pivot fields \n      return;\n    } else {\n      // Since outstanding requests have been filled, then we can drill down \n      // to the next deeper level and check it.\n      refineNextLevelOfFacets(pf);\n    }\n  }\n\n","bugFix":["92751ba9273251eab6a2e379ec42a1697a32ff96"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"92751ba9273251eab6a2e379ec42a1697a32ff96":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b6785b4fe22e78ff9bb8afd2d475325cfc1e006c":["92751ba9273251eab6a2e379ec42a1697a32ff96"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b6785b4fe22e78ff9bb8afd2d475325cfc1e006c"]},"commit2Childs":{"92751ba9273251eab6a2e379ec42a1697a32ff96":["b6785b4fe22e78ff9bb8afd2d475325cfc1e006c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["92751ba9273251eab6a2e379ec42a1697a32ff96"],"b6785b4fe22e78ff9bb8afd2d475325cfc1e006c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}