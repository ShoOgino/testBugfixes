{"path":"src/test/org/apache/lucene/search/TestCustomSearcherSort#matchHits(Searcher,Sort).mjava","commits":[{"id":"4d4707b60e1780a8b3e3d4a8fda80126e889deb5","date":1131678790,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/TestCustomSearcherSort#matchHits(Searcher,Sort).mjava","pathOld":"/dev/null","sourceNew":"\t// make sure the documents returned by the search match the expected list\r\n\tprivate void matchHits (Searcher searcher, Sort sort)\r\n\tthrows IOException {\r\n\t    // make a query without sorting first\r\n\t\tHits hitsByRank = searcher.search(query);\r\n\t\tcheckHits(hitsByRank, \"Sort by rank: \"); // check for duplicates\r\n        Map resultMap = new TreeMap();\r\n        // store hits in TreeMap - TreeMap does not allow duplicates; existing entries are silently overwritten\r\n        for(int hitid=0;hitid<hitsByRank.length(); ++hitid) {\r\n            resultMap.put(\r\n                    new Integer(hitsByRank.id(hitid)),  // Key:   Lucene Document ID\r\n                    new Integer(hitid));\t\t\t\t// Value: Hits-Objekt Index\r\n        }\r\n        \r\n        // now make a query using the sort criteria\r\n\t\tHits resultSort = searcher.search (query, sort);\r\n\t\tcheckHits(resultSort, \"Sort by custom criteria: \"); // check for duplicates\r\n\t\t\r\n        String lf = System.getProperty(\"line.separator\", \"\\n\");\r\n        // besides the sorting both sets of hits must be identical\r\n        for(int hitid=0;hitid<resultSort.length(); ++hitid) {\r\n            Integer idHitDate = new Integer(resultSort.id(hitid)); // document ID from sorted search\r\n            if(!resultMap.containsKey(idHitDate)) {\r\n                log(\"ID \"+idHitDate+\" not found. Possibliy a duplicate.\");\r\n            }\r\n            assertTrue(resultMap.containsKey(idHitDate)); // same ID must be in the Map from the rank-sorted search\r\n            // every hit must appear once in both result sets --> remove it from the Map.\r\n            // At the end the Map must be empty!\r\n            resultMap.remove(idHitDate);\r\n        }\r\n        if(resultMap.size()==0) {\r\n            log(\"All hits matched\");\r\n        } else {\r\n        log(\"Couldn't match \"+resultMap.size()+\" hits.\");\r\n        }\r\n        assertEquals(resultMap.size(), 0);\r\n\t}\r\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"77aeeb67c242aab2046ab501c4fa482c92f124d7","date":1132169911,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/TestCustomSearcherSort#matchHits(Searcher,Sort).mjava","pathOld":"src/test/org/apache/lucene/search/TestCustomSearcherSort#matchHits(Searcher,Sort).mjava","sourceNew":"\t// make sure the documents returned by the search match the expected list\r\n\tprivate void matchHits (Searcher searcher, Sort sort)\r\n\tthrows IOException {\r\n\t    // make a query without sorting first\r\n\t\tHits hitsByRank = searcher.search(query);\r\n\t\tcheckHits(hitsByRank, \"Sort by rank: \"); // check for duplicates\r\n        Map resultMap = new TreeMap();\r\n        // store hits in TreeMap - TreeMap does not allow duplicates; existing entries are silently overwritten\r\n        for(int hitid=0;hitid<hitsByRank.length(); ++hitid) {\r\n            resultMap.put(\r\n                    new Integer(hitsByRank.id(hitid)),  // Key:   Lucene Document ID\r\n                    new Integer(hitid));\t\t\t\t// Value: Hits-Objekt Index\r\n        }\r\n        \r\n        // now make a query using the sort criteria\r\n\t\tHits resultSort = searcher.search (query, sort);\r\n\t\tcheckHits(resultSort, \"Sort by custom criteria: \"); // check for duplicates\r\n\t\t\r\n        String lf = System.getProperty(\"line.separator\", \"\\n\");\r\n        // besides the sorting both sets of hits must be identical\r\n        for(int hitid=0;hitid<resultSort.length(); ++hitid) {\r\n            Integer idHitDate = new Integer(resultSort.id(hitid)); // document ID from sorted search\r\n            if(!resultMap.containsKey(idHitDate)) {\r\n                log(\"ID \"+idHitDate+\" not found. Possibliy a duplicate.\");\r\n            }\r\n            assertTrue(resultMap.containsKey(idHitDate)); // same ID must be in the Map from the rank-sorted search\r\n            // every hit must appear once in both result sets --> remove it from the Map.\r\n            // At the end the Map must be empty!\r\n            resultMap.remove(idHitDate);\r\n        }\r\n        if(resultMap.size()==0) {\r\n            // log(\"All hits matched\");\r\n        } else {\r\n        log(\"Couldn't match \"+resultMap.size()+\" hits.\");\r\n        }\r\n        assertEquals(resultMap.size(), 0);\r\n\t}\r\n\n","sourceOld":"\t// make sure the documents returned by the search match the expected list\r\n\tprivate void matchHits (Searcher searcher, Sort sort)\r\n\tthrows IOException {\r\n\t    // make a query without sorting first\r\n\t\tHits hitsByRank = searcher.search(query);\r\n\t\tcheckHits(hitsByRank, \"Sort by rank: \"); // check for duplicates\r\n        Map resultMap = new TreeMap();\r\n        // store hits in TreeMap - TreeMap does not allow duplicates; existing entries are silently overwritten\r\n        for(int hitid=0;hitid<hitsByRank.length(); ++hitid) {\r\n            resultMap.put(\r\n                    new Integer(hitsByRank.id(hitid)),  // Key:   Lucene Document ID\r\n                    new Integer(hitid));\t\t\t\t// Value: Hits-Objekt Index\r\n        }\r\n        \r\n        // now make a query using the sort criteria\r\n\t\tHits resultSort = searcher.search (query, sort);\r\n\t\tcheckHits(resultSort, \"Sort by custom criteria: \"); // check for duplicates\r\n\t\t\r\n        String lf = System.getProperty(\"line.separator\", \"\\n\");\r\n        // besides the sorting both sets of hits must be identical\r\n        for(int hitid=0;hitid<resultSort.length(); ++hitid) {\r\n            Integer idHitDate = new Integer(resultSort.id(hitid)); // document ID from sorted search\r\n            if(!resultMap.containsKey(idHitDate)) {\r\n                log(\"ID \"+idHitDate+\" not found. Possibliy a duplicate.\");\r\n            }\r\n            assertTrue(resultMap.containsKey(idHitDate)); // same ID must be in the Map from the rank-sorted search\r\n            // every hit must appear once in both result sets --> remove it from the Map.\r\n            // At the end the Map must be empty!\r\n            resultMap.remove(idHitDate);\r\n        }\r\n        if(resultMap.size()==0) {\r\n            log(\"All hits matched\");\r\n        } else {\r\n        log(\"Couldn't match \"+resultMap.size()+\" hits.\");\r\n        }\r\n        assertEquals(resultMap.size(), 0);\r\n\t}\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2123bddbd65dea198cac380540636ce43a880403","date":1211269254,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/TestCustomSearcherSort#matchHits(Searcher,Sort).mjava","pathOld":"src/test/org/apache/lucene/search/TestCustomSearcherSort#matchHits(Searcher,Sort).mjava","sourceNew":"\t// make sure the documents returned by the search match the expected list\n\tprivate void matchHits (Searcher searcher, Sort sort)\n\tthrows IOException {\n\t    // make a query without sorting first\n\t\tHits hitsByRank = searcher.search(query);\n\t\tcheckHits(hitsByRank, \"Sort by rank: \"); // check for duplicates\n        Map resultMap = new TreeMap();\n        // store hits in TreeMap - TreeMap does not allow duplicates; existing entries are silently overwritten\n        for(int hitid=0;hitid<hitsByRank.length(); ++hitid) {\n            resultMap.put(\n                    new Integer(hitsByRank.id(hitid)),  // Key:   Lucene Document ID\n                    new Integer(hitid));\t\t\t\t// Value: Hits-Objekt Index\n        }\n        \n        // now make a query using the sort criteria\n\t\tHits resultSort = searcher.search (query, sort);\n\t\tcheckHits(resultSort, \"Sort by custom criteria: \"); // check for duplicates\n\t\t\n        String lf = System.getProperty(\"line.separator\", \"\\n\");\n        // besides the sorting both sets of hits must be identical\n        for(int hitid=0;hitid<resultSort.length(); ++hitid) {\n            Integer idHitDate = new Integer(resultSort.id(hitid)); // document ID from sorted search\n            if(!resultMap.containsKey(idHitDate)) {\n                log(\"ID \"+idHitDate+\" not found. Possibliy a duplicate.\");\n            }\n            assertTrue(resultMap.containsKey(idHitDate)); // same ID must be in the Map from the rank-sorted search\n            // every hit must appear once in both result sets --> remove it from the Map.\n            // At the end the Map must be empty!\n            resultMap.remove(idHitDate);\n        }\n        if(resultMap.size()==0) {\n            // log(\"All hits matched\");\n        } else {\n        log(\"Couldn't match \"+resultMap.size()+\" hits.\");\n        }\n        assertEquals(resultMap.size(), 0);\n\t}\n\n","sourceOld":"\t// make sure the documents returned by the search match the expected list\r\n\tprivate void matchHits (Searcher searcher, Sort sort)\r\n\tthrows IOException {\r\n\t    // make a query without sorting first\r\n\t\tHits hitsByRank = searcher.search(query);\r\n\t\tcheckHits(hitsByRank, \"Sort by rank: \"); // check for duplicates\r\n        Map resultMap = new TreeMap();\r\n        // store hits in TreeMap - TreeMap does not allow duplicates; existing entries are silently overwritten\r\n        for(int hitid=0;hitid<hitsByRank.length(); ++hitid) {\r\n            resultMap.put(\r\n                    new Integer(hitsByRank.id(hitid)),  // Key:   Lucene Document ID\r\n                    new Integer(hitid));\t\t\t\t// Value: Hits-Objekt Index\r\n        }\r\n        \r\n        // now make a query using the sort criteria\r\n\t\tHits resultSort = searcher.search (query, sort);\r\n\t\tcheckHits(resultSort, \"Sort by custom criteria: \"); // check for duplicates\r\n\t\t\r\n        String lf = System.getProperty(\"line.separator\", \"\\n\");\r\n        // besides the sorting both sets of hits must be identical\r\n        for(int hitid=0;hitid<resultSort.length(); ++hitid) {\r\n            Integer idHitDate = new Integer(resultSort.id(hitid)); // document ID from sorted search\r\n            if(!resultMap.containsKey(idHitDate)) {\r\n                log(\"ID \"+idHitDate+\" not found. Possibliy a duplicate.\");\r\n            }\r\n            assertTrue(resultMap.containsKey(idHitDate)); // same ID must be in the Map from the rank-sorted search\r\n            // every hit must appear once in both result sets --> remove it from the Map.\r\n            // At the end the Map must be empty!\r\n            resultMap.remove(idHitDate);\r\n        }\r\n        if(resultMap.size()==0) {\r\n            // log(\"All hits matched\");\r\n        } else {\r\n        log(\"Couldn't match \"+resultMap.size()+\" hits.\");\r\n        }\r\n        assertEquals(resultMap.size(), 0);\r\n\t}\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5af07783dbc171e26a694c4f7d735e30c2769faa","date":1211569075,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/TestCustomSearcherSort#matchHits(Searcher,Sort).mjava","pathOld":"src/test/org/apache/lucene/search/TestCustomSearcherSort#matchHits(Searcher,Sort).mjava","sourceNew":"\t// make sure the documents returned by the search match the expected list\n\tprivate void matchHits (Searcher searcher, Sort sort)\n\tthrows IOException {\n\t    // make a query without sorting first\n    ScoreDoc[] hitsByRank = searcher.search(query, null, 1000).scoreDocs;\n\t\tcheckHits(hitsByRank, \"Sort by rank: \"); // check for duplicates\n        Map resultMap = new TreeMap();\n        // store hits in TreeMap - TreeMap does not allow duplicates; existing entries are silently overwritten\n        for(int hitid=0;hitid<hitsByRank.length; ++hitid) {\n            resultMap.put(\n                    new Integer(hitsByRank[hitid].doc),  // Key:   Lucene Document ID\n                    new Integer(hitid));\t\t\t\t// Value: Hits-Objekt Index\n        }\n        \n        // now make a query using the sort criteria\n    ScoreDoc[] resultSort = searcher.search (query, null, 1000, sort).scoreDocs;\n\t\tcheckHits(resultSort, \"Sort by custom criteria: \"); // check for duplicates\n\t\t\n        String lf = System.getProperty(\"line.separator\", \"\\n\");\n        // besides the sorting both sets of hits must be identical\n        for(int hitid=0;hitid<resultSort.length; ++hitid) {\n            Integer idHitDate = new Integer(resultSort[hitid].doc); // document ID from sorted search\n            if(!resultMap.containsKey(idHitDate)) {\n                log(\"ID \"+idHitDate+\" not found. Possibliy a duplicate.\");\n            }\n            assertTrue(resultMap.containsKey(idHitDate)); // same ID must be in the Map from the rank-sorted search\n            // every hit must appear once in both result sets --> remove it from the Map.\n            // At the end the Map must be empty!\n            resultMap.remove(idHitDate);\n        }\n        if(resultMap.size()==0) {\n            // log(\"All hits matched\");\n        } else {\n        log(\"Couldn't match \"+resultMap.size()+\" hits.\");\n        }\n        assertEquals(resultMap.size(), 0);\n\t}\n\n","sourceOld":"\t// make sure the documents returned by the search match the expected list\n\tprivate void matchHits (Searcher searcher, Sort sort)\n\tthrows IOException {\n\t    // make a query without sorting first\n\t\tHits hitsByRank = searcher.search(query);\n\t\tcheckHits(hitsByRank, \"Sort by rank: \"); // check for duplicates\n        Map resultMap = new TreeMap();\n        // store hits in TreeMap - TreeMap does not allow duplicates; existing entries are silently overwritten\n        for(int hitid=0;hitid<hitsByRank.length(); ++hitid) {\n            resultMap.put(\n                    new Integer(hitsByRank.id(hitid)),  // Key:   Lucene Document ID\n                    new Integer(hitid));\t\t\t\t// Value: Hits-Objekt Index\n        }\n        \n        // now make a query using the sort criteria\n\t\tHits resultSort = searcher.search (query, sort);\n\t\tcheckHits(resultSort, \"Sort by custom criteria: \"); // check for duplicates\n\t\t\n        String lf = System.getProperty(\"line.separator\", \"\\n\");\n        // besides the sorting both sets of hits must be identical\n        for(int hitid=0;hitid<resultSort.length(); ++hitid) {\n            Integer idHitDate = new Integer(resultSort.id(hitid)); // document ID from sorted search\n            if(!resultMap.containsKey(idHitDate)) {\n                log(\"ID \"+idHitDate+\" not found. Possibliy a duplicate.\");\n            }\n            assertTrue(resultMap.containsKey(idHitDate)); // same ID must be in the Map from the rank-sorted search\n            // every hit must appear once in both result sets --> remove it from the Map.\n            // At the end the Map must be empty!\n            resultMap.remove(idHitDate);\n        }\n        if(resultMap.size()==0) {\n            // log(\"All hits matched\");\n        } else {\n        log(\"Couldn't match \"+resultMap.size()+\" hits.\");\n        }\n        assertEquals(resultMap.size(), 0);\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb1066f2afe9450585d0d10063ea4450085236f1","date":1233870820,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/TestCustomSearcherSort#matchHits(Searcher,Sort).mjava","pathOld":"src/test/org/apache/lucene/search/TestCustomSearcherSort#matchHits(Searcher,Sort).mjava","sourceNew":"\t// make sure the documents returned by the search match the expected list\n\tprivate void matchHits (Searcher searcher, Sort sort)\n\tthrows IOException {\n\t    // make a query without sorting first\n    ScoreDoc[] hitsByRank = searcher.search(query, null, 1000).scoreDocs;\n\t\tcheckHits(hitsByRank, \"Sort by rank: \"); // check for duplicates\n        Map resultMap = new TreeMap();\n        // store hits in TreeMap - TreeMap does not allow duplicates; existing entries are silently overwritten\n        for(int hitid=0;hitid<hitsByRank.length; ++hitid) {\n            resultMap.put(\n                    new Integer(hitsByRank[hitid].doc),  // Key:   Lucene Document ID\n                    new Integer(hitid));\t\t\t\t// Value: Hits-Objekt Index\n        }\n        \n        // now make a query using the sort criteria\n    ScoreDoc[] resultSort = searcher.search (query, null, 1000, sort).scoreDocs;\n\t\tcheckHits(resultSort, \"Sort by custom criteria: \"); // check for duplicates\n\t\t\n        // besides the sorting both sets of hits must be identical\n        for(int hitid=0;hitid<resultSort.length; ++hitid) {\n            Integer idHitDate = new Integer(resultSort[hitid].doc); // document ID from sorted search\n            if(!resultMap.containsKey(idHitDate)) {\n                log(\"ID \"+idHitDate+\" not found. Possibliy a duplicate.\");\n            }\n            assertTrue(resultMap.containsKey(idHitDate)); // same ID must be in the Map from the rank-sorted search\n            // every hit must appear once in both result sets --> remove it from the Map.\n            // At the end the Map must be empty!\n            resultMap.remove(idHitDate);\n        }\n        if(resultMap.size()==0) {\n            // log(\"All hits matched\");\n        } else {\n        log(\"Couldn't match \"+resultMap.size()+\" hits.\");\n        }\n        assertEquals(resultMap.size(), 0);\n\t}\n\n","sourceOld":"\t// make sure the documents returned by the search match the expected list\n\tprivate void matchHits (Searcher searcher, Sort sort)\n\tthrows IOException {\n\t    // make a query without sorting first\n    ScoreDoc[] hitsByRank = searcher.search(query, null, 1000).scoreDocs;\n\t\tcheckHits(hitsByRank, \"Sort by rank: \"); // check for duplicates\n        Map resultMap = new TreeMap();\n        // store hits in TreeMap - TreeMap does not allow duplicates; existing entries are silently overwritten\n        for(int hitid=0;hitid<hitsByRank.length; ++hitid) {\n            resultMap.put(\n                    new Integer(hitsByRank[hitid].doc),  // Key:   Lucene Document ID\n                    new Integer(hitid));\t\t\t\t// Value: Hits-Objekt Index\n        }\n        \n        // now make a query using the sort criteria\n    ScoreDoc[] resultSort = searcher.search (query, null, 1000, sort).scoreDocs;\n\t\tcheckHits(resultSort, \"Sort by custom criteria: \"); // check for duplicates\n\t\t\n        String lf = System.getProperty(\"line.separator\", \"\\n\");\n        // besides the sorting both sets of hits must be identical\n        for(int hitid=0;hitid<resultSort.length; ++hitid) {\n            Integer idHitDate = new Integer(resultSort[hitid].doc); // document ID from sorted search\n            if(!resultMap.containsKey(idHitDate)) {\n                log(\"ID \"+idHitDate+\" not found. Possibliy a duplicate.\");\n            }\n            assertTrue(resultMap.containsKey(idHitDate)); // same ID must be in the Map from the rank-sorted search\n            // every hit must appear once in both result sets --> remove it from the Map.\n            // At the end the Map must be empty!\n            resultMap.remove(idHitDate);\n        }\n        if(resultMap.size()==0) {\n            // log(\"All hits matched\");\n        } else {\n        log(\"Couldn't match \"+resultMap.size()+\" hits.\");\n        }\n        assertEquals(resultMap.size(), 0);\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bcde5e3f23911110baa101ed062b544162825b5","date":1254521804,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/TestCustomSearcherSort#matchHits(Searcher,Sort).mjava","pathOld":"src/test/org/apache/lucene/search/TestCustomSearcherSort#matchHits(Searcher,Sort).mjava","sourceNew":"\t// make sure the documents returned by the search match the expected list\n\tprivate void matchHits (Searcher searcher, Sort sort)\n\tthrows IOException {\n\t    // make a query without sorting first\n    ScoreDoc[] hitsByRank = searcher.search(query, null, 1000).scoreDocs;\n\t\tcheckHits(hitsByRank, \"Sort by rank: \"); // check for duplicates\n        Map resultMap = new TreeMap();\n        // store hits in TreeMap - TreeMap does not allow duplicates; existing entries are silently overwritten\n        for(int hitid=0;hitid<hitsByRank.length; ++hitid) {\n            resultMap.put(\n                    Integer.valueOf(hitsByRank[hitid].doc),  // Key:   Lucene Document ID\n                    Integer.valueOf(hitid));\t\t\t\t// Value: Hits-Objekt Index\n        }\n        \n        // now make a query using the sort criteria\n    ScoreDoc[] resultSort = searcher.search (query, null, 1000, sort).scoreDocs;\n\t\tcheckHits(resultSort, \"Sort by custom criteria: \"); // check for duplicates\n\t\t\n        // besides the sorting both sets of hits must be identical\n        for(int hitid=0;hitid<resultSort.length; ++hitid) {\n            Integer idHitDate = Integer.valueOf(resultSort[hitid].doc); // document ID from sorted search\n            if(!resultMap.containsKey(idHitDate)) {\n                log(\"ID \"+idHitDate+\" not found. Possibliy a duplicate.\");\n            }\n            assertTrue(resultMap.containsKey(idHitDate)); // same ID must be in the Map from the rank-sorted search\n            // every hit must appear once in both result sets --> remove it from the Map.\n            // At the end the Map must be empty!\n            resultMap.remove(idHitDate);\n        }\n        if(resultMap.size()==0) {\n            // log(\"All hits matched\");\n        } else {\n        log(\"Couldn't match \"+resultMap.size()+\" hits.\");\n        }\n        assertEquals(resultMap.size(), 0);\n\t}\n\n","sourceOld":"\t// make sure the documents returned by the search match the expected list\n\tprivate void matchHits (Searcher searcher, Sort sort)\n\tthrows IOException {\n\t    // make a query without sorting first\n    ScoreDoc[] hitsByRank = searcher.search(query, null, 1000).scoreDocs;\n\t\tcheckHits(hitsByRank, \"Sort by rank: \"); // check for duplicates\n        Map resultMap = new TreeMap();\n        // store hits in TreeMap - TreeMap does not allow duplicates; existing entries are silently overwritten\n        for(int hitid=0;hitid<hitsByRank.length; ++hitid) {\n            resultMap.put(\n                    new Integer(hitsByRank[hitid].doc),  // Key:   Lucene Document ID\n                    new Integer(hitid));\t\t\t\t// Value: Hits-Objekt Index\n        }\n        \n        // now make a query using the sort criteria\n    ScoreDoc[] resultSort = searcher.search (query, null, 1000, sort).scoreDocs;\n\t\tcheckHits(resultSort, \"Sort by custom criteria: \"); // check for duplicates\n\t\t\n        // besides the sorting both sets of hits must be identical\n        for(int hitid=0;hitid<resultSort.length; ++hitid) {\n            Integer idHitDate = new Integer(resultSort[hitid].doc); // document ID from sorted search\n            if(!resultMap.containsKey(idHitDate)) {\n                log(\"ID \"+idHitDate+\" not found. Possibliy a duplicate.\");\n            }\n            assertTrue(resultMap.containsKey(idHitDate)); // same ID must be in the Map from the rank-sorted search\n            // every hit must appear once in both result sets --> remove it from the Map.\n            // At the end the Map must be empty!\n            resultMap.remove(idHitDate);\n        }\n        if(resultMap.size()==0) {\n            // log(\"All hits matched\");\n        } else {\n        log(\"Couldn't match \"+resultMap.size()+\" hits.\");\n        }\n        assertEquals(resultMap.size(), 0);\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1326054a8d3aa66382d49decc7f330955c9c6f71","date":1257386139,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/TestCustomSearcherSort#matchHits(Searcher,Sort).mjava","pathOld":"src/test/org/apache/lucene/search/TestCustomSearcherSort#matchHits(Searcher,Sort).mjava","sourceNew":"  // make sure the documents returned by the search match the expected list\n  private void matchHits (Searcher searcher, Sort sort)\n  throws IOException {\n      // make a query without sorting first\n    ScoreDoc[] hitsByRank = searcher.search(query, null, 1000).scoreDocs;\n    checkHits(hitsByRank, \"Sort by rank: \"); // check for duplicates\n        Map resultMap = new TreeMap();\n        // store hits in TreeMap - TreeMap does not allow duplicates; existing entries are silently overwritten\n        for(int hitid=0;hitid<hitsByRank.length; ++hitid) {\n            resultMap.put(\n                    Integer.valueOf(hitsByRank[hitid].doc),  // Key:   Lucene Document ID\n                    Integer.valueOf(hitid));\t\t\t\t// Value: Hits-Objekt Index\n        }\n        \n        // now make a query using the sort criteria\n    ScoreDoc[] resultSort = searcher.search (query, null, 1000, sort).scoreDocs;\n    checkHits(resultSort, \"Sort by custom criteria: \"); // check for duplicates\n    \n        // besides the sorting both sets of hits must be identical\n        for(int hitid=0;hitid<resultSort.length; ++hitid) {\n            Integer idHitDate = Integer.valueOf(resultSort[hitid].doc); // document ID from sorted search\n            if(!resultMap.containsKey(idHitDate)) {\n                log(\"ID \"+idHitDate+\" not found. Possibliy a duplicate.\");\n            }\n            assertTrue(resultMap.containsKey(idHitDate)); // same ID must be in the Map from the rank-sorted search\n            // every hit must appear once in both result sets --> remove it from the Map.\n            // At the end the Map must be empty!\n            resultMap.remove(idHitDate);\n        }\n        if(resultMap.size()==0) {\n            // log(\"All hits matched\");\n        } else {\n        log(\"Couldn't match \"+resultMap.size()+\" hits.\");\n        }\n        assertEquals(resultMap.size(), 0);\n  }\n\n","sourceOld":"\t// make sure the documents returned by the search match the expected list\n\tprivate void matchHits (Searcher searcher, Sort sort)\n\tthrows IOException {\n\t    // make a query without sorting first\n    ScoreDoc[] hitsByRank = searcher.search(query, null, 1000).scoreDocs;\n\t\tcheckHits(hitsByRank, \"Sort by rank: \"); // check for duplicates\n        Map resultMap = new TreeMap();\n        // store hits in TreeMap - TreeMap does not allow duplicates; existing entries are silently overwritten\n        for(int hitid=0;hitid<hitsByRank.length; ++hitid) {\n            resultMap.put(\n                    Integer.valueOf(hitsByRank[hitid].doc),  // Key:   Lucene Document ID\n                    Integer.valueOf(hitid));\t\t\t\t// Value: Hits-Objekt Index\n        }\n        \n        // now make a query using the sort criteria\n    ScoreDoc[] resultSort = searcher.search (query, null, 1000, sort).scoreDocs;\n\t\tcheckHits(resultSort, \"Sort by custom criteria: \"); // check for duplicates\n\t\t\n        // besides the sorting both sets of hits must be identical\n        for(int hitid=0;hitid<resultSort.length; ++hitid) {\n            Integer idHitDate = Integer.valueOf(resultSort[hitid].doc); // document ID from sorted search\n            if(!resultMap.containsKey(idHitDate)) {\n                log(\"ID \"+idHitDate+\" not found. Possibliy a duplicate.\");\n            }\n            assertTrue(resultMap.containsKey(idHitDate)); // same ID must be in the Map from the rank-sorted search\n            // every hit must appear once in both result sets --> remove it from the Map.\n            // At the end the Map must be empty!\n            resultMap.remove(idHitDate);\n        }\n        if(resultMap.size()==0) {\n            // log(\"All hits matched\");\n        } else {\n        log(\"Couldn't match \"+resultMap.size()+\" hits.\");\n        }\n        assertEquals(resultMap.size(), 0);\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e450c7d50c2fc84c963d0d7ade9d3217d868064d","date":1259932067,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/TestCustomSearcherSort#matchHits(Searcher,Sort).mjava","pathOld":"src/test/org/apache/lucene/search/TestCustomSearcherSort#matchHits(Searcher,Sort).mjava","sourceNew":"  // make sure the documents returned by the search match the expected list\n  private void matchHits (Searcher searcher, Sort sort)\n  throws IOException {\n      // make a query without sorting first\n    ScoreDoc[] hitsByRank = searcher.search(query, null, 1000).scoreDocs;\n    checkHits(hitsByRank, \"Sort by rank: \"); // check for duplicates\n        Map<Integer,Integer> resultMap = new TreeMap<Integer,Integer>();\n        // store hits in TreeMap - TreeMap does not allow duplicates; existing entries are silently overwritten\n        for(int hitid=0;hitid<hitsByRank.length; ++hitid) {\n            resultMap.put(\n                    Integer.valueOf(hitsByRank[hitid].doc),  // Key:   Lucene Document ID\n                    Integer.valueOf(hitid));\t\t\t\t// Value: Hits-Objekt Index\n        }\n        \n        // now make a query using the sort criteria\n    ScoreDoc[] resultSort = searcher.search (query, null, 1000, sort).scoreDocs;\n    checkHits(resultSort, \"Sort by custom criteria: \"); // check for duplicates\n    \n        // besides the sorting both sets of hits must be identical\n        for(int hitid=0;hitid<resultSort.length; ++hitid) {\n            Integer idHitDate = Integer.valueOf(resultSort[hitid].doc); // document ID from sorted search\n            if(!resultMap.containsKey(idHitDate)) {\n                log(\"ID \"+idHitDate+\" not found. Possibliy a duplicate.\");\n            }\n            assertTrue(resultMap.containsKey(idHitDate)); // same ID must be in the Map from the rank-sorted search\n            // every hit must appear once in both result sets --> remove it from the Map.\n            // At the end the Map must be empty!\n            resultMap.remove(idHitDate);\n        }\n        if(resultMap.size()==0) {\n            // log(\"All hits matched\");\n        } else {\n        log(\"Couldn't match \"+resultMap.size()+\" hits.\");\n        }\n        assertEquals(resultMap.size(), 0);\n  }\n\n","sourceOld":"  // make sure the documents returned by the search match the expected list\n  private void matchHits (Searcher searcher, Sort sort)\n  throws IOException {\n      // make a query without sorting first\n    ScoreDoc[] hitsByRank = searcher.search(query, null, 1000).scoreDocs;\n    checkHits(hitsByRank, \"Sort by rank: \"); // check for duplicates\n        Map resultMap = new TreeMap();\n        // store hits in TreeMap - TreeMap does not allow duplicates; existing entries are silently overwritten\n        for(int hitid=0;hitid<hitsByRank.length; ++hitid) {\n            resultMap.put(\n                    Integer.valueOf(hitsByRank[hitid].doc),  // Key:   Lucene Document ID\n                    Integer.valueOf(hitid));\t\t\t\t// Value: Hits-Objekt Index\n        }\n        \n        // now make a query using the sort criteria\n    ScoreDoc[] resultSort = searcher.search (query, null, 1000, sort).scoreDocs;\n    checkHits(resultSort, \"Sort by custom criteria: \"); // check for duplicates\n    \n        // besides the sorting both sets of hits must be identical\n        for(int hitid=0;hitid<resultSort.length; ++hitid) {\n            Integer idHitDate = Integer.valueOf(resultSort[hitid].doc); // document ID from sorted search\n            if(!resultMap.containsKey(idHitDate)) {\n                log(\"ID \"+idHitDate+\" not found. Possibliy a duplicate.\");\n            }\n            assertTrue(resultMap.containsKey(idHitDate)); // same ID must be in the Map from the rank-sorted search\n            // every hit must appear once in both result sets --> remove it from the Map.\n            // At the end the Map must be empty!\n            resultMap.remove(idHitDate);\n        }\n        if(resultMap.size()==0) {\n            // log(\"All hits matched\");\n        } else {\n        log(\"Couldn't match \"+resultMap.size()+\" hits.\");\n        }\n        assertEquals(resultMap.size(), 0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestCustomSearcherSort#matchHits(Searcher,Sort).mjava","pathOld":"src/test/org/apache/lucene/search/TestCustomSearcherSort#matchHits(Searcher,Sort).mjava","sourceNew":"  // make sure the documents returned by the search match the expected list\n  private void matchHits (Searcher searcher, Sort sort)\n  throws IOException {\n      // make a query without sorting first\n    ScoreDoc[] hitsByRank = searcher.search(query, null, 1000).scoreDocs;\n    checkHits(hitsByRank, \"Sort by rank: \"); // check for duplicates\n        Map<Integer,Integer> resultMap = new TreeMap<Integer,Integer>();\n        // store hits in TreeMap - TreeMap does not allow duplicates; existing entries are silently overwritten\n        for(int hitid=0;hitid<hitsByRank.length; ++hitid) {\n            resultMap.put(\n                    Integer.valueOf(hitsByRank[hitid].doc),  // Key:   Lucene Document ID\n                    Integer.valueOf(hitid));\t\t\t\t// Value: Hits-Objekt Index\n        }\n        \n        // now make a query using the sort criteria\n    ScoreDoc[] resultSort = searcher.search (query, null, 1000, sort).scoreDocs;\n    checkHits(resultSort, \"Sort by custom criteria: \"); // check for duplicates\n    \n        // besides the sorting both sets of hits must be identical\n        for(int hitid=0;hitid<resultSort.length; ++hitid) {\n            Integer idHitDate = Integer.valueOf(resultSort[hitid].doc); // document ID from sorted search\n            if(!resultMap.containsKey(idHitDate)) {\n                log(\"ID \"+idHitDate+\" not found. Possibliy a duplicate.\");\n            }\n            assertTrue(resultMap.containsKey(idHitDate)); // same ID must be in the Map from the rank-sorted search\n            // every hit must appear once in both result sets --> remove it from the Map.\n            // At the end the Map must be empty!\n            resultMap.remove(idHitDate);\n        }\n        if(resultMap.size()==0) {\n            // log(\"All hits matched\");\n        } else {\n        log(\"Couldn't match \"+resultMap.size()+\" hits.\");\n        }\n        assertEquals(resultMap.size(), 0);\n  }\n\n","sourceOld":"  // make sure the documents returned by the search match the expected list\n  private void matchHits (Searcher searcher, Sort sort)\n  throws IOException {\n      // make a query without sorting first\n    ScoreDoc[] hitsByRank = searcher.search(query, null, 1000).scoreDocs;\n    checkHits(hitsByRank, \"Sort by rank: \"); // check for duplicates\n        Map<Integer,Integer> resultMap = new TreeMap<Integer,Integer>();\n        // store hits in TreeMap - TreeMap does not allow duplicates; existing entries are silently overwritten\n        for(int hitid=0;hitid<hitsByRank.length; ++hitid) {\n            resultMap.put(\n                    Integer.valueOf(hitsByRank[hitid].doc),  // Key:   Lucene Document ID\n                    Integer.valueOf(hitid));\t\t\t\t// Value: Hits-Objekt Index\n        }\n        \n        // now make a query using the sort criteria\n    ScoreDoc[] resultSort = searcher.search (query, null, 1000, sort).scoreDocs;\n    checkHits(resultSort, \"Sort by custom criteria: \"); // check for duplicates\n    \n        // besides the sorting both sets of hits must be identical\n        for(int hitid=0;hitid<resultSort.length; ++hitid) {\n            Integer idHitDate = Integer.valueOf(resultSort[hitid].doc); // document ID from sorted search\n            if(!resultMap.containsKey(idHitDate)) {\n                log(\"ID \"+idHitDate+\" not found. Possibliy a duplicate.\");\n            }\n            assertTrue(resultMap.containsKey(idHitDate)); // same ID must be in the Map from the rank-sorted search\n            // every hit must appear once in both result sets --> remove it from the Map.\n            // At the end the Map must be empty!\n            resultMap.remove(idHitDate);\n        }\n        if(resultMap.size()==0) {\n            // log(\"All hits matched\");\n        } else {\n        log(\"Couldn't match \"+resultMap.size()+\" hits.\");\n        }\n        assertEquals(resultMap.size(), 0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1326054a8d3aa66382d49decc7f330955c9c6f71":["6bcde5e3f23911110baa101ed062b544162825b5"],"6bcde5e3f23911110baa101ed062b544162825b5":["cb1066f2afe9450585d0d10063ea4450085236f1"],"cb1066f2afe9450585d0d10063ea4450085236f1":["5af07783dbc171e26a694c4f7d735e30c2769faa"],"4d4707b60e1780a8b3e3d4a8fda80126e889deb5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2123bddbd65dea198cac380540636ce43a880403":["77aeeb67c242aab2046ab501c4fa482c92f124d7"],"5af07783dbc171e26a694c4f7d735e30c2769faa":["2123bddbd65dea198cac380540636ce43a880403"],"77aeeb67c242aab2046ab501c4fa482c92f124d7":["4d4707b60e1780a8b3e3d4a8fda80126e889deb5"],"e450c7d50c2fc84c963d0d7ade9d3217d868064d":["1326054a8d3aa66382d49decc7f330955c9c6f71"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["e450c7d50c2fc84c963d0d7ade9d3217d868064d"]},"commit2Childs":{"1326054a8d3aa66382d49decc7f330955c9c6f71":["e450c7d50c2fc84c963d0d7ade9d3217d868064d"],"6bcde5e3f23911110baa101ed062b544162825b5":["1326054a8d3aa66382d49decc7f330955c9c6f71"],"cb1066f2afe9450585d0d10063ea4450085236f1":["6bcde5e3f23911110baa101ed062b544162825b5"],"4d4707b60e1780a8b3e3d4a8fda80126e889deb5":["77aeeb67c242aab2046ab501c4fa482c92f124d7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4d4707b60e1780a8b3e3d4a8fda80126e889deb5"],"2123bddbd65dea198cac380540636ce43a880403":["5af07783dbc171e26a694c4f7d735e30c2769faa"],"5af07783dbc171e26a694c4f7d735e30c2769faa":["cb1066f2afe9450585d0d10063ea4450085236f1"],"77aeeb67c242aab2046ab501c4fa482c92f124d7":["2123bddbd65dea198cac380540636ce43a880403"],"e450c7d50c2fc84c963d0d7ade9d3217d868064d":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}