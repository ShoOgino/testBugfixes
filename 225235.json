{"path":"lucene/core/src/java/org/apache/lucene/store/ByteBufferIndexInput#buildSlice(long,long).mjava","commits":[{"id":"4e5e734869d76c22acfc12bc53ecbfcc1606c2f5","date":1347072117,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/ByteBufferIndexInput#buildSlice(long,long).mjava","pathOld":"/dev/null","sourceNew":"  private ByteBufferIndexInput buildSlice(long offset, long length) {\n    if (buffers == null) {\n      throw new AlreadyClosedException(\"Already closed: \" + this);\n    }\n    if (offset < 0 || length < 0 || offset+length > this.length) {\n      throw new IllegalArgumentException(\"slice() \" + sliceDescription + \" out of bounds: offset=\" + offset + \",length=\" + length + \",fileLength=\"  + this.length + \": \"  + this);\n    }\n    \n    // include our own offset into the final offset:\n    offset += this.offset;\n    \n    final ByteBufferIndexInput clone = (ByteBufferIndexInput)super.clone();\n    clone.isClone = true;\n    // we keep clone.clones, so it shares the same map with original and we have no additional cost on clones\n    assert clone.clones == this.clones;\n    clone.buffers = buildSlice(buffers, offset, length);\n    clone.offset = (int) (offset & chunkSizeMask);\n    clone.length = length;\n\n    // register the new clone in our clone list to clean it up on closing:\n    this.clones.put(clone, Boolean.TRUE);\n    \n    return clone;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["55d81732702acdcf369ac1e8077a9d11a2559f67"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55d81732702acdcf369ac1e8077a9d11a2559f67","date":1359801354,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/ByteBufferIndexInput#buildSlice(long,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/ByteBufferIndexInput#buildSlice(long,long).mjava","sourceNew":"  private ByteBufferIndexInput buildSlice(long offset, long length) {\n    if (buffers == null) {\n      throw new AlreadyClosedException(\"Already closed: \" + this);\n    }\n    if (offset < 0 || length < 0 || offset+length > this.length) {\n      throw new IllegalArgumentException(\"slice() \" + sliceDescription + \" out of bounds: offset=\" + offset + \",length=\" + length + \",fileLength=\"  + this.length + \": \"  + this);\n    }\n    \n    // include our own offset into the final offset:\n    offset += this.offset;\n    \n    final ByteBufferIndexInput clone = (ByteBufferIndexInput)super.clone();\n    clone.isClone = true;\n    // we keep clone.clones, so it shares the same map with original and we have no additional cost on clones\n    assert clone.clones == this.clones;\n    clone.buffers = buildSlice(buffers, offset, length);\n    clone.offset = (int) (offset & chunkSizeMask);\n    clone.length = length;\n\n    // register the new clone in our clone list to clean it up on closing:\n    if (clones != null) {\n      this.clones.put(clone, Boolean.TRUE);\n    }\n    \n    return clone;\n  }\n\n","sourceOld":"  private ByteBufferIndexInput buildSlice(long offset, long length) {\n    if (buffers == null) {\n      throw new AlreadyClosedException(\"Already closed: \" + this);\n    }\n    if (offset < 0 || length < 0 || offset+length > this.length) {\n      throw new IllegalArgumentException(\"slice() \" + sliceDescription + \" out of bounds: offset=\" + offset + \",length=\" + length + \",fileLength=\"  + this.length + \": \"  + this);\n    }\n    \n    // include our own offset into the final offset:\n    offset += this.offset;\n    \n    final ByteBufferIndexInput clone = (ByteBufferIndexInput)super.clone();\n    clone.isClone = true;\n    // we keep clone.clones, so it shares the same map with original and we have no additional cost on clones\n    assert clone.clones == this.clones;\n    clone.buffers = buildSlice(buffers, offset, length);\n    clone.offset = (int) (offset & chunkSizeMask);\n    clone.length = length;\n\n    // register the new clone in our clone list to clean it up on closing:\n    this.clones.put(clone, Boolean.TRUE);\n    \n    return clone;\n  }\n\n","bugFix":["4e5e734869d76c22acfc12bc53ecbfcc1606c2f5"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eb97a913498e2387924cb19fb8be9a95daf6f38a","date":1359823388,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/ByteBufferIndexInput#buildSlice(long,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/ByteBufferIndexInput#buildSlice(long,long).mjava","sourceNew":"  private ByteBufferIndexInput buildSlice(long offset, long length) {\n    if (buffers == null) {\n      throw new AlreadyClosedException(\"Already closed: \" + this);\n    }\n    if (offset < 0 || length < 0 || offset+length > this.length) {\n      throw new IllegalArgumentException(\"slice() \" + sliceDescription + \" out of bounds: offset=\" + offset + \",length=\" + length + \",fileLength=\"  + this.length + \": \"  + this);\n    }\n    \n    // include our own offset into the final offset:\n    offset += this.offset;\n    \n    final ByteBufferIndexInput clone = (ByteBufferIndexInput)super.clone();\n    clone.isClone = true;\n    // we keep clone.clones, so it shares the same map with original and we have no additional cost on clones\n    assert clone.clones == this.clones;\n    clone.buffers = buildSlice(buffers, offset, length);\n    clone.offset = (int) (offset & chunkSizeMask);\n    clone.length = length;\n\n    // register the new clone in our clone list to clean it up on closing:\n    if (clones != null) {\n      this.clones.put(clone, Boolean.TRUE);\n    }\n    \n    return clone;\n  }\n\n","sourceOld":"  private ByteBufferIndexInput buildSlice(long offset, long length) {\n    if (buffers == null) {\n      throw new AlreadyClosedException(\"Already closed: \" + this);\n    }\n    if (offset < 0 || length < 0 || offset+length > this.length) {\n      throw new IllegalArgumentException(\"slice() \" + sliceDescription + \" out of bounds: offset=\" + offset + \",length=\" + length + \",fileLength=\"  + this.length + \": \"  + this);\n    }\n    \n    // include our own offset into the final offset:\n    offset += this.offset;\n    \n    final ByteBufferIndexInput clone = (ByteBufferIndexInput)super.clone();\n    clone.isClone = true;\n    // we keep clone.clones, so it shares the same map with original and we have no additional cost on clones\n    assert clone.clones == this.clones;\n    clone.buffers = buildSlice(buffers, offset, length);\n    clone.offset = (int) (offset & chunkSizeMask);\n    clone.length = length;\n\n    // register the new clone in our clone list to clean it up on closing:\n    this.clones.put(clone, Boolean.TRUE);\n    \n    return clone;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d930518685c8546474147d14ea1a67e8159a0e4","date":1401716142,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/ByteBufferIndexInput#buildSlice(long,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/ByteBufferIndexInput#buildSlice(long,long).mjava","sourceNew":"  private ByteBufferIndexInput buildSlice(long offset, long length) {\n    if (buffers == null) {\n      throw new AlreadyClosedException(\"Already closed: \" + this);\n    }\n    if (offset < 0 || length < 0 || offset+length > this.length) {\n      throw new IllegalArgumentException(\"slice() \" + sliceDescription + \" out of bounds: offset=\" + offset + \",length=\" + length + \",fileLength=\"  + this.length + \": \"  + this);\n    }\n    \n    // include our own offset into the final offset:\n    offset += this.offset;\n    \n    final ByteBufferIndexInput clone = (ByteBufferIndexInput)super.clone();\n    clone.isClone = true;\n    // we keep clone.clones, so it shares the same map with original and we have no additional cost on clones\n    assert clone.clones == this.clones;\n    clone.buffers = buildSlice(buffers, offset, length);\n    clone.offset = (int) (offset & chunkSizeMask);\n    clone.length = length;\n    clone.curBufIndex = -1;\n\n    // register the new clone in our clone list to clean it up on closing:\n    if (clones != null) {\n      this.clones.put(clone, Boolean.TRUE);\n    }\n    \n    return clone;\n  }\n\n","sourceOld":"  private ByteBufferIndexInput buildSlice(long offset, long length) {\n    if (buffers == null) {\n      throw new AlreadyClosedException(\"Already closed: \" + this);\n    }\n    if (offset < 0 || length < 0 || offset+length > this.length) {\n      throw new IllegalArgumentException(\"slice() \" + sliceDescription + \" out of bounds: offset=\" + offset + \",length=\" + length + \",fileLength=\"  + this.length + \": \"  + this);\n    }\n    \n    // include our own offset into the final offset:\n    offset += this.offset;\n    \n    final ByteBufferIndexInput clone = (ByteBufferIndexInput)super.clone();\n    clone.isClone = true;\n    // we keep clone.clones, so it shares the same map with original and we have no additional cost on clones\n    assert clone.clones == this.clones;\n    clone.buffers = buildSlice(buffers, offset, length);\n    clone.offset = (int) (offset & chunkSizeMask);\n    clone.length = length;\n\n    // register the new clone in our clone list to clean it up on closing:\n    if (clones != null) {\n      this.clones.put(clone, Boolean.TRUE);\n    }\n    \n    return clone;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f986320666d675a260eb4529a0c3c40595731441","date":1401729997,"type":4,"author":"Uwe Schindler","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/store/ByteBufferIndexInput#buildSlice(long,long).mjava","sourceNew":null,"sourceOld":"  private ByteBufferIndexInput buildSlice(long offset, long length) {\n    if (buffers == null) {\n      throw new AlreadyClosedException(\"Already closed: \" + this);\n    }\n    if (offset < 0 || length < 0 || offset+length > this.length) {\n      throw new IllegalArgumentException(\"slice() \" + sliceDescription + \" out of bounds: offset=\" + offset + \",length=\" + length + \",fileLength=\"  + this.length + \": \"  + this);\n    }\n    \n    // include our own offset into the final offset:\n    offset += this.offset;\n    \n    final ByteBufferIndexInput clone = (ByteBufferIndexInput)super.clone();\n    clone.isClone = true;\n    // we keep clone.clones, so it shares the same map with original and we have no additional cost on clones\n    assert clone.clones == this.clones;\n    clone.buffers = buildSlice(buffers, offset, length);\n    clone.offset = (int) (offset & chunkSizeMask);\n    clone.length = length;\n    clone.curBufIndex = -1;\n\n    // register the new clone in our clone list to clean it up on closing:\n    if (clones != null) {\n      this.clones.put(clone, Boolean.TRUE);\n    }\n    \n    return clone;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4e5e734869d76c22acfc12bc53ecbfcc1606c2f5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"eb97a913498e2387924cb19fb8be9a95daf6f38a":["4e5e734869d76c22acfc12bc53ecbfcc1606c2f5","55d81732702acdcf369ac1e8077a9d11a2559f67"],"f986320666d675a260eb4529a0c3c40595731441":["0d930518685c8546474147d14ea1a67e8159a0e4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0d930518685c8546474147d14ea1a67e8159a0e4":["55d81732702acdcf369ac1e8077a9d11a2559f67"],"55d81732702acdcf369ac1e8077a9d11a2559f67":["4e5e734869d76c22acfc12bc53ecbfcc1606c2f5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f986320666d675a260eb4529a0c3c40595731441"]},"commit2Childs":{"4e5e734869d76c22acfc12bc53ecbfcc1606c2f5":["eb97a913498e2387924cb19fb8be9a95daf6f38a","55d81732702acdcf369ac1e8077a9d11a2559f67"],"eb97a913498e2387924cb19fb8be9a95daf6f38a":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4e5e734869d76c22acfc12bc53ecbfcc1606c2f5"],"f986320666d675a260eb4529a0c3c40595731441":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0d930518685c8546474147d14ea1a67e8159a0e4":["f986320666d675a260eb4529a0c3c40595731441"],"55d81732702acdcf369ac1e8077a9d11a2559f67":["eb97a913498e2387924cb19fb8be9a95daf6f38a","0d930518685c8546474147d14ea1a67e8159a0e4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["eb97a913498e2387924cb19fb8be9a95daf6f38a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}