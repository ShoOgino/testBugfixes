{"path":"lucene/core/src/test/org/apache/lucene/index/TestDemoParallelLeafReader.ReindexingReader#pruneOldSegments(boolean).mjava","commits":[{"id":"4d9aa91d3fdd25528bac3b2e6115d54fc2f28753","date":1416999434,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDemoParallelLeafReader.ReindexingReader#pruneOldSegments(boolean).mjava","pathOld":"/dev/null","sourceNew":"    /** Removes the parallel index that are no longer in the last commit point.  We can't\n     *  remove this when the parallel reader is closed because it may still be referenced by\n     *  the last commit. */\n    private void pruneOldSegments(boolean removeOldGens) throws IOException {\n      SegmentInfos lastCommit = SegmentInfos.readLatestCommit(indexDir);\n      if (DEBUG) System.out.println(\"TEST: prune\");\n\n      Set<String> liveIDs = new HashSet<String>();\n      for(SegmentCommitInfo info : lastCommit) {\n        String idString = StringHelper.idToString(info.info.getId());\n        liveIDs.add(idString);\n      }\n\n      long currentSchemaGen = getCurrentSchemaGen();\n\n      if (Files.exists(segsPath)) {\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(segsPath)) {\n            for (Path path : stream) {\n              if (Files.isDirectory(path)) {\n                SegmentIDAndGen segIDGen = new SegmentIDAndGen(path.getFileName().toString());\n                assert segIDGen.schemaGen <= currentSchemaGen;\n                if (liveIDs.contains(segIDGen.segID) == false && (closedSegments.contains(segIDGen) || (removeOldGens && segIDGen.schemaGen < currentSchemaGen))) {\n                  if (DEBUG) System.out.println(\"TEST: remove \" + segIDGen);\n                  try {\n                    IOUtils.rm(path);\n                    closedSegments.remove(segIDGen);\n                  } catch (IOException ioe) {\n                    // OK, we'll retry later\n                    if (DEBUG) System.out.println(\"TEST: ignore ioe during delete \" + path + \":\" + ioe);\n                  }\n                }\n              }\n            }\n          }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"22989c36ff05c657df26dd3377b37c9ad35859bc","date":1424477375,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDemoParallelLeafReader.ReindexingReader#pruneOldSegments(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDemoParallelLeafReader.ReindexingReader#pruneOldSegments(boolean).mjava","sourceNew":"    /** Removes the parallel index that are no longer in the last commit point.  We can't\n     *  remove this when the parallel reader is closed because it may still be referenced by\n     *  the last commit. */\n    private void pruneOldSegments(boolean removeOldGens) throws IOException {\n      SegmentInfos lastCommit = SegmentInfos.readLatestCommit(indexDir);\n      if (DEBUG) System.out.println(\"TEST: prune\");\n\n      Set<String> liveIDs = new HashSet<String>();\n      for(SegmentCommitInfo info : lastCommit) {\n        String idString = StringHelper.idToString(info.info.getId());\n        liveIDs.add(idString);\n      }\n\n      long currentSchemaGen = getCurrentSchemaGen();\n\n      if (Files.exists(segsPath)) {\n        for (Path path : segSubDirs(segsPath)) {\n          if (Files.isDirectory(path)) {\n            SegmentIDAndGen segIDGen = new SegmentIDAndGen(path.getFileName().toString());\n            assert segIDGen.schemaGen <= currentSchemaGen;\n            if (liveIDs.contains(segIDGen.segID) == false && (closedSegments.contains(segIDGen) || (removeOldGens && segIDGen.schemaGen < currentSchemaGen))) {\n              if (DEBUG) System.out.println(\"TEST: remove \" + segIDGen);\n              try {\n                IOUtils.rm(path);\n                closedSegments.remove(segIDGen);\n              } catch (IOException ioe) {\n                // OK, we'll retry later\n                if (DEBUG) System.out.println(\"TEST: ignore ioe during delete \" + path + \":\" + ioe);\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /** Removes the parallel index that are no longer in the last commit point.  We can't\n     *  remove this when the parallel reader is closed because it may still be referenced by\n     *  the last commit. */\n    private void pruneOldSegments(boolean removeOldGens) throws IOException {\n      SegmentInfos lastCommit = SegmentInfos.readLatestCommit(indexDir);\n      if (DEBUG) System.out.println(\"TEST: prune\");\n\n      Set<String> liveIDs = new HashSet<String>();\n      for(SegmentCommitInfo info : lastCommit) {\n        String idString = StringHelper.idToString(info.info.getId());\n        liveIDs.add(idString);\n      }\n\n      long currentSchemaGen = getCurrentSchemaGen();\n\n      if (Files.exists(segsPath)) {\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(segsPath)) {\n            for (Path path : stream) {\n              if (Files.isDirectory(path)) {\n                SegmentIDAndGen segIDGen = new SegmentIDAndGen(path.getFileName().toString());\n                assert segIDGen.schemaGen <= currentSchemaGen;\n                if (liveIDs.contains(segIDGen.segID) == false && (closedSegments.contains(segIDGen) || (removeOldGens && segIDGen.schemaGen < currentSchemaGen))) {\n                  if (DEBUG) System.out.println(\"TEST: remove \" + segIDGen);\n                  try {\n                    IOUtils.rm(path);\n                    closedSegments.remove(segIDGen);\n                  } catch (IOException ioe) {\n                    // OK, we'll retry later\n                    if (DEBUG) System.out.println(\"TEST: ignore ioe during delete \" + path + \":\" + ioe);\n                  }\n                }\n              }\n            }\n          }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4d9aa91d3fdd25528bac3b2e6115d54fc2f28753":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"22989c36ff05c657df26dd3377b37c9ad35859bc":["4d9aa91d3fdd25528bac3b2e6115d54fc2f28753"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["22989c36ff05c657df26dd3377b37c9ad35859bc"]},"commit2Childs":{"4d9aa91d3fdd25528bac3b2e6115d54fc2f28753":["22989c36ff05c657df26dd3377b37c9ad35859bc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4d9aa91d3fdd25528bac3b2e6115d54fc2f28753"],"22989c36ff05c657df26dd3377b37c9ad35859bc":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}