{"path":"lucene/misc/src/java/org/apache/lucene/search/DiversifiedTopDocsCollector#insert(ScoreDocKey,int,NumericDocValues).mjava","commits":[{"id":"45ccb604e99f21f1c05722c0e28bcfa64b94a861","date":1423735816,"type":0,"author":"Mark Harwood","isMerge":false,"pathNew":"lucene/misc/src/java/org/apache/lucene/search/DiversifiedTopDocsCollector#insert(ScoreDocKey,int,NumericDocValues).mjava","pathOld":"/dev/null","sourceNew":"  protected ScoreDocKey insert(ScoreDocKey addition, int docBase,\n      NumericDocValues keys) {\n    if ((globalQueue.size() >= numHits)\n        && (globalQueue.lessThan(addition, globalQueue.top()))) {\n      // Queue is full and proposed addition is not a globally\n      // competitive score\n      return addition;\n    }\n    // The addition stands a chance of being entered - check the\n    // key-specific restrictions.\n    // We delay fetching the key until we are certain the score is globally\n    // competitive. We need to adjust the ScoreDoc's global doc value to be\n    // a leaf reader value when looking up keys\n    addition.key = keys.get(addition.doc - docBase);\n\n    // For this to work the choice of key class needs to implement\n    // hashcode and equals.\n    ScoreDocKeyQueue thisKeyQ = perKeyQueues.get(addition.key);\n\n    if (thisKeyQ == null) {\n      if (sparePerKeyQueues.size() == 0) {\n        thisKeyQ = new ScoreDocKeyQueue(maxNumPerKey);\n      } else {\n        thisKeyQ = sparePerKeyQueues.pop();\n      }\n      perKeyQueues.put(addition.key, thisKeyQ);\n    }\n    ScoreDocKey perKeyOverflow = thisKeyQ.insertWithOverflow(addition);\n    if (perKeyOverflow == addition) {\n      // This key group has reached capacity and our proposed addition\n      // was not competitive in the group - do not insert into the\n      // main PQ or the key will be overly-populated in final results.\n      return addition;\n    }\n    if (perKeyOverflow == null) {\n      // This proposed addition is also locally competitive within the\n      // key group - make a global entry and return\n      ScoreDocKey globalOverflow = globalQueue.insertWithOverflow(addition);\n      perKeyGroupRemove(globalOverflow);\n      return globalOverflow;\n    }\n    // For the given key, we have reached max capacity but the new addition\n    // is better than a prior entry that still exists in the global results\n    // - request the weaker-scoring entry to be removed from the global\n    // queue.\n    globalQueue.remove(perKeyOverflow);\n    // Add the locally-competitive addition into the globally queue\n    globalQueue.add(addition);\n    return perKeyOverflow;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6652c74b2358a0b13223817a6a793bf1c9d0749d","date":1474465301,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/misc/src/java/org/apache/lucene/search/DiversifiedTopDocsCollector#insert(ScoreDocKey,int,NumericDocValues).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/search/DiversifiedTopDocsCollector#insert(ScoreDocKey,int,NumericDocValues).mjava","sourceNew":"  protected ScoreDocKey insert(ScoreDocKey addition, int docBase,\n      NumericDocValues keys) throws IOException {\n    if ((globalQueue.size() >= numHits)\n        && (globalQueue.lessThan(addition, globalQueue.top()))) {\n      // Queue is full and proposed addition is not a globally\n      // competitive score\n      return addition;\n    }\n    // The addition stands a chance of being entered - check the\n    // key-specific restrictions.\n    // We delay fetching the key until we are certain the score is globally\n    // competitive. We need to adjust the ScoreDoc's global doc value to be\n    // a leaf reader value when looking up keys\n    int leafDocID = addition.doc - docBase;\n    long value;\n    if (keys.docID() < leafDocID) {\n      keys.advance(leafDocID);\n    }\n    if (keys.docID() == leafDocID) {\n      value = keys.longValue();\n    } else {\n      value = 0;\n    }\n    addition.key = value;\n\n    // For this to work the choice of key class needs to implement\n    // hashcode and equals.\n    ScoreDocKeyQueue thisKeyQ = perKeyQueues.get(addition.key);\n\n    if (thisKeyQ == null) {\n      if (sparePerKeyQueues.size() == 0) {\n        thisKeyQ = new ScoreDocKeyQueue(maxNumPerKey);\n      } else {\n        thisKeyQ = sparePerKeyQueues.pop();\n      }\n      perKeyQueues.put(addition.key, thisKeyQ);\n    }\n    ScoreDocKey perKeyOverflow = thisKeyQ.insertWithOverflow(addition);\n    if (perKeyOverflow == addition) {\n      // This key group has reached capacity and our proposed addition\n      // was not competitive in the group - do not insert into the\n      // main PQ or the key will be overly-populated in final results.\n      return addition;\n    }\n    if (perKeyOverflow == null) {\n      // This proposed addition is also locally competitive within the\n      // key group - make a global entry and return\n      ScoreDocKey globalOverflow = globalQueue.insertWithOverflow(addition);\n      perKeyGroupRemove(globalOverflow);\n      return globalOverflow;\n    }\n    // For the given key, we have reached max capacity but the new addition\n    // is better than a prior entry that still exists in the global results\n    // - request the weaker-scoring entry to be removed from the global\n    // queue.\n    globalQueue.remove(perKeyOverflow);\n    // Add the locally-competitive addition into the globally queue\n    globalQueue.add(addition);\n    return perKeyOverflow;\n  }\n\n","sourceOld":"  protected ScoreDocKey insert(ScoreDocKey addition, int docBase,\n      NumericDocValues keys) {\n    if ((globalQueue.size() >= numHits)\n        && (globalQueue.lessThan(addition, globalQueue.top()))) {\n      // Queue is full and proposed addition is not a globally\n      // competitive score\n      return addition;\n    }\n    // The addition stands a chance of being entered - check the\n    // key-specific restrictions.\n    // We delay fetching the key until we are certain the score is globally\n    // competitive. We need to adjust the ScoreDoc's global doc value to be\n    // a leaf reader value when looking up keys\n    addition.key = keys.get(addition.doc - docBase);\n\n    // For this to work the choice of key class needs to implement\n    // hashcode and equals.\n    ScoreDocKeyQueue thisKeyQ = perKeyQueues.get(addition.key);\n\n    if (thisKeyQ == null) {\n      if (sparePerKeyQueues.size() == 0) {\n        thisKeyQ = new ScoreDocKeyQueue(maxNumPerKey);\n      } else {\n        thisKeyQ = sparePerKeyQueues.pop();\n      }\n      perKeyQueues.put(addition.key, thisKeyQ);\n    }\n    ScoreDocKey perKeyOverflow = thisKeyQ.insertWithOverflow(addition);\n    if (perKeyOverflow == addition) {\n      // This key group has reached capacity and our proposed addition\n      // was not competitive in the group - do not insert into the\n      // main PQ or the key will be overly-populated in final results.\n      return addition;\n    }\n    if (perKeyOverflow == null) {\n      // This proposed addition is also locally competitive within the\n      // key group - make a global entry and return\n      ScoreDocKey globalOverflow = globalQueue.insertWithOverflow(addition);\n      perKeyGroupRemove(globalOverflow);\n      return globalOverflow;\n    }\n    // For the given key, we have reached max capacity but the new addition\n    // is better than a prior entry that still exists in the global results\n    // - request the weaker-scoring entry to be removed from the global\n    // queue.\n    globalQueue.remove(perKeyOverflow);\n    // Add the locally-competitive addition into the globally queue\n    globalQueue.add(addition);\n    return perKeyOverflow;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/misc/src/java/org/apache/lucene/search/DiversifiedTopDocsCollector#insert(ScoreDocKey,int,NumericDocValues).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/search/DiversifiedTopDocsCollector#insert(ScoreDocKey,int,NumericDocValues).mjava","sourceNew":"  protected ScoreDocKey insert(ScoreDocKey addition, int docBase,\n      NumericDocValues keys) throws IOException {\n    if ((globalQueue.size() >= numHits)\n        && (globalQueue.lessThan(addition, globalQueue.top()))) {\n      // Queue is full and proposed addition is not a globally\n      // competitive score\n      return addition;\n    }\n    // The addition stands a chance of being entered - check the\n    // key-specific restrictions.\n    // We delay fetching the key until we are certain the score is globally\n    // competitive. We need to adjust the ScoreDoc's global doc value to be\n    // a leaf reader value when looking up keys\n    int leafDocID = addition.doc - docBase;\n    long value;\n    if (keys.docID() < leafDocID) {\n      keys.advance(leafDocID);\n    }\n    if (keys.docID() == leafDocID) {\n      value = keys.longValue();\n    } else {\n      value = 0;\n    }\n    addition.key = value;\n\n    // For this to work the choice of key class needs to implement\n    // hashcode and equals.\n    ScoreDocKeyQueue thisKeyQ = perKeyQueues.get(addition.key);\n\n    if (thisKeyQ == null) {\n      if (sparePerKeyQueues.size() == 0) {\n        thisKeyQ = new ScoreDocKeyQueue(maxNumPerKey);\n      } else {\n        thisKeyQ = sparePerKeyQueues.pop();\n      }\n      perKeyQueues.put(addition.key, thisKeyQ);\n    }\n    ScoreDocKey perKeyOverflow = thisKeyQ.insertWithOverflow(addition);\n    if (perKeyOverflow == addition) {\n      // This key group has reached capacity and our proposed addition\n      // was not competitive in the group - do not insert into the\n      // main PQ or the key will be overly-populated in final results.\n      return addition;\n    }\n    if (perKeyOverflow == null) {\n      // This proposed addition is also locally competitive within the\n      // key group - make a global entry and return\n      ScoreDocKey globalOverflow = globalQueue.insertWithOverflow(addition);\n      perKeyGroupRemove(globalOverflow);\n      return globalOverflow;\n    }\n    // For the given key, we have reached max capacity but the new addition\n    // is better than a prior entry that still exists in the global results\n    // - request the weaker-scoring entry to be removed from the global\n    // queue.\n    globalQueue.remove(perKeyOverflow);\n    // Add the locally-competitive addition into the globally queue\n    globalQueue.add(addition);\n    return perKeyOverflow;\n  }\n\n","sourceOld":"  protected ScoreDocKey insert(ScoreDocKey addition, int docBase,\n      NumericDocValues keys) {\n    if ((globalQueue.size() >= numHits)\n        && (globalQueue.lessThan(addition, globalQueue.top()))) {\n      // Queue is full and proposed addition is not a globally\n      // competitive score\n      return addition;\n    }\n    // The addition stands a chance of being entered - check the\n    // key-specific restrictions.\n    // We delay fetching the key until we are certain the score is globally\n    // competitive. We need to adjust the ScoreDoc's global doc value to be\n    // a leaf reader value when looking up keys\n    addition.key = keys.get(addition.doc - docBase);\n\n    // For this to work the choice of key class needs to implement\n    // hashcode and equals.\n    ScoreDocKeyQueue thisKeyQ = perKeyQueues.get(addition.key);\n\n    if (thisKeyQ == null) {\n      if (sparePerKeyQueues.size() == 0) {\n        thisKeyQ = new ScoreDocKeyQueue(maxNumPerKey);\n      } else {\n        thisKeyQ = sparePerKeyQueues.pop();\n      }\n      perKeyQueues.put(addition.key, thisKeyQ);\n    }\n    ScoreDocKey perKeyOverflow = thisKeyQ.insertWithOverflow(addition);\n    if (perKeyOverflow == addition) {\n      // This key group has reached capacity and our proposed addition\n      // was not competitive in the group - do not insert into the\n      // main PQ or the key will be overly-populated in final results.\n      return addition;\n    }\n    if (perKeyOverflow == null) {\n      // This proposed addition is also locally competitive within the\n      // key group - make a global entry and return\n      ScoreDocKey globalOverflow = globalQueue.insertWithOverflow(addition);\n      perKeyGroupRemove(globalOverflow);\n      return globalOverflow;\n    }\n    // For the given key, we have reached max capacity but the new addition\n    // is better than a prior entry that still exists in the global results\n    // - request the weaker-scoring entry to be removed from the global\n    // queue.\n    globalQueue.remove(perKeyOverflow);\n    // Add the locally-competitive addition into the globally queue\n    globalQueue.add(addition);\n    return perKeyOverflow;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/misc/src/java/org/apache/lucene/search/DiversifiedTopDocsCollector#insert(ScoreDocKey,int,NumericDocValues).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/search/DiversifiedTopDocsCollector#insert(ScoreDocKey,int,NumericDocValues).mjava","sourceNew":"  protected ScoreDocKey insert(ScoreDocKey addition, int docBase,\n      NumericDocValues keys) throws IOException {\n    if ((globalQueue.size() >= numHits)\n        && (globalQueue.lessThan(addition, globalQueue.top()))) {\n      // Queue is full and proposed addition is not a globally\n      // competitive score\n      return addition;\n    }\n    // The addition stands a chance of being entered - check the\n    // key-specific restrictions.\n    // We delay fetching the key until we are certain the score is globally\n    // competitive. We need to adjust the ScoreDoc's global doc value to be\n    // a leaf reader value when looking up keys\n    int leafDocID = addition.doc - docBase;\n    long value;\n    if (keys.docID() < leafDocID) {\n      keys.advance(leafDocID);\n    }\n    if (keys.docID() == leafDocID) {\n      value = keys.longValue();\n    } else {\n      value = 0;\n    }\n    addition.key = value;\n\n    // For this to work the choice of key class needs to implement\n    // hashcode and equals.\n    ScoreDocKeyQueue thisKeyQ = perKeyQueues.get(addition.key);\n\n    if (thisKeyQ == null) {\n      if (sparePerKeyQueues.size() == 0) {\n        thisKeyQ = new ScoreDocKeyQueue(maxNumPerKey);\n      } else {\n        thisKeyQ = sparePerKeyQueues.pop();\n      }\n      perKeyQueues.put(addition.key, thisKeyQ);\n    }\n    ScoreDocKey perKeyOverflow = thisKeyQ.insertWithOverflow(addition);\n    if (perKeyOverflow == addition) {\n      // This key group has reached capacity and our proposed addition\n      // was not competitive in the group - do not insert into the\n      // main PQ or the key will be overly-populated in final results.\n      return addition;\n    }\n    if (perKeyOverflow == null) {\n      // This proposed addition is also locally competitive within the\n      // key group - make a global entry and return\n      ScoreDocKey globalOverflow = globalQueue.insertWithOverflow(addition);\n      perKeyGroupRemove(globalOverflow);\n      return globalOverflow;\n    }\n    // For the given key, we have reached max capacity but the new addition\n    // is better than a prior entry that still exists in the global results\n    // - request the weaker-scoring entry to be removed from the global\n    // queue.\n    globalQueue.remove(perKeyOverflow);\n    // Add the locally-competitive addition into the globally queue\n    globalQueue.add(addition);\n    return perKeyOverflow;\n  }\n\n","sourceOld":"  protected ScoreDocKey insert(ScoreDocKey addition, int docBase,\n      NumericDocValues keys) {\n    if ((globalQueue.size() >= numHits)\n        && (globalQueue.lessThan(addition, globalQueue.top()))) {\n      // Queue is full and proposed addition is not a globally\n      // competitive score\n      return addition;\n    }\n    // The addition stands a chance of being entered - check the\n    // key-specific restrictions.\n    // We delay fetching the key until we are certain the score is globally\n    // competitive. We need to adjust the ScoreDoc's global doc value to be\n    // a leaf reader value when looking up keys\n    addition.key = keys.get(addition.doc - docBase);\n\n    // For this to work the choice of key class needs to implement\n    // hashcode and equals.\n    ScoreDocKeyQueue thisKeyQ = perKeyQueues.get(addition.key);\n\n    if (thisKeyQ == null) {\n      if (sparePerKeyQueues.size() == 0) {\n        thisKeyQ = new ScoreDocKeyQueue(maxNumPerKey);\n      } else {\n        thisKeyQ = sparePerKeyQueues.pop();\n      }\n      perKeyQueues.put(addition.key, thisKeyQ);\n    }\n    ScoreDocKey perKeyOverflow = thisKeyQ.insertWithOverflow(addition);\n    if (perKeyOverflow == addition) {\n      // This key group has reached capacity and our proposed addition\n      // was not competitive in the group - do not insert into the\n      // main PQ or the key will be overly-populated in final results.\n      return addition;\n    }\n    if (perKeyOverflow == null) {\n      // This proposed addition is also locally competitive within the\n      // key group - make a global entry and return\n      ScoreDocKey globalOverflow = globalQueue.insertWithOverflow(addition);\n      perKeyGroupRemove(globalOverflow);\n      return globalOverflow;\n    }\n    // For the given key, we have reached max capacity but the new addition\n    // is better than a prior entry that still exists in the global results\n    // - request the weaker-scoring entry to be removed from the global\n    // queue.\n    globalQueue.remove(perKeyOverflow);\n    // Add the locally-competitive addition into the globally queue\n    globalQueue.add(addition);\n    return perKeyOverflow;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f0e682caaf14dec14c8a59447256eb5ef4700c1c","date":1491164709,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/misc/src/java/org/apache/lucene/search/DiversifiedTopDocsCollector#insert(ScoreDocKey,int,NumericDocValues).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/search/DiversifiedTopDocsCollector#insert(ScoreDocKey,int,NumericDocValues).mjava","sourceNew":"  protected ScoreDocKey insert(ScoreDocKey addition, int docBase,\n      NumericDocValues keys) throws IOException {\n    if ((globalQueue.size() >= numHits)\n        && (globalQueue.lessThan(addition, globalQueue.top()))) {\n      // Queue is full and proposed addition is not a globally\n      // competitive score\n      return addition;\n    }\n    // The addition stands a chance of being entered - check the\n    // key-specific restrictions.\n    // We delay fetching the key until we are certain the score is globally\n    // competitive. We need to adjust the ScoreDoc's global doc value to be\n    // a leaf reader value when looking up keys\n    int leafDocID = addition.doc - docBase;\n    long value;\n    if (keys.advanceExact(leafDocID)) {\n      value = keys.longValue();\n    } else {\n      value = 0;\n    }\n    addition.key = value;\n\n    // For this to work the choice of key class needs to implement\n    // hashcode and equals.\n    ScoreDocKeyQueue thisKeyQ = perKeyQueues.get(addition.key);\n\n    if (thisKeyQ == null) {\n      if (sparePerKeyQueues.size() == 0) {\n        thisKeyQ = new ScoreDocKeyQueue(maxNumPerKey);\n      } else {\n        thisKeyQ = sparePerKeyQueues.pop();\n      }\n      perKeyQueues.put(addition.key, thisKeyQ);\n    }\n    ScoreDocKey perKeyOverflow = thisKeyQ.insertWithOverflow(addition);\n    if (perKeyOverflow == addition) {\n      // This key group has reached capacity and our proposed addition\n      // was not competitive in the group - do not insert into the\n      // main PQ or the key will be overly-populated in final results.\n      return addition;\n    }\n    if (perKeyOverflow == null) {\n      // This proposed addition is also locally competitive within the\n      // key group - make a global entry and return\n      ScoreDocKey globalOverflow = globalQueue.insertWithOverflow(addition);\n      perKeyGroupRemove(globalOverflow);\n      return globalOverflow;\n    }\n    // For the given key, we have reached max capacity but the new addition\n    // is better than a prior entry that still exists in the global results\n    // - request the weaker-scoring entry to be removed from the global\n    // queue.\n    globalQueue.remove(perKeyOverflow);\n    // Add the locally-competitive addition into the globally queue\n    globalQueue.add(addition);\n    return perKeyOverflow;\n  }\n\n","sourceOld":"  protected ScoreDocKey insert(ScoreDocKey addition, int docBase,\n      NumericDocValues keys) throws IOException {\n    if ((globalQueue.size() >= numHits)\n        && (globalQueue.lessThan(addition, globalQueue.top()))) {\n      // Queue is full and proposed addition is not a globally\n      // competitive score\n      return addition;\n    }\n    // The addition stands a chance of being entered - check the\n    // key-specific restrictions.\n    // We delay fetching the key until we are certain the score is globally\n    // competitive. We need to adjust the ScoreDoc's global doc value to be\n    // a leaf reader value when looking up keys\n    int leafDocID = addition.doc - docBase;\n    long value;\n    if (keys.docID() < leafDocID) {\n      keys.advance(leafDocID);\n    }\n    if (keys.docID() == leafDocID) {\n      value = keys.longValue();\n    } else {\n      value = 0;\n    }\n    addition.key = value;\n\n    // For this to work the choice of key class needs to implement\n    // hashcode and equals.\n    ScoreDocKeyQueue thisKeyQ = perKeyQueues.get(addition.key);\n\n    if (thisKeyQ == null) {\n      if (sparePerKeyQueues.size() == 0) {\n        thisKeyQ = new ScoreDocKeyQueue(maxNumPerKey);\n      } else {\n        thisKeyQ = sparePerKeyQueues.pop();\n      }\n      perKeyQueues.put(addition.key, thisKeyQ);\n    }\n    ScoreDocKey perKeyOverflow = thisKeyQ.insertWithOverflow(addition);\n    if (perKeyOverflow == addition) {\n      // This key group has reached capacity and our proposed addition\n      // was not competitive in the group - do not insert into the\n      // main PQ or the key will be overly-populated in final results.\n      return addition;\n    }\n    if (perKeyOverflow == null) {\n      // This proposed addition is also locally competitive within the\n      // key group - make a global entry and return\n      ScoreDocKey globalOverflow = globalQueue.insertWithOverflow(addition);\n      perKeyGroupRemove(globalOverflow);\n      return globalOverflow;\n    }\n    // For the given key, we have reached max capacity but the new addition\n    // is better than a prior entry that still exists in the global results\n    // - request the weaker-scoring entry to be removed from the global\n    // queue.\n    globalQueue.remove(perKeyOverflow);\n    // Add the locally-competitive addition into the globally queue\n    globalQueue.add(addition);\n    return perKeyOverflow;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"87d08934283634934b3844d0a9888f458ccabe7f","date":1491219821,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/misc/src/java/org/apache/lucene/search/DiversifiedTopDocsCollector#insert(ScoreDocKey,int,NumericDocValues).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/search/DiversifiedTopDocsCollector#insert(ScoreDocKey,int,NumericDocValues).mjava","sourceNew":"  protected ScoreDocKey insert(ScoreDocKey addition, int docBase,\n      NumericDocValues keys) throws IOException {\n    if ((globalQueue.size() >= numHits)\n        && (globalQueue.lessThan(addition, globalQueue.top()))) {\n      // Queue is full and proposed addition is not a globally\n      // competitive score\n      return addition;\n    }\n    // The addition stands a chance of being entered - check the\n    // key-specific restrictions.\n    // We delay fetching the key until we are certain the score is globally\n    // competitive. We need to adjust the ScoreDoc's global doc value to be\n    // a leaf reader value when looking up keys\n    int leafDocID = addition.doc - docBase;\n    long value;\n    if (keys.advanceExact(leafDocID)) {\n      value = keys.longValue();\n    } else {\n      value = 0;\n    }\n    addition.key = value;\n\n    // For this to work the choice of key class needs to implement\n    // hashcode and equals.\n    ScoreDocKeyQueue thisKeyQ = perKeyQueues.get(addition.key);\n\n    if (thisKeyQ == null) {\n      if (sparePerKeyQueues.size() == 0) {\n        thisKeyQ = new ScoreDocKeyQueue(maxNumPerKey);\n      } else {\n        thisKeyQ = sparePerKeyQueues.pop();\n      }\n      perKeyQueues.put(addition.key, thisKeyQ);\n    }\n    ScoreDocKey perKeyOverflow = thisKeyQ.insertWithOverflow(addition);\n    if (perKeyOverflow == addition) {\n      // This key group has reached capacity and our proposed addition\n      // was not competitive in the group - do not insert into the\n      // main PQ or the key will be overly-populated in final results.\n      return addition;\n    }\n    if (perKeyOverflow == null) {\n      // This proposed addition is also locally competitive within the\n      // key group - make a global entry and return\n      ScoreDocKey globalOverflow = globalQueue.insertWithOverflow(addition);\n      perKeyGroupRemove(globalOverflow);\n      return globalOverflow;\n    }\n    // For the given key, we have reached max capacity but the new addition\n    // is better than a prior entry that still exists in the global results\n    // - request the weaker-scoring entry to be removed from the global\n    // queue.\n    globalQueue.remove(perKeyOverflow);\n    // Add the locally-competitive addition into the globally queue\n    globalQueue.add(addition);\n    return perKeyOverflow;\n  }\n\n","sourceOld":"  protected ScoreDocKey insert(ScoreDocKey addition, int docBase,\n      NumericDocValues keys) throws IOException {\n    if ((globalQueue.size() >= numHits)\n        && (globalQueue.lessThan(addition, globalQueue.top()))) {\n      // Queue is full and proposed addition is not a globally\n      // competitive score\n      return addition;\n    }\n    // The addition stands a chance of being entered - check the\n    // key-specific restrictions.\n    // We delay fetching the key until we are certain the score is globally\n    // competitive. We need to adjust the ScoreDoc's global doc value to be\n    // a leaf reader value when looking up keys\n    int leafDocID = addition.doc - docBase;\n    long value;\n    if (keys.docID() < leafDocID) {\n      keys.advance(leafDocID);\n    }\n    if (keys.docID() == leafDocID) {\n      value = keys.longValue();\n    } else {\n      value = 0;\n    }\n    addition.key = value;\n\n    // For this to work the choice of key class needs to implement\n    // hashcode and equals.\n    ScoreDocKeyQueue thisKeyQ = perKeyQueues.get(addition.key);\n\n    if (thisKeyQ == null) {\n      if (sparePerKeyQueues.size() == 0) {\n        thisKeyQ = new ScoreDocKeyQueue(maxNumPerKey);\n      } else {\n        thisKeyQ = sparePerKeyQueues.pop();\n      }\n      perKeyQueues.put(addition.key, thisKeyQ);\n    }\n    ScoreDocKey perKeyOverflow = thisKeyQ.insertWithOverflow(addition);\n    if (perKeyOverflow == addition) {\n      // This key group has reached capacity and our proposed addition\n      // was not competitive in the group - do not insert into the\n      // main PQ or the key will be overly-populated in final results.\n      return addition;\n    }\n    if (perKeyOverflow == null) {\n      // This proposed addition is also locally competitive within the\n      // key group - make a global entry and return\n      ScoreDocKey globalOverflow = globalQueue.insertWithOverflow(addition);\n      perKeyGroupRemove(globalOverflow);\n      return globalOverflow;\n    }\n    // For the given key, we have reached max capacity but the new addition\n    // is better than a prior entry that still exists in the global results\n    // - request the weaker-scoring entry to be removed from the global\n    // queue.\n    globalQueue.remove(perKeyOverflow);\n    // Add the locally-competitive addition into the globally queue\n    globalQueue.add(addition);\n    return perKeyOverflow;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f0e682caaf14dec14c8a59447256eb5ef4700c1c":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"45ccb604e99f21f1c05722c0e28bcfa64b94a861":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["45ccb604e99f21f1c05722c0e28bcfa64b94a861","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["45ccb604e99f21f1c05722c0e28bcfa64b94a861"],"87d08934283634934b3844d0a9888f458ccabe7f":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["45ccb604e99f21f1c05722c0e28bcfa64b94a861","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f0e682caaf14dec14c8a59447256eb5ef4700c1c"]},"commit2Childs":{"f0e682caaf14dec14c8a59447256eb5ef4700c1c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"45ccb604e99f21f1c05722c0e28bcfa64b94a861":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","6652c74b2358a0b13223817a6a793bf1c9d0749d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["f0e682caaf14dec14c8a59447256eb5ef4700c1c","87d08934283634934b3844d0a9888f458ccabe7f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["45ccb604e99f21f1c05722c0e28bcfa64b94a861"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"87d08934283634934b3844d0a9888f458ccabe7f":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["87d08934283634934b3844d0a9888f458ccabe7f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}