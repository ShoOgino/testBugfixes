{"path":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testRandom().mjava","commits":[{"id":"f31d1f3a9bc5a99a8d7f3110bab36210e7d967c6","date":1337196931,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testRandom().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandom() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n    memCtrl.limit = 1000;\n    memCtrl.netBytes = 1;\n    ctrl.updateStalled(memCtrl);\n    Thread[] stallThreads = new Thread[atLeast(3)];\n    for (int i = 0; i < stallThreads.length; i++) {\n      final int threadId = i;\n      stallThreads[i] = new Thread() {\n        public void run() {\n          int baseBytes = threadId % 2 == 0 ? 500 : 700;\n          SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n          memCtrl.limit = 1000;\n          memCtrl.netBytes = 1;\n          int iters = atLeast(1000);\n          for (int j = 0; j < iters; j++) {\n            memCtrl.netBytes = baseBytes + random().nextInt(1000);\n            ctrl.updateStalled(memCtrl);\n            if (random().nextInt(5) == 0) { // thread 0 only updates\n              ctrl.waitIfStalled();\n            }\n          }\n        }\n      };\n    }\n    start(stallThreads);\n    long time = System.currentTimeMillis();\n    /*\n     * use a 100 sec timeout to make sure we not hang forever. join will fail in\n     * that case\n     */\n    while ((System.currentTimeMillis() - time) < 100 * 1000\n        && !terminated(stallThreads)) {\n      ctrl.updateStalled(memCtrl);\n      if (random().nextBoolean()) {\n        Thread.yield();\n      } else {\n        Thread.sleep(1);\n      }\n      \n    }\n    join(stallThreads, 100);\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["b0b7352903525839fa9ecf337b5a5e90ea91f243"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ef0d8a69209261514c5739c770bba706c2308450","date":1337607597,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testRandom().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandom() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n    memCtrl.limit = 1000;\n    memCtrl.netBytes = 1;\n    ctrl.updateStalled(memCtrl);\n    Thread[] stallThreads = new Thread[atLeast(3)];\n    for (int i = 0; i < stallThreads.length; i++) {\n      final int threadId = i;\n      stallThreads[i] = new Thread() {\n        public void run() {\n          int baseBytes = threadId % 2 == 0 ? 500 : 700;\n          SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n          memCtrl.limit = 1000;\n          memCtrl.netBytes = 1;\n          int iters = atLeast(1000);\n          for (int j = 0; j < iters; j++) {\n            memCtrl.netBytes = baseBytes + random().nextInt(1000);\n            ctrl.updateStalled(memCtrl);\n            if (random().nextInt(5) == 0) { // thread 0 only updates\n              ctrl.waitIfStalled();\n            }\n          }\n        }\n      };\n    }\n    start(stallThreads);\n    long time = System.currentTimeMillis();\n    /*\n     * use a 100 sec timeout to make sure we not hang forever. join will fail in\n     * that case\n     */\n    while ((System.currentTimeMillis() - time) < 100 * 1000\n        && !terminated(stallThreads)) {\n      ctrl.updateStalled(memCtrl);\n      if (random().nextBoolean()) {\n        Thread.yield();\n      } else {\n        Thread.sleep(1);\n      }\n      \n    }\n    join(stallThreads, 100);\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a0bb7b6eeee9103dc4c7cb2dfd62a9a41894fc2","date":1337674113,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testRandom().mjava","sourceNew":"  public void testRandom() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n    memCtrl.limit = 1000;\n    memCtrl.netBytes = 1;\n    ctrl.updateStalled(memCtrl);\n    Thread[] stallThreads = new Thread[atLeast(3)];\n    for (int i = 0; i < stallThreads.length; i++) {\n      final int threadId = i;\n      stallThreads[i] = new Thread() {\n        public void run() {\n          int baseBytes = threadId % 2 == 0 ? 500 : 700;\n          SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n          memCtrl.limit = 1000;\n          memCtrl.netBytes = 1;\n          memCtrl.flushBytes = 0;\n\n          int iters = atLeast(1000);\n          for (int j = 0; j < iters; j++) {\n            memCtrl.netBytes = baseBytes + random().nextInt(1000);\n            memCtrl.flushBytes = random().nextInt((int)memCtrl.netBytes);\n            ctrl.updateStalled(memCtrl);\n            if (random().nextInt(5) == 0) { // thread 0 only updates\n              ctrl.waitIfStalled();\n            }\n          }\n        }\n      };\n    }\n    start(stallThreads);\n    long time = System.currentTimeMillis();\n    /*\n     * use a 100 sec timeout to make sure we not hang forever. join will fail in\n     * that case\n     */\n    while ((System.currentTimeMillis() - time) < 100 * 1000\n        && !terminated(stallThreads)) {\n      ctrl.updateStalled(memCtrl);\n      if (random().nextBoolean()) {\n        Thread.yield();\n      } else {\n        Thread.sleep(1);\n      }\n      \n    }\n    join(stallThreads, 100);\n    \n  }\n\n","sourceOld":"  public void testRandom() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n    memCtrl.limit = 1000;\n    memCtrl.netBytes = 1;\n    ctrl.updateStalled(memCtrl);\n    Thread[] stallThreads = new Thread[atLeast(3)];\n    for (int i = 0; i < stallThreads.length; i++) {\n      final int threadId = i;\n      stallThreads[i] = new Thread() {\n        public void run() {\n          int baseBytes = threadId % 2 == 0 ? 500 : 700;\n          SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n          memCtrl.limit = 1000;\n          memCtrl.netBytes = 1;\n          int iters = atLeast(1000);\n          for (int j = 0; j < iters; j++) {\n            memCtrl.netBytes = baseBytes + random().nextInt(1000);\n            ctrl.updateStalled(memCtrl);\n            if (random().nextInt(5) == 0) { // thread 0 only updates\n              ctrl.waitIfStalled();\n            }\n          }\n        }\n      };\n    }\n    start(stallThreads);\n    long time = System.currentTimeMillis();\n    /*\n     * use a 100 sec timeout to make sure we not hang forever. join will fail in\n     * that case\n     */\n    while ((System.currentTimeMillis() - time) < 100 * 1000\n        && !terminated(stallThreads)) {\n      ctrl.updateStalled(memCtrl);\n      if (random().nextBoolean()) {\n        Thread.yield();\n      } else {\n        Thread.sleep(1);\n      }\n      \n    }\n    join(stallThreads, 100);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3599646b4d4c346cf74d334813488b8b337b5bf5","date":1337790261,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testRandom().mjava","sourceNew":"  public void testRandom() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n    memCtrl.limit = 1000;\n    memCtrl.netBytes = 1;\n    ctrl.updateStalled(memCtrl);\n    Thread[] stallThreads = new Thread[atLeast(3)];\n    for (int i = 0; i < stallThreads.length; i++) {\n      final int threadId = i;\n      stallThreads[i] = new Thread() {\n        public void run() {\n          int baseBytes = threadId % 2 == 0 ? 500 : 700;\n          SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n          memCtrl.limit = 1000;\n          memCtrl.netBytes = 1;\n          memCtrl.flushBytes = 0;\n\n          int iters = atLeast(1000);\n          for (int j = 0; j < iters; j++) {\n            memCtrl.netBytes = baseBytes + random().nextInt(1000);\n            memCtrl.flushBytes = random().nextInt((int)memCtrl.netBytes);\n            ctrl.updateStalled(memCtrl);\n            if (random().nextInt(5) == 0) { // thread 0 only updates\n              ctrl.waitIfStalled();\n            }\n          }\n        }\n      };\n    }\n    start(stallThreads);\n    long time = System.currentTimeMillis();\n    /*\n     * use a 100 sec timeout to make sure we not hang forever. join will fail in\n     * that case\n     */\n    while ((System.currentTimeMillis() - time) < 100 * 1000\n        && !terminated(stallThreads)) {\n      ctrl.updateStalled(memCtrl);\n      if (random().nextBoolean()) {\n        Thread.yield();\n      } else {\n        Thread.sleep(1);\n      }\n      \n    }\n    join(stallThreads, 100);\n    \n  }\n\n","sourceOld":"  public void testRandom() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n    memCtrl.limit = 1000;\n    memCtrl.netBytes = 1;\n    ctrl.updateStalled(memCtrl);\n    Thread[] stallThreads = new Thread[atLeast(3)];\n    for (int i = 0; i < stallThreads.length; i++) {\n      final int threadId = i;\n      stallThreads[i] = new Thread() {\n        public void run() {\n          int baseBytes = threadId % 2 == 0 ? 500 : 700;\n          SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n          memCtrl.limit = 1000;\n          memCtrl.netBytes = 1;\n          int iters = atLeast(1000);\n          for (int j = 0; j < iters; j++) {\n            memCtrl.netBytes = baseBytes + random().nextInt(1000);\n            ctrl.updateStalled(memCtrl);\n            if (random().nextInt(5) == 0) { // thread 0 only updates\n              ctrl.waitIfStalled();\n            }\n          }\n        }\n      };\n    }\n    start(stallThreads);\n    long time = System.currentTimeMillis();\n    /*\n     * use a 100 sec timeout to make sure we not hang forever. join will fail in\n     * that case\n     */\n    while ((System.currentTimeMillis() - time) < 100 * 1000\n        && !terminated(stallThreads)) {\n      ctrl.updateStalled(memCtrl);\n      if (random().nextBoolean()) {\n        Thread.yield();\n      } else {\n        Thread.sleep(1);\n      }\n      \n    }\n    join(stallThreads, 100);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5e38f40562eb7c165ae08ab2367a031883138354","date":1340287338,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testRandom().mjava","sourceNew":"  public void testRandom() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    ctrl.updateStalled(false);\n    \n    Thread[] stallThreads = new Thread[atLeast(3)];\n    for (int i = 0; i < stallThreads.length; i++) {\n      final int threadId = i;\n      final int stallProbability = 1 +random().nextInt(10);\n      stallThreads[i] = new Thread() {\n        public void run() {\n\n          int iters = atLeast(1000);\n          for (int j = 0; j < iters; j++) {\n            ctrl.updateStalled(random().nextInt(stallProbability) == 0);\n            if (random().nextInt(5) == 0) { // thread 0 only updates\n              ctrl.waitIfStalled();\n            }\n          }\n        }\n      };\n    }\n    start(stallThreads);\n    long time = System.currentTimeMillis();\n    /*\n     * use a 100 sec timeout to make sure we not hang forever. join will fail in\n     * that case\n     */\n    while ((System.currentTimeMillis() - time) < 100 * 1000\n        && !terminated(stallThreads)) {\n      ctrl.updateStalled(false);\n      if (random().nextBoolean()) {\n        Thread.yield();\n      } else {\n        Thread.sleep(1);\n      }\n      \n    }\n    join(stallThreads, 100);\n    \n  }\n\n","sourceOld":"  public void testRandom() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n    memCtrl.limit = 1000;\n    memCtrl.netBytes = 1;\n    ctrl.updateStalled(memCtrl);\n    Thread[] stallThreads = new Thread[atLeast(3)];\n    for (int i = 0; i < stallThreads.length; i++) {\n      final int threadId = i;\n      stallThreads[i] = new Thread() {\n        public void run() {\n          int baseBytes = threadId % 2 == 0 ? 500 : 700;\n          SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n          memCtrl.limit = 1000;\n          memCtrl.netBytes = 1;\n          memCtrl.flushBytes = 0;\n\n          int iters = atLeast(1000);\n          for (int j = 0; j < iters; j++) {\n            memCtrl.netBytes = baseBytes + random().nextInt(1000);\n            memCtrl.flushBytes = random().nextInt((int)memCtrl.netBytes);\n            ctrl.updateStalled(memCtrl);\n            if (random().nextInt(5) == 0) { // thread 0 only updates\n              ctrl.waitIfStalled();\n            }\n          }\n        }\n      };\n    }\n    start(stallThreads);\n    long time = System.currentTimeMillis();\n    /*\n     * use a 100 sec timeout to make sure we not hang forever. join will fail in\n     * that case\n     */\n    while ((System.currentTimeMillis() - time) < 100 * 1000\n        && !terminated(stallThreads)) {\n      ctrl.updateStalled(memCtrl);\n      if (random().nextBoolean()) {\n        Thread.yield();\n      } else {\n        Thread.sleep(1);\n      }\n      \n    }\n    join(stallThreads, 100);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b0b7352903525839fa9ecf337b5a5e90ea91f243","date":1340613989,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testRandom().mjava","sourceNew":"  public void testRandom() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    ctrl.updateStalled(false);\n    \n    Thread[] stallThreads = new Thread[atLeast(3)];\n    for (int i = 0; i < stallThreads.length; i++) {\n      final int stallProbability = 1 +random().nextInt(10);\n      stallThreads[i] = new Thread() {\n        public void run() {\n\n          int iters = atLeast(1000);\n          for (int j = 0; j < iters; j++) {\n            ctrl.updateStalled(random().nextInt(stallProbability) == 0);\n            if (random().nextInt(5) == 0) { // thread 0 only updates\n              ctrl.waitIfStalled();\n            }\n          }\n        }\n      };\n    }\n    start(stallThreads);\n    long time = System.currentTimeMillis();\n    /*\n     * use a 100 sec timeout to make sure we not hang forever. join will fail in\n     * that case\n     */\n    while ((System.currentTimeMillis() - time) < 100 * 1000\n        && !terminated(stallThreads)) {\n      ctrl.updateStalled(false);\n      if (random().nextBoolean()) {\n        Thread.yield();\n      } else {\n        Thread.sleep(1);\n      }\n      \n    }\n    join(stallThreads, 100);\n    \n  }\n\n","sourceOld":"  public void testRandom() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    ctrl.updateStalled(false);\n    \n    Thread[] stallThreads = new Thread[atLeast(3)];\n    for (int i = 0; i < stallThreads.length; i++) {\n      final int threadId = i;\n      final int stallProbability = 1 +random().nextInt(10);\n      stallThreads[i] = new Thread() {\n        public void run() {\n\n          int iters = atLeast(1000);\n          for (int j = 0; j < iters; j++) {\n            ctrl.updateStalled(random().nextInt(stallProbability) == 0);\n            if (random().nextInt(5) == 0) { // thread 0 only updates\n              ctrl.waitIfStalled();\n            }\n          }\n        }\n      };\n    }\n    start(stallThreads);\n    long time = System.currentTimeMillis();\n    /*\n     * use a 100 sec timeout to make sure we not hang forever. join will fail in\n     * that case\n     */\n    while ((System.currentTimeMillis() - time) < 100 * 1000\n        && !terminated(stallThreads)) {\n      ctrl.updateStalled(false);\n      if (random().nextBoolean()) {\n        Thread.yield();\n      } else {\n        Thread.sleep(1);\n      }\n      \n    }\n    join(stallThreads, 100);\n    \n  }\n\n","bugFix":["f31d1f3a9bc5a99a8d7f3110bab36210e7d967c6"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testRandom().mjava","sourceNew":"  public void testRandom() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    ctrl.updateStalled(false);\n    \n    Thread[] stallThreads = new Thread[atLeast(3)];\n    for (int i = 0; i < stallThreads.length; i++) {\n      final int stallProbability = 1 +random().nextInt(10);\n      stallThreads[i] = new Thread() {\n        public void run() {\n\n          int iters = atLeast(1000);\n          for (int j = 0; j < iters; j++) {\n            ctrl.updateStalled(random().nextInt(stallProbability) == 0);\n            if (random().nextInt(5) == 0) { // thread 0 only updates\n              ctrl.waitIfStalled();\n            }\n          }\n        }\n      };\n    }\n    start(stallThreads);\n    long time = System.currentTimeMillis();\n    /*\n     * use a 100 sec timeout to make sure we not hang forever. join will fail in\n     * that case\n     */\n    while ((System.currentTimeMillis() - time) < 100 * 1000\n        && !terminated(stallThreads)) {\n      ctrl.updateStalled(false);\n      if (random().nextBoolean()) {\n        Thread.yield();\n      } else {\n        Thread.sleep(1);\n      }\n      \n    }\n    join(stallThreads, 100);\n    \n  }\n\n","sourceOld":"  public void testRandom() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n    memCtrl.limit = 1000;\n    memCtrl.netBytes = 1;\n    ctrl.updateStalled(memCtrl);\n    Thread[] stallThreads = new Thread[atLeast(3)];\n    for (int i = 0; i < stallThreads.length; i++) {\n      final int threadId = i;\n      stallThreads[i] = new Thread() {\n        public void run() {\n          int baseBytes = threadId % 2 == 0 ? 500 : 700;\n          SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n          memCtrl.limit = 1000;\n          memCtrl.netBytes = 1;\n          memCtrl.flushBytes = 0;\n\n          int iters = atLeast(1000);\n          for (int j = 0; j < iters; j++) {\n            memCtrl.netBytes = baseBytes + random().nextInt(1000);\n            memCtrl.flushBytes = random().nextInt((int)memCtrl.netBytes);\n            ctrl.updateStalled(memCtrl);\n            if (random().nextInt(5) == 0) { // thread 0 only updates\n              ctrl.waitIfStalled();\n            }\n          }\n        }\n      };\n    }\n    start(stallThreads);\n    long time = System.currentTimeMillis();\n    /*\n     * use a 100 sec timeout to make sure we not hang forever. join will fail in\n     * that case\n     */\n    while ((System.currentTimeMillis() - time) < 100 * 1000\n        && !terminated(stallThreads)) {\n      ctrl.updateStalled(memCtrl);\n      if (random().nextBoolean()) {\n        Thread.yield();\n      } else {\n        Thread.sleep(1);\n      }\n      \n    }\n    join(stallThreads, 100);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61a1004502370815d01bf1b70296c08d563033fe","date":1349367697,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testRandom().mjava","sourceNew":"  public void testRandom() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    ctrl.updateStalled(false);\n    \n    Thread[] stallThreads = new Thread[atLeast(3)];\n    for (int i = 0; i < stallThreads.length; i++) {\n      final int stallProbability = 1 +random().nextInt(10);\n      stallThreads[i] = new Thread() {\n        public void run() {\n\n          int iters = atLeast(1000);\n          for (int j = 0; j < iters; j++) {\n            ctrl.updateStalled(random().nextInt(stallProbability) == 0);\n            if (random().nextInt(5) == 0) { // thread 0 only updates\n              ctrl.waitIfStalled();\n            }\n          }\n        }\n      };\n    }\n    start(stallThreads);\n    long time = System.currentTimeMillis();\n    /*\n     * use a 100 sec timeout to make sure we not hang forever. join will fail in\n     * that case\n     */\n    while ((System.currentTimeMillis() - time) < 100 * 1000\n        && !terminated(stallThreads)) {\n      ctrl.updateStalled(false);\n      if (random().nextBoolean()) {\n        Thread.yield();\n      } else {\n        Thread.sleep(1);\n      }\n      \n    }\n    join(stallThreads);\n    \n  }\n\n","sourceOld":"  public void testRandom() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    ctrl.updateStalled(false);\n    \n    Thread[] stallThreads = new Thread[atLeast(3)];\n    for (int i = 0; i < stallThreads.length; i++) {\n      final int stallProbability = 1 +random().nextInt(10);\n      stallThreads[i] = new Thread() {\n        public void run() {\n\n          int iters = atLeast(1000);\n          for (int j = 0; j < iters; j++) {\n            ctrl.updateStalled(random().nextInt(stallProbability) == 0);\n            if (random().nextInt(5) == 0) { // thread 0 only updates\n              ctrl.waitIfStalled();\n            }\n          }\n        }\n      };\n    }\n    start(stallThreads);\n    long time = System.currentTimeMillis();\n    /*\n     * use a 100 sec timeout to make sure we not hang forever. join will fail in\n     * that case\n     */\n    while ((System.currentTimeMillis() - time) < 100 * 1000\n        && !terminated(stallThreads)) {\n      ctrl.updateStalled(false);\n      if (random().nextBoolean()) {\n        Thread.yield();\n      } else {\n        Thread.sleep(1);\n      }\n      \n    }\n    join(stallThreads, 100);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testRandom().mjava","sourceNew":"  public void testRandom() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    ctrl.updateStalled(false);\n    \n    Thread[] stallThreads = new Thread[atLeast(3)];\n    for (int i = 0; i < stallThreads.length; i++) {\n      final int stallProbability = 1 +random().nextInt(10);\n      stallThreads[i] = new Thread() {\n        @Override\n        public void run() {\n\n          int iters = atLeast(1000);\n          for (int j = 0; j < iters; j++) {\n            ctrl.updateStalled(random().nextInt(stallProbability) == 0);\n            if (random().nextInt(5) == 0) { // thread 0 only updates\n              ctrl.waitIfStalled();\n            }\n          }\n        }\n      };\n    }\n    start(stallThreads);\n    long time = System.currentTimeMillis();\n    /*\n     * use a 100 sec timeout to make sure we not hang forever. join will fail in\n     * that case\n     */\n    while ((System.currentTimeMillis() - time) < 100 * 1000\n        && !terminated(stallThreads)) {\n      ctrl.updateStalled(false);\n      if (random().nextBoolean()) {\n        Thread.yield();\n      } else {\n        Thread.sleep(1);\n      }\n      \n    }\n    join(stallThreads);\n    \n  }\n\n","sourceOld":"  public void testRandom() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    ctrl.updateStalled(false);\n    \n    Thread[] stallThreads = new Thread[atLeast(3)];\n    for (int i = 0; i < stallThreads.length; i++) {\n      final int stallProbability = 1 +random().nextInt(10);\n      stallThreads[i] = new Thread() {\n        public void run() {\n\n          int iters = atLeast(1000);\n          for (int j = 0; j < iters; j++) {\n            ctrl.updateStalled(random().nextInt(stallProbability) == 0);\n            if (random().nextInt(5) == 0) { // thread 0 only updates\n              ctrl.waitIfStalled();\n            }\n          }\n        }\n      };\n    }\n    start(stallThreads);\n    long time = System.currentTimeMillis();\n    /*\n     * use a 100 sec timeout to make sure we not hang forever. join will fail in\n     * that case\n     */\n    while ((System.currentTimeMillis() - time) < 100 * 1000\n        && !terminated(stallThreads)) {\n      ctrl.updateStalled(false);\n      if (random().nextBoolean()) {\n        Thread.yield();\n      } else {\n        Thread.sleep(1);\n      }\n      \n    }\n    join(stallThreads);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testRandom().mjava","sourceNew":"  public void testRandom() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    ctrl.updateStalled(false);\n    \n    Thread[] stallThreads = new Thread[atLeast(3)];\n    for (int i = 0; i < stallThreads.length; i++) {\n      final int stallProbability = 1 +random().nextInt(10);\n      stallThreads[i] = new Thread() {\n        @Override\n        public void run() {\n\n          int iters = atLeast(1000);\n          for (int j = 0; j < iters; j++) {\n            ctrl.updateStalled(random().nextInt(stallProbability) == 0);\n            if (random().nextInt(5) == 0) { // thread 0 only updates\n              ctrl.waitIfStalled();\n            }\n          }\n        }\n      };\n    }\n    start(stallThreads);\n    long time = System.currentTimeMillis();\n    /*\n     * use a 100 sec timeout to make sure we not hang forever. join will fail in\n     * that case\n     */\n    while ((System.currentTimeMillis() - time) < 100 * 1000\n        && !terminated(stallThreads)) {\n      ctrl.updateStalled(false);\n      if (random().nextBoolean()) {\n        Thread.yield();\n      } else {\n        Thread.sleep(1);\n      }\n      \n    }\n    join(stallThreads);\n    \n  }\n\n","sourceOld":"  public void testRandom() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    ctrl.updateStalled(false);\n    \n    Thread[] stallThreads = new Thread[atLeast(3)];\n    for (int i = 0; i < stallThreads.length; i++) {\n      final int stallProbability = 1 +random().nextInt(10);\n      stallThreads[i] = new Thread() {\n        public void run() {\n\n          int iters = atLeast(1000);\n          for (int j = 0; j < iters; j++) {\n            ctrl.updateStalled(random().nextInt(stallProbability) == 0);\n            if (random().nextInt(5) == 0) { // thread 0 only updates\n              ctrl.waitIfStalled();\n            }\n          }\n        }\n      };\n    }\n    start(stallThreads);\n    long time = System.currentTimeMillis();\n    /*\n     * use a 100 sec timeout to make sure we not hang forever. join will fail in\n     * that case\n     */\n    while ((System.currentTimeMillis() - time) < 100 * 1000\n        && !terminated(stallThreads)) {\n      ctrl.updateStalled(false);\n      if (random().nextBoolean()) {\n        Thread.yield();\n      } else {\n        Thread.sleep(1);\n      }\n      \n    }\n    join(stallThreads);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bbd7967e39613fd5cfff97ca0eee81b1028a85d1","date":1422628745,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testRandom().mjava","sourceNew":"  public void testRandom() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl(newIndexWriterConfig());\n    ctrl.updateStalled(false);\n    \n    Thread[] stallThreads = new Thread[atLeast(3)];\n    for (int i = 0; i < stallThreads.length; i++) {\n      final int stallProbability = 1 +random().nextInt(10);\n      stallThreads[i] = new Thread() {\n        @Override\n        public void run() {\n\n          int iters = atLeast(1000);\n          for (int j = 0; j < iters; j++) {\n            ctrl.updateStalled(random().nextInt(stallProbability) == 0);\n            if (random().nextInt(5) == 0) { // thread 0 only updates\n              ctrl.waitIfStalled();\n            }\n          }\n        }\n      };\n    }\n    start(stallThreads);\n    long time = System.currentTimeMillis();\n    /*\n     * use a 100 sec timeout to make sure we not hang forever. join will fail in\n     * that case\n     */\n    while ((System.currentTimeMillis() - time) < 100 * 1000\n        && !terminated(stallThreads)) {\n      ctrl.updateStalled(false);\n      if (random().nextBoolean()) {\n        Thread.yield();\n      } else {\n        Thread.sleep(1);\n      }\n      \n    }\n    join(stallThreads);\n    \n  }\n\n","sourceOld":"  public void testRandom() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    ctrl.updateStalled(false);\n    \n    Thread[] stallThreads = new Thread[atLeast(3)];\n    for (int i = 0; i < stallThreads.length; i++) {\n      final int stallProbability = 1 +random().nextInt(10);\n      stallThreads[i] = new Thread() {\n        @Override\n        public void run() {\n\n          int iters = atLeast(1000);\n          for (int j = 0; j < iters; j++) {\n            ctrl.updateStalled(random().nextInt(stallProbability) == 0);\n            if (random().nextInt(5) == 0) { // thread 0 only updates\n              ctrl.waitIfStalled();\n            }\n          }\n        }\n      };\n    }\n    start(stallThreads);\n    long time = System.currentTimeMillis();\n    /*\n     * use a 100 sec timeout to make sure we not hang forever. join will fail in\n     * that case\n     */\n    while ((System.currentTimeMillis() - time) < 100 * 1000\n        && !terminated(stallThreads)) {\n      ctrl.updateStalled(false);\n      if (random().nextBoolean()) {\n        Thread.yield();\n      } else {\n        Thread.sleep(1);\n      }\n      \n    }\n    join(stallThreads);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"be382406ee6e8449e49c082b50c31367e7add702","date":1469488703,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testRandom().mjava","sourceNew":"  public void testRandom() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    ctrl.updateStalled(false);\n    \n    Thread[] stallThreads = new Thread[atLeast(3)];\n    for (int i = 0; i < stallThreads.length; i++) {\n      final int stallProbability = 1 +random().nextInt(10);\n      stallThreads[i] = new Thread() {\n        @Override\n        public void run() {\n\n          int iters = atLeast(1000);\n          for (int j = 0; j < iters; j++) {\n            ctrl.updateStalled(random().nextInt(stallProbability) == 0);\n            if (random().nextInt(5) == 0) { // thread 0 only updates\n              ctrl.waitIfStalled();\n            }\n          }\n        }\n      };\n    }\n    start(stallThreads);\n    long time = System.currentTimeMillis();\n    /*\n     * use a 100 sec timeout to make sure we not hang forever. join will fail in\n     * that case\n     */\n    while ((System.currentTimeMillis() - time) < 100 * 1000\n        && !terminated(stallThreads)) {\n      ctrl.updateStalled(false);\n      if (random().nextBoolean()) {\n        Thread.yield();\n      } else {\n        Thread.sleep(1);\n      }\n      \n    }\n    join(stallThreads);\n    \n  }\n\n","sourceOld":"  public void testRandom() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl(newIndexWriterConfig());\n    ctrl.updateStalled(false);\n    \n    Thread[] stallThreads = new Thread[atLeast(3)];\n    for (int i = 0; i < stallThreads.length; i++) {\n      final int stallProbability = 1 +random().nextInt(10);\n      stallThreads[i] = new Thread() {\n        @Override\n        public void run() {\n\n          int iters = atLeast(1000);\n          for (int j = 0; j < iters; j++) {\n            ctrl.updateStalled(random().nextInt(stallProbability) == 0);\n            if (random().nextInt(5) == 0) { // thread 0 only updates\n              ctrl.waitIfStalled();\n            }\n          }\n        }\n      };\n    }\n    start(stallThreads);\n    long time = System.currentTimeMillis();\n    /*\n     * use a 100 sec timeout to make sure we not hang forever. join will fail in\n     * that case\n     */\n    while ((System.currentTimeMillis() - time) < 100 * 1000\n        && !terminated(stallThreads)) {\n      ctrl.updateStalled(false);\n      if (random().nextBoolean()) {\n        Thread.yield();\n      } else {\n        Thread.sleep(1);\n      }\n      \n    }\n    join(stallThreads);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d08973aa47f2cf98a588293a53af4e948952ccfb","date":1469518724,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testRandom().mjava","sourceNew":"  public void testRandom() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    ctrl.updateStalled(false);\n    \n    Thread[] stallThreads = new Thread[atLeast(3)];\n    for (int i = 0; i < stallThreads.length; i++) {\n      final int stallProbability = 1 +random().nextInt(10);\n      stallThreads[i] = new Thread() {\n        @Override\n        public void run() {\n\n          int iters = atLeast(1000);\n          for (int j = 0; j < iters; j++) {\n            ctrl.updateStalled(random().nextInt(stallProbability) == 0);\n            if (random().nextInt(5) == 0) { // thread 0 only updates\n              ctrl.waitIfStalled();\n            }\n          }\n        }\n      };\n    }\n    start(stallThreads);\n    long time = System.currentTimeMillis();\n    /*\n     * use a 100 sec timeout to make sure we not hang forever. join will fail in\n     * that case\n     */\n    while ((System.currentTimeMillis() - time) < 100 * 1000\n        && !terminated(stallThreads)) {\n      ctrl.updateStalled(false);\n      if (random().nextBoolean()) {\n        Thread.yield();\n      } else {\n        Thread.sleep(1);\n      }\n      \n    }\n    join(stallThreads);\n    \n  }\n\n","sourceOld":"  public void testRandom() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl(newIndexWriterConfig());\n    ctrl.updateStalled(false);\n    \n    Thread[] stallThreads = new Thread[atLeast(3)];\n    for (int i = 0; i < stallThreads.length; i++) {\n      final int stallProbability = 1 +random().nextInt(10);\n      stallThreads[i] = new Thread() {\n        @Override\n        public void run() {\n\n          int iters = atLeast(1000);\n          for (int j = 0; j < iters; j++) {\n            ctrl.updateStalled(random().nextInt(stallProbability) == 0);\n            if (random().nextInt(5) == 0) { // thread 0 only updates\n              ctrl.waitIfStalled();\n            }\n          }\n        }\n      };\n    }\n    start(stallThreads);\n    long time = System.currentTimeMillis();\n    /*\n     * use a 100 sec timeout to make sure we not hang forever. join will fail in\n     * that case\n     */\n    while ((System.currentTimeMillis() - time) < 100 * 1000\n        && !terminated(stallThreads)) {\n      ctrl.updateStalled(false);\n      if (random().nextBoolean()) {\n        Thread.yield();\n      } else {\n        Thread.sleep(1);\n      }\n      \n    }\n    join(stallThreads);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testRandom().mjava","sourceNew":"  public void testRandom() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    ctrl.updateStalled(false);\n    \n    Thread[] stallThreads = new Thread[atLeast(3)];\n    for (int i = 0; i < stallThreads.length; i++) {\n      final int stallProbability = 1 +random().nextInt(10);\n      stallThreads[i] = new Thread() {\n        @Override\n        public void run() {\n\n          int iters = atLeast(1000);\n          for (int j = 0; j < iters; j++) {\n            ctrl.updateStalled(random().nextInt(stallProbability) == 0);\n            if (random().nextInt(5) == 0) { // thread 0 only updates\n              ctrl.waitIfStalled();\n            }\n          }\n        }\n      };\n    }\n    start(stallThreads);\n    long time = System.currentTimeMillis();\n    /*\n     * use a 100 sec timeout to make sure we not hang forever. join will fail in\n     * that case\n     */\n    while ((System.currentTimeMillis() - time) < 100 * 1000\n        && !terminated(stallThreads)) {\n      ctrl.updateStalled(false);\n      if (random().nextBoolean()) {\n        Thread.yield();\n      } else {\n        Thread.sleep(1);\n      }\n      \n    }\n    join(stallThreads);\n    \n  }\n\n","sourceOld":"  public void testRandom() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl(newIndexWriterConfig());\n    ctrl.updateStalled(false);\n    \n    Thread[] stallThreads = new Thread[atLeast(3)];\n    for (int i = 0; i < stallThreads.length; i++) {\n      final int stallProbability = 1 +random().nextInt(10);\n      stallThreads[i] = new Thread() {\n        @Override\n        public void run() {\n\n          int iters = atLeast(1000);\n          for (int j = 0; j < iters; j++) {\n            ctrl.updateStalled(random().nextInt(stallProbability) == 0);\n            if (random().nextInt(5) == 0) { // thread 0 only updates\n              ctrl.waitIfStalled();\n            }\n          }\n        }\n      };\n    }\n    start(stallThreads);\n    long time = System.currentTimeMillis();\n    /*\n     * use a 100 sec timeout to make sure we not hang forever. join will fail in\n     * that case\n     */\n    while ((System.currentTimeMillis() - time) < 100 * 1000\n        && !terminated(stallThreads)) {\n      ctrl.updateStalled(false);\n      if (random().nextBoolean()) {\n        Thread.yield();\n      } else {\n        Thread.sleep(1);\n      }\n      \n    }\n    join(stallThreads);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["61a1004502370815d01bf1b70296c08d563033fe","7530de27b87b961b51f01bd1299b7004d46e8823"],"5e38f40562eb7c165ae08ab2367a031883138354":["7a0bb7b6eeee9103dc4c7cb2dfd62a9a41894fc2"],"f31d1f3a9bc5a99a8d7f3110bab36210e7d967c6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b0b7352903525839fa9ecf337b5a5e90ea91f243":["5e38f40562eb7c165ae08ab2367a031883138354"],"7a0bb7b6eeee9103dc4c7cb2dfd62a9a41894fc2":["f31d1f3a9bc5a99a8d7f3110bab36210e7d967c6"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["bbd7967e39613fd5cfff97ca0eee81b1028a85d1","d08973aa47f2cf98a588293a53af4e948952ccfb"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["7a0bb7b6eeee9103dc4c7cb2dfd62a9a41894fc2","b0b7352903525839fa9ecf337b5a5e90ea91f243"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"be382406ee6e8449e49c082b50c31367e7add702":["bbd7967e39613fd5cfff97ca0eee81b1028a85d1"],"3599646b4d4c346cf74d334813488b8b337b5bf5":["ef0d8a69209261514c5739c770bba706c2308450","7a0bb7b6eeee9103dc4c7cb2dfd62a9a41894fc2"],"7530de27b87b961b51f01bd1299b7004d46e8823":["61a1004502370815d01bf1b70296c08d563033fe"],"61a1004502370815d01bf1b70296c08d563033fe":["b0b7352903525839fa9ecf337b5a5e90ea91f243"],"d08973aa47f2cf98a588293a53af4e948952ccfb":["bbd7967e39613fd5cfff97ca0eee81b1028a85d1","be382406ee6e8449e49c082b50c31367e7add702"],"ef0d8a69209261514c5739c770bba706c2308450":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f31d1f3a9bc5a99a8d7f3110bab36210e7d967c6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d08973aa47f2cf98a588293a53af4e948952ccfb"],"bbd7967e39613fd5cfff97ca0eee81b1028a85d1":["7530de27b87b961b51f01bd1299b7004d46e8823"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"5e38f40562eb7c165ae08ab2367a031883138354":["b0b7352903525839fa9ecf337b5a5e90ea91f243"],"f31d1f3a9bc5a99a8d7f3110bab36210e7d967c6":["7a0bb7b6eeee9103dc4c7cb2dfd62a9a41894fc2","ef0d8a69209261514c5739c770bba706c2308450"],"b0b7352903525839fa9ecf337b5a5e90ea91f243":["fe33227f6805edab2036cbb80645cc4e2d1fa424","61a1004502370815d01bf1b70296c08d563033fe"],"7a0bb7b6eeee9103dc4c7cb2dfd62a9a41894fc2":["5e38f40562eb7c165ae08ab2367a031883138354","fe33227f6805edab2036cbb80645cc4e2d1fa424","3599646b4d4c346cf74d334813488b8b337b5bf5"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f31d1f3a9bc5a99a8d7f3110bab36210e7d967c6","ef0d8a69209261514c5739c770bba706c2308450"],"be382406ee6e8449e49c082b50c31367e7add702":["d08973aa47f2cf98a588293a53af4e948952ccfb"],"3599646b4d4c346cf74d334813488b8b337b5bf5":[],"61a1004502370815d01bf1b70296c08d563033fe":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7530de27b87b961b51f01bd1299b7004d46e8823"],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","bbd7967e39613fd5cfff97ca0eee81b1028a85d1"],"d08973aa47f2cf98a588293a53af4e948952ccfb":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ef0d8a69209261514c5739c770bba706c2308450":["3599646b4d4c346cf74d334813488b8b337b5bf5"],"bbd7967e39613fd5cfff97ca0eee81b1028a85d1":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","be382406ee6e8449e49c082b50c31367e7add702","d08973aa47f2cf98a588293a53af4e948952ccfb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","fe33227f6805edab2036cbb80645cc4e2d1fa424","3599646b4d4c346cf74d334813488b8b337b5bf5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}