{"path":"solr/core/src/test/org/apache/solr/cloud/ReplicaPropertiesBase#verifyUnique(CloudSolrServer,String,String,boolean).mjava","commits":[{"id":"64707d25b6352cf02909d3916038a3b3cec7f0a8","date":1412782122,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReplicaPropertiesBase#verifyUnique(CloudSolrServer,String,String,boolean).mjava","pathOld":"/dev/null","sourceNew":"  void verifyUnique(CloudSolrServer client, String collectionName, String property, boolean balanced)\n      throws KeeperException, InterruptedException {\n\n    DocCollection col = null;\n    for (int idx = 0; idx < 300; ++idx) {\n      client.getZkStateReader().updateClusterState(true);\n      ClusterState clusterState = client.getZkStateReader().getClusterState();\n\n      col = clusterState.getCollection(collectionName);\n      if (col == null) {\n        fail(\"Could not find collection \" + collectionName);\n      }\n      Map<String, Integer> counts = new HashMap<>();\n      Set<String> uniqueNodes = new HashSet<>();\n      boolean allSlicesHaveProp = true;\n      boolean badSlice = false;\n      for (Slice slice : col.getSlices()) {\n        boolean thisSliceHasProp = false;\n        int propCount = 0;\n        for (Replica replica : slice.getReplicas()) {\n          uniqueNodes.add(replica.getNodeName());\n          String propVal = replica.getStr(property);\n          if (StringUtils.isNotBlank(propVal)) {\n            ++propCount;\n            if (counts.containsKey(replica.getNodeName()) == false) {\n              counts.put(replica.getNodeName(), 0);\n            }\n            int count = counts.get(replica.getNodeName());\n            thisSliceHasProp = true;\n            counts.put(replica.getNodeName(), count + 1);\n          }\n        }\n        badSlice = (propCount > 1) ? true : badSlice;\n        allSlicesHaveProp = allSlicesHaveProp ? thisSliceHasProp : allSlicesHaveProp;\n      }\n      if (balanced == false && badSlice == false) {\n        return;\n      }\n      if (allSlicesHaveProp && balanced) {\n        // Check that the properties are evenly distributed.\n        int minProps = col.getSlices().size() / uniqueNodes.size();\n        int maxProps = minProps;\n\n        if (col.getSlices().size() % uniqueNodes.size() > 0) {\n          ++maxProps;\n        }\n        boolean doSleep = false;\n        for (Map.Entry<String, Integer> ent : counts.entrySet()) {\n          if (ent.getValue() != minProps && ent.getValue() != maxProps) {\n            doSleep = true;\n          }\n        }\n\n        if (doSleep == false) {\n          assertTrue(\"We really shouldn't be calling this if there is no node with the property \" + property,\n              counts.size() > 0);\n          return;\n        }\n      }\n      Thread.sleep(100);\n    }\n    fail(\"Collection \" + collectionName + \" does not have roles evenly distributed. Collection is: \" + col.toString());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReplicaPropertiesBase#verifyUnique(CloudSolrServer,String,String,boolean).mjava","pathOld":"/dev/null","sourceNew":"  void verifyUnique(CloudSolrServer client, String collectionName, String property, boolean balanced)\n      throws KeeperException, InterruptedException {\n\n    DocCollection col = null;\n    for (int idx = 0; idx < 300; ++idx) {\n      client.getZkStateReader().updateClusterState(true);\n      ClusterState clusterState = client.getZkStateReader().getClusterState();\n\n      col = clusterState.getCollection(collectionName);\n      if (col == null) {\n        fail(\"Could not find collection \" + collectionName);\n      }\n      Map<String, Integer> counts = new HashMap<>();\n      Set<String> uniqueNodes = new HashSet<>();\n      boolean allSlicesHaveProp = true;\n      boolean badSlice = false;\n      for (Slice slice : col.getSlices()) {\n        boolean thisSliceHasProp = false;\n        int propCount = 0;\n        for (Replica replica : slice.getReplicas()) {\n          uniqueNodes.add(replica.getNodeName());\n          String propVal = replica.getStr(property);\n          if (StringUtils.isNotBlank(propVal)) {\n            ++propCount;\n            if (counts.containsKey(replica.getNodeName()) == false) {\n              counts.put(replica.getNodeName(), 0);\n            }\n            int count = counts.get(replica.getNodeName());\n            thisSliceHasProp = true;\n            counts.put(replica.getNodeName(), count + 1);\n          }\n        }\n        badSlice = (propCount > 1) ? true : badSlice;\n        allSlicesHaveProp = allSlicesHaveProp ? thisSliceHasProp : allSlicesHaveProp;\n      }\n      if (balanced == false && badSlice == false) {\n        return;\n      }\n      if (allSlicesHaveProp && balanced) {\n        // Check that the properties are evenly distributed.\n        int minProps = col.getSlices().size() / uniqueNodes.size();\n        int maxProps = minProps;\n\n        if (col.getSlices().size() % uniqueNodes.size() > 0) {\n          ++maxProps;\n        }\n        boolean doSleep = false;\n        for (Map.Entry<String, Integer> ent : counts.entrySet()) {\n          if (ent.getValue() != minProps && ent.getValue() != maxProps) {\n            doSleep = true;\n          }\n        }\n\n        if (doSleep == false) {\n          assertTrue(\"We really shouldn't be calling this if there is no node with the property \" + property,\n              counts.size() > 0);\n          return;\n        }\n      }\n      Thread.sleep(100);\n    }\n    fail(\"Collection \" + collectionName + \" does not have roles evenly distributed. Collection is: \" + col.toString());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ec3dbdc850ca18bf4aef9acb85f2ea0554306d","date":1419896224,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReplicaPropertiesBase#verifyUnique(CloudSolrServer,String,String,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReplicaPropertiesBase#verifyUnique(CloudSolrServer,String,String,boolean).mjava","sourceNew":"  public static void verifyUnique(CloudSolrServer client, String collectionName, String property, boolean balanced)\n      throws KeeperException, InterruptedException {\n\n    DocCollection col = null;\n    for (int idx = 0; idx < 300; ++idx) {\n      client.getZkStateReader().updateClusterState(true);\n      ClusterState clusterState = client.getZkStateReader().getClusterState();\n\n      col = clusterState.getCollection(collectionName);\n      if (col == null) {\n        fail(\"Could not find collection \" + collectionName);\n      }\n      Map<String, Integer> counts = new HashMap<>();\n      Set<String> uniqueNodes = new HashSet<>();\n      boolean allSlicesHaveProp = true;\n      boolean badSlice = false;\n      for (Slice slice : col.getSlices()) {\n        boolean thisSliceHasProp = false;\n        int propCount = 0;\n        for (Replica replica : slice.getReplicas()) {\n          uniqueNodes.add(replica.getNodeName());\n          String propVal = replica.getStr(property);\n          if (StringUtils.isNotBlank(propVal)) {\n            ++propCount;\n            if (counts.containsKey(replica.getNodeName()) == false) {\n              counts.put(replica.getNodeName(), 0);\n            }\n            int count = counts.get(replica.getNodeName());\n            thisSliceHasProp = true;\n            counts.put(replica.getNodeName(), count + 1);\n          }\n        }\n        badSlice = (propCount > 1) ? true : badSlice;\n        allSlicesHaveProp = allSlicesHaveProp ? thisSliceHasProp : allSlicesHaveProp;\n      }\n      if (balanced == false && badSlice == false) {\n        return;\n      }\n      if (allSlicesHaveProp && balanced) {\n        // Check that the properties are evenly distributed.\n        int minProps = col.getSlices().size() / uniqueNodes.size();\n        int maxProps = minProps;\n\n        if (col.getSlices().size() % uniqueNodes.size() > 0) {\n          ++maxProps;\n        }\n        boolean doSleep = false;\n        for (Map.Entry<String, Integer> ent : counts.entrySet()) {\n          if (ent.getValue() != minProps && ent.getValue() != maxProps) {\n            doSleep = true;\n          }\n        }\n\n        if (doSleep == false) {\n          assertTrue(\"We really shouldn't be calling this if there is no node with the property \" + property,\n              counts.size() > 0);\n          return;\n        }\n      }\n      Thread.sleep(100);\n    }\n    fail(\"Collection \" + collectionName + \" does not have roles evenly distributed. Collection is: \" + col.toString());\n  }\n\n","sourceOld":"  void verifyUnique(CloudSolrServer client, String collectionName, String property, boolean balanced)\n      throws KeeperException, InterruptedException {\n\n    DocCollection col = null;\n    for (int idx = 0; idx < 300; ++idx) {\n      client.getZkStateReader().updateClusterState(true);\n      ClusterState clusterState = client.getZkStateReader().getClusterState();\n\n      col = clusterState.getCollection(collectionName);\n      if (col == null) {\n        fail(\"Could not find collection \" + collectionName);\n      }\n      Map<String, Integer> counts = new HashMap<>();\n      Set<String> uniqueNodes = new HashSet<>();\n      boolean allSlicesHaveProp = true;\n      boolean badSlice = false;\n      for (Slice slice : col.getSlices()) {\n        boolean thisSliceHasProp = false;\n        int propCount = 0;\n        for (Replica replica : slice.getReplicas()) {\n          uniqueNodes.add(replica.getNodeName());\n          String propVal = replica.getStr(property);\n          if (StringUtils.isNotBlank(propVal)) {\n            ++propCount;\n            if (counts.containsKey(replica.getNodeName()) == false) {\n              counts.put(replica.getNodeName(), 0);\n            }\n            int count = counts.get(replica.getNodeName());\n            thisSliceHasProp = true;\n            counts.put(replica.getNodeName(), count + 1);\n          }\n        }\n        badSlice = (propCount > 1) ? true : badSlice;\n        allSlicesHaveProp = allSlicesHaveProp ? thisSliceHasProp : allSlicesHaveProp;\n      }\n      if (balanced == false && badSlice == false) {\n        return;\n      }\n      if (allSlicesHaveProp && balanced) {\n        // Check that the properties are evenly distributed.\n        int minProps = col.getSlices().size() / uniqueNodes.size();\n        int maxProps = minProps;\n\n        if (col.getSlices().size() % uniqueNodes.size() > 0) {\n          ++maxProps;\n        }\n        boolean doSleep = false;\n        for (Map.Entry<String, Integer> ent : counts.entrySet()) {\n          if (ent.getValue() != minProps && ent.getValue() != maxProps) {\n            doSleep = true;\n          }\n        }\n\n        if (doSleep == false) {\n          assertTrue(\"We really shouldn't be calling this if there is no node with the property \" + property,\n              counts.size() > 0);\n          return;\n        }\n      }\n      Thread.sleep(100);\n    }\n    fail(\"Collection \" + collectionName + \" does not have roles evenly distributed. Collection is: \" + col.toString());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReplicaPropertiesBase#verifyUnique(CloudSolrClient,String,String,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReplicaPropertiesBase#verifyUnique(CloudSolrServer,String,String,boolean).mjava","sourceNew":"  public static void verifyUnique(CloudSolrClient client, String collectionName, String property, boolean balanced)\n      throws KeeperException, InterruptedException {\n\n    DocCollection col = null;\n    for (int idx = 0; idx < 300; ++idx) {\n      client.getZkStateReader().updateClusterState(true);\n      ClusterState clusterState = client.getZkStateReader().getClusterState();\n\n      col = clusterState.getCollection(collectionName);\n      if (col == null) {\n        fail(\"Could not find collection \" + collectionName);\n      }\n      Map<String, Integer> counts = new HashMap<>();\n      Set<String> uniqueNodes = new HashSet<>();\n      boolean allSlicesHaveProp = true;\n      boolean badSlice = false;\n      for (Slice slice : col.getSlices()) {\n        boolean thisSliceHasProp = false;\n        int propCount = 0;\n        for (Replica replica : slice.getReplicas()) {\n          uniqueNodes.add(replica.getNodeName());\n          String propVal = replica.getStr(property);\n          if (StringUtils.isNotBlank(propVal)) {\n            ++propCount;\n            if (counts.containsKey(replica.getNodeName()) == false) {\n              counts.put(replica.getNodeName(), 0);\n            }\n            int count = counts.get(replica.getNodeName());\n            thisSliceHasProp = true;\n            counts.put(replica.getNodeName(), count + 1);\n          }\n        }\n        badSlice = (propCount > 1) ? true : badSlice;\n        allSlicesHaveProp = allSlicesHaveProp ? thisSliceHasProp : allSlicesHaveProp;\n      }\n      if (balanced == false && badSlice == false) {\n        return;\n      }\n      if (allSlicesHaveProp && balanced) {\n        // Check that the properties are evenly distributed.\n        int minProps = col.getSlices().size() / uniqueNodes.size();\n        int maxProps = minProps;\n\n        if (col.getSlices().size() % uniqueNodes.size() > 0) {\n          ++maxProps;\n        }\n        boolean doSleep = false;\n        for (Map.Entry<String, Integer> ent : counts.entrySet()) {\n          if (ent.getValue() != minProps && ent.getValue() != maxProps) {\n            doSleep = true;\n          }\n        }\n\n        if (doSleep == false) {\n          assertTrue(\"We really shouldn't be calling this if there is no node with the property \" + property,\n              counts.size() > 0);\n          return;\n        }\n      }\n      Thread.sleep(100);\n    }\n    fail(\"Collection \" + collectionName + \" does not have roles evenly distributed. Collection is: \" + col.toString());\n  }\n\n","sourceOld":"  public static void verifyUnique(CloudSolrServer client, String collectionName, String property, boolean balanced)\n      throws KeeperException, InterruptedException {\n\n    DocCollection col = null;\n    for (int idx = 0; idx < 300; ++idx) {\n      client.getZkStateReader().updateClusterState(true);\n      ClusterState clusterState = client.getZkStateReader().getClusterState();\n\n      col = clusterState.getCollection(collectionName);\n      if (col == null) {\n        fail(\"Could not find collection \" + collectionName);\n      }\n      Map<String, Integer> counts = new HashMap<>();\n      Set<String> uniqueNodes = new HashSet<>();\n      boolean allSlicesHaveProp = true;\n      boolean badSlice = false;\n      for (Slice slice : col.getSlices()) {\n        boolean thisSliceHasProp = false;\n        int propCount = 0;\n        for (Replica replica : slice.getReplicas()) {\n          uniqueNodes.add(replica.getNodeName());\n          String propVal = replica.getStr(property);\n          if (StringUtils.isNotBlank(propVal)) {\n            ++propCount;\n            if (counts.containsKey(replica.getNodeName()) == false) {\n              counts.put(replica.getNodeName(), 0);\n            }\n            int count = counts.get(replica.getNodeName());\n            thisSliceHasProp = true;\n            counts.put(replica.getNodeName(), count + 1);\n          }\n        }\n        badSlice = (propCount > 1) ? true : badSlice;\n        allSlicesHaveProp = allSlicesHaveProp ? thisSliceHasProp : allSlicesHaveProp;\n      }\n      if (balanced == false && badSlice == false) {\n        return;\n      }\n      if (allSlicesHaveProp && balanced) {\n        // Check that the properties are evenly distributed.\n        int minProps = col.getSlices().size() / uniqueNodes.size();\n        int maxProps = minProps;\n\n        if (col.getSlices().size() % uniqueNodes.size() > 0) {\n          ++maxProps;\n        }\n        boolean doSleep = false;\n        for (Map.Entry<String, Integer> ent : counts.entrySet()) {\n          if (ent.getValue() != minProps && ent.getValue() != maxProps) {\n            doSleep = true;\n          }\n        }\n\n        if (doSleep == false) {\n          assertTrue(\"We really shouldn't be calling this if there is no node with the property \" + property,\n              counts.size() > 0);\n          return;\n        }\n      }\n      Thread.sleep(100);\n    }\n    fail(\"Collection \" + collectionName + \" does not have roles evenly distributed. Collection is: \" + col.toString());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"55980207f1977bd1463465de1659b821347e2fa8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","64707d25b6352cf02909d3916038a3b3cec7f0a8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"64707d25b6352cf02909d3916038a3b3cec7f0a8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"bafca15d8e408346a67f4282ad1143b88023893b":["d0ec3dbdc850ca18bf4aef9acb85f2ea0554306d"],"d0ec3dbdc850ca18bf4aef9acb85f2ea0554306d":["64707d25b6352cf02909d3916038a3b3cec7f0a8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bafca15d8e408346a67f4282ad1143b88023893b"]},"commit2Childs":{"55980207f1977bd1463465de1659b821347e2fa8":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["55980207f1977bd1463465de1659b821347e2fa8","64707d25b6352cf02909d3916038a3b3cec7f0a8"],"64707d25b6352cf02909d3916038a3b3cec7f0a8":["55980207f1977bd1463465de1659b821347e2fa8","d0ec3dbdc850ca18bf4aef9acb85f2ea0554306d"],"bafca15d8e408346a67f4282ad1143b88023893b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d0ec3dbdc850ca18bf4aef9acb85f2ea0554306d":["bafca15d8e408346a67f4282ad1143b88023893b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["55980207f1977bd1463465de1659b821347e2fa8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}