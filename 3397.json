{"path":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,LegacyNumericType,Query,IndexSearcher,ScoreMode).mjava","commits":[{"id":"770342641f7b505eaa8dccdc666158bff2419109","date":1449868421,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,LegacyNumericType,Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,NumericType,Query,IndexSearcher,ScoreMode).mjava","sourceNew":"  /**\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs and ints. \n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link org.apache.lucene.document.LegacyIntField} or {@link org.apache.lucene.document.LegacyLongField}\n   * @param numericType               either {@link org.apache.lucene.document.FieldType.LegacyNumericType#INT} or {@link org.apache.lucene.document.FieldType.LegacyNumericType#LONG}, it should correspond to fromField and toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  \n  public static Query createJoinQuery(String fromField,\n      boolean multipleValuesPerDocument,\n      String toField, LegacyNumericType numericType,\n      Query fromQuery,\n      IndexSearcher fromSearcher,\n      ScoreMode scoreMode) throws IOException {\n    \n    final GenericTermsCollector termsCollector;\n     \n    if (multipleValuesPerDocument) {\n      Function<SortedSetDocValues> mvFunction = DocValuesTermsCollector.sortedNumericAsSortedSetDocValues(fromField,numericType);\n      termsCollector = GenericTermsCollector.createCollectorMV(mvFunction, scoreMode);\n    } else {\n      Function<BinaryDocValues> svFunction = DocValuesTermsCollector.numericAsBinaryDocValues(fromField,numericType);\n      termsCollector =  GenericTermsCollector.createCollectorSV(svFunction, scoreMode);\n    }\n    \n    return createJoinQuery(multipleValuesPerDocument, toField, fromQuery, fromSearcher, scoreMode,\n        termsCollector);\n    \n  }\n\n","sourceOld":"  /**\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs and ints. \n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link IntField} or {@link LongField}\n   * @param numericType               either {@link NumericType#INT} or {@link NumericType#LONG}, it should correspond to fromField and toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  \n  public static Query createJoinQuery(String fromField,\n      boolean multipleValuesPerDocument,\n      String toField, NumericType numericType,\n      Query fromQuery,\n      IndexSearcher fromSearcher,\n      ScoreMode scoreMode) throws IOException {\n    \n    final GenericTermsCollector termsCollector;\n     \n    if (multipleValuesPerDocument) {\n      Function<SortedSetDocValues> mvFunction = DocValuesTermsCollector.sortedNumericAsSortedSetDocValues(fromField,numericType);\n      termsCollector = GenericTermsCollector.createCollectorMV(mvFunction, scoreMode);\n    } else {\n      Function<BinaryDocValues> svFunction = DocValuesTermsCollector.numericAsBinaryDocValues(fromField,numericType);\n      termsCollector =  GenericTermsCollector.createCollectorSV(svFunction, scoreMode);\n    }\n    \n    return createJoinQuery(multipleValuesPerDocument, toField, fromQuery, fromSearcher, scoreMode,\n        termsCollector);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0a97513a3a796fa8e709a0dcfec8a2e628e721b","date":1458922983,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,LegacyNumericType,Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,LegacyNumericType,Query,IndexSearcher,ScoreMode).mjava","sourceNew":"  /**\n   * @deprecated Because {@link LegacyNumericType} is deprecated, instead use {@link #createJoinQuery(String, boolean, String, Class, Query, IndexSearcher, ScoreMode)}\n   *\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs and ints. \n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link org.apache.lucene.document.LegacyIntField} or {@link org.apache.lucene.document.LegacyLongField}\n   * @param numericType               either {@link org.apache.lucene.document.FieldType.LegacyNumericType#INT} or {@link org.apache.lucene.document.FieldType.LegacyNumericType#LONG}, it should correspond to fromField and toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  @Deprecated\n  public static Query createJoinQuery(String fromField,\n      boolean multipleValuesPerDocument,\n      String toField, LegacyNumericType numericType,\n      Query fromQuery,\n      IndexSearcher fromSearcher,\n      ScoreMode scoreMode) throws IOException {\n    \n    final GenericTermsCollector termsCollector;\n     \n    if (multipleValuesPerDocument) {\n      Function<SortedSetDocValues> mvFunction = DocValuesTermsCollector.sortedNumericAsSortedSetDocValues(fromField,numericType);\n      termsCollector = GenericTermsCollector.createCollectorMV(mvFunction, scoreMode);\n    } else {\n      Function<BinaryDocValues> svFunction = DocValuesTermsCollector.numericAsBinaryDocValues(fromField,numericType);\n      termsCollector =  GenericTermsCollector.createCollectorSV(svFunction, scoreMode);\n    }\n    \n    return createJoinQuery(multipleValuesPerDocument, toField, fromQuery, fromSearcher, scoreMode,\n        termsCollector);\n    \n  }\n\n","sourceOld":"  /**\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs and ints. \n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link org.apache.lucene.document.LegacyIntField} or {@link org.apache.lucene.document.LegacyLongField}\n   * @param numericType               either {@link org.apache.lucene.document.FieldType.LegacyNumericType#INT} or {@link org.apache.lucene.document.FieldType.LegacyNumericType#LONG}, it should correspond to fromField and toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  \n  public static Query createJoinQuery(String fromField,\n      boolean multipleValuesPerDocument,\n      String toField, LegacyNumericType numericType,\n      Query fromQuery,\n      IndexSearcher fromSearcher,\n      ScoreMode scoreMode) throws IOException {\n    \n    final GenericTermsCollector termsCollector;\n     \n    if (multipleValuesPerDocument) {\n      Function<SortedSetDocValues> mvFunction = DocValuesTermsCollector.sortedNumericAsSortedSetDocValues(fromField,numericType);\n      termsCollector = GenericTermsCollector.createCollectorMV(mvFunction, scoreMode);\n    } else {\n      Function<BinaryDocValues> svFunction = DocValuesTermsCollector.numericAsBinaryDocValues(fromField,numericType);\n      termsCollector =  GenericTermsCollector.createCollectorSV(svFunction, scoreMode);\n    }\n    \n    return createJoinQuery(multipleValuesPerDocument, toField, fromQuery, fromSearcher, scoreMode,\n        termsCollector);\n    \n  }\n\n","bugFix":["af3f3d3f7a6a159ccf14d58544fd71ae72c89b10"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5af5ba0166322092193d4c29880b0f7670fc7ca0","date":1471440525,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,LegacyNumericType,Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,LegacyNumericType,Query,IndexSearcher,ScoreMode).mjava","sourceNew":"  /**\n   * @deprecated Because {@link LegacyNumericType} is deprecated, instead use {@link #createJoinQuery(String, boolean, String, Class, Query, IndexSearcher, ScoreMode)}\n   *\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs and ints. \n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link org.apache.lucene.legacy.LegacyIntField} or {@link org.apache.lucene.legacy.LegacyLongField}\n   * @param numericType               either {@link LegacyNumericType#INT} or {@link LegacyNumericType#LONG}, it should correspond to fromField and toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  @Deprecated\n  public static Query createJoinQuery(String fromField,\n      boolean multipleValuesPerDocument,\n      String toField, LegacyNumericType numericType,\n      Query fromQuery,\n      IndexSearcher fromSearcher,\n      ScoreMode scoreMode) throws IOException {\n    \n    final GenericTermsCollector termsCollector;\n     \n    if (multipleValuesPerDocument) {\n      Function<SortedSetDocValues> mvFunction = DocValuesTermsCollector.sortedNumericAsSortedSetDocValues(fromField,numericType);\n      termsCollector = GenericTermsCollector.createCollectorMV(mvFunction, scoreMode);\n    } else {\n      Function<BinaryDocValues> svFunction = DocValuesTermsCollector.numericAsBinaryDocValues(fromField,numericType);\n      termsCollector =  GenericTermsCollector.createCollectorSV(svFunction, scoreMode);\n    }\n    \n    return createJoinQuery(multipleValuesPerDocument, toField, fromQuery, fromSearcher, scoreMode,\n        termsCollector);\n    \n  }\n\n","sourceOld":"  /**\n   * @deprecated Because {@link LegacyNumericType} is deprecated, instead use {@link #createJoinQuery(String, boolean, String, Class, Query, IndexSearcher, ScoreMode)}\n   *\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs and ints. \n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link org.apache.lucene.document.LegacyIntField} or {@link org.apache.lucene.document.LegacyLongField}\n   * @param numericType               either {@link org.apache.lucene.document.FieldType.LegacyNumericType#INT} or {@link org.apache.lucene.document.FieldType.LegacyNumericType#LONG}, it should correspond to fromField and toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  @Deprecated\n  public static Query createJoinQuery(String fromField,\n      boolean multipleValuesPerDocument,\n      String toField, LegacyNumericType numericType,\n      Query fromQuery,\n      IndexSearcher fromSearcher,\n      ScoreMode scoreMode) throws IOException {\n    \n    final GenericTermsCollector termsCollector;\n     \n    if (multipleValuesPerDocument) {\n      Function<SortedSetDocValues> mvFunction = DocValuesTermsCollector.sortedNumericAsSortedSetDocValues(fromField,numericType);\n      termsCollector = GenericTermsCollector.createCollectorMV(mvFunction, scoreMode);\n    } else {\n      Function<BinaryDocValues> svFunction = DocValuesTermsCollector.numericAsBinaryDocValues(fromField,numericType);\n      termsCollector =  GenericTermsCollector.createCollectorSV(svFunction, scoreMode);\n    }\n    \n    return createJoinQuery(multipleValuesPerDocument, toField, fromQuery, fromSearcher, scoreMode,\n        termsCollector);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6","date":1471496851,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,LegacyNumericType,Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,LegacyNumericType,Query,IndexSearcher,ScoreMode).mjava","sourceNew":"  /**\n   * @deprecated Because {@link LegacyNumericType} is deprecated, instead use {@link #createJoinQuery(String, boolean, String, Class, Query, IndexSearcher, ScoreMode)}\n   *\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs and ints. \n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link org.apache.lucene.legacy.LegacyIntField} or {@link org.apache.lucene.legacy.LegacyLongField}\n   * @param numericType               either {@link LegacyNumericType#INT} or {@link LegacyNumericType#LONG}, it should correspond to fromField and toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  @Deprecated\n  public static Query createJoinQuery(String fromField,\n      boolean multipleValuesPerDocument,\n      String toField, LegacyNumericType numericType,\n      Query fromQuery,\n      IndexSearcher fromSearcher,\n      ScoreMode scoreMode) throws IOException {\n    \n    final GenericTermsCollector termsCollector;\n     \n    if (multipleValuesPerDocument) {\n      Function<SortedSetDocValues> mvFunction = DocValuesTermsCollector.sortedNumericAsSortedSetDocValues(fromField,numericType);\n      termsCollector = GenericTermsCollector.createCollectorMV(mvFunction, scoreMode);\n    } else {\n      Function<BinaryDocValues> svFunction = DocValuesTermsCollector.numericAsBinaryDocValues(fromField,numericType);\n      termsCollector =  GenericTermsCollector.createCollectorSV(svFunction, scoreMode);\n    }\n    \n    return createJoinQuery(multipleValuesPerDocument, toField, fromQuery, fromSearcher, scoreMode,\n        termsCollector);\n    \n  }\n\n","sourceOld":"  /**\n   * @deprecated Because {@link LegacyNumericType} is deprecated, instead use {@link #createJoinQuery(String, boolean, String, Class, Query, IndexSearcher, ScoreMode)}\n   *\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs and ints. \n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link org.apache.lucene.document.LegacyIntField} or {@link org.apache.lucene.document.LegacyLongField}\n   * @param numericType               either {@link org.apache.lucene.document.FieldType.LegacyNumericType#INT} or {@link org.apache.lucene.document.FieldType.LegacyNumericType#LONG}, it should correspond to fromField and toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  @Deprecated\n  public static Query createJoinQuery(String fromField,\n      boolean multipleValuesPerDocument,\n      String toField, LegacyNumericType numericType,\n      Query fromQuery,\n      IndexSearcher fromSearcher,\n      ScoreMode scoreMode) throws IOException {\n    \n    final GenericTermsCollector termsCollector;\n     \n    if (multipleValuesPerDocument) {\n      Function<SortedSetDocValues> mvFunction = DocValuesTermsCollector.sortedNumericAsSortedSetDocValues(fromField,numericType);\n      termsCollector = GenericTermsCollector.createCollectorMV(mvFunction, scoreMode);\n    } else {\n      Function<BinaryDocValues> svFunction = DocValuesTermsCollector.numericAsBinaryDocValues(fromField,numericType);\n      termsCollector =  GenericTermsCollector.createCollectorSV(svFunction, scoreMode);\n    }\n    \n    return createJoinQuery(multipleValuesPerDocument, toField, fromQuery, fromSearcher, scoreMode,\n        termsCollector);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"403d05f7f8d69b65659157eff1bc1d2717f04c66","date":1471692961,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,LegacyNumericType,Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,LegacyNumericType,Query,IndexSearcher,ScoreMode).mjava","sourceNew":"  /**\n   * @deprecated Because {@link LegacyNumericType} is deprecated, instead use {@link #createJoinQuery(String, boolean, String, Class, Query, IndexSearcher, ScoreMode)}\n   *\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs and ints. \n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link org.apache.lucene.legacy.LegacyIntField} or {@link org.apache.lucene.legacy.LegacyLongField}\n   * @param numericType               either {@link LegacyNumericType#INT} or {@link LegacyNumericType#LONG}, it should correspond to fromField and toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  @Deprecated\n  public static Query createJoinQuery(String fromField,\n      boolean multipleValuesPerDocument,\n      String toField, LegacyNumericType numericType,\n      Query fromQuery,\n      IndexSearcher fromSearcher,\n      ScoreMode scoreMode) throws IOException {\n    \n    final GenericTermsCollector termsCollector;\n     \n    if (multipleValuesPerDocument) {\n      Function<SortedSetDocValues> mvFunction = DocValuesTermsCollector.sortedNumericAsSortedSetDocValues(fromField,numericType);\n      termsCollector = GenericTermsCollector.createCollectorMV(mvFunction, scoreMode);\n    } else {\n      Function<BinaryDocValues> svFunction = DocValuesTermsCollector.numericAsBinaryDocValues(fromField,numericType);\n      termsCollector =  GenericTermsCollector.createCollectorSV(svFunction, scoreMode);\n    }\n    \n    return createJoinQuery(multipleValuesPerDocument, toField, fromQuery, fromSearcher, scoreMode,\n        termsCollector);\n    \n  }\n\n","sourceOld":"  /**\n   * @deprecated Because {@link LegacyNumericType} is deprecated, instead use {@link #createJoinQuery(String, boolean, String, Class, Query, IndexSearcher, ScoreMode)}\n   *\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs and ints. \n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link org.apache.lucene.document.LegacyIntField} or {@link org.apache.lucene.document.LegacyLongField}\n   * @param numericType               either {@link org.apache.lucene.document.FieldType.LegacyNumericType#INT} or {@link org.apache.lucene.document.FieldType.LegacyNumericType#LONG}, it should correspond to fromField and toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  @Deprecated\n  public static Query createJoinQuery(String fromField,\n      boolean multipleValuesPerDocument,\n      String toField, LegacyNumericType numericType,\n      Query fromQuery,\n      IndexSearcher fromSearcher,\n      ScoreMode scoreMode) throws IOException {\n    \n    final GenericTermsCollector termsCollector;\n     \n    if (multipleValuesPerDocument) {\n      Function<SortedSetDocValues> mvFunction = DocValuesTermsCollector.sortedNumericAsSortedSetDocValues(fromField,numericType);\n      termsCollector = GenericTermsCollector.createCollectorMV(mvFunction, scoreMode);\n    } else {\n      Function<BinaryDocValues> svFunction = DocValuesTermsCollector.numericAsBinaryDocValues(fromField,numericType);\n      termsCollector =  GenericTermsCollector.createCollectorSV(svFunction, scoreMode);\n    }\n    \n    return createJoinQuery(multipleValuesPerDocument, toField, fromQuery, fromSearcher, scoreMode,\n        termsCollector);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"50b8410419cbbe9d8e1a96c918a951976bffe680","date":1471869553,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,LegacyNumericType,Query,IndexSearcher,ScoreMode).mjava","sourceNew":null,"sourceOld":"  /**\n   * @deprecated Because {@link LegacyNumericType} is deprecated, instead use {@link #createJoinQuery(String, boolean, String, Class, Query, IndexSearcher, ScoreMode)}\n   *\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs and ints. \n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link org.apache.lucene.legacy.LegacyIntField} or {@link org.apache.lucene.legacy.LegacyLongField}\n   * @param numericType               either {@link LegacyNumericType#INT} or {@link LegacyNumericType#LONG}, it should correspond to fromField and toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  @Deprecated\n  public static Query createJoinQuery(String fromField,\n      boolean multipleValuesPerDocument,\n      String toField, LegacyNumericType numericType,\n      Query fromQuery,\n      IndexSearcher fromSearcher,\n      ScoreMode scoreMode) throws IOException {\n    \n    final GenericTermsCollector termsCollector;\n     \n    if (multipleValuesPerDocument) {\n      Function<SortedSetDocValues> mvFunction = DocValuesTermsCollector.sortedNumericAsSortedSetDocValues(fromField,numericType);\n      termsCollector = GenericTermsCollector.createCollectorMV(mvFunction, scoreMode);\n    } else {\n      Function<BinaryDocValues> svFunction = DocValuesTermsCollector.numericAsBinaryDocValues(fromField,numericType);\n      termsCollector =  GenericTermsCollector.createCollectorSV(svFunction, scoreMode);\n    }\n    \n    return createJoinQuery(multipleValuesPerDocument, toField, fromQuery, fromSearcher, scoreMode,\n        termsCollector);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0c82557b0a8c9d4012f208e5de912ae7500ea351","date":1471888093,"type":4,"author":"Noble Paul","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,LegacyNumericType,Query,IndexSearcher,ScoreMode).mjava","sourceNew":null,"sourceOld":"  /**\n   * @deprecated Because {@link LegacyNumericType} is deprecated, instead use {@link #createJoinQuery(String, boolean, String, Class, Query, IndexSearcher, ScoreMode)}\n   *\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs and ints. \n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link org.apache.lucene.legacy.LegacyIntField} or {@link org.apache.lucene.legacy.LegacyLongField}\n   * @param numericType               either {@link LegacyNumericType#INT} or {@link LegacyNumericType#LONG}, it should correspond to fromField and toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  @Deprecated\n  public static Query createJoinQuery(String fromField,\n      boolean multipleValuesPerDocument,\n      String toField, LegacyNumericType numericType,\n      Query fromQuery,\n      IndexSearcher fromSearcher,\n      ScoreMode scoreMode) throws IOException {\n    \n    final GenericTermsCollector termsCollector;\n     \n    if (multipleValuesPerDocument) {\n      Function<SortedSetDocValues> mvFunction = DocValuesTermsCollector.sortedNumericAsSortedSetDocValues(fromField,numericType);\n      termsCollector = GenericTermsCollector.createCollectorMV(mvFunction, scoreMode);\n    } else {\n      Function<BinaryDocValues> svFunction = DocValuesTermsCollector.numericAsBinaryDocValues(fromField,numericType);\n      termsCollector =  GenericTermsCollector.createCollectorSV(svFunction, scoreMode);\n    }\n    \n    return createJoinQuery(multipleValuesPerDocument, toField, fromQuery, fromSearcher, scoreMode,\n        termsCollector);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a","date":1472163016,"type":4,"author":"Karl Wright","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,LegacyNumericType,Query,IndexSearcher,ScoreMode).mjava","sourceNew":null,"sourceOld":"  /**\n   * @deprecated Because {@link LegacyNumericType} is deprecated, instead use {@link #createJoinQuery(String, boolean, String, Class, Query, IndexSearcher, ScoreMode)}\n   *\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs and ints. \n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link org.apache.lucene.legacy.LegacyIntField} or {@link org.apache.lucene.legacy.LegacyLongField}\n   * @param numericType               either {@link LegacyNumericType#INT} or {@link LegacyNumericType#LONG}, it should correspond to fromField and toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  @Deprecated\n  public static Query createJoinQuery(String fromField,\n      boolean multipleValuesPerDocument,\n      String toField, LegacyNumericType numericType,\n      Query fromQuery,\n      IndexSearcher fromSearcher,\n      ScoreMode scoreMode) throws IOException {\n    \n    final GenericTermsCollector termsCollector;\n     \n    if (multipleValuesPerDocument) {\n      Function<SortedSetDocValues> mvFunction = DocValuesTermsCollector.sortedNumericAsSortedSetDocValues(fromField,numericType);\n      termsCollector = GenericTermsCollector.createCollectorMV(mvFunction, scoreMode);\n    } else {\n      Function<BinaryDocValues> svFunction = DocValuesTermsCollector.numericAsBinaryDocValues(fromField,numericType);\n      termsCollector =  GenericTermsCollector.createCollectorSV(svFunction, scoreMode);\n    }\n    \n    return createJoinQuery(multipleValuesPerDocument, toField, fromQuery, fromSearcher, scoreMode,\n        termsCollector);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":4,"author":"Kevin Risden","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,LegacyNumericType,Query,IndexSearcher,ScoreMode).mjava","sourceNew":null,"sourceOld":"  /**\n   * @deprecated Because {@link LegacyNumericType} is deprecated, instead use {@link #createJoinQuery(String, boolean, String, Class, Query, IndexSearcher, ScoreMode)}\n   *\n   * Method for query time joining for numeric fields. It supports multi- and single- values longs and ints. \n   * All considerations from {@link JoinUtil#createJoinQuery(String, boolean, String, Query, IndexSearcher, ScoreMode)} are applicable here too,\n   * though memory consumption might be higher.\n   * <p>\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   *                                  when true fromField might be {@link DocValuesType#SORTED_NUMERIC},\n   *                                  otherwise fromField should be {@link DocValuesType#NUMERIC}\n   * @param toField                   The to field to join to, should be {@link org.apache.lucene.document.LegacyIntField} or {@link org.apache.lucene.document.LegacyLongField}\n   * @param numericType               either {@link org.apache.lucene.document.FieldType.LegacyNumericType#INT} or {@link org.apache.lucene.document.FieldType.LegacyNumericType#LONG}, it should correspond to fromField and toField types\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  @Deprecated\n  public static Query createJoinQuery(String fromField,\n      boolean multipleValuesPerDocument,\n      String toField, LegacyNumericType numericType,\n      Query fromQuery,\n      IndexSearcher fromSearcher,\n      ScoreMode scoreMode) throws IOException {\n    \n    final GenericTermsCollector termsCollector;\n     \n    if (multipleValuesPerDocument) {\n      Function<SortedSetDocValues> mvFunction = DocValuesTermsCollector.sortedNumericAsSortedSetDocValues(fromField,numericType);\n      termsCollector = GenericTermsCollector.createCollectorMV(mvFunction, scoreMode);\n    } else {\n      Function<BinaryDocValues> svFunction = DocValuesTermsCollector.numericAsBinaryDocValues(fromField,numericType);\n      termsCollector =  GenericTermsCollector.createCollectorSV(svFunction, scoreMode);\n    }\n    \n    return createJoinQuery(multipleValuesPerDocument, toField, fromQuery, fromSearcher, scoreMode,\n        termsCollector);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"403d05f7f8d69b65659157eff1bc1d2717f04c66":["a0a97513a3a796fa8e709a0dcfec8a2e628e721b","2c8bedceb91e64a3f0e831450058fc4a76d2c0a6"],"a0a97513a3a796fa8e709a0dcfec8a2e628e721b":["770342641f7b505eaa8dccdc666158bff2419109"],"0c82557b0a8c9d4012f208e5de912ae7500ea351":["403d05f7f8d69b65659157eff1bc1d2717f04c66","50b8410419cbbe9d8e1a96c918a951976bffe680"],"50b8410419cbbe9d8e1a96c918a951976bffe680":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5af5ba0166322092193d4c29880b0f7670fc7ca0":["a0a97513a3a796fa8e709a0dcfec8a2e628e721b"],"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6":["a0a97513a3a796fa8e709a0dcfec8a2e628e721b","5af5ba0166322092193d4c29880b0f7670fc7ca0"],"770342641f7b505eaa8dccdc666158bff2419109":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a":["403d05f7f8d69b65659157eff1bc1d2717f04c66","0c82557b0a8c9d4012f208e5de912ae7500ea351"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0a97513a3a796fa8e709a0dcfec8a2e628e721b","e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"]},"commit2Childs":{"403d05f7f8d69b65659157eff1bc1d2717f04c66":["0c82557b0a8c9d4012f208e5de912ae7500ea351","50b8410419cbbe9d8e1a96c918a951976bffe680","e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"a0a97513a3a796fa8e709a0dcfec8a2e628e721b":["403d05f7f8d69b65659157eff1bc1d2717f04c66","5af5ba0166322092193d4c29880b0f7670fc7ca0","2c8bedceb91e64a3f0e831450058fc4a76d2c0a6","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"0c82557b0a8c9d4012f208e5de912ae7500ea351":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"50b8410419cbbe9d8e1a96c918a951976bffe680":["0c82557b0a8c9d4012f208e5de912ae7500ea351"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["770342641f7b505eaa8dccdc666158bff2419109"],"5af5ba0166322092193d4c29880b0f7670fc7ca0":["2c8bedceb91e64a3f0e831450058fc4a76d2c0a6"],"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"770342641f7b505eaa8dccdc666158bff2419109":["a0a97513a3a796fa8e709a0dcfec8a2e628e721b"],"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}