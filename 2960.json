{"path":"solr/core/src/test/org/apache/solr/CursorPagingTest#pruneAndDeterministicallySort(Collection[String]).mjava","commits":[{"id":"6a0f9b793b360e5f5863eef2d4b02a2ddd8b47b4","date":1390935815,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/CursorPagingTest#pruneAndDeterministicallySort(Collection[String]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * <p>\n   * Given a list of field names in the schema, returns an immutable list in \n   * deterministically random order with the following things removed:\n   * </p>\n   * <ul>\n   *  <li><code>_version_</code> is removed</li>\n   *  <li><code>dv_last</code> and <code>dv_first</code> fields are removed \n   *      if the codec doesn't support them</li>\n   * </ul>\n   * @see #defaultCodecSupportsMissingDocValues\n   */\n  public static List<String> pruneAndDeterministicallySort(Collection<String> raw) {\n\n    final boolean prune_dv_missing = ! defaultCodecSupportsMissingDocValues();\n\n    ArrayList<String> names = new ArrayList<String>(37);\n    for (String f : raw) {\n      if (f.equals(\"_version_\")) {\n        continue;\n      }\n      if (prune_dv_missing && (f.endsWith(\"_dv_last\") || f.endsWith(\"_dv_first\")) ) {\n        continue;\n      }\n      names.add(f);\n    }\n\n    Collections.sort(names);\n    Collections.shuffle(names,random());\n    return Collections.<String>unmodifiableList(names);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["402ad3ddc9da7b70da1b167667a60ece6a1381fb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b73878fdd4a16043b65851ffb05b43fa1c7281f7","date":1392065712,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/CursorPagingTest#pruneAndDeterministicallySort(Collection[String]).mjava","pathOld":"solr/core/src/test/org/apache/solr/CursorPagingTest#pruneAndDeterministicallySort(Collection[String]).mjava","sourceNew":"  /**\n   * <p>\n   * Given a list of field names in the schema, returns an immutable list in \n   * deterministically random order with the following things removed:\n   * </p>\n   * <ul>\n   *  <li><code>_version_</code> is removed</li>\n   *  <li>\n   *    <code>*_dv_last</code>, <code>*_dv_first</code> and <code>*_dv</code>\n   *    fields are removed if the codec doesn't support missing DocValues\n   *  </li>\n   * </ul>\n   * @see #defaultCodecSupportsMissingDocValues\n   */\n  public static List<String> pruneAndDeterministicallySort(Collection<String> raw) {\n\n    final boolean prune_dv = ! defaultCodecSupportsMissingDocValues();\n\n    ArrayList<String> names = new ArrayList<String>(37);\n    for (String f : raw) {\n      if (f.equals(\"_version_\")) {\n        continue;\n      }\n      if (prune_dv && (f.endsWith(\"_dv_last\") || f.endsWith(\"_dv_first\"))\n                       || f.endsWith(\"_dv\")) {\n        continue;\n      }\n      names.add(f);\n    }\n\n    Collections.sort(names);\n    Collections.shuffle(names,random());\n    return Collections.<String>unmodifiableList(names);\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * Given a list of field names in the schema, returns an immutable list in \n   * deterministically random order with the following things removed:\n   * </p>\n   * <ul>\n   *  <li><code>_version_</code> is removed</li>\n   *  <li><code>dv_last</code> and <code>dv_first</code> fields are removed \n   *      if the codec doesn't support them</li>\n   * </ul>\n   * @see #defaultCodecSupportsMissingDocValues\n   */\n  public static List<String> pruneAndDeterministicallySort(Collection<String> raw) {\n\n    final boolean prune_dv_missing = ! defaultCodecSupportsMissingDocValues();\n\n    ArrayList<String> names = new ArrayList<String>(37);\n    for (String f : raw) {\n      if (f.equals(\"_version_\")) {\n        continue;\n      }\n      if (prune_dv_missing && (f.endsWith(\"_dv_last\") || f.endsWith(\"_dv_first\")) ) {\n        continue;\n      }\n      names.add(f);\n    }\n\n    Collections.sort(names);\n    Collections.shuffle(names,random());\n    return Collections.<String>unmodifiableList(names);\n  }\n\n","bugFix":null,"bugIntro":["402ad3ddc9da7b70da1b167667a60ece6a1381fb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/CursorPagingTest#pruneAndDeterministicallySort(Collection[String]).mjava","pathOld":"solr/core/src/test/org/apache/solr/CursorPagingTest#pruneAndDeterministicallySort(Collection[String]).mjava","sourceNew":"  /**\n   * <p>\n   * Given a list of field names in the schema, returns an immutable list in \n   * deterministically random order with the following things removed:\n   * </p>\n   * <ul>\n   *  <li><code>_version_</code> is removed</li>\n   *  <li>\n   *    <code>*_dv_last</code>, <code>*_dv_first</code> and <code>*_dv</code>\n   *    fields are removed if the codec doesn't support missing DocValues\n   *  </li>\n   * </ul>\n   * @see #defaultCodecSupportsMissingDocValues\n   */\n  public static List<String> pruneAndDeterministicallySort(Collection<String> raw) {\n\n    final boolean prune_dv = ! defaultCodecSupportsMissingDocValues();\n\n    ArrayList<String> names = new ArrayList<>(37);\n    for (String f : raw) {\n      if (f.equals(\"_version_\")) {\n        continue;\n      }\n      if (prune_dv && (f.endsWith(\"_dv_last\") || f.endsWith(\"_dv_first\"))\n                       || f.endsWith(\"_dv\")) {\n        continue;\n      }\n      names.add(f);\n    }\n\n    Collections.sort(names);\n    Collections.shuffle(names,random());\n    return Collections.<String>unmodifiableList(names);\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * Given a list of field names in the schema, returns an immutable list in \n   * deterministically random order with the following things removed:\n   * </p>\n   * <ul>\n   *  <li><code>_version_</code> is removed</li>\n   *  <li>\n   *    <code>*_dv_last</code>, <code>*_dv_first</code> and <code>*_dv</code>\n   *    fields are removed if the codec doesn't support missing DocValues\n   *  </li>\n   * </ul>\n   * @see #defaultCodecSupportsMissingDocValues\n   */\n  public static List<String> pruneAndDeterministicallySort(Collection<String> raw) {\n\n    final boolean prune_dv = ! defaultCodecSupportsMissingDocValues();\n\n    ArrayList<String> names = new ArrayList<String>(37);\n    for (String f : raw) {\n      if (f.equals(\"_version_\")) {\n        continue;\n      }\n      if (prune_dv && (f.endsWith(\"_dv_last\") || f.endsWith(\"_dv_first\"))\n                       || f.endsWith(\"_dv\")) {\n        continue;\n      }\n      names.add(f);\n    }\n\n    Collections.sort(names);\n    Collections.shuffle(names,random());\n    return Collections.<String>unmodifiableList(names);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad2a673349939e48652bf304cccf673c3412198f","date":1409585169,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/CursorPagingTest#pruneAndDeterministicallySort(Collection[String]).mjava","pathOld":"solr/core/src/test/org/apache/solr/CursorPagingTest#pruneAndDeterministicallySort(Collection[String]).mjava","sourceNew":"  /**\n   * <p>\n   * Given a list of field names in the schema, returns an immutable list in \n   * deterministically random order with the following things removed:\n   * </p>\n   * <ul>\n   *  <li><code>_version_</code> is removed</li>\n   * </ul>\n   */\n  public static List<String> pruneAndDeterministicallySort(Collection<String> raw) {\n\n    ArrayList<String> names = new ArrayList<>(37);\n    for (String f : raw) {\n      if (f.equals(\"_version_\")) {\n        continue;\n      }\n      names.add(f);\n    }\n\n    Collections.sort(names);\n    Collections.shuffle(names,random());\n    return Collections.<String>unmodifiableList(names);\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * Given a list of field names in the schema, returns an immutable list in \n   * deterministically random order with the following things removed:\n   * </p>\n   * <ul>\n   *  <li><code>_version_</code> is removed</li>\n   *  <li>\n   *    <code>*_dv_last</code>, <code>*_dv_first</code> and <code>*_dv</code>\n   *    fields are removed if the codec doesn't support missing DocValues\n   *  </li>\n   * </ul>\n   * @see #defaultCodecSupportsMissingDocValues\n   */\n  public static List<String> pruneAndDeterministicallySort(Collection<String> raw) {\n\n    final boolean prune_dv = ! defaultCodecSupportsMissingDocValues();\n\n    ArrayList<String> names = new ArrayList<>(37);\n    for (String f : raw) {\n      if (f.equals(\"_version_\")) {\n        continue;\n      }\n      if (prune_dv && (f.endsWith(\"_dv_last\") || f.endsWith(\"_dv_first\"))\n                       || f.endsWith(\"_dv\")) {\n        continue;\n      }\n      names.add(f);\n    }\n\n    Collections.sort(names);\n    Collections.shuffle(names,random());\n    return Collections.<String>unmodifiableList(names);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"402ad3ddc9da7b70da1b167667a60ece6a1381fb","date":1409656478,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/CursorPagingTest#pruneAndDeterministicallySort(Collection[String]).mjava","pathOld":"solr/core/src/test/org/apache/solr/CursorPagingTest#pruneAndDeterministicallySort(Collection[String]).mjava","sourceNew":"  /**\n   * <p>\n   * Given a list of field names in the schema, returns an immutable list in \n   * deterministically random order with the following things removed:\n   * </p>\n   * <ul>\n   *  <li><code>_version_</code> is removed</li>\n   * </ul>\n   */\n  public static List<String> pruneAndDeterministicallySort(Collection<String> raw) {\n\n    ArrayList<String> names = new ArrayList<>(37);\n    for (String f : raw) {\n      if (f.equals(\"_version_\")) {\n        continue;\n      }\n      names.add(f);\n    }\n\n    Collections.sort(names);\n    Collections.shuffle(names,random());\n    return Collections.<String>unmodifiableList(names);\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * Given a list of field names in the schema, returns an immutable list in \n   * deterministically random order with the following things removed:\n   * </p>\n   * <ul>\n   *  <li><code>_version_</code> is removed</li>\n   *  <li>\n   *    <code>*_dv_last</code>, <code>*_dv_first</code> and <code>*_dv</code>\n   *    fields are removed if the codec doesn't support missing DocValues\n   *  </li>\n   * </ul>\n   * @see #defaultCodecSupportsMissingDocValues\n   */\n  public static List<String> pruneAndDeterministicallySort(Collection<String> raw) {\n\n    final boolean prune_dv = ! defaultCodecSupportsMissingDocValues();\n\n    ArrayList<String> names = new ArrayList<>(37);\n    for (String f : raw) {\n      if (f.equals(\"_version_\")) {\n        continue;\n      }\n      if (prune_dv && (f.endsWith(\"_dv_last\") || f.endsWith(\"_dv_first\"))\n                       || f.endsWith(\"_dv\")) {\n        continue;\n      }\n      names.add(f);\n    }\n\n    Collections.sort(names);\n    Collections.shuffle(names,random());\n    return Collections.<String>unmodifiableList(names);\n  }\n\n","bugFix":["b73878fdd4a16043b65851ffb05b43fa1c7281f7","6a0f9b793b360e5f5863eef2d4b02a2ddd8b47b4"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["b73878fdd4a16043b65851ffb05b43fa1c7281f7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b73878fdd4a16043b65851ffb05b43fa1c7281f7":["6a0f9b793b360e5f5863eef2d4b02a2ddd8b47b4"],"6a0f9b793b360e5f5863eef2d4b02a2ddd8b47b4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ad2a673349939e48652bf304cccf673c3412198f":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["402ad3ddc9da7b70da1b167667a60ece6a1381fb"],"402ad3ddc9da7b70da1b167667a60ece6a1381fb":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","ad2a673349939e48652bf304cccf673c3412198f"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["ad2a673349939e48652bf304cccf673c3412198f","402ad3ddc9da7b70da1b167667a60ece6a1381fb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6a0f9b793b360e5f5863eef2d4b02a2ddd8b47b4"],"b73878fdd4a16043b65851ffb05b43fa1c7281f7":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"6a0f9b793b360e5f5863eef2d4b02a2ddd8b47b4":["b73878fdd4a16043b65851ffb05b43fa1c7281f7"],"ad2a673349939e48652bf304cccf673c3412198f":["402ad3ddc9da7b70da1b167667a60ece6a1381fb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"402ad3ddc9da7b70da1b167667a60ece6a1381fb":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}