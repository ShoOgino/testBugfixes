{"path":"lucene/core/src/test/org/apache/lucene/util/TestDocIdSetBuilder#testRandom().mjava","commits":[{"id":"0e91a2d9ed80172872da0f517870da6756289554","date":1436431140,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestDocIdSetBuilder#testRandom().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandom() throws IOException {\n    final int maxDoc = TestUtil.nextInt(random(), 1, 10000000);\n    for (int i = 1 ; i < maxDoc / 2; i <<=1) {\n      final int numDocs = TestUtil.nextInt(random(), 1, i);\n      final FixedBitSet docs = new FixedBitSet(maxDoc);\n      int c = 0;\n      while (c < numDocs) {\n        final int d = random().nextInt(maxDoc);\n        if (docs.get(d) == false) {\n          docs.set(d);\n          c += 1;\n        }\n      }\n\n      final int[] array = new int[numDocs + random().nextInt(100)];\n      DocIdSetIterator it = new BitSetIterator(docs, 0L);\n      int j = 0;\n      for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n        array[j++] = doc;\n      }\n      assertEquals(numDocs, j);\n\n      // add some duplicates\n      while (j < array.length) {\n        array[j++] = array[random().nextInt(numDocs)];\n      }\n\n      // shuffle\n      for (j = array.length - 1; j >= 1; --j) {\n        final int k = random().nextInt(j);\n        int tmp = array[j];\n        array[j] = array[k];\n        array[k] = tmp;\n      }\n\n      // add docs out of order\n      DocIdSetBuilder builder = new DocIdSetBuilder(maxDoc);\n      for (j = 0; j < array.length; ) {\n        final int l = TestUtil.nextInt(random(), 1, array.length - j);\n        if (rarely()) {\n          builder.grow(l);\n        }\n        for (int k = 0; k < l; ++k) {\n          builder.add(array[j++]);\n        }\n      }\n\n      final DocIdSet expected = new BitDocIdSet(docs);\n      final DocIdSet actual = builder.build();\n      assertEquals(expected, actual);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d3eccadf4f2a01d2034c96afe1a5c617b2e85af","date":1461918927,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestDocIdSetBuilder#testRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestDocIdSetBuilder#testRandom().mjava","sourceNew":"  public void testRandom() throws IOException {\n    final int maxDoc = TestUtil.nextInt(random(), 1, 10000000);\n    for (int i = 1 ; i < maxDoc / 2; i <<=1) {\n      final int numDocs = TestUtil.nextInt(random(), 1, i);\n      final FixedBitSet docs = new FixedBitSet(maxDoc);\n      int c = 0;\n      while (c < numDocs) {\n        final int d = random().nextInt(maxDoc);\n        if (docs.get(d) == false) {\n          docs.set(d);\n          c += 1;\n        }\n      }\n\n      final int[] array = new int[numDocs + random().nextInt(100)];\n      DocIdSetIterator it = new BitSetIterator(docs, 0L);\n      int j = 0;\n      for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n        array[j++] = doc;\n      }\n      assertEquals(numDocs, j);\n\n      // add some duplicates\n      while (j < array.length) {\n        array[j++] = array[random().nextInt(numDocs)];\n      }\n\n      // shuffle\n      for (j = array.length - 1; j >= 1; --j) {\n        final int k = random().nextInt(j);\n        int tmp = array[j];\n        array[j] = array[k];\n        array[k] = tmp;\n      }\n\n      // add docs out of order\n      DocIdSetBuilder builder = new DocIdSetBuilder(maxDoc);\n      for (j = 0; j < array.length; ) {\n        final int l = TestUtil.nextInt(random(), 1, array.length - j);\n        DocIdSetBuilder.BulkAdder adder = null;\n        for (int k = 0, budget = 0; k < l; ++k) {\n          if (budget == 0 || rarely()) {\n            budget = TestUtil.nextInt(random(), 1, l - k + 5);\n            adder = builder.grow(budget);\n          }\n          adder.add(array[j++]);\n          budget--;\n        }\n      }\n\n      final DocIdSet expected = new BitDocIdSet(docs);\n      final DocIdSet actual = builder.build();\n      assertEquals(expected, actual);\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws IOException {\n    final int maxDoc = TestUtil.nextInt(random(), 1, 10000000);\n    for (int i = 1 ; i < maxDoc / 2; i <<=1) {\n      final int numDocs = TestUtil.nextInt(random(), 1, i);\n      final FixedBitSet docs = new FixedBitSet(maxDoc);\n      int c = 0;\n      while (c < numDocs) {\n        final int d = random().nextInt(maxDoc);\n        if (docs.get(d) == false) {\n          docs.set(d);\n          c += 1;\n        }\n      }\n\n      final int[] array = new int[numDocs + random().nextInt(100)];\n      DocIdSetIterator it = new BitSetIterator(docs, 0L);\n      int j = 0;\n      for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n        array[j++] = doc;\n      }\n      assertEquals(numDocs, j);\n\n      // add some duplicates\n      while (j < array.length) {\n        array[j++] = array[random().nextInt(numDocs)];\n      }\n\n      // shuffle\n      for (j = array.length - 1; j >= 1; --j) {\n        final int k = random().nextInt(j);\n        int tmp = array[j];\n        array[j] = array[k];\n        array[k] = tmp;\n      }\n\n      // add docs out of order\n      DocIdSetBuilder builder = new DocIdSetBuilder(maxDoc);\n      for (j = 0; j < array.length; ) {\n        final int l = TestUtil.nextInt(random(), 1, array.length - j);\n        if (rarely()) {\n          builder.grow(l);\n        }\n        for (int k = 0; k < l; ++k) {\n          builder.add(array[j++]);\n        }\n      }\n\n      final DocIdSet expected = new BitDocIdSet(docs);\n      final DocIdSet actual = builder.build();\n      assertEquals(expected, actual);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8e8d5955830d712186a4beb716e797d505af7981","date":1461951189,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestDocIdSetBuilder#testRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestDocIdSetBuilder#testRandom().mjava","sourceNew":"  public void testRandom() throws IOException {\n    final int maxDoc = TestUtil.nextInt(random(), 1, 10000000);\n    for (int i = 1 ; i < maxDoc / 2; i <<=1) {\n      final int numDocs = TestUtil.nextInt(random(), 1, i);\n      final FixedBitSet docs = new FixedBitSet(maxDoc);\n      int c = 0;\n      while (c < numDocs) {\n        final int d = random().nextInt(maxDoc);\n        if (docs.get(d) == false) {\n          docs.set(d);\n          c += 1;\n        }\n      }\n\n      final int[] array = new int[numDocs + random().nextInt(100)];\n      DocIdSetIterator it = new BitSetIterator(docs, 0L);\n      int j = 0;\n      for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n        array[j++] = doc;\n      }\n      assertEquals(numDocs, j);\n\n      // add some duplicates\n      while (j < array.length) {\n        array[j++] = array[random().nextInt(numDocs)];\n      }\n\n      // shuffle\n      for (j = array.length - 1; j >= 1; --j) {\n        final int k = random().nextInt(j);\n        int tmp = array[j];\n        array[j] = array[k];\n        array[k] = tmp;\n      }\n\n      // add docs out of order\n      DocIdSetBuilder builder = new DocIdSetBuilder(maxDoc);\n      for (j = 0; j < array.length; ) {\n        final int l = TestUtil.nextInt(random(), 1, array.length - j);\n        DocIdSetBuilder.BulkAdder adder = null;\n        for (int k = 0, budget = 0; k < l; ++k) {\n          if (budget == 0 || rarely()) {\n            budget = TestUtil.nextInt(random(), 1, l - k + 5);\n            adder = builder.grow(budget);\n          }\n          adder.add(array[j++]);\n          budget--;\n        }\n      }\n\n      final DocIdSet expected = new BitDocIdSet(docs);\n      final DocIdSet actual = builder.build();\n      assertEquals(expected, actual);\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws IOException {\n    final int maxDoc = TestUtil.nextInt(random(), 1, 10000000);\n    for (int i = 1 ; i < maxDoc / 2; i <<=1) {\n      final int numDocs = TestUtil.nextInt(random(), 1, i);\n      final FixedBitSet docs = new FixedBitSet(maxDoc);\n      int c = 0;\n      while (c < numDocs) {\n        final int d = random().nextInt(maxDoc);\n        if (docs.get(d) == false) {\n          docs.set(d);\n          c += 1;\n        }\n      }\n\n      final int[] array = new int[numDocs + random().nextInt(100)];\n      DocIdSetIterator it = new BitSetIterator(docs, 0L);\n      int j = 0;\n      for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n        array[j++] = doc;\n      }\n      assertEquals(numDocs, j);\n\n      // add some duplicates\n      while (j < array.length) {\n        array[j++] = array[random().nextInt(numDocs)];\n      }\n\n      // shuffle\n      for (j = array.length - 1; j >= 1; --j) {\n        final int k = random().nextInt(j);\n        int tmp = array[j];\n        array[j] = array[k];\n        array[k] = tmp;\n      }\n\n      // add docs out of order\n      DocIdSetBuilder builder = new DocIdSetBuilder(maxDoc);\n      for (j = 0; j < array.length; ) {\n        final int l = TestUtil.nextInt(random(), 1, array.length - j);\n        if (rarely()) {\n          builder.grow(l);\n        }\n        for (int k = 0; k < l; ++k) {\n          builder.add(array[j++]);\n        }\n      }\n\n      final DocIdSet expected = new BitDocIdSet(docs);\n      final DocIdSet actual = builder.build();\n      assertEquals(expected, actual);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55b50463286869f584cf849d1587a0fcd54d1dfa","date":1462378517,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestDocIdSetBuilder#testRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestDocIdSetBuilder#testRandom().mjava","sourceNew":"  public void testRandom() throws IOException {\n    final int maxDoc = TestUtil.nextInt(random(), 1, 10000000);\n    for (int i = 1 ; i < maxDoc / 2; i <<=1) {\n      final int numDocs = TestUtil.nextInt(random(), 1, i);\n      final FixedBitSet docs = new FixedBitSet(maxDoc);\n      int c = 0;\n      while (c < numDocs) {\n        final int d = random().nextInt(maxDoc);\n        if (docs.get(d) == false) {\n          docs.set(d);\n          c += 1;\n        }\n      }\n\n      final int[] array = new int[numDocs + random().nextInt(100)];\n      DocIdSetIterator it = new BitSetIterator(docs, 0L);\n      int j = 0;\n      for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n        array[j++] = doc;\n      }\n      assertEquals(numDocs, j);\n\n      // add some duplicates\n      while (j < array.length) {\n        array[j++] = array[random().nextInt(numDocs)];\n      }\n\n      // shuffle\n      for (j = array.length - 1; j >= 1; --j) {\n        final int k = random().nextInt(j);\n        int tmp = array[j];\n        array[j] = array[k];\n        array[k] = tmp;\n      }\n\n      // add docs out of order\n      DocIdSetBuilder builder = new DocIdSetBuilder(maxDoc);\n      for (j = 0; j < array.length; ) {\n        final int l = TestUtil.nextInt(random(), 1, array.length - j);\n        DocIdSetBuilder.BulkAdder adder = null;\n        for (int k = 0, budget = 0; k < l; ++k) {\n          if (budget == 0 || rarely()) {\n            budget = TestUtil.nextInt(random(), 1, l - k + 5);\n            adder = builder.grow(budget);\n          }\n          adder.add(array[j++]);\n          budget--;\n        }\n      }\n\n      final DocIdSet expected = new BitDocIdSet(docs);\n      final DocIdSet actual = builder.build();\n      assertEquals(expected, actual);\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws IOException {\n    final int maxDoc = TestUtil.nextInt(random(), 1, 10000000);\n    for (int i = 1 ; i < maxDoc / 2; i <<=1) {\n      final int numDocs = TestUtil.nextInt(random(), 1, i);\n      final FixedBitSet docs = new FixedBitSet(maxDoc);\n      int c = 0;\n      while (c < numDocs) {\n        final int d = random().nextInt(maxDoc);\n        if (docs.get(d) == false) {\n          docs.set(d);\n          c += 1;\n        }\n      }\n\n      final int[] array = new int[numDocs + random().nextInt(100)];\n      DocIdSetIterator it = new BitSetIterator(docs, 0L);\n      int j = 0;\n      for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n        array[j++] = doc;\n      }\n      assertEquals(numDocs, j);\n\n      // add some duplicates\n      while (j < array.length) {\n        array[j++] = array[random().nextInt(numDocs)];\n      }\n\n      // shuffle\n      for (j = array.length - 1; j >= 1; --j) {\n        final int k = random().nextInt(j);\n        int tmp = array[j];\n        array[j] = array[k];\n        array[k] = tmp;\n      }\n\n      // add docs out of order\n      DocIdSetBuilder builder = new DocIdSetBuilder(maxDoc);\n      for (j = 0; j < array.length; ) {\n        final int l = TestUtil.nextInt(random(), 1, array.length - j);\n        if (rarely()) {\n          builder.grow(l);\n        }\n        for (int k = 0; k < l; ++k) {\n          builder.add(array[j++]);\n        }\n      }\n\n      final DocIdSet expected = new BitDocIdSet(docs);\n      final DocIdSet actual = builder.build();\n      assertEquals(expected, actual);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57c6c784f777a2cc8fa014507ea129526822714d","date":1579733373,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestDocIdSetBuilder#testRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestDocIdSetBuilder#testRandom().mjava","sourceNew":"  public void testRandom() throws IOException {\n    final int maxDoc = TEST_NIGHTLY ? TestUtil.nextInt(random(), 1, 10000000) : TestUtil.nextInt(random(), 1, 100000) ;\n    for (int i = 1 ; i < maxDoc / 2; i <<=1) {\n      final int numDocs = TestUtil.nextInt(random(), 1, i);\n      final FixedBitSet docs = new FixedBitSet(maxDoc);\n      int c = 0;\n      while (c < numDocs) {\n        final int d = random().nextInt(maxDoc);\n        if (docs.get(d) == false) {\n          docs.set(d);\n          c += 1;\n        }\n      }\n\n      final int[] array = new int[numDocs + random().nextInt(100)];\n      DocIdSetIterator it = new BitSetIterator(docs, 0L);\n      int j = 0;\n      for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n        array[j++] = doc;\n      }\n      assertEquals(numDocs, j);\n\n      // add some duplicates\n      while (j < array.length) {\n        array[j++] = array[random().nextInt(numDocs)];\n      }\n\n      // shuffle\n      for (j = array.length - 1; j >= 1; --j) {\n        final int k = random().nextInt(j);\n        int tmp = array[j];\n        array[j] = array[k];\n        array[k] = tmp;\n      }\n\n      // add docs out of order\n      DocIdSetBuilder builder = new DocIdSetBuilder(maxDoc);\n      for (j = 0; j < array.length; ) {\n        final int l = TestUtil.nextInt(random(), 1, array.length - j);\n        DocIdSetBuilder.BulkAdder adder = null;\n        for (int k = 0, budget = 0; k < l; ++k) {\n          if (budget == 0 || rarely()) {\n            budget = TestUtil.nextInt(random(), 1, l - k + 5);\n            adder = builder.grow(budget);\n          }\n          adder.add(array[j++]);\n          budget--;\n        }\n      }\n\n      final DocIdSet expected = new BitDocIdSet(docs);\n      final DocIdSet actual = builder.build();\n      assertEquals(expected, actual);\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws IOException {\n    final int maxDoc = TestUtil.nextInt(random(), 1, 10000000);\n    for (int i = 1 ; i < maxDoc / 2; i <<=1) {\n      final int numDocs = TestUtil.nextInt(random(), 1, i);\n      final FixedBitSet docs = new FixedBitSet(maxDoc);\n      int c = 0;\n      while (c < numDocs) {\n        final int d = random().nextInt(maxDoc);\n        if (docs.get(d) == false) {\n          docs.set(d);\n          c += 1;\n        }\n      }\n\n      final int[] array = new int[numDocs + random().nextInt(100)];\n      DocIdSetIterator it = new BitSetIterator(docs, 0L);\n      int j = 0;\n      for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n        array[j++] = doc;\n      }\n      assertEquals(numDocs, j);\n\n      // add some duplicates\n      while (j < array.length) {\n        array[j++] = array[random().nextInt(numDocs)];\n      }\n\n      // shuffle\n      for (j = array.length - 1; j >= 1; --j) {\n        final int k = random().nextInt(j);\n        int tmp = array[j];\n        array[j] = array[k];\n        array[k] = tmp;\n      }\n\n      // add docs out of order\n      DocIdSetBuilder builder = new DocIdSetBuilder(maxDoc);\n      for (j = 0; j < array.length; ) {\n        final int l = TestUtil.nextInt(random(), 1, array.length - j);\n        DocIdSetBuilder.BulkAdder adder = null;\n        for (int k = 0, budget = 0; k < l; ++k) {\n          if (budget == 0 || rarely()) {\n            budget = TestUtil.nextInt(random(), 1, l - k + 5);\n            adder = builder.grow(budget);\n          }\n          adder.add(array[j++]);\n          budget--;\n        }\n      }\n\n      final DocIdSet expected = new BitDocIdSet(docs);\n      final DocIdSet actual = builder.build();\n      assertEquals(expected, actual);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"57c6c784f777a2cc8fa014507ea129526822714d":["8e8d5955830d712186a4beb716e797d505af7981"],"3d3eccadf4f2a01d2034c96afe1a5c617b2e85af":["0e91a2d9ed80172872da0f517870da6756289554"],"8e8d5955830d712186a4beb716e797d505af7981":["0e91a2d9ed80172872da0f517870da6756289554","3d3eccadf4f2a01d2034c96afe1a5c617b2e85af"],"0e91a2d9ed80172872da0f517870da6756289554":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["57c6c784f777a2cc8fa014507ea129526822714d"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["0e91a2d9ed80172872da0f517870da6756289554","8e8d5955830d712186a4beb716e797d505af7981"]},"commit2Childs":{"57c6c784f777a2cc8fa014507ea129526822714d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3d3eccadf4f2a01d2034c96afe1a5c617b2e85af":["8e8d5955830d712186a4beb716e797d505af7981"],"8e8d5955830d712186a4beb716e797d505af7981":["57c6c784f777a2cc8fa014507ea129526822714d","55b50463286869f584cf849d1587a0fcd54d1dfa"],"0e91a2d9ed80172872da0f517870da6756289554":["3d3eccadf4f2a01d2034c96afe1a5c617b2e85af","8e8d5955830d712186a4beb716e797d505af7981","55b50463286869f584cf849d1587a0fcd54d1dfa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0e91a2d9ed80172872da0f517870da6756289554"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"55b50463286869f584cf849d1587a0fcd54d1dfa":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","55b50463286869f584cf849d1587a0fcd54d1dfa"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}