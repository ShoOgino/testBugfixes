{"path":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#getDocIdSet().mjava","commits":[{"id":"c659c37800c0dfd82fa025b5834f4ab065903d11","date":1361851047,"type":0,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#getDocIdSet().mjava","pathOld":"/dev/null","sourceNew":"    public DocIdSet getDocIdSet() throws IOException {\n      assert curVNode == null : \"Called more than once?\";\n      if (termsEnum == null)\n        return null;\n      //advance\n      if ((thisTerm = termsEnum.next()) == null)\n        return null; // all done\n\n      curVNode = new VNode(null);\n      curVNode.reset(grid.getWorldNode());\n\n      start();\n\n      addIntersectingChildren();\n\n      main: while (thisTerm != null) {//terminates for other reasons too!\n\n        //Advance curVNode pointer\n        if (curVNode.children != null) {\n          //-- HAVE CHILDREN: DESCEND\n          assert curVNode.children.hasNext();//if we put it there then it has something\n          preSiblings(curVNode);\n          curVNode = curVNode.children.next();\n        } else {\n          //-- NO CHILDREN: ADVANCE TO NEXT SIBLING\n          VNode parentVNode = curVNode.parent;\n          while (true) {\n            if (parentVNode == null)\n              break main; // all done\n            if (parentVNode.children.hasNext()) {\n              //advance next sibling\n              curVNode = parentVNode.children.next();\n              break;\n            } else {\n              //reached end of siblings; pop up\n              postSiblings(parentVNode);\n              parentVNode.children = null;//GC\n              parentVNode = parentVNode.parent;\n            }\n          }\n        }\n\n        //Seek to curVNode's cell (or skip if termsEnum has moved beyond)\n        curVNodeTerm.bytes = curVNode.cell.getTokenBytes();\n        curVNodeTerm.length = curVNodeTerm.bytes.length;\n        int compare = termsEnum.getComparator().compare(thisTerm, curVNodeTerm);\n        if (compare > 0) {\n          // leap frog (termsEnum is beyond where we would otherwise seek)\n          assert ! context.reader().terms(fieldName).iterator(null).seekExact(curVNodeTerm, false) : \"should be absent\";\n        } else {\n          if (compare < 0) {\n            // Seek !\n            TermsEnum.SeekStatus seekStatus = termsEnum.seekCeil(curVNodeTerm, true);\n            if (seekStatus == TermsEnum.SeekStatus.END)\n              break; // all done\n            thisTerm = termsEnum.term();\n            if (seekStatus == TermsEnum.SeekStatus.NOT_FOUND) {\n              continue; // leap frog\n            }\n          }\n          // Visit!\n          boolean descend = visit(curVNode.cell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            break; // all done\n          if (descend)\n            addIntersectingChildren();\n\n        }\n\n      }//main loop\n\n      return finish();\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8259c159da2de2e8528524fb76b244b46cbded59","date":1364478249,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#getDocIdSet().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#getDocIdSet().mjava","sourceNew":"    public DocIdSet getDocIdSet() throws IOException {\n      assert curVNode == null : \"Called more than once?\";\n      if (termsEnum == null)\n        return null;\n      //advance\n      if ((thisTerm = termsEnum.next()) == null)\n        return null; // all done\n\n      curVNode = new VNode(null);\n      curVNode.reset(grid.getWorldCell());\n\n      start();\n\n      addIntersectingChildren();\n\n      main: while (thisTerm != null) {//terminates for other reasons too!\n\n        //Advance curVNode pointer\n        if (curVNode.children != null) {\n          //-- HAVE CHILDREN: DESCEND\n          assert curVNode.children.hasNext();//if we put it there then it has something\n          preSiblings(curVNode);\n          curVNode = curVNode.children.next();\n        } else {\n          //-- NO CHILDREN: ADVANCE TO NEXT SIBLING\n          VNode parentVNode = curVNode.parent;\n          while (true) {\n            if (parentVNode == null)\n              break main; // all done\n            if (parentVNode.children.hasNext()) {\n              //advance next sibling\n              curVNode = parentVNode.children.next();\n              break;\n            } else {\n              //reached end of siblings; pop up\n              postSiblings(parentVNode);\n              parentVNode.children = null;//GC\n              parentVNode = parentVNode.parent;\n            }\n          }\n        }\n\n        //Seek to curVNode's cell (or skip if termsEnum has moved beyond)\n        curVNodeTerm.bytes = curVNode.cell.getTokenBytes();\n        curVNodeTerm.length = curVNodeTerm.bytes.length;\n        int compare = termsEnum.getComparator().compare(thisTerm, curVNodeTerm);\n        if (compare > 0) {\n          // leap frog (termsEnum is beyond where we would otherwise seek)\n          assert ! context.reader().terms(fieldName).iterator(null).seekExact(curVNodeTerm, false) : \"should be absent\";\n        } else {\n          if (compare < 0) {\n            // Seek !\n            TermsEnum.SeekStatus seekStatus = termsEnum.seekCeil(curVNodeTerm, true);\n            if (seekStatus == TermsEnum.SeekStatus.END)\n              break; // all done\n            thisTerm = termsEnum.term();\n            if (seekStatus == TermsEnum.SeekStatus.NOT_FOUND) {\n              continue; // leap frog\n            }\n          }\n          // Visit!\n          boolean descend = visit(curVNode.cell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            break; // all done\n          if (descend)\n            addIntersectingChildren();\n\n        }\n\n      }//main loop\n\n      return finish();\n    }\n\n","sourceOld":"    public DocIdSet getDocIdSet() throws IOException {\n      assert curVNode == null : \"Called more than once?\";\n      if (termsEnum == null)\n        return null;\n      //advance\n      if ((thisTerm = termsEnum.next()) == null)\n        return null; // all done\n\n      curVNode = new VNode(null);\n      curVNode.reset(grid.getWorldNode());\n\n      start();\n\n      addIntersectingChildren();\n\n      main: while (thisTerm != null) {//terminates for other reasons too!\n\n        //Advance curVNode pointer\n        if (curVNode.children != null) {\n          //-- HAVE CHILDREN: DESCEND\n          assert curVNode.children.hasNext();//if we put it there then it has something\n          preSiblings(curVNode);\n          curVNode = curVNode.children.next();\n        } else {\n          //-- NO CHILDREN: ADVANCE TO NEXT SIBLING\n          VNode parentVNode = curVNode.parent;\n          while (true) {\n            if (parentVNode == null)\n              break main; // all done\n            if (parentVNode.children.hasNext()) {\n              //advance next sibling\n              curVNode = parentVNode.children.next();\n              break;\n            } else {\n              //reached end of siblings; pop up\n              postSiblings(parentVNode);\n              parentVNode.children = null;//GC\n              parentVNode = parentVNode.parent;\n            }\n          }\n        }\n\n        //Seek to curVNode's cell (or skip if termsEnum has moved beyond)\n        curVNodeTerm.bytes = curVNode.cell.getTokenBytes();\n        curVNodeTerm.length = curVNodeTerm.bytes.length;\n        int compare = termsEnum.getComparator().compare(thisTerm, curVNodeTerm);\n        if (compare > 0) {\n          // leap frog (termsEnum is beyond where we would otherwise seek)\n          assert ! context.reader().terms(fieldName).iterator(null).seekExact(curVNodeTerm, false) : \"should be absent\";\n        } else {\n          if (compare < 0) {\n            // Seek !\n            TermsEnum.SeekStatus seekStatus = termsEnum.seekCeil(curVNodeTerm, true);\n            if (seekStatus == TermsEnum.SeekStatus.END)\n              break; // all done\n            thisTerm = termsEnum.term();\n            if (seekStatus == TermsEnum.SeekStatus.NOT_FOUND) {\n              continue; // leap frog\n            }\n          }\n          // Visit!\n          boolean descend = visit(curVNode.cell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            break; // all done\n          if (descend)\n            addIntersectingChildren();\n\n        }\n\n      }//main loop\n\n      return finish();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8","date":1373996650,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#getDocIdSet().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#getDocIdSet().mjava","sourceNew":"    public DocIdSet getDocIdSet() throws IOException {\n      assert curVNode == null : \"Called more than once?\";\n      if (termsEnum == null)\n        return null;\n      //advance\n      if ((thisTerm = termsEnum.next()) == null)\n        return null; // all done\n\n      curVNode = new VNode(null);\n      curVNode.reset(grid.getWorldCell());\n\n      start();\n\n      addIntersectingChildren();\n\n      main: while (thisTerm != null) {//terminates for other reasons too!\n\n        //Advance curVNode pointer\n        if (curVNode.children != null) {\n          //-- HAVE CHILDREN: DESCEND\n          assert curVNode.children.hasNext();//if we put it there then it has something\n          preSiblings(curVNode);\n          curVNode = curVNode.children.next();\n        } else {\n          //-- NO CHILDREN: ADVANCE TO NEXT SIBLING\n          VNode parentVNode = curVNode.parent;\n          while (true) {\n            if (parentVNode == null)\n              break main; // all done\n            if (parentVNode.children.hasNext()) {\n              //advance next sibling\n              curVNode = parentVNode.children.next();\n              break;\n            } else {\n              //reached end of siblings; pop up\n              postSiblings(parentVNode);\n              parentVNode.children = null;//GC\n              parentVNode = parentVNode.parent;\n            }\n          }\n        }\n\n        //Seek to curVNode's cell (or skip if termsEnum has moved beyond)\n        curVNodeTerm.bytes = curVNode.cell.getTokenBytes();\n        curVNodeTerm.length = curVNodeTerm.bytes.length;\n        int compare = termsEnum.getComparator().compare(thisTerm, curVNodeTerm);\n        if (compare > 0) {\n          // leap frog (termsEnum is beyond where we would otherwise seek)\n          assert ! context.reader().terms(fieldName).iterator(null).seekExact(curVNodeTerm) : \"should be absent\";\n        } else {\n          if (compare < 0) {\n            // Seek !\n            TermsEnum.SeekStatus seekStatus = termsEnum.seekCeil(curVNodeTerm);\n            if (seekStatus == TermsEnum.SeekStatus.END)\n              break; // all done\n            thisTerm = termsEnum.term();\n            if (seekStatus == TermsEnum.SeekStatus.NOT_FOUND) {\n              continue; // leap frog\n            }\n          }\n          // Visit!\n          boolean descend = visit(curVNode.cell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            break; // all done\n          if (descend)\n            addIntersectingChildren();\n\n        }\n\n      }//main loop\n\n      return finish();\n    }\n\n","sourceOld":"    public DocIdSet getDocIdSet() throws IOException {\n      assert curVNode == null : \"Called more than once?\";\n      if (termsEnum == null)\n        return null;\n      //advance\n      if ((thisTerm = termsEnum.next()) == null)\n        return null; // all done\n\n      curVNode = new VNode(null);\n      curVNode.reset(grid.getWorldCell());\n\n      start();\n\n      addIntersectingChildren();\n\n      main: while (thisTerm != null) {//terminates for other reasons too!\n\n        //Advance curVNode pointer\n        if (curVNode.children != null) {\n          //-- HAVE CHILDREN: DESCEND\n          assert curVNode.children.hasNext();//if we put it there then it has something\n          preSiblings(curVNode);\n          curVNode = curVNode.children.next();\n        } else {\n          //-- NO CHILDREN: ADVANCE TO NEXT SIBLING\n          VNode parentVNode = curVNode.parent;\n          while (true) {\n            if (parentVNode == null)\n              break main; // all done\n            if (parentVNode.children.hasNext()) {\n              //advance next sibling\n              curVNode = parentVNode.children.next();\n              break;\n            } else {\n              //reached end of siblings; pop up\n              postSiblings(parentVNode);\n              parentVNode.children = null;//GC\n              parentVNode = parentVNode.parent;\n            }\n          }\n        }\n\n        //Seek to curVNode's cell (or skip if termsEnum has moved beyond)\n        curVNodeTerm.bytes = curVNode.cell.getTokenBytes();\n        curVNodeTerm.length = curVNodeTerm.bytes.length;\n        int compare = termsEnum.getComparator().compare(thisTerm, curVNodeTerm);\n        if (compare > 0) {\n          // leap frog (termsEnum is beyond where we would otherwise seek)\n          assert ! context.reader().terms(fieldName).iterator(null).seekExact(curVNodeTerm, false) : \"should be absent\";\n        } else {\n          if (compare < 0) {\n            // Seek !\n            TermsEnum.SeekStatus seekStatus = termsEnum.seekCeil(curVNodeTerm, true);\n            if (seekStatus == TermsEnum.SeekStatus.END)\n              break; // all done\n            thisTerm = termsEnum.term();\n            if (seekStatus == TermsEnum.SeekStatus.NOT_FOUND) {\n              continue; // leap frog\n            }\n          }\n          // Visit!\n          boolean descend = visit(curVNode.cell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            break; // all done\n          if (descend)\n            addIntersectingChildren();\n\n        }\n\n      }//main loop\n\n      return finish();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#getDocIdSet().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#getDocIdSet().mjava","sourceNew":"    public DocIdSet getDocIdSet() throws IOException {\n      assert curVNode == null : \"Called more than once?\";\n      if (termsEnum == null)\n        return null;\n      //advance\n      if ((thisTerm = termsEnum.next()) == null)\n        return null; // all done\n\n      curVNode = new VNode(null);\n      curVNode.reset(grid.getWorldCell());\n\n      start();\n\n      addIntersectingChildren();\n\n      main: while (thisTerm != null) {//terminates for other reasons too!\n\n        //Advance curVNode pointer\n        if (curVNode.children != null) {\n          //-- HAVE CHILDREN: DESCEND\n          assert curVNode.children.hasNext();//if we put it there then it has something\n          preSiblings(curVNode);\n          curVNode = curVNode.children.next();\n        } else {\n          //-- NO CHILDREN: ADVANCE TO NEXT SIBLING\n          VNode parentVNode = curVNode.parent;\n          while (true) {\n            if (parentVNode == null)\n              break main; // all done\n            if (parentVNode.children.hasNext()) {\n              //advance next sibling\n              curVNode = parentVNode.children.next();\n              break;\n            } else {\n              //reached end of siblings; pop up\n              postSiblings(parentVNode);\n              parentVNode.children = null;//GC\n              parentVNode = parentVNode.parent;\n            }\n          }\n        }\n\n        //Seek to curVNode's cell (or skip if termsEnum has moved beyond)\n        curVNodeTerm.bytes = curVNode.cell.getTokenBytes();\n        curVNodeTerm.length = curVNodeTerm.bytes.length;\n        int compare = termsEnum.getComparator().compare(thisTerm, curVNodeTerm);\n        if (compare > 0) {\n          // leap frog (termsEnum is beyond where we would otherwise seek)\n          assert ! context.reader().terms(fieldName).iterator(null).seekExact(curVNodeTerm) : \"should be absent\";\n        } else {\n          if (compare < 0) {\n            // Seek !\n            TermsEnum.SeekStatus seekStatus = termsEnum.seekCeil(curVNodeTerm);\n            if (seekStatus == TermsEnum.SeekStatus.END)\n              break; // all done\n            thisTerm = termsEnum.term();\n            if (seekStatus == TermsEnum.SeekStatus.NOT_FOUND) {\n              continue; // leap frog\n            }\n          }\n          // Visit!\n          boolean descend = visit(curVNode.cell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            break; // all done\n          if (descend)\n            addIntersectingChildren();\n\n        }\n\n      }//main loop\n\n      return finish();\n    }\n\n","sourceOld":"    public DocIdSet getDocIdSet() throws IOException {\n      assert curVNode == null : \"Called more than once?\";\n      if (termsEnum == null)\n        return null;\n      //advance\n      if ((thisTerm = termsEnum.next()) == null)\n        return null; // all done\n\n      curVNode = new VNode(null);\n      curVNode.reset(grid.getWorldCell());\n\n      start();\n\n      addIntersectingChildren();\n\n      main: while (thisTerm != null) {//terminates for other reasons too!\n\n        //Advance curVNode pointer\n        if (curVNode.children != null) {\n          //-- HAVE CHILDREN: DESCEND\n          assert curVNode.children.hasNext();//if we put it there then it has something\n          preSiblings(curVNode);\n          curVNode = curVNode.children.next();\n        } else {\n          //-- NO CHILDREN: ADVANCE TO NEXT SIBLING\n          VNode parentVNode = curVNode.parent;\n          while (true) {\n            if (parentVNode == null)\n              break main; // all done\n            if (parentVNode.children.hasNext()) {\n              //advance next sibling\n              curVNode = parentVNode.children.next();\n              break;\n            } else {\n              //reached end of siblings; pop up\n              postSiblings(parentVNode);\n              parentVNode.children = null;//GC\n              parentVNode = parentVNode.parent;\n            }\n          }\n        }\n\n        //Seek to curVNode's cell (or skip if termsEnum has moved beyond)\n        curVNodeTerm.bytes = curVNode.cell.getTokenBytes();\n        curVNodeTerm.length = curVNodeTerm.bytes.length;\n        int compare = termsEnum.getComparator().compare(thisTerm, curVNodeTerm);\n        if (compare > 0) {\n          // leap frog (termsEnum is beyond where we would otherwise seek)\n          assert ! context.reader().terms(fieldName).iterator(null).seekExact(curVNodeTerm, false) : \"should be absent\";\n        } else {\n          if (compare < 0) {\n            // Seek !\n            TermsEnum.SeekStatus seekStatus = termsEnum.seekCeil(curVNodeTerm, true);\n            if (seekStatus == TermsEnum.SeekStatus.END)\n              break; // all done\n            thisTerm = termsEnum.term();\n            if (seekStatus == TermsEnum.SeekStatus.NOT_FOUND) {\n              continue; // leap frog\n            }\n          }\n          // Visit!\n          boolean descend = visit(curVNode.cell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            break; // all done\n          if (descend)\n            addIntersectingChildren();\n\n        }\n\n      }//main loop\n\n      return finish();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5","date":1379624229,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#getDocIdSet().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#getDocIdSet().mjava","sourceNew":"    public DocIdSet getDocIdSet() throws IOException {\n      assert curVNode == null : \"Called more than once?\";\n      if (termsEnum == null)\n        return null;\n      //advance\n      if ((thisTerm = termsEnum.next()) == null)\n        return null; // all done\n\n      curVNode = new VNode(null);\n      curVNode.reset(grid.getWorldCell());\n\n      start();\n\n      addIntersectingChildren();\n\n      main: while (thisTerm != null) {//terminates for other reasons too!\n\n        //Advance curVNode pointer\n        if (curVNode.children != null) {\n          //-- HAVE CHILDREN: DESCEND\n          assert curVNode.children.hasNext();//if we put it there then it has something\n          preSiblings(curVNode);\n          curVNode = curVNode.children.next();\n        } else {\n          //-- NO CHILDREN: ADVANCE TO NEXT SIBLING\n          VNode parentVNode = curVNode.parent;\n          while (true) {\n            if (parentVNode == null)\n              break main; // all done\n            if (parentVNode.children.hasNext()) {\n              //advance next sibling\n              curVNode = parentVNode.children.next();\n              break;\n            } else {\n              //reached end of siblings; pop up\n              postSiblings(parentVNode);\n              parentVNode.children = null;//GC\n              parentVNode = parentVNode.parent;\n            }\n          }\n        }\n\n        //Seek to curVNode's cell (or skip if termsEnum has moved beyond)\n        curVNodeTerm.bytes = curVNode.cell.getTokenBytes();\n        curVNodeTerm.length = curVNodeTerm.bytes.length;\n        int compare = thisTerm.compareTo(curVNodeTerm);\n        if (compare > 0) {\n          // leap frog (termsEnum is beyond where we would otherwise seek)\n          assert ! context.reader().terms(fieldName).iterator(null).seekExact(curVNodeTerm) : \"should be absent\";\n        } else {\n          if (compare < 0) {\n            // Seek !\n            TermsEnum.SeekStatus seekStatus = termsEnum.seekCeil(curVNodeTerm);\n            if (seekStatus == TermsEnum.SeekStatus.END)\n              break; // all done\n            thisTerm = termsEnum.term();\n            if (seekStatus == TermsEnum.SeekStatus.NOT_FOUND) {\n              continue; // leap frog\n            }\n          }\n          // Visit!\n          boolean descend = visit(curVNode.cell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            break; // all done\n          if (descend)\n            addIntersectingChildren();\n\n        }\n\n      }//main loop\n\n      return finish();\n    }\n\n","sourceOld":"    public DocIdSet getDocIdSet() throws IOException {\n      assert curVNode == null : \"Called more than once?\";\n      if (termsEnum == null)\n        return null;\n      //advance\n      if ((thisTerm = termsEnum.next()) == null)\n        return null; // all done\n\n      curVNode = new VNode(null);\n      curVNode.reset(grid.getWorldCell());\n\n      start();\n\n      addIntersectingChildren();\n\n      main: while (thisTerm != null) {//terminates for other reasons too!\n\n        //Advance curVNode pointer\n        if (curVNode.children != null) {\n          //-- HAVE CHILDREN: DESCEND\n          assert curVNode.children.hasNext();//if we put it there then it has something\n          preSiblings(curVNode);\n          curVNode = curVNode.children.next();\n        } else {\n          //-- NO CHILDREN: ADVANCE TO NEXT SIBLING\n          VNode parentVNode = curVNode.parent;\n          while (true) {\n            if (parentVNode == null)\n              break main; // all done\n            if (parentVNode.children.hasNext()) {\n              //advance next sibling\n              curVNode = parentVNode.children.next();\n              break;\n            } else {\n              //reached end of siblings; pop up\n              postSiblings(parentVNode);\n              parentVNode.children = null;//GC\n              parentVNode = parentVNode.parent;\n            }\n          }\n        }\n\n        //Seek to curVNode's cell (or skip if termsEnum has moved beyond)\n        curVNodeTerm.bytes = curVNode.cell.getTokenBytes();\n        curVNodeTerm.length = curVNodeTerm.bytes.length;\n        int compare = termsEnum.getComparator().compare(thisTerm, curVNodeTerm);\n        if (compare > 0) {\n          // leap frog (termsEnum is beyond where we would otherwise seek)\n          assert ! context.reader().terms(fieldName).iterator(null).seekExact(curVNodeTerm) : \"should be absent\";\n        } else {\n          if (compare < 0) {\n            // Seek !\n            TermsEnum.SeekStatus seekStatus = termsEnum.seekCeil(curVNodeTerm);\n            if (seekStatus == TermsEnum.SeekStatus.END)\n              break; // all done\n            thisTerm = termsEnum.term();\n            if (seekStatus == TermsEnum.SeekStatus.NOT_FOUND) {\n              continue; // leap frog\n            }\n          }\n          // Visit!\n          boolean descend = visit(curVNode.cell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            break; // all done\n          if (descend)\n            addIntersectingChildren();\n\n        }\n\n      }//main loop\n\n      return finish();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4de14be4bd1b857ba37ca138b61c4661c6d1bed3","date":1396628861,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#getDocIdSet().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#getDocIdSet().mjava","sourceNew":"    public DocIdSet getDocIdSet() throws IOException {\n      assert curVNode == null : \"Called more than once?\";\n      if (termsEnum == null)\n        return null;\n      //advance\n      if ((thisTerm = termsEnum.next()) == null)\n        return null; // all done\n\n      curVNode = new VNode(null);\n      curVNode.reset(grid.getWorldCell());\n\n      start();\n\n      addIntersectingChildren();\n\n      main: while (thisTerm != null) {//terminates for other reasons too!\n\n        //Advance curVNode pointer\n        if (curVNode.children != null) {\n          //-- HAVE CHILDREN: DESCEND\n          assert curVNode.children.hasNext();//if we put it there then it has something\n          preSiblings(curVNode);\n          curVNode = curVNode.children.next();\n        } else {\n          //-- NO CHILDREN: ADVANCE TO NEXT SIBLING\n          VNode parentVNode = curVNode.parent;\n          while (true) {\n            if (parentVNode == null)\n              break main; // all done\n            if (parentVNode.children.hasNext()) {\n              //advance next sibling\n              curVNode = parentVNode.children.next();\n              break;\n            } else {\n              //reached end of siblings; pop up\n              postSiblings(parentVNode);\n              parentVNode.children = null;//GC\n              parentVNode = parentVNode.parent;\n            }\n          }\n        }\n\n        //Seek to curVNode's cell (or skip if termsEnum has moved beyond)\n        curVNode.cell.getTokenBytesNoLeaf(curVNodeTerm);\n        int compare = thisTerm.compareTo(curVNodeTerm);\n        if (compare > 0) {\n          // leap frog (termsEnum is beyond where we would otherwise seek)\n          assert ! context.reader().terms(fieldName).iterator(null).seekExact(curVNodeTerm) : \"should be absent\";\n        } else {\n          if (compare < 0) {\n            // Seek !\n            TermsEnum.SeekStatus seekStatus = termsEnum.seekCeil(curVNodeTerm);\n            if (seekStatus == TermsEnum.SeekStatus.END)\n              break; // all done\n            thisTerm = termsEnum.term();\n            if (seekStatus == TermsEnum.SeekStatus.NOT_FOUND) {\n              continue; // leap frog\n            }\n          }\n          // Visit!\n          boolean descend = visit(curVNode.cell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            break; // all done\n          if (descend)\n            addIntersectingChildren();\n\n        }\n\n      }//main loop\n\n      return finish();\n    }\n\n","sourceOld":"    public DocIdSet getDocIdSet() throws IOException {\n      assert curVNode == null : \"Called more than once?\";\n      if (termsEnum == null)\n        return null;\n      //advance\n      if ((thisTerm = termsEnum.next()) == null)\n        return null; // all done\n\n      curVNode = new VNode(null);\n      curVNode.reset(grid.getWorldCell());\n\n      start();\n\n      addIntersectingChildren();\n\n      main: while (thisTerm != null) {//terminates for other reasons too!\n\n        //Advance curVNode pointer\n        if (curVNode.children != null) {\n          //-- HAVE CHILDREN: DESCEND\n          assert curVNode.children.hasNext();//if we put it there then it has something\n          preSiblings(curVNode);\n          curVNode = curVNode.children.next();\n        } else {\n          //-- NO CHILDREN: ADVANCE TO NEXT SIBLING\n          VNode parentVNode = curVNode.parent;\n          while (true) {\n            if (parentVNode == null)\n              break main; // all done\n            if (parentVNode.children.hasNext()) {\n              //advance next sibling\n              curVNode = parentVNode.children.next();\n              break;\n            } else {\n              //reached end of siblings; pop up\n              postSiblings(parentVNode);\n              parentVNode.children = null;//GC\n              parentVNode = parentVNode.parent;\n            }\n          }\n        }\n\n        //Seek to curVNode's cell (or skip if termsEnum has moved beyond)\n        curVNodeTerm.bytes = curVNode.cell.getTokenBytes();\n        curVNodeTerm.length = curVNodeTerm.bytes.length;\n        int compare = thisTerm.compareTo(curVNodeTerm);\n        if (compare > 0) {\n          // leap frog (termsEnum is beyond where we would otherwise seek)\n          assert ! context.reader().terms(fieldName).iterator(null).seekExact(curVNodeTerm) : \"should be absent\";\n        } else {\n          if (compare < 0) {\n            // Seek !\n            TermsEnum.SeekStatus seekStatus = termsEnum.seekCeil(curVNodeTerm);\n            if (seekStatus == TermsEnum.SeekStatus.END)\n              break; // all done\n            thisTerm = termsEnum.term();\n            if (seekStatus == TermsEnum.SeekStatus.NOT_FOUND) {\n              continue; // leap frog\n            }\n          }\n          // Visit!\n          boolean descend = visit(curVNode.cell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            break; // all done\n          if (descend)\n            addIntersectingChildren();\n\n        }\n\n      }//main loop\n\n      return finish();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15e323346eac5e4685c0a9f2df85eb96b4239bbb","date":1396688577,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#getDocIdSet().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#getDocIdSet().mjava","sourceNew":"    public DocIdSet getDocIdSet() throws IOException {\n      assert curVNode == null : \"Called more than once?\";\n      if (termsEnum == null)\n        return null;\n      //advance\n      if ((thisTerm = termsEnum.next()) == null)\n        return null; // all done\n\n      curVNode = new VNode(null);\n      curVNode.reset(grid.getWorldCell());\n\n      start();\n\n      addIntersectingChildren();\n\n      main: while (thisTerm != null) {//terminates for other reasons too!\n\n        //Advance curVNode pointer\n        if (curVNode.children != null) {\n          //-- HAVE CHILDREN: DESCEND\n          assert curVNode.children.hasNext();//if we put it there then it has something\n          preSiblings(curVNode);\n          curVNode = curVNode.children.next();\n        } else {\n          //-- NO CHILDREN: ADVANCE TO NEXT SIBLING\n          VNode parentVNode = curVNode.parent;\n          while (true) {\n            if (parentVNode == null)\n              break main; // all done\n            if (parentVNode.children.hasNext()) {\n              //advance next sibling\n              curVNode = parentVNode.children.next();\n              break;\n            } else {\n              //reached end of siblings; pop up\n              postSiblings(parentVNode);\n              parentVNode.children = null;//GC\n              parentVNode = parentVNode.parent;\n            }\n          }\n        }\n\n        //Seek to curVNode's cell (or skip if termsEnum has moved beyond)\n        curVNode.cell.getTokenBytesNoLeaf(curVNodeTerm);\n        int compare = thisTerm.compareTo(curVNodeTerm);\n        if (compare > 0) {\n          // leap frog (termsEnum is beyond where we would otherwise seek)\n          assert ! context.reader().terms(fieldName).iterator(null).seekExact(curVNodeTerm) : \"should be absent\";\n        } else {\n          if (compare < 0) {\n            // Seek !\n            TermsEnum.SeekStatus seekStatus = termsEnum.seekCeil(curVNodeTerm);\n            if (seekStatus == TermsEnum.SeekStatus.END)\n              break; // all done\n            thisTerm = termsEnum.term();\n            if (seekStatus == TermsEnum.SeekStatus.NOT_FOUND) {\n              continue; // leap frog\n            }\n          }\n          // Visit!\n          boolean descend = visit(curVNode.cell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            break; // all done\n          if (descend)\n            addIntersectingChildren();\n\n        }\n\n      }//main loop\n\n      return finish();\n    }\n\n","sourceOld":"    public DocIdSet getDocIdSet() throws IOException {\n      assert curVNode == null : \"Called more than once?\";\n      if (termsEnum == null)\n        return null;\n      //advance\n      if ((thisTerm = termsEnum.next()) == null)\n        return null; // all done\n\n      curVNode = new VNode(null);\n      curVNode.reset(grid.getWorldCell());\n\n      start();\n\n      addIntersectingChildren();\n\n      main: while (thisTerm != null) {//terminates for other reasons too!\n\n        //Advance curVNode pointer\n        if (curVNode.children != null) {\n          //-- HAVE CHILDREN: DESCEND\n          assert curVNode.children.hasNext();//if we put it there then it has something\n          preSiblings(curVNode);\n          curVNode = curVNode.children.next();\n        } else {\n          //-- NO CHILDREN: ADVANCE TO NEXT SIBLING\n          VNode parentVNode = curVNode.parent;\n          while (true) {\n            if (parentVNode == null)\n              break main; // all done\n            if (parentVNode.children.hasNext()) {\n              //advance next sibling\n              curVNode = parentVNode.children.next();\n              break;\n            } else {\n              //reached end of siblings; pop up\n              postSiblings(parentVNode);\n              parentVNode.children = null;//GC\n              parentVNode = parentVNode.parent;\n            }\n          }\n        }\n\n        //Seek to curVNode's cell (or skip if termsEnum has moved beyond)\n        curVNodeTerm.bytes = curVNode.cell.getTokenBytes();\n        curVNodeTerm.length = curVNodeTerm.bytes.length;\n        int compare = thisTerm.compareTo(curVNodeTerm);\n        if (compare > 0) {\n          // leap frog (termsEnum is beyond where we would otherwise seek)\n          assert ! context.reader().terms(fieldName).iterator(null).seekExact(curVNodeTerm) : \"should be absent\";\n        } else {\n          if (compare < 0) {\n            // Seek !\n            TermsEnum.SeekStatus seekStatus = termsEnum.seekCeil(curVNodeTerm);\n            if (seekStatus == TermsEnum.SeekStatus.END)\n              break; // all done\n            thisTerm = termsEnum.term();\n            if (seekStatus == TermsEnum.SeekStatus.NOT_FOUND) {\n              continue; // leap frog\n            }\n          }\n          // Visit!\n          boolean descend = visit(curVNode.cell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            break; // all done\n          if (descend)\n            addIntersectingChildren();\n\n        }\n\n      }//main loop\n\n      return finish();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0","date":1426015524,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#getDocIdSet().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#getDocIdSet().mjava","sourceNew":"    public DocIdSet getDocIdSet() throws IOException {\n      assert curVNode == null : \"Called more than once?\";\n      if (termsEnum == null)\n        return null;\n      if (!nextTerm()) {//advances\n        return null;\n      }\n\n      curVNode = new VNode(null);\n      curVNode.reset(grid.getWorldCell());\n\n      start();\n\n      addIntersectingChildren();\n\n      main: while (thisTerm != null) {//terminates for other reasons too!\n\n        //Advance curVNode pointer\n        if (curVNode.children != null) {\n          //-- HAVE CHILDREN: DESCEND\n          assert curVNode.children.hasNext();//if we put it there then it has something\n          preSiblings(curVNode);\n          curVNode = curVNode.children.next();\n        } else {\n          //-- NO CHILDREN: ADVANCE TO NEXT SIBLING\n          VNode parentVNode = curVNode.parent;\n          while (true) {\n            if (parentVNode == null)\n              break main; // all done\n            if (parentVNode.children.hasNext()) {\n              //advance next sibling\n              curVNode = parentVNode.children.next();\n              break;\n            } else {\n              //reached end of siblings; pop up\n              postSiblings(parentVNode);\n              parentVNode.children = null;//GC\n              parentVNode = parentVNode.parent;\n            }\n          }\n        }\n\n        //Seek to curVNode's cell (or skip if termsEnum has moved beyond)\n        final int compare = indexedCell.compareToNoLeaf(curVNode.cell);\n        if (compare > 0) {\n          // The indexed cell is after; continue loop to next query cell\n          continue;\n        }\n        if (compare < 0) {\n          // The indexed cell is before; seek ahead to query cell:\n          //      Seek !\n          curVNode.cell.getTokenBytesNoLeaf(curVNodeTerm);\n          TermsEnum.SeekStatus seekStatus = termsEnum.seekCeil(curVNodeTerm);\n          if (seekStatus == TermsEnum.SeekStatus.END)\n            break; // all done\n          thisTerm = termsEnum.term();\n          indexedCell = grid.readCell(thisTerm, indexedCell);\n          if (seekStatus == TermsEnum.SeekStatus.NOT_FOUND) {\n            // Did we find a leaf of the cell we were looking for or something after?\n            if (!indexedCell.isLeaf() || indexedCell.compareToNoLeaf(curVNode.cell) != 0)\n              continue; // The indexed cell is after; continue loop to next query cell\n          }\n        }\n        // indexedCell == queryCell (disregarding leaf).\n\n        // If indexedCell is a leaf then there's no prefix (prefix sorts before) -- just visit and continue\n        if (indexedCell.isLeaf()) {\n          visitLeaf(indexedCell);//TODO or query cell? Though shouldn't matter.\n          if (!nextTerm()) break;\n          continue;\n        }\n        // If a prefix (non-leaf) then visit; see if we descend.\n        final boolean descend = visitPrefix(curVNode.cell);//need to use curVNode.cell not indexedCell\n        if (!nextTerm()) break;\n        // Check for adjacent leaf with the same prefix\n        if (indexedCell.isLeaf() && indexedCell.getLevel() == curVNode.cell.getLevel()) {\n          visitLeaf(indexedCell);//TODO or query cell? Though shouldn't matter.\n          if (!nextTerm()) break;\n        }\n\n\n        if (descend) {\n          addIntersectingChildren();\n        }\n\n      }//main loop\n\n      return finish();\n    }\n\n","sourceOld":"    public DocIdSet getDocIdSet() throws IOException {\n      assert curVNode == null : \"Called more than once?\";\n      if (termsEnum == null)\n        return null;\n      //advance\n      if ((thisTerm = termsEnum.next()) == null)\n        return null; // all done\n\n      curVNode = new VNode(null);\n      curVNode.reset(grid.getWorldCell());\n\n      start();\n\n      addIntersectingChildren();\n\n      main: while (thisTerm != null) {//terminates for other reasons too!\n\n        //Advance curVNode pointer\n        if (curVNode.children != null) {\n          //-- HAVE CHILDREN: DESCEND\n          assert curVNode.children.hasNext();//if we put it there then it has something\n          preSiblings(curVNode);\n          curVNode = curVNode.children.next();\n        } else {\n          //-- NO CHILDREN: ADVANCE TO NEXT SIBLING\n          VNode parentVNode = curVNode.parent;\n          while (true) {\n            if (parentVNode == null)\n              break main; // all done\n            if (parentVNode.children.hasNext()) {\n              //advance next sibling\n              curVNode = parentVNode.children.next();\n              break;\n            } else {\n              //reached end of siblings; pop up\n              postSiblings(parentVNode);\n              parentVNode.children = null;//GC\n              parentVNode = parentVNode.parent;\n            }\n          }\n        }\n\n        //Seek to curVNode's cell (or skip if termsEnum has moved beyond)\n        curVNode.cell.getTokenBytesNoLeaf(curVNodeTerm);\n        int compare = thisTerm.compareTo(curVNodeTerm);\n        if (compare > 0) {\n          // leap frog (termsEnum is beyond where we would otherwise seek)\n          assert ! context.reader().terms(fieldName).iterator(null).seekExact(curVNodeTerm) : \"should be absent\";\n        } else {\n          if (compare < 0) {\n            // Seek !\n            TermsEnum.SeekStatus seekStatus = termsEnum.seekCeil(curVNodeTerm);\n            if (seekStatus == TermsEnum.SeekStatus.END)\n              break; // all done\n            thisTerm = termsEnum.term();\n            if (seekStatus == TermsEnum.SeekStatus.NOT_FOUND) {\n              continue; // leap frog\n            }\n          }\n          // Visit!\n          boolean descend = visit(curVNode.cell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            break; // all done\n          if (descend)\n            addIntersectingChildren();\n\n        }\n\n      }//main loop\n\n      return finish();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#getDocIdSet().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#getDocIdSet().mjava","sourceNew":"    public DocIdSet getDocIdSet() throws IOException {\n      assert curVNode == null : \"Called more than once?\";\n      if (termsEnum == null)\n        return null;\n      if (!nextTerm()) {//advances\n        return null;\n      }\n\n      curVNode = new VNode(null);\n      curVNode.reset(grid.getWorldCell());\n\n      start();\n\n      addIntersectingChildren();\n\n      main: while (thisTerm != null) {//terminates for other reasons too!\n\n        //Advance curVNode pointer\n        if (curVNode.children != null) {\n          //-- HAVE CHILDREN: DESCEND\n          assert curVNode.children.hasNext();//if we put it there then it has something\n          preSiblings(curVNode);\n          curVNode = curVNode.children.next();\n        } else {\n          //-- NO CHILDREN: ADVANCE TO NEXT SIBLING\n          VNode parentVNode = curVNode.parent;\n          while (true) {\n            if (parentVNode == null)\n              break main; // all done\n            if (parentVNode.children.hasNext()) {\n              //advance next sibling\n              curVNode = parentVNode.children.next();\n              break;\n            } else {\n              //reached end of siblings; pop up\n              postSiblings(parentVNode);\n              parentVNode.children = null;//GC\n              parentVNode = parentVNode.parent;\n            }\n          }\n        }\n\n        //Seek to curVNode's cell (or skip if termsEnum has moved beyond)\n        final int compare = indexedCell.compareToNoLeaf(curVNode.cell);\n        if (compare > 0) {\n          // The indexed cell is after; continue loop to next query cell\n          continue;\n        }\n        if (compare < 0) {\n          // The indexed cell is before; seek ahead to query cell:\n          //      Seek !\n          curVNode.cell.getTokenBytesNoLeaf(curVNodeTerm);\n          TermsEnum.SeekStatus seekStatus = termsEnum.seekCeil(curVNodeTerm);\n          if (seekStatus == TermsEnum.SeekStatus.END)\n            break; // all done\n          thisTerm = termsEnum.term();\n          indexedCell = grid.readCell(thisTerm, indexedCell);\n          if (seekStatus == TermsEnum.SeekStatus.NOT_FOUND) {\n            // Did we find a leaf of the cell we were looking for or something after?\n            if (!indexedCell.isLeaf() || indexedCell.compareToNoLeaf(curVNode.cell) != 0)\n              continue; // The indexed cell is after; continue loop to next query cell\n          }\n        }\n        // indexedCell == queryCell (disregarding leaf).\n\n        // If indexedCell is a leaf then there's no prefix (prefix sorts before) -- just visit and continue\n        if (indexedCell.isLeaf()) {\n          visitLeaf(indexedCell);//TODO or query cell? Though shouldn't matter.\n          if (!nextTerm()) break;\n          continue;\n        }\n        // If a prefix (non-leaf) then visit; see if we descend.\n        final boolean descend = visitPrefix(curVNode.cell);//need to use curVNode.cell not indexedCell\n        if (!nextTerm()) break;\n        // Check for adjacent leaf with the same prefix\n        if (indexedCell.isLeaf() && indexedCell.getLevel() == curVNode.cell.getLevel()) {\n          visitLeaf(indexedCell);//TODO or query cell? Though shouldn't matter.\n          if (!nextTerm()) break;\n        }\n\n\n        if (descend) {\n          addIntersectingChildren();\n        }\n\n      }//main loop\n\n      return finish();\n    }\n\n","sourceOld":"    public DocIdSet getDocIdSet() throws IOException {\n      assert curVNode == null : \"Called more than once?\";\n      if (termsEnum == null)\n        return null;\n      //advance\n      if ((thisTerm = termsEnum.next()) == null)\n        return null; // all done\n\n      curVNode = new VNode(null);\n      curVNode.reset(grid.getWorldCell());\n\n      start();\n\n      addIntersectingChildren();\n\n      main: while (thisTerm != null) {//terminates for other reasons too!\n\n        //Advance curVNode pointer\n        if (curVNode.children != null) {\n          //-- HAVE CHILDREN: DESCEND\n          assert curVNode.children.hasNext();//if we put it there then it has something\n          preSiblings(curVNode);\n          curVNode = curVNode.children.next();\n        } else {\n          //-- NO CHILDREN: ADVANCE TO NEXT SIBLING\n          VNode parentVNode = curVNode.parent;\n          while (true) {\n            if (parentVNode == null)\n              break main; // all done\n            if (parentVNode.children.hasNext()) {\n              //advance next sibling\n              curVNode = parentVNode.children.next();\n              break;\n            } else {\n              //reached end of siblings; pop up\n              postSiblings(parentVNode);\n              parentVNode.children = null;//GC\n              parentVNode = parentVNode.parent;\n            }\n          }\n        }\n\n        //Seek to curVNode's cell (or skip if termsEnum has moved beyond)\n        curVNode.cell.getTokenBytesNoLeaf(curVNodeTerm);\n        int compare = thisTerm.compareTo(curVNodeTerm);\n        if (compare > 0) {\n          // leap frog (termsEnum is beyond where we would otherwise seek)\n          assert ! context.reader().terms(fieldName).iterator(null).seekExact(curVNodeTerm) : \"should be absent\";\n        } else {\n          if (compare < 0) {\n            // Seek !\n            TermsEnum.SeekStatus seekStatus = termsEnum.seekCeil(curVNodeTerm);\n            if (seekStatus == TermsEnum.SeekStatus.END)\n              break; // all done\n            thisTerm = termsEnum.term();\n            if (seekStatus == TermsEnum.SeekStatus.NOT_FOUND) {\n              continue; // leap frog\n            }\n          }\n          // Visit!\n          boolean descend = visit(curVNode.cell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            break; // all done\n          if (descend)\n            addIntersectingChildren();\n\n        }\n\n      }//main loop\n\n      return finish();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"672b198fc3dce868916c727917cae58c2906763d","date":1443669960,"type":5,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeQuery.VisitorTemplate#getDocIdSet().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#getDocIdSet().mjava","sourceNew":"    public DocIdSet getDocIdSet() throws IOException {\n      assert curVNode == null : \"Called more than once?\";\n      if (termsEnum == null)\n        return null;\n      if (!nextTerm()) {//advances\n        return null;\n      }\n\n      curVNode = new VNode(null);\n      curVNode.reset(grid.getWorldCell());\n\n      start();\n\n      addIntersectingChildren();\n\n      main: while (thisTerm != null) {//terminates for other reasons too!\n\n        //Advance curVNode pointer\n        if (curVNode.children != null) {\n          //-- HAVE CHILDREN: DESCEND\n          assert curVNode.children.hasNext();//if we put it there then it has something\n          preSiblings(curVNode);\n          curVNode = curVNode.children.next();\n        } else {\n          //-- NO CHILDREN: ADVANCE TO NEXT SIBLING\n          VNode parentVNode = curVNode.parent;\n          while (true) {\n            if (parentVNode == null)\n              break main; // all done\n            if (parentVNode.children.hasNext()) {\n              //advance next sibling\n              curVNode = parentVNode.children.next();\n              break;\n            } else {\n              //reached end of siblings; pop up\n              postSiblings(parentVNode);\n              parentVNode.children = null;//GC\n              parentVNode = parentVNode.parent;\n            }\n          }\n        }\n\n        //Seek to curVNode's cell (or skip if termsEnum has moved beyond)\n        final int compare = indexedCell.compareToNoLeaf(curVNode.cell);\n        if (compare > 0) {\n          // The indexed cell is after; continue loop to next query cell\n          continue;\n        }\n        if (compare < 0) {\n          // The indexed cell is before; seek ahead to query cell:\n          //      Seek !\n          curVNode.cell.getTokenBytesNoLeaf(curVNodeTerm);\n          TermsEnum.SeekStatus seekStatus = termsEnum.seekCeil(curVNodeTerm);\n          if (seekStatus == TermsEnum.SeekStatus.END)\n            break; // all done\n          thisTerm = termsEnum.term();\n          indexedCell = grid.readCell(thisTerm, indexedCell);\n          if (seekStatus == TermsEnum.SeekStatus.NOT_FOUND) {\n            // Did we find a leaf of the cell we were looking for or something after?\n            if (!indexedCell.isLeaf() || indexedCell.compareToNoLeaf(curVNode.cell) != 0)\n              continue; // The indexed cell is after; continue loop to next query cell\n          }\n        }\n        // indexedCell == queryCell (disregarding leaf).\n\n        // If indexedCell is a leaf then there's no prefix (prefix sorts before) -- just visit and continue\n        if (indexedCell.isLeaf()) {\n          visitLeaf(indexedCell);//TODO or query cell? Though shouldn't matter.\n          if (!nextTerm()) break;\n          continue;\n        }\n        // If a prefix (non-leaf) then visit; see if we descend.\n        final boolean descend = visitPrefix(curVNode.cell);//need to use curVNode.cell not indexedCell\n        if (!nextTerm()) break;\n        // Check for adjacent leaf with the same prefix\n        if (indexedCell.isLeaf() && indexedCell.getLevel() == curVNode.cell.getLevel()) {\n          visitLeaf(indexedCell);//TODO or query cell? Though shouldn't matter.\n          if (!nextTerm()) break;\n        }\n\n\n        if (descend) {\n          addIntersectingChildren();\n        }\n\n      }//main loop\n\n      return finish();\n    }\n\n","sourceOld":"    public DocIdSet getDocIdSet() throws IOException {\n      assert curVNode == null : \"Called more than once?\";\n      if (termsEnum == null)\n        return null;\n      if (!nextTerm()) {//advances\n        return null;\n      }\n\n      curVNode = new VNode(null);\n      curVNode.reset(grid.getWorldCell());\n\n      start();\n\n      addIntersectingChildren();\n\n      main: while (thisTerm != null) {//terminates for other reasons too!\n\n        //Advance curVNode pointer\n        if (curVNode.children != null) {\n          //-- HAVE CHILDREN: DESCEND\n          assert curVNode.children.hasNext();//if we put it there then it has something\n          preSiblings(curVNode);\n          curVNode = curVNode.children.next();\n        } else {\n          //-- NO CHILDREN: ADVANCE TO NEXT SIBLING\n          VNode parentVNode = curVNode.parent;\n          while (true) {\n            if (parentVNode == null)\n              break main; // all done\n            if (parentVNode.children.hasNext()) {\n              //advance next sibling\n              curVNode = parentVNode.children.next();\n              break;\n            } else {\n              //reached end of siblings; pop up\n              postSiblings(parentVNode);\n              parentVNode.children = null;//GC\n              parentVNode = parentVNode.parent;\n            }\n          }\n        }\n\n        //Seek to curVNode's cell (or skip if termsEnum has moved beyond)\n        final int compare = indexedCell.compareToNoLeaf(curVNode.cell);\n        if (compare > 0) {\n          // The indexed cell is after; continue loop to next query cell\n          continue;\n        }\n        if (compare < 0) {\n          // The indexed cell is before; seek ahead to query cell:\n          //      Seek !\n          curVNode.cell.getTokenBytesNoLeaf(curVNodeTerm);\n          TermsEnum.SeekStatus seekStatus = termsEnum.seekCeil(curVNodeTerm);\n          if (seekStatus == TermsEnum.SeekStatus.END)\n            break; // all done\n          thisTerm = termsEnum.term();\n          indexedCell = grid.readCell(thisTerm, indexedCell);\n          if (seekStatus == TermsEnum.SeekStatus.NOT_FOUND) {\n            // Did we find a leaf of the cell we were looking for or something after?\n            if (!indexedCell.isLeaf() || indexedCell.compareToNoLeaf(curVNode.cell) != 0)\n              continue; // The indexed cell is after; continue loop to next query cell\n          }\n        }\n        // indexedCell == queryCell (disregarding leaf).\n\n        // If indexedCell is a leaf then there's no prefix (prefix sorts before) -- just visit and continue\n        if (indexedCell.isLeaf()) {\n          visitLeaf(indexedCell);//TODO or query cell? Though shouldn't matter.\n          if (!nextTerm()) break;\n          continue;\n        }\n        // If a prefix (non-leaf) then visit; see if we descend.\n        final boolean descend = visitPrefix(curVNode.cell);//need to use curVNode.cell not indexedCell\n        if (!nextTerm()) break;\n        // Check for adjacent leaf with the same prefix\n        if (indexedCell.isLeaf() && indexedCell.getLevel() == curVNode.cell.getLevel()) {\n          visitLeaf(indexedCell);//TODO or query cell? Though shouldn't matter.\n          if (!nextTerm()) break;\n        }\n\n\n        if (descend) {\n          addIntersectingChildren();\n        }\n\n      }//main loop\n\n      return finish();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["4de14be4bd1b857ba37ca138b61c4661c6d1bed3","11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0"],"672b198fc3dce868916c727917cae58c2906763d":["11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":["519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5","4de14be4bd1b857ba37ca138b61c4661c6d1bed3"],"519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5":["eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["8259c159da2de2e8528524fb76b244b46cbded59"],"4de14be4bd1b857ba37ca138b61c4661c6d1bed3":["519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5"],"11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0":["4de14be4bd1b857ba37ca138b61c4661c6d1bed3"],"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8":["8259c159da2de2e8528524fb76b244b46cbded59"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["672b198fc3dce868916c727917cae58c2906763d"],"8259c159da2de2e8528524fb76b244b46cbded59":["c659c37800c0dfd82fa025b5834f4ab065903d11"],"c659c37800c0dfd82fa025b5834f4ab065903d11":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"672b198fc3dce868916c727917cae58c2906763d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":[],"519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","4de14be4bd1b857ba37ca138b61c4661c6d1bed3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c659c37800c0dfd82fa025b5834f4ab065903d11"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"4de14be4bd1b857ba37ca138b61c4661c6d1bed3":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","15e323346eac5e4685c0a9f2df85eb96b4239bbb","11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0"],"11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","672b198fc3dce868916c727917cae58c2906763d"],"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8":["519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5"],"8259c159da2de2e8528524fb76b244b46cbded59":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"c659c37800c0dfd82fa025b5834f4ab065903d11":["8259c159da2de2e8528524fb76b244b46cbded59"]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","15e323346eac5e4685c0a9f2df85eb96b4239bbb","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}