{"path":"src/java/org/apache/lucene/analysis/TokenStream#next().mjava","commits":[{"id":"91109046a59c58ee0ee5d0d2767b08d1f30d6702","date":1000830588,"type":0,"author":"Jason van Zyl","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/TokenStream#next().mjava","pathOld":"/dev/null","sourceNew":"  /** Returns the next token in the stream, or null at EOS. */\n  abstract public Token next() throws IOException;\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"03ae70812bc33b0270c1366378b2c2da95fe86a6","date":1036648540,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/TokenStream#next().mjava","pathOld":"src/java/org/apache/lucene/analysis/TokenStream#next().mjava","sourceNew":"  /** Returns the next token in the stream, or null at EOS. */\n  public abstract Token next() throws IOException;\n\n","sourceOld":"  /** Returns the next token in the stream, or null at EOS. */\n  abstract public Token next() throws IOException;\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6864413dbc0c12104c978c05456f3da1d45adb03","date":1186770873,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/TokenStream#next().mjava","pathOld":"src/java/org/apache/lucene/analysis/TokenStream#next().mjava","sourceNew":"  /** Returns the next token in the stream, or null at EOS.\n   *  The returned Token is a \"full private copy\" (not\n   *  re-used across calls to next()) but will be slower\n   *  than calling {@link #next(Token)} instead.. */\n  public Token next() throws IOException {\n    Token result = next(new Token());\n    return result;\n  }\n\n","sourceOld":"  /** Returns the next token in the stream, or null at EOS. */\n  public abstract Token next() throws IOException;\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"66ba51c00e882f0132a67162dc4fd8e4340f8618","date":1195505109,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/TokenStream#next().mjava","pathOld":"src/java/org/apache/lucene/analysis/TokenStream#next().mjava","sourceNew":"  /** Returns the next token in the stream, or null at EOS.\n   *  The returned Token is a \"full private copy\" (not\n   *  re-used across calls to next()) but will be slower\n   *  than calling {@link #next(Token)} instead.. */\n  public Token next() throws IOException {\n    Token result = next(new Token());\n\n    if (result != null) {\n      Payload p = result.getPayload();\n      if (p != null)\n        result.setPayload(new Payload(p.toByteArray(), 0, p.length()));\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns the next token in the stream, or null at EOS.\n   *  The returned Token is a \"full private copy\" (not\n   *  re-used across calls to next()) but will be slower\n   *  than calling {@link #next(Token)} instead.. */\n  public Token next() throws IOException {\n    Token result = next(new Token());\n    return result;\n  }\n\n","bugFix":null,"bugIntro":["97c663a0e8cf62834049da11ecd70bd4a639ac9c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"97c663a0e8cf62834049da11ecd70bd4a639ac9c","date":1195852652,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/TokenStream#next().mjava","pathOld":"src/java/org/apache/lucene/analysis/TokenStream#next().mjava","sourceNew":"  /** Returns the next token in the stream, or null at EOS.\n   *  The returned Token is a \"full private copy\" (not\n   *  re-used across calls to next()) but will be slower\n   *  than calling {@link #next(Token)} instead.. */\n  public Token next() throws IOException {\n    Token result = next(new Token());\n\n    if (result != null) {\n      Payload p = result.getPayload();\n      if (p != null) {\n        result.setPayload((Payload) p.clone());\n      }\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns the next token in the stream, or null at EOS.\n   *  The returned Token is a \"full private copy\" (not\n   *  re-used across calls to next()) but will be slower\n   *  than calling {@link #next(Token)} instead.. */\n  public Token next() throws IOException {\n    Token result = next(new Token());\n\n    if (result != null) {\n      Payload p = result.getPayload();\n      if (p != null)\n        result.setPayload(new Payload(p.toByteArray(), 0, p.length()));\n    }\n\n    return result;\n  }\n\n","bugFix":["66ba51c00e882f0132a67162dc4fd8e4340f8618"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e2cb543b41c145f33390f460ee743d6693c9c6c","date":1219243087,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/TokenStream#next().mjava","pathOld":"src/java/org/apache/lucene/analysis/TokenStream#next().mjava","sourceNew":"  /** Returns the next token in the stream, or null at EOS.\n   *  @deprecated The returned Token is a \"full private copy\" (not\n   *  re-used across calls to next()) but will be slower\n   *  than calling {@link #next(Token)} instead.. */\n  public Token next() throws IOException {\n    final Token reusableToken = new Token();\n    Token nextToken = next(reusableToken);\n\n    if (nextToken != null) {\n      Payload p = nextToken.getPayload();\n      if (p != null) {\n        nextToken.setPayload((Payload) p.clone());\n      }\n    }\n\n    return nextToken;\n  }\n\n","sourceOld":"  /** Returns the next token in the stream, or null at EOS.\n   *  The returned Token is a \"full private copy\" (not\n   *  re-used across calls to next()) but will be slower\n   *  than calling {@link #next(Token)} instead.. */\n  public Token next() throws IOException {\n    Token result = next(new Token());\n\n    if (result != null) {\n      Payload p = result.getPayload();\n      if (p != null) {\n        result.setPayload((Payload) p.clone());\n      }\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec8b5a20a12931b8d7e616c79c5248ae06cc5568","date":1248471948,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/TokenStream#next().mjava","pathOld":"src/java/org/apache/lucene/analysis/TokenStream#next().mjava","sourceNew":"  /** Returns the next token in the stream, or null at EOS.\n   * @deprecated The returned Token is a \"full private copy\" (not\n   * re-used across calls to next()) but will be slower\n   * than calling {@link #next(Token)} or using the new\n   * {@link #incrementToken()} method with the new\n   * {@link AttributeSource} API.\n   */\n  public Token next() throws IOException {\n    if (onlyUseNewAPI)\n      throw new UnsupportedOperationException(\"This TokenStream only supports the new Attributes API.\");\n    \n    if (hasIncrementToken) {\n      return incrementToken() ? ((Token) tokenWrapper.delegate.clone()) : null;\n    } else {\n      assert hasReusableNext;\n      final Token token = next(tokenWrapper.delegate);\n      if (token == null) return null;\n      tokenWrapper.delegate = token;\n      return (Token) token.clone();\n    }\n  }\n\n","sourceOld":"  /** Returns the next token in the stream, or null at EOS.\n   *  @deprecated The returned Token is a \"full private copy\" (not\n   *  re-used across calls to next()) but will be slower\n   *  than calling {@link #next(Token)} instead.. */\n  public Token next() throws IOException {\n    final Token reusableToken = new Token();\n    Token nextToken = next(reusableToken);\n\n    if (nextToken != null) {\n      Payload p = nextToken.getPayload();\n      if (p != null) {\n        nextToken.setPayload((Payload) p.clone());\n      }\n    }\n\n    return nextToken;\n  }\n\n","bugFix":null,"bugIntro":["93995eb4992a09cc5a4b13b04225eca0bca45d57"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0833fee1ce16a2b8e10f21cbccd2e93f3d8ccf31","date":1249940086,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/TokenStream#next().mjava","pathOld":"src/java/org/apache/lucene/analysis/TokenStream#next().mjava","sourceNew":"  /** Returns the next token in the stream, or null at EOS.\n   * @deprecated The returned Token is a \"full private copy\" (not\n   * re-used across calls to next()) but will be slower\n   * than calling {@link #next(Token)} or using the new\n   * {@link #incrementToken()} method with the new\n   * {@link AttributeSource} API.\n   */\n  public Token next() throws IOException {\n    if (onlyUseNewAPI)\n      throw new UnsupportedOperationException(\"This TokenStream only supports the new Attributes API.\");\n    \n    if (supportedMethods.hasIncrementToken) {\n      return incrementToken() ? ((Token) tokenWrapper.delegate.clone()) : null;\n    } else {\n      assert supportedMethods.hasReusableNext;\n      final Token token = next(tokenWrapper.delegate);\n      if (token == null) return null;\n      tokenWrapper.delegate = token;\n      return (Token) token.clone();\n    }\n  }\n\n","sourceOld":"  /** Returns the next token in the stream, or null at EOS.\n   * @deprecated The returned Token is a \"full private copy\" (not\n   * re-used across calls to next()) but will be slower\n   * than calling {@link #next(Token)} or using the new\n   * {@link #incrementToken()} method with the new\n   * {@link AttributeSource} API.\n   */\n  public Token next() throws IOException {\n    if (onlyUseNewAPI)\n      throw new UnsupportedOperationException(\"This TokenStream only supports the new Attributes API.\");\n    \n    if (hasIncrementToken) {\n      return incrementToken() ? ((Token) tokenWrapper.delegate.clone()) : null;\n    } else {\n      assert hasReusableNext;\n      final Token token = next(tokenWrapper.delegate);\n      if (token == null) return null;\n      tokenWrapper.delegate = token;\n      return (Token) token.clone();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"39c72a0a1f317a4165b759c7842b5d73d7858d1d","date":1251209760,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/TokenStream#next().mjava","pathOld":"src/java/org/apache/lucene/analysis/TokenStream#next().mjava","sourceNew":"  /**\n   * Returns the next {@link Token} in the stream, or null at EOS.\n   * \n   * @deprecated The returned Token is a \"full private copy\" (not re-used across\n   *             calls to {@link #next()}) but will be slower than calling\n   *             {@link #next(Token)} or using the new {@link #incrementToken()}\n   *             method with the new {@link AttributeSource} API.\n   */\n  public Token next() throws IOException {\n    if (onlyUseNewAPI)\n      throw new UnsupportedOperationException(\"This TokenStream only supports the new Attributes API.\");\n    \n    if (supportedMethods.hasIncrementToken) {\n      return incrementToken() ? ((Token) tokenWrapper.delegate.clone()) : null;\n    } else {\n      assert supportedMethods.hasReusableNext;\n      final Token token = next(tokenWrapper.delegate);\n      if (token == null) return null;\n      tokenWrapper.delegate = token;\n      return (Token) token.clone();\n    }\n  }\n\n","sourceOld":"  /** Returns the next token in the stream, or null at EOS.\n   * @deprecated The returned Token is a \"full private copy\" (not\n   * re-used across calls to next()) but will be slower\n   * than calling {@link #next(Token)} or using the new\n   * {@link #incrementToken()} method with the new\n   * {@link AttributeSource} API.\n   */\n  public Token next() throws IOException {\n    if (onlyUseNewAPI)\n      throw new UnsupportedOperationException(\"This TokenStream only supports the new Attributes API.\");\n    \n    if (supportedMethods.hasIncrementToken) {\n      return incrementToken() ? ((Token) tokenWrapper.delegate.clone()) : null;\n    } else {\n      assert supportedMethods.hasReusableNext;\n      final Token token = next(tokenWrapper.delegate);\n      if (token == null) return null;\n      tokenWrapper.delegate = token;\n      return (Token) token.clone();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f4821e344090113a4e6d4d31265a0166ab07930d","date":1251215880,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/TokenStream#next().mjava","pathOld":"src/java/org/apache/lucene/analysis/TokenStream#next().mjava","sourceNew":"  /**\n   * Returns the next {@link Token} in the stream, or null at EOS.\n   * \n   * @deprecated The returned Token is a \"full private copy\" (not re-used across\n   *             calls to {@link #next()}) but will be slower than calling\n   *             {@link #next(Token)} or using the new {@link #incrementToken()}\n   *             method with the new {@link AttributeSource} API.\n   */\n  public Token next() throws IOException {\n    if (tokenWrapper == null)\n      throw new UnsupportedOperationException(\"This TokenStream only supports the new Attributes API.\");\n    \n    if (supportedMethods.hasIncrementToken) {\n      return incrementToken() ? ((Token) tokenWrapper.delegate.clone()) : null;\n    } else {\n      assert supportedMethods.hasReusableNext;\n      final Token token = next(tokenWrapper.delegate);\n      if (token == null) return null;\n      tokenWrapper.delegate = token;\n      return (Token) token.clone();\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns the next {@link Token} in the stream, or null at EOS.\n   * \n   * @deprecated The returned Token is a \"full private copy\" (not re-used across\n   *             calls to {@link #next()}) but will be slower than calling\n   *             {@link #next(Token)} or using the new {@link #incrementToken()}\n   *             method with the new {@link AttributeSource} API.\n   */\n  public Token next() throws IOException {\n    if (onlyUseNewAPI)\n      throw new UnsupportedOperationException(\"This TokenStream only supports the new Attributes API.\");\n    \n    if (supportedMethods.hasIncrementToken) {\n      return incrementToken() ? ((Token) tokenWrapper.delegate.clone()) : null;\n    } else {\n      assert supportedMethods.hasReusableNext;\n      final Token token = next(tokenWrapper.delegate);\n      if (token == null) return null;\n      tokenWrapper.delegate = token;\n      return (Token) token.clone();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93995eb4992a09cc5a4b13b04225eca0bca45d57","date":1253288184,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/TokenStream#next().mjava","pathOld":"src/java/org/apache/lucene/analysis/TokenStream#next().mjava","sourceNew":"  /**\n   * Returns the next {@link Token} in the stream, or null at EOS.\n   * \n   * @deprecated The returned Token is a \"full private copy\" (not re-used across\n   *             calls to {@link #next()}) but will be slower than calling\n   *             {@link #next(Token)} or using the new {@link #incrementToken()}\n   *             method with the new {@link AttributeSource} API.\n   */\n  public Token next() throws IOException {\n    if (tokenWrapper == null)\n      throw new UnsupportedOperationException(\"This TokenStream only supports the new Attributes API.\");\n    \n    final Token nextToken;\n    if (supportedMethods.hasIncrementToken) {\n      final Token savedDelegate = tokenWrapper.delegate;\n      tokenWrapper.delegate = new Token();\n      nextToken = incrementToken() ? tokenWrapper.delegate : null;\n      tokenWrapper.delegate = savedDelegate;\n    } else {\n      assert supportedMethods.hasReusableNext;\n      nextToken = next(new Token());\n    }\n    \n    if (nextToken != null) {\n      Payload p = nextToken.getPayload();\n      if (p != null) {\n        nextToken.setPayload((Payload) p.clone());\n      }\n    }\n    return nextToken;\n  }\n\n","sourceOld":"  /**\n   * Returns the next {@link Token} in the stream, or null at EOS.\n   * \n   * @deprecated The returned Token is a \"full private copy\" (not re-used across\n   *             calls to {@link #next()}) but will be slower than calling\n   *             {@link #next(Token)} or using the new {@link #incrementToken()}\n   *             method with the new {@link AttributeSource} API.\n   */\n  public Token next() throws IOException {\n    if (tokenWrapper == null)\n      throw new UnsupportedOperationException(\"This TokenStream only supports the new Attributes API.\");\n    \n    if (supportedMethods.hasIncrementToken) {\n      return incrementToken() ? ((Token) tokenWrapper.delegate.clone()) : null;\n    } else {\n      assert supportedMethods.hasReusableNext;\n      final Token token = next(tokenWrapper.delegate);\n      if (token == null) return null;\n      tokenWrapper.delegate = token;\n      return (Token) token.clone();\n    }\n  }\n\n","bugFix":["ec8b5a20a12931b8d7e616c79c5248ae06cc5568"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"439b0fe2f799d1c722151e88e32bdefad8d34ebe","date":1255282509,"type":4,"author":"Uwe Schindler","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/analysis/TokenStream#next().mjava","sourceNew":null,"sourceOld":"  /**\n   * Returns the next {@link Token} in the stream, or null at EOS.\n   * \n   * @deprecated The returned Token is a \"full private copy\" (not re-used across\n   *             calls to {@link #next()}) but will be slower than calling\n   *             {@link #next(Token)} or using the new {@link #incrementToken()}\n   *             method with the new {@link AttributeSource} API.\n   */\n  public Token next() throws IOException {\n    if (tokenWrapper == null)\n      throw new UnsupportedOperationException(\"This TokenStream only supports the new Attributes API.\");\n    \n    final Token nextToken;\n    if (supportedMethods.hasIncrementToken) {\n      final Token savedDelegate = tokenWrapper.delegate;\n      tokenWrapper.delegate = new Token();\n      nextToken = incrementToken() ? tokenWrapper.delegate : null;\n      tokenWrapper.delegate = savedDelegate;\n    } else {\n      assert supportedMethods.hasReusableNext;\n      nextToken = next(new Token());\n    }\n    \n    if (nextToken != null) {\n      Payload p = nextToken.getPayload();\n      if (p != null) {\n        nextToken.setPayload((Payload) p.clone());\n      }\n    }\n    return nextToken;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7e2cb543b41c145f33390f460ee743d6693c9c6c":["97c663a0e8cf62834049da11ecd70bd4a639ac9c"],"6864413dbc0c12104c978c05456f3da1d45adb03":["03ae70812bc33b0270c1366378b2c2da95fe86a6"],"91109046a59c58ee0ee5d0d2767b08d1f30d6702":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"439b0fe2f799d1c722151e88e32bdefad8d34ebe":["93995eb4992a09cc5a4b13b04225eca0bca45d57"],"97c663a0e8cf62834049da11ecd70bd4a639ac9c":["66ba51c00e882f0132a67162dc4fd8e4340f8618"],"39c72a0a1f317a4165b759c7842b5d73d7858d1d":["0833fee1ce16a2b8e10f21cbccd2e93f3d8ccf31"],"0833fee1ce16a2b8e10f21cbccd2e93f3d8ccf31":["ec8b5a20a12931b8d7e616c79c5248ae06cc5568"],"93995eb4992a09cc5a4b13b04225eca0bca45d57":["f4821e344090113a4e6d4d31265a0166ab07930d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"03ae70812bc33b0270c1366378b2c2da95fe86a6":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"f4821e344090113a4e6d4d31265a0166ab07930d":["39c72a0a1f317a4165b759c7842b5d73d7858d1d"],"66ba51c00e882f0132a67162dc4fd8e4340f8618":["6864413dbc0c12104c978c05456f3da1d45adb03"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["439b0fe2f799d1c722151e88e32bdefad8d34ebe"],"ec8b5a20a12931b8d7e616c79c5248ae06cc5568":["7e2cb543b41c145f33390f460ee743d6693c9c6c"]},"commit2Childs":{"7e2cb543b41c145f33390f460ee743d6693c9c6c":["ec8b5a20a12931b8d7e616c79c5248ae06cc5568"],"6864413dbc0c12104c978c05456f3da1d45adb03":["66ba51c00e882f0132a67162dc4fd8e4340f8618"],"91109046a59c58ee0ee5d0d2767b08d1f30d6702":["03ae70812bc33b0270c1366378b2c2da95fe86a6"],"97c663a0e8cf62834049da11ecd70bd4a639ac9c":["7e2cb543b41c145f33390f460ee743d6693c9c6c"],"439b0fe2f799d1c722151e88e32bdefad8d34ebe":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"39c72a0a1f317a4165b759c7842b5d73d7858d1d":["f4821e344090113a4e6d4d31265a0166ab07930d"],"0833fee1ce16a2b8e10f21cbccd2e93f3d8ccf31":["39c72a0a1f317a4165b759c7842b5d73d7858d1d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"93995eb4992a09cc5a4b13b04225eca0bca45d57":["439b0fe2f799d1c722151e88e32bdefad8d34ebe"],"03ae70812bc33b0270c1366378b2c2da95fe86a6":["6864413dbc0c12104c978c05456f3da1d45adb03"],"66ba51c00e882f0132a67162dc4fd8e4340f8618":["97c663a0e8cf62834049da11ecd70bd4a639ac9c"],"f4821e344090113a4e6d4d31265a0166ab07930d":["93995eb4992a09cc5a4b13b04225eca0bca45d57"],"ec8b5a20a12931b8d7e616c79c5248ae06cc5568":["0833fee1ce16a2b8e10f21cbccd2e93f3d8ccf31"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}