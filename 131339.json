{"path":"lucene/src/test/org/apache/lucene/index/TestFilterIndexReader#testOverrideMethods().mjava","commits":[{"id":"43d5fa62da3987dc94d3b33e427840fe4c5295d5","date":1323279355,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestFilterIndexReader#testOverrideMethods().mjava","pathOld":"/dev/null","sourceNew":"  public void testOverrideMethods() throws Exception {\n    HashSet<String> methodsThatShouldNotBeOverridden = new HashSet<String>();\n    methodsThatShouldNotBeOverridden.add(\"doOpenIfChanged\");\n    methodsThatShouldNotBeOverridden.add(\"clone\");\n    boolean fail = false;\n    for (Method m : FilterIndexReader.class.getMethods()) {\n      int mods = m.getModifiers();\n      if (Modifier.isStatic(mods) || Modifier.isFinal(mods)) {\n        continue;\n      }\n      Class< ? > declaringClass = m.getDeclaringClass();\n      String name = m.getName();\n      if (declaringClass != FilterIndexReader.class && declaringClass != Object.class && !methodsThatShouldNotBeOverridden.contains(name)) {\n        System.err.println(\"method is not overridden by FilterIndexReader: \" + name);\n        fail = true;\n      } else if (declaringClass == FilterIndexReader.class && methodsThatShouldNotBeOverridden.contains(name)) {\n        System.err.println(\"method should not be overridden by FilterIndexReader: \" + name);\n        fail = true;\n      }\n    }\n    assertFalse(\"FilterIndexReader overrides (or not) some problematic methods; see log above\", fail);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3615ce4a1f785ae1b779244de52c6a7d99227e60","date":1323422019,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestFilterIndexReader#testOverrideMethods().mjava","pathOld":"/dev/null","sourceNew":"  public void testOverrideMethods() throws Exception {\n    HashSet<String> methodsThatShouldNotBeOverridden = new HashSet<String>();\n    methodsThatShouldNotBeOverridden.add(\"doOpenIfChanged\");\n    methodsThatShouldNotBeOverridden.add(\"clone\");\n    boolean fail = false;\n    for (Method m : FilterIndexReader.class.getMethods()) {\n      int mods = m.getModifiers();\n      if (Modifier.isStatic(mods) || Modifier.isFinal(mods)) {\n        continue;\n      }\n      Class< ? > declaringClass = m.getDeclaringClass();\n      String name = m.getName();\n      if (declaringClass != FilterIndexReader.class && declaringClass != Object.class && !methodsThatShouldNotBeOverridden.contains(name)) {\n        System.err.println(\"method is not overridden by FilterIndexReader: \" + name);\n        fail = true;\n      } else if (declaringClass == FilterIndexReader.class && methodsThatShouldNotBeOverridden.contains(name)) {\n        System.err.println(\"method should not be overridden by FilterIndexReader: \" + name);\n        fail = true;\n      }\n    }\n    assertFalse(\"FilterIndexReader overrides (or not) some problematic methods; see log above\", fail);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","date":1323437438,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestFilterIndexReader#testOverrideMethods().mjava","pathOld":"/dev/null","sourceNew":"  public void testOverrideMethods() throws Exception {\n    HashSet<String> methodsThatShouldNotBeOverridden = new HashSet<String>();\n    methodsThatShouldNotBeOverridden.add(\"doOpenIfChanged\");\n    methodsThatShouldNotBeOverridden.add(\"clone\");\n    boolean fail = false;\n    for (Method m : FilterIndexReader.class.getMethods()) {\n      int mods = m.getModifiers();\n      if (Modifier.isStatic(mods) || Modifier.isFinal(mods)) {\n        continue;\n      }\n      Class< ? > declaringClass = m.getDeclaringClass();\n      String name = m.getName();\n      if (declaringClass != FilterIndexReader.class && declaringClass != Object.class && !methodsThatShouldNotBeOverridden.contains(name)) {\n        System.err.println(\"method is not overridden by FilterIndexReader: \" + name);\n        fail = true;\n      } else if (declaringClass == FilterIndexReader.class && methodsThatShouldNotBeOverridden.contains(name)) {\n        System.err.println(\"method should not be overridden by FilterIndexReader: \" + name);\n        fail = true;\n      }\n    }\n    assertFalse(\"FilterIndexReader overrides (or not) some problematic methods; see log above\", fail);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"868186558eb3a854ce7e720a52bb445795d54910","date":1327853682,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestFilterIndexReader#testOverrideMethods().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestFilterIndexReader#testOverrideMethods().mjava","sourceNew":"  public void testOverrideMethods() throws Exception {\n    boolean fail = false;\n    for (Method m : FilterIndexReader.class.getMethods()) {\n      int mods = m.getModifiers();\n      if (Modifier.isStatic(mods) || Modifier.isFinal(mods) || m.isSynthetic()) {\n        continue;\n      }\n      Class<?> declaringClass = m.getDeclaringClass();\n      String name = m.getName();\n      if (declaringClass != FilterIndexReader.class && declaringClass != Object.class) {\n        System.err.println(\"method is not overridden by FilterIndexReader: \" + name);\n        fail = true;\n      }\n    }\n    assertFalse(\"FilterIndexReader overrides (or not) some problematic methods; see log above\", fail);\n  }\n\n","sourceOld":"  public void testOverrideMethods() throws Exception {\n    HashSet<String> methodsThatShouldNotBeOverridden = new HashSet<String>();\n    methodsThatShouldNotBeOverridden.add(\"doOpenIfChanged\");\n    methodsThatShouldNotBeOverridden.add(\"clone\");\n    boolean fail = false;\n    for (Method m : FilterIndexReader.class.getMethods()) {\n      int mods = m.getModifiers();\n      if (Modifier.isStatic(mods) || Modifier.isFinal(mods)) {\n        continue;\n      }\n      Class< ? > declaringClass = m.getDeclaringClass();\n      String name = m.getName();\n      if (declaringClass != FilterIndexReader.class && declaringClass != Object.class && !methodsThatShouldNotBeOverridden.contains(name)) {\n        System.err.println(\"method is not overridden by FilterIndexReader: \" + name);\n        fail = true;\n      } else if (declaringClass == FilterIndexReader.class && methodsThatShouldNotBeOverridden.contains(name)) {\n        System.err.println(\"method should not be overridden by FilterIndexReader: \" + name);\n        fail = true;\n      }\n    }\n    assertFalse(\"FilterIndexReader overrides (or not) some problematic methods; see log above\", fail);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestFilterIndexReader#testOverrideMethods().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestFilterIndexReader#testOverrideMethods().mjava","sourceNew":"  public void testOverrideMethods() throws Exception {\n    boolean fail = false;\n    for (Method m : FilterIndexReader.class.getMethods()) {\n      int mods = m.getModifiers();\n      if (Modifier.isStatic(mods) || Modifier.isFinal(mods) || m.isSynthetic()) {\n        continue;\n      }\n      Class<?> declaringClass = m.getDeclaringClass();\n      String name = m.getName();\n      if (declaringClass != FilterIndexReader.class && declaringClass != Object.class) {\n        System.err.println(\"method is not overridden by FilterIndexReader: \" + name);\n        fail = true;\n      }\n    }\n    assertFalse(\"FilterIndexReader overrides (or not) some problematic methods; see log above\", fail);\n  }\n\n","sourceOld":"  public void testOverrideMethods() throws Exception {\n    HashSet<String> methodsThatShouldNotBeOverridden = new HashSet<String>();\n    methodsThatShouldNotBeOverridden.add(\"doOpenIfChanged\");\n    methodsThatShouldNotBeOverridden.add(\"clone\");\n    boolean fail = false;\n    for (Method m : FilterIndexReader.class.getMethods()) {\n      int mods = m.getModifiers();\n      if (Modifier.isStatic(mods) || Modifier.isFinal(mods)) {\n        continue;\n      }\n      Class< ? > declaringClass = m.getDeclaringClass();\n      String name = m.getName();\n      if (declaringClass != FilterIndexReader.class && declaringClass != Object.class && !methodsThatShouldNotBeOverridden.contains(name)) {\n        System.err.println(\"method is not overridden by FilterIndexReader: \" + name);\n        fail = true;\n      } else if (declaringClass == FilterIndexReader.class && methodsThatShouldNotBeOverridden.contains(name)) {\n        System.err.println(\"method should not be overridden by FilterIndexReader: \" + name);\n        fail = true;\n      }\n    }\n    assertFalse(\"FilterIndexReader overrides (or not) some problematic methods; see log above\", fail);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestFilterIndexReader#testOverrideMethods().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestFilterIndexReader#testOverrideMethods().mjava","sourceNew":"  public void testOverrideMethods() throws Exception {\n    boolean fail = false;\n    for (Method m : FilterIndexReader.class.getMethods()) {\n      int mods = m.getModifiers();\n      if (Modifier.isStatic(mods) || Modifier.isFinal(mods) || m.isSynthetic()) {\n        continue;\n      }\n      Class<?> declaringClass = m.getDeclaringClass();\n      String name = m.getName();\n      if (declaringClass != FilterIndexReader.class && declaringClass != Object.class) {\n        System.err.println(\"method is not overridden by FilterIndexReader: \" + name);\n        fail = true;\n      }\n    }\n    assertFalse(\"FilterIndexReader overrides (or not) some problematic methods; see log above\", fail);\n  }\n\n","sourceOld":"  public void testOverrideMethods() throws Exception {\n    boolean fail = false;\n    for (Method m : FilterIndexReader.class.getMethods()) {\n      int mods = m.getModifiers();\n      if (Modifier.isStatic(mods) || Modifier.isFinal(mods) || m.isSynthetic()) {\n        continue;\n      }\n      Class<?> declaringClass = m.getDeclaringClass();\n      String name = m.getName();\n      if (declaringClass != FilterIndexReader.class && declaringClass != Object.class) {\n        System.err.println(\"method is not overridden by FilterIndexReader: \" + name);\n        fail = true;\n      }\n    }\n    assertFalse(\"FilterIndexReader overrides (or not) some problematic methods; see log above\", fail);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"43d5fa62da3987dc94d3b33e427840fe4c5295d5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3615ce4a1f785ae1b779244de52c6a7d99227e60"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3615ce4a1f785ae1b779244de52c6a7d99227e60":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","43d5fa62da3987dc94d3b33e427840fe4c5295d5"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["3615ce4a1f785ae1b779244de52c6a7d99227e60","868186558eb3a854ce7e720a52bb445795d54910"],"868186558eb3a854ce7e720a52bb445795d54910":["3615ce4a1f785ae1b779244de52c6a7d99227e60"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"43d5fa62da3987dc94d3b33e427840fe4c5295d5":["3615ce4a1f785ae1b779244de52c6a7d99227e60"],"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["43d5fa62da3987dc94d3b33e427840fe4c5295d5","ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","3615ce4a1f785ae1b779244de52c6a7d99227e60"],"3615ce4a1f785ae1b779244de52c6a7d99227e60":["ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","5cab9a86bd67202d20b6adc463008c8e982b070a","868186558eb3a854ce7e720a52bb445795d54910"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"868186558eb3a854ce7e720a52bb445795d54910":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}