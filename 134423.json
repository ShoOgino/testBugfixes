{"path":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#intersect(QueryState,int,int,int,int,int).mjava","commits":[{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#intersect(QueryState,int,int,int,int,int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#intersect(Bits,QueryState,int,int,int,int,int).mjava","sourceNew":"  private int intersect(QueryState state,\n                        int nodeID,\n                        int cellLatMinEnc, int cellLatMaxEnc, int cellLonMinEnc, int cellLonMaxEnc)\n    throws IOException {\n\n    // 2.06 sec -> 1.52 sec for 225 OSM London queries:\n    if (state.latLonFilter != null) {\n      if (cellLatMinEnc > state.latMinEnc ||\n          cellLatMaxEnc < state.latMaxEnc ||\n          cellLonMinEnc > state.lonMinEnc ||\n          cellLonMaxEnc < state.lonMaxEnc) {\n        Relation r = state.latLonFilter.compare(BKDTreeWriter.decodeLat(cellLatMinEnc),\n                                                BKDTreeWriter.decodeLat(cellLatMaxEnc),\n                                                BKDTreeWriter.decodeLon(cellLonMinEnc),\n                                                BKDTreeWriter.decodeLon(cellLonMaxEnc));\n        //System.out.println(\"BKD.intersect cellLat=\" + BKDTreeWriter.decodeLat(cellLatMinEnc) + \" TO \" + BKDTreeWriter.decodeLat(cellLatMaxEnc) + \", cellLon=\" + BKDTreeWriter.decodeLon(cellLonMinEnc) + \" TO \" + BKDTreeWriter.decodeLon(cellLonMaxEnc) + \" compare=\" + r);\n        if (r == Relation.OUTSIDE) {\n          // This cell is fully outside of the query shape: stop recursing\n          return 0;\n        } else if (r == Relation.INSIDE) {\n          // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n          return addAll(state, nodeID);\n        } else {\n          // The cell crosses the shape boundary, so we fall through and do full filtering\n        }\n      }\n    } else if (state.latMinEnc <= cellLatMinEnc && state.latMaxEnc >= cellLatMaxEnc && state.lonMinEnc <= cellLonMinEnc && state.lonMaxEnc >= cellLonMaxEnc) {\n      // Optimize the case when the query fully contains this cell: we can\n      // recursively add all points without checking if they match the query:\n      return addAll(state, nodeID);\n    }\n\n    long latRange = (long) cellLatMaxEnc - (long) cellLatMinEnc;\n    long lonRange = (long) cellLonMaxEnc - (long) cellLonMinEnc;\n\n    int dim;\n    if (latRange >= lonRange) {\n      dim = 0;\n    } else {\n      dim = 1;\n    }\n\n    //System.out.println(\"\\nintersect node=\" + nodeID + \" vs \" + leafNodeOffset);\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node; scan and filter all points in this block:\n      //System.out.println(\"    intersect leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + leafBlockFPs[nodeID-leafNodeOffset]);\n      int hitCount = 0;\n\n      //IndexInput in = leafDISI.in;\n      long fp = leafBlockFPs[nodeID-leafNodeOffset];\n      if (fp == 0) {\n        // Dead end node (adversary case):\n        //System.out.println(\"    dead-end leaf\");\n        return 0;\n      }\n\n      /*\n      System.out.println(\"I: \" + BKDTreeWriter.decodeLat(cellLatMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLat(cellLatMaxEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMaxEnc));\n      */\n\n      state.in.seek(fp);\n\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n\n      for(int i=0;i<count;i++) {\n        int docID = state.in.readInt();\n        state.sndv.setDocument(docID);\n        // How many values this doc has:\n        int docValueCount = state.sndv.count();\n        for(int j=0;j<docValueCount;j++) {\n          long enc = state.sndv.valueAt(j);\n\n          int latEnc = (int) ((enc>>32) & 0xffffffffL);\n          int lonEnc = (int) (enc & 0xffffffffL);\n\n          if (latEnc >= state.latMinEnc &&\n              latEnc < state.latMaxEnc &&\n              lonEnc >= state.lonMinEnc &&\n              lonEnc < state.lonMaxEnc &&\n              (state.latLonFilter == null ||\n               state.latLonFilter.accept(BKDTreeWriter.decodeLat(latEnc), BKDTreeWriter.decodeLon(lonEnc)))) {\n            state.bits.set(docID);\n            hitCount++;\n\n            // Stop processing values for this doc:\n            break;\n          }\n        }\n      }\n\n      return hitCount;\n\n      // this (using BitDocIdSet.Builder) is 3.4X slower!\n      /*\n      //bits.or(leafDISI);\n      //return leafDISI.getHitCount();\n      */\n\n    } else {\n\n      int splitValue = splitValues[nodeID];\n\n      if (splitValue == Integer.MAX_VALUE) {\n        // Dead end node (adversary case):\n        //System.out.println(\"    dead-end sub-tree\");\n        return 0;\n      }\n\n      //System.out.println(\"  splitValue=\" + splitValue);\n\n      int count = 0;\n\n      if (dim == 0) {\n\n        //System.out.println(\"  split on lat=\" + splitValue);\n\n        // Inner node split on lat:\n\n        // Left node:\n        if (state.latMinEnc < splitValue) {\n          //System.out.println(\"  recurse left\");\n          count += intersect(state,\n                             2*nodeID,\n                             cellLatMinEnc, splitValue, cellLonMinEnc, cellLonMaxEnc);\n        }\n\n        // Right node:\n        if (state.latMaxEnc >= splitValue) {\n          //System.out.println(\"  recurse right\");\n          count += intersect(state,\n                             2*nodeID+1,\n                             splitValue, cellLatMaxEnc, cellLonMinEnc, cellLonMaxEnc);\n        }\n\n      } else {\n        // Inner node split on lon:\n        assert dim == 1;\n\n        // System.out.println(\"  split on lon=\" + splitValue);\n\n        // Left node:\n        if (state.lonMinEnc < splitValue) {\n          // System.out.println(\"  recurse left\");\n          count += intersect(state,\n                             2*nodeID,\n                             cellLatMinEnc, cellLatMaxEnc, cellLonMinEnc, splitValue);\n        }\n\n        // Right node:\n        if (state.lonMaxEnc >= splitValue) {\n          // System.out.println(\"  recurse right\");\n          count += intersect(state,\n                             2*nodeID+1,\n                             cellLatMinEnc, cellLatMaxEnc, splitValue, cellLonMaxEnc);\n        }\n      }\n\n      return count;\n    }\n  }\n\n","sourceOld":"  private int intersect(Bits acceptDocs, QueryState state,\n                        int nodeID,\n                        int cellLatMinEnc, int cellLatMaxEnc, int cellLonMinEnc, int cellLonMaxEnc)\n    throws IOException {\n\n    // 2.06 sec -> 1.52 sec for 225 OSM London queries:\n    if (state.latLonFilter != null) {\n      if (cellLatMinEnc > state.latMinEnc ||\n          cellLatMaxEnc < state.latMaxEnc ||\n          cellLonMinEnc > state.lonMinEnc ||\n          cellLonMaxEnc < state.lonMaxEnc) {\n        Relation r = state.latLonFilter.compare(BKDTreeWriter.decodeLat(cellLatMinEnc),\n                                                BKDTreeWriter.decodeLat(cellLatMaxEnc),\n                                                BKDTreeWriter.decodeLon(cellLonMinEnc),\n                                                BKDTreeWriter.decodeLon(cellLonMaxEnc));\n        //System.out.println(\"BKD.intersect cellLat=\" + BKDTreeWriter.decodeLat(cellLatMinEnc) + \" TO \" + BKDTreeWriter.decodeLat(cellLatMaxEnc) + \", cellLon=\" + BKDTreeWriter.decodeLon(cellLonMinEnc) + \" TO \" + BKDTreeWriter.decodeLon(cellLonMaxEnc) + \" compare=\" + r);\n        if (r == Relation.OUTSIDE) {\n          // This cell is fully outside of the query shape: stop recursing\n          return 0;\n        } else if (r == Relation.INSIDE) {\n          // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n          return addAll(acceptDocs, state, nodeID);\n        } else {\n          // The cell crosses the shape boundary, so we fall through and do full filtering\n        }\n      }\n    } else if (state.latMinEnc <= cellLatMinEnc && state.latMaxEnc >= cellLatMaxEnc && state.lonMinEnc <= cellLonMinEnc && state.lonMaxEnc >= cellLonMaxEnc) {\n      // Optimize the case when the query fully contains this cell: we can\n      // recursively add all points without checking if they match the query:\n      return addAll(acceptDocs, state, nodeID);\n    }\n\n    long latRange = (long) cellLatMaxEnc - (long) cellLatMinEnc;\n    long lonRange = (long) cellLonMaxEnc - (long) cellLonMinEnc;\n\n    int dim;\n    if (latRange >= lonRange) {\n      dim = 0;\n    } else {\n      dim = 1;\n    }\n\n    //System.out.println(\"\\nintersect node=\" + nodeID + \" vs \" + leafNodeOffset);\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node; scan and filter all points in this block:\n      //System.out.println(\"    intersect leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + leafBlockFPs[nodeID-leafNodeOffset]);\n      int hitCount = 0;\n\n      //IndexInput in = leafDISI.in;\n      long fp = leafBlockFPs[nodeID-leafNodeOffset];\n      if (fp == 0) {\n        // Dead end node (adversary case):\n        //System.out.println(\"    dead-end leaf\");\n        return 0;\n      }\n\n      /*\n      System.out.println(\"I: \" + BKDTreeWriter.decodeLat(cellLatMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLat(cellLatMaxEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMaxEnc));\n      */\n\n      state.in.seek(fp);\n\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n\n      for(int i=0;i<count;i++) {\n        int docID = state.in.readInt();\n        if (acceptDocs == null || acceptDocs.get(docID)) {\n          state.sndv.setDocument(docID);\n          // How many values this doc has:\n          int docValueCount = state.sndv.count();\n          for(int j=0;j<docValueCount;j++) {\n            long enc = state.sndv.valueAt(j);\n\n            int latEnc = (int) ((enc>>32) & 0xffffffffL);\n            int lonEnc = (int) (enc & 0xffffffffL);\n\n            if (latEnc >= state.latMinEnc &&\n                latEnc < state.latMaxEnc &&\n                lonEnc >= state.lonMinEnc &&\n                lonEnc < state.lonMaxEnc &&\n                (state.latLonFilter == null ||\n                 state.latLonFilter.accept(BKDTreeWriter.decodeLat(latEnc), BKDTreeWriter.decodeLon(lonEnc)))) {\n              state.bits.set(docID);\n              hitCount++;\n\n              // Stop processing values for this doc:\n              break;\n            }\n          }\n        }\n      }\n\n      return hitCount;\n\n      // this (using BitDocIdSet.Builder) is 3.4X slower!\n      /*\n      //bits.or(leafDISI);\n      //return leafDISI.getHitCount();\n      */\n\n    } else {\n\n      int splitValue = splitValues[nodeID];\n\n      if (splitValue == Integer.MAX_VALUE) {\n        // Dead end node (adversary case):\n        //System.out.println(\"    dead-end sub-tree\");\n        return 0;\n      }\n\n      //System.out.println(\"  splitValue=\" + splitValue);\n\n      int count = 0;\n\n      if (dim == 0) {\n\n        //System.out.println(\"  split on lat=\" + splitValue);\n\n        // Inner node split on lat:\n\n        // Left node:\n        if (state.latMinEnc < splitValue) {\n          //System.out.println(\"  recurse left\");\n          count += intersect(acceptDocs, state,\n                             2*nodeID,\n                             cellLatMinEnc, splitValue, cellLonMinEnc, cellLonMaxEnc);\n        }\n\n        // Right node:\n        if (state.latMaxEnc >= splitValue) {\n          //System.out.println(\"  recurse right\");\n          count += intersect(acceptDocs, state,\n                             2*nodeID+1,\n                             splitValue, cellLatMaxEnc, cellLonMinEnc, cellLonMaxEnc);\n        }\n\n      } else {\n        // Inner node split on lon:\n        assert dim == 1;\n\n        // System.out.println(\"  split on lon=\" + splitValue);\n\n        // Left node:\n        if (state.lonMinEnc < splitValue) {\n          // System.out.println(\"  recurse left\");\n          count += intersect(acceptDocs, state,\n                             2*nodeID,\n                             cellLatMinEnc, cellLatMaxEnc, cellLonMinEnc, splitValue);\n        }\n\n        // Right node:\n        if (state.lonMaxEnc >= splitValue) {\n          // System.out.println(\"  recurse right\");\n          count += intersect(acceptDocs, state,\n                             2*nodeID+1,\n                             cellLatMinEnc, cellLatMaxEnc, splitValue, cellLonMaxEnc);\n        }\n      }\n\n      return count;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e91a2d9ed80172872da0f517870da6756289554","date":1436431140,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#intersect(QueryState,int,int,int,int,int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#intersect(QueryState,int,int,int,int,int).mjava","sourceNew":"  private int intersect(QueryState state,\n                        int nodeID,\n                        int cellLatMinEnc, int cellLatMaxEnc, int cellLonMinEnc, int cellLonMaxEnc)\n    throws IOException {\n\n    // 2.06 sec -> 1.52 sec for 225 OSM London queries:\n    if (state.latLonFilter != null) {\n      if (cellLatMinEnc > state.latMinEnc ||\n          cellLatMaxEnc < state.latMaxEnc ||\n          cellLonMinEnc > state.lonMinEnc ||\n          cellLonMaxEnc < state.lonMaxEnc) {\n        Relation r = state.latLonFilter.compare(BKDTreeWriter.decodeLat(cellLatMinEnc),\n                                                BKDTreeWriter.decodeLat(cellLatMaxEnc),\n                                                BKDTreeWriter.decodeLon(cellLonMinEnc),\n                                                BKDTreeWriter.decodeLon(cellLonMaxEnc));\n        //System.out.println(\"BKD.intersect cellLat=\" + BKDTreeWriter.decodeLat(cellLatMinEnc) + \" TO \" + BKDTreeWriter.decodeLat(cellLatMaxEnc) + \", cellLon=\" + BKDTreeWriter.decodeLon(cellLonMinEnc) + \" TO \" + BKDTreeWriter.decodeLon(cellLonMaxEnc) + \" compare=\" + r);\n        if (r == Relation.OUTSIDE) {\n          // This cell is fully outside of the query shape: stop recursing\n          return 0;\n        } else if (r == Relation.INSIDE) {\n          // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n          return addAll(state, nodeID);\n        } else {\n          // The cell crosses the shape boundary, so we fall through and do full filtering\n        }\n      }\n    } else if (state.latMinEnc <= cellLatMinEnc && state.latMaxEnc >= cellLatMaxEnc && state.lonMinEnc <= cellLonMinEnc && state.lonMaxEnc >= cellLonMaxEnc) {\n      // Optimize the case when the query fully contains this cell: we can\n      // recursively add all points without checking if they match the query:\n      return addAll(state, nodeID);\n    }\n\n    long latRange = (long) cellLatMaxEnc - (long) cellLatMinEnc;\n    long lonRange = (long) cellLonMaxEnc - (long) cellLonMinEnc;\n\n    int dim;\n    if (latRange >= lonRange) {\n      dim = 0;\n    } else {\n      dim = 1;\n    }\n\n    //System.out.println(\"\\nintersect node=\" + nodeID + \" vs \" + leafNodeOffset);\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node; scan and filter all points in this block:\n      //System.out.println(\"    intersect leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + leafBlockFPs[nodeID-leafNodeOffset]);\n      int hitCount = 0;\n\n      //IndexInput in = leafDISI.in;\n      long fp = leafBlockFPs[nodeID-leafNodeOffset];\n      if (fp == 0) {\n        // Dead end node (adversary case):\n        //System.out.println(\"    dead-end leaf\");\n        return 0;\n      }\n\n      /*\n      System.out.println(\"I: \" + BKDTreeWriter.decodeLat(cellLatMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLat(cellLatMaxEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMaxEnc));\n      */\n\n      state.in.seek(fp);\n\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n\n      state.docs.grow(count);\n      for(int i=0;i<count;i++) {\n        int docID = state.in.readInt();\n        state.sndv.setDocument(docID);\n        // How many values this doc has:\n        int docValueCount = state.sndv.count();\n        for(int j=0;j<docValueCount;j++) {\n          long enc = state.sndv.valueAt(j);\n\n          int latEnc = (int) ((enc>>32) & 0xffffffffL);\n          int lonEnc = (int) (enc & 0xffffffffL);\n\n          if (latEnc >= state.latMinEnc &&\n              latEnc < state.latMaxEnc &&\n              lonEnc >= state.lonMinEnc &&\n              lonEnc < state.lonMaxEnc &&\n              (state.latLonFilter == null ||\n               state.latLonFilter.accept(BKDTreeWriter.decodeLat(latEnc), BKDTreeWriter.decodeLon(lonEnc)))) {\n            state.docs.add(docID);\n            hitCount++;\n\n            // Stop processing values for this doc:\n            break;\n          }\n        }\n      }\n\n      return hitCount;\n\n      // this (using BitDocIdSet.Builder) is 3.4X slower!\n      /*\n      //bits.or(leafDISI);\n      //return leafDISI.getHitCount();\n      */\n\n    } else {\n\n      int splitValue = splitValues[nodeID];\n\n      if (splitValue == Integer.MAX_VALUE) {\n        // Dead end node (adversary case):\n        //System.out.println(\"    dead-end sub-tree\");\n        return 0;\n      }\n\n      //System.out.println(\"  splitValue=\" + splitValue);\n\n      int count = 0;\n\n      if (dim == 0) {\n\n        //System.out.println(\"  split on lat=\" + splitValue);\n\n        // Inner node split on lat:\n\n        // Left node:\n        if (state.latMinEnc < splitValue) {\n          //System.out.println(\"  recurse left\");\n          count += intersect(state,\n                             2*nodeID,\n                             cellLatMinEnc, splitValue, cellLonMinEnc, cellLonMaxEnc);\n        }\n\n        // Right node:\n        if (state.latMaxEnc >= splitValue) {\n          //System.out.println(\"  recurse right\");\n          count += intersect(state,\n                             2*nodeID+1,\n                             splitValue, cellLatMaxEnc, cellLonMinEnc, cellLonMaxEnc);\n        }\n\n      } else {\n        // Inner node split on lon:\n        assert dim == 1;\n\n        // System.out.println(\"  split on lon=\" + splitValue);\n\n        // Left node:\n        if (state.lonMinEnc < splitValue) {\n          // System.out.println(\"  recurse left\");\n          count += intersect(state,\n                             2*nodeID,\n                             cellLatMinEnc, cellLatMaxEnc, cellLonMinEnc, splitValue);\n        }\n\n        // Right node:\n        if (state.lonMaxEnc >= splitValue) {\n          // System.out.println(\"  recurse right\");\n          count += intersect(state,\n                             2*nodeID+1,\n                             cellLatMinEnc, cellLatMaxEnc, splitValue, cellLonMaxEnc);\n        }\n      }\n\n      return count;\n    }\n  }\n\n","sourceOld":"  private int intersect(QueryState state,\n                        int nodeID,\n                        int cellLatMinEnc, int cellLatMaxEnc, int cellLonMinEnc, int cellLonMaxEnc)\n    throws IOException {\n\n    // 2.06 sec -> 1.52 sec for 225 OSM London queries:\n    if (state.latLonFilter != null) {\n      if (cellLatMinEnc > state.latMinEnc ||\n          cellLatMaxEnc < state.latMaxEnc ||\n          cellLonMinEnc > state.lonMinEnc ||\n          cellLonMaxEnc < state.lonMaxEnc) {\n        Relation r = state.latLonFilter.compare(BKDTreeWriter.decodeLat(cellLatMinEnc),\n                                                BKDTreeWriter.decodeLat(cellLatMaxEnc),\n                                                BKDTreeWriter.decodeLon(cellLonMinEnc),\n                                                BKDTreeWriter.decodeLon(cellLonMaxEnc));\n        //System.out.println(\"BKD.intersect cellLat=\" + BKDTreeWriter.decodeLat(cellLatMinEnc) + \" TO \" + BKDTreeWriter.decodeLat(cellLatMaxEnc) + \", cellLon=\" + BKDTreeWriter.decodeLon(cellLonMinEnc) + \" TO \" + BKDTreeWriter.decodeLon(cellLonMaxEnc) + \" compare=\" + r);\n        if (r == Relation.OUTSIDE) {\n          // This cell is fully outside of the query shape: stop recursing\n          return 0;\n        } else if (r == Relation.INSIDE) {\n          // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n          return addAll(state, nodeID);\n        } else {\n          // The cell crosses the shape boundary, so we fall through and do full filtering\n        }\n      }\n    } else if (state.latMinEnc <= cellLatMinEnc && state.latMaxEnc >= cellLatMaxEnc && state.lonMinEnc <= cellLonMinEnc && state.lonMaxEnc >= cellLonMaxEnc) {\n      // Optimize the case when the query fully contains this cell: we can\n      // recursively add all points without checking if they match the query:\n      return addAll(state, nodeID);\n    }\n\n    long latRange = (long) cellLatMaxEnc - (long) cellLatMinEnc;\n    long lonRange = (long) cellLonMaxEnc - (long) cellLonMinEnc;\n\n    int dim;\n    if (latRange >= lonRange) {\n      dim = 0;\n    } else {\n      dim = 1;\n    }\n\n    //System.out.println(\"\\nintersect node=\" + nodeID + \" vs \" + leafNodeOffset);\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node; scan and filter all points in this block:\n      //System.out.println(\"    intersect leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + leafBlockFPs[nodeID-leafNodeOffset]);\n      int hitCount = 0;\n\n      //IndexInput in = leafDISI.in;\n      long fp = leafBlockFPs[nodeID-leafNodeOffset];\n      if (fp == 0) {\n        // Dead end node (adversary case):\n        //System.out.println(\"    dead-end leaf\");\n        return 0;\n      }\n\n      /*\n      System.out.println(\"I: \" + BKDTreeWriter.decodeLat(cellLatMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLat(cellLatMaxEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMaxEnc));\n      */\n\n      state.in.seek(fp);\n\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n\n      for(int i=0;i<count;i++) {\n        int docID = state.in.readInt();\n        state.sndv.setDocument(docID);\n        // How many values this doc has:\n        int docValueCount = state.sndv.count();\n        for(int j=0;j<docValueCount;j++) {\n          long enc = state.sndv.valueAt(j);\n\n          int latEnc = (int) ((enc>>32) & 0xffffffffL);\n          int lonEnc = (int) (enc & 0xffffffffL);\n\n          if (latEnc >= state.latMinEnc &&\n              latEnc < state.latMaxEnc &&\n              lonEnc >= state.lonMinEnc &&\n              lonEnc < state.lonMaxEnc &&\n              (state.latLonFilter == null ||\n               state.latLonFilter.accept(BKDTreeWriter.decodeLat(latEnc), BKDTreeWriter.decodeLon(lonEnc)))) {\n            state.bits.set(docID);\n            hitCount++;\n\n            // Stop processing values for this doc:\n            break;\n          }\n        }\n      }\n\n      return hitCount;\n\n      // this (using BitDocIdSet.Builder) is 3.4X slower!\n      /*\n      //bits.or(leafDISI);\n      //return leafDISI.getHitCount();\n      */\n\n    } else {\n\n      int splitValue = splitValues[nodeID];\n\n      if (splitValue == Integer.MAX_VALUE) {\n        // Dead end node (adversary case):\n        //System.out.println(\"    dead-end sub-tree\");\n        return 0;\n      }\n\n      //System.out.println(\"  splitValue=\" + splitValue);\n\n      int count = 0;\n\n      if (dim == 0) {\n\n        //System.out.println(\"  split on lat=\" + splitValue);\n\n        // Inner node split on lat:\n\n        // Left node:\n        if (state.latMinEnc < splitValue) {\n          //System.out.println(\"  recurse left\");\n          count += intersect(state,\n                             2*nodeID,\n                             cellLatMinEnc, splitValue, cellLonMinEnc, cellLonMaxEnc);\n        }\n\n        // Right node:\n        if (state.latMaxEnc >= splitValue) {\n          //System.out.println(\"  recurse right\");\n          count += intersect(state,\n                             2*nodeID+1,\n                             splitValue, cellLatMaxEnc, cellLonMinEnc, cellLonMaxEnc);\n        }\n\n      } else {\n        // Inner node split on lon:\n        assert dim == 1;\n\n        // System.out.println(\"  split on lon=\" + splitValue);\n\n        // Left node:\n        if (state.lonMinEnc < splitValue) {\n          // System.out.println(\"  recurse left\");\n          count += intersect(state,\n                             2*nodeID,\n                             cellLatMinEnc, cellLatMaxEnc, cellLonMinEnc, splitValue);\n        }\n\n        // Right node:\n        if (state.lonMaxEnc >= splitValue) {\n          // System.out.println(\"  recurse right\");\n          count += intersect(state,\n                             2*nodeID+1,\n                             cellLatMinEnc, cellLatMaxEnc, splitValue, cellLonMaxEnc);\n        }\n      }\n\n      return count;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f64b7098768253180859cd8faeae6b1a185b06ed","date":1441223971,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#intersect(QueryState,int,int,int,int,int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#intersect(QueryState,int,int,int,int,int).mjava","sourceNew":"  private int intersect(QueryState state,\n                        int nodeID,\n                        int cellLatMinEnc, int cellLatMaxEnc, int cellLonMinEnc, int cellLonMaxEnc)\n    throws IOException {\n\n    // 2.06 sec -> 1.52 sec for 225 OSM London queries:\n    if (state.latLonFilter != null) {\n\n      // Only call the filter when the current cell does not fully contain the bbox:\n      if (cellLatMinEnc > state.latMinEnc || cellLatMaxEnc < state.latMaxEnc ||\n          cellLonMinEnc > state.lonMinEnc || cellLonMaxEnc < state.lonMaxEnc) {\n\n        Relation r = state.latLonFilter.compare(BKDTreeWriter.decodeLat(cellLatMinEnc),\n                                                BKDTreeWriter.decodeLat(cellLatMaxEnc),\n                                                BKDTreeWriter.decodeLon(cellLonMinEnc),\n                                                BKDTreeWriter.decodeLon(cellLonMaxEnc));\n        // System.out.println(\"BKD.intersect cellLat=\" + BKDTreeWriter.decodeLat(cellLatMinEnc) + \" TO \" + BKDTreeWriter.decodeLat(cellLatMaxEnc) + \", cellLon=\" + BKDTreeWriter.decodeLon(cellLonMinEnc) + \" TO \" + BKDTreeWriter.decodeLon(cellLonMaxEnc) + \" compare=\" + r);\n        if (r == Relation.SHAPE_OUTSIDE_CELL) {\n          // This cell is fully outside of the query shape: stop recursing\n          return 0;\n        } else if (r == Relation.CELL_INSIDE_SHAPE) {\n          // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n          return addAll(state, nodeID);\n        } else {\n          // The cell crosses the shape boundary, so we fall through and do full filtering\n        }\n      }\n    // TODO: clean this up: the bbox case should also just be a filter, and we should assert filter != null at the start\n    } else if (state.latMinEnc <= cellLatMinEnc && state.latMaxEnc >= cellLatMaxEnc && state.lonMinEnc <= cellLonMinEnc && state.lonMaxEnc >= cellLonMaxEnc) {\n      // Bbox query: optimize the case when the query fully contains this cell: we can\n      // recursively add all points without checking if they match the query:\n      return addAll(state, nodeID);\n    }\n\n    long latRange = (long) cellLatMaxEnc - (long) cellLatMinEnc;\n    long lonRange = (long) cellLonMaxEnc - (long) cellLonMinEnc;\n\n    int dim;\n    if (latRange >= lonRange) {\n      dim = 0;\n    } else {\n      dim = 1;\n    }\n\n    //System.out.println(\"\\nintersect node=\" + nodeID + \" vs \" + leafNodeOffset);\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node; scan and filter all points in this block:\n      //System.out.println(\"    intersect leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + leafBlockFPs[nodeID-leafNodeOffset]);\n      int hitCount = 0;\n\n      long fp = leafBlockFPs[nodeID-leafNodeOffset];\n      if (fp == 0) {\n        // Dead end node (adversary case):\n        //System.out.println(\"    dead-end leaf\");\n        return 0;\n      }\n\n      /*\n      System.out.println(\"I: \" + BKDTreeWriter.decodeLat(cellLatMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLat(cellLatMaxEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMaxEnc));\n      */\n\n      state.in.seek(fp);\n\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n\n      state.docs.grow(count);\n      for(int i=0;i<count;i++) {\n        int docID = state.in.readInt();\n        state.sndv.setDocument(docID);\n        // How many values this doc has:\n        int docValueCount = state.sndv.count();\n        for(int j=0;j<docValueCount;j++) {\n          long enc = state.sndv.valueAt(j);\n\n          int latEnc = (int) ((enc>>32) & 0xffffffffL);\n          int lonEnc = (int) (enc & 0xffffffffL);\n\n          if (latEnc >= state.latMinEnc &&\n              latEnc < state.latMaxEnc &&\n              lonEnc >= state.lonMinEnc &&\n              lonEnc < state.lonMaxEnc &&\n              (state.latLonFilter == null ||\n               state.latLonFilter.accept(BKDTreeWriter.decodeLat(latEnc), BKDTreeWriter.decodeLon(lonEnc)))) {\n            state.docs.add(docID);\n            hitCount++;\n\n            // Stop processing values for this doc:\n            break;\n          }\n        }\n      }\n\n      return hitCount;\n\n    } else {\n\n      int splitValue = splitValues[nodeID];\n\n      if (splitValue == Integer.MAX_VALUE) {\n        // Dead end node (adversary case):\n        //System.out.println(\"    dead-end sub-tree\");\n        return 0;\n      }\n\n      //System.out.println(\"  splitValue=\" + splitValue);\n\n      int count = 0;\n\n      if (dim == 0) {\n\n        //System.out.println(\"  split on lat=\" + splitValue);\n\n        // Inner node split on lat:\n\n        // Left node:\n        if (state.latMinEnc < splitValue) {\n          //System.out.println(\"  recurse left\");\n          count += intersect(state,\n                             2*nodeID,\n                             cellLatMinEnc, splitValue, cellLonMinEnc, cellLonMaxEnc);\n        }\n\n        // Right node:\n        if (state.latMaxEnc >= splitValue) {\n          //System.out.println(\"  recurse right\");\n          count += intersect(state,\n                             2*nodeID+1,\n                             splitValue, cellLatMaxEnc, cellLonMinEnc, cellLonMaxEnc);\n        }\n\n      } else {\n        // Inner node split on lon:\n        assert dim == 1;\n\n        // System.out.println(\"  split on lon=\" + splitValue);\n\n        // Left node:\n        if (state.lonMinEnc < splitValue) {\n          // System.out.println(\"  recurse left\");\n          count += intersect(state,\n                             2*nodeID,\n                             cellLatMinEnc, cellLatMaxEnc, cellLonMinEnc, splitValue);\n        }\n\n        // Right node:\n        if (state.lonMaxEnc >= splitValue) {\n          // System.out.println(\"  recurse right\");\n          count += intersect(state,\n                             2*nodeID+1,\n                             cellLatMinEnc, cellLatMaxEnc, splitValue, cellLonMaxEnc);\n        }\n      }\n\n      return count;\n    }\n  }\n\n","sourceOld":"  private int intersect(QueryState state,\n                        int nodeID,\n                        int cellLatMinEnc, int cellLatMaxEnc, int cellLonMinEnc, int cellLonMaxEnc)\n    throws IOException {\n\n    // 2.06 sec -> 1.52 sec for 225 OSM London queries:\n    if (state.latLonFilter != null) {\n      if (cellLatMinEnc > state.latMinEnc ||\n          cellLatMaxEnc < state.latMaxEnc ||\n          cellLonMinEnc > state.lonMinEnc ||\n          cellLonMaxEnc < state.lonMaxEnc) {\n        Relation r = state.latLonFilter.compare(BKDTreeWriter.decodeLat(cellLatMinEnc),\n                                                BKDTreeWriter.decodeLat(cellLatMaxEnc),\n                                                BKDTreeWriter.decodeLon(cellLonMinEnc),\n                                                BKDTreeWriter.decodeLon(cellLonMaxEnc));\n        //System.out.println(\"BKD.intersect cellLat=\" + BKDTreeWriter.decodeLat(cellLatMinEnc) + \" TO \" + BKDTreeWriter.decodeLat(cellLatMaxEnc) + \", cellLon=\" + BKDTreeWriter.decodeLon(cellLonMinEnc) + \" TO \" + BKDTreeWriter.decodeLon(cellLonMaxEnc) + \" compare=\" + r);\n        if (r == Relation.OUTSIDE) {\n          // This cell is fully outside of the query shape: stop recursing\n          return 0;\n        } else if (r == Relation.INSIDE) {\n          // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n          return addAll(state, nodeID);\n        } else {\n          // The cell crosses the shape boundary, so we fall through and do full filtering\n        }\n      }\n    } else if (state.latMinEnc <= cellLatMinEnc && state.latMaxEnc >= cellLatMaxEnc && state.lonMinEnc <= cellLonMinEnc && state.lonMaxEnc >= cellLonMaxEnc) {\n      // Optimize the case when the query fully contains this cell: we can\n      // recursively add all points without checking if they match the query:\n      return addAll(state, nodeID);\n    }\n\n    long latRange = (long) cellLatMaxEnc - (long) cellLatMinEnc;\n    long lonRange = (long) cellLonMaxEnc - (long) cellLonMinEnc;\n\n    int dim;\n    if (latRange >= lonRange) {\n      dim = 0;\n    } else {\n      dim = 1;\n    }\n\n    //System.out.println(\"\\nintersect node=\" + nodeID + \" vs \" + leafNodeOffset);\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node; scan and filter all points in this block:\n      //System.out.println(\"    intersect leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + leafBlockFPs[nodeID-leafNodeOffset]);\n      int hitCount = 0;\n\n      //IndexInput in = leafDISI.in;\n      long fp = leafBlockFPs[nodeID-leafNodeOffset];\n      if (fp == 0) {\n        // Dead end node (adversary case):\n        //System.out.println(\"    dead-end leaf\");\n        return 0;\n      }\n\n      /*\n      System.out.println(\"I: \" + BKDTreeWriter.decodeLat(cellLatMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLat(cellLatMaxEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMaxEnc));\n      */\n\n      state.in.seek(fp);\n\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n\n      state.docs.grow(count);\n      for(int i=0;i<count;i++) {\n        int docID = state.in.readInt();\n        state.sndv.setDocument(docID);\n        // How many values this doc has:\n        int docValueCount = state.sndv.count();\n        for(int j=0;j<docValueCount;j++) {\n          long enc = state.sndv.valueAt(j);\n\n          int latEnc = (int) ((enc>>32) & 0xffffffffL);\n          int lonEnc = (int) (enc & 0xffffffffL);\n\n          if (latEnc >= state.latMinEnc &&\n              latEnc < state.latMaxEnc &&\n              lonEnc >= state.lonMinEnc &&\n              lonEnc < state.lonMaxEnc &&\n              (state.latLonFilter == null ||\n               state.latLonFilter.accept(BKDTreeWriter.decodeLat(latEnc), BKDTreeWriter.decodeLon(lonEnc)))) {\n            state.docs.add(docID);\n            hitCount++;\n\n            // Stop processing values for this doc:\n            break;\n          }\n        }\n      }\n\n      return hitCount;\n\n      // this (using BitDocIdSet.Builder) is 3.4X slower!\n      /*\n      //bits.or(leafDISI);\n      //return leafDISI.getHitCount();\n      */\n\n    } else {\n\n      int splitValue = splitValues[nodeID];\n\n      if (splitValue == Integer.MAX_VALUE) {\n        // Dead end node (adversary case):\n        //System.out.println(\"    dead-end sub-tree\");\n        return 0;\n      }\n\n      //System.out.println(\"  splitValue=\" + splitValue);\n\n      int count = 0;\n\n      if (dim == 0) {\n\n        //System.out.println(\"  split on lat=\" + splitValue);\n\n        // Inner node split on lat:\n\n        // Left node:\n        if (state.latMinEnc < splitValue) {\n          //System.out.println(\"  recurse left\");\n          count += intersect(state,\n                             2*nodeID,\n                             cellLatMinEnc, splitValue, cellLonMinEnc, cellLonMaxEnc);\n        }\n\n        // Right node:\n        if (state.latMaxEnc >= splitValue) {\n          //System.out.println(\"  recurse right\");\n          count += intersect(state,\n                             2*nodeID+1,\n                             splitValue, cellLatMaxEnc, cellLonMinEnc, cellLonMaxEnc);\n        }\n\n      } else {\n        // Inner node split on lon:\n        assert dim == 1;\n\n        // System.out.println(\"  split on lon=\" + splitValue);\n\n        // Left node:\n        if (state.lonMinEnc < splitValue) {\n          // System.out.println(\"  recurse left\");\n          count += intersect(state,\n                             2*nodeID,\n                             cellLatMinEnc, cellLatMaxEnc, cellLonMinEnc, splitValue);\n        }\n\n        // Right node:\n        if (state.lonMaxEnc >= splitValue) {\n          // System.out.println(\"  recurse right\");\n          count += intersect(state,\n                             2*nodeID+1,\n                             cellLatMinEnc, cellLatMaxEnc, splitValue, cellLonMaxEnc);\n        }\n      }\n\n      return count;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07c50cb1eca5629cac5b6702dd0f5e06157af61a","date":1445464748,"type":3,"author":"Nick Knize","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#intersect(QueryState,int,int,int,int,int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#intersect(QueryState,int,int,int,int,int).mjava","sourceNew":"  private int intersect(QueryState state,\n                        int nodeID,\n                        int cellLatMinEnc, int cellLatMaxEnc, int cellLonMinEnc, int cellLonMaxEnc)\n    throws IOException {\n\n    //System.out.println(\"\\nBKD: intersect nodeID=\" + nodeID + \" lat=\" + BKDTreeWriter.decodeLat(state.latMinEnc) + \" TO \" + BKDTreeWriter.decodeLat(state.latMaxEnc) +\n    //\" lon=\" + BKDTreeWriter.decodeLon(state.lonMinEnc) + \" TO \" + BKDTreeWriter.decodeLon(state.lonMaxEnc));\n\n    // 2.06 sec -> 1.52 sec for 225 OSM London queries:\n    if (state.latLonFilter != null) {\n\n      // Don't check the filter if the current cell fully contains the query bbox (just keep recursing in that case):\n      if (cellLatMinEnc > state.latMinEnc || cellLatMaxEnc < state.latMaxEnc ||\n          cellLonMinEnc > state.lonMinEnc || cellLonMaxEnc < state.lonMaxEnc) {\n\n        Relation r = state.latLonFilter.compare(BKDTreeWriter.decodeLat(cellLatMinEnc),\n                                                BKDTreeWriter.decodeLat(cellLatMaxEnc),\n                                                BKDTreeWriter.decodeLon(cellLonMinEnc),\n                                                BKDTreeWriter.decodeLon(cellLonMaxEnc));\n        // System.out.println(\"BKD.intersect cellLat=\" + BKDTreeWriter.decodeLat(cellLatMinEnc) + \" TO \" + BKDTreeWriter.decodeLat(cellLatMaxEnc) + \", cellLon=\" + BKDTreeWriter.decodeLon(cellLonMinEnc) + \" TO \" + BKDTreeWriter.decodeLon(cellLonMaxEnc) + \" compare=\" + r);\n        if (r == Relation.SHAPE_OUTSIDE_CELL) {\n          // This cell is fully outside of the query shape: stop recursing\n          return 0;\n        } else if (r == Relation.CELL_INSIDE_SHAPE) {\n          // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n          return addAll(state, nodeID);\n        } else {\n          // The cell crosses the shape boundary, so we fall through and do full filtering\n        }\n      } else {\n        //System.out.println(\"  straight recurse\");\n      }\n    // TODO: clean this up: the bbox case should also just be a filter, and we should assert filter != null at the start\n    } else if (state.latMinEnc <= cellLatMinEnc && state.latMaxEnc >= cellLatMaxEnc && state.lonMinEnc <= cellLonMinEnc && state.lonMaxEnc >= cellLonMaxEnc) {\n      // Bbox query: optimize the case when the query fully contains this cell: we can\n      // recursively add all points without checking if they match the query:\n      return addAll(state, nodeID);\n    }\n\n    long latRange = (long) cellLatMaxEnc - (long) cellLatMinEnc;\n    long lonRange = (long) cellLonMaxEnc - (long) cellLonMinEnc;\n\n    int dim;\n    if (latRange >= lonRange) {\n      dim = 0;\n    } else {\n      dim = 1;\n    }\n\n    //System.out.println(\"\\nintersect node=\" + nodeID + \" vs \" + leafNodeOffset);\n\n    if (nodeID >= leafNodeOffset) {\n\n      // Leaf node; scan and filter all points in this block:\n      //System.out.println(\"    intersect leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + leafBlockFPs[nodeID-leafNodeOffset]);\n      int hitCount = 0;\n\n      long fp = leafBlockFPs[nodeID-leafNodeOffset];\n      //System.out.println(\"  intersect leaf fp=\" + fp);\n      if (fp == 0) {\n        // Dead end node (adversary case):\n        //System.out.println(\"    dead-end leaf\");\n        return 0;\n      }\n\n      /*\n      System.out.println(\"I: \" + BKDTreeWriter.decodeLat(cellLatMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLat(cellLatMaxEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMaxEnc));\n      */\n\n      state.in.seek(fp);\n\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n\n      state.docs.grow(count);\n      for(int i=0;i<count;i++) {\n        int docID = state.in.readInt();\n        if (accept(state, docID)) {\n          state.docs.add(docID);\n          hitCount++;\n        }\n      }\n\n      return hitCount;\n\n    } else {\n\n      int splitValue = splitValues[nodeID];\n\n      if (splitValue == Integer.MAX_VALUE) {\n        // Dead end node (adversary case):\n        //System.out.println(\"    dead-end sub-tree\");\n        return 0;\n      }\n\n      //System.out.println(\"  splitValue=\" + splitValue);\n\n      int count = 0;\n\n      if (dim == 0) {\n\n        //System.out.println(\"  split on lat=\" + BKDTreeWriter.decodeLat(splitValue));\n\n        // Inner node split on lat:\n\n        // Left node:\n        if (state.latMinEnc < splitValue) {\n          //System.out.println(\"  recurse left\");\n          count += intersect(state,\n                             2*nodeID,\n                             cellLatMinEnc, splitValue, cellLonMinEnc, cellLonMaxEnc);\n        } else {\n          //System.out.println(\"  no recurse left\");\n        }\n\n        // Right node:\n        if (state.latMaxEnc >= splitValue) {\n          //System.out.println(\"  recurse right\");\n          count += intersect(state,\n                             2*nodeID+1,\n                             splitValue, cellLatMaxEnc, cellLonMinEnc, cellLonMaxEnc);\n        } else {\n          //System.out.println(\"  no recurse right\");\n        }\n\n      } else {\n        // Inner node split on lon:\n        assert dim == 1;\n\n        //System.out.println(\"  split on lon=\" + BKDTreeWriter.decodeLon(splitValue));\n\n        // Left node:\n        if (state.lonMinEnc < splitValue) {\n          //System.out.println(\"  recurse left\");\n          count += intersect(state,\n                             2*nodeID,\n                             cellLatMinEnc, cellLatMaxEnc, cellLonMinEnc, splitValue);\n        } else {\n          //System.out.println(\"  no recurse left\");\n        }\n\n        // Right node:\n        if (state.lonMaxEnc >= splitValue) {\n          //System.out.println(\"  recurse right\");\n          count += intersect(state,\n                             2*nodeID+1,\n                             cellLatMinEnc, cellLatMaxEnc, splitValue, cellLonMaxEnc);\n        } else {\n          //System.out.println(\"  no recurse right\");\n        }\n      }\n      //System.out.println(\"  return nodeID=\" + nodeID);\n      return count;\n    }\n  }\n\n","sourceOld":"  private int intersect(QueryState state,\n                        int nodeID,\n                        int cellLatMinEnc, int cellLatMaxEnc, int cellLonMinEnc, int cellLonMaxEnc)\n    throws IOException {\n\n    // 2.06 sec -> 1.52 sec for 225 OSM London queries:\n    if (state.latLonFilter != null) {\n\n      // Only call the filter when the current cell does not fully contain the bbox:\n      if (cellLatMinEnc > state.latMinEnc || cellLatMaxEnc < state.latMaxEnc ||\n          cellLonMinEnc > state.lonMinEnc || cellLonMaxEnc < state.lonMaxEnc) {\n\n        Relation r = state.latLonFilter.compare(BKDTreeWriter.decodeLat(cellLatMinEnc),\n                                                BKDTreeWriter.decodeLat(cellLatMaxEnc),\n                                                BKDTreeWriter.decodeLon(cellLonMinEnc),\n                                                BKDTreeWriter.decodeLon(cellLonMaxEnc));\n        // System.out.println(\"BKD.intersect cellLat=\" + BKDTreeWriter.decodeLat(cellLatMinEnc) + \" TO \" + BKDTreeWriter.decodeLat(cellLatMaxEnc) + \", cellLon=\" + BKDTreeWriter.decodeLon(cellLonMinEnc) + \" TO \" + BKDTreeWriter.decodeLon(cellLonMaxEnc) + \" compare=\" + r);\n        if (r == Relation.SHAPE_OUTSIDE_CELL) {\n          // This cell is fully outside of the query shape: stop recursing\n          return 0;\n        } else if (r == Relation.CELL_INSIDE_SHAPE) {\n          // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n          return addAll(state, nodeID);\n        } else {\n          // The cell crosses the shape boundary, so we fall through and do full filtering\n        }\n      }\n    // TODO: clean this up: the bbox case should also just be a filter, and we should assert filter != null at the start\n    } else if (state.latMinEnc <= cellLatMinEnc && state.latMaxEnc >= cellLatMaxEnc && state.lonMinEnc <= cellLonMinEnc && state.lonMaxEnc >= cellLonMaxEnc) {\n      // Bbox query: optimize the case when the query fully contains this cell: we can\n      // recursively add all points without checking if they match the query:\n      return addAll(state, nodeID);\n    }\n\n    long latRange = (long) cellLatMaxEnc - (long) cellLatMinEnc;\n    long lonRange = (long) cellLonMaxEnc - (long) cellLonMinEnc;\n\n    int dim;\n    if (latRange >= lonRange) {\n      dim = 0;\n    } else {\n      dim = 1;\n    }\n\n    //System.out.println(\"\\nintersect node=\" + nodeID + \" vs \" + leafNodeOffset);\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node; scan and filter all points in this block:\n      //System.out.println(\"    intersect leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + leafBlockFPs[nodeID-leafNodeOffset]);\n      int hitCount = 0;\n\n      long fp = leafBlockFPs[nodeID-leafNodeOffset];\n      if (fp == 0) {\n        // Dead end node (adversary case):\n        //System.out.println(\"    dead-end leaf\");\n        return 0;\n      }\n\n      /*\n      System.out.println(\"I: \" + BKDTreeWriter.decodeLat(cellLatMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLat(cellLatMaxEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMaxEnc));\n      */\n\n      state.in.seek(fp);\n\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n\n      state.docs.grow(count);\n      for(int i=0;i<count;i++) {\n        int docID = state.in.readInt();\n        state.sndv.setDocument(docID);\n        // How many values this doc has:\n        int docValueCount = state.sndv.count();\n        for(int j=0;j<docValueCount;j++) {\n          long enc = state.sndv.valueAt(j);\n\n          int latEnc = (int) ((enc>>32) & 0xffffffffL);\n          int lonEnc = (int) (enc & 0xffffffffL);\n\n          if (latEnc >= state.latMinEnc &&\n              latEnc < state.latMaxEnc &&\n              lonEnc >= state.lonMinEnc &&\n              lonEnc < state.lonMaxEnc &&\n              (state.latLonFilter == null ||\n               state.latLonFilter.accept(BKDTreeWriter.decodeLat(latEnc), BKDTreeWriter.decodeLon(lonEnc)))) {\n            state.docs.add(docID);\n            hitCount++;\n\n            // Stop processing values for this doc:\n            break;\n          }\n        }\n      }\n\n      return hitCount;\n\n    } else {\n\n      int splitValue = splitValues[nodeID];\n\n      if (splitValue == Integer.MAX_VALUE) {\n        // Dead end node (adversary case):\n        //System.out.println(\"    dead-end sub-tree\");\n        return 0;\n      }\n\n      //System.out.println(\"  splitValue=\" + splitValue);\n\n      int count = 0;\n\n      if (dim == 0) {\n\n        //System.out.println(\"  split on lat=\" + splitValue);\n\n        // Inner node split on lat:\n\n        // Left node:\n        if (state.latMinEnc < splitValue) {\n          //System.out.println(\"  recurse left\");\n          count += intersect(state,\n                             2*nodeID,\n                             cellLatMinEnc, splitValue, cellLonMinEnc, cellLonMaxEnc);\n        }\n\n        // Right node:\n        if (state.latMaxEnc >= splitValue) {\n          //System.out.println(\"  recurse right\");\n          count += intersect(state,\n                             2*nodeID+1,\n                             splitValue, cellLatMaxEnc, cellLonMinEnc, cellLonMaxEnc);\n        }\n\n      } else {\n        // Inner node split on lon:\n        assert dim == 1;\n\n        // System.out.println(\"  split on lon=\" + splitValue);\n\n        // Left node:\n        if (state.lonMinEnc < splitValue) {\n          // System.out.println(\"  recurse left\");\n          count += intersect(state,\n                             2*nodeID,\n                             cellLatMinEnc, cellLatMaxEnc, cellLonMinEnc, splitValue);\n        }\n\n        // Right node:\n        if (state.lonMaxEnc >= splitValue) {\n          // System.out.println(\"  recurse right\");\n          count += intersect(state,\n                             2*nodeID+1,\n                             cellLatMinEnc, cellLatMaxEnc, splitValue, cellLonMaxEnc);\n        }\n      }\n\n      return count;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1904709ea0185dc04e3d77ea01c79e909caf2796","date":1447006699,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#intersect(QueryState,int,int,int,int,int).mjava","sourceNew":null,"sourceOld":"  private int intersect(QueryState state,\n                        int nodeID,\n                        int cellLatMinEnc, int cellLatMaxEnc, int cellLonMinEnc, int cellLonMaxEnc)\n    throws IOException {\n\n    //System.out.println(\"\\nBKD: intersect nodeID=\" + nodeID + \" lat=\" + BKDTreeWriter.decodeLat(state.latMinEnc) + \" TO \" + BKDTreeWriter.decodeLat(state.latMaxEnc) +\n    //\" lon=\" + BKDTreeWriter.decodeLon(state.lonMinEnc) + \" TO \" + BKDTreeWriter.decodeLon(state.lonMaxEnc));\n\n    // 2.06 sec -> 1.52 sec for 225 OSM London queries:\n    if (state.latLonFilter != null) {\n\n      // Don't check the filter if the current cell fully contains the query bbox (just keep recursing in that case):\n      if (cellLatMinEnc > state.latMinEnc || cellLatMaxEnc < state.latMaxEnc ||\n          cellLonMinEnc > state.lonMinEnc || cellLonMaxEnc < state.lonMaxEnc) {\n\n        Relation r = state.latLonFilter.compare(BKDTreeWriter.decodeLat(cellLatMinEnc),\n                                                BKDTreeWriter.decodeLat(cellLatMaxEnc),\n                                                BKDTreeWriter.decodeLon(cellLonMinEnc),\n                                                BKDTreeWriter.decodeLon(cellLonMaxEnc));\n        // System.out.println(\"BKD.intersect cellLat=\" + BKDTreeWriter.decodeLat(cellLatMinEnc) + \" TO \" + BKDTreeWriter.decodeLat(cellLatMaxEnc) + \", cellLon=\" + BKDTreeWriter.decodeLon(cellLonMinEnc) + \" TO \" + BKDTreeWriter.decodeLon(cellLonMaxEnc) + \" compare=\" + r);\n        if (r == Relation.SHAPE_OUTSIDE_CELL) {\n          // This cell is fully outside of the query shape: stop recursing\n          return 0;\n        } else if (r == Relation.CELL_INSIDE_SHAPE) {\n          // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n          return addAll(state, nodeID);\n        } else {\n          // The cell crosses the shape boundary, so we fall through and do full filtering\n        }\n      } else {\n        //System.out.println(\"  straight recurse\");\n      }\n    // TODO: clean this up: the bbox case should also just be a filter, and we should assert filter != null at the start\n    } else if (state.latMinEnc <= cellLatMinEnc && state.latMaxEnc >= cellLatMaxEnc && state.lonMinEnc <= cellLonMinEnc && state.lonMaxEnc >= cellLonMaxEnc) {\n      // Bbox query: optimize the case when the query fully contains this cell: we can\n      // recursively add all points without checking if they match the query:\n      return addAll(state, nodeID);\n    }\n\n    long latRange = (long) cellLatMaxEnc - (long) cellLatMinEnc;\n    long lonRange = (long) cellLonMaxEnc - (long) cellLonMinEnc;\n\n    int dim;\n    if (latRange >= lonRange) {\n      dim = 0;\n    } else {\n      dim = 1;\n    }\n\n    //System.out.println(\"\\nintersect node=\" + nodeID + \" vs \" + leafNodeOffset);\n\n    if (nodeID >= leafNodeOffset) {\n\n      // Leaf node; scan and filter all points in this block:\n      //System.out.println(\"    intersect leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + leafBlockFPs[nodeID-leafNodeOffset]);\n      int hitCount = 0;\n\n      long fp = leafBlockFPs[nodeID-leafNodeOffset];\n      //System.out.println(\"  intersect leaf fp=\" + fp);\n      if (fp == 0) {\n        // Dead end node (adversary case):\n        //System.out.println(\"    dead-end leaf\");\n        return 0;\n      }\n\n      /*\n      System.out.println(\"I: \" + BKDTreeWriter.decodeLat(cellLatMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLat(cellLatMaxEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMaxEnc));\n      */\n\n      state.in.seek(fp);\n\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n\n      state.docs.grow(count);\n      for(int i=0;i<count;i++) {\n        int docID = state.in.readInt();\n        if (accept(state, docID)) {\n          state.docs.add(docID);\n          hitCount++;\n        }\n      }\n\n      return hitCount;\n\n    } else {\n\n      int splitValue = splitValues[nodeID];\n\n      if (splitValue == Integer.MAX_VALUE) {\n        // Dead end node (adversary case):\n        //System.out.println(\"    dead-end sub-tree\");\n        return 0;\n      }\n\n      //System.out.println(\"  splitValue=\" + splitValue);\n\n      int count = 0;\n\n      if (dim == 0) {\n\n        //System.out.println(\"  split on lat=\" + BKDTreeWriter.decodeLat(splitValue));\n\n        // Inner node split on lat:\n\n        // Left node:\n        if (state.latMinEnc < splitValue) {\n          //System.out.println(\"  recurse left\");\n          count += intersect(state,\n                             2*nodeID,\n                             cellLatMinEnc, splitValue, cellLonMinEnc, cellLonMaxEnc);\n        } else {\n          //System.out.println(\"  no recurse left\");\n        }\n\n        // Right node:\n        if (state.latMaxEnc >= splitValue) {\n          //System.out.println(\"  recurse right\");\n          count += intersect(state,\n                             2*nodeID+1,\n                             splitValue, cellLatMaxEnc, cellLonMinEnc, cellLonMaxEnc);\n        } else {\n          //System.out.println(\"  no recurse right\");\n        }\n\n      } else {\n        // Inner node split on lon:\n        assert dim == 1;\n\n        //System.out.println(\"  split on lon=\" + BKDTreeWriter.decodeLon(splitValue));\n\n        // Left node:\n        if (state.lonMinEnc < splitValue) {\n          //System.out.println(\"  recurse left\");\n          count += intersect(state,\n                             2*nodeID,\n                             cellLatMinEnc, cellLatMaxEnc, cellLonMinEnc, splitValue);\n        } else {\n          //System.out.println(\"  no recurse left\");\n        }\n\n        // Right node:\n        if (state.lonMaxEnc >= splitValue) {\n          //System.out.println(\"  recurse right\");\n          count += intersect(state,\n                             2*nodeID+1,\n                             cellLatMinEnc, cellLatMaxEnc, splitValue, cellLonMaxEnc);\n        } else {\n          //System.out.println(\"  no recurse right\");\n        }\n      }\n      //System.out.println(\"  return nodeID=\" + nodeID);\n      return count;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0f4464508ee83288c8c4585b533f9faaa93aa314":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f64b7098768253180859cd8faeae6b1a185b06ed":["0e91a2d9ed80172872da0f517870da6756289554"],"0e91a2d9ed80172872da0f517870da6756289554":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1904709ea0185dc04e3d77ea01c79e909caf2796":["07c50cb1eca5629cac5b6702dd0f5e06157af61a"],"07c50cb1eca5629cac5b6702dd0f5e06157af61a":["f64b7098768253180859cd8faeae6b1a185b06ed"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1904709ea0185dc04e3d77ea01c79e909caf2796"]},"commit2Childs":{"0f4464508ee83288c8c4585b533f9faaa93aa314":["0e91a2d9ed80172872da0f517870da6756289554"],"f64b7098768253180859cd8faeae6b1a185b06ed":["07c50cb1eca5629cac5b6702dd0f5e06157af61a"],"0e91a2d9ed80172872da0f517870da6756289554":["f64b7098768253180859cd8faeae6b1a185b06ed"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"1904709ea0185dc04e3d77ea01c79e909caf2796":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"07c50cb1eca5629cac5b6702dd0f5e06157af61a":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}