{"path":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose()) {\n          message(\"  merge thread: start\");\n        }\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            tWriter.mergeInit(merge);\n            updateMergeThreads();\n            if (verbose()) {\n              message(\"  merge thread: do another merge \" + tWriter.segString(merge.segments));\n            }\n          } else {\n            break;\n          }\n        }\n\n        if (verbose()) {\n          message(\"  merge thread: done\");\n        }\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          //System.out.println(Thread.currentThread().getName() + \": CMS: exc\");\n          //exc.printStackTrace(System.out);\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        done = true;\n        synchronized(ConcurrentMergeScheduler.this) {\n          updateMergeThreads();\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose()) {\n          message(\"  merge thread: start\");\n        }\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            tWriter.mergeInit(merge);\n            updateMergeThreads();\n            if (verbose()) {\n              message(\"  merge thread: do another merge \" + tWriter.segString(merge.segments));\n            }\n          } else {\n            break;\n          }\n        }\n\n        if (verbose()) {\n          message(\"  merge thread: done\");\n        }\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          //System.out.println(Thread.currentThread().getName() + \": CMS: exc\");\n          //exc.printStackTrace(System.out);\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        done = true;\n        synchronized(ConcurrentMergeScheduler.this) {\n          updateMergeThreads();\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"94b4f4bf8892e6006d66f4231d6d1873bbe56e73","date":1352661595,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose()) {\n          message(\"  merge thread: start\");\n        }\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            updateMergeThreads();\n            if (verbose()) {\n              message(\"  merge thread: do another merge \" + tWriter.segString(merge.segments));\n            }\n          } else {\n            break;\n          }\n        }\n\n        if (verbose()) {\n          message(\"  merge thread: done\");\n        }\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          //System.out.println(Thread.currentThread().getName() + \": CMS: exc\");\n          //exc.printStackTrace(System.out);\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        done = true;\n        synchronized(ConcurrentMergeScheduler.this) {\n          updateMergeThreads();\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose()) {\n          message(\"  merge thread: start\");\n        }\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            tWriter.mergeInit(merge);\n            updateMergeThreads();\n            if (verbose()) {\n              message(\"  merge thread: do another merge \" + tWriter.segString(merge.segments));\n            }\n          } else {\n            break;\n          }\n        }\n\n        if (verbose()) {\n          message(\"  merge thread: done\");\n        }\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          //System.out.println(Thread.currentThread().getName() + \": CMS: exc\");\n          //exc.printStackTrace(System.out);\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        done = true;\n        synchronized(ConcurrentMergeScheduler.this) {\n          updateMergeThreads();\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","bugFix":["a9ac13b5f0ce5ef1b2ce168367d993a79594b23a"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose()) {\n          message(\"  merge thread: start\");\n        }\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            updateMergeThreads();\n            if (verbose()) {\n              message(\"  merge thread: do another merge \" + tWriter.segString(merge.segments));\n            }\n          } else {\n            break;\n          }\n        }\n\n        if (verbose()) {\n          message(\"  merge thread: done\");\n        }\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          //System.out.println(Thread.currentThread().getName() + \": CMS: exc\");\n          //exc.printStackTrace(System.out);\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        done = true;\n        synchronized(ConcurrentMergeScheduler.this) {\n          updateMergeThreads();\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose()) {\n          message(\"  merge thread: start\");\n        }\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            tWriter.mergeInit(merge);\n            updateMergeThreads();\n            if (verbose()) {\n              message(\"  merge thread: do another merge \" + tWriter.segString(merge.segments));\n            }\n          } else {\n            break;\n          }\n        }\n\n        if (verbose()) {\n          message(\"  merge thread: done\");\n        }\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          //System.out.println(Thread.currentThread().getName() + \": CMS: exc\");\n          //exc.printStackTrace(System.out);\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        done = true;\n        synchronized(ConcurrentMergeScheduler.this) {\n          updateMergeThreads();\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"124f2681d830f623c9a11f8653129137de1ec0e8","date":1357315882,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose()) {\n          message(\"  merge thread: start\");\n        }\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n\n          // Notify here in case any threads were stalled;\n          // they will notice that the pending merge has\n          // been pulled and possibly resume:\n          synchronized(ConcurrentMergeScheduler.this) {\n            ConcurrentMergeScheduler.this.notifyAll();\n          }\n\n          if (merge != null) {\n            updateMergeThreads();\n            if (verbose()) {\n              message(\"  merge thread: do another merge \" + tWriter.segString(merge.segments));\n            }\n          } else {\n            break;\n          }\n        }\n\n        if (verbose()) {\n          message(\"  merge thread: done\");\n        }\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          //System.out.println(Thread.currentThread().getName() + \": CMS: exc\");\n          //exc.printStackTrace(System.out);\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        done = true;\n        synchronized(ConcurrentMergeScheduler.this) {\n          updateMergeThreads();\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose()) {\n          message(\"  merge thread: start\");\n        }\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            updateMergeThreads();\n            if (verbose()) {\n              message(\"  merge thread: do another merge \" + tWriter.segString(merge.segments));\n            }\n          } else {\n            break;\n          }\n        }\n\n        if (verbose()) {\n          message(\"  merge thread: done\");\n        }\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          //System.out.println(Thread.currentThread().getName() + \": CMS: exc\");\n          //exc.printStackTrace(System.out);\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        done = true;\n        synchronized(ConcurrentMergeScheduler.this) {\n          updateMergeThreads();\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose()) {\n          message(\"  merge thread: start\");\n        }\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n\n          // Notify here in case any threads were stalled;\n          // they will notice that the pending merge has\n          // been pulled and possibly resume:\n          synchronized(ConcurrentMergeScheduler.this) {\n            ConcurrentMergeScheduler.this.notifyAll();\n          }\n\n          if (merge != null) {\n            updateMergeThreads();\n            if (verbose()) {\n              message(\"  merge thread: do another merge \" + tWriter.segString(merge.segments));\n            }\n          } else {\n            break;\n          }\n        }\n\n        if (verbose()) {\n          message(\"  merge thread: done\");\n        }\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          //System.out.println(Thread.currentThread().getName() + \": CMS: exc\");\n          //exc.printStackTrace(System.out);\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        done = true;\n        synchronized(ConcurrentMergeScheduler.this) {\n          updateMergeThreads();\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose()) {\n          message(\"  merge thread: start\");\n        }\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            updateMergeThreads();\n            if (verbose()) {\n              message(\"  merge thread: do another merge \" + tWriter.segString(merge.segments));\n            }\n          } else {\n            break;\n          }\n        }\n\n        if (verbose()) {\n          message(\"  merge thread: done\");\n        }\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          //System.out.println(Thread.currentThread().getName() + \": CMS: exc\");\n          //exc.printStackTrace(System.out);\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        done = true;\n        synchronized(ConcurrentMergeScheduler.this) {\n          updateMergeThreads();\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5faf65b6692f15cca0f87bf8666c87899afc619f","date":1420468108,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      try {\n\n        if (verbose()) {\n          message(\"  merge thread: start\");\n        }\n\n        doMerge(writer, merge);\n\n        if (verbose()) {\n          message(\"  merge thread: done\");\n        }\n\n        removeMergeThread(this);\n\n        // Let CMS run new merges if necessary:\n        try {\n          merge(writer, MergeTrigger.MERGE_FINISHED, true);\n        } catch (AlreadyClosedException ace) {\n          // OK\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n      } catch (Throwable exc) {\n\n        if (exc instanceof MergePolicy.MergeAbortedException) {\n          // OK to ignore\n        } else if (suppressExceptions == false) {\n          // suppressExceptions is normally only set during\n          // testing.\n          handleMergeException(writer.getDirectory(), exc);\n        }\n\n      } finally {\n        synchronized(ConcurrentMergeScheduler.this) {\n          updateMergeThreads();\n\n          // In case we had stalled indexing, we can now wake up\n          // and possibly unstall:\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose()) {\n          message(\"  merge thread: start\");\n        }\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n\n          // Notify here in case any threads were stalled;\n          // they will notice that the pending merge has\n          // been pulled and possibly resume:\n          synchronized(ConcurrentMergeScheduler.this) {\n            ConcurrentMergeScheduler.this.notifyAll();\n          }\n\n          if (merge != null) {\n            updateMergeThreads();\n            if (verbose()) {\n              message(\"  merge thread: do another merge \" + tWriter.segString(merge.segments));\n            }\n          } else {\n            break;\n          }\n        }\n\n        if (verbose()) {\n          message(\"  merge thread: done\");\n        }\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          //System.out.println(Thread.currentThread().getName() + \": CMS: exc\");\n          //exc.printStackTrace(System.out);\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        done = true;\n        synchronized(ConcurrentMergeScheduler.this) {\n          updateMergeThreads();\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":["c6cc2915889370c9313ee1741da315e976bdd574","737e811ac4583c640a0680e784121677f311a8af"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c6cc2915889370c9313ee1741da315e976bdd574","date":1422111819,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      try {\n\n        if (verbose()) {\n          message(\"  merge thread: start\");\n        }\n\n        doMerge(writer, merge);\n\n        if (verbose()) {\n          message(\"  merge thread: done\");\n        }\n\n        // Let CMS run new merges if necessary:\n        try {\n          merge(writer, MergeTrigger.MERGE_FINISHED, true);\n        } catch (AlreadyClosedException ace) {\n          // OK\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n      } catch (Throwable exc) {\n\n        if (exc instanceof MergePolicy.MergeAbortedException) {\n          // OK to ignore\n        } else if (suppressExceptions == false) {\n          // suppressExceptions is normally only set during\n          // testing.\n          handleMergeException(writer.getDirectory(), exc);\n        }\n\n      } finally {\n        synchronized(ConcurrentMergeScheduler.this) {\n          removeMergeThread();\n\n          updateMergeThreads();\n\n          // In case we had stalled indexing, we can now wake up\n          // and possibly unstall:\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      try {\n\n        if (verbose()) {\n          message(\"  merge thread: start\");\n        }\n\n        doMerge(writer, merge);\n\n        if (verbose()) {\n          message(\"  merge thread: done\");\n        }\n\n        removeMergeThread(this);\n\n        // Let CMS run new merges if necessary:\n        try {\n          merge(writer, MergeTrigger.MERGE_FINISHED, true);\n        } catch (AlreadyClosedException ace) {\n          // OK\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n      } catch (Throwable exc) {\n\n        if (exc instanceof MergePolicy.MergeAbortedException) {\n          // OK to ignore\n        } else if (suppressExceptions == false) {\n          // suppressExceptions is normally only set during\n          // testing.\n          handleMergeException(writer.getDirectory(), exc);\n        }\n\n      } finally {\n        synchronized(ConcurrentMergeScheduler.this) {\n          updateMergeThreads();\n\n          // In case we had stalled indexing, we can now wake up\n          // and possibly unstall:\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","bugFix":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"bugIntro":["737e811ac4583c640a0680e784121677f311a8af"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c1ee9437ba5a8297220428d48a6bb823d1fcd57b","date":1489137809,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n      try {\n        if (verbose()) {\n          message(\"  merge thread: start\");\n        }\n\n        doMerge(writer, merge);\n\n        if (verbose()) {\n          message(\"  merge thread: done\");\n        }\n\n        // Let CMS run new merges if necessary:\n        try {\n          merge(writer, MergeTrigger.MERGE_FINISHED, true);\n        } catch (AlreadyClosedException ace) {\n          // OK\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n      } catch (Throwable exc) {\n\n        if (exc instanceof MergePolicy.MergeAbortedException) {\n          // OK to ignore\n        } else if (suppressExceptions == false) {\n          // suppressExceptions is normally only set during\n          // testing.\n          handleMergeException(writer.getDirectory(), exc);\n        }\n\n      } finally {\n        synchronized(ConcurrentMergeScheduler.this) {\n          removeMergeThread();\n\n          updateMergeThreads();\n\n          // In case we had stalled indexing, we can now wake up\n          // and possibly unstall:\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      try {\n\n        if (verbose()) {\n          message(\"  merge thread: start\");\n        }\n\n        doMerge(writer, merge);\n\n        if (verbose()) {\n          message(\"  merge thread: done\");\n        }\n\n        // Let CMS run new merges if necessary:\n        try {\n          merge(writer, MergeTrigger.MERGE_FINISHED, true);\n        } catch (AlreadyClosedException ace) {\n          // OK\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n      } catch (Throwable exc) {\n\n        if (exc instanceof MergePolicy.MergeAbortedException) {\n          // OK to ignore\n        } else if (suppressExceptions == false) {\n          // suppressExceptions is normally only set during\n          // testing.\n          handleMergeException(writer.getDirectory(), exc);\n        }\n\n      } finally {\n        synchronized(ConcurrentMergeScheduler.this) {\n          removeMergeThread();\n\n          updateMergeThreads();\n\n          // In case we had stalled indexing, we can now wake up\n          // and possibly unstall:\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"737e811ac4583c640a0680e784121677f311a8af","date":1587558614,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n      try {\n        if (verbose()) {\n          message(\"  merge thread: start\");\n        }\n\n        doMerge(writer, merge);\n\n        if (verbose()) {\n          message(\"  merge thread: done\");\n        }\n        runOnMergeFinished(writer);\n      } catch (Throwable exc) {\n        if (exc instanceof MergePolicy.MergeAbortedException) {\n          // OK to ignore\n        } else if (suppressExceptions == false) {\n          // suppressExceptions is normally only set during\n          // testing.\n          handleMergeException(writer.getDirectory(), exc);\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      try {\n        if (verbose()) {\n          message(\"  merge thread: start\");\n        }\n\n        doMerge(writer, merge);\n\n        if (verbose()) {\n          message(\"  merge thread: done\");\n        }\n\n        // Let CMS run new merges if necessary:\n        try {\n          merge(writer, MergeTrigger.MERGE_FINISHED, true);\n        } catch (AlreadyClosedException ace) {\n          // OK\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n      } catch (Throwable exc) {\n\n        if (exc instanceof MergePolicy.MergeAbortedException) {\n          // OK to ignore\n        } else if (suppressExceptions == false) {\n          // suppressExceptions is normally only set during\n          // testing.\n          handleMergeException(writer.getDirectory(), exc);\n        }\n\n      } finally {\n        synchronized(ConcurrentMergeScheduler.this) {\n          removeMergeThread();\n\n          updateMergeThreads();\n\n          // In case we had stalled indexing, we can now wake up\n          // and possibly unstall:\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","bugFix":["5faf65b6692f15cca0f87bf8666c87899afc619f","b1405362241b561f5590ff4a87d5d6e173bcd9cf","eb1b144119d471f0d0af58fe8cf3af07b40f72be","60679157c78fc286ee35471398529a1e5749621c","346d5897e4c4e77ed5dbd31f7730ff30973d5971","c6cc2915889370c9313ee1741da315e976bdd574"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89697e7abc9807639c384eecf5a2a6eef1080426","date":1587733375,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n      try {\n        if (verbose()) {\n          message(\"  merge thread: start\");\n        }\n\n        doMerge(mergeSource, merge);\n\n        if (verbose()) {\n          message(\"  merge thread: done\");\n        }\n        runOnMergeFinished(mergeSource);\n      } catch (Throwable exc) {\n        if (exc instanceof MergePolicy.MergeAbortedException) {\n          // OK to ignore\n        } else if (suppressExceptions == false) {\n          // suppressExceptions is normally only set during\n          // testing.\n          handleMergeException(exc);\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      try {\n        if (verbose()) {\n          message(\"  merge thread: start\");\n        }\n\n        doMerge(writer, merge);\n\n        if (verbose()) {\n          message(\"  merge thread: done\");\n        }\n        runOnMergeFinished(writer);\n      } catch (Throwable exc) {\n        if (exc instanceof MergePolicy.MergeAbortedException) {\n          // OK to ignore\n        } else if (suppressExceptions == false) {\n          // suppressExceptions is normally only set during\n          // testing.\n          handleMergeException(writer.getDirectory(), exc);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"89697e7abc9807639c384eecf5a2a6eef1080426":["737e811ac4583c640a0680e784121677f311a8af"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","124f2681d830f623c9a11f8653129137de1ec0e8"],"94b4f4bf8892e6006d66f4231d6d1873bbe56e73":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","94b4f4bf8892e6006d66f4231d6d1873bbe56e73"],"c6cc2915889370c9313ee1741da315e976bdd574":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"c1ee9437ba5a8297220428d48a6bb823d1fcd57b":["c6cc2915889370c9313ee1741da315e976bdd574"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["124f2681d830f623c9a11f8653129137de1ec0e8"],"124f2681d830f623c9a11f8653129137de1ec0e8":["94b4f4bf8892e6006d66f4231d6d1873bbe56e73"],"737e811ac4583c640a0680e784121677f311a8af":["c1ee9437ba5a8297220428d48a6bb823d1fcd57b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["89697e7abc9807639c384eecf5a2a6eef1080426"]},"commit2Childs":{"89697e7abc9807639c384eecf5a2a6eef1080426":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"94b4f4bf8892e6006d66f4231d6d1873bbe56e73":["407687e67faf6e1f02a211ca078d8e3eed631027","124f2681d830f623c9a11f8653129137de1ec0e8"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["94b4f4bf8892e6006d66f4231d6d1873bbe56e73","407687e67faf6e1f02a211ca078d8e3eed631027"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"c6cc2915889370c9313ee1741da315e976bdd574":["c1ee9437ba5a8297220428d48a6bb823d1fcd57b"],"c1ee9437ba5a8297220428d48a6bb823d1fcd57b":["737e811ac4583c640a0680e784121677f311a8af"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["c6cc2915889370c9313ee1741da315e976bdd574"],"124f2681d830f623c9a11f8653129137de1ec0e8":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","5faf65b6692f15cca0f87bf8666c87899afc619f"],"737e811ac4583c640a0680e784121677f311a8af":["89697e7abc9807639c384eecf5a2a6eef1080426"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}