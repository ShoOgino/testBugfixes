{"path":"solr/core/src/java/org/apache/solr/handler/CatStream#findReadableFiles(CrawlFile,List[CrawlFile]).mjava","commits":[{"id":"fa57c615885d274eb8087f89b6a9e1f84e655a74","date":1565267901,"type":1,"author":"Jason Gerlowski","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/CatStream#findReadableFiles(CrawlFile,List[CrawlFile]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/FilesStream#findReadableFiles(CrawlFile,List[CrawlFile]).mjava","sourceNew":"  private void findReadableFiles(CrawlFile seed, List<CrawlFile> foundFiles) {\n\n    final File entry = new File(seed.absolutePath);\n\n    // Skip over paths that don't exist or that are symbolic links\n    if ((!entry.exists()) || (!entry.canRead()) || Files.isSymbolicLink(entry.toPath())) {\n      return;\n    }\n\n    // We already know that the path in question exists, is readable, and is in our sandbox\n    if (entry.isFile()) {\n      foundFiles.add(seed);\n    } else if (entry.isDirectory()) {\n      final String[] directoryContents = entry.list();\n      Arrays.sort(directoryContents);\n      if (directoryContents != null) {\n        for (String item : directoryContents) {\n          final String itemDisplayPath = Paths.get(seed.displayPath, item).toString();\n          final String itemAbsolutePath = Paths.get(seed.absolutePath, item).toString();\n          findReadableFiles(new CrawlFile(itemDisplayPath, itemAbsolutePath), foundFiles);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void findReadableFiles(CrawlFile seed, List<CrawlFile> foundFiles) {\n\n    final File entry = new File(seed.absolutePath);\n\n    // Skip over paths that don't exist or that are symbolic links\n    if ((!entry.exists()) || (!entry.canRead()) || Files.isSymbolicLink(entry.toPath())) {\n      return;\n    }\n\n    // We already know that the path in question exists, is readable, and is in our sandbox\n    if (entry.isFile()) {\n      foundFiles.add(seed);\n    } else if (entry.isDirectory()) {\n      final String[] directoryContents = entry.list();\n      Arrays.sort(directoryContents);\n      if (directoryContents != null) {\n        for (String item : directoryContents) {\n          final String itemDisplayPath = Paths.get(seed.displayPath, item).toString();\n          final String itemAbsolutePath = Paths.get(seed.absolutePath, item).toString();\n          findReadableFiles(new CrawlFile(itemDisplayPath, itemAbsolutePath), foundFiles);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e8c36bc16f489634a3fcf14294704824192273df","date":1593058738,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/CatStream#findReadableFiles(CrawlFile,List[CrawlFile]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/CatStream#findReadableFiles(CrawlFile,List[CrawlFile]).mjava","sourceNew":"  private void findReadableFiles(CrawlFile seed, List<CrawlFile> foundFiles) {\n\n    final Path entry = seed.absolutePath;\n\n    // Skip over paths that don't exist or that are symbolic links\n    if ((!Files.exists(entry)) || (!Files.isReadable(entry)) || Files.isSymbolicLink(entry)) {\n      return;\n    }\n\n    // We already know that the path in question exists, is readable, and is in our sandbox\n    if (Files.isRegularFile(entry)) {\n      foundFiles.add(seed);\n    } else if (Files.isDirectory(entry)) {\n      try (Stream<Path> directoryContents = Files.list(entry)) {\n        directoryContents.sorted().forEach(iPath -> {\n          final String itemDisplayPath = seed.displayPath + \"/\" + iPath.getFileName();\n          findReadableFiles(new CrawlFile(itemDisplayPath, iPath), foundFiles);\n        });\n      } catch (IOException e) {\n        throw new RuntimeIOException(e);\n      }\n    }\n  }\n\n","sourceOld":"  private void findReadableFiles(CrawlFile seed, List<CrawlFile> foundFiles) {\n\n    final File entry = new File(seed.absolutePath);\n\n    // Skip over paths that don't exist or that are symbolic links\n    if ((!entry.exists()) || (!entry.canRead()) || Files.isSymbolicLink(entry.toPath())) {\n      return;\n    }\n\n    // We already know that the path in question exists, is readable, and is in our sandbox\n    if (entry.isFile()) {\n      foundFiles.add(seed);\n    } else if (entry.isDirectory()) {\n      final String[] directoryContents = entry.list();\n      Arrays.sort(directoryContents);\n      if (directoryContents != null) {\n        for (String item : directoryContents) {\n          final String itemDisplayPath = Paths.get(seed.displayPath, item).toString();\n          final String itemAbsolutePath = Paths.get(seed.absolutePath, item).toString();\n          findReadableFiles(new CrawlFile(itemDisplayPath, itemAbsolutePath), foundFiles);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"836d62921e732127203632eb0b1fbb98ab0548c6","date":1593274405,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/CatStream#findReadableFiles(CrawlFile,List[CrawlFile]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/CatStream#findReadableFiles(CrawlFile,List[CrawlFile]).mjava","sourceNew":"  private void findReadableFiles(CrawlFile seed, List<CrawlFile> foundFiles) {\n\n    final Path entry = seed.absolutePath;\n\n    // Skip over paths that don't exist or that are symbolic links\n    if ((!Files.exists(entry)) || (!Files.isReadable(entry)) || Files.isSymbolicLink(entry)) {\n      return;\n    }\n\n    // We already know that the path in question exists, is readable, and is in our sandbox\n    if (Files.isRegularFile(entry)) {\n      foundFiles.add(seed);\n    } else if (Files.isDirectory(entry)) {\n      try (Stream<Path> directoryContents = Files.list(entry)) {\n        directoryContents.sorted().forEach(iPath -> {\n          // debatable: should the separator be OS/file-system specific, or perhaps always \"/\" ?\n          final String displayPathSeparator = iPath.getFileSystem().getSeparator();\n          final String itemDisplayPath = seed.displayPath + displayPathSeparator + iPath.getFileName();\n          findReadableFiles(new CrawlFile(itemDisplayPath, iPath), foundFiles);\n        });\n      } catch (IOException e) {\n        throw new RuntimeIOException(e);\n      }\n    }\n  }\n\n","sourceOld":"  private void findReadableFiles(CrawlFile seed, List<CrawlFile> foundFiles) {\n\n    final Path entry = seed.absolutePath;\n\n    // Skip over paths that don't exist or that are symbolic links\n    if ((!Files.exists(entry)) || (!Files.isReadable(entry)) || Files.isSymbolicLink(entry)) {\n      return;\n    }\n\n    // We already know that the path in question exists, is readable, and is in our sandbox\n    if (Files.isRegularFile(entry)) {\n      foundFiles.add(seed);\n    } else if (Files.isDirectory(entry)) {\n      try (Stream<Path> directoryContents = Files.list(entry)) {\n        directoryContents.sorted().forEach(iPath -> {\n          final String itemDisplayPath = seed.displayPath + \"/\" + iPath.getFileName();\n          findReadableFiles(new CrawlFile(itemDisplayPath, iPath), foundFiles);\n        });\n      } catch (IOException e) {\n        throw new RuntimeIOException(e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"836d62921e732127203632eb0b1fbb98ab0548c6":["e8c36bc16f489634a3fcf14294704824192273df"],"e8c36bc16f489634a3fcf14294704824192273df":["fa57c615885d274eb8087f89b6a9e1f84e655a74"],"fa57c615885d274eb8087f89b6a9e1f84e655a74":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["836d62921e732127203632eb0b1fbb98ab0548c6"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fa57c615885d274eb8087f89b6a9e1f84e655a74"],"836d62921e732127203632eb0b1fbb98ab0548c6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e8c36bc16f489634a3fcf14294704824192273df":["836d62921e732127203632eb0b1fbb98ab0548c6"],"fa57c615885d274eb8087f89b6a9e1f84e655a74":["e8c36bc16f489634a3fcf14294704824192273df"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}