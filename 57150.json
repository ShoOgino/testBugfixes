{"path":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","pathOld":"modules/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharStream>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || brokenComponents.contains(c)\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharStream.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class)) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharStream.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharStream.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharStream>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || brokenComponents.contains(c)\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharStream.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class)) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharStream.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharStream.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc706b1e03a539d44d99998108feb684bb44cbb2","date":1342522408,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharFilter>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || brokenComponents.contains(c)\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharFilter.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class)) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharFilter.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharStream>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || brokenComponents.contains(c)\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharStream.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class)) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharStream.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharStream.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharFilter>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || brokenComponents.contains(c)\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharFilter.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class)) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharFilter.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharStream>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || brokenComponents.contains(c)\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharStream.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class)) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharStream.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharStream.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharFilter>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || brokenComponents.contains(c)\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharFilter.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class)) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharFilter.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharStream>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || brokenComponents.contains(c)\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharStream.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class)) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharStream.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharStream.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ba781c85445e8d9544105ba6c4c34b5f4219752","date":1344816119,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = getClassesForPackage(\"org.apache.lucene.analysis\");\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharFilter>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || brokenComponents.contains(c)\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharFilter.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class)) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharFilter.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharFilter>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || brokenComponents.contains(c)\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharFilter.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class)) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharFilter.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = getClassesForPackage(\"org.apache.lucene.analysis\");\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharFilter>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || brokenComponents.contains(c)\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharFilter.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class)) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharFilter.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharFilter>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || brokenComponents.contains(c)\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharFilter.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class)) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharFilter.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","date":1344867506,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = getClassesForPackage(\"org.apache.lucene.analysis\");\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharFilter>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || brokenComponents.contains(c)\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharFilter.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class)) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharFilter.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = new ArrayList<Class<?>>();\n    getClassesForPackage(\"org.apache.lucene.analysis\", analysisClasses);\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharFilter>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || brokenComponents.contains(c)\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharFilter.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class)) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharFilter.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"19786ac48e7c7cb2da0d29218e579be4c750f8ff","date":1357748196,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = getClassesForPackage(\"org.apache.lucene.analysis\");\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharFilter>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharFilter.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class) || brokenConstructors.get(ctor) == ALWAYS) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharFilter.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = getClassesForPackage(\"org.apache.lucene.analysis\");\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharFilter>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || brokenComponents.contains(c)\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharFilter.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class)) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharFilter.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4e6354dd7c71fe122926fc53d7d29f715b1283db","date":1357915185,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = getClassesForPackage(\"org.apache.lucene.analysis\");\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharFilter>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharFilter.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class) || brokenConstructors.get(ctor) == ALWAYS) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharFilter.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = getClassesForPackage(\"org.apache.lucene.analysis\");\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharFilter>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || brokenComponents.contains(c)\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharFilter.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class)) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharFilter.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31f253a4f41457e79e36c9b6c54166ae9883b9f7","date":1362143536,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = getClassesForPackage(\"org.apache.lucene.analysis\");\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharFilter>>();\n    for (final Class<?> c : analysisClasses) {\n      // TODO: Fix below code to use c.isAnnotationPresent(). It was changed\n      // to the null check to work around a bug in JDK 8 b78 (see LUCENE-4808).\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || c.getAnnotation(Deprecated.class) != null\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharFilter.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.getAnnotation(Deprecated.class) != null || brokenConstructors.get(ctor) == ALWAYS) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharFilter.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = getClassesForPackage(\"org.apache.lucene.analysis\");\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharFilter>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharFilter.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class) || brokenConstructors.get(ctor) == ALWAYS) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharFilter.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","bugFix":null,"bugIntro":["879f774d3d719fff4f9f8bd6b0a98dc2025f8ce5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"879f774d3d719fff4f9f8bd6b0a98dc2025f8ce5","date":1363992115,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = getClassesForPackage(\"org.apache.lucene.analysis\");\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharFilter>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharFilter.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class) || brokenConstructors.get(ctor) == ALWAYS) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharFilter.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = getClassesForPackage(\"org.apache.lucene.analysis\");\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharFilter>>();\n    for (final Class<?> c : analysisClasses) {\n      // TODO: Fix below code to use c.isAnnotationPresent(). It was changed\n      // to the null check to work around a bug in JDK 8 b78 (see LUCENE-4808).\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || c.getAnnotation(Deprecated.class) != null\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharFilter.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.getAnnotation(Deprecated.class) != null || brokenConstructors.get(ctor) == ALWAYS) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharFilter.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","bugFix":["31f253a4f41457e79e36c9b6c54166ae9883b9f7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = getClassesForPackage(\"org.apache.lucene.analysis\");\n    tokenizers = new ArrayList<>();\n    tokenfilters = new ArrayList<>();\n    charfilters = new ArrayList<>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharFilter.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class) || brokenConstructors.get(ctor) == ALWAYS) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharFilter.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = getClassesForPackage(\"org.apache.lucene.analysis\");\n    tokenizers = new ArrayList<Constructor<? extends Tokenizer>>();\n    tokenfilters = new ArrayList<Constructor<? extends TokenFilter>>();\n    charfilters = new ArrayList<Constructor<? extends CharFilter>>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharFilter.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class) || brokenConstructors.get(ctor) == ALWAYS) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharFilter.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1bb78b03a4010509ef504f049857b42aeea7b3f5","date":1482349496,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = getClassesForPackage(\"org.apache.lucene.analysis\");\n    tokenizers = new ArrayList<>();\n    tokenfilters = new ArrayList<>();\n    charfilters = new ArrayList<>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharFilter.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class) || brokenConstructors.get(ctor) == ALWAYS) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharFilter.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = (arg0, arg1) -> arg0.toGenericString().compareTo(arg1.toGenericString());\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = getClassesForPackage(\"org.apache.lucene.analysis\");\n    tokenizers = new ArrayList<>();\n    tokenfilters = new ArrayList<>();\n    charfilters = new ArrayList<>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharFilter.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class) || brokenConstructors.get(ctor) == ALWAYS) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharFilter.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = getClassesForPackage(\"org.apache.lucene.analysis\");\n    tokenizers = new ArrayList<>();\n    tokenfilters = new ArrayList<>();\n    charfilters = new ArrayList<>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharFilter.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class) || brokenConstructors.get(ctor) == ALWAYS) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharFilter.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = (arg0, arg1) -> arg0.toGenericString().compareTo(arg1.toGenericString());\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = getClassesForPackage(\"org.apache.lucene.analysis\");\n    tokenizers = new ArrayList<>();\n    tokenfilters = new ArrayList<>();\n    charfilters = new ArrayList<>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharFilter.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class) || brokenConstructors.get(ctor) == ALWAYS) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharFilter.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = new Comparator<Constructor<?>>() {\n      @Override\n      public int compare(Constructor<?> arg0, Constructor<?> arg1) {\n        return arg0.toGenericString().compareTo(arg1.toGenericString());\n      }\n    };\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"25d4b0425e7ddf8fb0d7b4e24c06ecd9f071e5bd","date":1526034899,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestRandomChains#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = getClassesForPackage(\"org.apache.lucene.analysis\");\n    tokenizers = new ArrayList<>();\n    tokenfilters = new ArrayList<>();\n    charfilters = new ArrayList<>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharFilter.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class) || brokenConstructors.get(ctor) == ALWAYS) {\n          continue;\n        }\n        // conditional filters are tested elsewhere\n        if (ConditionalTokenFilter.class.isAssignableFrom(c)) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharFilter.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = (arg0, arg1) -> arg0.toGenericString().compareTo(arg1.toGenericString());\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    List<Class<?>> analysisClasses = getClassesForPackage(\"org.apache.lucene.analysis\");\n    tokenizers = new ArrayList<>();\n    tokenfilters = new ArrayList<>();\n    charfilters = new ArrayList<>();\n    for (final Class<?> c : analysisClasses) {\n      final int modifiers = c.getModifiers();\n      if (\n        // don't waste time with abstract classes or deprecated known-buggy ones\n        Modifier.isAbstract(modifiers) || !Modifier.isPublic(modifiers)\n        || c.isSynthetic() || c.isAnonymousClass() || c.isMemberClass() || c.isInterface()\n        || c.isAnnotationPresent(Deprecated.class)\n        || !(Tokenizer.class.isAssignableFrom(c) || TokenFilter.class.isAssignableFrom(c) || CharFilter.class.isAssignableFrom(c))\n      ) {\n        continue;\n      }\n      \n      for (final Constructor<?> ctor : c.getConstructors()) {\n        // don't test synthetic or deprecated ctors, they likely have known bugs:\n        if (ctor.isSynthetic() || ctor.isAnnotationPresent(Deprecated.class) || brokenConstructors.get(ctor) == ALWAYS) {\n          continue;\n        }\n        if (Tokenizer.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenizerArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenizers.add(castConstructor(Tokenizer.class, ctor));\n        } else if (TokenFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedTokenFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          tokenfilters.add(castConstructor(TokenFilter.class, ctor));\n        } else if (CharFilter.class.isAssignableFrom(c)) {\n          assertTrue(ctor.toGenericString() + \" has unsupported parameter types\",\n            allowedCharFilterArgs.containsAll(Arrays.asList(ctor.getParameterTypes())));\n          charfilters.add(castConstructor(CharFilter.class, ctor));\n        } else {\n          fail(\"Cannot get here\");\n        }\n      }\n    }\n    \n    final Comparator<Constructor<?>> ctorComp = (arg0, arg1) -> arg0.toGenericString().compareTo(arg1.toGenericString());\n    Collections.sort(tokenizers, ctorComp);\n    Collections.sort(tokenfilters, ctorComp);\n    Collections.sort(charfilters, ctorComp);\n    if (VERBOSE) {\n      System.out.println(\"tokenizers = \" + tokenizers);\n      System.out.println(\"tokenfilters = \" + tokenfilters);\n      System.out.println(\"charfilters = \" + charfilters);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"879f774d3d719fff4f9f8bd6b0a98dc2025f8ce5":["31f253a4f41457e79e36c9b6c54166ae9883b9f7"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["879f774d3d719fff4f9f8bd6b0a98dc2025f8ce5"],"19786ac48e7c7cb2da0d29218e579be4c750f8ff":["0ba781c85445e8d9544105ba6c4c34b5f4219752"],"fc706b1e03a539d44d99998108feb684bb44cbb2":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"0ba781c85445e8d9544105ba6c4c34b5f4219752":["fc706b1e03a539d44d99998108feb684bb44cbb2"],"25d4b0425e7ddf8fb0d7b4e24c06ecd9f071e5bd":["1bb78b03a4010509ef504f049857b42aeea7b3f5"],"31f253a4f41457e79e36c9b6c54166ae9883b9f7":["19786ac48e7c7cb2da0d29218e579be4c750f8ff"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","1bb78b03a4010509ef504f049857b42aeea7b3f5"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"aba371508186796cc6151d8223a5b4e16d02e26e":["b89678825b68eccaf09e6ab71675fc0b0af1e099","fc706b1e03a539d44d99998108feb684bb44cbb2"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["fe33227f6805edab2036cbb80645cc4e2d1fa424","0ba781c85445e8d9544105ba6c4c34b5f4219752"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["b89678825b68eccaf09e6ab71675fc0b0af1e099","fc706b1e03a539d44d99998108feb684bb44cbb2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1bb78b03a4010509ef504f049857b42aeea7b3f5":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"4e6354dd7c71fe122926fc53d7d29f715b1283db":["0ba781c85445e8d9544105ba6c4c34b5f4219752","19786ac48e7c7cb2da0d29218e579be4c750f8ff"],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":["aba371508186796cc6151d8223a5b4e16d02e26e","0ba781c85445e8d9544105ba6c4c34b5f4219752"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["25d4b0425e7ddf8fb0d7b4e24c06ecd9f071e5bd"]},"commit2Childs":{"879f774d3d719fff4f9f8bd6b0a98dc2025f8ce5":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["f03e4bed5023ec3ef93a771b8888cae991cf448d","1bb78b03a4010509ef504f049857b42aeea7b3f5"],"19786ac48e7c7cb2da0d29218e579be4c750f8ff":["31f253a4f41457e79e36c9b6c54166ae9883b9f7","4e6354dd7c71fe122926fc53d7d29f715b1283db"],"fc706b1e03a539d44d99998108feb684bb44cbb2":["0ba781c85445e8d9544105ba6c4c34b5f4219752","aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"0ba781c85445e8d9544105ba6c4c34b5f4219752":["19786ac48e7c7cb2da0d29218e579be4c750f8ff","c7869f64c874ebf7f317d22c00baf2b6857797a6","4e6354dd7c71fe122926fc53d7d29f715b1283db","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9"],"31f253a4f41457e79e36c9b6c54166ae9883b9f7":["879f774d3d719fff4f9f8bd6b0a98dc2025f8ce5"],"25d4b0425e7ddf8fb0d7b4e24c06ecd9f071e5bd":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":[],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["fc706b1e03a539d44d99998108feb684bb44cbb2","aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"aba371508186796cc6151d8223a5b4e16d02e26e":["d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":[],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["c7869f64c874ebf7f317d22c00baf2b6857797a6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"1bb78b03a4010509ef504f049857b42aeea7b3f5":["25d4b0425e7ddf8fb0d7b4e24c06ecd9f071e5bd","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"4e6354dd7c71fe122926fc53d7d29f715b1283db":[],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["f03e4bed5023ec3ef93a771b8888cae991cf448d","c7869f64c874ebf7f317d22c00baf2b6857797a6","4e6354dd7c71fe122926fc53d7d29f715b1283db","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}