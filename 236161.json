{"path":"lucene/src/java/org/apache/lucene/index/values/Bytes#getWriter(Directory,String,Mode,Comparator[BytesRef],boolean,AtomicLong,IOContext).mjava","commits":[{"id":"b6f9be74ca7baaef11857ad002cad40419979516","date":1309449808,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/values/Bytes#getWriter(Directory,String,Mode,Comparator[BytesRef],boolean,AtomicLong,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/values/Bytes#getWriter(Directory,String,Mode,Comparator[BytesRef],boolean,AtomicLong).mjava","sourceNew":"  /**\n   * Creates a new <tt>byte[]</tt> {@link Writer} instances for the given\n   * directory.\n   * \n   * @param dir\n   *          the directory to write the values to\n   * @param id\n   *          the id used to create a unique file name. Usually composed out of\n   *          the segment name and a unique id per segment.\n   * @param mode\n   *          the writers store mode\n   * @param comp\n   *          a {@link BytesRef} comparator - only used with {@link Mode#SORTED}\n   * @param fixedSize\n   *          <code>true</code> if all bytes subsequently passed to the\n   *          {@link Writer} will have the same length\n   * @param bytesUsed\n   *          an {@link AtomicLong} instance to track the used bytes within the\n   *          {@link Writer}. A call to {@link Writer#finish(int)} will release\n   *          all internally used resources and frees the memeory tracking\n   *          reference.\n   * @return a new {@link Writer} instance\n   * @throws IOException\n   *           if the files for the writer can not be created.\n   */\n  public static Writer getWriter(Directory dir, String id, Mode mode,\n      Comparator<BytesRef> comp, boolean fixedSize, AtomicLong bytesUsed, IOContext context)\n      throws IOException {\n\n    // TODO -- i shouldn't have to specify fixed? can\n    // track itself & do the write thing at write time?\n    if (comp == null) {\n      comp = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id, context);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, comp, bytesUsed, context);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, comp, bytesUsed, context);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","sourceOld":"  /**\n   * Creates a new <tt>byte[]</tt> {@link Writer} instances for the given\n   * directory.\n   * \n   * @param dir\n   *          the directory to write the values to\n   * @param id\n   *          the id used to create a unique file name. Usually composed out of\n   *          the segment name and a unique id per segment.\n   * @param mode\n   *          the writers store mode\n   * @param comp\n   *          a {@link BytesRef} comparator - only used with {@link Mode#SORTED}\n   * @param fixedSize\n   *          <code>true</code> if all bytes subsequently passed to the\n   *          {@link Writer} will have the same length\n   * @param bytesUsed\n   *          an {@link AtomicLong} instance to track the used bytes within the\n   *          {@link Writer}. A call to {@link Writer#finish(int)} will release\n   *          all internally used resources and frees the memeory tracking\n   *          reference.\n   * @return a new {@link Writer} instance\n   * @throws IOException\n   *           if the files for the writer can not be created.\n   */\n  public static Writer getWriter(Directory dir, String id, Mode mode,\n      Comparator<BytesRef> comp, boolean fixedSize, AtomicLong bytesUsed)\n      throws IOException {\n    //nocommit this and all the blow need an IOContext too\n\n    // TODO -- i shouldn't have to specify fixed? can\n    // track itself & do the write thing at write time?\n    if (comp == null) {\n      comp = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/values/Bytes#getWriter(Directory,String,Mode,Comparator[BytesRef],boolean,AtomicLong,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/values/Bytes#getWriter(Directory,String,Mode,Comparator[BytesRef],boolean,AtomicLong,IOContext).mjava","sourceNew":"  /**\n   * Creates a new <tt>byte[]</tt> {@link Writer} instances for the given\n   * directory.\n   * \n   * @param dir\n   *          the directory to write the values to\n   * @param id\n   *          the id used to create a unique file name. Usually composed out of\n   *          the segment name and a unique id per segment.\n   * @param mode\n   *          the writers store mode\n   * @param comp\n   *          a {@link BytesRef} comparator - only used with {@link Mode#SORTED}\n   * @param fixedSize\n   *          <code>true</code> if all bytes subsequently passed to the\n   *          {@link Writer} will have the same length\n   * @param bytesUsed\n   *          an {@link AtomicLong} instance to track the used bytes within the\n   *          {@link Writer}. A call to {@link Writer#finish(int)} will release\n   *          all internally used resources and frees the memeory tracking\n   *          reference.\n   * @param context \n   * @return a new {@link Writer} instance\n   * @throws IOException\n   *           if the files for the writer can not be created.\n   */\n  public static Writer getWriter(Directory dir, String id, Mode mode,\n      Comparator<BytesRef> comp, boolean fixedSize, AtomicLong bytesUsed, IOContext context)\n      throws IOException {\n    // TODO -- i shouldn't have to specify fixed? can\n    // track itself & do the write thing at write time?\n    if (comp == null) {\n      comp = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, comp, bytesUsed, context);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, comp, bytesUsed, context);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","sourceOld":"  /**\n   * Creates a new <tt>byte[]</tt> {@link Writer} instances for the given\n   * directory.\n   * \n   * @param dir\n   *          the directory to write the values to\n   * @param id\n   *          the id used to create a unique file name. Usually composed out of\n   *          the segment name and a unique id per segment.\n   * @param mode\n   *          the writers store mode\n   * @param comp\n   *          a {@link BytesRef} comparator - only used with {@link Mode#SORTED}\n   * @param fixedSize\n   *          <code>true</code> if all bytes subsequently passed to the\n   *          {@link Writer} will have the same length\n   * @param bytesUsed\n   *          an {@link AtomicLong} instance to track the used bytes within the\n   *          {@link Writer}. A call to {@link Writer#finish(int)} will release\n   *          all internally used resources and frees the memeory tracking\n   *          reference.\n   * @return a new {@link Writer} instance\n   * @throws IOException\n   *           if the files for the writer can not be created.\n   */\n  public static Writer getWriter(Directory dir, String id, Mode mode,\n      Comparator<BytesRef> comp, boolean fixedSize, AtomicLong bytesUsed, IOContext context)\n      throws IOException {\n\n    // TODO -- i shouldn't have to specify fixed? can\n    // track itself & do the write thing at write time?\n    if (comp == null) {\n      comp = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id, context);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, comp, bytesUsed, context);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, comp, bytesUsed, context);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ddc4c914be86e34b54f70023f45a60fa7f04e929","date":1310115160,"type":1,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/values/Bytes#getWriter(Directory,String,Mode,Comparator[BytesRef],boolean,AtomicLong,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/values/Bytes#getWriter(Directory,String,Mode,Comparator[BytesRef],boolean,AtomicLong).mjava","sourceNew":"  /**\n   * Creates a new <tt>byte[]</tt> {@link Writer} instances for the given\n   * directory.\n   * \n   * @param dir\n   *          the directory to write the values to\n   * @param id\n   *          the id used to create a unique file name. Usually composed out of\n   *          the segment name and a unique id per segment.\n   * @param mode\n   *          the writers store mode\n   * @param comp\n   *          a {@link BytesRef} comparator - only used with {@link Mode#SORTED}\n   * @param fixedSize\n   *          <code>true</code> if all bytes subsequently passed to the\n   *          {@link Writer} will have the same length\n   * @param bytesUsed\n   *          an {@link AtomicLong} instance to track the used bytes within the\n   *          {@link Writer}. A call to {@link Writer#finish(int)} will release\n   *          all internally used resources and frees the memeory tracking\n   *          reference.\n   * @param context \n   * @return a new {@link Writer} instance\n   * @throws IOException\n   *           if the files for the writer can not be created.\n   */\n  public static Writer getWriter(Directory dir, String id, Mode mode,\n      Comparator<BytesRef> comp, boolean fixedSize, AtomicLong bytesUsed, IOContext context)\n      throws IOException {\n    // TODO -- i shouldn't have to specify fixed? can\n    // track itself & do the write thing at write time?\n    if (comp == null) {\n      comp = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, comp, bytesUsed, context);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, comp, bytesUsed, context);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","sourceOld":"  /**\n   * Creates a new <tt>byte[]</tt> {@link Writer} instances for the given\n   * directory.\n   * \n   * @param dir\n   *          the directory to write the values to\n   * @param id\n   *          the id used to create a unique file name. Usually composed out of\n   *          the segment name and a unique id per segment.\n   * @param mode\n   *          the writers store mode\n   * @param comp\n   *          a {@link BytesRef} comparator - only used with {@link Mode#SORTED}\n   * @param fixedSize\n   *          <code>true</code> if all bytes subsequently passed to the\n   *          {@link Writer} will have the same length\n   * @param bytesUsed\n   *          an {@link AtomicLong} instance to track the used bytes within the\n   *          {@link Writer}. A call to {@link Writer#finish(int)} will release\n   *          all internally used resources and frees the memeory tracking\n   *          reference.\n   * @return a new {@link Writer} instance\n   * @throws IOException\n   *           if the files for the writer can not be created.\n   */\n  public static Writer getWriter(Directory dir, String id, Mode mode,\n      Comparator<BytesRef> comp, boolean fixedSize, AtomicLong bytesUsed)\n      throws IOException {\n    // TODO -- i shouldn't have to specify fixed? can\n    // track itself & do the write thing at write time?\n    if (comp == null) {\n      comp = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5d004d0e0b3f65bb40da76d476d659d7888270e8","date":1310158940,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/values/Bytes#getWriter(Directory,String,Mode,Comparator[BytesRef],boolean,AtomicLong,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/values/Bytes#getWriter(Directory,String,Mode,Comparator[BytesRef],boolean,AtomicLong).mjava","sourceNew":"  /**\n   * Creates a new <tt>byte[]</tt> {@link Writer} instances for the given\n   * directory.\n   * \n   * @param dir\n   *          the directory to write the values to\n   * @param id\n   *          the id used to create a unique file name. Usually composed out of\n   *          the segment name and a unique id per segment.\n   * @param mode\n   *          the writers store mode\n   * @param comp\n   *          a {@link BytesRef} comparator - only used with {@link Mode#SORTED}\n   * @param fixedSize\n   *          <code>true</code> if all bytes subsequently passed to the\n   *          {@link Writer} will have the same length\n   * @param bytesUsed\n   *          an {@link AtomicLong} instance to track the used bytes within the\n   *          {@link Writer}. A call to {@link Writer#finish(int)} will release\n   *          all internally used resources and frees the memeory tracking\n   *          reference.\n   * @param context \n   * @return a new {@link Writer} instance\n   * @throws IOException\n   *           if the files for the writer can not be created.\n   */\n  public static Writer getWriter(Directory dir, String id, Mode mode,\n      Comparator<BytesRef> comp, boolean fixedSize, AtomicLong bytesUsed, IOContext context)\n      throws IOException {\n    // TODO -- i shouldn't have to specify fixed? can\n    // track itself & do the write thing at write time?\n    if (comp == null) {\n      comp = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, comp, bytesUsed, context);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, comp, bytesUsed, context);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","sourceOld":"  /**\n   * Creates a new <tt>byte[]</tt> {@link Writer} instances for the given\n   * directory.\n   * \n   * @param dir\n   *          the directory to write the values to\n   * @param id\n   *          the id used to create a unique file name. Usually composed out of\n   *          the segment name and a unique id per segment.\n   * @param mode\n   *          the writers store mode\n   * @param comp\n   *          a {@link BytesRef} comparator - only used with {@link Mode#SORTED}\n   * @param fixedSize\n   *          <code>true</code> if all bytes subsequently passed to the\n   *          {@link Writer} will have the same length\n   * @param bytesUsed\n   *          an {@link AtomicLong} instance to track the used bytes within the\n   *          {@link Writer}. A call to {@link Writer#finish(int)} will release\n   *          all internally used resources and frees the memeory tracking\n   *          reference.\n   * @return a new {@link Writer} instance\n   * @throws IOException\n   *           if the files for the writer can not be created.\n   */\n  public static Writer getWriter(Directory dir, String id, Mode mode,\n      Comparator<BytesRef> comp, boolean fixedSize, AtomicLong bytesUsed)\n      throws IOException {\n    // TODO -- i shouldn't have to specify fixed? can\n    // track itself & do the write thing at write time?\n    if (comp == null) {\n      comp = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id, bytesUsed);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, comp, bytesUsed);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17cc1e690c31c800f83860fbfd0423462962ef01","date":1314789725,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/values/Bytes#getWriter(Directory,String,Mode,Comparator[BytesRef],boolean,Counter,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/values/Bytes#getWriter(Directory,String,Mode,Comparator[BytesRef],boolean,AtomicLong,IOContext).mjava","sourceNew":"  /**\n   * Creates a new <tt>byte[]</tt> {@link Writer} instances for the given\n   * directory.\n   * \n   * @param dir\n   *          the directory to write the values to\n   * @param id\n   *          the id used to create a unique file name. Usually composed out of\n   *          the segment name and a unique id per segment.\n   * @param mode\n   *          the writers store mode\n   * @param comp\n   *          a {@link BytesRef} comparator - only used with {@link Mode#SORTED}\n   * @param fixedSize\n   *          <code>true</code> if all bytes subsequently passed to the\n   *          {@link Writer} will have the same length\n   * @param bytesUsed\n   *          an {@link AtomicLong} instance to track the used bytes within the\n   *          {@link Writer}. A call to {@link Writer#finish(int)} will release\n   *          all internally used resources and frees the memeory tracking\n   *          reference.\n   * @param context \n   * @return a new {@link Writer} instance\n   * @throws IOException\n   *           if the files for the writer can not be created.\n   */\n  public static Writer getWriter(Directory dir, String id, Mode mode,\n      Comparator<BytesRef> comp, boolean fixedSize, Counter bytesUsed, IOContext context)\n      throws IOException {\n    // TODO -- i shouldn't have to specify fixed? can\n    // track itself & do the write thing at write time?\n    if (comp == null) {\n      comp = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, comp, bytesUsed, context);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, comp, bytesUsed, context);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","sourceOld":"  /**\n   * Creates a new <tt>byte[]</tt> {@link Writer} instances for the given\n   * directory.\n   * \n   * @param dir\n   *          the directory to write the values to\n   * @param id\n   *          the id used to create a unique file name. Usually composed out of\n   *          the segment name and a unique id per segment.\n   * @param mode\n   *          the writers store mode\n   * @param comp\n   *          a {@link BytesRef} comparator - only used with {@link Mode#SORTED}\n   * @param fixedSize\n   *          <code>true</code> if all bytes subsequently passed to the\n   *          {@link Writer} will have the same length\n   * @param bytesUsed\n   *          an {@link AtomicLong} instance to track the used bytes within the\n   *          {@link Writer}. A call to {@link Writer#finish(int)} will release\n   *          all internally used resources and frees the memeory tracking\n   *          reference.\n   * @param context \n   * @return a new {@link Writer} instance\n   * @throws IOException\n   *           if the files for the writer can not be created.\n   */\n  public static Writer getWriter(Directory dir, String id, Mode mode,\n      Comparator<BytesRef> comp, boolean fixedSize, AtomicLong bytesUsed, IOContext context)\n      throws IOException {\n    // TODO -- i shouldn't have to specify fixed? can\n    // track itself & do the write thing at write time?\n    if (comp == null) {\n      comp = BytesRef.getUTF8SortedAsUnicodeComparator();\n    }\n\n    if (fixedSize) {\n      if (mode == Mode.STRAIGHT) {\n        return new FixedStraightBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.DEREF) {\n        return new FixedDerefBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.SORTED) {\n        return new FixedSortedBytesImpl.Writer(dir, id, comp, bytesUsed, context);\n      }\n    } else {\n      if (mode == Mode.STRAIGHT) {\n        return new VarStraightBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.DEREF) {\n        return new VarDerefBytesImpl.Writer(dir, id, bytesUsed, context);\n      } else if (mode == Mode.SORTED) {\n        return new VarSortedBytesImpl.Writer(dir, id, comp, bytesUsed, context);\n      }\n    }\n\n    throw new IllegalArgumentException(\"\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"17cc1e690c31c800f83860fbfd0423462962ef01":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b6f9be74ca7baaef11857ad002cad40419979516":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ddc4c914be86e34b54f70023f45a60fa7f04e929"],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["b6f9be74ca7baaef11857ad002cad40419979516","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["17cc1e690c31c800f83860fbfd0423462962ef01"]},"commit2Childs":{"17cc1e690c31c800f83860fbfd0423462962ef01":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b6f9be74ca7baaef11857ad002cad40419979516","5d004d0e0b3f65bb40da76d476d659d7888270e8","ddc4c914be86e34b54f70023f45a60fa7f04e929","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"b6f9be74ca7baaef11857ad002cad40419979516":["d083e83f225b11e5fdd900e83d26ddb385b6955c"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":[],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["17cc1e690c31c800f83860fbfd0423462962ef01","5d004d0e0b3f65bb40da76d476d659d7888270e8"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5d004d0e0b3f65bb40da76d476d659d7888270e8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}