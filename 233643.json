{"path":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#collect(int).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#collect(int).mjava","pathOld":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#collect(int).mjava","sourceNew":"  @Override\n  public void collect(int doc) throws IOException {\n\n    // System.out.println(\"C \" + doc);\n\n    if (doc > groupEndDocID) {\n      // Group changed\n      if (subDocUpto != 0) {\n        processGroup();\n      }\n      groupEndDocID = lastDocPerGroupBits.advance(doc);\n      //System.out.println(\"  adv \" + groupEndDocID + \" \" + lastDocPerGroupBits);\n      subDocUpto = 0;\n      groupCompetes = !queueFull;\n    }\n\n    totalHitCount++;\n\n    // Always cache doc/score within this group:\n    if (subDocUpto == pendingSubDocs.length) {\n      pendingSubDocs = ArrayUtil.grow(pendingSubDocs);\n    }\n    pendingSubDocs[subDocUpto] = doc;\n    if (needsScores) {\n      if (subDocUpto == pendingSubScores.length) {\n        pendingSubScores = ArrayUtil.grow(pendingSubScores);\n      }\n      pendingSubScores[subDocUpto] = scorer.score();\n    }\n    subDocUpto++;\n\n    if (groupCompetes) {\n      if (subDocUpto == 1) {\n        assert !queueFull;\n\n        //System.out.println(\"    init copy to bottomSlot=\" + bottomSlot);\n        for (FieldComparator<?> fc : comparators) {\n          fc.copy(bottomSlot, doc);\n          fc.setBottom(bottomSlot);\n        }        \n        topGroupDoc = doc;\n      } else {\n        // Compare to bottomSlot\n        for (int compIDX = 0;; compIDX++) {\n          final int c = reversed[compIDX] * comparators[compIDX].compareBottom(doc);\n          if (c < 0) {\n            // Definitely not competitive -- done\n            return;\n          } else if (c > 0) {\n            // Definitely competitive.\n            break;\n          } else if (compIDX == compIDXEnd) {\n            // Ties with bottom, except we know this docID is\n            // > docID in the queue (docs are visited in\n            // order), so not competitive:\n            return;\n          }\n        }\n\n        //System.out.println(\"       best w/in group!\");\n        \n        for (FieldComparator<?> fc : comparators) {\n          fc.copy(bottomSlot, doc);\n          // Necessary because some comparators cache\n          // details of bottom slot; this forces them to\n          // re-cache:\n          fc.setBottom(bottomSlot);\n        }        \n        topGroupDoc = doc;\n      }\n    } else {\n      // We're not sure this group will make it into the\n      // queue yet\n      for (int compIDX = 0;; compIDX++) {\n        final int c = reversed[compIDX] * comparators[compIDX].compareBottom(doc);\n        if (c < 0) {\n          // Definitely not competitive -- done\n          //System.out.println(\"    doc doesn't compete w/ top groups\");\n          return;\n        } else if (c > 0) {\n          // Definitely competitive.\n          break;\n        } else if (compIDX == compIDXEnd) {\n          // Ties with bottom, except we know this docID is\n          // > docID in the queue (docs are visited in\n          // order), so not competitive:\n          //System.out.println(\"    doc doesn't compete w/ top groups\");\n          return;\n        }\n      }\n      groupCompetes = true;\n      for (FieldComparator<?> fc : comparators) {\n        fc.copy(bottomSlot, doc);\n        // Necessary because some comparators cache\n        // details of bottom slot; this forces them to\n        // re-cache:\n        fc.setBottom(bottomSlot);\n      }\n      topGroupDoc = doc;\n      //System.out.println(\"        doc competes w/ top groups\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void collect(int doc) throws IOException {\n\n    // System.out.println(\"C \" + doc);\n\n    if (doc > groupEndDocID) {\n      // Group changed\n      if (subDocUpto != 0) {\n        processGroup();\n      }\n      groupEndDocID = lastDocPerGroupBits.advance(doc);\n      //System.out.println(\"  adv \" + groupEndDocID + \" \" + lastDocPerGroupBits);\n      subDocUpto = 0;\n      groupCompetes = !queueFull;\n    }\n\n    totalHitCount++;\n\n    // Always cache doc/score within this group:\n    if (subDocUpto == pendingSubDocs.length) {\n      pendingSubDocs = ArrayUtil.grow(pendingSubDocs);\n    }\n    pendingSubDocs[subDocUpto] = doc;\n    if (needsScores) {\n      if (subDocUpto == pendingSubScores.length) {\n        pendingSubScores = ArrayUtil.grow(pendingSubScores);\n      }\n      pendingSubScores[subDocUpto] = scorer.score();\n    }\n    subDocUpto++;\n\n    if (groupCompetes) {\n      if (subDocUpto == 1) {\n        assert !queueFull;\n\n        //System.out.println(\"    init copy to bottomSlot=\" + bottomSlot);\n        for (FieldComparator<?> fc : comparators) {\n          fc.copy(bottomSlot, doc);\n          fc.setBottom(bottomSlot);\n        }        \n        topGroupDoc = doc;\n      } else {\n        // Compare to bottomSlot\n        for (int compIDX = 0;; compIDX++) {\n          final int c = reversed[compIDX] * comparators[compIDX].compareBottom(doc);\n          if (c < 0) {\n            // Definitely not competitive -- done\n            return;\n          } else if (c > 0) {\n            // Definitely competitive.\n            break;\n          } else if (compIDX == compIDXEnd) {\n            // Ties with bottom, except we know this docID is\n            // > docID in the queue (docs are visited in\n            // order), so not competitive:\n            return;\n          }\n        }\n\n        //System.out.println(\"       best w/in group!\");\n        \n        for (FieldComparator<?> fc : comparators) {\n          fc.copy(bottomSlot, doc);\n          // Necessary because some comparators cache\n          // details of bottom slot; this forces them to\n          // re-cache:\n          fc.setBottom(bottomSlot);\n        }        \n        topGroupDoc = doc;\n      }\n    } else {\n      // We're not sure this group will make it into the\n      // queue yet\n      for (int compIDX = 0;; compIDX++) {\n        final int c = reversed[compIDX] * comparators[compIDX].compareBottom(doc);\n        if (c < 0) {\n          // Definitely not competitive -- done\n          //System.out.println(\"    doc doesn't compete w/ top groups\");\n          return;\n        } else if (c > 0) {\n          // Definitely competitive.\n          break;\n        } else if (compIDX == compIDXEnd) {\n          // Ties with bottom, except we know this docID is\n          // > docID in the queue (docs are visited in\n          // order), so not competitive:\n          //System.out.println(\"    doc doesn't compete w/ top groups\");\n          return;\n        }\n      }\n      groupCompetes = true;\n      for (FieldComparator<?> fc : comparators) {\n        fc.copy(bottomSlot, doc);\n        // Necessary because some comparators cache\n        // details of bottom slot; this forces them to\n        // re-cache:\n        fc.setBottom(bottomSlot);\n      }\n      topGroupDoc = doc;\n      //System.out.println(\"        doc competes w/ top groups\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"901e951cec2e6af4e503209a6721c8834db23279","date":1420556599,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#collect(int).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#collect(int).mjava","sourceNew":"  @Override\n  public void collect(int doc) throws IOException {\n\n    // System.out.println(\"C \" + doc);\n\n    if (doc > groupEndDocID) {\n      // Group changed\n      if (subDocUpto != 0) {\n        processGroup();\n      }\n      groupEndDocID = lastDocPerGroupBits.advance(doc);\n      //System.out.println(\"  adv \" + groupEndDocID + \" \" + lastDocPerGroupBits);\n      subDocUpto = 0;\n      groupCompetes = !queueFull;\n    }\n\n    totalHitCount++;\n\n    // Always cache doc/score within this group:\n    if (subDocUpto == pendingSubDocs.length) {\n      pendingSubDocs = ArrayUtil.grow(pendingSubDocs);\n    }\n    pendingSubDocs[subDocUpto] = doc;\n    if (needsScores) {\n      if (subDocUpto == pendingSubScores.length) {\n        pendingSubScores = ArrayUtil.grow(pendingSubScores);\n      }\n      pendingSubScores[subDocUpto] = scorer.score();\n    }\n    subDocUpto++;\n\n    if (groupCompetes) {\n      if (subDocUpto == 1) {\n        assert !queueFull;\n\n        //System.out.println(\"    init copy to bottomSlot=\" + bottomSlot);\n        for (LeafFieldComparator fc : leafComparators) {\n          fc.copy(bottomSlot, doc);\n          fc.setBottom(bottomSlot);\n        }        \n        topGroupDoc = doc;\n      } else {\n        // Compare to bottomSlot\n        for (int compIDX = 0;; compIDX++) {\n          final int c = reversed[compIDX] * leafComparators[compIDX].compareBottom(doc);\n          if (c < 0) {\n            // Definitely not competitive -- done\n            return;\n          } else if (c > 0) {\n            // Definitely competitive.\n            break;\n          } else if (compIDX == compIDXEnd) {\n            // Ties with bottom, except we know this docID is\n            // > docID in the queue (docs are visited in\n            // order), so not competitive:\n            return;\n          }\n        }\n\n        //System.out.println(\"       best w/in group!\");\n        \n        for (LeafFieldComparator fc : leafComparators) {\n          fc.copy(bottomSlot, doc);\n          // Necessary because some comparators cache\n          // details of bottom slot; this forces them to\n          // re-cache:\n          fc.setBottom(bottomSlot);\n        }        \n        topGroupDoc = doc;\n      }\n    } else {\n      // We're not sure this group will make it into the\n      // queue yet\n      for (int compIDX = 0;; compIDX++) {\n        final int c = reversed[compIDX] * leafComparators[compIDX].compareBottom(doc);\n        if (c < 0) {\n          // Definitely not competitive -- done\n          //System.out.println(\"    doc doesn't compete w/ top groups\");\n          return;\n        } else if (c > 0) {\n          // Definitely competitive.\n          break;\n        } else if (compIDX == compIDXEnd) {\n          // Ties with bottom, except we know this docID is\n          // > docID in the queue (docs are visited in\n          // order), so not competitive:\n          //System.out.println(\"    doc doesn't compete w/ top groups\");\n          return;\n        }\n      }\n      groupCompetes = true;\n      for (LeafFieldComparator fc : leafComparators) {\n        fc.copy(bottomSlot, doc);\n        // Necessary because some comparators cache\n        // details of bottom slot; this forces them to\n        // re-cache:\n        fc.setBottom(bottomSlot);\n      }\n      topGroupDoc = doc;\n      //System.out.println(\"        doc competes w/ top groups\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void collect(int doc) throws IOException {\n\n    // System.out.println(\"C \" + doc);\n\n    if (doc > groupEndDocID) {\n      // Group changed\n      if (subDocUpto != 0) {\n        processGroup();\n      }\n      groupEndDocID = lastDocPerGroupBits.advance(doc);\n      //System.out.println(\"  adv \" + groupEndDocID + \" \" + lastDocPerGroupBits);\n      subDocUpto = 0;\n      groupCompetes = !queueFull;\n    }\n\n    totalHitCount++;\n\n    // Always cache doc/score within this group:\n    if (subDocUpto == pendingSubDocs.length) {\n      pendingSubDocs = ArrayUtil.grow(pendingSubDocs);\n    }\n    pendingSubDocs[subDocUpto] = doc;\n    if (needsScores) {\n      if (subDocUpto == pendingSubScores.length) {\n        pendingSubScores = ArrayUtil.grow(pendingSubScores);\n      }\n      pendingSubScores[subDocUpto] = scorer.score();\n    }\n    subDocUpto++;\n\n    if (groupCompetes) {\n      if (subDocUpto == 1) {\n        assert !queueFull;\n\n        //System.out.println(\"    init copy to bottomSlot=\" + bottomSlot);\n        for (FieldComparator<?> fc : comparators) {\n          fc.copy(bottomSlot, doc);\n          fc.setBottom(bottomSlot);\n        }        \n        topGroupDoc = doc;\n      } else {\n        // Compare to bottomSlot\n        for (int compIDX = 0;; compIDX++) {\n          final int c = reversed[compIDX] * comparators[compIDX].compareBottom(doc);\n          if (c < 0) {\n            // Definitely not competitive -- done\n            return;\n          } else if (c > 0) {\n            // Definitely competitive.\n            break;\n          } else if (compIDX == compIDXEnd) {\n            // Ties with bottom, except we know this docID is\n            // > docID in the queue (docs are visited in\n            // order), so not competitive:\n            return;\n          }\n        }\n\n        //System.out.println(\"       best w/in group!\");\n        \n        for (FieldComparator<?> fc : comparators) {\n          fc.copy(bottomSlot, doc);\n          // Necessary because some comparators cache\n          // details of bottom slot; this forces them to\n          // re-cache:\n          fc.setBottom(bottomSlot);\n        }        \n        topGroupDoc = doc;\n      }\n    } else {\n      // We're not sure this group will make it into the\n      // queue yet\n      for (int compIDX = 0;; compIDX++) {\n        final int c = reversed[compIDX] * comparators[compIDX].compareBottom(doc);\n        if (c < 0) {\n          // Definitely not competitive -- done\n          //System.out.println(\"    doc doesn't compete w/ top groups\");\n          return;\n        } else if (c > 0) {\n          // Definitely competitive.\n          break;\n        } else if (compIDX == compIDXEnd) {\n          // Ties with bottom, except we know this docID is\n          // > docID in the queue (docs are visited in\n          // order), so not competitive:\n          //System.out.println(\"    doc doesn't compete w/ top groups\");\n          return;\n        }\n      }\n      groupCompetes = true;\n      for (FieldComparator<?> fc : comparators) {\n        fc.copy(bottomSlot, doc);\n        // Necessary because some comparators cache\n        // details of bottom slot; this forces them to\n        // re-cache:\n        fc.setBottom(bottomSlot);\n      }\n      topGroupDoc = doc;\n      //System.out.println(\"        doc competes w/ top groups\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"901e951cec2e6af4e503209a6721c8834db23279":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["901e951cec2e6af4e503209a6721c8834db23279"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["901e951cec2e6af4e503209a6721c8834db23279"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"901e951cec2e6af4e503209a6721c8834db23279":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}