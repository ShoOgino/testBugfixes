{"path":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#getSegState(LeafReaderContext).mjava","commits":[{"id":"16b25963ad38ed289ebf0f7af31269fa1ce80a11","date":1442083896,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#getSegState(LeafReaderContext).mjava","pathOld":"/dev/null","sourceNew":"    private SegState getSegState(LeafReaderContext context) throws IOException {\n      SegState segState = segStates[context.ord];\n      if (segState != null) return segState;\n\n      // first time, check our filter cache\n      boolean doCheck = !checkedFilterCache && context.ord == 0;\n      checkedFilterCache = true;\n      SolrIndexSearcher solrSearcher = null;\n      if (doCheck && searcher instanceof SolrIndexSearcher) {\n        solrSearcher = (SolrIndexSearcher)searcher;\n        if (solrSearcher.getFilterCache() == null) {\n          doCheck = false;\n        } else {\n          solrSearcher = (SolrIndexSearcher)searcher;\n          DocSet answer = solrSearcher.getFilterCache().get(SolrRangeQuery.this);\n          if (answer != null) {\n            filter = answer.getTopFilter();\n          }\n        }\n      }\n\n      if (filter != null) {\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n\n      final Terms terms = context.reader().terms(SolrRangeQuery.this.getField());\n      if (terms == null) {\n        return segStates[context.ord] = new SegState((DocIdSet) null);\n      }\n\n      final TermsEnum termsEnum = SolrRangeQuery.this.getTermsEnum(context);\n\n      PostingsEnum docs = null;\n\n      final List<TermAndState> collectedTerms = new ArrayList<>();\n      long count = collectTerms(context, termsEnum, collectedTerms);\n      if (count < 0) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        for (TermAndState t : collectedTerms) {\n          final TermContext termContext = new TermContext(searcher.getTopReaderContext());\n          termContext.register(t.state, context.ord, t.docFreq, t.totalTermFreq);\n          bq.add(new TermQuery(new Term( SolrRangeQuery.this.getField(), t.term), termContext), BooleanClause.Occur.SHOULD);\n        }\n        Query q = new ConstantScoreQuery(bq.build());\n        final Weight weight = searcher.rewrite(q).createWeight(searcher, needScores);\n        weight.normalize(1f, score());\n        return segStates[context.ord] = new SegState(weight);\n      }\n\n      // Too many terms for boolean query...\n\n      if (doCheck) {\n        DocSet answer = createDocSet(solrSearcher, count);\n        solrSearcher.getFilterCache().put(SolrRangeQuery.this, answer);\n        filter = answer.getTopFilter();\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      /* FUTURE: reuse term states in the future to help build DocSet, use collected count so far...\n      Bits liveDocs = context.reader().getLiveDocs();\n      int base = context.docBase;\n      int termsVisited = collectedTerms.size();\n\n      DocSetBuilder builder = new DocSetBuilder(searcher.getIndexReader().maxDoc());\n      if (!collectedTerms.isEmpty()) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs, context.docBase, liveDocs);\n        }\n      }\n\n      termsVisited += builder.add(termsEnum, base, liveDocs);\n     */\n\n      DocIdSetBuilder builder = new DocIdSetBuilder(context.reader().maxDoc());\n      builder.grow((int)Math.min(Integer.MAX_VALUE,count));\n      if (collectedTerms.isEmpty() == false) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs);\n        }\n      }\n\n      do {\n        // already positioned on the next term, so don't call next() here...\n        docs = termsEnum.postings(docs, PostingsEnum.NONE);\n        builder.add(docs);\n      } while (termsEnum.next() != null);\n\n      DocIdSet segSet = builder.build();\n      return segStates[context.ord] = new SegState(segSet);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["5cb157886ecc78f33fafd9d403e96a4a495503b3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c9ee4c03e3ee986704eeeb45c571d001905a6430","date":1462194267,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#getSegState(LeafReaderContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#getSegState(LeafReaderContext).mjava","sourceNew":"    private SegState getSegState(LeafReaderContext context) throws IOException {\n      SegState segState = segStates[context.ord];\n      if (segState != null) return segState;\n\n      // first time, check our filter cache\n      boolean doCheck = !checkedFilterCache && context.ord == 0;\n      checkedFilterCache = true;\n      SolrIndexSearcher solrSearcher = null;\n      if (doCheck && searcher instanceof SolrIndexSearcher) {\n        solrSearcher = (SolrIndexSearcher)searcher;\n        if (solrSearcher.getFilterCache() == null) {\n          doCheck = false;\n        } else {\n          solrSearcher = (SolrIndexSearcher)searcher;\n          DocSet answer = solrSearcher.getFilterCache().get(SolrRangeQuery.this);\n          if (answer != null) {\n            filter = answer.getTopFilter();\n          }\n        }\n      }\n\n      if (filter != null) {\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n\n      final Terms terms = context.reader().terms(SolrRangeQuery.this.getField());\n      if (terms == null) {\n        return segStates[context.ord] = new SegState((DocIdSet) null);\n      }\n\n      final TermsEnum termsEnum = SolrRangeQuery.this.getTermsEnum(context);\n\n      PostingsEnum docs = null;\n\n      final List<TermAndState> collectedTerms = new ArrayList<>();\n      long count = collectTerms(context, termsEnum, collectedTerms);\n      if (count < 0) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        for (TermAndState t : collectedTerms) {\n          final TermContext termContext = new TermContext(searcher.getTopReaderContext());\n          termContext.register(t.state, context.ord, t.docFreq, t.totalTermFreq);\n          bq.add(new TermQuery(new Term( SolrRangeQuery.this.getField(), t.term), termContext), BooleanClause.Occur.SHOULD);\n        }\n        Query q = new ConstantScoreQuery(bq.build());\n        final Weight weight = searcher.rewrite(q).createWeight(searcher, needScores);\n        weight.normalize(1f, score());\n        return segStates[context.ord] = new SegState(weight);\n      }\n\n      // Too many terms for boolean query...\n\n      if (doCheck) {\n        DocSet answer = createDocSet(solrSearcher, count);\n        solrSearcher.getFilterCache().put(SolrRangeQuery.this, answer);\n        filter = answer.getTopFilter();\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      /* FUTURE: reuse term states in the future to help build DocSet, use collected count so far...\n      Bits liveDocs = context.reader().getLiveDocs();\n      int base = context.docBase;\n      int termsVisited = collectedTerms.size();\n\n      DocSetBuilder builder = new DocSetBuilder(searcher.getIndexReader().maxDoc());\n      if (!collectedTerms.isEmpty()) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs, context.docBase, liveDocs);\n        }\n      }\n\n      termsVisited += builder.add(termsEnum, base, liveDocs);\n     */\n\n      DocIdSetBuilder builder = new DocIdSetBuilder(context.reader().maxDoc(), terms);\n      builder.grow((int)Math.min(Integer.MAX_VALUE,count));\n      if (collectedTerms.isEmpty() == false) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs);\n        }\n      }\n\n      do {\n        // already positioned on the next term, so don't call next() here...\n        docs = termsEnum.postings(docs, PostingsEnum.NONE);\n        builder.add(docs);\n      } while (termsEnum.next() != null);\n\n      DocIdSet segSet = builder.build();\n      return segStates[context.ord] = new SegState(segSet);\n    }\n\n","sourceOld":"    private SegState getSegState(LeafReaderContext context) throws IOException {\n      SegState segState = segStates[context.ord];\n      if (segState != null) return segState;\n\n      // first time, check our filter cache\n      boolean doCheck = !checkedFilterCache && context.ord == 0;\n      checkedFilterCache = true;\n      SolrIndexSearcher solrSearcher = null;\n      if (doCheck && searcher instanceof SolrIndexSearcher) {\n        solrSearcher = (SolrIndexSearcher)searcher;\n        if (solrSearcher.getFilterCache() == null) {\n          doCheck = false;\n        } else {\n          solrSearcher = (SolrIndexSearcher)searcher;\n          DocSet answer = solrSearcher.getFilterCache().get(SolrRangeQuery.this);\n          if (answer != null) {\n            filter = answer.getTopFilter();\n          }\n        }\n      }\n\n      if (filter != null) {\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n\n      final Terms terms = context.reader().terms(SolrRangeQuery.this.getField());\n      if (terms == null) {\n        return segStates[context.ord] = new SegState((DocIdSet) null);\n      }\n\n      final TermsEnum termsEnum = SolrRangeQuery.this.getTermsEnum(context);\n\n      PostingsEnum docs = null;\n\n      final List<TermAndState> collectedTerms = new ArrayList<>();\n      long count = collectTerms(context, termsEnum, collectedTerms);\n      if (count < 0) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        for (TermAndState t : collectedTerms) {\n          final TermContext termContext = new TermContext(searcher.getTopReaderContext());\n          termContext.register(t.state, context.ord, t.docFreq, t.totalTermFreq);\n          bq.add(new TermQuery(new Term( SolrRangeQuery.this.getField(), t.term), termContext), BooleanClause.Occur.SHOULD);\n        }\n        Query q = new ConstantScoreQuery(bq.build());\n        final Weight weight = searcher.rewrite(q).createWeight(searcher, needScores);\n        weight.normalize(1f, score());\n        return segStates[context.ord] = new SegState(weight);\n      }\n\n      // Too many terms for boolean query...\n\n      if (doCheck) {\n        DocSet answer = createDocSet(solrSearcher, count);\n        solrSearcher.getFilterCache().put(SolrRangeQuery.this, answer);\n        filter = answer.getTopFilter();\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      /* FUTURE: reuse term states in the future to help build DocSet, use collected count so far...\n      Bits liveDocs = context.reader().getLiveDocs();\n      int base = context.docBase;\n      int termsVisited = collectedTerms.size();\n\n      DocSetBuilder builder = new DocSetBuilder(searcher.getIndexReader().maxDoc());\n      if (!collectedTerms.isEmpty()) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs, context.docBase, liveDocs);\n        }\n      }\n\n      termsVisited += builder.add(termsEnum, base, liveDocs);\n     */\n\n      DocIdSetBuilder builder = new DocIdSetBuilder(context.reader().maxDoc());\n      builder.grow((int)Math.min(Integer.MAX_VALUE,count));\n      if (collectedTerms.isEmpty() == false) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs);\n        }\n      }\n\n      do {\n        // already positioned on the next term, so don't call next() here...\n        docs = termsEnum.postings(docs, PostingsEnum.NONE);\n        builder.add(docs);\n      } while (termsEnum.next() != null);\n\n      DocIdSet segSet = builder.build();\n      return segStates[context.ord] = new SegState(segSet);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"30540ec27130887a9372c159e8fe971200f37727","date":1462223109,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#getSegState(LeafReaderContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#getSegState(LeafReaderContext).mjava","sourceNew":"    private SegState getSegState(LeafReaderContext context) throws IOException {\n      SegState segState = segStates[context.ord];\n      if (segState != null) return segState;\n\n      // first time, check our filter cache\n      boolean doCheck = !checkedFilterCache && context.ord == 0;\n      checkedFilterCache = true;\n      SolrIndexSearcher solrSearcher = null;\n      if (doCheck && searcher instanceof SolrIndexSearcher) {\n        solrSearcher = (SolrIndexSearcher)searcher;\n        if (solrSearcher.getFilterCache() == null) {\n          doCheck = false;\n        } else {\n          solrSearcher = (SolrIndexSearcher)searcher;\n          DocSet answer = solrSearcher.getFilterCache().get(SolrRangeQuery.this);\n          if (answer != null) {\n            filter = answer.getTopFilter();\n          }\n        }\n      }\n\n      if (filter != null) {\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n\n      final Terms terms = context.reader().terms(SolrRangeQuery.this.getField());\n      if (terms == null) {\n        return segStates[context.ord] = new SegState((DocIdSet) null);\n      }\n\n      final TermsEnum termsEnum = SolrRangeQuery.this.getTermsEnum(context);\n\n      PostingsEnum docs = null;\n\n      final List<TermAndState> collectedTerms = new ArrayList<>();\n      long count = collectTerms(context, termsEnum, collectedTerms);\n      if (count < 0) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        for (TermAndState t : collectedTerms) {\n          final TermContext termContext = new TermContext(searcher.getTopReaderContext());\n          termContext.register(t.state, context.ord, t.docFreq, t.totalTermFreq);\n          bq.add(new TermQuery(new Term( SolrRangeQuery.this.getField(), t.term), termContext), BooleanClause.Occur.SHOULD);\n        }\n        Query q = new ConstantScoreQuery(bq.build());\n        final Weight weight = searcher.rewrite(q).createWeight(searcher, needScores);\n        weight.normalize(1f, score());\n        return segStates[context.ord] = new SegState(weight);\n      }\n\n      // Too many terms for boolean query...\n\n      if (doCheck) {\n        DocSet answer = createDocSet(solrSearcher, count);\n        solrSearcher.getFilterCache().put(SolrRangeQuery.this, answer);\n        filter = answer.getTopFilter();\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      /* FUTURE: reuse term states in the future to help build DocSet, use collected count so far...\n      Bits liveDocs = context.reader().getLiveDocs();\n      int base = context.docBase;\n      int termsVisited = collectedTerms.size();\n\n      DocSetBuilder builder = new DocSetBuilder(searcher.getIndexReader().maxDoc());\n      if (!collectedTerms.isEmpty()) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs, context.docBase, liveDocs);\n        }\n      }\n\n      termsVisited += builder.add(termsEnum, base, liveDocs);\n     */\n\n      DocIdSetBuilder builder = new DocIdSetBuilder(context.reader().maxDoc(), terms);\n      builder.grow((int)Math.min(Integer.MAX_VALUE,count));\n      if (collectedTerms.isEmpty() == false) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs);\n        }\n      }\n\n      do {\n        // already positioned on the next term, so don't call next() here...\n        docs = termsEnum.postings(docs, PostingsEnum.NONE);\n        builder.add(docs);\n      } while (termsEnum.next() != null);\n\n      DocIdSet segSet = builder.build();\n      return segStates[context.ord] = new SegState(segSet);\n    }\n\n","sourceOld":"    private SegState getSegState(LeafReaderContext context) throws IOException {\n      SegState segState = segStates[context.ord];\n      if (segState != null) return segState;\n\n      // first time, check our filter cache\n      boolean doCheck = !checkedFilterCache && context.ord == 0;\n      checkedFilterCache = true;\n      SolrIndexSearcher solrSearcher = null;\n      if (doCheck && searcher instanceof SolrIndexSearcher) {\n        solrSearcher = (SolrIndexSearcher)searcher;\n        if (solrSearcher.getFilterCache() == null) {\n          doCheck = false;\n        } else {\n          solrSearcher = (SolrIndexSearcher)searcher;\n          DocSet answer = solrSearcher.getFilterCache().get(SolrRangeQuery.this);\n          if (answer != null) {\n            filter = answer.getTopFilter();\n          }\n        }\n      }\n\n      if (filter != null) {\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n\n      final Terms terms = context.reader().terms(SolrRangeQuery.this.getField());\n      if (terms == null) {\n        return segStates[context.ord] = new SegState((DocIdSet) null);\n      }\n\n      final TermsEnum termsEnum = SolrRangeQuery.this.getTermsEnum(context);\n\n      PostingsEnum docs = null;\n\n      final List<TermAndState> collectedTerms = new ArrayList<>();\n      long count = collectTerms(context, termsEnum, collectedTerms);\n      if (count < 0) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        for (TermAndState t : collectedTerms) {\n          final TermContext termContext = new TermContext(searcher.getTopReaderContext());\n          termContext.register(t.state, context.ord, t.docFreq, t.totalTermFreq);\n          bq.add(new TermQuery(new Term( SolrRangeQuery.this.getField(), t.term), termContext), BooleanClause.Occur.SHOULD);\n        }\n        Query q = new ConstantScoreQuery(bq.build());\n        final Weight weight = searcher.rewrite(q).createWeight(searcher, needScores);\n        weight.normalize(1f, score());\n        return segStates[context.ord] = new SegState(weight);\n      }\n\n      // Too many terms for boolean query...\n\n      if (doCheck) {\n        DocSet answer = createDocSet(solrSearcher, count);\n        solrSearcher.getFilterCache().put(SolrRangeQuery.this, answer);\n        filter = answer.getTopFilter();\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      /* FUTURE: reuse term states in the future to help build DocSet, use collected count so far...\n      Bits liveDocs = context.reader().getLiveDocs();\n      int base = context.docBase;\n      int termsVisited = collectedTerms.size();\n\n      DocSetBuilder builder = new DocSetBuilder(searcher.getIndexReader().maxDoc());\n      if (!collectedTerms.isEmpty()) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs, context.docBase, liveDocs);\n        }\n      }\n\n      termsVisited += builder.add(termsEnum, base, liveDocs);\n     */\n\n      DocIdSetBuilder builder = new DocIdSetBuilder(context.reader().maxDoc());\n      builder.grow((int)Math.min(Integer.MAX_VALUE,count));\n      if (collectedTerms.isEmpty() == false) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs);\n        }\n      }\n\n      do {\n        // already positioned on the next term, so don't call next() here...\n        docs = termsEnum.postings(docs, PostingsEnum.NONE);\n        builder.add(docs);\n      } while (termsEnum.next() != null);\n\n      DocIdSet segSet = builder.build();\n      return segStates[context.ord] = new SegState(segSet);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55b50463286869f584cf849d1587a0fcd54d1dfa","date":1462378517,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#getSegState(LeafReaderContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#getSegState(LeafReaderContext).mjava","sourceNew":"    private SegState getSegState(LeafReaderContext context) throws IOException {\n      SegState segState = segStates[context.ord];\n      if (segState != null) return segState;\n\n      // first time, check our filter cache\n      boolean doCheck = !checkedFilterCache && context.ord == 0;\n      checkedFilterCache = true;\n      SolrIndexSearcher solrSearcher = null;\n      if (doCheck && searcher instanceof SolrIndexSearcher) {\n        solrSearcher = (SolrIndexSearcher)searcher;\n        if (solrSearcher.getFilterCache() == null) {\n          doCheck = false;\n        } else {\n          solrSearcher = (SolrIndexSearcher)searcher;\n          DocSet answer = solrSearcher.getFilterCache().get(SolrRangeQuery.this);\n          if (answer != null) {\n            filter = answer.getTopFilter();\n          }\n        }\n      }\n\n      if (filter != null) {\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n\n      final Terms terms = context.reader().terms(SolrRangeQuery.this.getField());\n      if (terms == null) {\n        return segStates[context.ord] = new SegState((DocIdSet) null);\n      }\n\n      final TermsEnum termsEnum = SolrRangeQuery.this.getTermsEnum(context);\n\n      PostingsEnum docs = null;\n\n      final List<TermAndState> collectedTerms = new ArrayList<>();\n      long count = collectTerms(context, termsEnum, collectedTerms);\n      if (count < 0) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        for (TermAndState t : collectedTerms) {\n          final TermContext termContext = new TermContext(searcher.getTopReaderContext());\n          termContext.register(t.state, context.ord, t.docFreq, t.totalTermFreq);\n          bq.add(new TermQuery(new Term( SolrRangeQuery.this.getField(), t.term), termContext), BooleanClause.Occur.SHOULD);\n        }\n        Query q = new ConstantScoreQuery(bq.build());\n        final Weight weight = searcher.rewrite(q).createWeight(searcher, needScores);\n        weight.normalize(1f, score());\n        return segStates[context.ord] = new SegState(weight);\n      }\n\n      // Too many terms for boolean query...\n\n      if (doCheck) {\n        DocSet answer = createDocSet(solrSearcher, count);\n        solrSearcher.getFilterCache().put(SolrRangeQuery.this, answer);\n        filter = answer.getTopFilter();\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      /* FUTURE: reuse term states in the future to help build DocSet, use collected count so far...\n      Bits liveDocs = context.reader().getLiveDocs();\n      int base = context.docBase;\n      int termsVisited = collectedTerms.size();\n\n      DocSetBuilder builder = new DocSetBuilder(searcher.getIndexReader().maxDoc());\n      if (!collectedTerms.isEmpty()) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs, context.docBase, liveDocs);\n        }\n      }\n\n      termsVisited += builder.add(termsEnum, base, liveDocs);\n     */\n\n      DocIdSetBuilder builder = new DocIdSetBuilder(context.reader().maxDoc(), terms);\n      builder.grow((int)Math.min(Integer.MAX_VALUE,count));\n      if (collectedTerms.isEmpty() == false) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs);\n        }\n      }\n\n      do {\n        // already positioned on the next term, so don't call next() here...\n        docs = termsEnum.postings(docs, PostingsEnum.NONE);\n        builder.add(docs);\n      } while (termsEnum.next() != null);\n\n      DocIdSet segSet = builder.build();\n      return segStates[context.ord] = new SegState(segSet);\n    }\n\n","sourceOld":"    private SegState getSegState(LeafReaderContext context) throws IOException {\n      SegState segState = segStates[context.ord];\n      if (segState != null) return segState;\n\n      // first time, check our filter cache\n      boolean doCheck = !checkedFilterCache && context.ord == 0;\n      checkedFilterCache = true;\n      SolrIndexSearcher solrSearcher = null;\n      if (doCheck && searcher instanceof SolrIndexSearcher) {\n        solrSearcher = (SolrIndexSearcher)searcher;\n        if (solrSearcher.getFilterCache() == null) {\n          doCheck = false;\n        } else {\n          solrSearcher = (SolrIndexSearcher)searcher;\n          DocSet answer = solrSearcher.getFilterCache().get(SolrRangeQuery.this);\n          if (answer != null) {\n            filter = answer.getTopFilter();\n          }\n        }\n      }\n\n      if (filter != null) {\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n\n      final Terms terms = context.reader().terms(SolrRangeQuery.this.getField());\n      if (terms == null) {\n        return segStates[context.ord] = new SegState((DocIdSet) null);\n      }\n\n      final TermsEnum termsEnum = SolrRangeQuery.this.getTermsEnum(context);\n\n      PostingsEnum docs = null;\n\n      final List<TermAndState> collectedTerms = new ArrayList<>();\n      long count = collectTerms(context, termsEnum, collectedTerms);\n      if (count < 0) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        for (TermAndState t : collectedTerms) {\n          final TermContext termContext = new TermContext(searcher.getTopReaderContext());\n          termContext.register(t.state, context.ord, t.docFreq, t.totalTermFreq);\n          bq.add(new TermQuery(new Term( SolrRangeQuery.this.getField(), t.term), termContext), BooleanClause.Occur.SHOULD);\n        }\n        Query q = new ConstantScoreQuery(bq.build());\n        final Weight weight = searcher.rewrite(q).createWeight(searcher, needScores);\n        weight.normalize(1f, score());\n        return segStates[context.ord] = new SegState(weight);\n      }\n\n      // Too many terms for boolean query...\n\n      if (doCheck) {\n        DocSet answer = createDocSet(solrSearcher, count);\n        solrSearcher.getFilterCache().put(SolrRangeQuery.this, answer);\n        filter = answer.getTopFilter();\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      /* FUTURE: reuse term states in the future to help build DocSet, use collected count so far...\n      Bits liveDocs = context.reader().getLiveDocs();\n      int base = context.docBase;\n      int termsVisited = collectedTerms.size();\n\n      DocSetBuilder builder = new DocSetBuilder(searcher.getIndexReader().maxDoc());\n      if (!collectedTerms.isEmpty()) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs, context.docBase, liveDocs);\n        }\n      }\n\n      termsVisited += builder.add(termsEnum, base, liveDocs);\n     */\n\n      DocIdSetBuilder builder = new DocIdSetBuilder(context.reader().maxDoc());\n      builder.grow((int)Math.min(Integer.MAX_VALUE,count));\n      if (collectedTerms.isEmpty() == false) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs);\n        }\n      }\n\n      do {\n        // already positioned on the next term, so don't call next() here...\n        docs = termsEnum.postings(docs, PostingsEnum.NONE);\n        builder.add(docs);\n      } while (termsEnum.next() != null);\n\n      DocIdSet segSet = builder.build();\n      return segStates[context.ord] = new SegState(segSet);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5cb157886ecc78f33fafd9d403e96a4a495503b3","date":1467753535,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#getSegState(LeafReaderContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#getSegState(LeafReaderContext).mjava","sourceNew":"    private SegState getSegState(LeafReaderContext context) throws IOException {\n      SegState segState = segStates[context.ord];\n      if (segState != null) return segState;\n\n      // first time, check our filter cache\n      boolean doCheck = !checkedFilterCache && context.ord == 0;\n      checkedFilterCache = true;\n      SolrIndexSearcher solrSearcher = null;\n      if (doCheck && searcher instanceof SolrIndexSearcher) {\n        solrSearcher = (SolrIndexSearcher)searcher;\n        if (solrSearcher.getFilterCache() == null) {\n          doCheck = false;\n        } else {\n          solrSearcher = (SolrIndexSearcher)searcher;\n          DocSet answer = solrSearcher.getFilterCache().get(SolrRangeQuery.this);\n          if (answer != null) {\n            filter = answer.getTopFilter();\n          }\n        }\n      } else {\n        doCheck = false;\n      }\n      \n      if (filter != null) {\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      final Terms terms = context.reader().terms(SolrRangeQuery.this.getField());\n      if (terms == null) {\n        return segStates[context.ord] = new SegState((DocIdSet) null);\n      }\n\n      final TermsEnum termsEnum = SolrRangeQuery.this.getTermsEnum(context);\n\n      PostingsEnum docs = null;\n\n      final List<TermAndState> collectedTerms = new ArrayList<>();\n      long count = collectTerms(context, termsEnum, collectedTerms);\n      if (count < 0) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        for (TermAndState t : collectedTerms) {\n          final TermContext termContext = new TermContext(searcher.getTopReaderContext());\n          termContext.register(t.state, context.ord, t.docFreq, t.totalTermFreq);\n          bq.add(new TermQuery(new Term( SolrRangeQuery.this.getField(), t.term), termContext), BooleanClause.Occur.SHOULD);\n        }\n        Query q = new ConstantScoreQuery(bq.build());\n        final Weight weight = searcher.rewrite(q).createWeight(searcher, needScores);\n        weight.normalize(1f, score());\n        return segStates[context.ord] = new SegState(weight);\n      }\n\n      // Too many terms for boolean query...\n\n      if (doCheck) {\n        DocSet answer = createDocSet(solrSearcher, count);\n        solrSearcher.getFilterCache().put(SolrRangeQuery.this, answer);\n        filter = answer.getTopFilter();\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      /* FUTURE: reuse term states in the future to help build DocSet, use collected count so far...\n      Bits liveDocs = context.reader().getLiveDocs();\n      int base = context.docBase;\n      int termsVisited = collectedTerms.size();\n\n      DocSetBuilder builder = new DocSetBuilder(searcher.getIndexReader().maxDoc());\n      if (!collectedTerms.isEmpty()) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs, context.docBase, liveDocs);\n        }\n      }\n\n      termsVisited += builder.add(termsEnum, base, liveDocs);\n     */\n\n      DocIdSetBuilder builder = new DocIdSetBuilder(context.reader().maxDoc(), terms);\n      builder.grow((int)Math.min(Integer.MAX_VALUE,count));\n      if (collectedTerms.isEmpty() == false) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs);\n        }\n      }\n\n      do {\n        // already positioned on the next term, so don't call next() here...\n        docs = termsEnum.postings(docs, PostingsEnum.NONE);\n        builder.add(docs);\n      } while (termsEnum.next() != null);\n\n      DocIdSet segSet = builder.build();\n      return segStates[context.ord] = new SegState(segSet);\n    }\n\n","sourceOld":"    private SegState getSegState(LeafReaderContext context) throws IOException {\n      SegState segState = segStates[context.ord];\n      if (segState != null) return segState;\n\n      // first time, check our filter cache\n      boolean doCheck = !checkedFilterCache && context.ord == 0;\n      checkedFilterCache = true;\n      SolrIndexSearcher solrSearcher = null;\n      if (doCheck && searcher instanceof SolrIndexSearcher) {\n        solrSearcher = (SolrIndexSearcher)searcher;\n        if (solrSearcher.getFilterCache() == null) {\n          doCheck = false;\n        } else {\n          solrSearcher = (SolrIndexSearcher)searcher;\n          DocSet answer = solrSearcher.getFilterCache().get(SolrRangeQuery.this);\n          if (answer != null) {\n            filter = answer.getTopFilter();\n          }\n        }\n      }\n\n      if (filter != null) {\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n\n      final Terms terms = context.reader().terms(SolrRangeQuery.this.getField());\n      if (terms == null) {\n        return segStates[context.ord] = new SegState((DocIdSet) null);\n      }\n\n      final TermsEnum termsEnum = SolrRangeQuery.this.getTermsEnum(context);\n\n      PostingsEnum docs = null;\n\n      final List<TermAndState> collectedTerms = new ArrayList<>();\n      long count = collectTerms(context, termsEnum, collectedTerms);\n      if (count < 0) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        for (TermAndState t : collectedTerms) {\n          final TermContext termContext = new TermContext(searcher.getTopReaderContext());\n          termContext.register(t.state, context.ord, t.docFreq, t.totalTermFreq);\n          bq.add(new TermQuery(new Term( SolrRangeQuery.this.getField(), t.term), termContext), BooleanClause.Occur.SHOULD);\n        }\n        Query q = new ConstantScoreQuery(bq.build());\n        final Weight weight = searcher.rewrite(q).createWeight(searcher, needScores);\n        weight.normalize(1f, score());\n        return segStates[context.ord] = new SegState(weight);\n      }\n\n      // Too many terms for boolean query...\n\n      if (doCheck) {\n        DocSet answer = createDocSet(solrSearcher, count);\n        solrSearcher.getFilterCache().put(SolrRangeQuery.this, answer);\n        filter = answer.getTopFilter();\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      /* FUTURE: reuse term states in the future to help build DocSet, use collected count so far...\n      Bits liveDocs = context.reader().getLiveDocs();\n      int base = context.docBase;\n      int termsVisited = collectedTerms.size();\n\n      DocSetBuilder builder = new DocSetBuilder(searcher.getIndexReader().maxDoc());\n      if (!collectedTerms.isEmpty()) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs, context.docBase, liveDocs);\n        }\n      }\n\n      termsVisited += builder.add(termsEnum, base, liveDocs);\n     */\n\n      DocIdSetBuilder builder = new DocIdSetBuilder(context.reader().maxDoc(), terms);\n      builder.grow((int)Math.min(Integer.MAX_VALUE,count));\n      if (collectedTerms.isEmpty() == false) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs);\n        }\n      }\n\n      do {\n        // already positioned on the next term, so don't call next() here...\n        docs = termsEnum.postings(docs, PostingsEnum.NONE);\n        builder.add(docs);\n      } while (termsEnum.next() != null);\n\n      DocIdSet segSet = builder.build();\n      return segStates[context.ord] = new SegState(segSet);\n    }\n\n","bugFix":["16b25963ad38ed289ebf0f7af31269fa1ce80a11"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"02e175abd2c4c1611c5a9647486ae8ba249a94c1","date":1468327116,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#getSegState(LeafReaderContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#getSegState(LeafReaderContext).mjava","sourceNew":"    private SegState getSegState(LeafReaderContext context) throws IOException {\n      SegState segState = segStates[context.ord];\n      if (segState != null) return segState;\n\n      // first time, check our filter cache\n      boolean doCheck = !checkedFilterCache && context.ord == 0;\n      checkedFilterCache = true;\n      SolrIndexSearcher solrSearcher = null;\n      if (doCheck && searcher instanceof SolrIndexSearcher) {\n        solrSearcher = (SolrIndexSearcher)searcher;\n        if (solrSearcher.getFilterCache() == null) {\n          doCheck = false;\n        } else {\n          solrSearcher = (SolrIndexSearcher)searcher;\n          DocSet answer = solrSearcher.getFilterCache().get(SolrRangeQuery.this);\n          if (answer != null) {\n            filter = answer.getTopFilter();\n          }\n        }\n      } else {\n        doCheck = false;\n      }\n      \n      if (filter != null) {\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      final Terms terms = context.reader().terms(SolrRangeQuery.this.getField());\n      if (terms == null) {\n        return segStates[context.ord] = new SegState((DocIdSet) null);\n      }\n\n      final TermsEnum termsEnum = SolrRangeQuery.this.getTermsEnum(context);\n\n      PostingsEnum docs = null;\n\n      final List<TermAndState> collectedTerms = new ArrayList<>();\n      long count = collectTerms(context, termsEnum, collectedTerms);\n      if (count < 0) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        for (TermAndState t : collectedTerms) {\n          final TermContext termContext = new TermContext(searcher.getTopReaderContext());\n          termContext.register(t.state, context.ord, t.docFreq, t.totalTermFreq);\n          bq.add(new TermQuery(new Term( SolrRangeQuery.this.getField(), t.term), termContext), BooleanClause.Occur.SHOULD);\n        }\n        Query q = new ConstantScoreQuery(bq.build());\n        final Weight weight = searcher.rewrite(q).createWeight(searcher, needScores, score());\n        return segStates[context.ord] = new SegState(weight);\n      }\n\n      // Too many terms for boolean query...\n\n      if (doCheck) {\n        DocSet answer = createDocSet(solrSearcher, count);\n        solrSearcher.getFilterCache().put(SolrRangeQuery.this, answer);\n        filter = answer.getTopFilter();\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      /* FUTURE: reuse term states in the future to help build DocSet, use collected count so far...\n      Bits liveDocs = context.reader().getLiveDocs();\n      int base = context.docBase;\n      int termsVisited = collectedTerms.size();\n\n      DocSetBuilder builder = new DocSetBuilder(searcher.getIndexReader().maxDoc());\n      if (!collectedTerms.isEmpty()) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs, context.docBase, liveDocs);\n        }\n      }\n\n      termsVisited += builder.add(termsEnum, base, liveDocs);\n     */\n\n      DocIdSetBuilder builder = new DocIdSetBuilder(context.reader().maxDoc(), terms);\n      builder.grow((int)Math.min(Integer.MAX_VALUE,count));\n      if (collectedTerms.isEmpty() == false) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs);\n        }\n      }\n\n      do {\n        // already positioned on the next term, so don't call next() here...\n        docs = termsEnum.postings(docs, PostingsEnum.NONE);\n        builder.add(docs);\n      } while (termsEnum.next() != null);\n\n      DocIdSet segSet = builder.build();\n      return segStates[context.ord] = new SegState(segSet);\n    }\n\n","sourceOld":"    private SegState getSegState(LeafReaderContext context) throws IOException {\n      SegState segState = segStates[context.ord];\n      if (segState != null) return segState;\n\n      // first time, check our filter cache\n      boolean doCheck = !checkedFilterCache && context.ord == 0;\n      checkedFilterCache = true;\n      SolrIndexSearcher solrSearcher = null;\n      if (doCheck && searcher instanceof SolrIndexSearcher) {\n        solrSearcher = (SolrIndexSearcher)searcher;\n        if (solrSearcher.getFilterCache() == null) {\n          doCheck = false;\n        } else {\n          solrSearcher = (SolrIndexSearcher)searcher;\n          DocSet answer = solrSearcher.getFilterCache().get(SolrRangeQuery.this);\n          if (answer != null) {\n            filter = answer.getTopFilter();\n          }\n        }\n      } else {\n        doCheck = false;\n      }\n      \n      if (filter != null) {\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      final Terms terms = context.reader().terms(SolrRangeQuery.this.getField());\n      if (terms == null) {\n        return segStates[context.ord] = new SegState((DocIdSet) null);\n      }\n\n      final TermsEnum termsEnum = SolrRangeQuery.this.getTermsEnum(context);\n\n      PostingsEnum docs = null;\n\n      final List<TermAndState> collectedTerms = new ArrayList<>();\n      long count = collectTerms(context, termsEnum, collectedTerms);\n      if (count < 0) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        for (TermAndState t : collectedTerms) {\n          final TermContext termContext = new TermContext(searcher.getTopReaderContext());\n          termContext.register(t.state, context.ord, t.docFreq, t.totalTermFreq);\n          bq.add(new TermQuery(new Term( SolrRangeQuery.this.getField(), t.term), termContext), BooleanClause.Occur.SHOULD);\n        }\n        Query q = new ConstantScoreQuery(bq.build());\n        final Weight weight = searcher.rewrite(q).createWeight(searcher, needScores);\n        weight.normalize(1f, score());\n        return segStates[context.ord] = new SegState(weight);\n      }\n\n      // Too many terms for boolean query...\n\n      if (doCheck) {\n        DocSet answer = createDocSet(solrSearcher, count);\n        solrSearcher.getFilterCache().put(SolrRangeQuery.this, answer);\n        filter = answer.getTopFilter();\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      /* FUTURE: reuse term states in the future to help build DocSet, use collected count so far...\n      Bits liveDocs = context.reader().getLiveDocs();\n      int base = context.docBase;\n      int termsVisited = collectedTerms.size();\n\n      DocSetBuilder builder = new DocSetBuilder(searcher.getIndexReader().maxDoc());\n      if (!collectedTerms.isEmpty()) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs, context.docBase, liveDocs);\n        }\n      }\n\n      termsVisited += builder.add(termsEnum, base, liveDocs);\n     */\n\n      DocIdSetBuilder builder = new DocIdSetBuilder(context.reader().maxDoc(), terms);\n      builder.grow((int)Math.min(Integer.MAX_VALUE,count));\n      if (collectedTerms.isEmpty() == false) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs);\n        }\n      }\n\n      do {\n        // already positioned on the next term, so don't call next() here...\n        docs = termsEnum.postings(docs, PostingsEnum.NONE);\n        builder.add(docs);\n      } while (termsEnum.next() != null);\n\n      DocIdSet segSet = builder.build();\n      return segStates[context.ord] = new SegState(segSet);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#getSegState(LeafReaderContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#getSegState(LeafReaderContext).mjava","sourceNew":"    private SegState getSegState(LeafReaderContext context) throws IOException {\n      SegState segState = segStates[context.ord];\n      if (segState != null) return segState;\n\n      // first time, check our filter cache\n      boolean doCheck = !checkedFilterCache && context.ord == 0;\n      checkedFilterCache = true;\n      SolrIndexSearcher solrSearcher = null;\n      if (doCheck && searcher instanceof SolrIndexSearcher) {\n        solrSearcher = (SolrIndexSearcher)searcher;\n        if (solrSearcher.getFilterCache() == null) {\n          doCheck = false;\n        } else {\n          solrSearcher = (SolrIndexSearcher)searcher;\n          DocSet answer = solrSearcher.getFilterCache().get(SolrRangeQuery.this);\n          if (answer != null) {\n            filter = answer.getTopFilter();\n          }\n        }\n      } else {\n        doCheck = false;\n      }\n      \n      if (filter != null) {\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      final Terms terms = context.reader().terms(SolrRangeQuery.this.getField());\n      if (terms == null) {\n        return segStates[context.ord] = new SegState((DocIdSet) null);\n      }\n\n      final TermsEnum termsEnum = SolrRangeQuery.this.getTermsEnum(context);\n\n      PostingsEnum docs = null;\n\n      final List<TermAndState> collectedTerms = new ArrayList<>();\n      long count = collectTerms(context, termsEnum, collectedTerms);\n      if (count < 0) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        for (TermAndState t : collectedTerms) {\n          final TermContext termContext = new TermContext(searcher.getTopReaderContext());\n          termContext.register(t.state, context.ord, t.docFreq, t.totalTermFreq);\n          bq.add(new TermQuery(new Term( SolrRangeQuery.this.getField(), t.term), termContext), BooleanClause.Occur.SHOULD);\n        }\n        Query q = new ConstantScoreQuery(bq.build());\n        final Weight weight = searcher.rewrite(q).createWeight(searcher, needScores, score());\n        return segStates[context.ord] = new SegState(weight);\n      }\n\n      // Too many terms for boolean query...\n\n      if (doCheck) {\n        DocSet answer = createDocSet(solrSearcher, count);\n        solrSearcher.getFilterCache().put(SolrRangeQuery.this, answer);\n        filter = answer.getTopFilter();\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      /* FUTURE: reuse term states in the future to help build DocSet, use collected count so far...\n      Bits liveDocs = context.reader().getLiveDocs();\n      int base = context.docBase;\n      int termsVisited = collectedTerms.size();\n\n      DocSetBuilder builder = new DocSetBuilder(searcher.getIndexReader().maxDoc());\n      if (!collectedTerms.isEmpty()) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs, context.docBase, liveDocs);\n        }\n      }\n\n      termsVisited += builder.add(termsEnum, base, liveDocs);\n     */\n\n      DocIdSetBuilder builder = new DocIdSetBuilder(context.reader().maxDoc(), terms);\n      builder.grow((int)Math.min(Integer.MAX_VALUE,count));\n      if (collectedTerms.isEmpty() == false) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs);\n        }\n      }\n\n      do {\n        // already positioned on the next term, so don't call next() here...\n        docs = termsEnum.postings(docs, PostingsEnum.NONE);\n        builder.add(docs);\n      } while (termsEnum.next() != null);\n\n      DocIdSet segSet = builder.build();\n      return segStates[context.ord] = new SegState(segSet);\n    }\n\n","sourceOld":"    private SegState getSegState(LeafReaderContext context) throws IOException {\n      SegState segState = segStates[context.ord];\n      if (segState != null) return segState;\n\n      // first time, check our filter cache\n      boolean doCheck = !checkedFilterCache && context.ord == 0;\n      checkedFilterCache = true;\n      SolrIndexSearcher solrSearcher = null;\n      if (doCheck && searcher instanceof SolrIndexSearcher) {\n        solrSearcher = (SolrIndexSearcher)searcher;\n        if (solrSearcher.getFilterCache() == null) {\n          doCheck = false;\n        } else {\n          solrSearcher = (SolrIndexSearcher)searcher;\n          DocSet answer = solrSearcher.getFilterCache().get(SolrRangeQuery.this);\n          if (answer != null) {\n            filter = answer.getTopFilter();\n          }\n        }\n      }\n\n      if (filter != null) {\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n\n      final Terms terms = context.reader().terms(SolrRangeQuery.this.getField());\n      if (terms == null) {\n        return segStates[context.ord] = new SegState((DocIdSet) null);\n      }\n\n      final TermsEnum termsEnum = SolrRangeQuery.this.getTermsEnum(context);\n\n      PostingsEnum docs = null;\n\n      final List<TermAndState> collectedTerms = new ArrayList<>();\n      long count = collectTerms(context, termsEnum, collectedTerms);\n      if (count < 0) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        for (TermAndState t : collectedTerms) {\n          final TermContext termContext = new TermContext(searcher.getTopReaderContext());\n          termContext.register(t.state, context.ord, t.docFreq, t.totalTermFreq);\n          bq.add(new TermQuery(new Term( SolrRangeQuery.this.getField(), t.term), termContext), BooleanClause.Occur.SHOULD);\n        }\n        Query q = new ConstantScoreQuery(bq.build());\n        final Weight weight = searcher.rewrite(q).createWeight(searcher, needScores);\n        weight.normalize(1f, score());\n        return segStates[context.ord] = new SegState(weight);\n      }\n\n      // Too many terms for boolean query...\n\n      if (doCheck) {\n        DocSet answer = createDocSet(solrSearcher, count);\n        solrSearcher.getFilterCache().put(SolrRangeQuery.this, answer);\n        filter = answer.getTopFilter();\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      /* FUTURE: reuse term states in the future to help build DocSet, use collected count so far...\n      Bits liveDocs = context.reader().getLiveDocs();\n      int base = context.docBase;\n      int termsVisited = collectedTerms.size();\n\n      DocSetBuilder builder = new DocSetBuilder(searcher.getIndexReader().maxDoc());\n      if (!collectedTerms.isEmpty()) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs, context.docBase, liveDocs);\n        }\n      }\n\n      termsVisited += builder.add(termsEnum, base, liveDocs);\n     */\n\n      DocIdSetBuilder builder = new DocIdSetBuilder(context.reader().maxDoc(), terms);\n      builder.grow((int)Math.min(Integer.MAX_VALUE,count));\n      if (collectedTerms.isEmpty() == false) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs);\n        }\n      }\n\n      do {\n        // already positioned on the next term, so don't call next() here...\n        docs = termsEnum.postings(docs, PostingsEnum.NONE);\n        builder.add(docs);\n      } while (termsEnum.next() != null);\n\n      DocIdSet segSet = builder.build();\n      return segStates[context.ord] = new SegState(segSet);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc47cb7b4346802411bb432f501ed0673d7119e","date":1512640179,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#getSegState(LeafReaderContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#getSegState(LeafReaderContext).mjava","sourceNew":"    private SegState getSegState(LeafReaderContext context) throws IOException {\n      SegState segState = segStates[context.ord];\n      if (segState != null) return segState;\n\n      // first time, check our filter cache\n      boolean doCheck = !checkedFilterCache && context.ord == 0;\n      checkedFilterCache = true;\n      SolrIndexSearcher solrSearcher = null;\n      if (doCheck && searcher instanceof SolrIndexSearcher) {\n        solrSearcher = (SolrIndexSearcher)searcher;\n        if (solrSearcher.getFilterCache() == null) {\n          doCheck = false;\n        } else {\n          solrSearcher = (SolrIndexSearcher)searcher;\n          DocSet answer = solrSearcher.getFilterCache().get(SolrRangeQuery.this);\n          if (answer != null) {\n            filter = answer.getTopFilter();\n          }\n        }\n      } else {\n        doCheck = false;\n      }\n      \n      if (filter != null) {\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      final Terms terms = context.reader().terms(SolrRangeQuery.this.getField());\n      if (terms == null) {\n        return segStates[context.ord] = new SegState((DocIdSet) null);\n      }\n\n      final TermsEnum termsEnum = SolrRangeQuery.this.getTermsEnum(context);\n\n      PostingsEnum docs = null;\n\n      final List<TermAndState> collectedTerms = new ArrayList<>();\n      long count = collectTerms(context, termsEnum, collectedTerms);\n      if (count < 0) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        for (TermAndState t : collectedTerms) {\n          final TermContext termContext = new TermContext(searcher.getTopReaderContext());\n          termContext.register(t.state, context.ord, t.docFreq, t.totalTermFreq);\n          bq.add(new TermQuery(new Term( SolrRangeQuery.this.getField(), t.term), termContext), BooleanClause.Occur.SHOULD);\n        }\n        Query q = new ConstantScoreQuery(bq.build());\n        final Weight weight = searcher.rewrite(q).createWeight(searcher, needScores ? ScoreMode.COMPLETE : ScoreMode.COMPLETE_NO_SCORES, score());\n        return segStates[context.ord] = new SegState(weight);\n      }\n\n      // Too many terms for boolean query...\n\n      if (doCheck) {\n        DocSet answer = createDocSet(solrSearcher, count);\n        solrSearcher.getFilterCache().put(SolrRangeQuery.this, answer);\n        filter = answer.getTopFilter();\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      /* FUTURE: reuse term states in the future to help build DocSet, use collected count so far...\n      Bits liveDocs = context.reader().getLiveDocs();\n      int base = context.docBase;\n      int termsVisited = collectedTerms.size();\n\n      DocSetBuilder builder = new DocSetBuilder(searcher.getIndexReader().maxDoc());\n      if (!collectedTerms.isEmpty()) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs, context.docBase, liveDocs);\n        }\n      }\n\n      termsVisited += builder.add(termsEnum, base, liveDocs);\n     */\n\n      DocIdSetBuilder builder = new DocIdSetBuilder(context.reader().maxDoc(), terms);\n      builder.grow((int)Math.min(Integer.MAX_VALUE,count));\n      if (collectedTerms.isEmpty() == false) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs);\n        }\n      }\n\n      do {\n        // already positioned on the next term, so don't call next() here...\n        docs = termsEnum.postings(docs, PostingsEnum.NONE);\n        builder.add(docs);\n      } while (termsEnum.next() != null);\n\n      DocIdSet segSet = builder.build();\n      return segStates[context.ord] = new SegState(segSet);\n    }\n\n","sourceOld":"    private SegState getSegState(LeafReaderContext context) throws IOException {\n      SegState segState = segStates[context.ord];\n      if (segState != null) return segState;\n\n      // first time, check our filter cache\n      boolean doCheck = !checkedFilterCache && context.ord == 0;\n      checkedFilterCache = true;\n      SolrIndexSearcher solrSearcher = null;\n      if (doCheck && searcher instanceof SolrIndexSearcher) {\n        solrSearcher = (SolrIndexSearcher)searcher;\n        if (solrSearcher.getFilterCache() == null) {\n          doCheck = false;\n        } else {\n          solrSearcher = (SolrIndexSearcher)searcher;\n          DocSet answer = solrSearcher.getFilterCache().get(SolrRangeQuery.this);\n          if (answer != null) {\n            filter = answer.getTopFilter();\n          }\n        }\n      } else {\n        doCheck = false;\n      }\n      \n      if (filter != null) {\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      final Terms terms = context.reader().terms(SolrRangeQuery.this.getField());\n      if (terms == null) {\n        return segStates[context.ord] = new SegState((DocIdSet) null);\n      }\n\n      final TermsEnum termsEnum = SolrRangeQuery.this.getTermsEnum(context);\n\n      PostingsEnum docs = null;\n\n      final List<TermAndState> collectedTerms = new ArrayList<>();\n      long count = collectTerms(context, termsEnum, collectedTerms);\n      if (count < 0) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        for (TermAndState t : collectedTerms) {\n          final TermContext termContext = new TermContext(searcher.getTopReaderContext());\n          termContext.register(t.state, context.ord, t.docFreq, t.totalTermFreq);\n          bq.add(new TermQuery(new Term( SolrRangeQuery.this.getField(), t.term), termContext), BooleanClause.Occur.SHOULD);\n        }\n        Query q = new ConstantScoreQuery(bq.build());\n        final Weight weight = searcher.rewrite(q).createWeight(searcher, needScores, score());\n        return segStates[context.ord] = new SegState(weight);\n      }\n\n      // Too many terms for boolean query...\n\n      if (doCheck) {\n        DocSet answer = createDocSet(solrSearcher, count);\n        solrSearcher.getFilterCache().put(SolrRangeQuery.this, answer);\n        filter = answer.getTopFilter();\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      /* FUTURE: reuse term states in the future to help build DocSet, use collected count so far...\n      Bits liveDocs = context.reader().getLiveDocs();\n      int base = context.docBase;\n      int termsVisited = collectedTerms.size();\n\n      DocSetBuilder builder = new DocSetBuilder(searcher.getIndexReader().maxDoc());\n      if (!collectedTerms.isEmpty()) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs, context.docBase, liveDocs);\n        }\n      }\n\n      termsVisited += builder.add(termsEnum, base, liveDocs);\n     */\n\n      DocIdSetBuilder builder = new DocIdSetBuilder(context.reader().maxDoc(), terms);\n      builder.grow((int)Math.min(Integer.MAX_VALUE,count));\n      if (collectedTerms.isEmpty() == false) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs);\n        }\n      }\n\n      do {\n        // already positioned on the next term, so don't call next() here...\n        docs = termsEnum.postings(docs, PostingsEnum.NONE);\n        builder.add(docs);\n      } while (termsEnum.next() != null);\n\n      DocIdSet segSet = builder.build();\n      return segStates[context.ord] = new SegState(segSet);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#getSegState(LeafReaderContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#getSegState(LeafReaderContext).mjava","sourceNew":"    private SegState getSegState(LeafReaderContext context) throws IOException {\n      SegState segState = segStates[context.ord];\n      if (segState != null) return segState;\n\n      // first time, check our filter cache\n      boolean doCheck = !checkedFilterCache && context.ord == 0;\n      checkedFilterCache = true;\n      SolrIndexSearcher solrSearcher = null;\n      if (doCheck && searcher instanceof SolrIndexSearcher) {\n        solrSearcher = (SolrIndexSearcher)searcher;\n        if (solrSearcher.getFilterCache() == null) {\n          doCheck = false;\n        } else {\n          solrSearcher = (SolrIndexSearcher)searcher;\n          DocSet answer = solrSearcher.getFilterCache().get(SolrRangeQuery.this);\n          if (answer != null) {\n            filter = answer.getTopFilter();\n          }\n        }\n      } else {\n        doCheck = false;\n      }\n      \n      if (filter != null) {\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      final Terms terms = context.reader().terms(SolrRangeQuery.this.getField());\n      if (terms == null) {\n        return segStates[context.ord] = new SegState((DocIdSet) null);\n      }\n\n      final TermsEnum termsEnum = SolrRangeQuery.this.getTermsEnum(context);\n\n      PostingsEnum docs = null;\n\n      final List<TermAndState> collectedTerms = new ArrayList<>();\n      long count = collectTerms(context, termsEnum, collectedTerms);\n      if (count < 0) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        for (TermAndState t : collectedTerms) {\n          final TermContext termContext = new TermContext(searcher.getTopReaderContext());\n          termContext.register(t.state, context.ord, t.docFreq, t.totalTermFreq);\n          bq.add(new TermQuery(new Term( SolrRangeQuery.this.getField(), t.term), termContext), BooleanClause.Occur.SHOULD);\n        }\n        Query q = new ConstantScoreQuery(bq.build());\n        final Weight weight = searcher.rewrite(q).createWeight(searcher, needScores ? ScoreMode.COMPLETE : ScoreMode.COMPLETE_NO_SCORES, score());\n        return segStates[context.ord] = new SegState(weight);\n      }\n\n      // Too many terms for boolean query...\n\n      if (doCheck) {\n        DocSet answer = createDocSet(solrSearcher, count);\n        solrSearcher.getFilterCache().put(SolrRangeQuery.this, answer);\n        filter = answer.getTopFilter();\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      /* FUTURE: reuse term states in the future to help build DocSet, use collected count so far...\n      Bits liveDocs = context.reader().getLiveDocs();\n      int base = context.docBase;\n      int termsVisited = collectedTerms.size();\n\n      DocSetBuilder builder = new DocSetBuilder(searcher.getIndexReader().maxDoc());\n      if (!collectedTerms.isEmpty()) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs, context.docBase, liveDocs);\n        }\n      }\n\n      termsVisited += builder.add(termsEnum, base, liveDocs);\n     */\n\n      DocIdSetBuilder builder = new DocIdSetBuilder(context.reader().maxDoc(), terms);\n      builder.grow((int)Math.min(Integer.MAX_VALUE,count));\n      if (collectedTerms.isEmpty() == false) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs);\n        }\n      }\n\n      do {\n        // already positioned on the next term, so don't call next() here...\n        docs = termsEnum.postings(docs, PostingsEnum.NONE);\n        builder.add(docs);\n      } while (termsEnum.next() != null);\n\n      DocIdSet segSet = builder.build();\n      return segStates[context.ord] = new SegState(segSet);\n    }\n\n","sourceOld":"    private SegState getSegState(LeafReaderContext context) throws IOException {\n      SegState segState = segStates[context.ord];\n      if (segState != null) return segState;\n\n      // first time, check our filter cache\n      boolean doCheck = !checkedFilterCache && context.ord == 0;\n      checkedFilterCache = true;\n      SolrIndexSearcher solrSearcher = null;\n      if (doCheck && searcher instanceof SolrIndexSearcher) {\n        solrSearcher = (SolrIndexSearcher)searcher;\n        if (solrSearcher.getFilterCache() == null) {\n          doCheck = false;\n        } else {\n          solrSearcher = (SolrIndexSearcher)searcher;\n          DocSet answer = solrSearcher.getFilterCache().get(SolrRangeQuery.this);\n          if (answer != null) {\n            filter = answer.getTopFilter();\n          }\n        }\n      } else {\n        doCheck = false;\n      }\n      \n      if (filter != null) {\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      final Terms terms = context.reader().terms(SolrRangeQuery.this.getField());\n      if (terms == null) {\n        return segStates[context.ord] = new SegState((DocIdSet) null);\n      }\n\n      final TermsEnum termsEnum = SolrRangeQuery.this.getTermsEnum(context);\n\n      PostingsEnum docs = null;\n\n      final List<TermAndState> collectedTerms = new ArrayList<>();\n      long count = collectTerms(context, termsEnum, collectedTerms);\n      if (count < 0) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        for (TermAndState t : collectedTerms) {\n          final TermContext termContext = new TermContext(searcher.getTopReaderContext());\n          termContext.register(t.state, context.ord, t.docFreq, t.totalTermFreq);\n          bq.add(new TermQuery(new Term( SolrRangeQuery.this.getField(), t.term), termContext), BooleanClause.Occur.SHOULD);\n        }\n        Query q = new ConstantScoreQuery(bq.build());\n        final Weight weight = searcher.rewrite(q).createWeight(searcher, needScores, score());\n        return segStates[context.ord] = new SegState(weight);\n      }\n\n      // Too many terms for boolean query...\n\n      if (doCheck) {\n        DocSet answer = createDocSet(solrSearcher, count);\n        solrSearcher.getFilterCache().put(SolrRangeQuery.this, answer);\n        filter = answer.getTopFilter();\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      /* FUTURE: reuse term states in the future to help build DocSet, use collected count so far...\n      Bits liveDocs = context.reader().getLiveDocs();\n      int base = context.docBase;\n      int termsVisited = collectedTerms.size();\n\n      DocSetBuilder builder = new DocSetBuilder(searcher.getIndexReader().maxDoc());\n      if (!collectedTerms.isEmpty()) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs, context.docBase, liveDocs);\n        }\n      }\n\n      termsVisited += builder.add(termsEnum, base, liveDocs);\n     */\n\n      DocIdSetBuilder builder = new DocIdSetBuilder(context.reader().maxDoc(), terms);\n      builder.grow((int)Math.min(Integer.MAX_VALUE,count));\n      if (collectedTerms.isEmpty() == false) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs);\n        }\n      }\n\n      do {\n        // already positioned on the next term, so don't call next() here...\n        docs = termsEnum.postings(docs, PostingsEnum.NONE);\n        builder.add(docs);\n      } while (termsEnum.next() != null);\n\n      DocIdSet segSet = builder.build();\n      return segStates[context.ord] = new SegState(segSet);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6e9f769521480a623f897c0d59089b919fa4239","date":1515161835,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#getSegState(LeafReaderContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#getSegState(LeafReaderContext).mjava","sourceNew":"    private SegState getSegState(LeafReaderContext context) throws IOException {\n      SegState segState = segStates[context.ord];\n      if (segState != null) return segState;\n\n      // first time, check our filter cache\n      boolean doCheck = !checkedFilterCache && context.ord == 0;\n      checkedFilterCache = true;\n      SolrIndexSearcher solrSearcher = null;\n      if (doCheck && searcher instanceof SolrIndexSearcher) {\n        solrSearcher = (SolrIndexSearcher)searcher;\n        if (solrSearcher.getFilterCache() == null) {\n          doCheck = false;\n        } else {\n          solrSearcher = (SolrIndexSearcher)searcher;\n          DocSet answer = solrSearcher.getFilterCache().get(SolrRangeQuery.this);\n          if (answer != null) {\n            filter = answer.getTopFilter();\n          }\n        }\n      } else {\n        doCheck = false;\n      }\n      \n      if (filter != null) {\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      final Terms terms = context.reader().terms(SolrRangeQuery.this.getField());\n      if (terms == null) {\n        return segStates[context.ord] = new SegState((DocIdSet) null);\n      }\n\n      final TermsEnum termsEnum = SolrRangeQuery.this.getTermsEnum(context);\n\n      PostingsEnum docs = null;\n\n      final List<TermAndState> collectedTerms = new ArrayList<>();\n      long count = collectTerms(context, termsEnum, collectedTerms);\n      if (count < 0) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        for (TermAndState t : collectedTerms) {\n          final TermStates termStates = new TermStates(searcher.getTopReaderContext());\n          termStates.register(t.state, context.ord, t.docFreq, t.totalTermFreq);\n          bq.add(new TermQuery(new Term( SolrRangeQuery.this.getField(), t.term), termStates), BooleanClause.Occur.SHOULD);\n        }\n        Query q = new ConstantScoreQuery(bq.build());\n        final Weight weight = searcher.rewrite(q).createWeight(searcher, needScores ? ScoreMode.COMPLETE : ScoreMode.COMPLETE_NO_SCORES, score());\n        return segStates[context.ord] = new SegState(weight);\n      }\n\n      // Too many terms for boolean query...\n\n      if (doCheck) {\n        DocSet answer = createDocSet(solrSearcher, count);\n        solrSearcher.getFilterCache().put(SolrRangeQuery.this, answer);\n        filter = answer.getTopFilter();\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      /* FUTURE: reuse term states in the future to help build DocSet, use collected count so far...\n      Bits liveDocs = context.reader().getLiveDocs();\n      int base = context.docBase;\n      int termsVisited = collectedTerms.size();\n\n      DocSetBuilder builder = new DocSetBuilder(searcher.getIndexReader().maxDoc());\n      if (!collectedTerms.isEmpty()) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs, context.docBase, liveDocs);\n        }\n      }\n\n      termsVisited += builder.add(termsEnum, base, liveDocs);\n     */\n\n      DocIdSetBuilder builder = new DocIdSetBuilder(context.reader().maxDoc(), terms);\n      builder.grow((int)Math.min(Integer.MAX_VALUE,count));\n      if (collectedTerms.isEmpty() == false) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs);\n        }\n      }\n\n      do {\n        // already positioned on the next term, so don't call next() here...\n        docs = termsEnum.postings(docs, PostingsEnum.NONE);\n        builder.add(docs);\n      } while (termsEnum.next() != null);\n\n      DocIdSet segSet = builder.build();\n      return segStates[context.ord] = new SegState(segSet);\n    }\n\n","sourceOld":"    private SegState getSegState(LeafReaderContext context) throws IOException {\n      SegState segState = segStates[context.ord];\n      if (segState != null) return segState;\n\n      // first time, check our filter cache\n      boolean doCheck = !checkedFilterCache && context.ord == 0;\n      checkedFilterCache = true;\n      SolrIndexSearcher solrSearcher = null;\n      if (doCheck && searcher instanceof SolrIndexSearcher) {\n        solrSearcher = (SolrIndexSearcher)searcher;\n        if (solrSearcher.getFilterCache() == null) {\n          doCheck = false;\n        } else {\n          solrSearcher = (SolrIndexSearcher)searcher;\n          DocSet answer = solrSearcher.getFilterCache().get(SolrRangeQuery.this);\n          if (answer != null) {\n            filter = answer.getTopFilter();\n          }\n        }\n      } else {\n        doCheck = false;\n      }\n      \n      if (filter != null) {\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      final Terms terms = context.reader().terms(SolrRangeQuery.this.getField());\n      if (terms == null) {\n        return segStates[context.ord] = new SegState((DocIdSet) null);\n      }\n\n      final TermsEnum termsEnum = SolrRangeQuery.this.getTermsEnum(context);\n\n      PostingsEnum docs = null;\n\n      final List<TermAndState> collectedTerms = new ArrayList<>();\n      long count = collectTerms(context, termsEnum, collectedTerms);\n      if (count < 0) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        for (TermAndState t : collectedTerms) {\n          final TermContext termContext = new TermContext(searcher.getTopReaderContext());\n          termContext.register(t.state, context.ord, t.docFreq, t.totalTermFreq);\n          bq.add(new TermQuery(new Term( SolrRangeQuery.this.getField(), t.term), termContext), BooleanClause.Occur.SHOULD);\n        }\n        Query q = new ConstantScoreQuery(bq.build());\n        final Weight weight = searcher.rewrite(q).createWeight(searcher, needScores ? ScoreMode.COMPLETE : ScoreMode.COMPLETE_NO_SCORES, score());\n        return segStates[context.ord] = new SegState(weight);\n      }\n\n      // Too many terms for boolean query...\n\n      if (doCheck) {\n        DocSet answer = createDocSet(solrSearcher, count);\n        solrSearcher.getFilterCache().put(SolrRangeQuery.this, answer);\n        filter = answer.getTopFilter();\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      /* FUTURE: reuse term states in the future to help build DocSet, use collected count so far...\n      Bits liveDocs = context.reader().getLiveDocs();\n      int base = context.docBase;\n      int termsVisited = collectedTerms.size();\n\n      DocSetBuilder builder = new DocSetBuilder(searcher.getIndexReader().maxDoc());\n      if (!collectedTerms.isEmpty()) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs, context.docBase, liveDocs);\n        }\n      }\n\n      termsVisited += builder.add(termsEnum, base, liveDocs);\n     */\n\n      DocIdSetBuilder builder = new DocIdSetBuilder(context.reader().maxDoc(), terms);\n      builder.grow((int)Math.min(Integer.MAX_VALUE,count));\n      if (collectedTerms.isEmpty() == false) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs);\n        }\n      }\n\n      do {\n        // already positioned on the next term, so don't call next() here...\n        docs = termsEnum.postings(docs, PostingsEnum.NONE);\n        builder.add(docs);\n      } while (termsEnum.next() != null);\n\n      DocIdSet segSet = builder.build();\n      return segStates[context.ord] = new SegState(segSet);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#getSegState(LeafReaderContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#getSegState(LeafReaderContext).mjava","sourceNew":"    private SegState getSegState(LeafReaderContext context) throws IOException {\n      SegState segState = segStates[context.ord];\n      if (segState != null) return segState;\n\n      // first time, check our filter cache\n      boolean doCheck = !checkedFilterCache && context.ord == 0;\n      checkedFilterCache = true;\n      SolrIndexSearcher solrSearcher = null;\n      if (doCheck && searcher instanceof SolrIndexSearcher) {\n        solrSearcher = (SolrIndexSearcher)searcher;\n        if (solrSearcher.getFilterCache() == null) {\n          doCheck = false;\n        } else {\n          solrSearcher = (SolrIndexSearcher)searcher;\n          DocSet answer = solrSearcher.getFilterCache().get(SolrRangeQuery.this);\n          if (answer != null) {\n            filter = answer.getTopFilter();\n          }\n        }\n      } else {\n        doCheck = false;\n      }\n      \n      if (filter != null) {\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      final Terms terms = context.reader().terms(SolrRangeQuery.this.getField());\n      if (terms == null) {\n        return segStates[context.ord] = new SegState((DocIdSet) null);\n      }\n\n      final TermsEnum termsEnum = SolrRangeQuery.this.getTermsEnum(context);\n\n      PostingsEnum docs = null;\n\n      final List<TermAndState> collectedTerms = new ArrayList<>();\n      long count = collectTerms(context, termsEnum, collectedTerms);\n      if (count < 0) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        for (TermAndState t : collectedTerms) {\n          final TermStates termStates = new TermStates(searcher.getTopReaderContext());\n          termStates.register(t.state, context.ord, t.docFreq, t.totalTermFreq);\n          bq.add(new TermQuery(new Term( SolrRangeQuery.this.getField(), t.term), termStates), BooleanClause.Occur.SHOULD);\n        }\n        Query q = new ConstantScoreQuery(bq.build());\n        final Weight weight = searcher.rewrite(q).createWeight(searcher, needScores ? ScoreMode.COMPLETE : ScoreMode.COMPLETE_NO_SCORES, score());\n        return segStates[context.ord] = new SegState(weight);\n      }\n\n      // Too many terms for boolean query...\n\n      if (doCheck) {\n        DocSet answer = createDocSet(solrSearcher, count);\n        solrSearcher.getFilterCache().put(SolrRangeQuery.this, answer);\n        filter = answer.getTopFilter();\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      /* FUTURE: reuse term states in the future to help build DocSet, use collected count so far...\n      Bits liveDocs = context.reader().getLiveDocs();\n      int base = context.docBase;\n      int termsVisited = collectedTerms.size();\n\n      DocSetBuilder builder = new DocSetBuilder(searcher.getIndexReader().maxDoc());\n      if (!collectedTerms.isEmpty()) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs, context.docBase, liveDocs);\n        }\n      }\n\n      termsVisited += builder.add(termsEnum, base, liveDocs);\n     */\n\n      DocIdSetBuilder builder = new DocIdSetBuilder(context.reader().maxDoc(), terms);\n      builder.grow((int)Math.min(Integer.MAX_VALUE,count));\n      if (collectedTerms.isEmpty() == false) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs);\n        }\n      }\n\n      do {\n        // already positioned on the next term, so don't call next() here...\n        docs = termsEnum.postings(docs, PostingsEnum.NONE);\n        builder.add(docs);\n      } while (termsEnum.next() != null);\n\n      DocIdSet segSet = builder.build();\n      return segStates[context.ord] = new SegState(segSet);\n    }\n\n","sourceOld":"    private SegState getSegState(LeafReaderContext context) throws IOException {\n      SegState segState = segStates[context.ord];\n      if (segState != null) return segState;\n\n      // first time, check our filter cache\n      boolean doCheck = !checkedFilterCache && context.ord == 0;\n      checkedFilterCache = true;\n      SolrIndexSearcher solrSearcher = null;\n      if (doCheck && searcher instanceof SolrIndexSearcher) {\n        solrSearcher = (SolrIndexSearcher)searcher;\n        if (solrSearcher.getFilterCache() == null) {\n          doCheck = false;\n        } else {\n          solrSearcher = (SolrIndexSearcher)searcher;\n          DocSet answer = solrSearcher.getFilterCache().get(SolrRangeQuery.this);\n          if (answer != null) {\n            filter = answer.getTopFilter();\n          }\n        }\n      } else {\n        doCheck = false;\n      }\n      \n      if (filter != null) {\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      final Terms terms = context.reader().terms(SolrRangeQuery.this.getField());\n      if (terms == null) {\n        return segStates[context.ord] = new SegState((DocIdSet) null);\n      }\n\n      final TermsEnum termsEnum = SolrRangeQuery.this.getTermsEnum(context);\n\n      PostingsEnum docs = null;\n\n      final List<TermAndState> collectedTerms = new ArrayList<>();\n      long count = collectTerms(context, termsEnum, collectedTerms);\n      if (count < 0) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        for (TermAndState t : collectedTerms) {\n          final TermContext termContext = new TermContext(searcher.getTopReaderContext());\n          termContext.register(t.state, context.ord, t.docFreq, t.totalTermFreq);\n          bq.add(new TermQuery(new Term( SolrRangeQuery.this.getField(), t.term), termContext), BooleanClause.Occur.SHOULD);\n        }\n        Query q = new ConstantScoreQuery(bq.build());\n        final Weight weight = searcher.rewrite(q).createWeight(searcher, needScores ? ScoreMode.COMPLETE : ScoreMode.COMPLETE_NO_SCORES, score());\n        return segStates[context.ord] = new SegState(weight);\n      }\n\n      // Too many terms for boolean query...\n\n      if (doCheck) {\n        DocSet answer = createDocSet(solrSearcher, count);\n        solrSearcher.getFilterCache().put(SolrRangeQuery.this, answer);\n        filter = answer.getTopFilter();\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      /* FUTURE: reuse term states in the future to help build DocSet, use collected count so far...\n      Bits liveDocs = context.reader().getLiveDocs();\n      int base = context.docBase;\n      int termsVisited = collectedTerms.size();\n\n      DocSetBuilder builder = new DocSetBuilder(searcher.getIndexReader().maxDoc());\n      if (!collectedTerms.isEmpty()) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs, context.docBase, liveDocs);\n        }\n      }\n\n      termsVisited += builder.add(termsEnum, base, liveDocs);\n     */\n\n      DocIdSetBuilder builder = new DocIdSetBuilder(context.reader().maxDoc(), terms);\n      builder.grow((int)Math.min(Integer.MAX_VALUE,count));\n      if (collectedTerms.isEmpty() == false) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs);\n        }\n      }\n\n      do {\n        // already positioned on the next term, so don't call next() here...\n        docs = termsEnum.postings(docs, PostingsEnum.NONE);\n        builder.add(docs);\n      } while (termsEnum.next() != null);\n\n      DocIdSet segSet = builder.build();\n      return segStates[context.ord] = new SegState(segSet);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9c226b0eeb8b028f572020f459851a663a2c064e","date":1542377651,"type":3,"author":"Christophe Bismuth","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#getSegState(LeafReaderContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/query/SolrRangeQuery.ConstWeight#getSegState(LeafReaderContext).mjava","sourceNew":"    private SegState getSegState(LeafReaderContext context) throws IOException {\n      SegState segState = segStates[context.ord];\n      if (segState != null) return segState;\n\n      // first time, check our filter cache\n      boolean doCheck = !checkedFilterCache && context.ord == 0;\n      checkedFilterCache = true;\n      SolrIndexSearcher solrSearcher = null;\n      if (doCheck && searcher instanceof SolrIndexSearcher) {\n        solrSearcher = (SolrIndexSearcher)searcher;\n        if (solrSearcher.getFilterCache() == null) {\n          doCheck = false;\n        } else {\n          solrSearcher = (SolrIndexSearcher)searcher;\n          DocSet answer = solrSearcher.getFilterCache().get(SolrRangeQuery.this);\n          if (answer != null) {\n            filter = answer.getTopFilter();\n          }\n        }\n      } else {\n        doCheck = false;\n      }\n      \n      if (filter != null) {\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      final Terms terms = context.reader().terms(SolrRangeQuery.this.getField());\n      if (terms == null) {\n        return segStates[context.ord] = new SegState((DocIdSet) null);\n      }\n\n      final TermsEnum termsEnum = SolrRangeQuery.this.getTermsEnum(context);\n\n      PostingsEnum docs = null;\n\n      final List<TermAndState> collectedTerms = new ArrayList<>();\n      long count = collectTerms(context, termsEnum, collectedTerms);\n      if (count < 0) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        for (TermAndState t : collectedTerms) {\n          final TermStates termStates = new TermStates(searcher.getTopReaderContext());\n          termStates.register(t.state, context.ord, t.docFreq, t.totalTermFreq);\n          bq.add(new TermQuery(new Term( SolrRangeQuery.this.getField(), t.term), termStates), BooleanClause.Occur.SHOULD);\n        }\n        Query q = new ConstantScoreQuery(bq.build());\n        final Weight weight = searcher.rewrite(q).createWeight(searcher, scoreMode, score());\n        return segStates[context.ord] = new SegState(weight);\n      }\n\n      // Too many terms for boolean query...\n\n      if (doCheck) {\n        DocSet answer = createDocSet(solrSearcher, count);\n        solrSearcher.getFilterCache().put(SolrRangeQuery.this, answer);\n        filter = answer.getTopFilter();\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      /* FUTURE: reuse term states in the future to help build DocSet, use collected count so far...\n      Bits liveDocs = context.reader().getLiveDocs();\n      int base = context.docBase;\n      int termsVisited = collectedTerms.size();\n\n      DocSetBuilder builder = new DocSetBuilder(searcher.getIndexReader().maxDoc());\n      if (!collectedTerms.isEmpty()) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs, context.docBase, liveDocs);\n        }\n      }\n\n      termsVisited += builder.add(termsEnum, base, liveDocs);\n     */\n\n      DocIdSetBuilder builder = new DocIdSetBuilder(context.reader().maxDoc(), terms);\n      builder.grow((int)Math.min(Integer.MAX_VALUE,count));\n      if (collectedTerms.isEmpty() == false) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs);\n        }\n      }\n\n      do {\n        // already positioned on the next term, so don't call next() here...\n        docs = termsEnum.postings(docs, PostingsEnum.NONE);\n        builder.add(docs);\n      } while (termsEnum.next() != null);\n\n      DocIdSet segSet = builder.build();\n      return segStates[context.ord] = new SegState(segSet);\n    }\n\n","sourceOld":"    private SegState getSegState(LeafReaderContext context) throws IOException {\n      SegState segState = segStates[context.ord];\n      if (segState != null) return segState;\n\n      // first time, check our filter cache\n      boolean doCheck = !checkedFilterCache && context.ord == 0;\n      checkedFilterCache = true;\n      SolrIndexSearcher solrSearcher = null;\n      if (doCheck && searcher instanceof SolrIndexSearcher) {\n        solrSearcher = (SolrIndexSearcher)searcher;\n        if (solrSearcher.getFilterCache() == null) {\n          doCheck = false;\n        } else {\n          solrSearcher = (SolrIndexSearcher)searcher;\n          DocSet answer = solrSearcher.getFilterCache().get(SolrRangeQuery.this);\n          if (answer != null) {\n            filter = answer.getTopFilter();\n          }\n        }\n      } else {\n        doCheck = false;\n      }\n      \n      if (filter != null) {\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      final Terms terms = context.reader().terms(SolrRangeQuery.this.getField());\n      if (terms == null) {\n        return segStates[context.ord] = new SegState((DocIdSet) null);\n      }\n\n      final TermsEnum termsEnum = SolrRangeQuery.this.getTermsEnum(context);\n\n      PostingsEnum docs = null;\n\n      final List<TermAndState> collectedTerms = new ArrayList<>();\n      long count = collectTerms(context, termsEnum, collectedTerms);\n      if (count < 0) {\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        for (TermAndState t : collectedTerms) {\n          final TermStates termStates = new TermStates(searcher.getTopReaderContext());\n          termStates.register(t.state, context.ord, t.docFreq, t.totalTermFreq);\n          bq.add(new TermQuery(new Term( SolrRangeQuery.this.getField(), t.term), termStates), BooleanClause.Occur.SHOULD);\n        }\n        Query q = new ConstantScoreQuery(bq.build());\n        final Weight weight = searcher.rewrite(q).createWeight(searcher, needScores ? ScoreMode.COMPLETE : ScoreMode.COMPLETE_NO_SCORES, score());\n        return segStates[context.ord] = new SegState(weight);\n      }\n\n      // Too many terms for boolean query...\n\n      if (doCheck) {\n        DocSet answer = createDocSet(solrSearcher, count);\n        solrSearcher.getFilterCache().put(SolrRangeQuery.this, answer);\n        filter = answer.getTopFilter();\n        return segStates[context.ord] = new SegState(filter.getDocIdSet(context, null));\n      }\n\n      /* FUTURE: reuse term states in the future to help build DocSet, use collected count so far...\n      Bits liveDocs = context.reader().getLiveDocs();\n      int base = context.docBase;\n      int termsVisited = collectedTerms.size();\n\n      DocSetBuilder builder = new DocSetBuilder(searcher.getIndexReader().maxDoc());\n      if (!collectedTerms.isEmpty()) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs, context.docBase, liveDocs);\n        }\n      }\n\n      termsVisited += builder.add(termsEnum, base, liveDocs);\n     */\n\n      DocIdSetBuilder builder = new DocIdSetBuilder(context.reader().maxDoc(), terms);\n      builder.grow((int)Math.min(Integer.MAX_VALUE,count));\n      if (collectedTerms.isEmpty() == false) {\n        TermsEnum termsEnum2 = terms.iterator();\n        for (TermAndState t : collectedTerms) {\n          termsEnum2.seekExact(t.term, t.state);\n          docs = termsEnum2.postings(docs, PostingsEnum.NONE);\n          builder.add(docs);\n        }\n      }\n\n      do {\n        // already positioned on the next term, so don't call next() here...\n        docs = termsEnum.postings(docs, PostingsEnum.NONE);\n        builder.add(docs);\n      } while (termsEnum.next() != null);\n\n      DocIdSet segSet = builder.build();\n      return segStates[context.ord] = new SegState(segSet);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"16b25963ad38ed289ebf0f7af31269fa1ce80a11":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b94236357aaa22b76c10629851fe4e376e0cea82":["417142ff08fda9cf0b72d5133e63097a166c6458","a6e9f769521480a623f897c0d59089b919fa4239"],"5cb157886ecc78f33fafd9d403e96a4a495503b3":["30540ec27130887a9372c159e8fe971200f37727"],"30540ec27130887a9372c159e8fe971200f37727":["16b25963ad38ed289ebf0f7af31269fa1ce80a11","c9ee4c03e3ee986704eeeb45c571d001905a6430"],"9c226b0eeb8b028f572020f459851a663a2c064e":["b94236357aaa22b76c10629851fe4e376e0cea82"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["55b50463286869f584cf849d1587a0fcd54d1dfa","02e175abd2c4c1611c5a9647486ae8ba249a94c1"],"417142ff08fda9cf0b72d5133e63097a166c6458":["02e175abd2c4c1611c5a9647486ae8ba249a94c1","9fc47cb7b4346802411bb432f501ed0673d7119e"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["16b25963ad38ed289ebf0f7af31269fa1ce80a11","30540ec27130887a9372c159e8fe971200f37727"],"a6e9f769521480a623f897c0d59089b919fa4239":["417142ff08fda9cf0b72d5133e63097a166c6458"],"c9ee4c03e3ee986704eeeb45c571d001905a6430":["16b25963ad38ed289ebf0f7af31269fa1ce80a11"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"02e175abd2c4c1611c5a9647486ae8ba249a94c1":["5cb157886ecc78f33fafd9d403e96a4a495503b3"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["02e175abd2c4c1611c5a9647486ae8ba249a94c1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9c226b0eeb8b028f572020f459851a663a2c064e"]},"commit2Childs":{"16b25963ad38ed289ebf0f7af31269fa1ce80a11":["30540ec27130887a9372c159e8fe971200f37727","55b50463286869f584cf849d1587a0fcd54d1dfa","c9ee4c03e3ee986704eeeb45c571d001905a6430"],"b94236357aaa22b76c10629851fe4e376e0cea82":["9c226b0eeb8b028f572020f459851a663a2c064e"],"5cb157886ecc78f33fafd9d403e96a4a495503b3":["02e175abd2c4c1611c5a9647486ae8ba249a94c1"],"30540ec27130887a9372c159e8fe971200f37727":["5cb157886ecc78f33fafd9d403e96a4a495503b3","55b50463286869f584cf849d1587a0fcd54d1dfa"],"9c226b0eeb8b028f572020f459851a663a2c064e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"417142ff08fda9cf0b72d5133e63097a166c6458":["b94236357aaa22b76c10629851fe4e376e0cea82","a6e9f769521480a623f897c0d59089b919fa4239"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a6e9f769521480a623f897c0d59089b919fa4239":["b94236357aaa22b76c10629851fe4e376e0cea82"],"c9ee4c03e3ee986704eeeb45c571d001905a6430":["30540ec27130887a9372c159e8fe971200f37727"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["16b25963ad38ed289ebf0f7af31269fa1ce80a11"],"02e175abd2c4c1611c5a9647486ae8ba249a94c1":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","417142ff08fda9cf0b72d5133e63097a166c6458","9fc47cb7b4346802411bb432f501ed0673d7119e"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["417142ff08fda9cf0b72d5133e63097a166c6458"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}