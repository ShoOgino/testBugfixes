{"path":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","sourceNew":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      final long ramBufferBytes = (long) (maxConfiguredRamBuffer * 1024 * 1024);\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta \n      final long expected = (2 * (ramBufferBytes)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta);\n      if (peakDelta < (ramBufferBytes >> 1)) {\n        /*\n         * if we are indexing with very low maxRamBuffer like 0.1MB memory can\n         * easily overflow if we check out some DWPT based on docCount and have\n         * several DWPT in flight indexing large documents (compared to the ram\n         * buffer). This means that those DWPT and their threads will not hit\n         * the stall control before asserting the memory which would in turn\n         * fail. To prevent this we only assert if the the largest document seen\n         * is smaller than the 1/2 of the maxRamBufferMB\n         */\n        assert ram <= expected : \"ram was \" + ram + \" expected: \" + expected\n            + \" flush mem: \" + flushBytes + \" activeMem: \" + activeBytes\n            + \" pendingMem: \" + numPending + \" flushingMem: \"\n            + numFlushingDWPT() + \" blockedMem: \" + numBlockedFlushes()\n            + \" peakDeltaMem: \" + peakDelta;\n      }\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      final long ramBufferBytes = (long) (maxConfiguredRamBuffer * 1024 * 1024);\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta \n      final long expected = (2 * (ramBufferBytes)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta);\n      if (peakDelta < (ramBufferBytes >> 1)) {\n        /*\n         * if we are indexing with very low maxRamBuffer like 0.1MB memory can\n         * easily overflow if we check out some DWPT based on docCount and have\n         * several DWPT in flight indexing large documents (compared to the ram\n         * buffer). This means that those DWPT and their threads will not hit\n         * the stall control before asserting the memory which would in turn\n         * fail. To prevent this we only assert if the the largest document seen\n         * is smaller than the 1/2 of the maxRamBufferMB\n         */\n        assert ram <= expected : \"ram was \" + ram + \" expected: \" + expected\n            + \" flush mem: \" + flushBytes + \" activeMem: \" + activeBytes\n            + \" pendingMem: \" + numPending + \" flushingMem: \"\n            + numFlushingDWPT() + \" blockedMem: \" + numBlockedFlushes()\n            + \" peakDeltaMem: \" + peakDelta;\n      }\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7698eeb1d6d7bff293dff708890f1a4849a45b4","date":1350583538,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","sourceNew":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      final long ramBufferBytes = (long) (maxConfiguredRamBuffer * 1024 * 1024);\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta\n      \n      // 2 * ramBufferBytes -> before we stall we need to cross the 2xRAM Buffer border this is still a valid limit\n      // (numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta) -> those are the total number of DWPT that are not active but not yet fully fluhsed\n      // all of them could theoretically be taken out of the loop once they crossed the RAM buffer and the last document was the peak delta\n      // (perThreadPool.getActiveThreadState() * peakDelta) -> at any given time there could be n threads in flight that crossed the stall control before we reached the limit and each of them could hold a peak document\n      final long expected = (2 * (ramBufferBytes)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta) + (perThreadPool.getActiveThreadState() * peakDelta);\n      // the expected ram consumption is an upper bound at this point and not really the expected consumption\n      if (peakDelta < (ramBufferBytes >> 1)) {\n        /*\n         * if we are indexing with very low maxRamBuffer like 0.1MB memory can\n         * easily overflow if we check out some DWPT based on docCount and have\n         * several DWPT in flight indexing large documents (compared to the ram\n         * buffer). This means that those DWPT and their threads will not hit\n         * the stall control before asserting the memory which would in turn\n         * fail. To prevent this we only assert if the the largest document seen\n         * is smaller than the 1/2 of the maxRamBufferMB\n         */\n        assert ram <= expected : \"actual mem: \" + ram + \" byte, expected mem: \" + expected\n            + \" byte, flush mem: \" + flushBytes + \", active mem: \" + activeBytes\n            + \", pending DWPT: \" + numPending + \", flushing DWPT: \"\n            + numFlushingDWPT() + \", blocked DWPT: \" + numBlockedFlushes()\n            + \", peakDelta mem: \" + peakDelta + \" byte\";\n      }\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      final long ramBufferBytes = (long) (maxConfiguredRamBuffer * 1024 * 1024);\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta \n      final long expected = (2 * (ramBufferBytes)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta);\n      if (peakDelta < (ramBufferBytes >> 1)) {\n        /*\n         * if we are indexing with very low maxRamBuffer like 0.1MB memory can\n         * easily overflow if we check out some DWPT based on docCount and have\n         * several DWPT in flight indexing large documents (compared to the ram\n         * buffer). This means that those DWPT and their threads will not hit\n         * the stall control before asserting the memory which would in turn\n         * fail. To prevent this we only assert if the the largest document seen\n         * is smaller than the 1/2 of the maxRamBufferMB\n         */\n        assert ram <= expected : \"ram was \" + ram + \" expected: \" + expected\n            + \" flush mem: \" + flushBytes + \" activeMem: \" + activeBytes\n            + \" pendingMem: \" + numPending + \" flushingMem: \"\n            + numFlushingDWPT() + \" blockedMem: \" + numBlockedFlushes()\n            + \" peakDeltaMem: \" + peakDelta;\n      }\n    }\n    return true;\n  }\n\n","bugFix":["fd9cc9d77712aba3662f24632df7539ab75e3667","32f306edd62f81390a6e263e8b913f089f3e98a1","73f7144b3d593d06882d826ef9e09bd8a1b75614"],"bugIntro":["18e20fa02735869173a20f36b8bfb855be5e5a13"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"62e52115b56781006682fd92c6938efaf174304d","date":1351014780,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","sourceNew":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      final long ramBufferBytes = (long) (maxConfiguredRamBuffer * 1024 * 1024);\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta\n      \n      // 2 * ramBufferBytes -> before we stall we need to cross the 2xRAM Buffer border this is still a valid limit\n      // (numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta) -> those are the total number of DWPT that are not active but not yet fully fluhsed\n      // all of them could theoretically be taken out of the loop once they crossed the RAM buffer and the last document was the peak delta\n      // (perThreadPool.getActiveThreadState() * peakDelta) -> at any given time there could be n threads in flight that crossed the stall control before we reached the limit and each of them could hold a peak document\n      final long expected = (2 * (ramBufferBytes)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta) + (perThreadPool.getActiveThreadState() * peakDelta);\n      // the expected ram consumption is an upper bound at this point and not really the expected consumption\n      if (peakDelta < (ramBufferBytes >> 1)) {\n        /*\n         * if we are indexing with very low maxRamBuffer like 0.1MB memory can\n         * easily overflow if we check out some DWPT based on docCount and have\n         * several DWPT in flight indexing large documents (compared to the ram\n         * buffer). This means that those DWPT and their threads will not hit\n         * the stall control before asserting the memory which would in turn\n         * fail. To prevent this we only assert if the the largest document seen\n         * is smaller than the 1/2 of the maxRamBufferMB\n         */\n        assert ram <= expected : \"actual mem: \" + ram + \" byte, expected mem: \" + expected\n            + \" byte, flush mem: \" + flushBytes + \", active mem: \" + activeBytes\n            + \", pending DWPT: \" + numPending + \", flushing DWPT: \"\n            + numFlushingDWPT() + \", blocked DWPT: \" + numBlockedFlushes()\n            + \", peakDelta mem: \" + peakDelta + \" byte\";\n      }\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      final long ramBufferBytes = (long) (maxConfiguredRamBuffer * 1024 * 1024);\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta \n      final long expected = (2 * (ramBufferBytes)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta);\n      if (peakDelta < (ramBufferBytes >> 1)) {\n        /*\n         * if we are indexing with very low maxRamBuffer like 0.1MB memory can\n         * easily overflow if we check out some DWPT based on docCount and have\n         * several DWPT in flight indexing large documents (compared to the ram\n         * buffer). This means that those DWPT and their threads will not hit\n         * the stall control before asserting the memory which would in turn\n         * fail. To prevent this we only assert if the the largest document seen\n         * is smaller than the 1/2 of the maxRamBufferMB\n         */\n        assert ram <= expected : \"ram was \" + ram + \" expected: \" + expected\n            + \" flush mem: \" + flushBytes + \" activeMem: \" + activeBytes\n            + \" pendingMem: \" + numPending + \" flushingMem: \"\n            + numFlushingDWPT() + \" blockedMem: \" + numBlockedFlushes()\n            + \" peakDeltaMem: \" + peakDelta;\n      }\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"18e20fa02735869173a20f36b8bfb855be5e5a13","date":1353071141,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","sourceNew":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      final long ramBufferBytes = (long) (maxConfiguredRamBuffer * 1024 * 1024);\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta\n      \n      // 2 * ramBufferBytes -> before we stall we need to cross the 2xRAM Buffer border this is still a valid limit\n      // (numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta) -> those are the total number of DWPT that are not active but not yet fully fluhsed\n      // all of them could theoretically be taken out of the loop once they crossed the RAM buffer and the last document was the peak delta\n      // (numDocsSinceStalled * peakDelta) -> at any given time there could be n threads in flight that crossed the stall control before we reached the limit and each of them could hold a peak document\n      final long expected = (2 * (ramBufferBytes)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta) + (numDocsSinceStalled * peakDelta);\n      // the expected ram consumption is an upper bound at this point and not really the expected consumption\n      if (peakDelta < (ramBufferBytes >> 1)) {\n        /*\n         * if we are indexing with very low maxRamBuffer like 0.1MB memory can\n         * easily overflow if we check out some DWPT based on docCount and have\n         * several DWPT in flight indexing large documents (compared to the ram\n         * buffer). This means that those DWPT and their threads will not hit\n         * the stall control before asserting the memory which would in turn\n         * fail. To prevent this we only assert if the the largest document seen\n         * is smaller than the 1/2 of the maxRamBufferMB\n         */\n        assert ram <= expected : \"actual mem: \" + ram + \" byte, expected mem: \" + expected\n            + \" byte, flush mem: \" + flushBytes + \", active mem: \" + activeBytes\n            + \", pending DWPT: \" + numPending + \", flushing DWPT: \"\n            + numFlushingDWPT() + \", blocked DWPT: \" + numBlockedFlushes()\n            + \", peakDelta mem: \" + peakDelta + \" byte\";\n      }\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      final long ramBufferBytes = (long) (maxConfiguredRamBuffer * 1024 * 1024);\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta\n      \n      // 2 * ramBufferBytes -> before we stall we need to cross the 2xRAM Buffer border this is still a valid limit\n      // (numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta) -> those are the total number of DWPT that are not active but not yet fully fluhsed\n      // all of them could theoretically be taken out of the loop once they crossed the RAM buffer and the last document was the peak delta\n      // (perThreadPool.getActiveThreadState() * peakDelta) -> at any given time there could be n threads in flight that crossed the stall control before we reached the limit and each of them could hold a peak document\n      final long expected = (2 * (ramBufferBytes)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta) + (perThreadPool.getActiveThreadState() * peakDelta);\n      // the expected ram consumption is an upper bound at this point and not really the expected consumption\n      if (peakDelta < (ramBufferBytes >> 1)) {\n        /*\n         * if we are indexing with very low maxRamBuffer like 0.1MB memory can\n         * easily overflow if we check out some DWPT based on docCount and have\n         * several DWPT in flight indexing large documents (compared to the ram\n         * buffer). This means that those DWPT and their threads will not hit\n         * the stall control before asserting the memory which would in turn\n         * fail. To prevent this we only assert if the the largest document seen\n         * is smaller than the 1/2 of the maxRamBufferMB\n         */\n        assert ram <= expected : \"actual mem: \" + ram + \" byte, expected mem: \" + expected\n            + \" byte, flush mem: \" + flushBytes + \", active mem: \" + activeBytes\n            + \", pending DWPT: \" + numPending + \", flushing DWPT: \"\n            + numFlushingDWPT() + \", blocked DWPT: \" + numBlockedFlushes()\n            + \", peakDelta mem: \" + peakDelta + \" byte\";\n      }\n    }\n    return true;\n  }\n\n","bugFix":["f7698eeb1d6d7bff293dff708890f1a4849a45b4"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","sourceNew":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      final long ramBufferBytes = (long) (maxConfiguredRamBuffer * 1024 * 1024);\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta\n      \n      // 2 * ramBufferBytes -> before we stall we need to cross the 2xRAM Buffer border this is still a valid limit\n      // (numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta) -> those are the total number of DWPT that are not active but not yet fully fluhsed\n      // all of them could theoretically be taken out of the loop once they crossed the RAM buffer and the last document was the peak delta\n      // (numDocsSinceStalled * peakDelta) -> at any given time there could be n threads in flight that crossed the stall control before we reached the limit and each of them could hold a peak document\n      final long expected = (2 * (ramBufferBytes)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta) + (numDocsSinceStalled * peakDelta);\n      // the expected ram consumption is an upper bound at this point and not really the expected consumption\n      if (peakDelta < (ramBufferBytes >> 1)) {\n        /*\n         * if we are indexing with very low maxRamBuffer like 0.1MB memory can\n         * easily overflow if we check out some DWPT based on docCount and have\n         * several DWPT in flight indexing large documents (compared to the ram\n         * buffer). This means that those DWPT and their threads will not hit\n         * the stall control before asserting the memory which would in turn\n         * fail. To prevent this we only assert if the the largest document seen\n         * is smaller than the 1/2 of the maxRamBufferMB\n         */\n        assert ram <= expected : \"actual mem: \" + ram + \" byte, expected mem: \" + expected\n            + \" byte, flush mem: \" + flushBytes + \", active mem: \" + activeBytes\n            + \", pending DWPT: \" + numPending + \", flushing DWPT: \"\n            + numFlushingDWPT() + \", blocked DWPT: \" + numBlockedFlushes()\n            + \", peakDelta mem: \" + peakDelta + \" byte\";\n      }\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      final long ramBufferBytes = (long) (maxConfiguredRamBuffer * 1024 * 1024);\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta\n      \n      // 2 * ramBufferBytes -> before we stall we need to cross the 2xRAM Buffer border this is still a valid limit\n      // (numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta) -> those are the total number of DWPT that are not active but not yet fully fluhsed\n      // all of them could theoretically be taken out of the loop once they crossed the RAM buffer and the last document was the peak delta\n      // (perThreadPool.getActiveThreadState() * peakDelta) -> at any given time there could be n threads in flight that crossed the stall control before we reached the limit and each of them could hold a peak document\n      final long expected = (2 * (ramBufferBytes)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta) + (perThreadPool.getActiveThreadState() * peakDelta);\n      // the expected ram consumption is an upper bound at this point and not really the expected consumption\n      if (peakDelta < (ramBufferBytes >> 1)) {\n        /*\n         * if we are indexing with very low maxRamBuffer like 0.1MB memory can\n         * easily overflow if we check out some DWPT based on docCount and have\n         * several DWPT in flight indexing large documents (compared to the ram\n         * buffer). This means that those DWPT and their threads will not hit\n         * the stall control before asserting the memory which would in turn\n         * fail. To prevent this we only assert if the the largest document seen\n         * is smaller than the 1/2 of the maxRamBufferMB\n         */\n        assert ram <= expected : \"actual mem: \" + ram + \" byte, expected mem: \" + expected\n            + \" byte, flush mem: \" + flushBytes + \", active mem: \" + activeBytes\n            + \", pending DWPT: \" + numPending + \", flushing DWPT: \"\n            + numFlushingDWPT() + \", blocked DWPT: \" + numBlockedFlushes()\n            + \", peakDelta mem: \" + peakDelta + \" byte\";\n      }\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b7d69c53c444cbbdbc1cd27e9f51f83b3ed14cb","date":1400265925,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","sourceNew":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    // We can only assert if we have always been flushing by RAM usage; otherwise the assert will false trip if e.g. the\n    // flush-by-doc-count * doc size was large enough to use far more RAM than the sudden change to IWC's maxRAMBufferSizeMB:\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH && flushByRAMWasDisabled == false) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      final long ramBufferBytes = (long) (maxConfiguredRamBuffer * 1024 * 1024);\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta\n      \n      // 2 * ramBufferBytes -> before we stall we need to cross the 2xRAM Buffer border this is still a valid limit\n      // (numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta) -> those are the total number of DWPT that are not active but not yet fully flushed\n      // all of them could theoretically be taken out of the loop once they crossed the RAM buffer and the last document was the peak delta\n      // (numDocsSinceStalled * peakDelta) -> at any given time there could be n threads in flight that crossed the stall control before we reached the limit and each of them could hold a peak document\n      final long expected = (2 * (ramBufferBytes)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta) + (numDocsSinceStalled * peakDelta);\n      // the expected ram consumption is an upper bound at this point and not really the expected consumption\n      if (peakDelta < (ramBufferBytes >> 1)) {\n        /*\n         * if we are indexing with very low maxRamBuffer like 0.1MB memory can\n         * easily overflow if we check out some DWPT based on docCount and have\n         * several DWPT in flight indexing large documents (compared to the ram\n         * buffer). This means that those DWPT and their threads will not hit\n         * the stall control before asserting the memory which would in turn\n         * fail. To prevent this we only assert if the the largest document seen\n         * is smaller than the 1/2 of the maxRamBufferMB\n         */\n        assert ram <= expected : \"actual mem: \" + ram + \" byte, expected mem: \" + expected\n            + \" byte, flush mem: \" + flushBytes + \", active mem: \" + activeBytes\n            + \", pending DWPT: \" + numPending + \", flushing DWPT: \"\n            + numFlushingDWPT() + \", blocked DWPT: \" + numBlockedFlushes()\n            + \", peakDelta mem: \" + peakDelta + \" bytes, ramBufferBytes=\" + ramBufferBytes\n            + \", maxConfiguredRamBuffer=\" + maxConfiguredRamBuffer;\n      }\n    } else {\n      flushByRAMWasDisabled = true;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      final long ramBufferBytes = (long) (maxConfiguredRamBuffer * 1024 * 1024);\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta\n      \n      // 2 * ramBufferBytes -> before we stall we need to cross the 2xRAM Buffer border this is still a valid limit\n      // (numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta) -> those are the total number of DWPT that are not active but not yet fully fluhsed\n      // all of them could theoretically be taken out of the loop once they crossed the RAM buffer and the last document was the peak delta\n      // (numDocsSinceStalled * peakDelta) -> at any given time there could be n threads in flight that crossed the stall control before we reached the limit and each of them could hold a peak document\n      final long expected = (2 * (ramBufferBytes)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta) + (numDocsSinceStalled * peakDelta);\n      // the expected ram consumption is an upper bound at this point and not really the expected consumption\n      if (peakDelta < (ramBufferBytes >> 1)) {\n        /*\n         * if we are indexing with very low maxRamBuffer like 0.1MB memory can\n         * easily overflow if we check out some DWPT based on docCount and have\n         * several DWPT in flight indexing large documents (compared to the ram\n         * buffer). This means that those DWPT and their threads will not hit\n         * the stall control before asserting the memory which would in turn\n         * fail. To prevent this we only assert if the the largest document seen\n         * is smaller than the 1/2 of the maxRamBufferMB\n         */\n        assert ram <= expected : \"actual mem: \" + ram + \" byte, expected mem: \" + expected\n            + \" byte, flush mem: \" + flushBytes + \", active mem: \" + activeBytes\n            + \", pending DWPT: \" + numPending + \", flushing DWPT: \"\n            + numFlushingDWPT() + \", blocked DWPT: \" + numBlockedFlushes()\n            + \", peakDelta mem: \" + peakDelta + \" byte\";\n      }\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","sourceNew":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    // We can only assert if we have always been flushing by RAM usage; otherwise the assert will false trip if e.g. the\n    // flush-by-doc-count * doc size was large enough to use far more RAM than the sudden change to IWC's maxRAMBufferSizeMB:\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH && flushByRAMWasDisabled == false) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      final long ramBufferBytes = (long) (maxConfiguredRamBuffer * 1024 * 1024);\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta\n      \n      // 2 * ramBufferBytes -> before we stall we need to cross the 2xRAM Buffer border this is still a valid limit\n      // (numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta) -> those are the total number of DWPT that are not active but not yet fully flushed\n      // all of them could theoretically be taken out of the loop once they crossed the RAM buffer and the last document was the peak delta\n      // (numDocsSinceStalled * peakDelta) -> at any given time there could be n threads in flight that crossed the stall control before we reached the limit and each of them could hold a peak document\n      final long expected = (2 * (ramBufferBytes)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta) + (numDocsSinceStalled * peakDelta);\n      // the expected ram consumption is an upper bound at this point and not really the expected consumption\n      if (peakDelta < (ramBufferBytes >> 1)) {\n        /*\n         * if we are indexing with very low maxRamBuffer like 0.1MB memory can\n         * easily overflow if we check out some DWPT based on docCount and have\n         * several DWPT in flight indexing large documents (compared to the ram\n         * buffer). This means that those DWPT and their threads will not hit\n         * the stall control before asserting the memory which would in turn\n         * fail. To prevent this we only assert if the the largest document seen\n         * is smaller than the 1/2 of the maxRamBufferMB\n         */\n        assert ram <= expected : \"actual mem: \" + ram + \" byte, expected mem: \" + expected\n            + \" byte, flush mem: \" + flushBytes + \", active mem: \" + activeBytes\n            + \", pending DWPT: \" + numPending + \", flushing DWPT: \"\n            + numFlushingDWPT() + \", blocked DWPT: \" + numBlockedFlushes()\n            + \", peakDelta mem: \" + peakDelta + \" bytes, ramBufferBytes=\" + ramBufferBytes\n            + \", maxConfiguredRamBuffer=\" + maxConfiguredRamBuffer;\n      }\n    } else {\n      flushByRAMWasDisabled = true;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      final long ramBufferBytes = (long) (maxConfiguredRamBuffer * 1024 * 1024);\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta\n      \n      // 2 * ramBufferBytes -> before we stall we need to cross the 2xRAM Buffer border this is still a valid limit\n      // (numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta) -> those are the total number of DWPT that are not active but not yet fully fluhsed\n      // all of them could theoretically be taken out of the loop once they crossed the RAM buffer and the last document was the peak delta\n      // (numDocsSinceStalled * peakDelta) -> at any given time there could be n threads in flight that crossed the stall control before we reached the limit and each of them could hold a peak document\n      final long expected = (2 * (ramBufferBytes)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta) + (numDocsSinceStalled * peakDelta);\n      // the expected ram consumption is an upper bound at this point and not really the expected consumption\n      if (peakDelta < (ramBufferBytes >> 1)) {\n        /*\n         * if we are indexing with very low maxRamBuffer like 0.1MB memory can\n         * easily overflow if we check out some DWPT based on docCount and have\n         * several DWPT in flight indexing large documents (compared to the ram\n         * buffer). This means that those DWPT and their threads will not hit\n         * the stall control before asserting the memory which would in turn\n         * fail. To prevent this we only assert if the the largest document seen\n         * is smaller than the 1/2 of the maxRamBufferMB\n         */\n        assert ram <= expected : \"actual mem: \" + ram + \" byte, expected mem: \" + expected\n            + \" byte, flush mem: \" + flushBytes + \", active mem: \" + activeBytes\n            + \", pending DWPT: \" + numPending + \", flushing DWPT: \"\n            + numFlushingDWPT() + \", blocked DWPT: \" + numBlockedFlushes()\n            + \", peakDelta mem: \" + peakDelta + \" byte\";\n      }\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c02b804ab16489b95429791a2d8fb0e0728354d4","date":1436551798,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","sourceNew":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    // We can only assert if we have always been flushing by RAM usage; otherwise the assert will false trip if e.g. the\n    // flush-by-doc-count * doc size was large enough to use far more RAM than the sudden change to IWC's maxRAMBufferSizeMB:\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH && flushByRAMWasDisabled == false) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      final long ramBufferBytes = (long) (maxConfiguredRamBuffer * 1024 * 1024);\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta\n      \n      // 2 * ramBufferBytes -> before we stall we need to cross the 2xRAM Buffer border this is still a valid limit\n      // (numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta) -> those are the total number of DWPT that are not active but not yet fully flushed\n      // all of them could theoretically be taken out of the loop once they crossed the RAM buffer and the last document was the peak delta\n      // (numDocsSinceStalled * peakDelta) -> at any given time there could be n threads in flight that crossed the stall control before we reached the limit and each of them could hold a peak document\n      final long expected = (2 * ramBufferBytes) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta) + (numDocsSinceStalled * peakDelta);\n      // the expected ram consumption is an upper bound at this point and not really the expected consumption\n      if (peakDelta < (ramBufferBytes >> 1)) {\n        /*\n         * if we are indexing with very low maxRamBuffer like 0.1MB memory can\n         * easily overflow if we check out some DWPT based on docCount and have\n         * several DWPT in flight indexing large documents (compared to the ram\n         * buffer). This means that those DWPT and their threads will not hit\n         * the stall control before asserting the memory which would in turn\n         * fail. To prevent this we only assert if the the largest document seen\n         * is smaller than the 1/2 of the maxRamBufferMB\n         */\n        assert ram <= expected : \"actual mem: \" + ram + \" byte, expected mem: \" + expected\n            + \" byte, flush mem: \" + flushBytes + \", active mem: \" + activeBytes\n            + \", pending DWPT: \" + numPending + \", flushing DWPT: \"\n            + numFlushingDWPT() + \", blocked DWPT: \" + numBlockedFlushes()\n            + \", peakDelta mem: \" + peakDelta + \" bytes, ramBufferBytes=\" + ramBufferBytes\n            + \", maxConfiguredRamBuffer=\" + maxConfiguredRamBuffer;\n      }\n    } else {\n      flushByRAMWasDisabled = true;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    // We can only assert if we have always been flushing by RAM usage; otherwise the assert will false trip if e.g. the\n    // flush-by-doc-count * doc size was large enough to use far more RAM than the sudden change to IWC's maxRAMBufferSizeMB:\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH && flushByRAMWasDisabled == false) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      final long ramBufferBytes = (long) (maxConfiguredRamBuffer * 1024 * 1024);\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta\n      \n      // 2 * ramBufferBytes -> before we stall we need to cross the 2xRAM Buffer border this is still a valid limit\n      // (numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta) -> those are the total number of DWPT that are not active but not yet fully flushed\n      // all of them could theoretically be taken out of the loop once they crossed the RAM buffer and the last document was the peak delta\n      // (numDocsSinceStalled * peakDelta) -> at any given time there could be n threads in flight that crossed the stall control before we reached the limit and each of them could hold a peak document\n      final long expected = (2 * (ramBufferBytes)) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta) + (numDocsSinceStalled * peakDelta);\n      // the expected ram consumption is an upper bound at this point and not really the expected consumption\n      if (peakDelta < (ramBufferBytes >> 1)) {\n        /*\n         * if we are indexing with very low maxRamBuffer like 0.1MB memory can\n         * easily overflow if we check out some DWPT based on docCount and have\n         * several DWPT in flight indexing large documents (compared to the ram\n         * buffer). This means that those DWPT and their threads will not hit\n         * the stall control before asserting the memory which would in turn\n         * fail. To prevent this we only assert if the the largest document seen\n         * is smaller than the 1/2 of the maxRamBufferMB\n         */\n        assert ram <= expected : \"actual mem: \" + ram + \" byte, expected mem: \" + expected\n            + \" byte, flush mem: \" + flushBytes + \", active mem: \" + activeBytes\n            + \", pending DWPT: \" + numPending + \", flushing DWPT: \"\n            + numFlushingDWPT() + \", blocked DWPT: \" + numBlockedFlushes()\n            + \", peakDelta mem: \" + peakDelta + \" bytes, ramBufferBytes=\" + ramBufferBytes\n            + \", maxConfiguredRamBuffer=\" + maxConfiguredRamBuffer;\n      }\n    } else {\n      flushByRAMWasDisabled = true;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3570e776df3671c1bce4f54b07bf03ca5a2c23de","date":1593033351,"type":3,"author":"Mike Drob","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#assertMemory().mjava","sourceNew":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    // We can only assert if we have always been flushing by RAM usage; otherwise the assert will false trip if e.g. the\n    // flush-by-doc-count * doc size was large enough to use far more RAM than the sudden change to IWC's maxRAMBufferSizeMB:\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH && flushByRAMWasDisabled == false) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      final long ramBufferBytes = (long) (maxConfiguredRamBuffer * 1024 * 1024);\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta\n      \n      // 2 * ramBufferBytes -> before we stall we need to cross the 2xRAM Buffer border this is still a valid limit\n      // (numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta) -> those are the total number of DWPT that are not active but not yet fully flushed\n      // all of them could theoretically be taken out of the loop once they crossed the RAM buffer and the last document was the peak delta\n      // (numDocsSinceStalled * peakDelta) -> at any given time there could be n threads in flight that crossed the stall control before we reached the limit and each of them could hold a peak document\n      final long expected = (2 * ramBufferBytes) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta) + (numDocsSinceStalled * peakDelta);\n      // the expected ram consumption is an upper bound at this point and not really the expected consumption\n      if (peakDelta < (ramBufferBytes >> 1)) {\n        /*\n         * if we are indexing with very low maxRamBuffer like 0.1MB memory can\n         * easily overflow if we check out some DWPT based on docCount and have\n         * several DWPT in flight indexing large documents (compared to the ram\n         * buffer). This means that those DWPT and their threads will not hit\n         * the stall control before asserting the memory which would in turn\n         * fail. To prevent this we only assert if the largest document seen\n         * is smaller than the 1/2 of the maxRamBufferMB\n         */\n        assert ram <= expected : \"actual mem: \" + ram + \" byte, expected mem: \" + expected\n            + \" byte, flush mem: \" + flushBytes + \", active mem: \" + activeBytes\n            + \", pending DWPT: \" + numPending + \", flushing DWPT: \"\n            + numFlushingDWPT() + \", blocked DWPT: \" + numBlockedFlushes()\n            + \", peakDelta mem: \" + peakDelta + \" bytes, ramBufferBytes=\" + ramBufferBytes\n            + \", maxConfiguredRamBuffer=\" + maxConfiguredRamBuffer;\n      }\n    } else {\n      flushByRAMWasDisabled = true;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean assertMemory() {\n    final double maxRamMB = config.getRAMBufferSizeMB();\n    // We can only assert if we have always been flushing by RAM usage; otherwise the assert will false trip if e.g. the\n    // flush-by-doc-count * doc size was large enough to use far more RAM than the sudden change to IWC's maxRAMBufferSizeMB:\n    if (maxRamMB != IndexWriterConfig.DISABLE_AUTO_FLUSH && flushByRAMWasDisabled == false) {\n      // for this assert we must be tolerant to ram buffer changes!\n      maxConfiguredRamBuffer = Math.max(maxRamMB, maxConfiguredRamBuffer);\n      final long ram = flushBytes + activeBytes;\n      final long ramBufferBytes = (long) (maxConfiguredRamBuffer * 1024 * 1024);\n      // take peakDelta into account - worst case is that all flushing, pending and blocked DWPT had maxMem and the last doc had the peakDelta\n      \n      // 2 * ramBufferBytes -> before we stall we need to cross the 2xRAM Buffer border this is still a valid limit\n      // (numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta) -> those are the total number of DWPT that are not active but not yet fully flushed\n      // all of them could theoretically be taken out of the loop once they crossed the RAM buffer and the last document was the peak delta\n      // (numDocsSinceStalled * peakDelta) -> at any given time there could be n threads in flight that crossed the stall control before we reached the limit and each of them could hold a peak document\n      final long expected = (2 * ramBufferBytes) + ((numPending + numFlushingDWPT() + numBlockedFlushes()) * peakDelta) + (numDocsSinceStalled * peakDelta);\n      // the expected ram consumption is an upper bound at this point and not really the expected consumption\n      if (peakDelta < (ramBufferBytes >> 1)) {\n        /*\n         * if we are indexing with very low maxRamBuffer like 0.1MB memory can\n         * easily overflow if we check out some DWPT based on docCount and have\n         * several DWPT in flight indexing large documents (compared to the ram\n         * buffer). This means that those DWPT and their threads will not hit\n         * the stall control before asserting the memory which would in turn\n         * fail. To prevent this we only assert if the the largest document seen\n         * is smaller than the 1/2 of the maxRamBufferMB\n         */\n        assert ram <= expected : \"actual mem: \" + ram + \" byte, expected mem: \" + expected\n            + \" byte, flush mem: \" + flushBytes + \", active mem: \" + activeBytes\n            + \", pending DWPT: \" + numPending + \", flushing DWPT: \"\n            + numFlushingDWPT() + \", blocked DWPT: \" + numBlockedFlushes()\n            + \", peakDelta mem: \" + peakDelta + \" bytes, ramBufferBytes=\" + ramBufferBytes\n            + \", maxConfiguredRamBuffer=\" + maxConfiguredRamBuffer;\n      }\n    } else {\n      flushByRAMWasDisabled = true;\n    }\n    return true;\n  }\n\n","bugFix":["73f7144b3d593d06882d826ef9e09bd8a1b75614"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3570e776df3671c1bce4f54b07bf03ca5a2c23de":["c02b804ab16489b95429791a2d8fb0e0728354d4"],"62e52115b56781006682fd92c6938efaf174304d":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","f7698eeb1d6d7bff293dff708890f1a4849a45b4"],"18e20fa02735869173a20f36b8bfb855be5e5a13":["f7698eeb1d6d7bff293dff708890f1a4849a45b4"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f7698eeb1d6d7bff293dff708890f1a4849a45b4":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["f7698eeb1d6d7bff293dff708890f1a4849a45b4","18e20fa02735869173a20f36b8bfb855be5e5a13"],"56572ec06f1407c066d6b7399413178b33176cd8":["18e20fa02735869173a20f36b8bfb855be5e5a13","5b7d69c53c444cbbdbc1cd27e9f51f83b3ed14cb"],"5b7d69c53c444cbbdbc1cd27e9f51f83b3ed14cb":["18e20fa02735869173a20f36b8bfb855be5e5a13"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3570e776df3671c1bce4f54b07bf03ca5a2c23de"],"c02b804ab16489b95429791a2d8fb0e0728354d4":["5b7d69c53c444cbbdbc1cd27e9f51f83b3ed14cb"]},"commit2Childs":{"3570e776df3671c1bce4f54b07bf03ca5a2c23de":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"62e52115b56781006682fd92c6938efaf174304d":[],"18e20fa02735869173a20f36b8bfb855be5e5a13":["407687e67faf6e1f02a211ca078d8e3eed631027","56572ec06f1407c066d6b7399413178b33176cd8","5b7d69c53c444cbbdbc1cd27e9f51f83b3ed14cb"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["62e52115b56781006682fd92c6938efaf174304d","f7698eeb1d6d7bff293dff708890f1a4849a45b4"],"f7698eeb1d6d7bff293dff708890f1a4849a45b4":["62e52115b56781006682fd92c6938efaf174304d","18e20fa02735869173a20f36b8bfb855be5e5a13","407687e67faf6e1f02a211ca078d8e3eed631027"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"56572ec06f1407c066d6b7399413178b33176cd8":[],"5b7d69c53c444cbbdbc1cd27e9f51f83b3ed14cb":["56572ec06f1407c066d6b7399413178b33176cd8","c02b804ab16489b95429791a2d8fb0e0728354d4"],"c02b804ab16489b95429791a2d8fb0e0728354d4":["3570e776df3671c1bce4f54b07bf03ca5a2c23de"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["62e52115b56781006682fd92c6938efaf174304d","407687e67faf6e1f02a211ca078d8e3eed631027","56572ec06f1407c066d6b7399413178b33176cd8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}