{"path":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers.ScheduledTrigger#run().mjava","commits":[{"id":"009caa80830ac6369c42e5f6515405d686eabfee","date":1494487120,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers.ScheduledTrigger#run().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public void run() {\n      // fire a trigger only if an action is not pending\n      // note this is not fool proof e.g. it does not prevent an action being executed while a trigger\n      // is still executing. There is additional protection against that scenario in the event listener.\n      if (!hasPendingActions.get())  {\n        try {\n          trigger.run();\n        } catch (Exception e) {\n          // log but do not propagate exception because an exception thrown from a scheduled operation\n          // will suppress future executions\n          log.error(\"Unexpected execution from trigger: \" + trigger.getName(), e);\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"464244264804e3f981bf1fb4b732516d8d62dbc2","date":1495736161,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers.ScheduledTrigger#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers.ScheduledTrigger#run().mjava","sourceNew":"    @Override\n    public void run() {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTrigger \" + trigger.getName() + \" has been closed.\");\n      }\n      // fire a trigger only if an action is not pending\n      // note this is not fool proof e.g. it does not prevent an action being executed while a trigger\n      // is still executing. There is additional protection against that scenario in the event listener.\n      if (!hasPendingActions.get())  {\n        // replay accumulated events on first run, if any\n        if (replay) {\n          TriggerEvent event;\n          // peek first without removing - we may crash before calling the listener\n          while ((event = queue.peekEvent()) != null) {\n            // override REPLAYING=true\n            event.getProperties().put(TriggerEvent.REPLAYING, true);\n            if (! trigger.getListener().triggerFired(event)) {\n              log.error(\"Failed to re-play event, discarding: \" + event);\n            }\n            queue.pollEvent(); // always remove it from queue\n          }\n          // now restore saved state to possibly generate new events from old state on the first run\n          try {\n            trigger.restoreState();\n          } catch (Exception e) {\n            // log but don't throw - see below\n            log.error(\"Error restoring trigger state \" + trigger.getName(), e);\n          }\n          replay = false;\n        }\n        try {\n          trigger.run();\n        } catch (Exception e) {\n          // log but do not propagate exception because an exception thrown from a scheduled operation\n          // will suppress future executions\n          log.error(\"Unexpected execution from trigger: \" + trigger.getName(), e);\n        } finally {\n          // checkpoint after each run\n          trigger.saveState();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // fire a trigger only if an action is not pending\n      // note this is not fool proof e.g. it does not prevent an action being executed while a trigger\n      // is still executing. There is additional protection against that scenario in the event listener.\n      if (!hasPendingActions.get())  {\n        try {\n          trigger.run();\n        } catch (Exception e) {\n          // log but do not propagate exception because an exception thrown from a scheduled operation\n          // will suppress future executions\n          log.error(\"Unexpected execution from trigger: \" + trigger.getName(), e);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5531f16a602ef350b6c9adfb08ebaa13a60fe3db","date":1495756318,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers.ScheduledTrigger#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers.ScheduledTrigger#run().mjava","sourceNew":"    @Override\n    public void run() {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTrigger \" + trigger.getName() + \" has been closed.\");\n      }\n      // fire a trigger only if an action is not pending\n      // note this is not fool proof e.g. it does not prevent an action being executed while a trigger\n      // is still executing. There is additional protection against that scenario in the event listener.\n      if (!hasPendingActions.get())  {\n        // replay accumulated events on first run, if any\n        if (replay) {\n          TriggerEvent event;\n          // peek first without removing - we may crash before calling the listener\n          while ((event = queue.peekEvent()) != null) {\n            // override REPLAYING=true\n            event.getProperties().put(TriggerEvent.REPLAYING, true);\n            if (! trigger.getListener().triggerFired(event)) {\n              log.error(\"Failed to re-play event, discarding: \" + event);\n            }\n            queue.pollEvent(); // always remove it from queue\n          }\n          // now restore saved state to possibly generate new events from old state on the first run\n          try {\n            trigger.restoreState();\n          } catch (Exception e) {\n            // log but don't throw - see below\n            log.error(\"Error restoring trigger state \" + trigger.getName(), e);\n          }\n          replay = false;\n        }\n        try {\n          trigger.run();\n        } catch (Exception e) {\n          // log but do not propagate exception because an exception thrown from a scheduled operation\n          // will suppress future executions\n          log.error(\"Unexpected execution from trigger: \" + trigger.getName(), e);\n        } finally {\n          // checkpoint after each run\n          trigger.saveState();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // fire a trigger only if an action is not pending\n      // note this is not fool proof e.g. it does not prevent an action being executed while a trigger\n      // is still executing. There is additional protection against that scenario in the event listener.\n      if (!hasPendingActions.get())  {\n        try {\n          trigger.run();\n        } catch (Exception e) {\n          // log but do not propagate exception because an exception thrown from a scheduled operation\n          // will suppress future executions\n          log.error(\"Unexpected execution from trigger: \" + trigger.getName(), e);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c5fd294da67452cd8d116692194908de00eb5209","date":1499704155,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers.ScheduledTrigger#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers.ScheduledTrigger#run().mjava","sourceNew":"    @Override\n    public void run() {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTrigger \" + trigger.getName() + \" has been closed.\");\n      }\n      // fire a trigger only if an action is not pending\n      // note this is not fool proof e.g. it does not prevent an action being executed while a trigger\n      // is still executing. There is additional protection against that scenario in the event listener.\n      if (!hasPendingActions.get())  {\n        // replay accumulated events on first run, if any\n        if (replay) {\n          TriggerEvent event;\n          // peek first without removing - we may crash before calling the listener\n          while ((event = queue.peekEvent()) != null) {\n            // override REPLAYING=true\n            event.getProperties().put(TriggerEvent.REPLAYING, true);\n            if (! trigger.getProcessor().process(event)) {\n              log.error(\"Failed to re-play event, discarding: \" + event);\n            }\n            queue.pollEvent(); // always remove it from queue\n          }\n          // now restore saved state to possibly generate new events from old state on the first run\n          try {\n            trigger.restoreState();\n          } catch (Exception e) {\n            // log but don't throw - see below\n            log.error(\"Error restoring trigger state \" + trigger.getName(), e);\n          }\n          replay = false;\n        }\n        try {\n          trigger.run();\n        } catch (Exception e) {\n          // log but do not propagate exception because an exception thrown from a scheduled operation\n          // will suppress future executions\n          log.error(\"Unexpected execution from trigger: \" + trigger.getName(), e);\n        } finally {\n          // checkpoint after each run\n          trigger.saveState();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTrigger \" + trigger.getName() + \" has been closed.\");\n      }\n      // fire a trigger only if an action is not pending\n      // note this is not fool proof e.g. it does not prevent an action being executed while a trigger\n      // is still executing. There is additional protection against that scenario in the event listener.\n      if (!hasPendingActions.get())  {\n        // replay accumulated events on first run, if any\n        if (replay) {\n          TriggerEvent event;\n          // peek first without removing - we may crash before calling the listener\n          while ((event = queue.peekEvent()) != null) {\n            // override REPLAYING=true\n            event.getProperties().put(TriggerEvent.REPLAYING, true);\n            if (! trigger.getListener().triggerFired(event)) {\n              log.error(\"Failed to re-play event, discarding: \" + event);\n            }\n            queue.pollEvent(); // always remove it from queue\n          }\n          // now restore saved state to possibly generate new events from old state on the first run\n          try {\n            trigger.restoreState();\n          } catch (Exception e) {\n            // log but don't throw - see below\n            log.error(\"Error restoring trigger state \" + trigger.getName(), e);\n          }\n          replay = false;\n        }\n        try {\n          trigger.run();\n        } catch (Exception e) {\n          // log but do not propagate exception because an exception thrown from a scheduled operation\n          // will suppress future executions\n          log.error(\"Unexpected execution from trigger: \" + trigger.getName(), e);\n        } finally {\n          // checkpoint after each run\n          trigger.saveState();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2366044456b379068d7b2f3d88a2ebcc3bbf8831","date":1500017643,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers.ScheduledTrigger#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers.ScheduledTrigger#run().mjava","sourceNew":"    @Override\n    public void run() {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTrigger \" + trigger.getName() + \" has been closed.\");\n      }\n      // fire a trigger only if an action is not pending\n      // note this is not fool proof e.g. it does not prevent an action being executed while a trigger\n      // is still executing. There is additional protection against that scenario in the event listener.\n      if (!hasPendingActions.get())  {\n        // replay accumulated events on first run, if any\n        if (replay) {\n          TriggerEvent event;\n          // peek first without removing - we may crash before calling the listener\n          while ((event = queue.peekEvent()) != null) {\n            // override REPLAYING=true\n            event.getProperties().put(TriggerEvent.REPLAYING, true);\n            if (! trigger.getProcessor().process(event)) {\n              log.error(\"Failed to re-play event, discarding: \" + event);\n            }\n            queue.pollEvent(); // always remove it from queue\n          }\n          // now restore saved state to possibly generate new events from old state on the first run\n          try {\n            trigger.restoreState();\n          } catch (Exception e) {\n            // log but don't throw - see below\n            log.error(\"Error restoring trigger state \" + trigger.getName(), e);\n          }\n          replay = false;\n        }\n        try {\n          trigger.run();\n        } catch (Exception e) {\n          // log but do not propagate exception because an exception thrown from a scheduled operation\n          // will suppress future executions\n          log.error(\"Unexpected exception from trigger: \" + trigger.getName(), e);\n        } finally {\n          // checkpoint after each run\n          trigger.saveState();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTrigger \" + trigger.getName() + \" has been closed.\");\n      }\n      // fire a trigger only if an action is not pending\n      // note this is not fool proof e.g. it does not prevent an action being executed while a trigger\n      // is still executing. There is additional protection against that scenario in the event listener.\n      if (!hasPendingActions.get())  {\n        // replay accumulated events on first run, if any\n        if (replay) {\n          TriggerEvent event;\n          // peek first without removing - we may crash before calling the listener\n          while ((event = queue.peekEvent()) != null) {\n            // override REPLAYING=true\n            event.getProperties().put(TriggerEvent.REPLAYING, true);\n            if (! trigger.getProcessor().process(event)) {\n              log.error(\"Failed to re-play event, discarding: \" + event);\n            }\n            queue.pollEvent(); // always remove it from queue\n          }\n          // now restore saved state to possibly generate new events from old state on the first run\n          try {\n            trigger.restoreState();\n          } catch (Exception e) {\n            // log but don't throw - see below\n            log.error(\"Error restoring trigger state \" + trigger.getName(), e);\n          }\n          replay = false;\n        }\n        try {\n          trigger.run();\n        } catch (Exception e) {\n          // log but do not propagate exception because an exception thrown from a scheduled operation\n          // will suppress future executions\n          log.error(\"Unexpected execution from trigger: \" + trigger.getName(), e);\n        } finally {\n          // checkpoint after each run\n          trigger.saveState();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2db92e6e82ec303a2d386048fd103cdb3ae4a806","date":1500018439,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers.ScheduledTrigger#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers.ScheduledTrigger#run().mjava","sourceNew":"    @Override\n    public void run() {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTrigger \" + trigger.getName() + \" has been closed.\");\n      }\n      // fire a trigger only if an action is not pending\n      // note this is not fool proof e.g. it does not prevent an action being executed while a trigger\n      // is still executing. There is additional protection against that scenario in the event listener.\n      if (!hasPendingActions.get())  {\n        // replay accumulated events on first run, if any\n        if (replay) {\n          TriggerEvent event;\n          // peek first without removing - we may crash before calling the listener\n          while ((event = queue.peekEvent()) != null) {\n            // override REPLAYING=true\n            event.getProperties().put(TriggerEvent.REPLAYING, true);\n            if (! trigger.getProcessor().process(event)) {\n              log.error(\"Failed to re-play event, discarding: \" + event);\n            }\n            queue.pollEvent(); // always remove it from queue\n          }\n          // now restore saved state to possibly generate new events from old state on the first run\n          try {\n            trigger.restoreState();\n          } catch (Exception e) {\n            // log but don't throw - see below\n            log.error(\"Error restoring trigger state \" + trigger.getName(), e);\n          }\n          replay = false;\n        }\n        try {\n          trigger.run();\n        } catch (Exception e) {\n          // log but do not propagate exception because an exception thrown from a scheduled operation\n          // will suppress future executions\n          log.error(\"Unexpected exception from trigger: \" + trigger.getName(), e);\n        } finally {\n          // checkpoint after each run\n          trigger.saveState();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTrigger \" + trigger.getName() + \" has been closed.\");\n      }\n      // fire a trigger only if an action is not pending\n      // note this is not fool proof e.g. it does not prevent an action being executed while a trigger\n      // is still executing. There is additional protection against that scenario in the event listener.\n      if (!hasPendingActions.get())  {\n        // replay accumulated events on first run, if any\n        if (replay) {\n          TriggerEvent event;\n          // peek first without removing - we may crash before calling the listener\n          while ((event = queue.peekEvent()) != null) {\n            // override REPLAYING=true\n            event.getProperties().put(TriggerEvent.REPLAYING, true);\n            if (! trigger.getProcessor().process(event)) {\n              log.error(\"Failed to re-play event, discarding: \" + event);\n            }\n            queue.pollEvent(); // always remove it from queue\n          }\n          // now restore saved state to possibly generate new events from old state on the first run\n          try {\n            trigger.restoreState();\n          } catch (Exception e) {\n            // log but don't throw - see below\n            log.error(\"Error restoring trigger state \" + trigger.getName(), e);\n          }\n          replay = false;\n        }\n        try {\n          trigger.run();\n        } catch (Exception e) {\n          // log but do not propagate exception because an exception thrown from a scheduled operation\n          // will suppress future executions\n          log.error(\"Unexpected execution from trigger: \" + trigger.getName(), e);\n        } finally {\n          // checkpoint after each run\n          trigger.saveState();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c304e97e7c1d472bc70e801b35ee78583916c6cd","date":1507105431,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers.ScheduledTrigger#run().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public void run() {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTrigger \" + trigger.getName() + \" has been closed.\");\n      }\n      // fire a trigger only if an action is not pending\n      // note this is not fool proof e.g. it does not prevent an action being executed while a trigger\n      // is still executing. There is additional protection against that scenario in the event listener.\n      if (!hasPendingActions.get())  {\n        // replay accumulated events on first run, if any\n        if (replay) {\n          TriggerEvent event;\n          // peek first without removing - we may crash before calling the listener\n          while ((event = queue.peekEvent()) != null) {\n            // override REPLAYING=true\n            event.getProperties().put(TriggerEvent.REPLAYING, true);\n            if (! trigger.getProcessor().process(event)) {\n              log.error(\"Failed to re-play event, discarding: \" + event);\n            }\n            queue.pollEvent(); // always remove it from queue\n          }\n          // now restore saved state to possibly generate new events from old state on the first run\n          try {\n            trigger.restoreState();\n          } catch (Exception e) {\n            // log but don't throw - see below\n            log.error(\"Error restoring trigger state \" + trigger.getName(), e);\n          }\n          replay = false;\n        }\n        try {\n          trigger.run();\n        } catch (Exception e) {\n          // log but do not propagate exception because an exception thrown from a scheduled operation\n          // will suppress future executions\n          log.error(\"Unexpected exception from trigger: \" + trigger.getName(), e);\n        } finally {\n          // checkpoint after each run\n          trigger.saveState();\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"560c18d71dad43d675158783c3840f8c80d6d39c","date":1507105532,"type":0,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers.ScheduledTrigger#run().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public void run() {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTrigger \" + trigger.getName() + \" has been closed.\");\n      }\n      // fire a trigger only if an action is not pending\n      // note this is not fool proof e.g. it does not prevent an action being executed while a trigger\n      // is still executing. There is additional protection against that scenario in the event listener.\n      if (!hasPendingActions.get())  {\n        // replay accumulated events on first run, if any\n        if (replay) {\n          TriggerEvent event;\n          // peek first without removing - we may crash before calling the listener\n          while ((event = queue.peekEvent()) != null) {\n            // override REPLAYING=true\n            event.getProperties().put(TriggerEvent.REPLAYING, true);\n            if (! trigger.getProcessor().process(event)) {\n              log.error(\"Failed to re-play event, discarding: \" + event);\n            }\n            queue.pollEvent(); // always remove it from queue\n          }\n          // now restore saved state to possibly generate new events from old state on the first run\n          try {\n            trigger.restoreState();\n          } catch (Exception e) {\n            // log but don't throw - see below\n            log.error(\"Error restoring trigger state \" + trigger.getName(), e);\n          }\n          replay = false;\n        }\n        try {\n          trigger.run();\n        } catch (Exception e) {\n          // log but do not propagate exception because an exception thrown from a scheduled operation\n          // will suppress future executions\n          log.error(\"Unexpected exception from trigger: \" + trigger.getName(), e);\n        } finally {\n          // checkpoint after each run\n          trigger.saveState();\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15ba547dfc0dd0b670e678cb3db8e5d27c694420","date":1511865512,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers.ScheduledTrigger#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers.ScheduledTrigger#run().mjava","sourceNew":"    @Override\n    public void run() {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTrigger \" + trigger.getName() + \" has been closed.\");\n      }\n      // fire a trigger only if an action is not pending\n      // note this is not fool proof e.g. it does not prevent an action being executed while a trigger\n      // is still executing. There is additional protection against that scenario in the event listener.\n      if (!hasPendingActions.get())  {\n        // this synchronization is usually never under contention\n        // but the only reason to have it here is to ensure that when the set-properties API is used\n        // to change the schedule delay, we can safely cancel the old scheduled task\n        // and create another one with the new delay without worrying about concurrent\n        // execution of the same trigger instance\n        synchronized (ScheduledTrigger.this) {\n          // replay accumulated events on first run, if any\n          if (replay) {\n            TriggerEvent event;\n            // peek first without removing - we may crash before calling the listener\n            while ((event = queue.peekEvent()) != null) {\n              // override REPLAYING=true\n              event.getProperties().put(TriggerEvent.REPLAYING, true);\n              if (! trigger.getProcessor().process(event)) {\n                log.error(\"Failed to re-play event, discarding: \" + event);\n              }\n              queue.pollEvent(); // always remove it from queue\n            }\n            // now restore saved state to possibly generate new events from old state on the first run\n            try {\n              trigger.restoreState();\n            } catch (Exception e) {\n              // log but don't throw - see below\n              log.error(\"Error restoring trigger state \" + trigger.getName(), e);\n            }\n            replay = false;\n          }\n          try {\n            trigger.run();\n          } catch (Exception e) {\n            // log but do not propagate exception because an exception thrown from a scheduled operation\n            // will suppress future executions\n            log.error(\"Unexpected exception from trigger: \" + trigger.getName(), e);\n          } finally {\n            // checkpoint after each run\n            trigger.saveState();\n          }\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTrigger \" + trigger.getName() + \" has been closed.\");\n      }\n      // fire a trigger only if an action is not pending\n      // note this is not fool proof e.g. it does not prevent an action being executed while a trigger\n      // is still executing. There is additional protection against that scenario in the event listener.\n      if (!hasPendingActions.get())  {\n        // replay accumulated events on first run, if any\n        if (replay) {\n          TriggerEvent event;\n          // peek first without removing - we may crash before calling the listener\n          while ((event = queue.peekEvent()) != null) {\n            // override REPLAYING=true\n            event.getProperties().put(TriggerEvent.REPLAYING, true);\n            if (! trigger.getProcessor().process(event)) {\n              log.error(\"Failed to re-play event, discarding: \" + event);\n            }\n            queue.pollEvent(); // always remove it from queue\n          }\n          // now restore saved state to possibly generate new events from old state on the first run\n          try {\n            trigger.restoreState();\n          } catch (Exception e) {\n            // log but don't throw - see below\n            log.error(\"Error restoring trigger state \" + trigger.getName(), e);\n          }\n          replay = false;\n        }\n        try {\n          trigger.run();\n        } catch (Exception e) {\n          // log but do not propagate exception because an exception thrown from a scheduled operation\n          // will suppress future executions\n          log.error(\"Unexpected exception from trigger: \" + trigger.getName(), e);\n        } finally {\n          // checkpoint after each run\n          trigger.saveState();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1aad05eeff7818b0833c02ac6b743aa72054963b","date":1512093122,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers.ScheduledTrigger#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers.ScheduledTrigger#run().mjava","sourceNew":"    @Override\n    public void run() {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTrigger \" + trigger.getName() + \" has been closed.\");\n      }\n      // fire a trigger only if an action is not pending\n      // note this is not fool proof e.g. it does not prevent an action being executed while a trigger\n      // is still executing. There is additional protection against that scenario in the event listener.\n      if (!hasPendingActions.get())  {\n        // this synchronization is usually never under contention\n        // but the only reason to have it here is to ensure that when the set-properties API is used\n        // to change the schedule delay, we can safely cancel the old scheduled task\n        // and create another one with the new delay without worrying about concurrent\n        // execution of the same trigger instance\n        synchronized (ScheduledTrigger.this) {\n          // replay accumulated events on first run, if any\n          if (replay) {\n            TriggerEvent event;\n            // peek first without removing - we may crash before calling the listener\n            while ((event = queue.peekEvent()) != null) {\n              // override REPLAYING=true\n              event.getProperties().put(TriggerEvent.REPLAYING, true);\n              if (! trigger.getProcessor().process(event)) {\n                log.error(\"Failed to re-play event, discarding: \" + event);\n              }\n              queue.pollEvent(); // always remove it from queue\n            }\n            // now restore saved state to possibly generate new events from old state on the first run\n            try {\n              trigger.restoreState();\n            } catch (Exception e) {\n              // log but don't throw - see below\n              log.error(\"Error restoring trigger state \" + trigger.getName(), e);\n            }\n            replay = false;\n          }\n          try {\n            trigger.run();\n          } catch (Exception e) {\n            // log but do not propagate exception because an exception thrown from a scheduled operation\n            // will suppress future executions\n            log.error(\"Unexpected exception from trigger: \" + trigger.getName(), e);\n          } finally {\n            // checkpoint after each run\n            trigger.saveState();\n          }\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTrigger \" + trigger.getName() + \" has been closed.\");\n      }\n      // fire a trigger only if an action is not pending\n      // note this is not fool proof e.g. it does not prevent an action being executed while a trigger\n      // is still executing. There is additional protection against that scenario in the event listener.\n      if (!hasPendingActions.get())  {\n        // replay accumulated events on first run, if any\n        if (replay) {\n          TriggerEvent event;\n          // peek first without removing - we may crash before calling the listener\n          while ((event = queue.peekEvent()) != null) {\n            // override REPLAYING=true\n            event.getProperties().put(TriggerEvent.REPLAYING, true);\n            if (! trigger.getProcessor().process(event)) {\n              log.error(\"Failed to re-play event, discarding: \" + event);\n            }\n            queue.pollEvent(); // always remove it from queue\n          }\n          // now restore saved state to possibly generate new events from old state on the first run\n          try {\n            trigger.restoreState();\n          } catch (Exception e) {\n            // log but don't throw - see below\n            log.error(\"Error restoring trigger state \" + trigger.getName(), e);\n          }\n          replay = false;\n        }\n        try {\n          trigger.run();\n        } catch (Exception e) {\n          // log but do not propagate exception because an exception thrown from a scheduled operation\n          // will suppress future executions\n          log.error(\"Unexpected exception from trigger: \" + trigger.getName(), e);\n        } finally {\n          // checkpoint after each run\n          trigger.saveState();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8af24f206736d88373229e8c83ddb84a433e57f3","date":1520362563,"type":5,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers.TriggerWrapper#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers.ScheduledTrigger#run().mjava","sourceNew":"    @Override\n    public void run() {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTrigger \" + trigger.getName() + \" has been closed.\");\n      }\n      // fire a trigger only if an action is not pending\n      // note this is not fool proof e.g. it does not prevent an action being executed while a trigger\n      // is still executing. There is additional protection against that scenario in the event listener.\n      if (!hasPendingActions.get())  {\n        // this synchronization is usually never under contention\n        // but the only reason to have it here is to ensure that when the set-properties API is used\n        // to change the schedule delay, we can safely cancel the old scheduled task\n        // and create another one with the new delay without worrying about concurrent\n        // execution of the same trigger instance\n        synchronized (TriggerWrapper.this) {\n          // replay accumulated events on first run, if any\n          if (replay) {\n            TriggerEvent event;\n            // peek first without removing - we may crash before calling the listener\n            while ((event = queue.peekEvent()) != null) {\n              // override REPLAYING=true\n              event.getProperties().put(TriggerEvent.REPLAYING, true);\n              if (! trigger.getProcessor().process(event)) {\n                log.error(\"Failed to re-play event, discarding: \" + event);\n              }\n              queue.pollEvent(); // always remove it from queue\n            }\n            // now restore saved state to possibly generate new events from old state on the first run\n            try {\n              trigger.restoreState();\n            } catch (Exception e) {\n              // log but don't throw - see below\n              log.error(\"Error restoring trigger state \" + trigger.getName(), e);\n            }\n            replay = false;\n          }\n          try {\n            trigger.run();\n          } catch (Exception e) {\n            // log but do not propagate exception because an exception thrown from a scheduled operation\n            // will suppress future executions\n            log.error(\"Unexpected exception from trigger: \" + trigger.getName(), e);\n          } finally {\n            // checkpoint after each run\n            trigger.saveState();\n          }\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTrigger \" + trigger.getName() + \" has been closed.\");\n      }\n      // fire a trigger only if an action is not pending\n      // note this is not fool proof e.g. it does not prevent an action being executed while a trigger\n      // is still executing. There is additional protection against that scenario in the event listener.\n      if (!hasPendingActions.get())  {\n        // this synchronization is usually never under contention\n        // but the only reason to have it here is to ensure that when the set-properties API is used\n        // to change the schedule delay, we can safely cancel the old scheduled task\n        // and create another one with the new delay without worrying about concurrent\n        // execution of the same trigger instance\n        synchronized (ScheduledTrigger.this) {\n          // replay accumulated events on first run, if any\n          if (replay) {\n            TriggerEvent event;\n            // peek first without removing - we may crash before calling the listener\n            while ((event = queue.peekEvent()) != null) {\n              // override REPLAYING=true\n              event.getProperties().put(TriggerEvent.REPLAYING, true);\n              if (! trigger.getProcessor().process(event)) {\n                log.error(\"Failed to re-play event, discarding: \" + event);\n              }\n              queue.pollEvent(); // always remove it from queue\n            }\n            // now restore saved state to possibly generate new events from old state on the first run\n            try {\n              trigger.restoreState();\n            } catch (Exception e) {\n              // log but don't throw - see below\n              log.error(\"Error restoring trigger state \" + trigger.getName(), e);\n            }\n            replay = false;\n          }\n          try {\n            trigger.run();\n          } catch (Exception e) {\n            // log but do not propagate exception because an exception thrown from a scheduled operation\n            // will suppress future executions\n            log.error(\"Unexpected exception from trigger: \" + trigger.getName(), e);\n          } finally {\n            // checkpoint after each run\n            trigger.saveState();\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"c304e97e7c1d472bc70e801b35ee78583916c6cd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2db92e6e82ec303a2d386048fd103cdb3ae4a806"],"8af24f206736d88373229e8c83ddb84a433e57f3":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"2366044456b379068d7b2f3d88a2ebcc3bbf8831":["c5fd294da67452cd8d116692194908de00eb5209"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["560c18d71dad43d675158783c3840f8c80d6d39c","15ba547dfc0dd0b670e678cb3db8e5d27c694420"],"15ba547dfc0dd0b670e678cb3db8e5d27c694420":["560c18d71dad43d675158783c3840f8c80d6d39c"],"5531f16a602ef350b6c9adfb08ebaa13a60fe3db":["009caa80830ac6369c42e5f6515405d686eabfee","464244264804e3f981bf1fb4b732516d8d62dbc2"],"009caa80830ac6369c42e5f6515405d686eabfee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c5fd294da67452cd8d116692194908de00eb5209":["5531f16a602ef350b6c9adfb08ebaa13a60fe3db"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"464244264804e3f981bf1fb4b732516d8d62dbc2":["009caa80830ac6369c42e5f6515405d686eabfee"],"2db92e6e82ec303a2d386048fd103cdb3ae4a806":["c5fd294da67452cd8d116692194908de00eb5209","2366044456b379068d7b2f3d88a2ebcc3bbf8831"],"560c18d71dad43d675158783c3840f8c80d6d39c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c304e97e7c1d472bc70e801b35ee78583916c6cd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8af24f206736d88373229e8c83ddb84a433e57f3"]},"commit2Childs":{"c304e97e7c1d472bc70e801b35ee78583916c6cd":["560c18d71dad43d675158783c3840f8c80d6d39c"],"8af24f206736d88373229e8c83ddb84a433e57f3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2366044456b379068d7b2f3d88a2ebcc3bbf8831":["2db92e6e82ec303a2d386048fd103cdb3ae4a806"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["8af24f206736d88373229e8c83ddb84a433e57f3"],"15ba547dfc0dd0b670e678cb3db8e5d27c694420":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"5531f16a602ef350b6c9adfb08ebaa13a60fe3db":["c5fd294da67452cd8d116692194908de00eb5209"],"009caa80830ac6369c42e5f6515405d686eabfee":["5531f16a602ef350b6c9adfb08ebaa13a60fe3db","464244264804e3f981bf1fb4b732516d8d62dbc2"],"c5fd294da67452cd8d116692194908de00eb5209":["2366044456b379068d7b2f3d88a2ebcc3bbf8831","2db92e6e82ec303a2d386048fd103cdb3ae4a806"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c304e97e7c1d472bc70e801b35ee78583916c6cd","009caa80830ac6369c42e5f6515405d686eabfee","560c18d71dad43d675158783c3840f8c80d6d39c"],"464244264804e3f981bf1fb4b732516d8d62dbc2":["5531f16a602ef350b6c9adfb08ebaa13a60fe3db"],"2db92e6e82ec303a2d386048fd103cdb3ae4a806":["c304e97e7c1d472bc70e801b35ee78583916c6cd"],"560c18d71dad43d675158783c3840f8c80d6d39c":["1aad05eeff7818b0833c02ac6b743aa72054963b","15ba547dfc0dd0b670e678cb3db8e5d27c694420"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}