{"path":"lucene/core/src/test/org/apache/lucene/index/TestAddIndexes#testAddIndicesWithSoftDeletes().mjava","commits":[{"id":"8f2203cb8ae87188877cfbf6ad170c5738a0aad5","date":1528117512,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestAddIndexes#testAddIndicesWithSoftDeletes().mjava","pathOld":"/dev/null","sourceNew":"  public void testAddIndicesWithSoftDeletes() throws IOException {\n    Directory dir1 = newDirectory();\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    IndexWriter writer = new IndexWriter(dir1, iwc1);\n    for (int i = 0; i < 30; i++) {\n      Document doc = new Document();\n      int docID = random().nextInt(5);\n      doc.add(new StringField(\"id\", \"\" + docID, Field.Store.YES));\n      writer.softUpdateDocument(new Term(\"id\", \"\" + docID), doc, new NumericDocValuesField(\"soft_delete\", 1));\n      if (random().nextBoolean()) {\n        writer.flush();\n      }\n    }\n    writer.commit();\n    writer.close();\n    DirectoryReader reader = DirectoryReader.open(dir1);\n    DirectoryReader wrappedReader = new SoftDeletesDirectoryReaderWrapper(reader, \"soft_delete\");\n    Directory dir2 = newDirectory();\n    int numDocs = reader.numDocs();\n    int maxDoc = reader.maxDoc();\n    assertEquals(numDocs, maxDoc);\n    iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    writer = new IndexWriter(dir2, iwc1);\n    CodecReader[] readers = new CodecReader[reader.leaves().size()];\n    for (int i = 0; i < readers.length; i++) {\n      readers[i] = (CodecReader)reader.leaves().get(i).reader();\n    }\n    writer.addIndexes(readers);\n    assertEquals(wrappedReader.numDocs(), writer.numDocs());\n    assertEquals(maxDoc, writer.maxDoc());\n    writer.commit();\n    SegmentCommitInfo commitInfo = writer.segmentInfos.asList().get(0);\n    assertEquals(maxDoc-wrappedReader.numDocs(), commitInfo.getSoftDelCount());\n    writer.close();\n    Directory dir3 = newDirectory();\n    iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    writer = new IndexWriter(dir3, iwc1);\n    for (int i = 0; i < readers.length; i++) {\n      readers[i] = (CodecReader)wrappedReader.leaves().get(i).reader();\n    }\n    writer.addIndexes(readers);\n    assertEquals(wrappedReader.numDocs(), writer.numDocs());\n    assertEquals(wrappedReader.numDocs(), writer.maxDoc());\n    IOUtils.close(reader, writer, dir3, dir2, dir1);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["631ea3d1607299c59f33edef140ffc19a81f07a0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":0,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestAddIndexes#testAddIndicesWithSoftDeletes().mjava","pathOld":"/dev/null","sourceNew":"  public void testAddIndicesWithSoftDeletes() throws IOException {\n    Directory dir1 = newDirectory();\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    IndexWriter writer = new IndexWriter(dir1, iwc1);\n    for (int i = 0; i < 30; i++) {\n      Document doc = new Document();\n      int docID = random().nextInt(5);\n      doc.add(new StringField(\"id\", \"\" + docID, Field.Store.YES));\n      writer.softUpdateDocument(new Term(\"id\", \"\" + docID), doc, new NumericDocValuesField(\"soft_delete\", 1));\n      if (random().nextBoolean()) {\n        writer.flush();\n      }\n    }\n    writer.commit();\n    writer.close();\n    DirectoryReader reader = DirectoryReader.open(dir1);\n    DirectoryReader wrappedReader = new SoftDeletesDirectoryReaderWrapper(reader, \"soft_delete\");\n    Directory dir2 = newDirectory();\n    int numDocs = reader.numDocs();\n    int maxDoc = reader.maxDoc();\n    assertEquals(numDocs, maxDoc);\n    iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    writer = new IndexWriter(dir2, iwc1);\n    CodecReader[] readers = new CodecReader[reader.leaves().size()];\n    for (int i = 0; i < readers.length; i++) {\n      readers[i] = (CodecReader)reader.leaves().get(i).reader();\n    }\n    writer.addIndexes(readers);\n    assertEquals(wrappedReader.numDocs(), writer.numDocs());\n    assertEquals(maxDoc, writer.maxDoc());\n    writer.commit();\n    SegmentCommitInfo commitInfo = writer.segmentInfos.asList().get(0);\n    assertEquals(maxDoc-wrappedReader.numDocs(), commitInfo.getSoftDelCount());\n    writer.close();\n    Directory dir3 = newDirectory();\n    iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    writer = new IndexWriter(dir3, iwc1);\n    for (int i = 0; i < readers.length; i++) {\n      readers[i] = (CodecReader)wrappedReader.leaves().get(i).reader();\n    }\n    writer.addIndexes(readers);\n    assertEquals(wrappedReader.numDocs(), writer.numDocs());\n    assertEquals(wrappedReader.numDocs(), writer.maxDoc());\n    IOUtils.close(reader, writer, dir3, dir2, dir1);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":0,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestAddIndexes#testAddIndicesWithSoftDeletes().mjava","pathOld":"/dev/null","sourceNew":"  public void testAddIndicesWithSoftDeletes() throws IOException {\n    Directory dir1 = newDirectory();\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    IndexWriter writer = new IndexWriter(dir1, iwc1);\n    for (int i = 0; i < 30; i++) {\n      Document doc = new Document();\n      int docID = random().nextInt(5);\n      doc.add(new StringField(\"id\", \"\" + docID, Field.Store.YES));\n      writer.softUpdateDocument(new Term(\"id\", \"\" + docID), doc, new NumericDocValuesField(\"soft_delete\", 1));\n      if (random().nextBoolean()) {\n        writer.flush();\n      }\n    }\n    writer.commit();\n    writer.close();\n    DirectoryReader reader = DirectoryReader.open(dir1);\n    DirectoryReader wrappedReader = new SoftDeletesDirectoryReaderWrapper(reader, \"soft_delete\");\n    Directory dir2 = newDirectory();\n    int numDocs = reader.numDocs();\n    int maxDoc = reader.maxDoc();\n    assertEquals(numDocs, maxDoc);\n    iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    writer = new IndexWriter(dir2, iwc1);\n    CodecReader[] readers = new CodecReader[reader.leaves().size()];\n    for (int i = 0; i < readers.length; i++) {\n      readers[i] = (CodecReader)reader.leaves().get(i).reader();\n    }\n    writer.addIndexes(readers);\n    assertEquals(wrappedReader.numDocs(), writer.numDocs());\n    assertEquals(maxDoc, writer.maxDoc());\n    writer.commit();\n    SegmentCommitInfo commitInfo = writer.segmentInfos.asList().get(0);\n    assertEquals(maxDoc-wrappedReader.numDocs(), commitInfo.getSoftDelCount());\n    writer.close();\n    Directory dir3 = newDirectory();\n    iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    writer = new IndexWriter(dir3, iwc1);\n    for (int i = 0; i < readers.length; i++) {\n      readers[i] = (CodecReader)wrappedReader.leaves().get(i).reader();\n    }\n    writer.addIndexes(readers);\n    assertEquals(wrappedReader.numDocs(), writer.numDocs());\n    assertEquals(wrappedReader.numDocs(), writer.maxDoc());\n    IOUtils.close(reader, writer, dir3, dir2, dir1);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"631ea3d1607299c59f33edef140ffc19a81f07a0","date":1532450367,"type":3,"author":"Nhat Nguyen","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestAddIndexes#testAddIndicesWithSoftDeletes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestAddIndexes#testAddIndicesWithSoftDeletes().mjava","sourceNew":"  public void testAddIndicesWithSoftDeletes() throws IOException {\n    Directory dir1 = newDirectory();\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    IndexWriter writer = new IndexWriter(dir1, iwc1);\n    for (int i = 0; i < 30; i++) {\n      Document doc = new Document();\n      int docID = random().nextInt(5);\n      doc.add(new StringField(\"id\", \"\" + docID, Field.Store.YES));\n      writer.softUpdateDocument(new Term(\"id\", \"\" + docID), doc, new NumericDocValuesField(\"soft_delete\", 1));\n      if (random().nextBoolean()) {\n        writer.flush();\n      }\n    }\n    writer.commit();\n    writer.close();\n    DirectoryReader reader = DirectoryReader.open(dir1);\n    DirectoryReader wrappedReader = new SoftDeletesDirectoryReaderWrapper(reader, \"soft_delete\");\n    Directory dir2 = newDirectory();\n    int numDocs = reader.numDocs();\n    int maxDoc = reader.maxDoc();\n    assertEquals(numDocs, maxDoc);\n    iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    writer = new IndexWriter(dir2, iwc1);\n    CodecReader[] readers = new CodecReader[reader.leaves().size()];\n    for (int i = 0; i < readers.length; i++) {\n      readers[i] = (CodecReader)reader.leaves().get(i).reader();\n    }\n    writer.addIndexes(readers);\n    assertEquals(wrappedReader.numDocs(), writer.numDocs());\n    assertEquals(maxDoc, writer.maxDoc());\n    writer.commit();\n    SegmentCommitInfo commitInfo = writer.listOfSegmentCommitInfos().get(0);\n    assertEquals(maxDoc-wrappedReader.numDocs(), commitInfo.getSoftDelCount());\n    writer.close();\n    Directory dir3 = newDirectory();\n    iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    writer = new IndexWriter(dir3, iwc1);\n    for (int i = 0; i < readers.length; i++) {\n      readers[i] = (CodecReader)wrappedReader.leaves().get(i).reader();\n    }\n    writer.addIndexes(readers);\n    assertEquals(wrappedReader.numDocs(), writer.numDocs());\n    assertEquals(wrappedReader.numDocs(), writer.maxDoc());\n    IOUtils.close(reader, writer, dir3, dir2, dir1);\n  }\n\n","sourceOld":"  public void testAddIndicesWithSoftDeletes() throws IOException {\n    Directory dir1 = newDirectory();\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    IndexWriter writer = new IndexWriter(dir1, iwc1);\n    for (int i = 0; i < 30; i++) {\n      Document doc = new Document();\n      int docID = random().nextInt(5);\n      doc.add(new StringField(\"id\", \"\" + docID, Field.Store.YES));\n      writer.softUpdateDocument(new Term(\"id\", \"\" + docID), doc, new NumericDocValuesField(\"soft_delete\", 1));\n      if (random().nextBoolean()) {\n        writer.flush();\n      }\n    }\n    writer.commit();\n    writer.close();\n    DirectoryReader reader = DirectoryReader.open(dir1);\n    DirectoryReader wrappedReader = new SoftDeletesDirectoryReaderWrapper(reader, \"soft_delete\");\n    Directory dir2 = newDirectory();\n    int numDocs = reader.numDocs();\n    int maxDoc = reader.maxDoc();\n    assertEquals(numDocs, maxDoc);\n    iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    writer = new IndexWriter(dir2, iwc1);\n    CodecReader[] readers = new CodecReader[reader.leaves().size()];\n    for (int i = 0; i < readers.length; i++) {\n      readers[i] = (CodecReader)reader.leaves().get(i).reader();\n    }\n    writer.addIndexes(readers);\n    assertEquals(wrappedReader.numDocs(), writer.numDocs());\n    assertEquals(maxDoc, writer.maxDoc());\n    writer.commit();\n    SegmentCommitInfo commitInfo = writer.segmentInfos.asList().get(0);\n    assertEquals(maxDoc-wrappedReader.numDocs(), commitInfo.getSoftDelCount());\n    writer.close();\n    Directory dir3 = newDirectory();\n    iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    writer = new IndexWriter(dir3, iwc1);\n    for (int i = 0; i < readers.length; i++) {\n      readers[i] = (CodecReader)wrappedReader.leaves().get(i).reader();\n    }\n    writer.addIndexes(readers);\n    assertEquals(wrappedReader.numDocs(), writer.numDocs());\n    assertEquals(wrappedReader.numDocs(), writer.maxDoc());\n    IOUtils.close(reader, writer, dir3, dir2, dir1);\n  }\n\n","bugFix":["8f2203cb8ae87188877cfbf6ad170c5738a0aad5"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bedab4bafa57e5b5a21fa9e700d1c76c4e9cda9e","date":1537365866,"type":3,"author":"Nhat Nguyen","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestAddIndexes#testAddIndicesWithSoftDeletes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestAddIndexes#testAddIndicesWithSoftDeletes().mjava","sourceNew":"  public void testAddIndicesWithSoftDeletes() throws IOException {\n    Directory dir1 = newDirectory();\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    IndexWriter writer = new IndexWriter(dir1, iwc1);\n    for (int i = 0; i < 30; i++) {\n      Document doc = new Document();\n      int docID = random().nextInt(5);\n      doc.add(new StringField(\"id\", \"\" + docID, Field.Store.YES));\n      writer.softUpdateDocument(new Term(\"id\", \"\" + docID), doc, new NumericDocValuesField(\"soft_delete\", 1));\n      if (random().nextBoolean()) {\n        writer.flush();\n      }\n    }\n    writer.commit();\n    writer.close();\n    DirectoryReader reader = DirectoryReader.open(dir1);\n    DirectoryReader wrappedReader = new SoftDeletesDirectoryReaderWrapper(reader, \"soft_delete\");\n    Directory dir2 = newDirectory();\n    int numDocs = reader.numDocs();\n    int maxDoc = reader.maxDoc();\n    assertEquals(numDocs, maxDoc);\n    iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    writer = new IndexWriter(dir2, iwc1);\n    CodecReader[] readers = new CodecReader[reader.leaves().size()];\n    for (int i = 0; i < readers.length; i++) {\n      readers[i] = (CodecReader)reader.leaves().get(i).reader();\n    }\n    writer.addIndexes(readers);\n    assertEquals(wrappedReader.numDocs(), writer.numDocs());\n    assertEquals(maxDoc, writer.maxDoc());\n    writer.commit();\n    SegmentCommitInfo commitInfo = writer.listOfSegmentCommitInfos().get(0);\n    assertEquals(maxDoc-wrappedReader.numDocs(), commitInfo.getSoftDelCount());\n    writer.close();\n    Directory dir3 = newDirectory();\n    iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    writer = new IndexWriter(dir3, iwc1);\n    // Resize as some fully deleted sub-readers might be dropped in the wrappedReader\n    readers = new CodecReader[(wrappedReader.leaves().size())];\n    for (int i = 0; i < readers.length; i++) {\n      readers[i] = (CodecReader)wrappedReader.leaves().get(i).reader();\n    }\n    writer.addIndexes(readers);\n    assertEquals(wrappedReader.numDocs(), writer.numDocs());\n    assertEquals(wrappedReader.numDocs(), writer.maxDoc());\n    IOUtils.close(reader, writer, dir3, dir2, dir1);\n  }\n\n","sourceOld":"  public void testAddIndicesWithSoftDeletes() throws IOException {\n    Directory dir1 = newDirectory();\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    IndexWriter writer = new IndexWriter(dir1, iwc1);\n    for (int i = 0; i < 30; i++) {\n      Document doc = new Document();\n      int docID = random().nextInt(5);\n      doc.add(new StringField(\"id\", \"\" + docID, Field.Store.YES));\n      writer.softUpdateDocument(new Term(\"id\", \"\" + docID), doc, new NumericDocValuesField(\"soft_delete\", 1));\n      if (random().nextBoolean()) {\n        writer.flush();\n      }\n    }\n    writer.commit();\n    writer.close();\n    DirectoryReader reader = DirectoryReader.open(dir1);\n    DirectoryReader wrappedReader = new SoftDeletesDirectoryReaderWrapper(reader, \"soft_delete\");\n    Directory dir2 = newDirectory();\n    int numDocs = reader.numDocs();\n    int maxDoc = reader.maxDoc();\n    assertEquals(numDocs, maxDoc);\n    iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    writer = new IndexWriter(dir2, iwc1);\n    CodecReader[] readers = new CodecReader[reader.leaves().size()];\n    for (int i = 0; i < readers.length; i++) {\n      readers[i] = (CodecReader)reader.leaves().get(i).reader();\n    }\n    writer.addIndexes(readers);\n    assertEquals(wrappedReader.numDocs(), writer.numDocs());\n    assertEquals(maxDoc, writer.maxDoc());\n    writer.commit();\n    SegmentCommitInfo commitInfo = writer.listOfSegmentCommitInfos().get(0);\n    assertEquals(maxDoc-wrappedReader.numDocs(), commitInfo.getSoftDelCount());\n    writer.close();\n    Directory dir3 = newDirectory();\n    iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    writer = new IndexWriter(dir3, iwc1);\n    for (int i = 0; i < readers.length; i++) {\n      readers[i] = (CodecReader)wrappedReader.leaves().get(i).reader();\n    }\n    writer.addIndexes(readers);\n    assertEquals(wrappedReader.numDocs(), writer.numDocs());\n    assertEquals(wrappedReader.numDocs(), writer.maxDoc());\n    IOUtils.close(reader, writer, dir3, dir2, dir1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"feb4029567b43f074ed7b6eb8fb126d355075dfd","date":1544812585,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestAddIndexes#testAddIndicesWithSoftDeletes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestAddIndexes#testAddIndicesWithSoftDeletes().mjava","sourceNew":"  public void testAddIndicesWithSoftDeletes() throws IOException {\n    Directory dir1 = newDirectory();\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    IndexWriter writer = new IndexWriter(dir1, iwc1);\n    for (int i = 0; i < 30; i++) {\n      Document doc = new Document();\n      int docID = random().nextInt(5);\n      doc.add(new StringField(\"id\", \"\" + docID, Field.Store.YES));\n      writer.softUpdateDocument(new Term(\"id\", \"\" + docID), doc, new NumericDocValuesField(\"soft_delete\", 1));\n      if (random().nextBoolean()) {\n        writer.flush();\n      }\n    }\n    writer.commit();\n    writer.close();\n    DirectoryReader reader = DirectoryReader.open(dir1);\n    DirectoryReader wrappedReader = new SoftDeletesDirectoryReaderWrapper(reader, \"soft_delete\");\n    Directory dir2 = newDirectory();\n    int numDocs = reader.numDocs();\n    int maxDoc = reader.maxDoc();\n    assertEquals(numDocs, maxDoc);\n    iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    writer = new IndexWriter(dir2, iwc1);\n    CodecReader[] readers = new CodecReader[reader.leaves().size()];\n    for (int i = 0; i < readers.length; i++) {\n      readers[i] = (CodecReader)reader.leaves().get(i).reader();\n    }\n    writer.addIndexes(readers);\n    assertEquals(wrappedReader.numDocs(), writer.getDocStats().numDocs);\n    assertEquals(maxDoc, writer.getDocStats().maxDoc);\n    writer.commit();\n    SegmentCommitInfo commitInfo = writer.listOfSegmentCommitInfos().get(0);\n    assertEquals(maxDoc-wrappedReader.numDocs(), commitInfo.getSoftDelCount());\n    writer.close();\n    Directory dir3 = newDirectory();\n    iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    writer = new IndexWriter(dir3, iwc1);\n    // Resize as some fully deleted sub-readers might be dropped in the wrappedReader\n    readers = new CodecReader[(wrappedReader.leaves().size())];\n    for (int i = 0; i < readers.length; i++) {\n      readers[i] = (CodecReader)wrappedReader.leaves().get(i).reader();\n    }\n    writer.addIndexes(readers);\n    assertEquals(wrappedReader.numDocs(), writer.getDocStats().numDocs);\n    assertEquals(wrappedReader.numDocs(), writer.getDocStats().maxDoc);\n    IOUtils.close(reader, writer, dir3, dir2, dir1);\n  }\n\n","sourceOld":"  public void testAddIndicesWithSoftDeletes() throws IOException {\n    Directory dir1 = newDirectory();\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    IndexWriter writer = new IndexWriter(dir1, iwc1);\n    for (int i = 0; i < 30; i++) {\n      Document doc = new Document();\n      int docID = random().nextInt(5);\n      doc.add(new StringField(\"id\", \"\" + docID, Field.Store.YES));\n      writer.softUpdateDocument(new Term(\"id\", \"\" + docID), doc, new NumericDocValuesField(\"soft_delete\", 1));\n      if (random().nextBoolean()) {\n        writer.flush();\n      }\n    }\n    writer.commit();\n    writer.close();\n    DirectoryReader reader = DirectoryReader.open(dir1);\n    DirectoryReader wrappedReader = new SoftDeletesDirectoryReaderWrapper(reader, \"soft_delete\");\n    Directory dir2 = newDirectory();\n    int numDocs = reader.numDocs();\n    int maxDoc = reader.maxDoc();\n    assertEquals(numDocs, maxDoc);\n    iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    writer = new IndexWriter(dir2, iwc1);\n    CodecReader[] readers = new CodecReader[reader.leaves().size()];\n    for (int i = 0; i < readers.length; i++) {\n      readers[i] = (CodecReader)reader.leaves().get(i).reader();\n    }\n    writer.addIndexes(readers);\n    assertEquals(wrappedReader.numDocs(), writer.numDocs());\n    assertEquals(maxDoc, writer.maxDoc());\n    writer.commit();\n    SegmentCommitInfo commitInfo = writer.listOfSegmentCommitInfos().get(0);\n    assertEquals(maxDoc-wrappedReader.numDocs(), commitInfo.getSoftDelCount());\n    writer.close();\n    Directory dir3 = newDirectory();\n    iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    writer = new IndexWriter(dir3, iwc1);\n    // Resize as some fully deleted sub-readers might be dropped in the wrappedReader\n    readers = new CodecReader[(wrappedReader.leaves().size())];\n    for (int i = 0; i < readers.length; i++) {\n      readers[i] = (CodecReader)wrappedReader.leaves().get(i).reader();\n    }\n    writer.addIndexes(readers);\n    assertEquals(wrappedReader.numDocs(), writer.numDocs());\n    assertEquals(wrappedReader.numDocs(), writer.maxDoc());\n    IOUtils.close(reader, writer, dir3, dir2, dir1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2","date":1588002560,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestAddIndexes#testAddIndicesWithSoftDeletes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestAddIndexes#testAddIndicesWithSoftDeletes().mjava","sourceNew":"  public void testAddIndicesWithSoftDeletes() throws IOException {\n    Directory dir1 = newDirectory();\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    IndexWriter writer = new IndexWriter(dir1, iwc1);\n    for (int i = 0; i < 30; i++) {\n      Document doc = new Document();\n      int docID = random().nextInt(5);\n      doc.add(new StringField(\"id\", \"\" + docID, Field.Store.YES));\n      writer.softUpdateDocument(new Term(\"id\", \"\" + docID), doc, new NumericDocValuesField(\"soft_delete\", 1));\n      if (random().nextBoolean()) {\n        writer.flush();\n      }\n    }\n    writer.commit();\n    writer.close();\n    DirectoryReader reader = DirectoryReader.open(dir1);\n    DirectoryReader wrappedReader = new SoftDeletesDirectoryReaderWrapper(reader, \"soft_delete\");\n    Directory dir2 = newDirectory();\n    int numDocs = reader.numDocs();\n    int maxDoc = reader.maxDoc();\n    assertEquals(numDocs, maxDoc);\n    iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    writer = new IndexWriter(dir2, iwc1);\n    CodecReader[] readers = new CodecReader[reader.leaves().size()];\n    for (int i = 0; i < readers.length; i++) {\n      readers[i] = (CodecReader)reader.leaves().get(i).reader();\n    }\n    writer.addIndexes(readers);\n    assertEquals(wrappedReader.numDocs(), writer.getDocStats().numDocs);\n    assertEquals(maxDoc, writer.getDocStats().maxDoc);\n    writer.commit();\n    SegmentCommitInfo commitInfo = writer.cloneSegmentInfos().info(0);\n    assertEquals(maxDoc-wrappedReader.numDocs(), commitInfo.getSoftDelCount());\n    writer.close();\n    Directory dir3 = newDirectory();\n    iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    writer = new IndexWriter(dir3, iwc1);\n    // Resize as some fully deleted sub-readers might be dropped in the wrappedReader\n    readers = new CodecReader[(wrappedReader.leaves().size())];\n    for (int i = 0; i < readers.length; i++) {\n      readers[i] = (CodecReader)wrappedReader.leaves().get(i).reader();\n    }\n    writer.addIndexes(readers);\n    assertEquals(wrappedReader.numDocs(), writer.getDocStats().numDocs);\n    assertEquals(wrappedReader.numDocs(), writer.getDocStats().maxDoc);\n    IOUtils.close(reader, writer, dir3, dir2, dir1);\n  }\n\n","sourceOld":"  public void testAddIndicesWithSoftDeletes() throws IOException {\n    Directory dir1 = newDirectory();\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    IndexWriter writer = new IndexWriter(dir1, iwc1);\n    for (int i = 0; i < 30; i++) {\n      Document doc = new Document();\n      int docID = random().nextInt(5);\n      doc.add(new StringField(\"id\", \"\" + docID, Field.Store.YES));\n      writer.softUpdateDocument(new Term(\"id\", \"\" + docID), doc, new NumericDocValuesField(\"soft_delete\", 1));\n      if (random().nextBoolean()) {\n        writer.flush();\n      }\n    }\n    writer.commit();\n    writer.close();\n    DirectoryReader reader = DirectoryReader.open(dir1);\n    DirectoryReader wrappedReader = new SoftDeletesDirectoryReaderWrapper(reader, \"soft_delete\");\n    Directory dir2 = newDirectory();\n    int numDocs = reader.numDocs();\n    int maxDoc = reader.maxDoc();\n    assertEquals(numDocs, maxDoc);\n    iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    writer = new IndexWriter(dir2, iwc1);\n    CodecReader[] readers = new CodecReader[reader.leaves().size()];\n    for (int i = 0; i < readers.length; i++) {\n      readers[i] = (CodecReader)reader.leaves().get(i).reader();\n    }\n    writer.addIndexes(readers);\n    assertEquals(wrappedReader.numDocs(), writer.getDocStats().numDocs);\n    assertEquals(maxDoc, writer.getDocStats().maxDoc);\n    writer.commit();\n    SegmentCommitInfo commitInfo = writer.listOfSegmentCommitInfos().get(0);\n    assertEquals(maxDoc-wrappedReader.numDocs(), commitInfo.getSoftDelCount());\n    writer.close();\n    Directory dir3 = newDirectory();\n    iwc1 = newIndexWriterConfig(new MockAnalyzer(random())).setSoftDeletesField(\"soft_delete\");\n    writer = new IndexWriter(dir3, iwc1);\n    // Resize as some fully deleted sub-readers might be dropped in the wrappedReader\n    readers = new CodecReader[(wrappedReader.leaves().size())];\n    for (int i = 0; i < readers.length; i++) {\n      readers[i] = (CodecReader)wrappedReader.leaves().get(i).reader();\n    }\n    writer.addIndexes(readers);\n    assertEquals(wrappedReader.numDocs(), writer.getDocStats().numDocs);\n    assertEquals(wrappedReader.numDocs(), writer.getDocStats().maxDoc);\n    IOUtils.close(reader, writer, dir3, dir2, dir1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bedab4bafa57e5b5a21fa9e700d1c76c4e9cda9e":["631ea3d1607299c59f33edef140ffc19a81f07a0"],"631ea3d1607299c59f33edef140ffc19a81f07a0":["8f2203cb8ae87188877cfbf6ad170c5738a0aad5"],"feb4029567b43f074ed7b6eb8fb126d355075dfd":["bedab4bafa57e5b5a21fa9e700d1c76c4e9cda9e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","8f2203cb8ae87188877cfbf6ad170c5738a0aad5"],"8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2":["feb4029567b43f074ed7b6eb8fb126d355075dfd"],"8f2203cb8ae87188877cfbf6ad170c5738a0aad5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f592209545c71895260367152601e9200399776d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","8f2203cb8ae87188877cfbf6ad170c5738a0aad5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2"]},"commit2Childs":{"bedab4bafa57e5b5a21fa9e700d1c76c4e9cda9e":["feb4029567b43f074ed7b6eb8fb126d355075dfd"],"631ea3d1607299c59f33edef140ffc19a81f07a0":["bedab4bafa57e5b5a21fa9e700d1c76c4e9cda9e"],"feb4029567b43f074ed7b6eb8fb126d355075dfd":["8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b70042a8a492f7054d480ccdd2be9796510d4327","8f2203cb8ae87188877cfbf6ad170c5738a0aad5","f592209545c71895260367152601e9200399776d"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8f2203cb8ae87188877cfbf6ad170c5738a0aad5":["631ea3d1607299c59f33edef140ffc19a81f07a0","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d"],"f592209545c71895260367152601e9200399776d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}