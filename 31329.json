{"path":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,boolean,CurrentCoreDescriptorProvider).mjava","commits":[{"id":"a7035935aa89f6951286e9005cbeb16e89a082a2","date":1385258396,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,boolean,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,boolean,int,int,CurrentCoreDescriptorProvider).mjava","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, int leaderVoteWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \n      (this.localHostContext.isEmpty() ? \"\" : (\"/\" + this.localHostContext));\n\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, new DefaultConnectionStrategy(),\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              ElectionContext context = new OverseerElectionContext(zkClient,\n                  overseer, getNodeName());\n              \n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n          }\n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, int leaderVoteWait, boolean genericCoreNodeNames, int distribUpdateConnTimeout, int distribUpdateSoTimeout, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    updateShardHandler = new UpdateShardHandler(distribUpdateConnTimeout, distribUpdateSoTimeout);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \n      (this.localHostContext.isEmpty() ? \"\" : (\"/\" + this.localHostContext));\n\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, new DefaultConnectionStrategy(),\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              ElectionContext context = new OverseerElectionContext(zkClient,\n                  overseer, getNodeName());\n              \n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n          }\n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,boolean,CurrentCoreDescriptorProvider).mjava","pathOld":"/dev/null","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, int leaderVoteWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \n      (this.localHostContext.isEmpty() ? \"\" : (\"/\" + this.localHostContext));\n\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, new DefaultConnectionStrategy(),\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              ElectionContext context = new OverseerElectionContext(zkClient,\n                  overseer, getNodeName());\n              \n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n          }\n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"97bd2b0da4beced82821b752b29576be986cf1ff","date":1387747012,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,boolean,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,boolean,CurrentCoreDescriptorProvider).mjava","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, int leaderVoteWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \n      (this.localHostContext.isEmpty() ? \"\" : (\"/\" + this.localHostContext));\n\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, new DefaultConnectionStrategy(),\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              ElectionContext context = new OverseerElectionContext(zkClient,\n                  overseer, getNodeName());\n              \n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n          }\n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, int leaderVoteWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \n      (this.localHostContext.isEmpty() ? \"\" : (\"/\" + this.localHostContext));\n\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, new DefaultConnectionStrategy(),\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              ElectionContext context = new OverseerElectionContext(zkClient,\n                  overseer, getNodeName());\n              \n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n          }\n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5be2ff5f99976897aa35a6ce84f61b0a2b45d91f","date":1389198917,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,boolean,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,boolean,CurrentCoreDescriptorProvider).mjava","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, int leaderVoteWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \n      (this.localHostContext.isEmpty() ? \"\" : (\"/\" + this.localHostContext));\n\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, new DefaultConnectionStrategy(),\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              ElectionContext context = new OverseerElectionContext(zkClient,\n                  overseer, getNodeName());\n              \n              ElectionContext prevContext = overseerElector.getContext();\n              if (prevContext != null) {\n                prevContext.cancelElection();\n              }\n              \n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n          }\n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, int leaderVoteWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \n      (this.localHostContext.isEmpty() ? \"\" : (\"/\" + this.localHostContext));\n\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, new DefaultConnectionStrategy(),\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              ElectionContext context = new OverseerElectionContext(zkClient,\n                  overseer, getNodeName());\n              \n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n          }\n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":["70c06ee2f4556113cf97d32fc61e506c602c9028"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","date":1389633998,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,boolean,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,boolean,CurrentCoreDescriptorProvider).mjava","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, int leaderVoteWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \n      (this.localHostContext.isEmpty() ? \"\" : (\"/\" + this.localHostContext));\n\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, new DefaultConnectionStrategy(),\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              ElectionContext context = new OverseerElectionContext(zkClient,\n                  overseer, getNodeName());\n              \n              ElectionContext prevContext = overseerElector.getContext();\n              if (prevContext != null) {\n                prevContext.cancelElection();\n              }\n              \n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n          }\n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, int leaderVoteWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \n      (this.localHostContext.isEmpty() ? \"\" : (\"/\" + this.localHostContext));\n\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, new DefaultConnectionStrategy(),\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              ElectionContext context = new OverseerElectionContext(zkClient,\n                  overseer, getNodeName());\n              \n              ElectionContext prevContext = overseerElector.getContext();\n              if (prevContext != null) {\n                prevContext.cancelElection();\n              }\n              \n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n          }\n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":["849494cf2f3a96af5c8c84995108ddd8456fcd04"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72","date":1391985588,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,boolean,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,boolean,CurrentCoreDescriptorProvider).mjava","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, int leaderVoteWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.hostName = normalizeHostName(localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, new DefaultConnectionStrategy(),\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              ElectionContext context = new OverseerElectionContext(zkClient,\n                  overseer, getNodeName());\n              \n              ElectionContext prevContext = overseerElector.getContext();\n              if (prevContext != null) {\n                prevContext.cancelElection();\n              }\n              \n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n          }\n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, int leaderVoteWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \n      (this.localHostContext.isEmpty() ? \"\" : (\"/\" + this.localHostContext));\n\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, new DefaultConnectionStrategy(),\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              ElectionContext context = new OverseerElectionContext(zkClient,\n                  overseer, getNodeName());\n              \n              ElectionContext prevContext = overseerElector.getContext();\n              if (prevContext != null) {\n                prevContext.cancelElection();\n              }\n              \n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n          }\n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"70c06ee2f4556113cf97d32fc61e506c602c9028","date":1392117115,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,boolean,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,boolean,CurrentCoreDescriptorProvider).mjava","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, int leaderVoteWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.hostName = normalizeHostName(localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, new DefaultConnectionStrategy(),\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              ElectionContext context = new OverseerElectionContext(zkClient,\n                  overseer, getNodeName());\n              \n              ElectionContext prevContext = overseerElector.getContext();\n              if (prevContext != null) {\n                prevContext.cancelElection();\n              }\n\n              overseerElector.setup(context);\n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n          }\n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, int leaderVoteWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.hostName = normalizeHostName(localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, new DefaultConnectionStrategy(),\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              ElectionContext context = new OverseerElectionContext(zkClient,\n                  overseer, getNodeName());\n              \n              ElectionContext prevContext = overseerElector.getContext();\n              if (prevContext != null) {\n                prevContext.cancelElection();\n              }\n              \n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n          }\n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":["5be2ff5f99976897aa35a6ce84f61b0a2b45d91f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4c3a1ead9dceabeebc8dee9f18829d65f63695cf","date":1392397168,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,boolean,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,boolean,CurrentCoreDescriptorProvider).mjava","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, int leaderVoteWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.hostName = normalizeHostName(localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, new DefaultConnectionStrategy(),\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              ElectionContext context = new OverseerElectionContext(zkClient,\n                  overseer, getNodeName());\n              \n              ElectionContext prevContext = overseerElector.getContext();\n              if (prevContext != null) {\n                prevContext.cancelElection();\n              }\n\n              overseerElector.setup(context);\n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n            markAllAsNotLeader(registerOnReconnect);\n          }\n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, int leaderVoteWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.hostName = normalizeHostName(localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, new DefaultConnectionStrategy(),\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              markAllAsNotLeader(registerOnReconnect);\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              ElectionContext context = new OverseerElectionContext(zkClient,\n                  overseer, getNodeName());\n              \n              ElectionContext prevContext = overseerElector.getContext();\n              if (prevContext != null) {\n                prevContext.cancelElection();\n              }\n\n              overseerElector.setup(context);\n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n          }\n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0b5db1c20d7a379233ae3955449a9e42caef007","date":1394048511,"type":5,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,int,boolean,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,boolean,CurrentCoreDescriptorProvider).mjava","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n        String localHostContext, int leaderVoteWait, int leaderConflictResolveWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) \n      throws InterruptedException, TimeoutException, IOException\n  {\n\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.hostName = normalizeHostName(localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.leaderConflictResolveWait = leaderConflictResolveWait;\n    \n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, new DefaultConnectionStrategy(),\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              ElectionContext context = new OverseerElectionContext(zkClient,\n                  overseer, getNodeName());\n              \n              ElectionContext prevContext = overseerElector.getContext();\n              if (prevContext != null) {\n                prevContext.cancelElection();\n              }\n\n              overseerElector.setup(context);\n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n            markAllAsNotLeader(registerOnReconnect);\n          }\n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, int leaderVoteWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.hostName = normalizeHostName(localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, new DefaultConnectionStrategy(),\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              ElectionContext context = new OverseerElectionContext(zkClient,\n                  overseer, getNodeName());\n              \n              ElectionContext prevContext = overseerElector.getContext();\n              if (prevContext != null) {\n                prevContext.cancelElection();\n              }\n\n              overseerElector.setup(context);\n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n            markAllAsNotLeader(registerOnReconnect);\n          }\n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"96ea64d994d340044e0d57aeb6a5871539d10ca5","date":1394225445,"type":5,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,int,boolean,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,boolean,CurrentCoreDescriptorProvider).mjava","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n        String localHostContext, int leaderVoteWait, int leaderConflictResolveWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) \n      throws InterruptedException, TimeoutException, IOException\n  {\n\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.hostName = normalizeHostName(localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.leaderConflictResolveWait = leaderConflictResolveWait;\n    \n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, new DefaultConnectionStrategy(),\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              ElectionContext context = new OverseerElectionContext(zkClient,\n                  overseer, getNodeName());\n              \n              ElectionContext prevContext = overseerElector.getContext();\n              if (prevContext != null) {\n                prevContext.cancelElection();\n              }\n\n              overseerElector.setup(context);\n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n            markAllAsNotLeader(registerOnReconnect);\n          }\n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, int leaderVoteWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.hostName = normalizeHostName(localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, new DefaultConnectionStrategy(),\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              ElectionContext context = new OverseerElectionContext(zkClient,\n                  overseer, getNodeName());\n              \n              ElectionContext prevContext = overseerElector.getContext();\n              if (prevContext != null) {\n                prevContext.cancelElection();\n              }\n\n              overseerElector.setup(context);\n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n            markAllAsNotLeader(registerOnReconnect);\n          }\n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"96ea64d994d340044e0d57aeb6a5871539d10ca5":["4c3a1ead9dceabeebc8dee9f18829d65f63695cf","a0b5db1c20d7a379233ae3955449a9e42caef007"],"97bd2b0da4beced82821b752b29576be986cf1ff":["a7035935aa89f6951286e9005cbeb16e89a082a2"],"57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"5be2ff5f99976897aa35a6ce84f61b0a2b45d91f":["97bd2b0da4beced82821b752b29576be986cf1ff"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"70c06ee2f4556113cf97d32fc61e506c602c9028":["57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a7035935aa89f6951286e9005cbeb16e89a082a2"],"a0b5db1c20d7a379233ae3955449a9e42caef007":["4c3a1ead9dceabeebc8dee9f18829d65f63695cf"],"a7035935aa89f6951286e9005cbeb16e89a082a2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["5be2ff5f99976897aa35a6ce84f61b0a2b45d91f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0b5db1c20d7a379233ae3955449a9e42caef007"],"4c3a1ead9dceabeebc8dee9f18829d65f63695cf":["70c06ee2f4556113cf97d32fc61e506c602c9028"]},"commit2Childs":{"96ea64d994d340044e0d57aeb6a5871539d10ca5":[],"97bd2b0da4beced82821b752b29576be986cf1ff":["5be2ff5f99976897aa35a6ce84f61b0a2b45d91f"],"57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72":["70c06ee2f4556113cf97d32fc61e506c602c9028"],"5be2ff5f99976897aa35a6ce84f61b0a2b45d91f":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","a7035935aa89f6951286e9005cbeb16e89a082a2"],"70c06ee2f4556113cf97d32fc61e506c602c9028":["4c3a1ead9dceabeebc8dee9f18829d65f63695cf"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"a0b5db1c20d7a379233ae3955449a9e42caef007":["96ea64d994d340044e0d57aeb6a5871539d10ca5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a7035935aa89f6951286e9005cbeb16e89a082a2":["97bd2b0da4beced82821b752b29576be986cf1ff","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72"],"4c3a1ead9dceabeebc8dee9f18829d65f63695cf":["96ea64d994d340044e0d57aeb6a5871539d10ca5","a0b5db1c20d7a379233ae3955449a9e42caef007"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["96ea64d994d340044e0d57aeb6a5871539d10ca5","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}