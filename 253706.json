{"path":"lucene/sandbox/src/java/org/apache/lucene/geo/Tessellator#eliminateHoles(Polygon,Node).mjava","commits":[{"id":"06fc6aedefe19d7a0b0d82dac953a4f161e16b5c","date":1531585717,"type":0,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/geo/Tessellator#eliminateHoles(Polygon,Node).mjava","pathOld":"/dev/null","sourceNew":"  /** Links every hole into the outer loop, producing a single-ring polygon without holes. **/\n  private static final Node eliminateHoles(final Polygon polygon, Node outerNode) {\n    // Define a list to hole a reference to each filtered hole list.\n    final List<Node> holeList = new ArrayList<>();\n    // Iterate through each array of hole vertices.\n    Polygon[] holes = polygon.getHoles();\n    for(int i = 0; i < polygon.numHoles(); ++i) {\n      // create the doubly-linked hole list\n      Node list = createDoublyLinkedList(holes[i], WindingOrder.CW);\n      if (list == list.next) {\n        list.isSteiner = true;\n      }\n      // Determine if the resulting hole polygon was successful.\n      if(list != null) {\n        // Add the leftmost vertex of the hole.\n        holeList.add(fetchLeftmost(list));\n      }\n    }\n\n    // Sort the hole vertices by x coordinate\n    holeList.sort((Node pNodeA, Node pNodeB) ->\n        pNodeA.getX() < pNodeB.getX() ? -1 : pNodeA.getX() == pNodeB.getX() ? 0 : 1);\n\n    // Process holes from left to right.\n    for(int i = 0; i < holeList.size(); ++i) {\n      // Eliminate hole triangles from the result set\n      final Node holeNode = holeList.get(i);\n      eliminateHole(holeNode, outerNode);\n      // Filter the new polygon.\n      outerNode = filterPoints(outerNode, outerNode.next);\n    }\n    // Return a pointer to the list.\n    return outerNode;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["62608383871b832d79e6dc58a3c783d7300f64d5","af3d65dc4ed982e4cd039cdc714a74f15757fa53"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":0,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/geo/Tessellator#eliminateHoles(Polygon,Node).mjava","pathOld":"/dev/null","sourceNew":"  /** Links every hole into the outer loop, producing a single-ring polygon without holes. **/\n  private static final Node eliminateHoles(final Polygon polygon, Node outerNode) {\n    // Define a list to hole a reference to each filtered hole list.\n    final List<Node> holeList = new ArrayList<>();\n    // Iterate through each array of hole vertices.\n    Polygon[] holes = polygon.getHoles();\n    for(int i = 0; i < polygon.numHoles(); ++i) {\n      // create the doubly-linked hole list\n      Node list = createDoublyLinkedList(holes[i], WindingOrder.CW);\n      if (list == list.next) {\n        list.isSteiner = true;\n      }\n      // Determine if the resulting hole polygon was successful.\n      if(list != null) {\n        // Add the leftmost vertex of the hole.\n        holeList.add(fetchLeftmost(list));\n      }\n    }\n\n    // Sort the hole vertices by x coordinate\n    holeList.sort((Node pNodeA, Node pNodeB) ->\n        pNodeA.getX() < pNodeB.getX() ? -1 : pNodeA.getX() == pNodeB.getX() ? 0 : 1);\n\n    // Process holes from left to right.\n    for(int i = 0; i < holeList.size(); ++i) {\n      // Eliminate hole triangles from the result set\n      final Node holeNode = holeList.get(i);\n      eliminateHole(holeNode, outerNode);\n      // Filter the new polygon.\n      outerNode = filterPoints(outerNode, outerNode.next);\n    }\n    // Return a pointer to the list.\n    return outerNode;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":0,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/geo/Tessellator#eliminateHoles(Polygon,Node).mjava","pathOld":"/dev/null","sourceNew":"  /** Links every hole into the outer loop, producing a single-ring polygon without holes. **/\n  private static final Node eliminateHoles(final Polygon polygon, Node outerNode) {\n    // Define a list to hole a reference to each filtered hole list.\n    final List<Node> holeList = new ArrayList<>();\n    // Iterate through each array of hole vertices.\n    Polygon[] holes = polygon.getHoles();\n    for(int i = 0; i < polygon.numHoles(); ++i) {\n      // create the doubly-linked hole list\n      Node list = createDoublyLinkedList(holes[i], WindingOrder.CW);\n      if (list == list.next) {\n        list.isSteiner = true;\n      }\n      // Determine if the resulting hole polygon was successful.\n      if(list != null) {\n        // Add the leftmost vertex of the hole.\n        holeList.add(fetchLeftmost(list));\n      }\n    }\n\n    // Sort the hole vertices by x coordinate\n    holeList.sort((Node pNodeA, Node pNodeB) ->\n        pNodeA.getX() < pNodeB.getX() ? -1 : pNodeA.getX() == pNodeB.getX() ? 0 : 1);\n\n    // Process holes from left to right.\n    for(int i = 0; i < holeList.size(); ++i) {\n      // Eliminate hole triangles from the result set\n      final Node holeNode = holeList.get(i);\n      eliminateHole(holeNode, outerNode);\n      // Filter the new polygon.\n      outerNode = filterPoints(outerNode, outerNode.next);\n    }\n    // Return a pointer to the list.\n    return outerNode;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"62608383871b832d79e6dc58a3c783d7300f64d5","date":1532707246,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/geo/Tessellator#eliminateHoles(Polygon,Node).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/geo/Tessellator#eliminateHoles(Polygon,Node).mjava","sourceNew":"  /** Links every hole into the outer loop, producing a single-ring polygon without holes. **/\n  private static final Node eliminateHoles(final Polygon polygon, Node outerNode) {\n    // Define a list to hole a reference to each filtered hole list.\n    final List<Node> holeList = new ArrayList<>();\n    // Iterate through each array of hole vertices.\n    Polygon[] holes = polygon.getHoles();\n    int nodeIndex = 0;\n    for(int i = 0; i < polygon.numHoles(); ++i) {\n      nodeIndex += holes[i].numPoints();\n      // create the doubly-linked hole list\n      Node list = createDoublyLinkedList(holes[i], nodeIndex, WindingOrder.CCW);\n      if (list == list.next) {\n        list.isSteiner = true;\n      }\n      // Determine if the resulting hole polygon was successful.\n      if(list != null) {\n        // Add the leftmost vertex of the hole.\n        holeList.add(fetchLeftmost(list));\n      }\n    }\n\n    // Sort the hole vertices by x coordinate\n    holeList.sort((Node pNodeA, Node pNodeB) ->\n        pNodeA.getX() < pNodeB.getX() ? -1 : pNodeA.getX() == pNodeB.getX() ? 0 : 1);\n\n    // Process holes from left to right.\n    for(int i = 0; i < holeList.size(); ++i) {\n      // Eliminate hole triangles from the result set\n      final Node holeNode = holeList.get(i);\n      eliminateHole(holeNode, outerNode);\n      // Filter the new polygon.\n      outerNode = filterPoints(outerNode, outerNode.next);\n    }\n    // Return a pointer to the list.\n    return outerNode;\n  }\n\n","sourceOld":"  /** Links every hole into the outer loop, producing a single-ring polygon without holes. **/\n  private static final Node eliminateHoles(final Polygon polygon, Node outerNode) {\n    // Define a list to hole a reference to each filtered hole list.\n    final List<Node> holeList = new ArrayList<>();\n    // Iterate through each array of hole vertices.\n    Polygon[] holes = polygon.getHoles();\n    for(int i = 0; i < polygon.numHoles(); ++i) {\n      // create the doubly-linked hole list\n      Node list = createDoublyLinkedList(holes[i], WindingOrder.CW);\n      if (list == list.next) {\n        list.isSteiner = true;\n      }\n      // Determine if the resulting hole polygon was successful.\n      if(list != null) {\n        // Add the leftmost vertex of the hole.\n        holeList.add(fetchLeftmost(list));\n      }\n    }\n\n    // Sort the hole vertices by x coordinate\n    holeList.sort((Node pNodeA, Node pNodeB) ->\n        pNodeA.getX() < pNodeB.getX() ? -1 : pNodeA.getX() == pNodeB.getX() ? 0 : 1);\n\n    // Process holes from left to right.\n    for(int i = 0; i < holeList.size(); ++i) {\n      // Eliminate hole triangles from the result set\n      final Node holeNode = holeList.get(i);\n      eliminateHole(holeNode, outerNode);\n      // Filter the new polygon.\n      outerNode = filterPoints(outerNode, outerNode.next);\n    }\n    // Return a pointer to the list.\n    return outerNode;\n  }\n\n","bugFix":["06fc6aedefe19d7a0b0d82dac953a4f161e16b5c"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"48333a719807c020be5d5ef1773d347156d46170","date":1537390171,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/geo/Tessellator#eliminateHoles(Polygon,Node).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/geo/Tessellator#eliminateHoles(Polygon,Node).mjava","sourceNew":"  /** Links every hole into the outer loop, producing a single-ring polygon without holes. **/\n  private static final Node eliminateHoles(final Polygon polygon, Node outerNode) {\n    // Define a list to hole a reference to each filtered hole list.\n    final List<Node> holeList = new ArrayList<>();\n    // Iterate through each array of hole vertices.\n    Polygon[] holes = polygon.getHoles();\n    int nodeIndex = polygon.numPoints();\n    for(int i = 0; i < polygon.numHoles(); ++i) {\n      // create the doubly-linked hole list\n      Node list = createDoublyLinkedList(holes[i], nodeIndex, WindingOrder.CCW);\n      if (list == list.next) {\n        list.isSteiner = true;\n      }\n      // Determine if the resulting hole polygon was successful.\n      if(list != null) {\n        // Add the leftmost vertex of the hole.\n        holeList.add(fetchLeftmost(list));\n      }\n      nodeIndex += holes[i].numPoints();\n    }\n\n    // Sort the hole vertices by x coordinate\n    holeList.sort((Node pNodeA, Node pNodeB) ->\n        pNodeA.getX() < pNodeB.getX() ? -1 : pNodeA.getX() == pNodeB.getX() ? 0 : 1);\n\n    // Process holes from left to right.\n    for(int i = 0; i < holeList.size(); ++i) {\n      // Eliminate hole triangles from the result set\n      final Node holeNode = holeList.get(i);\n      eliminateHole(holeNode, outerNode);\n      // Filter the new polygon.\n      outerNode = filterPoints(outerNode, outerNode.next);\n    }\n    // Return a pointer to the list.\n    return outerNode;\n  }\n\n","sourceOld":"  /** Links every hole into the outer loop, producing a single-ring polygon without holes. **/\n  private static final Node eliminateHoles(final Polygon polygon, Node outerNode) {\n    // Define a list to hole a reference to each filtered hole list.\n    final List<Node> holeList = new ArrayList<>();\n    // Iterate through each array of hole vertices.\n    Polygon[] holes = polygon.getHoles();\n    int nodeIndex = 0;\n    for(int i = 0; i < polygon.numHoles(); ++i) {\n      nodeIndex += holes[i].numPoints();\n      // create the doubly-linked hole list\n      Node list = createDoublyLinkedList(holes[i], nodeIndex, WindingOrder.CCW);\n      if (list == list.next) {\n        list.isSteiner = true;\n      }\n      // Determine if the resulting hole polygon was successful.\n      if(list != null) {\n        // Add the leftmost vertex of the hole.\n        holeList.add(fetchLeftmost(list));\n      }\n    }\n\n    // Sort the hole vertices by x coordinate\n    holeList.sort((Node pNodeA, Node pNodeB) ->\n        pNodeA.getX() < pNodeB.getX() ? -1 : pNodeA.getX() == pNodeB.getX() ? 0 : 1);\n\n    // Process holes from left to right.\n    for(int i = 0; i < holeList.size(); ++i) {\n      // Eliminate hole triangles from the result set\n      final Node holeNode = holeList.get(i);\n      eliminateHole(holeNode, outerNode);\n      // Filter the new polygon.\n      outerNode = filterPoints(outerNode, outerNode.next);\n    }\n    // Return a pointer to the list.\n    return outerNode;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3154b8a89750f531ca89c2fc8d7dc22a6ee5739d","date":1559804329,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/geo/Tessellator#eliminateHoles(Polygon,Node).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/geo/Tessellator#eliminateHoles(Polygon,Node).mjava","sourceNew":"  /** Links every hole into the outer loop, producing a single-ring polygon without holes. **/\n  private static final Node eliminateHoles(final Polygon polygon, Node outerNode) {\n    // Define a list to hole a reference to each filtered hole list.\n    final List<Node> holeList = new ArrayList<>();\n    // keep a reference to the hole\n    final Map<Node, Polygon> holeListPolygons = new HashMap<>();\n    // Iterate through each array of hole vertices.\n    Polygon[] holes = polygon.getHoles();\n    int nodeIndex = polygon.numPoints();\n    for(int i = 0; i < polygon.numHoles(); ++i) {\n      // create the doubly-linked hole list\n      Node list = createDoublyLinkedList(holes[i], nodeIndex, WindingOrder.CCW);\n\n      if (list == list.next) {\n        list.isSteiner = true;\n      }\n      // Determine if the resulting hole polygon was successful.\n      if(list != null) {\n        // Add the leftmost vertex of the hole.\n        Node leftMost = fetchLeftmost(list);\n        holeList.add(leftMost);\n        holeListPolygons.put(leftMost, holes[i]);\n      }\n      nodeIndex += holes[i].numPoints();\n    }\n\n    // Sort the hole vertices by x coordinate\n    holeList.sort((Node pNodeA, Node pNodeB) ->\n    {\n      double diff = pNodeA.getX() - pNodeB.getX();\n      if (diff == 0) {\n        diff = pNodeA.getY() - pNodeB.getY();\n        if (diff == 0) {\n          //same hole node\n          double a = Math.min(pNodeA.previous.getY(), pNodeA.next.getY());\n          double b = Math.min(pNodeB.previous.getY(), pNodeB.next.getY());\n          diff = a - b;\n        }\n      }\n      return diff < 0 ? -1 : diff > 0 ? 1 : 0;\n    });\n\n    // Process holes from left to right.\n    for(int i = 0; i < holeList.size(); ++i) {\n      // Eliminate hole triangles from the result set\n      final Node holeNode = holeList.get(i);\n      final Polygon hole = holeListPolygons.get(holeNode);\n      eliminateHole(holeNode, outerNode, hole);\n      // Filter the new polygon.\n      outerNode = filterPoints(outerNode, outerNode.next);\n    }\n    // Return a pointer to the list.\n    return outerNode;\n  }\n\n","sourceOld":"  /** Links every hole into the outer loop, producing a single-ring polygon without holes. **/\n  private static final Node eliminateHoles(final Polygon polygon, Node outerNode) {\n    // Define a list to hole a reference to each filtered hole list.\n    final List<Node> holeList = new ArrayList<>();\n    // Iterate through each array of hole vertices.\n    Polygon[] holes = polygon.getHoles();\n    int nodeIndex = polygon.numPoints();\n    for(int i = 0; i < polygon.numHoles(); ++i) {\n      // create the doubly-linked hole list\n      Node list = createDoublyLinkedList(holes[i], nodeIndex, WindingOrder.CCW);\n      if (list == list.next) {\n        list.isSteiner = true;\n      }\n      // Determine if the resulting hole polygon was successful.\n      if(list != null) {\n        // Add the leftmost vertex of the hole.\n        holeList.add(fetchLeftmost(list));\n      }\n      nodeIndex += holes[i].numPoints();\n    }\n\n    // Sort the hole vertices by x coordinate\n    holeList.sort((Node pNodeA, Node pNodeB) ->\n        pNodeA.getX() < pNodeB.getX() ? -1 : pNodeA.getX() == pNodeB.getX() ? 0 : 1);\n\n    // Process holes from left to right.\n    for(int i = 0; i < holeList.size(); ++i) {\n      // Eliminate hole triangles from the result set\n      final Node holeNode = holeList.get(i);\n      eliminateHole(holeNode, outerNode);\n      // Filter the new polygon.\n      outerNode = filterPoints(outerNode, outerNode.next);\n    }\n    // Return a pointer to the list.\n    return outerNode;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"af3d65dc4ed982e4cd039cdc714a74f15757fa53","date":1561362093,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/geo/Tessellator#eliminateHoles(Polygon,Node).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/geo/Tessellator#eliminateHoles(Polygon,Node).mjava","sourceNew":"  /** Links every hole into the outer loop, producing a single-ring polygon without holes. **/\n  private static final Node eliminateHoles(final Polygon polygon, Node outerNode) {\n    // Define a list to hole a reference to each filtered hole list.\n    final List<Node> holeList = new ArrayList<>();\n    // keep a reference to the hole\n    final Map<Node, Polygon> holeListPolygons = new HashMap<>();\n    // Iterate through each array of hole vertices.\n    Polygon[] holes = polygon.getHoles();\n    int nodeIndex = polygon.numPoints();\n    for(int i = 0; i < polygon.numHoles(); ++i) {\n      // create the doubly-linked hole list\n      Node list = createDoublyLinkedList(holes[i], nodeIndex, WindingOrder.CCW);\n\n      if (list == list.next) {\n        throw new IllegalArgumentException(\"Points are all coplanar in hole: \" + holes[i]);\n      }\n      // Determine if the resulting hole polygon was successful.\n      if(list != null) {\n        // Add the leftmost vertex of the hole.\n        Node leftMost = fetchLeftmost(list);\n        holeList.add(leftMost);\n        holeListPolygons.put(leftMost, holes[i]);\n      }\n      nodeIndex += holes[i].numPoints();\n    }\n\n    // Sort the hole vertices by x coordinate\n    holeList.sort((Node pNodeA, Node pNodeB) ->\n    {\n      double diff = pNodeA.getX() - pNodeB.getX();\n      if (diff == 0) {\n        diff = pNodeA.getY() - pNodeB.getY();\n        if (diff == 0) {\n          //same hole node\n          double a = Math.min(pNodeA.previous.getY(), pNodeA.next.getY());\n          double b = Math.min(pNodeB.previous.getY(), pNodeB.next.getY());\n          diff = a - b;\n        }\n      }\n      return diff < 0 ? -1 : diff > 0 ? 1 : 0;\n    });\n\n    // Process holes from left to right.\n    for(int i = 0; i < holeList.size(); ++i) {\n      // Eliminate hole triangles from the result set\n      final Node holeNode = holeList.get(i);\n      final Polygon hole = holeListPolygons.get(holeNode);\n      eliminateHole(holeNode, outerNode, hole);\n      // Filter the new polygon.\n      outerNode = filterPoints(outerNode, outerNode.next);\n    }\n    // Return a pointer to the list.\n    return outerNode;\n  }\n\n","sourceOld":"  /** Links every hole into the outer loop, producing a single-ring polygon without holes. **/\n  private static final Node eliminateHoles(final Polygon polygon, Node outerNode) {\n    // Define a list to hole a reference to each filtered hole list.\n    final List<Node> holeList = new ArrayList<>();\n    // keep a reference to the hole\n    final Map<Node, Polygon> holeListPolygons = new HashMap<>();\n    // Iterate through each array of hole vertices.\n    Polygon[] holes = polygon.getHoles();\n    int nodeIndex = polygon.numPoints();\n    for(int i = 0; i < polygon.numHoles(); ++i) {\n      // create the doubly-linked hole list\n      Node list = createDoublyLinkedList(holes[i], nodeIndex, WindingOrder.CCW);\n\n      if (list == list.next) {\n        list.isSteiner = true;\n      }\n      // Determine if the resulting hole polygon was successful.\n      if(list != null) {\n        // Add the leftmost vertex of the hole.\n        Node leftMost = fetchLeftmost(list);\n        holeList.add(leftMost);\n        holeListPolygons.put(leftMost, holes[i]);\n      }\n      nodeIndex += holes[i].numPoints();\n    }\n\n    // Sort the hole vertices by x coordinate\n    holeList.sort((Node pNodeA, Node pNodeB) ->\n    {\n      double diff = pNodeA.getX() - pNodeB.getX();\n      if (diff == 0) {\n        diff = pNodeA.getY() - pNodeB.getY();\n        if (diff == 0) {\n          //same hole node\n          double a = Math.min(pNodeA.previous.getY(), pNodeA.next.getY());\n          double b = Math.min(pNodeB.previous.getY(), pNodeB.next.getY());\n          diff = a - b;\n        }\n      }\n      return diff < 0 ? -1 : diff > 0 ? 1 : 0;\n    });\n\n    // Process holes from left to right.\n    for(int i = 0; i < holeList.size(); ++i) {\n      // Eliminate hole triangles from the result set\n      final Node holeNode = holeList.get(i);\n      final Polygon hole = holeListPolygons.get(holeNode);\n      eliminateHole(holeNode, outerNode, hole);\n      // Filter the new polygon.\n      outerNode = filterPoints(outerNode, outerNode.next);\n    }\n    // Return a pointer to the list.\n    return outerNode;\n  }\n\n","bugFix":["06fc6aedefe19d7a0b0d82dac953a4f161e16b5c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c286b0d8c507a88b289407e2fe161effa275c6b0","date":1562615977,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/geo/Tessellator#eliminateHoles(Polygon,Node).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/geo/Tessellator#eliminateHoles(Polygon,Node).mjava","sourceNew":"  /** Links every hole into the outer loop, producing a single-ring polygon without holes. **/\n  private static final Node eliminateHoles(final Polygon polygon, Node outerNode) {\n    // Define a list to hole a reference to each filtered hole list.\n    final List<Node> holeList = new ArrayList<>();\n    // keep a reference to the hole\n    final Map<Node, Polygon> holeListPolygons = new HashMap<>();\n    // Iterate through each array of hole vertices.\n    Polygon[] holes = polygon.getHoles();\n    int nodeIndex = polygon.numPoints();\n    for(int i = 0; i < polygon.numHoles(); ++i) {\n      // create the doubly-linked hole list\n      Node list = createDoublyLinkedList(holes[i].getPolyLons(), holes[i].getPolyLats(), holes[i].getWindingOrder(), true, nodeIndex, WindingOrder.CCW);\n      if (list == list.next) {\n        throw new IllegalArgumentException(\"Points are all coplanar in hole: \" + holes[i]);\n      }\n      // Determine if the resulting hole polygon was successful.\n      if(list != null) {\n        // Add the leftmost vertex of the hole.\n        Node leftMost = fetchLeftmost(list);\n        holeList.add(leftMost);\n        holeListPolygons.put(leftMost, holes[i]);\n      }\n      nodeIndex += holes[i].numPoints();\n    }\n    return eliminateHoles(holeList, holeListPolygons, outerNode);\n  }\n\n","sourceOld":"  /** Links every hole into the outer loop, producing a single-ring polygon without holes. **/\n  private static final Node eliminateHoles(final Polygon polygon, Node outerNode) {\n    // Define a list to hole a reference to each filtered hole list.\n    final List<Node> holeList = new ArrayList<>();\n    // keep a reference to the hole\n    final Map<Node, Polygon> holeListPolygons = new HashMap<>();\n    // Iterate through each array of hole vertices.\n    Polygon[] holes = polygon.getHoles();\n    int nodeIndex = polygon.numPoints();\n    for(int i = 0; i < polygon.numHoles(); ++i) {\n      // create the doubly-linked hole list\n      Node list = createDoublyLinkedList(holes[i], nodeIndex, WindingOrder.CCW);\n\n      if (list == list.next) {\n        throw new IllegalArgumentException(\"Points are all coplanar in hole: \" + holes[i]);\n      }\n      // Determine if the resulting hole polygon was successful.\n      if(list != null) {\n        // Add the leftmost vertex of the hole.\n        Node leftMost = fetchLeftmost(list);\n        holeList.add(leftMost);\n        holeListPolygons.put(leftMost, holes[i]);\n      }\n      nodeIndex += holes[i].numPoints();\n    }\n\n    // Sort the hole vertices by x coordinate\n    holeList.sort((Node pNodeA, Node pNodeB) ->\n    {\n      double diff = pNodeA.getX() - pNodeB.getX();\n      if (diff == 0) {\n        diff = pNodeA.getY() - pNodeB.getY();\n        if (diff == 0) {\n          //same hole node\n          double a = Math.min(pNodeA.previous.getY(), pNodeA.next.getY());\n          double b = Math.min(pNodeB.previous.getY(), pNodeB.next.getY());\n          diff = a - b;\n        }\n      }\n      return diff < 0 ? -1 : diff > 0 ? 1 : 0;\n    });\n\n    // Process holes from left to right.\n    for(int i = 0; i < holeList.size(); ++i) {\n      // Eliminate hole triangles from the result set\n      final Node holeNode = holeList.get(i);\n      final Polygon hole = holeListPolygons.get(holeNode);\n      eliminateHole(holeNode, outerNode, hole);\n      // Filter the new polygon.\n      outerNode = filterPoints(outerNode, outerNode.next);\n    }\n    // Return a pointer to the list.\n    return outerNode;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09c1e6d465800c73af60624bf9d4459a19f7940c","date":1579293280,"type":5,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/geo/Tessellator#eliminateHoles(Polygon,Node).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/geo/Tessellator#eliminateHoles(Polygon,Node).mjava","sourceNew":"  /** Links every hole into the outer loop, producing a single-ring polygon without holes. **/\n  private static final Node eliminateHoles(final Polygon polygon, Node outerNode) {\n    // Define a list to hole a reference to each filtered hole list.\n    final List<Node> holeList = new ArrayList<>();\n    // keep a reference to the hole\n    final Map<Node, Polygon> holeListPolygons = new HashMap<>();\n    // Iterate through each array of hole vertices.\n    Polygon[] holes = polygon.getHoles();\n    int nodeIndex = polygon.numPoints();\n    for(int i = 0; i < polygon.numHoles(); ++i) {\n      // create the doubly-linked hole list\n      Node list = createDoublyLinkedList(holes[i].getPolyLons(), holes[i].getPolyLats(), holes[i].getWindingOrder(), true, nodeIndex, WindingOrder.CCW);\n      if (list == list.next) {\n        throw new IllegalArgumentException(\"Points are all coplanar in hole: \" + holes[i]);\n      }\n      // Determine if the resulting hole polygon was successful.\n      if(list != null) {\n        // Add the leftmost vertex of the hole.\n        Node leftMost = fetchLeftmost(list);\n        holeList.add(leftMost);\n        holeListPolygons.put(leftMost, holes[i]);\n      }\n      nodeIndex += holes[i].numPoints();\n    }\n    return eliminateHoles(holeList, holeListPolygons, outerNode);\n  }\n\n","sourceOld":"  /** Links every hole into the outer loop, producing a single-ring polygon without holes. **/\n  private static final Node eliminateHoles(final Polygon polygon, Node outerNode) {\n    // Define a list to hole a reference to each filtered hole list.\n    final List<Node> holeList = new ArrayList<>();\n    // keep a reference to the hole\n    final Map<Node, Polygon> holeListPolygons = new HashMap<>();\n    // Iterate through each array of hole vertices.\n    Polygon[] holes = polygon.getHoles();\n    int nodeIndex = polygon.numPoints();\n    for(int i = 0; i < polygon.numHoles(); ++i) {\n      // create the doubly-linked hole list\n      Node list = createDoublyLinkedList(holes[i].getPolyLons(), holes[i].getPolyLats(), holes[i].getWindingOrder(), true, nodeIndex, WindingOrder.CCW);\n      if (list == list.next) {\n        throw new IllegalArgumentException(\"Points are all coplanar in hole: \" + holes[i]);\n      }\n      // Determine if the resulting hole polygon was successful.\n      if(list != null) {\n        // Add the leftmost vertex of the hole.\n        Node leftMost = fetchLeftmost(list);\n        holeList.add(leftMost);\n        holeListPolygons.put(leftMost, holes[i]);\n      }\n      nodeIndex += holes[i].numPoints();\n    }\n    return eliminateHoles(holeList, holeListPolygons, outerNode);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"62608383871b832d79e6dc58a3c783d7300f64d5":["06fc6aedefe19d7a0b0d82dac953a4f161e16b5c"],"06fc6aedefe19d7a0b0d82dac953a4f161e16b5c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","06fc6aedefe19d7a0b0d82dac953a4f161e16b5c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"09c1e6d465800c73af60624bf9d4459a19f7940c":["c286b0d8c507a88b289407e2fe161effa275c6b0"],"c286b0d8c507a88b289407e2fe161effa275c6b0":["af3d65dc4ed982e4cd039cdc714a74f15757fa53"],"af3d65dc4ed982e4cd039cdc714a74f15757fa53":["3154b8a89750f531ca89c2fc8d7dc22a6ee5739d"],"3154b8a89750f531ca89c2fc8d7dc22a6ee5739d":["48333a719807c020be5d5ef1773d347156d46170"],"48333a719807c020be5d5ef1773d347156d46170":["62608383871b832d79e6dc58a3c783d7300f64d5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["09c1e6d465800c73af60624bf9d4459a19f7940c"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","06fc6aedefe19d7a0b0d82dac953a4f161e16b5c"]},"commit2Childs":{"62608383871b832d79e6dc58a3c783d7300f64d5":["48333a719807c020be5d5ef1773d347156d46170"],"06fc6aedefe19d7a0b0d82dac953a4f161e16b5c":["62608383871b832d79e6dc58a3c783d7300f64d5","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["06fc6aedefe19d7a0b0d82dac953a4f161e16b5c","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"09c1e6d465800c73af60624bf9d4459a19f7940c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c286b0d8c507a88b289407e2fe161effa275c6b0":["09c1e6d465800c73af60624bf9d4459a19f7940c"],"af3d65dc4ed982e4cd039cdc714a74f15757fa53":["c286b0d8c507a88b289407e2fe161effa275c6b0"],"3154b8a89750f531ca89c2fc8d7dc22a6ee5739d":["af3d65dc4ed982e4cd039cdc714a74f15757fa53"],"48333a719807c020be5d5ef1773d347156d46170":["3154b8a89750f531ca89c2fc8d7dc22a6ee5739d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}