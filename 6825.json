{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#convertPolygon(List[List[GeoPoint]],PolygonDescription,List[GeoPoint]).mjava","commits":[{"id":"06729f5a814f91b46fa06d668ae86a5d257ba644","date":1461675413,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#convertPolygon(List[List[GeoPoint]],PolygonDescription,List[GeoPoint]).mjava","pathOld":"/dev/null","sourceNew":"  /** Convert a polygon description to a list of shapes.  Also locate an optimal shape for evaluating a test point.\n   * @param pointsList is the structure to add new polygons to.\n   * @param shape is the current polygon description.\n   * @param testPointShape is the current best choice for a low-level polygon to evaluate.\n   * @return an updated best-choice for a test point polygon, and update the points list.\n   */\n  private static List<GeoPoint> convertPolygon(final List<List<GeoPoint>> pointsList, final PolygonDescription shape, List<GeoPoint> testPointShape) {\n    // First, remove duplicate points.  If degenerate, just ignore the shape.\n    final List<GeoPoint> filteredPoints = filterPoints(shape.points);\n    if (filteredPoints == null) {\n      return testPointShape;\n    }\n    \n    // Non-degenerate.  Check if this is a candidate for in-set determination.\n    if (shape.holes.size() == 0) {\n      // This shape is a candidate for a test point.\n      if (testPointShape == null || testPointShape.size() > filteredPoints.size()) {\n        testPointShape = filteredPoints;\n      }\n    }\n    \n    pointsList.add(filteredPoints);\n    \n    // Now, do all holes too\n    for (final PolygonDescription hole : shape.holes) {\n      testPointShape = convertPolygon(pointsList, hole, testPointShape);\n    }\n    \n    // Done; return the updated test point shape.\n    return testPointShape;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0","date":1461888019,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#convertPolygon(List[List[GeoPoint]],PolygonDescription,List[GeoPoint]).mjava","pathOld":"/dev/null","sourceNew":"  /** Convert a polygon description to a list of shapes.  Also locate an optimal shape for evaluating a test point.\n   * @param pointsList is the structure to add new polygons to.\n   * @param shape is the current polygon description.\n   * @param testPointShape is the current best choice for a low-level polygon to evaluate.\n   * @return an updated best-choice for a test point polygon, and update the points list.\n   */\n  private static List<GeoPoint> convertPolygon(final List<List<GeoPoint>> pointsList, final PolygonDescription shape, List<GeoPoint> testPointShape) {\n    // First, remove duplicate points.  If degenerate, just ignore the shape.\n    final List<GeoPoint> filteredPoints = filterPoints(shape.points);\n    if (filteredPoints == null) {\n      return testPointShape;\n    }\n    \n    // Non-degenerate.  Check if this is a candidate for in-set determination.\n    if (shape.holes.size() == 0) {\n      // This shape is a candidate for a test point.\n      if (testPointShape == null || testPointShape.size() > filteredPoints.size()) {\n        testPointShape = filteredPoints;\n      }\n    }\n    \n    pointsList.add(filteredPoints);\n    \n    // Now, do all holes too\n    for (final PolygonDescription hole : shape.holes) {\n      testPointShape = convertPolygon(pointsList, hole, testPointShape);\n    }\n    \n    // Done; return the updated test point shape.\n    return testPointShape;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8825024cedab6612bf17c2b808f4f86abe6e45bb","date":1462272353,"type":5,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#convertPolygon(List[List[GeoPoint]],PolygonDescription,BestShape,boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#convertPolygon(List[List[GeoPoint]],PolygonDescription,List[GeoPoint]).mjava","sourceNew":"  /** Convert a polygon description to a list of shapes.  Also locate an optimal shape for evaluating a test point.\n   * @param pointsList is the structure to add new polygons to.\n   * @param shape is the current polygon description.\n   * @param testPointShape is the current best choice for a low-level polygon to evaluate.\n   * @return an updated best-choice for a test point polygon, and update the points list.\n   */\n  private static BestShape convertPolygon(final List<List<GeoPoint>> pointsList, final PolygonDescription shape, BestShape testPointShape, final boolean mustBeInside) {\n    // First, remove duplicate points.  If degenerate, just ignore the shape.\n    final List<GeoPoint> filteredPoints = filterPoints(shape.points);\n    if (filteredPoints == null) {\n      return testPointShape;\n    }\n    \n    // Non-degenerate.  Check if this is a candidate for in-set determination.\n    if (shape.holes.size() == 0) {\n      // This shape is a candidate for a test point.\n      if (testPointShape == null || testPointShape.points.size() > filteredPoints.size()) {\n        testPointShape = new BestShape(filteredPoints, mustBeInside);\n      }\n    }\n    \n    pointsList.add(filteredPoints);\n    \n    // Now, do all holes too\n    for (final PolygonDescription hole : shape.holes) {\n      testPointShape = convertPolygon(pointsList, hole, testPointShape, !mustBeInside);\n    }\n    \n    // Done; return the updated test point shape.\n    return testPointShape;\n  }\n\n","sourceOld":"  /** Convert a polygon description to a list of shapes.  Also locate an optimal shape for evaluating a test point.\n   * @param pointsList is the structure to add new polygons to.\n   * @param shape is the current polygon description.\n   * @param testPointShape is the current best choice for a low-level polygon to evaluate.\n   * @return an updated best-choice for a test point polygon, and update the points list.\n   */\n  private static List<GeoPoint> convertPolygon(final List<List<GeoPoint>> pointsList, final PolygonDescription shape, List<GeoPoint> testPointShape) {\n    // First, remove duplicate points.  If degenerate, just ignore the shape.\n    final List<GeoPoint> filteredPoints = filterPoints(shape.points);\n    if (filteredPoints == null) {\n      return testPointShape;\n    }\n    \n    // Non-degenerate.  Check if this is a candidate for in-set determination.\n    if (shape.holes.size() == 0) {\n      // This shape is a candidate for a test point.\n      if (testPointShape == null || testPointShape.size() > filteredPoints.size()) {\n        testPointShape = filteredPoints;\n      }\n    }\n    \n    pointsList.add(filteredPoints);\n    \n    // Now, do all holes too\n    for (final PolygonDescription hole : shape.holes) {\n      testPointShape = convertPolygon(pointsList, hole, testPointShape);\n    }\n    \n    // Done; return the updated test point shape.\n    return testPointShape;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"06729f5a814f91b46fa06d668ae86a5d257ba644":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8825024cedab6612bf17c2b808f4f86abe6e45bb":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","06729f5a814f91b46fa06d668ae86a5d257ba644"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8825024cedab6612bf17c2b808f4f86abe6e45bb"]},"commit2Childs":{"06729f5a814f91b46fa06d668ae86a5d257ba644":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["06729f5a814f91b46fa06d668ae86a5d257ba644","c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"8825024cedab6612bf17c2b808f4f86abe6e45bb":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0":["8825024cedab6612bf17c2b808f4f86abe6e45bb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}