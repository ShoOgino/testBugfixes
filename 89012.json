{"path":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testPreAssignedShardIndex().mjava","commits":[{"id":"9a5b816df64f2b489d1e711be80f9416f9862c1b","date":1487973679,"type":1,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testPreAssignedShardIndex().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testAssignShardIndex().mjava","sourceNew":"  public void testPreAssignedShardIndex() {\n    boolean useConstantScore = random().nextBoolean();\n    int numTopDocs = 2 + random().nextInt(10);\n    ArrayList<TopDocs> topDocs = new ArrayList<>(numTopDocs);\n    Map<Integer, TopDocs> shardResultMapping = new HashMap<>();\n    int numHitsTotal = 0;\n    for (int i = 0; i < numTopDocs; i++) {\n      int numHits = 1 + random().nextInt(10);\n      numHitsTotal += numHits;\n      ScoreDoc[] scoreDocs = new ScoreDoc[numHits];\n      for (int j = 0; j < scoreDocs.length; j++) {\n        float score = useConstantScore ? 1.0f : random().nextFloat();\n        // we set the shard index to index in the list here but shuffle the entire list below\n        scoreDocs[j] = new ScoreDoc((100 * i) + j, score , i);\n      }\n      topDocs.add(new TopDocs(numHits, scoreDocs));\n      shardResultMapping.put(i, topDocs.get(i));\n    }\n    // shuffle the entire thing such that we don't get 1 to 1 mapping of shard index to index in the array\n    // -- well likely ;)\n    Collections.shuffle(topDocs, random());\n    final int from = random().nextInt(numHitsTotal-1);\n    final int size = 1 + random().nextInt(numHitsTotal - from);\n\n    // passing false here means TopDocs.merge uses the incoming ScoreDoc.shardIndex\n    // that we already set, instead of the position of that TopDocs in the array:\n    TopDocs merge = TopDocs.merge(from, size, topDocs.toArray(new TopDocs[0]), false);\n    \n    assertTrue(merge.scoreDocs.length > 0);\n    for (ScoreDoc scoreDoc : merge.scoreDocs) {\n      assertTrue(scoreDoc.shardIndex != -1);\n      TopDocs shardTopDocs = shardResultMapping.get(scoreDoc.shardIndex);\n      assertNotNull(shardTopDocs);\n      boolean found = false;\n      for (ScoreDoc shardScoreDoc : shardTopDocs.scoreDocs) {\n        if (shardScoreDoc == scoreDoc) {\n          found = true;\n          break;\n        }\n      }\n      assertTrue(found);\n    }\n\n    // now ensure merge is stable even if we use our own shard IDs\n    Collections.shuffle(topDocs, random());\n    TopDocs merge2 = TopDocs.merge(from, size, topDocs.toArray(new TopDocs[0]), false);\n    assertArrayEquals(merge.scoreDocs, merge2.scoreDocs);\n  }\n\n","sourceOld":"  public void testAssignShardIndex() {\n    boolean useConstantScore = random().nextBoolean();\n    int numTopDocs = 2 + random().nextInt(10);\n    ArrayList<TopDocs> topDocs = new ArrayList<>(numTopDocs);\n    Map<Integer, TopDocs> shardResultMapping = new HashMap<>();\n    int numHitsTotal = 0;\n    for (int i = 0; i < numTopDocs; i++) {\n      int numHits = 1 + random().nextInt(10);\n      numHitsTotal += numHits;\n      ScoreDoc[] scoreDocs = new ScoreDoc[numHits];\n      for (int j = 0; j < scoreDocs.length; j++) {\n        float score = useConstantScore ? 1.0f : random().nextFloat();\n        scoreDocs[j] = new ScoreDoc((100 * i) + j, score , i);\n        // we set the shard index to index in the list here but shuffle the entire list below\n      }\n      topDocs.add(new TopDocs(numHits, scoreDocs));\n      shardResultMapping.put(i, topDocs.get(i));\n    }\n    // shuffle the entire thing such that we don't get 1 to 1 mapping of shard index to index in the array\n    // -- well likely ;)\n    Collections.shuffle(topDocs, random());\n    final int from = random().nextInt(numHitsTotal-1);\n    final int size = 1 + random().nextInt(numHitsTotal - from);\n    TopDocs merge = TopDocs.merge(from, size, topDocs.toArray(new TopDocs[0]));\n    assertTrue(merge.scoreDocs.length > 0);\n    for (ScoreDoc scoreDoc : merge.scoreDocs) {\n      assertTrue(scoreDoc.shardIndex != -1);\n      TopDocs shardTopDocs = shardResultMapping.get(scoreDoc.shardIndex);\n      assertNotNull(shardTopDocs);\n      boolean found = false;\n      for (ScoreDoc shardScoreDoc : shardTopDocs.scoreDocs) {\n        if (shardScoreDoc == scoreDoc) {\n          found = true;\n          break;\n        }\n      }\n      assertTrue(found);\n    }\n\n    // now ensure merge is stable even if we use our own shard IDs\n    Collections.shuffle(topDocs, random());\n    TopDocs merge2 = TopDocs.merge(from, size, topDocs.toArray(new TopDocs[0]));\n    assertArrayEquals(merge.scoreDocs, merge2.scoreDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testPreAssignedShardIndex().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testPreAssignedShardIndex().mjava","sourceNew":"  public void testPreAssignedShardIndex() {\n    boolean useConstantScore = random().nextBoolean();\n    int numTopDocs = 2 + random().nextInt(10);\n    ArrayList<TopDocs> topDocs = new ArrayList<>(numTopDocs);\n    Map<Integer, TopDocs> shardResultMapping = new HashMap<>();\n    int numHitsTotal = 0;\n    for (int i = 0; i < numTopDocs; i++) {\n      int numHits = 1 + random().nextInt(10);\n      numHitsTotal += numHits;\n      ScoreDoc[] scoreDocs = new ScoreDoc[numHits];\n      for (int j = 0; j < scoreDocs.length; j++) {\n        float score = useConstantScore ? 1.0f : random().nextFloat();\n        // we set the shard index to index in the list here but shuffle the entire list below\n        scoreDocs[j] = new ScoreDoc((100 * i) + j, score , i);\n      }\n      topDocs.add(new TopDocs(new TotalHits(numHits, TotalHits.Relation.EQUAL_TO), scoreDocs));\n      shardResultMapping.put(i, topDocs.get(i));\n    }\n    // shuffle the entire thing such that we don't get 1 to 1 mapping of shard index to index in the array\n    // -- well likely ;)\n    Collections.shuffle(topDocs, random());\n    final int from = random().nextInt(numHitsTotal-1);\n    final int size = 1 + random().nextInt(numHitsTotal - from);\n\n    // passing false here means TopDocs.merge uses the incoming ScoreDoc.shardIndex\n    // that we already set, instead of the position of that TopDocs in the array:\n    TopDocs merge = TopDocs.merge(from, size, topDocs.toArray(new TopDocs[0]), false);\n    \n    assertTrue(merge.scoreDocs.length > 0);\n    for (ScoreDoc scoreDoc : merge.scoreDocs) {\n      assertTrue(scoreDoc.shardIndex != -1);\n      TopDocs shardTopDocs = shardResultMapping.get(scoreDoc.shardIndex);\n      assertNotNull(shardTopDocs);\n      boolean found = false;\n      for (ScoreDoc shardScoreDoc : shardTopDocs.scoreDocs) {\n        if (shardScoreDoc == scoreDoc) {\n          found = true;\n          break;\n        }\n      }\n      assertTrue(found);\n    }\n\n    // now ensure merge is stable even if we use our own shard IDs\n    Collections.shuffle(topDocs, random());\n    TopDocs merge2 = TopDocs.merge(from, size, topDocs.toArray(new TopDocs[0]), false);\n    assertArrayEquals(merge.scoreDocs, merge2.scoreDocs);\n  }\n\n","sourceOld":"  public void testPreAssignedShardIndex() {\n    boolean useConstantScore = random().nextBoolean();\n    int numTopDocs = 2 + random().nextInt(10);\n    ArrayList<TopDocs> topDocs = new ArrayList<>(numTopDocs);\n    Map<Integer, TopDocs> shardResultMapping = new HashMap<>();\n    int numHitsTotal = 0;\n    for (int i = 0; i < numTopDocs; i++) {\n      int numHits = 1 + random().nextInt(10);\n      numHitsTotal += numHits;\n      ScoreDoc[] scoreDocs = new ScoreDoc[numHits];\n      for (int j = 0; j < scoreDocs.length; j++) {\n        float score = useConstantScore ? 1.0f : random().nextFloat();\n        // we set the shard index to index in the list here but shuffle the entire list below\n        scoreDocs[j] = new ScoreDoc((100 * i) + j, score , i);\n      }\n      topDocs.add(new TopDocs(numHits, scoreDocs));\n      shardResultMapping.put(i, topDocs.get(i));\n    }\n    // shuffle the entire thing such that we don't get 1 to 1 mapping of shard index to index in the array\n    // -- well likely ;)\n    Collections.shuffle(topDocs, random());\n    final int from = random().nextInt(numHitsTotal-1);\n    final int size = 1 + random().nextInt(numHitsTotal - from);\n\n    // passing false here means TopDocs.merge uses the incoming ScoreDoc.shardIndex\n    // that we already set, instead of the position of that TopDocs in the array:\n    TopDocs merge = TopDocs.merge(from, size, topDocs.toArray(new TopDocs[0]), false);\n    \n    assertTrue(merge.scoreDocs.length > 0);\n    for (ScoreDoc scoreDoc : merge.scoreDocs) {\n      assertTrue(scoreDoc.shardIndex != -1);\n      TopDocs shardTopDocs = shardResultMapping.get(scoreDoc.shardIndex);\n      assertNotNull(shardTopDocs);\n      boolean found = false;\n      for (ScoreDoc shardScoreDoc : shardTopDocs.scoreDocs) {\n        if (shardScoreDoc == scoreDoc) {\n          found = true;\n          break;\n        }\n      }\n      assertTrue(found);\n    }\n\n    // now ensure merge is stable even if we use our own shard IDs\n    Collections.shuffle(topDocs, random());\n    TopDocs merge2 = TopDocs.merge(from, size, topDocs.toArray(new TopDocs[0]), false);\n    assertArrayEquals(merge.scoreDocs, merge2.scoreDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36510a8e3c1ec60d366b45f8f716e9dc47589661","date":1561989412,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testPreAssignedShardIndex().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testPreAssignedShardIndex().mjava","sourceNew":"  public void testPreAssignedShardIndex() {\n    boolean useConstantScore = random().nextBoolean();\n    int numTopDocs = 2 + random().nextInt(10);\n    ArrayList<TopDocs> topDocs = new ArrayList<>(numTopDocs);\n    Map<Integer, TopDocs> shardResultMapping = new HashMap<>();\n    int numHitsTotal = 0;\n    for (int i = 0; i < numTopDocs; i++) {\n      int numHits = 1 + random().nextInt(10);\n      numHitsTotal += numHits;\n      ScoreDoc[] scoreDocs = new ScoreDoc[numHits];\n      for (int j = 0; j < scoreDocs.length; j++) {\n        float score = useConstantScore ? 1.0f : random().nextFloat();\n        // we set the shard index to index in the list here but shuffle the entire list below\n        scoreDocs[j] = new ScoreDoc((100 * i) + j, score , i);\n      }\n      topDocs.add(new TopDocs(new TotalHits(numHits, TotalHits.Relation.EQUAL_TO), scoreDocs));\n      shardResultMapping.put(i, topDocs.get(i));\n    }\n    // shuffle the entire thing such that we don't get 1 to 1 mapping of shard index to index in the array\n    // -- well likely ;)\n    Collections.shuffle(topDocs, random());\n    final int from = random().nextInt(numHitsTotal-1);\n    final int size = 1 + random().nextInt(numHitsTotal - from);\n\n    // passing false here means TopDocs.merge uses the incoming ScoreDoc.shardIndex\n    // that we already set, instead of the position of that TopDocs in the array:\n    TopDocs merge = TopDocs.merge(from, size, topDocs.toArray(new TopDocs[0]));\n    \n    assertTrue(merge.scoreDocs.length > 0);\n    for (ScoreDoc scoreDoc : merge.scoreDocs) {\n      assertTrue(scoreDoc.shardIndex != -1);\n      TopDocs shardTopDocs = shardResultMapping.get(scoreDoc.shardIndex);\n      assertNotNull(shardTopDocs);\n      boolean found = false;\n      for (ScoreDoc shardScoreDoc : shardTopDocs.scoreDocs) {\n        if (shardScoreDoc == scoreDoc) {\n          found = true;\n          break;\n        }\n      }\n      assertTrue(found);\n    }\n\n    // now ensure merge is stable even if we use our own shard IDs\n    Collections.shuffle(topDocs, random());\n    TopDocs merge2 = TopDocs.merge(from, size, topDocs.toArray(new TopDocs[0]));\n    assertArrayEquals(merge.scoreDocs, merge2.scoreDocs);\n  }\n\n","sourceOld":"  public void testPreAssignedShardIndex() {\n    boolean useConstantScore = random().nextBoolean();\n    int numTopDocs = 2 + random().nextInt(10);\n    ArrayList<TopDocs> topDocs = new ArrayList<>(numTopDocs);\n    Map<Integer, TopDocs> shardResultMapping = new HashMap<>();\n    int numHitsTotal = 0;\n    for (int i = 0; i < numTopDocs; i++) {\n      int numHits = 1 + random().nextInt(10);\n      numHitsTotal += numHits;\n      ScoreDoc[] scoreDocs = new ScoreDoc[numHits];\n      for (int j = 0; j < scoreDocs.length; j++) {\n        float score = useConstantScore ? 1.0f : random().nextFloat();\n        // we set the shard index to index in the list here but shuffle the entire list below\n        scoreDocs[j] = new ScoreDoc((100 * i) + j, score , i);\n      }\n      topDocs.add(new TopDocs(new TotalHits(numHits, TotalHits.Relation.EQUAL_TO), scoreDocs));\n      shardResultMapping.put(i, topDocs.get(i));\n    }\n    // shuffle the entire thing such that we don't get 1 to 1 mapping of shard index to index in the array\n    // -- well likely ;)\n    Collections.shuffle(topDocs, random());\n    final int from = random().nextInt(numHitsTotal-1);\n    final int size = 1 + random().nextInt(numHitsTotal - from);\n\n    // passing false here means TopDocs.merge uses the incoming ScoreDoc.shardIndex\n    // that we already set, instead of the position of that TopDocs in the array:\n    TopDocs merge = TopDocs.merge(from, size, topDocs.toArray(new TopDocs[0]), false);\n    \n    assertTrue(merge.scoreDocs.length > 0);\n    for (ScoreDoc scoreDoc : merge.scoreDocs) {\n      assertTrue(scoreDoc.shardIndex != -1);\n      TopDocs shardTopDocs = shardResultMapping.get(scoreDoc.shardIndex);\n      assertNotNull(shardTopDocs);\n      boolean found = false;\n      for (ScoreDoc shardScoreDoc : shardTopDocs.scoreDocs) {\n        if (shardScoreDoc == scoreDoc) {\n          found = true;\n          break;\n        }\n      }\n      assertTrue(found);\n    }\n\n    // now ensure merge is stable even if we use our own shard IDs\n    Collections.shuffle(topDocs, random());\n    TopDocs merge2 = TopDocs.merge(from, size, topDocs.toArray(new TopDocs[0]), false);\n    assertArrayEquals(merge.scoreDocs, merge2.scoreDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f4f6b0fb6f08ac48f438f03002a283a63cb9992","date":1561992803,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testPreAssignedShardIndex().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testPreAssignedShardIndex().mjava","sourceNew":"  public void testPreAssignedShardIndex() {\n    boolean useConstantScore = random().nextBoolean();\n    int numTopDocs = 2 + random().nextInt(10);\n    ArrayList<TopDocs> topDocs = new ArrayList<>(numTopDocs);\n    Map<Integer, TopDocs> shardResultMapping = new HashMap<>();\n    int numHitsTotal = 0;\n    for (int i = 0; i < numTopDocs; i++) {\n      int numHits = 1 + random().nextInt(10);\n      numHitsTotal += numHits;\n      ScoreDoc[] scoreDocs = new ScoreDoc[numHits];\n      for (int j = 0; j < scoreDocs.length; j++) {\n        float score = useConstantScore ? 1.0f : random().nextFloat();\n        // we set the shard index to index in the list here but shuffle the entire list below\n        scoreDocs[j] = new ScoreDoc((100 * i) + j, score , i);\n      }\n      topDocs.add(new TopDocs(new TotalHits(numHits, TotalHits.Relation.EQUAL_TO), scoreDocs));\n      shardResultMapping.put(i, topDocs.get(i));\n    }\n    // shuffle the entire thing such that we don't get 1 to 1 mapping of shard index to index in the array\n    // -- well likely ;)\n    Collections.shuffle(topDocs, random());\n    final int from = random().nextInt(numHitsTotal-1);\n    final int size = 1 + random().nextInt(numHitsTotal - from);\n\n    // passing false here means TopDocs.merge uses the incoming ScoreDoc.shardIndex\n    // that we already set, instead of the position of that TopDocs in the array:\n    TopDocs merge = TopDocs.merge(from, size, topDocs.toArray(new TopDocs[0]), false);\n    \n    assertTrue(merge.scoreDocs.length > 0);\n    for (ScoreDoc scoreDoc : merge.scoreDocs) {\n      assertTrue(scoreDoc.shardIndex != -1);\n      TopDocs shardTopDocs = shardResultMapping.get(scoreDoc.shardIndex);\n      assertNotNull(shardTopDocs);\n      boolean found = false;\n      for (ScoreDoc shardScoreDoc : shardTopDocs.scoreDocs) {\n        if (shardScoreDoc == scoreDoc) {\n          found = true;\n          break;\n        }\n      }\n      assertTrue(found);\n    }\n\n    // now ensure merge is stable even if we use our own shard IDs\n    Collections.shuffle(topDocs, random());\n    TopDocs merge2 = TopDocs.merge(from, size, topDocs.toArray(new TopDocs[0]), false);\n    assertArrayEquals(merge.scoreDocs, merge2.scoreDocs);\n  }\n\n","sourceOld":"  public void testPreAssignedShardIndex() {\n    boolean useConstantScore = random().nextBoolean();\n    int numTopDocs = 2 + random().nextInt(10);\n    ArrayList<TopDocs> topDocs = new ArrayList<>(numTopDocs);\n    Map<Integer, TopDocs> shardResultMapping = new HashMap<>();\n    int numHitsTotal = 0;\n    for (int i = 0; i < numTopDocs; i++) {\n      int numHits = 1 + random().nextInt(10);\n      numHitsTotal += numHits;\n      ScoreDoc[] scoreDocs = new ScoreDoc[numHits];\n      for (int j = 0; j < scoreDocs.length; j++) {\n        float score = useConstantScore ? 1.0f : random().nextFloat();\n        // we set the shard index to index in the list here but shuffle the entire list below\n        scoreDocs[j] = new ScoreDoc((100 * i) + j, score , i);\n      }\n      topDocs.add(new TopDocs(new TotalHits(numHits, TotalHits.Relation.EQUAL_TO), scoreDocs));\n      shardResultMapping.put(i, topDocs.get(i));\n    }\n    // shuffle the entire thing such that we don't get 1 to 1 mapping of shard index to index in the array\n    // -- well likely ;)\n    Collections.shuffle(topDocs, random());\n    final int from = random().nextInt(numHitsTotal-1);\n    final int size = 1 + random().nextInt(numHitsTotal - from);\n\n    // passing false here means TopDocs.merge uses the incoming ScoreDoc.shardIndex\n    // that we already set, instead of the position of that TopDocs in the array:\n    TopDocs merge = TopDocs.merge(from, size, topDocs.toArray(new TopDocs[0]));\n    \n    assertTrue(merge.scoreDocs.length > 0);\n    for (ScoreDoc scoreDoc : merge.scoreDocs) {\n      assertTrue(scoreDoc.shardIndex != -1);\n      TopDocs shardTopDocs = shardResultMapping.get(scoreDoc.shardIndex);\n      assertNotNull(shardTopDocs);\n      boolean found = false;\n      for (ScoreDoc shardScoreDoc : shardTopDocs.scoreDocs) {\n        if (shardScoreDoc == scoreDoc) {\n          found = true;\n          break;\n        }\n      }\n      assertTrue(found);\n    }\n\n    // now ensure merge is stable even if we use our own shard IDs\n    Collections.shuffle(topDocs, random());\n    TopDocs merge2 = TopDocs.merge(from, size, topDocs.toArray(new TopDocs[0]));\n    assertArrayEquals(merge.scoreDocs, merge2.scoreDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fccd4a691aac1aff06ab8110d8693514a34160c3","date":1562092518,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testPreAssignedShardIndex().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testPreAssignedShardIndex().mjava","sourceNew":"  public void testPreAssignedShardIndex() {\n    boolean useConstantScore = random().nextBoolean();\n    int numTopDocs = 2 + random().nextInt(10);\n    ArrayList<TopDocs> topDocs = new ArrayList<>(numTopDocs);\n    Map<Integer, TopDocs> shardResultMapping = new HashMap<>();\n    int numHitsTotal = 0;\n    for (int i = 0; i < numTopDocs; i++) {\n      int numHits = 1 + random().nextInt(10);\n      numHitsTotal += numHits;\n      ScoreDoc[] scoreDocs = new ScoreDoc[numHits];\n      for (int j = 0; j < scoreDocs.length; j++) {\n        float score = useConstantScore ? 1.0f : random().nextFloat();\n        // we set the shard index to index in the list here but shuffle the entire list below\n        scoreDocs[j] = new ScoreDoc((100 * i) + j, score , i);\n      }\n      topDocs.add(new TopDocs(new TotalHits(numHits, TotalHits.Relation.EQUAL_TO), scoreDocs));\n      shardResultMapping.put(i, topDocs.get(i));\n    }\n    // shuffle the entire thing such that we don't get 1 to 1 mapping of shard index to index in the array\n    // -- well likely ;)\n    Collections.shuffle(topDocs, random());\n    final int from = random().nextInt(numHitsTotal-1);\n    final int size = 1 + random().nextInt(numHitsTotal - from);\n\n    // passing false here means TopDocs.merge uses the incoming ScoreDoc.shardIndex\n    // that we already set, instead of the position of that TopDocs in the array:\n    TopDocs merge = TopDocs.merge(from, size, topDocs.toArray(new TopDocs[0]));\n    \n    assertTrue(merge.scoreDocs.length > 0);\n    for (ScoreDoc scoreDoc : merge.scoreDocs) {\n      assertTrue(scoreDoc.shardIndex != -1);\n      TopDocs shardTopDocs = shardResultMapping.get(scoreDoc.shardIndex);\n      assertNotNull(shardTopDocs);\n      boolean found = false;\n      for (ScoreDoc shardScoreDoc : shardTopDocs.scoreDocs) {\n        if (shardScoreDoc == scoreDoc) {\n          found = true;\n          break;\n        }\n      }\n      assertTrue(found);\n    }\n\n    // now ensure merge is stable even if we use our own shard IDs\n    Collections.shuffle(topDocs, random());\n    TopDocs merge2 = TopDocs.merge(from, size, topDocs.toArray(new TopDocs[0]));\n    assertArrayEquals(merge.scoreDocs, merge2.scoreDocs);\n  }\n\n","sourceOld":"  public void testPreAssignedShardIndex() {\n    boolean useConstantScore = random().nextBoolean();\n    int numTopDocs = 2 + random().nextInt(10);\n    ArrayList<TopDocs> topDocs = new ArrayList<>(numTopDocs);\n    Map<Integer, TopDocs> shardResultMapping = new HashMap<>();\n    int numHitsTotal = 0;\n    for (int i = 0; i < numTopDocs; i++) {\n      int numHits = 1 + random().nextInt(10);\n      numHitsTotal += numHits;\n      ScoreDoc[] scoreDocs = new ScoreDoc[numHits];\n      for (int j = 0; j < scoreDocs.length; j++) {\n        float score = useConstantScore ? 1.0f : random().nextFloat();\n        // we set the shard index to index in the list here but shuffle the entire list below\n        scoreDocs[j] = new ScoreDoc((100 * i) + j, score , i);\n      }\n      topDocs.add(new TopDocs(new TotalHits(numHits, TotalHits.Relation.EQUAL_TO), scoreDocs));\n      shardResultMapping.put(i, topDocs.get(i));\n    }\n    // shuffle the entire thing such that we don't get 1 to 1 mapping of shard index to index in the array\n    // -- well likely ;)\n    Collections.shuffle(topDocs, random());\n    final int from = random().nextInt(numHitsTotal-1);\n    final int size = 1 + random().nextInt(numHitsTotal - from);\n\n    // passing false here means TopDocs.merge uses the incoming ScoreDoc.shardIndex\n    // that we already set, instead of the position of that TopDocs in the array:\n    TopDocs merge = TopDocs.merge(from, size, topDocs.toArray(new TopDocs[0]), false);\n    \n    assertTrue(merge.scoreDocs.length > 0);\n    for (ScoreDoc scoreDoc : merge.scoreDocs) {\n      assertTrue(scoreDoc.shardIndex != -1);\n      TopDocs shardTopDocs = shardResultMapping.get(scoreDoc.shardIndex);\n      assertNotNull(shardTopDocs);\n      boolean found = false;\n      for (ScoreDoc shardScoreDoc : shardTopDocs.scoreDocs) {\n        if (shardScoreDoc == scoreDoc) {\n          found = true;\n          break;\n        }\n      }\n      assertTrue(found);\n    }\n\n    // now ensure merge is stable even if we use our own shard IDs\n    Collections.shuffle(topDocs, random());\n    TopDocs merge2 = TopDocs.merge(from, size, topDocs.toArray(new TopDocs[0]), false);\n    assertArrayEquals(merge.scoreDocs, merge2.scoreDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"36510a8e3c1ec60d366b45f8f716e9dc47589661":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"9a5b816df64f2b489d1e711be80f9416f9862c1b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fccd4a691aac1aff06ab8110d8693514a34160c3":["5f4f6b0fb6f08ac48f438f03002a283a63cb9992"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"83788ad129a5154d5c6562c4e8ce3db48793aada":["9a5b816df64f2b489d1e711be80f9416f9862c1b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fccd4a691aac1aff06ab8110d8693514a34160c3"],"5f4f6b0fb6f08ac48f438f03002a283a63cb9992":["36510a8e3c1ec60d366b45f8f716e9dc47589661"]},"commit2Childs":{"36510a8e3c1ec60d366b45f8f716e9dc47589661":["5f4f6b0fb6f08ac48f438f03002a283a63cb9992"],"9a5b816df64f2b489d1e711be80f9416f9862c1b":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"fccd4a691aac1aff06ab8110d8693514a34160c3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9a5b816df64f2b489d1e711be80f9416f9862c1b"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["36510a8e3c1ec60d366b45f8f716e9dc47589661"],"5f4f6b0fb6f08ac48f438f03002a283a63cb9992":["fccd4a691aac1aff06ab8110d8693514a34160c3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}