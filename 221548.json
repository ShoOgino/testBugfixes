{"path":"src/java/org/apache/solr/search/SolrIndexSearcher#initRegenerators(SolrConfig).mjava","commits":[{"id":"6d6338c87060be5f66757a94945975f3bbd377a9","date":1189278234,"type":0,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/SolrIndexSearcher#initRegenerators(SolrConfig).mjava","pathOld":"/dev/null","sourceNew":"  //\n  // Set default regenerators on filter and query caches if they don't have any\n  //\n  public static void initRegenerators(SolrConfig solrConfig) {\n    if (solrConfig.filterCacheConfig != null && solrConfig.filterCacheConfig.getRegenerator() == null) {\n      solrConfig.filterCacheConfig.setRegenerator(\n              new CacheRegenerator() {\n                public boolean regenerateItem(SolrIndexSearcher newSearcher, SolrCache newCache, SolrCache oldCache, Object oldKey, Object oldVal) throws IOException {\n                  newSearcher.cacheDocSet((Query)oldKey, null, false);\n                  return true;\n                }\n              }\n      );\n    }\n\n    if (solrConfig.queryResultCacheConfig != null && solrConfig.queryResultCacheConfig.getRegenerator() == null) {\n      final int queryResultWindowSize = solrConfig.queryResultWindowSize;\n      solrConfig.queryResultCacheConfig.setRegenerator(\n              new CacheRegenerator() {\n                public boolean regenerateItem(SolrIndexSearcher newSearcher, SolrCache newCache, SolrCache oldCache, Object oldKey, Object oldVal) throws IOException {\n                  QueryResultKey key = (QueryResultKey)oldKey;\n                  int nDocs=1;\n                  // request 1 doc and let caching round up to the next window size...\n                  // unless the window size is <=1, in which case we will pick\n                  // the minimum of the number of documents requested last time and\n                  // a reasonable number such as 40.\n                  // TODO: make more configurable later...\n\n                  if (queryResultWindowSize<=1) {\n                    DocList oldList = (DocList)oldVal;\n                    int oldnDocs = oldList.offset() + oldList.size();\n                    // 40 has factors of 2,4,5,10,20\n                    nDocs = Math.min(oldnDocs,40);\n                  }\n\n                  DocListAndSet ret = new DocListAndSet();\n                  int flags=NO_CHECK_QCACHE | key.nc_flags;\n\n                  newSearcher.getDocListC(ret, key.query, key.filters, null, key.sort, 0, nDocs, flags);\n                  return true;\n                }\n              }\n      );\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db25c1f61b5ae826f10777da6551a832703967d5","date":1215306972,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/SolrIndexSearcher#initRegenerators(SolrConfig).mjava","pathOld":"src/java/org/apache/solr/search/SolrIndexSearcher#initRegenerators(SolrConfig).mjava","sourceNew":"  //\n  // Set default regenerators on filter and query caches if they don't have any\n  //\n  public static void initRegenerators(SolrConfig solrConfig) {\n    if (solrConfig.filterCacheConfig != null && solrConfig.filterCacheConfig.getRegenerator() == null) {\n      solrConfig.filterCacheConfig.setRegenerator(\n              new CacheRegenerator() {\n                public boolean regenerateItem(SolrIndexSearcher newSearcher, SolrCache newCache, SolrCache oldCache, Object oldKey, Object oldVal) throws IOException {\n                  newSearcher.cacheDocSet((Query)oldKey, null, false);\n                  return true;\n                }\n              }\n      );\n    }\n\n    if (solrConfig.queryResultCacheConfig != null && solrConfig.queryResultCacheConfig.getRegenerator() == null) {\n      final int queryResultWindowSize = solrConfig.queryResultWindowSize;\n      solrConfig.queryResultCacheConfig.setRegenerator(\n              new CacheRegenerator() {\n                public boolean regenerateItem(SolrIndexSearcher newSearcher, SolrCache newCache, SolrCache oldCache, Object oldKey, Object oldVal) throws IOException {\n                  QueryResultKey key = (QueryResultKey)oldKey;\n                  int nDocs=1;\n                  // request 1 doc and let caching round up to the next window size...\n                  // unless the window size is <=1, in which case we will pick\n                  // the minimum of the number of documents requested last time and\n                  // a reasonable number such as 40.\n                  // TODO: make more configurable later...\n\n                  if (queryResultWindowSize<=1) {\n                    DocList oldList = (DocList)oldVal;\n                    int oldnDocs = oldList.offset() + oldList.size();\n                    // 40 has factors of 2,4,5,10,20\n                    nDocs = Math.min(oldnDocs,40);\n                  }\n\n                  int flags=NO_CHECK_QCACHE | key.nc_flags;\n                  QueryCommand qc = new QueryCommand();\n                  qc.setQuery(key.query)\n                    .setFilterList(key.filters)\n                    .setSort(key.sort)\n                    .setLen(nDocs)\n                    .setSupersetMaxDoc(nDocs)\n                    .setFlags(flags);\n                  QueryResult qr = new QueryResult();\n                  newSearcher.getDocListC(qr,qc);\n                  return true;\n                }\n              }\n      );\n    }\n  }\n\n","sourceOld":"  //\n  // Set default regenerators on filter and query caches if they don't have any\n  //\n  public static void initRegenerators(SolrConfig solrConfig) {\n    if (solrConfig.filterCacheConfig != null && solrConfig.filterCacheConfig.getRegenerator() == null) {\n      solrConfig.filterCacheConfig.setRegenerator(\n              new CacheRegenerator() {\n                public boolean regenerateItem(SolrIndexSearcher newSearcher, SolrCache newCache, SolrCache oldCache, Object oldKey, Object oldVal) throws IOException {\n                  newSearcher.cacheDocSet((Query)oldKey, null, false);\n                  return true;\n                }\n              }\n      );\n    }\n\n    if (solrConfig.queryResultCacheConfig != null && solrConfig.queryResultCacheConfig.getRegenerator() == null) {\n      final int queryResultWindowSize = solrConfig.queryResultWindowSize;\n      solrConfig.queryResultCacheConfig.setRegenerator(\n              new CacheRegenerator() {\n                public boolean regenerateItem(SolrIndexSearcher newSearcher, SolrCache newCache, SolrCache oldCache, Object oldKey, Object oldVal) throws IOException {\n                  QueryResultKey key = (QueryResultKey)oldKey;\n                  int nDocs=1;\n                  // request 1 doc and let caching round up to the next window size...\n                  // unless the window size is <=1, in which case we will pick\n                  // the minimum of the number of documents requested last time and\n                  // a reasonable number such as 40.\n                  // TODO: make more configurable later...\n\n                  if (queryResultWindowSize<=1) {\n                    DocList oldList = (DocList)oldVal;\n                    int oldnDocs = oldList.offset() + oldList.size();\n                    // 40 has factors of 2,4,5,10,20\n                    nDocs = Math.min(oldnDocs,40);\n                  }\n\n                  DocListAndSet ret = new DocListAndSet();\n                  int flags=NO_CHECK_QCACHE | key.nc_flags;\n\n                  newSearcher.getDocListC(ret, key.query, key.filters, null, key.sort, 0, nDocs, flags);\n                  return true;\n                }\n              }\n      );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa89a35683d73665c61d7af1d16f41649c25e5a7","date":1228684315,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/SolrIndexSearcher#initRegenerators(SolrConfig).mjava","pathOld":"src/java/org/apache/solr/search/SolrIndexSearcher#initRegenerators(SolrConfig).mjava","sourceNew":"  //\n  // Set default regenerators on filter and query caches if they don't have any\n  //\n  public static void initRegenerators(SolrConfig solrConfig) {\n    if (solrConfig.fieldValueCacheConfig != null && solrConfig.fieldValueCacheConfig.getRegenerator() == null) {\n      solrConfig.fieldValueCacheConfig.setRegenerator(\n              new CacheRegenerator() {\n                public boolean regenerateItem(SolrIndexSearcher newSearcher, SolrCache newCache, SolrCache oldCache, Object oldKey, Object oldVal) throws IOException {\n                  if (oldVal instanceof UnInvertedField) {\n                    UnInvertedField.getUnInvertedField((String)oldKey, newSearcher);\n                  }\n                  return true;\n                }\n              }\n      );\n    }\n\n    if (solrConfig.filterCacheConfig != null && solrConfig.filterCacheConfig.getRegenerator() == null) {\n      solrConfig.filterCacheConfig.setRegenerator(\n              new CacheRegenerator() {\n                public boolean regenerateItem(SolrIndexSearcher newSearcher, SolrCache newCache, SolrCache oldCache, Object oldKey, Object oldVal) throws IOException {\n                  newSearcher.cacheDocSet((Query)oldKey, null, false);\n                  return true;\n                }\n              }\n      );\n    }\n\n    if (solrConfig.queryResultCacheConfig != null && solrConfig.queryResultCacheConfig.getRegenerator() == null) {\n      final int queryResultWindowSize = solrConfig.queryResultWindowSize;\n      solrConfig.queryResultCacheConfig.setRegenerator(\n              new CacheRegenerator() {\n                public boolean regenerateItem(SolrIndexSearcher newSearcher, SolrCache newCache, SolrCache oldCache, Object oldKey, Object oldVal) throws IOException {\n                  QueryResultKey key = (QueryResultKey)oldKey;\n                  int nDocs=1;\n                  // request 1 doc and let caching round up to the next window size...\n                  // unless the window size is <=1, in which case we will pick\n                  // the minimum of the number of documents requested last time and\n                  // a reasonable number such as 40.\n                  // TODO: make more configurable later...\n\n                  if (queryResultWindowSize<=1) {\n                    DocList oldList = (DocList)oldVal;\n                    int oldnDocs = oldList.offset() + oldList.size();\n                    // 40 has factors of 2,4,5,10,20\n                    nDocs = Math.min(oldnDocs,40);\n                  }\n\n                  int flags=NO_CHECK_QCACHE | key.nc_flags;\n                  QueryCommand qc = new QueryCommand();\n                  qc.setQuery(key.query)\n                    .setFilterList(key.filters)\n                    .setSort(key.sort)\n                    .setLen(nDocs)\n                    .setSupersetMaxDoc(nDocs)\n                    .setFlags(flags);\n                  QueryResult qr = new QueryResult();\n                  newSearcher.getDocListC(qr,qc);\n                  return true;\n                }\n              }\n      );\n    }\n  }\n\n","sourceOld":"  //\n  // Set default regenerators on filter and query caches if they don't have any\n  //\n  public static void initRegenerators(SolrConfig solrConfig) {\n    if (solrConfig.filterCacheConfig != null && solrConfig.filterCacheConfig.getRegenerator() == null) {\n      solrConfig.filterCacheConfig.setRegenerator(\n              new CacheRegenerator() {\n                public boolean regenerateItem(SolrIndexSearcher newSearcher, SolrCache newCache, SolrCache oldCache, Object oldKey, Object oldVal) throws IOException {\n                  newSearcher.cacheDocSet((Query)oldKey, null, false);\n                  return true;\n                }\n              }\n      );\n    }\n\n    if (solrConfig.queryResultCacheConfig != null && solrConfig.queryResultCacheConfig.getRegenerator() == null) {\n      final int queryResultWindowSize = solrConfig.queryResultWindowSize;\n      solrConfig.queryResultCacheConfig.setRegenerator(\n              new CacheRegenerator() {\n                public boolean regenerateItem(SolrIndexSearcher newSearcher, SolrCache newCache, SolrCache oldCache, Object oldKey, Object oldVal) throws IOException {\n                  QueryResultKey key = (QueryResultKey)oldKey;\n                  int nDocs=1;\n                  // request 1 doc and let caching round up to the next window size...\n                  // unless the window size is <=1, in which case we will pick\n                  // the minimum of the number of documents requested last time and\n                  // a reasonable number such as 40.\n                  // TODO: make more configurable later...\n\n                  if (queryResultWindowSize<=1) {\n                    DocList oldList = (DocList)oldVal;\n                    int oldnDocs = oldList.offset() + oldList.size();\n                    // 40 has factors of 2,4,5,10,20\n                    nDocs = Math.min(oldnDocs,40);\n                  }\n\n                  int flags=NO_CHECK_QCACHE | key.nc_flags;\n                  QueryCommand qc = new QueryCommand();\n                  qc.setQuery(key.query)\n                    .setFilterList(key.filters)\n                    .setSort(key.sort)\n                    .setLen(nDocs)\n                    .setSupersetMaxDoc(nDocs)\n                    .setFlags(flags);\n                  QueryResult qr = new QueryResult();\n                  newSearcher.getDocListC(qr,qc);\n                  return true;\n                }\n              }\n      );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/SolrIndexSearcher#initRegenerators(SolrConfig).mjava","pathOld":"src/java/org/apache/solr/search/SolrIndexSearcher#initRegenerators(SolrConfig).mjava","sourceNew":"  //\n  // Set default regenerators on filter and query caches if they don't have any\n  //\n  public static void initRegenerators(SolrConfig solrConfig) {\n    if (solrConfig.fieldValueCacheConfig != null && solrConfig.fieldValueCacheConfig.getRegenerator() == null) {\n      solrConfig.fieldValueCacheConfig.setRegenerator(\n              new CacheRegenerator() {\n                public boolean regenerateItem(SolrIndexSearcher newSearcher, SolrCache newCache, SolrCache oldCache, Object oldKey, Object oldVal) throws IOException {\n                  if (oldVal instanceof UnInvertedField) {\n                    UnInvertedField.getUnInvertedField((String)oldKey, newSearcher);\n                  }\n                  return true;\n                }\n              }\n      );\n    }\n\n    if (solrConfig.filterCacheConfig != null && solrConfig.filterCacheConfig.getRegenerator() == null) {\n      solrConfig.filterCacheConfig.setRegenerator(\n              new CacheRegenerator() {\n                public boolean regenerateItem(SolrIndexSearcher newSearcher, SolrCache newCache, SolrCache oldCache, Object oldKey, Object oldVal) throws IOException {\n                  newSearcher.cacheDocSet((Query)oldKey, null, false);\n                  return true;\n                }\n              }\n      );\n    }\n\n    if (solrConfig.queryResultCacheConfig != null && solrConfig.queryResultCacheConfig.getRegenerator() == null) {\n      final int queryResultWindowSize = solrConfig.queryResultWindowSize;\n      solrConfig.queryResultCacheConfig.setRegenerator(\n              new CacheRegenerator() {\n                public boolean regenerateItem(SolrIndexSearcher newSearcher, SolrCache newCache, SolrCache oldCache, Object oldKey, Object oldVal) throws IOException {\n                  QueryResultKey key = (QueryResultKey)oldKey;\n                  int nDocs=1;\n                  // request 1 doc and let caching round up to the next window size...\n                  // unless the window size is <=1, in which case we will pick\n                  // the minimum of the number of documents requested last time and\n                  // a reasonable number such as 40.\n                  // TODO: make more configurable later...\n\n                  if (queryResultWindowSize<=1) {\n                    DocList oldList = (DocList)oldVal;\n                    int oldnDocs = oldList.offset() + oldList.size();\n                    // 40 has factors of 2,4,5,10,20\n                    nDocs = Math.min(oldnDocs,40);\n                  }\n\n                  int flags=NO_CHECK_QCACHE | key.nc_flags;\n                  QueryCommand qc = new QueryCommand();\n                  qc.setQuery(key.query)\n                    .setFilterList(key.filters)\n                    .setSort(key.sort)\n                    .setLen(nDocs)\n                    .setSupersetMaxDoc(nDocs)\n                    .setFlags(flags);\n                  QueryResult qr = new QueryResult();\n                  newSearcher.getDocListC(qr,qc);\n                  return true;\n                }\n              }\n      );\n    }\n  }\n\n","sourceOld":"  //\n  // Set default regenerators on filter and query caches if they don't have any\n  //\n  public static void initRegenerators(SolrConfig solrConfig) {\n    if (solrConfig.fieldValueCacheConfig != null && solrConfig.fieldValueCacheConfig.getRegenerator() == null) {\n      solrConfig.fieldValueCacheConfig.setRegenerator(\n              new CacheRegenerator() {\n                public boolean regenerateItem(SolrIndexSearcher newSearcher, SolrCache newCache, SolrCache oldCache, Object oldKey, Object oldVal) throws IOException {\n                  if (oldVal instanceof UnInvertedField) {\n                    UnInvertedField.getUnInvertedField((String)oldKey, newSearcher);\n                  }\n                  return true;\n                }\n              }\n      );\n    }\n\n    if (solrConfig.filterCacheConfig != null && solrConfig.filterCacheConfig.getRegenerator() == null) {\n      solrConfig.filterCacheConfig.setRegenerator(\n              new CacheRegenerator() {\n                public boolean regenerateItem(SolrIndexSearcher newSearcher, SolrCache newCache, SolrCache oldCache, Object oldKey, Object oldVal) throws IOException {\n                  newSearcher.cacheDocSet((Query)oldKey, null, false);\n                  return true;\n                }\n              }\n      );\n    }\n\n    if (solrConfig.queryResultCacheConfig != null && solrConfig.queryResultCacheConfig.getRegenerator() == null) {\n      final int queryResultWindowSize = solrConfig.queryResultWindowSize;\n      solrConfig.queryResultCacheConfig.setRegenerator(\n              new CacheRegenerator() {\n                public boolean regenerateItem(SolrIndexSearcher newSearcher, SolrCache newCache, SolrCache oldCache, Object oldKey, Object oldVal) throws IOException {\n                  QueryResultKey key = (QueryResultKey)oldKey;\n                  int nDocs=1;\n                  // request 1 doc and let caching round up to the next window size...\n                  // unless the window size is <=1, in which case we will pick\n                  // the minimum of the number of documents requested last time and\n                  // a reasonable number such as 40.\n                  // TODO: make more configurable later...\n\n                  if (queryResultWindowSize<=1) {\n                    DocList oldList = (DocList)oldVal;\n                    int oldnDocs = oldList.offset() + oldList.size();\n                    // 40 has factors of 2,4,5,10,20\n                    nDocs = Math.min(oldnDocs,40);\n                  }\n\n                  int flags=NO_CHECK_QCACHE | key.nc_flags;\n                  QueryCommand qc = new QueryCommand();\n                  qc.setQuery(key.query)\n                    .setFilterList(key.filters)\n                    .setSort(key.sort)\n                    .setLen(nDocs)\n                    .setSupersetMaxDoc(nDocs)\n                    .setFlags(flags);\n                  QueryResult qr = new QueryResult();\n                  newSearcher.getDocListC(qr,qc);\n                  return true;\n                }\n              }\n      );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fa89a35683d73665c61d7af1d16f41649c25e5a7":["db25c1f61b5ae826f10777da6551a832703967d5"],"6d6338c87060be5f66757a94945975f3bbd377a9":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"db25c1f61b5ae826f10777da6551a832703967d5":["6d6338c87060be5f66757a94945975f3bbd377a9"],"ad94625fb8d088209f46650c8097196fec67f00c":["fa89a35683d73665c61d7af1d16f41649c25e5a7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"fa89a35683d73665c61d7af1d16f41649c25e5a7":["ad94625fb8d088209f46650c8097196fec67f00c"],"6d6338c87060be5f66757a94945975f3bbd377a9":["db25c1f61b5ae826f10777da6551a832703967d5"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["6d6338c87060be5f66757a94945975f3bbd377a9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"db25c1f61b5ae826f10777da6551a832703967d5":["fa89a35683d73665c61d7af1d16f41649c25e5a7"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}