{"path":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/ThreadPumper#start(Runnable,BufferedReader,PrintStream,Writer).mjava","commits":[{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/ThreadPumper#start(Runnable,BufferedReader,PrintStream,Writer).mjava","pathOld":"/dev/null","sourceNew":"  public static Thread start(final Runnable onExit, final BufferedReader from, final PrintStream to, final Writer toFile) {\n    Thread t = new Thread() {\n        @Override\n        public void run() {\n          try {\n            Pattern logTimeStart = Pattern.compile(\"^[0-9\\\\.]+s .*\");\n            String line;\n            while ((line = from.readLine()) != null) {\n              if (toFile != null) {\n                toFile.write(line);\n                toFile.write(\"\\n\");\n                toFile.flush();\n              } else if (logTimeStart.matcher(line).matches()) {\n                // Already a well-formed log output:\n                System.out.println(line);\n              } else {\n                TestNRTReplication.message(line);\n              }\n            }\n            // Sub-process finished\n          } catch (IOException e) {\n            System.err.println(\"ignore IOExc reading from forked process pipe: \" + e);\n          } finally {\n            onExit.run();\n          }\n        }\n      };\n    t.start();\n    return t;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec317d5d3de749e12abcc9e6f976d765638fe9e2","date":1454411397,"type":5,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/ThreadPumper#start(Runnable,BufferedReader,PrintStream,Writer,AtomicBoolean).mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/ThreadPumper#start(Runnable,BufferedReader,PrintStream,Writer).mjava","sourceNew":"  public static Thread start(final Runnable onExit, final BufferedReader from, final PrintStream to, final Writer toFile, final AtomicBoolean nodeClosing) {\n    Thread t = new Thread() {\n        @Override\n        public void run() {\n          try {\n            Pattern logTimeStart = Pattern.compile(\"^[0-9\\\\.]+s .*\");\n            String line;\n            while ((line = from.readLine()) != null) {\n              if (toFile != null) {\n                toFile.write(line);\n                toFile.write(\"\\n\");\n                toFile.flush();\n              } else if (logTimeStart.matcher(line).matches()) {\n                // Already a well-formed log output:\n                System.out.println(line);\n              } else {\n                TestNRTReplication.message(line);\n              }\n              if (line.contains(\"now force close server socket after\")) {\n                nodeClosing.set(true);\n              }\n            }\n            // Sub-process finished\n          } catch (IOException e) {\n            System.err.println(\"ignore IOExc reading from forked process pipe: \" + e);\n          } finally {\n            onExit.run();\n          }\n        }\n      };\n    t.start();\n    return t;\n  }\n\n","sourceOld":"  public static Thread start(final Runnable onExit, final BufferedReader from, final PrintStream to, final Writer toFile) {\n    Thread t = new Thread() {\n        @Override\n        public void run() {\n          try {\n            Pattern logTimeStart = Pattern.compile(\"^[0-9\\\\.]+s .*\");\n            String line;\n            while ((line = from.readLine()) != null) {\n              if (toFile != null) {\n                toFile.write(line);\n                toFile.write(\"\\n\");\n                toFile.flush();\n              } else if (logTimeStart.matcher(line).matches()) {\n                // Already a well-formed log output:\n                System.out.println(line);\n              } else {\n                TestNRTReplication.message(line);\n              }\n            }\n            // Sub-process finished\n          } catch (IOException e) {\n            System.err.println(\"ignore IOExc reading from forked process pipe: \" + e);\n          } finally {\n            onExit.run();\n          }\n        }\n      };\n    t.start();\n    return t;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ec317d5d3de749e12abcc9e6f976d765638fe9e2":["0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"ec317d5d3de749e12abcc9e6f976d765638fe9e2":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["ec317d5d3de749e12abcc9e6f976d765638fe9e2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ec317d5d3de749e12abcc9e6f976d765638fe9e2","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}