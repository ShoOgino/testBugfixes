{"path":"lucene/core/src/java/org/apache/lucene/search/MinShouldMatchSumScorer#cost(Collection[Scorer],int).mjava","commits":[{"id":"251e6911800e3a02e1da3bfd4dc49a914aef9778","date":1423063783,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/MinShouldMatchSumScorer#cost(Collection[Scorer],int).mjava","pathOld":"/dev/null","sourceNew":"  private static long cost(Collection<Scorer> scorers, int minShouldMatch) {\n    // the idea here is the following: a boolean query c1,c2,...cn with minShouldMatch=m\n    // could be rewritten to:\n    // (c1 AND (c2..cn|msm=m-1)) OR (!c1 AND (c2..cn|msm=m))\n    // if we assume that clauses come in ascending cost, then\n    // the cost of the first part is the cost of c1 (because the cost of a conjunction is\n    // the cost of the least costly clause)\n    // the cost of the second part is the cost of finding m matches among the c2...cn\n    // remaining clauses\n    // since it is a disjunction overall, the total cost is the sum of the costs of these\n    // two parts\n\n    // If we recurse infinitely, we find out that the cost of a msm query is the sum of the\n    // costs of the num_scorers - minShouldMatch + 1 least costly scorers\n    final PriorityQueue<Scorer> pq = new PriorityQueue<Scorer>(scorers.size() - minShouldMatch + 1) {\n      @Override\n      protected boolean lessThan(Scorer a, Scorer b) {\n        return a.cost() > b.cost();\n      }\n    };\n    for (Scorer scorer : scorers) {\n      pq.insertWithOverflow(scorer);\n    }\n    long cost = 0;\n    for (Scorer scorer = pq.pop(); scorer != null; scorer = pq.pop()) {\n      cost += scorer.cost();\n    }\n    return cost;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7dd748bb245633a8195281556bb0e68a6ea97d18","date":1449755030,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/MinShouldMatchSumScorer#cost(Collection[Scorer],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/MinShouldMatchSumScorer#cost(Collection[Scorer],int).mjava","sourceNew":"  private static long cost(Collection<Scorer> scorers, int minShouldMatch) {\n    // the idea here is the following: a boolean query c1,c2,...cn with minShouldMatch=m\n    // could be rewritten to:\n    // (c1 AND (c2..cn|msm=m-1)) OR (!c1 AND (c2..cn|msm=m))\n    // if we assume that clauses come in ascending cost, then\n    // the cost of the first part is the cost of c1 (because the cost of a conjunction is\n    // the cost of the least costly clause)\n    // the cost of the second part is the cost of finding m matches among the c2...cn\n    // remaining clauses\n    // since it is a disjunction overall, the total cost is the sum of the costs of these\n    // two parts\n\n    // If we recurse infinitely, we find out that the cost of a msm query is the sum of the\n    // costs of the num_scorers - minShouldMatch + 1 least costly scorers\n    final PriorityQueue<Scorer> pq = new PriorityQueue<Scorer>(scorers.size() - minShouldMatch + 1) {\n      @Override\n      protected boolean lessThan(Scorer a, Scorer b) {\n        return a.iterator().cost() > b.iterator().cost();\n      }\n    };\n    for (Scorer scorer : scorers) {\n      pq.insertWithOverflow(scorer);\n    }\n    long cost = 0;\n    for (Scorer scorer = pq.pop(); scorer != null; scorer = pq.pop()) {\n      cost += scorer.iterator().cost();\n    }\n    return cost;\n  }\n\n","sourceOld":"  private static long cost(Collection<Scorer> scorers, int minShouldMatch) {\n    // the idea here is the following: a boolean query c1,c2,...cn with minShouldMatch=m\n    // could be rewritten to:\n    // (c1 AND (c2..cn|msm=m-1)) OR (!c1 AND (c2..cn|msm=m))\n    // if we assume that clauses come in ascending cost, then\n    // the cost of the first part is the cost of c1 (because the cost of a conjunction is\n    // the cost of the least costly clause)\n    // the cost of the second part is the cost of finding m matches among the c2...cn\n    // remaining clauses\n    // since it is a disjunction overall, the total cost is the sum of the costs of these\n    // two parts\n\n    // If we recurse infinitely, we find out that the cost of a msm query is the sum of the\n    // costs of the num_scorers - minShouldMatch + 1 least costly scorers\n    final PriorityQueue<Scorer> pq = new PriorityQueue<Scorer>(scorers.size() - minShouldMatch + 1) {\n      @Override\n      protected boolean lessThan(Scorer a, Scorer b) {\n        return a.cost() > b.cost();\n      }\n    };\n    for (Scorer scorer : scorers) {\n      pq.insertWithOverflow(scorer);\n    }\n    long cost = 0;\n    for (Scorer scorer = pq.pop(); scorer != null; scorer = pq.pop()) {\n      cost += scorer.cost();\n    }\n    return cost;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dca67e06c96e95a8d9ef07418b6299bfd981523b","date":1484639518,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/MinShouldMatchSumScorer#cost(LongStream,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/MinShouldMatchSumScorer#cost(Collection[Scorer],int).mjava","sourceNew":"  static long cost(LongStream costs, int numScorers, int minShouldMatch) {\n    // the idea here is the following: a boolean query c1,c2,...cn with minShouldMatch=m\n    // could be rewritten to:\n    // (c1 AND (c2..cn|msm=m-1)) OR (!c1 AND (c2..cn|msm=m))\n    // if we assume that clauses come in ascending cost, then\n    // the cost of the first part is the cost of c1 (because the cost of a conjunction is\n    // the cost of the least costly clause)\n    // the cost of the second part is the cost of finding m matches among the c2...cn\n    // remaining clauses\n    // since it is a disjunction overall, the total cost is the sum of the costs of these\n    // two parts\n\n    // If we recurse infinitely, we find out that the cost of a msm query is the sum of the\n    // costs of the num_scorers - minShouldMatch + 1 least costly scorers\n    final PriorityQueue<Long> pq = new PriorityQueue<Long>(numScorers - minShouldMatch + 1) {\n      @Override\n      protected boolean lessThan(Long a, Long b) {\n        return a > b;\n      }\n    };\n    costs.forEach(pq::insertWithOverflow);\n    return StreamSupport.stream(pq.spliterator(), false).mapToLong(Number::longValue).sum();\n  }\n\n","sourceOld":"  private static long cost(Collection<Scorer> scorers, int minShouldMatch) {\n    // the idea here is the following: a boolean query c1,c2,...cn with minShouldMatch=m\n    // could be rewritten to:\n    // (c1 AND (c2..cn|msm=m-1)) OR (!c1 AND (c2..cn|msm=m))\n    // if we assume that clauses come in ascending cost, then\n    // the cost of the first part is the cost of c1 (because the cost of a conjunction is\n    // the cost of the least costly clause)\n    // the cost of the second part is the cost of finding m matches among the c2...cn\n    // remaining clauses\n    // since it is a disjunction overall, the total cost is the sum of the costs of these\n    // two parts\n\n    // If we recurse infinitely, we find out that the cost of a msm query is the sum of the\n    // costs of the num_scorers - minShouldMatch + 1 least costly scorers\n    final PriorityQueue<Scorer> pq = new PriorityQueue<Scorer>(scorers.size() - minShouldMatch + 1) {\n      @Override\n      protected boolean lessThan(Scorer a, Scorer b) {\n        return a.iterator().cost() > b.iterator().cost();\n      }\n    };\n    for (Scorer scorer : scorers) {\n      pq.insertWithOverflow(scorer);\n    }\n    long cost = 0;\n    for (Scorer scorer = pq.pop(); scorer != null; scorer = pq.pop()) {\n      cost += scorer.iterator().cost();\n    }\n    return cost;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"302d34f2c66e8d489ee13078305c330cbf67b226","date":1484754357,"type":5,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/MinShouldMatchSumScorer#cost(LongStream,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/MinShouldMatchSumScorer#cost(Collection[Scorer],int).mjava","sourceNew":"  static long cost(LongStream costs, int numScorers, int minShouldMatch) {\n    // the idea here is the following: a boolean query c1,c2,...cn with minShouldMatch=m\n    // could be rewritten to:\n    // (c1 AND (c2..cn|msm=m-1)) OR (!c1 AND (c2..cn|msm=m))\n    // if we assume that clauses come in ascending cost, then\n    // the cost of the first part is the cost of c1 (because the cost of a conjunction is\n    // the cost of the least costly clause)\n    // the cost of the second part is the cost of finding m matches among the c2...cn\n    // remaining clauses\n    // since it is a disjunction overall, the total cost is the sum of the costs of these\n    // two parts\n\n    // If we recurse infinitely, we find out that the cost of a msm query is the sum of the\n    // costs of the num_scorers - minShouldMatch + 1 least costly scorers\n    final PriorityQueue<Long> pq = new PriorityQueue<Long>(numScorers - minShouldMatch + 1) {\n      @Override\n      protected boolean lessThan(Long a, Long b) {\n        return a > b;\n      }\n    };\n    costs.forEach(pq::insertWithOverflow);\n    return StreamSupport.stream(pq.spliterator(), false).mapToLong(Number::longValue).sum();\n  }\n\n","sourceOld":"  private static long cost(Collection<Scorer> scorers, int minShouldMatch) {\n    // the idea here is the following: a boolean query c1,c2,...cn with minShouldMatch=m\n    // could be rewritten to:\n    // (c1 AND (c2..cn|msm=m-1)) OR (!c1 AND (c2..cn|msm=m))\n    // if we assume that clauses come in ascending cost, then\n    // the cost of the first part is the cost of c1 (because the cost of a conjunction is\n    // the cost of the least costly clause)\n    // the cost of the second part is the cost of finding m matches among the c2...cn\n    // remaining clauses\n    // since it is a disjunction overall, the total cost is the sum of the costs of these\n    // two parts\n\n    // If we recurse infinitely, we find out that the cost of a msm query is the sum of the\n    // costs of the num_scorers - minShouldMatch + 1 least costly scorers\n    final PriorityQueue<Scorer> pq = new PriorityQueue<Scorer>(scorers.size() - minShouldMatch + 1) {\n      @Override\n      protected boolean lessThan(Scorer a, Scorer b) {\n        return a.iterator().cost() > b.iterator().cost();\n      }\n    };\n    for (Scorer scorer : scorers) {\n      pq.insertWithOverflow(scorer);\n    }\n    long cost = 0;\n    for (Scorer scorer = pq.pop(); scorer != null; scorer = pq.pop()) {\n      cost += scorer.iterator().cost();\n    }\n    return cost;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"251e6911800e3a02e1da3bfd4dc49a914aef9778":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"dca67e06c96e95a8d9ef07418b6299bfd981523b":["7dd748bb245633a8195281556bb0e68a6ea97d18"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7dd748bb245633a8195281556bb0e68a6ea97d18":["251e6911800e3a02e1da3bfd4dc49a914aef9778"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["dca67e06c96e95a8d9ef07418b6299bfd981523b"],"302d34f2c66e8d489ee13078305c330cbf67b226":["7dd748bb245633a8195281556bb0e68a6ea97d18","dca67e06c96e95a8d9ef07418b6299bfd981523b"]},"commit2Childs":{"251e6911800e3a02e1da3bfd4dc49a914aef9778":["7dd748bb245633a8195281556bb0e68a6ea97d18"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["251e6911800e3a02e1da3bfd4dc49a914aef9778"],"dca67e06c96e95a8d9ef07418b6299bfd981523b":["cd5edd1f2b162a5cfa08efd17851a07373a96817","302d34f2c66e8d489ee13078305c330cbf67b226"],"7dd748bb245633a8195281556bb0e68a6ea97d18":["dca67e06c96e95a8d9ef07418b6299bfd981523b","302d34f2c66e8d489ee13078305c330cbf67b226"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"302d34f2c66e8d489ee13078305c330cbf67b226":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","302d34f2c66e8d489ee13078305c330cbf67b226"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}