{"path":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","commits":[{"id":"d76ab9983349b199b0e6f65776c0087b0c08a10d","date":1282230089,"type":1,"author":"Grant Ingersoll","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(Collection[Token],IndexReader,int,boolean,boolean).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = (int) Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n        //These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = term.createTerm(tokenText);\n        result.add(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        for (int i = 0; i < countLimit; i++) {\n          term = term.createTerm(suggestions[i]);\n          result.add(token, suggestions[i], reader.docFreq(term));\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public SpellingResult getSuggestions(Collection<Token> tokens,\n                                       IndexReader reader, int count, boolean onlyMorePopular,\n                                       boolean extendedResults)\n          throws IOException {\n    SpellingResult result = new SpellingResult(tokens);\n    reader = determineReader(reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    for (Token token : tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText, (int) Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT),\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            onlyMorePopular);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n        //These are spelled the same, continue on\n        continue;\n      }\n\n      if (extendedResults == true && reader != null && field != null) {\n        term = term.createTerm(tokenText);\n        result.add(token, reader.docFreq(term));\n        int countLimit = Math.min(count, suggestions.length);\n        for (int i = 0; i < countLimit; i++) {\n          term = term.createTerm(suggestions[i]);\n          result.add(token, suggestions[i], reader.docFreq(term));\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > count) {\n            suggList = suggList.subList(0, count);\n          }\n          result.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6aab5206b894bf0ea232b059a45cf2de460726f","date":1284150281,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tboolean shardRequest = false;\n  \tSolrParams params = options.customParams;\n  \tif(params!=null)\n  \t{\n  \t\tshardRequest = \"true\".equals(params.get(ShardParams.IS_SHARD));\n  \t}\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = (int) Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = term.createTerm(tokenText);\n        result.add(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = term.createTerm(suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = (int) Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n        //These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = term.createTerm(tokenText);\n        result.add(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        for (int i = 0; i < countLimit; i++) {\n          term = term.createTerm(suggestions[i]);\n          result.add(token, suggestions[i], reader.docFreq(term));\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":["d76ab9983349b199b0e6f65776c0087b0c08a10d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f7e3e91f914e6265ed09a3208cc60c9ba2a477d","date":1286157263,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tboolean shardRequest = false;\n  \tSolrParams params = options.customParams;\n  \tif(params!=null)\n  \t{\n  \t\tshardRequest = \"true\".equals(params.get(ShardParams.IS_SHARD));\n  \t}\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = term.createTerm(tokenText);\n        result.add(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = term.createTerm(suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tboolean shardRequest = false;\n  \tSolrParams params = options.customParams;\n  \tif(params!=null)\n  \t{\n  \t\tshardRequest = \"true\".equals(params.get(ShardParams.IS_SHARD));\n  \t}\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = (int) Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = term.createTerm(tokenText);\n        result.add(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = term.createTerm(suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tboolean shardRequest = false;\n  \tSolrParams params = options.customParams;\n  \tif(params!=null)\n  \t{\n  \t\tshardRequest = \"true\".equals(params.get(ShardParams.IS_SHARD));\n  \t}\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = term.createTerm(tokenText);\n        result.add(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = term.createTerm(suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"de86357ed7f45c7efec5ea6ab5a403b027a9f0b0","date":1307486921,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tboolean shardRequest = false;\n  \tSolrParams params = options.customParams;\n  \tif(params!=null)\n  \t{\n  \t\tshardRequest = \"true\".equals(params.get(ShardParams.IS_SHARD));\n  \t}\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = term.createTerm(tokenText);\n        result.addFrequency(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = term.createTerm(suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tboolean shardRequest = false;\n  \tSolrParams params = options.customParams;\n  \tif(params!=null)\n  \t{\n  \t\tshardRequest = \"true\".equals(params.get(ShardParams.IS_SHARD));\n  \t}\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = term.createTerm(tokenText);\n        result.add(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = term.createTerm(suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"77cf4379b2824f6ea34b091c495d6e95c38ff9e2","date":1307610475,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tboolean shardRequest = false;\n  \tSolrParams params = options.customParams;\n  \tif(params!=null)\n  \t{\n  \t\tshardRequest = \"true\".equals(params.get(ShardParams.IS_SHARD));\n  \t}\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = term.createTerm(tokenText);\n        result.addFrequency(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = term.createTerm(suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tboolean shardRequest = false;\n  \tSolrParams params = options.customParams;\n  \tif(params!=null)\n  \t{\n  \t\tshardRequest = \"true\".equals(params.get(ShardParams.IS_SHARD));\n  \t}\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = term.createTerm(tokenText);\n        result.add(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = term.createTerm(suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","date":1307729864,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tboolean shardRequest = false;\n  \tSolrParams params = options.customParams;\n  \tif(params!=null)\n  \t{\n  \t\tshardRequest = \"true\".equals(params.get(ShardParams.IS_SHARD));\n  \t}\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = term.createTerm(tokenText);\n        result.addFrequency(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = term.createTerm(suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tboolean shardRequest = false;\n  \tSolrParams params = options.customParams;\n  \tif(params!=null)\n  \t{\n  \t\tshardRequest = \"true\".equals(params.get(ShardParams.IS_SHARD));\n  \t}\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = term.createTerm(tokenText);\n        result.add(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = term.createTerm(suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fafef7c83fe8e0b3ca9298d5d75d6b943dc28153","date":1308670974,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tboolean shardRequest = false;\n  \tSolrParams params = options.customParams;\n  \tif(params!=null)\n  \t{\n  \t\tshardRequest = \"true\".equals(params.get(ShardParams.IS_SHARD));\n  \t}\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = new Term(field, tokenText);\n        result.addFrequency(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = new Term(field, suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tboolean shardRequest = false;\n  \tSolrParams params = options.customParams;\n  \tif(params!=null)\n  \t{\n  \t\tshardRequest = \"true\".equals(params.get(ShardParams.IS_SHARD));\n  \t}\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = term.createTerm(tokenText);\n        result.addFrequency(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = term.createTerm(suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tboolean shardRequest = false;\n  \tSolrParams params = options.customParams;\n  \tif(params!=null)\n  \t{\n  \t\tshardRequest = \"true\".equals(params.get(ShardParams.IS_SHARD));\n  \t}\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = new Term(field, tokenText);\n        result.addFrequency(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = new Term(field, suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tboolean shardRequest = false;\n  \tSolrParams params = options.customParams;\n  \tif(params!=null)\n  \t{\n  \t\tshardRequest = \"true\".equals(params.get(ShardParams.IS_SHARD));\n  \t}\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = term.createTerm(tokenText);\n        result.addFrequency(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = term.createTerm(suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tboolean shardRequest = false;\n  \tSolrParams params = options.customParams;\n  \tif(params!=null)\n  \t{\n  \t\tshardRequest = \"true\".equals(params.get(ShardParams.IS_SHARD));\n  \t}\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = new Term(field, tokenText);\n        result.addFrequency(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = new Term(field, suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tboolean shardRequest = false;\n  \tSolrParams params = options.customParams;\n  \tif(params!=null)\n  \t{\n  \t\tshardRequest = \"true\".equals(params.get(ShardParams.IS_SHARD));\n  \t}\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = term.createTerm(tokenText);\n        result.addFrequency(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = term.createTerm(suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tboolean shardRequest = false;\n  \tSolrParams params = options.customParams;\n  \tif(params!=null)\n  \t{\n  \t\tshardRequest = \"true\".equals(params.get(ShardParams.IS_SHARD));\n  \t}\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = new Term(field, tokenText);\n        result.addFrequency(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = new Term(field, suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tboolean shardRequest = false;\n  \tSolrParams params = options.customParams;\n  \tif(params!=null)\n  \t{\n  \t\tshardRequest = \"true\".equals(params.get(ShardParams.IS_SHARD));\n  \t}\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = new Term(field, tokenText);\n        result.addFrequency(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = new Term(field, suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tboolean shardRequest = false;\n  \tSolrParams params = options.customParams;\n  \tif(params!=null)\n  \t{\n  \t\tshardRequest = \"true\".equals(params.get(ShardParams.IS_SHARD));\n  \t}\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = new Term(field, tokenText);\n        result.addFrequency(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = new Term(field, suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tboolean shardRequest = false;\n  \tSolrParams params = options.customParams;\n  \tif(params!=null)\n  \t{\n  \t\tshardRequest = \"true\".equals(params.get(ShardParams.IS_SHARD));\n  \t}\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = new Term(field, tokenText);\n        result.addFrequency(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = new Term(field, suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tboolean shardRequest = false;\n  \tSolrParams params = options.customParams;\n  \tif(params!=null)\n  \t{\n  \t\tshardRequest = \"true\".equals(params.get(ShardParams.IS_SHARD));\n  \t}\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = new Term(field, tokenText);\n        result.addFrequency(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = new Term(field, suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options) throws IOException {\n  \tboolean shardRequest = false;\n  \tSolrParams params = options.customParams;\n  \tif(params!=null)\n  \t{\n  \t\tshardRequest = \"true\".equals(params.get(ShardParams.IS_SHARD));\n  \t}\n    SpellingResult result = new SpellingResult(options.tokens);\n    IndexReader reader = determineReader(options.reader);\n    Term term = field != null ? new Term(field, \"\") : null;\n    float theAccuracy = (options.accuracy == Float.MIN_VALUE) ? spellChecker.getAccuracy() : options.accuracy;\n    \n    int count = Math.max(options.count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    for (Token token : options.tokens) {\n      String tokenText = new String(token.buffer(), 0, token.length());\n      String[] suggestions = spellChecker.suggestSimilar(tokenText,\n              count,\n            field != null ? reader : null, //workaround LUCENE-1295\n            field,\n            options.onlyMorePopular, theAccuracy);\n      if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {\n      \t//These are spelled the same, continue on\n        continue;\n      }\n\n      if (options.extendedResults == true && reader != null && field != null) {\n        term = new Term(field, tokenText);\n        result.addFrequency(token, reader.docFreq(term));\n        int countLimit = Math.min(options.count, suggestions.length);\n        if(countLimit>0)\n        {\n\t        for (int i = 0; i < countLimit; i++) {\n\t          term = new Term(field, suggestions[i]);\n\t          result.add(token, suggestions[i], reader.docFreq(term));\n\t        }\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      } else {\n        if (suggestions.length > 0) {\n          List<String> suggList = Arrays.asList(suggestions);\n          if (suggestions.length > options.count) {\n            suggList = suggList.subList(0, options.count);\n          }\n          result.add(token, suggList);\n        } else if(shardRequest) {\n        \tList<String> suggList = Collections.emptyList();\n        \tresult.add(token, suggList);\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3f7e3e91f914e6265ed09a3208cc60c9ba2a477d":["d6aab5206b894bf0ea232b059a45cf2de460726f"],"d6aab5206b894bf0ea232b059a45cf2de460726f":["d76ab9983349b199b0e6f65776c0087b0c08a10d"],"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["3f7e3e91f914e6265ed09a3208cc60c9ba2a477d","de86357ed7f45c7efec5ea6ab5a403b027a9f0b0"],"fafef7c83fe8e0b3ca9298d5d75d6b943dc28153":["de86357ed7f45c7efec5ea6ab5a403b027a9f0b0"],"c26f00b574427b55127e869b935845554afde1fa":["fafef7c83fe8e0b3ca9298d5d75d6b943dc28153","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"de86357ed7f45c7efec5ea6ab5a403b027a9f0b0":["3f7e3e91f914e6265ed09a3208cc60c9ba2a477d"],"2553b00f699380c64959ccb27991289aae87be2e":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","fafef7c83fe8e0b3ca9298d5d75d6b943dc28153"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3f7e3e91f914e6265ed09a3208cc60c9ba2a477d"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["de86357ed7f45c7efec5ea6ab5a403b027a9f0b0","fafef7c83fe8e0b3ca9298d5d75d6b943dc28153"],"d76ab9983349b199b0e6f65776c0087b0c08a10d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["2553b00f699380c64959ccb27991289aae87be2e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"77cf4379b2824f6ea34b091c495d6e95c38ff9e2":["3f7e3e91f914e6265ed09a3208cc60c9ba2a477d","de86357ed7f45c7efec5ea6ab5a403b027a9f0b0"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["fafef7c83fe8e0b3ca9298d5d75d6b943dc28153"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"3f7e3e91f914e6265ed09a3208cc60c9ba2a477d":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","de86357ed7f45c7efec5ea6ab5a403b027a9f0b0","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","77cf4379b2824f6ea34b091c495d6e95c38ff9e2"],"d6aab5206b894bf0ea232b059a45cf2de460726f":["3f7e3e91f914e6265ed09a3208cc60c9ba2a477d"],"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["2553b00f699380c64959ccb27991289aae87be2e"],"fafef7c83fe8e0b3ca9298d5d75d6b943dc28153":["c26f00b574427b55127e869b935845554afde1fa","2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","a258fbb26824fd104ed795e5d9033d2d040049ee"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"de86357ed7f45c7efec5ea6ab5a403b027a9f0b0":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","fafef7c83fe8e0b3ca9298d5d75d6b943dc28153","d083e83f225b11e5fdd900e83d26ddb385b6955c","77cf4379b2824f6ea34b091c495d6e95c38ff9e2"],"2553b00f699380c64959ccb27991289aae87be2e":["c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"d76ab9983349b199b0e6f65776c0087b0c08a10d":["d6aab5206b894bf0ea232b059a45cf2de460726f"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","d76ab9983349b199b0e6f65776c0087b0c08a10d"],"77cf4379b2824f6ea34b091c495d6e95c38ff9e2":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","d083e83f225b11e5fdd900e83d26ddb385b6955c","77cf4379b2824f6ea34b091c495d6e95c38ff9e2","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}