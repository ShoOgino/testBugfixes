{"path":"lucene/core/src/java/org/apache/lucene/index/SortedSetDocValuesWriter#addOneValue(BytesRef).mjava","commits":[{"id":"f366ce28775e2b8ea4e06355009471328711666d","date":1360551293,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SortedSetDocValuesWriter#addOneValue(BytesRef).mjava","pathOld":"/dev/null","sourceNew":"  private void addOneValue(BytesRef value) {\n    int ord = hash.add(value);\n    if (ord < 0) {\n      ord = -ord-1;\n    } else {\n      // reserve additional space for each unique value:\n      // 1. when indexing, when hash is 50% full, rehash() suddenly needs 2*size ints.\n      //    TODO: can this same OOM happen in THPF?\n      // 2. when flushing, we need 1 int per value (slot in the ordMap).\n      iwBytesUsed.addAndGet(2 * RamUsageEstimator.NUM_BYTES_INT);\n    }\n    \n    if (currentUpto == currentValues.length) {\n      currentValues = ArrayUtil.grow(currentValues, currentValues.length+1);\n      iwBytesUsed.addAndGet((currentValues.length - currentUpto) * RamUsageEstimator.NUM_BYTES_INT);\n    }\n    \n    currentValues[currentUpto] = ord;\n    currentUpto++;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"780b011e6e552810161e3c859b4bc270f655f47e","date":1360554192,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SortedSetDocValuesWriter#addOneValue(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SortedSetDocValuesWriter#addOneValue(BytesRef).mjava","sourceNew":"  private void addOneValue(BytesRef value) {\n    int ord = hash.add(value);\n    if (ord < 0) {\n      ord = -ord-1;\n    } else {\n      // reserve additional space for each unique value:\n      // 1. when indexing, when hash is 50% full, rehash() suddenly needs 2*size ints.\n      //    TODO: can this same OOM happen in THPF?\n      // 2. when flushing, we need 1 int per value (slot in the ordMap).\n      iwBytesUsed.addAndGet(2 * RamUsageEstimator.NUM_BYTES_INT);\n    }\n    \n    if (currentUpto == currentValues.length) {\n      currentValues = ArrayUtil.grow(currentValues, currentValues.length+1);\n      // reserve additional space for max # values per-doc\n      // when flushing, we need an int[] to sort the mapped-ords within the doc\n      iwBytesUsed.addAndGet((currentValues.length - currentUpto) * 2 * RamUsageEstimator.NUM_BYTES_INT);\n    }\n    \n    currentValues[currentUpto] = ord;\n    currentUpto++;\n  }\n\n","sourceOld":"  private void addOneValue(BytesRef value) {\n    int ord = hash.add(value);\n    if (ord < 0) {\n      ord = -ord-1;\n    } else {\n      // reserve additional space for each unique value:\n      // 1. when indexing, when hash is 50% full, rehash() suddenly needs 2*size ints.\n      //    TODO: can this same OOM happen in THPF?\n      // 2. when flushing, we need 1 int per value (slot in the ordMap).\n      iwBytesUsed.addAndGet(2 * RamUsageEstimator.NUM_BYTES_INT);\n    }\n    \n    if (currentUpto == currentValues.length) {\n      currentValues = ArrayUtil.grow(currentValues, currentValues.length+1);\n      iwBytesUsed.addAndGet((currentValues.length - currentUpto) * RamUsageEstimator.NUM_BYTES_INT);\n    }\n    \n    currentValues[currentUpto] = ord;\n    currentUpto++;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ddbb72a33557d2b5bc22ee95daf3281c43560502","date":1361334582,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SortedSetDocValuesWriter#addOneValue(BytesRef).mjava","pathOld":"/dev/null","sourceNew":"  private void addOneValue(BytesRef value) {\n    int ord = hash.add(value);\n    if (ord < 0) {\n      ord = -ord-1;\n    } else {\n      // reserve additional space for each unique value:\n      // 1. when indexing, when hash is 50% full, rehash() suddenly needs 2*size ints.\n      //    TODO: can this same OOM happen in THPF?\n      // 2. when flushing, we need 1 int per value (slot in the ordMap).\n      iwBytesUsed.addAndGet(2 * RamUsageEstimator.NUM_BYTES_INT);\n    }\n    \n    if (currentUpto == currentValues.length) {\n      currentValues = ArrayUtil.grow(currentValues, currentValues.length+1);\n      // reserve additional space for max # values per-doc\n      // when flushing, we need an int[] to sort the mapped-ords within the doc\n      iwBytesUsed.addAndGet((currentValues.length - currentUpto) * 2 * RamUsageEstimator.NUM_BYTES_INT);\n    }\n    \n    currentValues[currentUpto] = ord;\n    currentUpto++;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55536992cfc5c87d8b7196c556d1b458afe1f840","date":1362267535,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SortedSetDocValuesWriter#addOneValue(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SortedSetDocValuesWriter#addOneValue(BytesRef).mjava","sourceNew":"  private void addOneValue(BytesRef value) {\n    int termID = hash.add(value);\n    if (termID < 0) {\n      termID = -termID-1;\n    } else {\n      // reserve additional space for each unique value:\n      // 1. when indexing, when hash is 50% full, rehash() suddenly needs 2*size ints.\n      //    TODO: can this same OOM happen in THPF?\n      // 2. when flushing, we need 1 int per value (slot in the ordMap).\n      iwBytesUsed.addAndGet(2 * RamUsageEstimator.NUM_BYTES_INT);\n    }\n    \n    if (currentUpto == currentValues.length) {\n      currentValues = ArrayUtil.grow(currentValues, currentValues.length+1);\n      // reserve additional space for max # values per-doc\n      // when flushing, we need an int[] to sort the mapped-ords within the doc\n      iwBytesUsed.addAndGet((currentValues.length - currentUpto) * 2 * RamUsageEstimator.NUM_BYTES_INT);\n    }\n    \n    currentValues[currentUpto] = termID;\n    currentUpto++;\n  }\n\n","sourceOld":"  private void addOneValue(BytesRef value) {\n    int ord = hash.add(value);\n    if (ord < 0) {\n      ord = -ord-1;\n    } else {\n      // reserve additional space for each unique value:\n      // 1. when indexing, when hash is 50% full, rehash() suddenly needs 2*size ints.\n      //    TODO: can this same OOM happen in THPF?\n      // 2. when flushing, we need 1 int per value (slot in the ordMap).\n      iwBytesUsed.addAndGet(2 * RamUsageEstimator.NUM_BYTES_INT);\n    }\n    \n    if (currentUpto == currentValues.length) {\n      currentValues = ArrayUtil.grow(currentValues, currentValues.length+1);\n      // reserve additional space for max # values per-doc\n      // when flushing, we need an int[] to sort the mapped-ords within the doc\n      iwBytesUsed.addAndGet((currentValues.length - currentUpto) * 2 * RamUsageEstimator.NUM_BYTES_INT);\n    }\n    \n    currentValues[currentUpto] = ord;\n    currentUpto++;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f226a8b088dd9c8f6ab287a77237c4aa00a238e5","date":1456187572,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SortedSetDocValuesWriter#addOneValue(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SortedSetDocValuesWriter#addOneValue(BytesRef).mjava","sourceNew":"  private void addOneValue(BytesRef value) {\n    int termID = hash.add(value);\n    if (termID < 0) {\n      termID = -termID-1;\n    } else {\n      // reserve additional space for each unique value:\n      // 1. when indexing, when hash is 50% full, rehash() suddenly needs 2*size ints.\n      //    TODO: can this same OOM happen in THPF?\n      // 2. when flushing, we need 1 int per value (slot in the ordMap).\n      iwBytesUsed.addAndGet(2 * Integer.BYTES);\n    }\n    \n    if (currentUpto == currentValues.length) {\n      currentValues = ArrayUtil.grow(currentValues, currentValues.length+1);\n      // reserve additional space for max # values per-doc\n      // when flushing, we need an int[] to sort the mapped-ords within the doc\n      iwBytesUsed.addAndGet((currentValues.length - currentUpto) * 2 * Integer.BYTES);\n    }\n    \n    currentValues[currentUpto] = termID;\n    currentUpto++;\n  }\n\n","sourceOld":"  private void addOneValue(BytesRef value) {\n    int termID = hash.add(value);\n    if (termID < 0) {\n      termID = -termID-1;\n    } else {\n      // reserve additional space for each unique value:\n      // 1. when indexing, when hash is 50% full, rehash() suddenly needs 2*size ints.\n      //    TODO: can this same OOM happen in THPF?\n      // 2. when flushing, we need 1 int per value (slot in the ordMap).\n      iwBytesUsed.addAndGet(2 * RamUsageEstimator.NUM_BYTES_INT);\n    }\n    \n    if (currentUpto == currentValues.length) {\n      currentValues = ArrayUtil.grow(currentValues, currentValues.length+1);\n      // reserve additional space for max # values per-doc\n      // when flushing, we need an int[] to sort the mapped-ords within the doc\n      iwBytesUsed.addAndGet((currentValues.length - currentUpto) * 2 * RamUsageEstimator.NUM_BYTES_INT);\n    }\n    \n    currentValues[currentUpto] = termID;\n    currentUpto++;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"419a8f52c6635419beb951255cacbbb281044c57","date":1456189353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SortedSetDocValuesWriter#addOneValue(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SortedSetDocValuesWriter#addOneValue(BytesRef).mjava","sourceNew":"  private void addOneValue(BytesRef value) {\n    int termID = hash.add(value);\n    if (termID < 0) {\n      termID = -termID-1;\n    } else {\n      // reserve additional space for each unique value:\n      // 1. when indexing, when hash is 50% full, rehash() suddenly needs 2*size ints.\n      //    TODO: can this same OOM happen in THPF?\n      // 2. when flushing, we need 1 int per value (slot in the ordMap).\n      iwBytesUsed.addAndGet(2 * Integer.BYTES);\n    }\n    \n    if (currentUpto == currentValues.length) {\n      currentValues = ArrayUtil.grow(currentValues, currentValues.length+1);\n      // reserve additional space for max # values per-doc\n      // when flushing, we need an int[] to sort the mapped-ords within the doc\n      iwBytesUsed.addAndGet((currentValues.length - currentUpto) * 2 * Integer.BYTES);\n    }\n    \n    currentValues[currentUpto] = termID;\n    currentUpto++;\n  }\n\n","sourceOld":"  private void addOneValue(BytesRef value) {\n    int termID = hash.add(value);\n    if (termID < 0) {\n      termID = -termID-1;\n    } else {\n      // reserve additional space for each unique value:\n      // 1. when indexing, when hash is 50% full, rehash() suddenly needs 2*size ints.\n      //    TODO: can this same OOM happen in THPF?\n      // 2. when flushing, we need 1 int per value (slot in the ordMap).\n      iwBytesUsed.addAndGet(2 * RamUsageEstimator.NUM_BYTES_INT);\n    }\n    \n    if (currentUpto == currentValues.length) {\n      currentValues = ArrayUtil.grow(currentValues, currentValues.length+1);\n      // reserve additional space for max # values per-doc\n      // when flushing, we need an int[] to sort the mapped-ords within the doc\n      iwBytesUsed.addAndGet((currentValues.length - currentUpto) * 2 * RamUsageEstimator.NUM_BYTES_INT);\n    }\n    \n    currentValues[currentUpto] = termID;\n    currentUpto++;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6652c74b2358a0b13223817a6a793bf1c9d0749d","date":1474465301,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SortedSetDocValuesWriter#addOneValue(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SortedSetDocValuesWriter#addOneValue(BytesRef).mjava","sourceNew":"  private void addOneValue(BytesRef value) {\n    int termID = hash.add(value);\n    if (termID < 0) {\n      termID = -termID-1;\n    } else {\n      // reserve additional space for each unique value:\n      // 1. when indexing, when hash is 50% full, rehash() suddenly needs 2*size ints.\n      //    TODO: can this same OOM happen in THPF?\n      // 2. when flushing, we need 1 int per value (slot in the ordMap).\n      iwBytesUsed.addAndGet(2 * Integer.BYTES);\n    }\n    \n    if (currentUpto == currentValues.length) {\n      currentValues = ArrayUtil.grow(currentValues, currentValues.length+1);\n      iwBytesUsed.addAndGet((currentValues.length - currentUpto) * Integer.BYTES);\n    }\n    \n    currentValues[currentUpto] = termID;\n    currentUpto++;\n  }\n\n","sourceOld":"  private void addOneValue(BytesRef value) {\n    int termID = hash.add(value);\n    if (termID < 0) {\n      termID = -termID-1;\n    } else {\n      // reserve additional space for each unique value:\n      // 1. when indexing, when hash is 50% full, rehash() suddenly needs 2*size ints.\n      //    TODO: can this same OOM happen in THPF?\n      // 2. when flushing, we need 1 int per value (slot in the ordMap).\n      iwBytesUsed.addAndGet(2 * Integer.BYTES);\n    }\n    \n    if (currentUpto == currentValues.length) {\n      currentValues = ArrayUtil.grow(currentValues, currentValues.length+1);\n      // reserve additional space for max # values per-doc\n      // when flushing, we need an int[] to sort the mapped-ords within the doc\n      iwBytesUsed.addAndGet((currentValues.length - currentUpto) * 2 * Integer.BYTES);\n    }\n    \n    currentValues[currentUpto] = termID;\n    currentUpto++;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SortedSetDocValuesWriter#addOneValue(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SortedSetDocValuesWriter#addOneValue(BytesRef).mjava","sourceNew":"  private void addOneValue(BytesRef value) {\n    int termID = hash.add(value);\n    if (termID < 0) {\n      termID = -termID-1;\n    } else {\n      // reserve additional space for each unique value:\n      // 1. when indexing, when hash is 50% full, rehash() suddenly needs 2*size ints.\n      //    TODO: can this same OOM happen in THPF?\n      // 2. when flushing, we need 1 int per value (slot in the ordMap).\n      iwBytesUsed.addAndGet(2 * Integer.BYTES);\n    }\n    \n    if (currentUpto == currentValues.length) {\n      currentValues = ArrayUtil.grow(currentValues, currentValues.length+1);\n      iwBytesUsed.addAndGet((currentValues.length - currentUpto) * Integer.BYTES);\n    }\n    \n    currentValues[currentUpto] = termID;\n    currentUpto++;\n  }\n\n","sourceOld":"  private void addOneValue(BytesRef value) {\n    int termID = hash.add(value);\n    if (termID < 0) {\n      termID = -termID-1;\n    } else {\n      // reserve additional space for each unique value:\n      // 1. when indexing, when hash is 50% full, rehash() suddenly needs 2*size ints.\n      //    TODO: can this same OOM happen in THPF?\n      // 2. when flushing, we need 1 int per value (slot in the ordMap).\n      iwBytesUsed.addAndGet(2 * Integer.BYTES);\n    }\n    \n    if (currentUpto == currentValues.length) {\n      currentValues = ArrayUtil.grow(currentValues, currentValues.length+1);\n      // reserve additional space for max # values per-doc\n      // when flushing, we need an int[] to sort the mapped-ords within the doc\n      iwBytesUsed.addAndGet((currentValues.length - currentUpto) * 2 * Integer.BYTES);\n    }\n    \n    currentValues[currentUpto] = termID;\n    currentUpto++;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SortedSetDocValuesWriter#addOneValue(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SortedSetDocValuesWriter#addOneValue(BytesRef).mjava","sourceNew":"  private void addOneValue(BytesRef value) {\n    int termID = hash.add(value);\n    if (termID < 0) {\n      termID = -termID-1;\n    } else {\n      // reserve additional space for each unique value:\n      // 1. when indexing, when hash is 50% full, rehash() suddenly needs 2*size ints.\n      //    TODO: can this same OOM happen in THPF?\n      // 2. when flushing, we need 1 int per value (slot in the ordMap).\n      iwBytesUsed.addAndGet(2 * Integer.BYTES);\n    }\n    \n    if (currentUpto == currentValues.length) {\n      currentValues = ArrayUtil.grow(currentValues, currentValues.length+1);\n      iwBytesUsed.addAndGet((currentValues.length - currentUpto) * Integer.BYTES);\n    }\n    \n    currentValues[currentUpto] = termID;\n    currentUpto++;\n  }\n\n","sourceOld":"  private void addOneValue(BytesRef value) {\n    int termID = hash.add(value);\n    if (termID < 0) {\n      termID = -termID-1;\n    } else {\n      // reserve additional space for each unique value:\n      // 1. when indexing, when hash is 50% full, rehash() suddenly needs 2*size ints.\n      //    TODO: can this same OOM happen in THPF?\n      // 2. when flushing, we need 1 int per value (slot in the ordMap).\n      iwBytesUsed.addAndGet(2 * Integer.BYTES);\n    }\n    \n    if (currentUpto == currentValues.length) {\n      currentValues = ArrayUtil.grow(currentValues, currentValues.length+1);\n      // reserve additional space for max # values per-doc\n      // when flushing, we need an int[] to sort the mapped-ords within the doc\n      iwBytesUsed.addAndGet((currentValues.length - currentUpto) * 2 * Integer.BYTES);\n    }\n    \n    currentValues[currentUpto] = termID;\n    currentUpto++;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["419a8f52c6635419beb951255cacbbb281044c57","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["419a8f52c6635419beb951255cacbbb281044c57"],"419a8f52c6635419beb951255cacbbb281044c57":["55536992cfc5c87d8b7196c556d1b458afe1f840","f226a8b088dd9c8f6ab287a77237c4aa00a238e5"],"f226a8b088dd9c8f6ab287a77237c4aa00a238e5":["55536992cfc5c87d8b7196c556d1b458afe1f840"],"780b011e6e552810161e3c859b4bc270f655f47e":["f366ce28775e2b8ea4e06355009471328711666d"],"f366ce28775e2b8ea4e06355009471328711666d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ddbb72a33557d2b5bc22ee95daf3281c43560502":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","780b011e6e552810161e3c859b4bc270f655f47e"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["419a8f52c6635419beb951255cacbbb281044c57","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"55536992cfc5c87d8b7196c556d1b458afe1f840":["ddbb72a33557d2b5bc22ee95daf3281c43560502"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f366ce28775e2b8ea4e06355009471328711666d","ddbb72a33557d2b5bc22ee95daf3281c43560502"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"419a8f52c6635419beb951255cacbbb281044c57":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","6652c74b2358a0b13223817a6a793bf1c9d0749d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"f226a8b088dd9c8f6ab287a77237c4aa00a238e5":["419a8f52c6635419beb951255cacbbb281044c57"],"780b011e6e552810161e3c859b4bc270f655f47e":["ddbb72a33557d2b5bc22ee95daf3281c43560502"],"f366ce28775e2b8ea4e06355009471328711666d":["780b011e6e552810161e3c859b4bc270f655f47e"],"ddbb72a33557d2b5bc22ee95daf3281c43560502":["55536992cfc5c87d8b7196c556d1b458afe1f840"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"55536992cfc5c87d8b7196c556d1b458afe1f840":["419a8f52c6635419beb951255cacbbb281044c57","f226a8b088dd9c8f6ab287a77237c4aa00a238e5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}