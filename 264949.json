{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#SimpleTextBKDWriter(int,Directory,String,BKDConfig,double,long).mjava","commits":[{"id":"bb94bf667d51f9c390c99d97afb36b7caab6b6e9","date":1599548621,"type":1,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#SimpleTextBKDWriter(int,Directory,String,BKDConfig,double,long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#SimpleTextBKDWriter(int,Directory,String,int,int,int,int,double,long).mjava","sourceNew":"  public SimpleTextBKDWriter(int maxDoc, Directory tempDir, String tempFileNamePrefix, BKDConfig config, double maxMBSortInHeap, long totalPointCount) throws IOException {\n    verifyParams(maxMBSortInHeap, totalPointCount);\n    this.config = config;\n    // We use tracking dir to deal with removing files on exception, so each place that\n    // creates temp files doesn't need crazy try/finally/sucess logic:\n    this.tempDir = new TrackingDirectoryWrapper(tempDir);\n    this.tempFileNamePrefix = tempFileNamePrefix;\n\n    this.totalPointCount = totalPointCount;\n    this.maxDoc = maxDoc;\n    docsSeen = new FixedBitSet(maxDoc);\n\n\n    scratchDiff = new byte[config.bytesPerDim];\n    scratch1 = new byte[config.packedBytesLength];\n    scratch2 = new byte[config.packedBytesLength];\n    commonPrefixLengths = new int[config.numDims];\n\n    minPackedValue = new byte[config.packedIndexBytesLength];\n    maxPackedValue = new byte[config.packedIndexBytesLength];\n\n    // Maximum number of points we hold in memory at any time\n    maxPointsSortInHeap = (int) ((maxMBSortInHeap * 1024 * 1024) / (config.bytesPerDoc * config.numDims));\n\n    // Finally, we must be able to hold at least the leaf node in heap during build:\n    if (maxPointsSortInHeap < config.maxPointsInLeafNode) {\n      throw new IllegalArgumentException(\"maxMBSortInHeap=\" + maxMBSortInHeap + \" only allows for maxPointsSortInHeap=\" + maxPointsSortInHeap + \", but this is less than config.maxPointsInLeafNode=\" + config.maxPointsInLeafNode + \"; either increase maxMBSortInHeap or decrease config.maxPointsInLeafNode\");\n    }\n\n    this.maxMBSortInHeap = maxMBSortInHeap;\n  }\n\n","sourceOld":"  public SimpleTextBKDWriter(int maxDoc, Directory tempDir, String tempFileNamePrefix, int numDataDims, int numIndexDims, int bytesPerDim,\n                              int maxPointsInLeafNode, double maxMBSortInHeap, long totalPointCount) throws IOException {\n    verifyParams(numDataDims, numIndexDims, maxPointsInLeafNode, maxMBSortInHeap, totalPointCount);\n    // We use tracking dir to deal with removing files on exception, so each place that\n    // creates temp files doesn't need crazy try/finally/sucess logic:\n    this.tempDir = new TrackingDirectoryWrapper(tempDir);\n    this.tempFileNamePrefix = tempFileNamePrefix;\n    this.maxPointsInLeafNode = maxPointsInLeafNode;\n    this.numDataDims = numDataDims;\n    this.numIndexDims = numIndexDims;\n    this.bytesPerDim = bytesPerDim;\n    this.totalPointCount = totalPointCount;\n    this.maxDoc = maxDoc;\n    docsSeen = new FixedBitSet(maxDoc);\n    packedBytesLength = numDataDims * bytesPerDim;\n    packedIndexBytesLength = numIndexDims * bytesPerDim;\n\n    scratchDiff = new byte[bytesPerDim];\n    scratch1 = new byte[packedBytesLength];\n    scratch2 = new byte[packedBytesLength];\n    commonPrefixLengths = new int[numDataDims];\n\n    minPackedValue = new byte[packedIndexBytesLength];\n    maxPackedValue = new byte[packedIndexBytesLength];\n\n    // dimensional values (numDims * bytesPerDim) +  docID (int)\n    bytesPerDoc = packedBytesLength + Integer.BYTES;\n\n    // Maximum number of points we hold in memory at any time\n    maxPointsSortInHeap = (int) ((maxMBSortInHeap * 1024 * 1024) / (bytesPerDoc * numDataDims));\n\n    // Finally, we must be able to hold at least the leaf node in heap during build:\n    if (maxPointsSortInHeap < maxPointsInLeafNode) {\n      throw new IllegalArgumentException(\"maxMBSortInHeap=\" + maxMBSortInHeap + \" only allows for maxPointsSortInHeap=\" + maxPointsSortInHeap + \", but this is less than maxPointsInLeafNode=\" + maxPointsInLeafNode + \"; either increase maxMBSortInHeap or decrease maxPointsInLeafNode\");\n    }\n\n    this.maxMBSortInHeap = maxMBSortInHeap;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"]},"commit2Childs":{"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}