{"path":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#merge(SolrInputDocument,SolrInputDocument).mjava","commits":[{"id":"2d3b450958a83a29a16e492fbff9d094a9a571b6","date":1421525067,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#merge(SolrInputDocument,SolrInputDocument).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Merges the fromDoc into the toDoc using the atomic update syntax.\n   * \n   * @param fromDoc SolrInputDocument which will merged into the toDoc\n   * @param toDoc the final SolrInputDocument that will be mutated with the values from the fromDoc atomic commands\n   * @return toDoc with mutated values\n   */\n  public SolrInputDocument merge(final SolrInputDocument fromDoc, SolrInputDocument toDoc) {\n    for (SolrInputField sif : fromDoc.values()) {\n     Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          boolean updateField = false;\n          switch (key) {\n            case \"add\":\n              updateField = true;\n              doAdd(toDoc, sif, fieldVal);\n              break;\n            case \"set\":\n              updateField = true;\n              doSet(toDoc, sif, fieldVal);\n              break;\n            case \"remove\":\n              updateField = true;\n              doRemove(toDoc, sif, fieldVal);\n              break;\n            case \"removeregex\":\n              updateField = true;\n              doRemoveRegex(toDoc, sif, fieldVal);\n              break;\n            case \"inc\":\n              updateField = true;\n              doInc(toDoc, sif, fieldVal);\n              break;\n            default:\n              //Perhaps throw an error here instead?\n              log.warn(\"Unknown operation for the an atomic update, operation ignored: \" + key);\n              break;\n          }\n          // validate that the field being modified is not the id field.\n          if (updateField && idField.getName().equals(sif.getName())) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid update of id field: \" + sif);\n          }\n\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        toDoc.put(sif.getName(), sif);\n      }\n    }\n    \n    return toDoc;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bea398c878f7afaa4d36c2d0060392f73688de3e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b4d3dd8938b47955be7cebf7724fa9ae6122f106","date":1520246230,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#merge(SolrInputDocument,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#merge(SolrInputDocument,SolrInputDocument).mjava","sourceNew":"  /**\n   * Merges the fromDoc into the toDoc using the atomic update syntax.\n   * \n   * @param fromDoc SolrInputDocument which will merged into the toDoc\n   * @param toDoc the final SolrInputDocument that will be mutated with the values from the fromDoc atomic commands\n   * @return toDoc with mutated values\n   */\n  public SolrInputDocument merge(final SolrInputDocument fromDoc, SolrInputDocument toDoc) {\n    for (SolrInputField sif : fromDoc.values()) {\n     Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          boolean updateField = false;\n          switch (key) {\n            case \"add\":\n              updateField = true;\n              doAdd(toDoc, sif, fieldVal);\n              break;\n            case \"set\":\n              updateField = true;\n              doSet(toDoc, sif, fieldVal);\n              break;\n            case \"remove\":\n              updateField = true;\n              doRemove(toDoc, sif, fieldVal);\n              break;\n            case \"removeregex\":\n              updateField = true;\n              doRemoveRegex(toDoc, sif, fieldVal);\n              break;\n            case \"inc\":\n              updateField = true;\n              doInc(toDoc, sif, fieldVal);\n              break;\n            case \"add-distinct\":\n              updateField = true;\n              doAddDistinct(toDoc, sif, fieldVal);\n              break;\n            default:\n              //Perhaps throw an error here instead?\n              log.warn(\"Unknown operation for the an atomic update, operation ignored: \" + key);\n              break;\n          }\n          // validate that the field being modified is not the id field.\n          if (updateField && idField.getName().equals(sif.getName())) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid update of id field: \" + sif);\n          }\n\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        toDoc.put(sif.getName(), sif);\n      }\n    }\n    \n    return toDoc;\n  }\n\n","sourceOld":"  /**\n   * Merges the fromDoc into the toDoc using the atomic update syntax.\n   * \n   * @param fromDoc SolrInputDocument which will merged into the toDoc\n   * @param toDoc the final SolrInputDocument that will be mutated with the values from the fromDoc atomic commands\n   * @return toDoc with mutated values\n   */\n  public SolrInputDocument merge(final SolrInputDocument fromDoc, SolrInputDocument toDoc) {\n    for (SolrInputField sif : fromDoc.values()) {\n     Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          boolean updateField = false;\n          switch (key) {\n            case \"add\":\n              updateField = true;\n              doAdd(toDoc, sif, fieldVal);\n              break;\n            case \"set\":\n              updateField = true;\n              doSet(toDoc, sif, fieldVal);\n              break;\n            case \"remove\":\n              updateField = true;\n              doRemove(toDoc, sif, fieldVal);\n              break;\n            case \"removeregex\":\n              updateField = true;\n              doRemoveRegex(toDoc, sif, fieldVal);\n              break;\n            case \"inc\":\n              updateField = true;\n              doInc(toDoc, sif, fieldVal);\n              break;\n            default:\n              //Perhaps throw an error here instead?\n              log.warn(\"Unknown operation for the an atomic update, operation ignored: \" + key);\n              break;\n          }\n          // validate that the field being modified is not the id field.\n          if (updateField && idField.getName().equals(sif.getName())) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid update of id field: \" + sif);\n          }\n\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        toDoc.put(sif.getName(), sif);\n      }\n    }\n    \n    return toDoc;\n  }\n\n","bugFix":null,"bugIntro":["bea398c878f7afaa4d36c2d0060392f73688de3e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bea398c878f7afaa4d36c2d0060392f73688de3e","date":1556103010,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#merge(SolrInputDocument,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#merge(SolrInputDocument,SolrInputDocument).mjava","sourceNew":"  /**\n   * Merges the fromDoc into the toDoc using the atomic update syntax.\n   * \n   * @param fromDoc SolrInputDocument which will merged into the toDoc\n   * @param toDoc the final SolrInputDocument that will be mutated with the values from the fromDoc atomic commands\n   * @return toDoc with mutated values\n   */\n  public SolrInputDocument merge(final SolrInputDocument fromDoc, SolrInputDocument toDoc) {\n    for (SolrInputField sif : fromDoc.values()) {\n     Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          switch (key) {\n            case \"add\":\n              doAdd(toDoc, sif, fieldVal);\n              break;\n            case \"set\":\n              doSet(toDoc, sif, fieldVal);\n              break;\n            case \"remove\":\n              doRemove(toDoc, sif, fieldVal);\n              break;\n            case \"removeregex\":\n              doRemoveRegex(toDoc, sif, fieldVal);\n              break;\n            case \"inc\":\n              doInc(toDoc, sif, fieldVal);\n              break;\n            case \"add-distinct\":\n              doAddDistinct(toDoc, sif, fieldVal);\n              break;\n            default:\n              Object id = toDoc.containsKey(idField.getName())? toDoc.getFieldValue(idField.getName()):\n                  fromDoc.getFieldValue(idField.getName());\n              String err = \"Unknown operation for the an atomic update, operation ignored: \" + key;\n              if (id != null) {\n                err = err + \" for id:\" + id;\n              }\n              throw new SolrException(ErrorCode.BAD_REQUEST, err);\n          }\n          // validate that the field being modified is not the id field.\n          if (idField.getName().equals(sif.getName())) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid update of id field: \" + sif);\n          }\n\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        toDoc.put(sif.getName(), sif);\n      }\n    }\n    \n    return toDoc;\n  }\n\n","sourceOld":"  /**\n   * Merges the fromDoc into the toDoc using the atomic update syntax.\n   * \n   * @param fromDoc SolrInputDocument which will merged into the toDoc\n   * @param toDoc the final SolrInputDocument that will be mutated with the values from the fromDoc atomic commands\n   * @return toDoc with mutated values\n   */\n  public SolrInputDocument merge(final SolrInputDocument fromDoc, SolrInputDocument toDoc) {\n    for (SolrInputField sif : fromDoc.values()) {\n     Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          boolean updateField = false;\n          switch (key) {\n            case \"add\":\n              updateField = true;\n              doAdd(toDoc, sif, fieldVal);\n              break;\n            case \"set\":\n              updateField = true;\n              doSet(toDoc, sif, fieldVal);\n              break;\n            case \"remove\":\n              updateField = true;\n              doRemove(toDoc, sif, fieldVal);\n              break;\n            case \"removeregex\":\n              updateField = true;\n              doRemoveRegex(toDoc, sif, fieldVal);\n              break;\n            case \"inc\":\n              updateField = true;\n              doInc(toDoc, sif, fieldVal);\n              break;\n            case \"add-distinct\":\n              updateField = true;\n              doAddDistinct(toDoc, sif, fieldVal);\n              break;\n            default:\n              //Perhaps throw an error here instead?\n              log.warn(\"Unknown operation for the an atomic update, operation ignored: \" + key);\n              break;\n          }\n          // validate that the field being modified is not the id field.\n          if (updateField && idField.getName().equals(sif.getName())) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid update of id field: \" + sif);\n          }\n\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        toDoc.put(sif.getName(), sif);\n      }\n    }\n    \n    return toDoc;\n  }\n\n","bugFix":["2d3b450958a83a29a16e492fbff9d094a9a571b6","b4d3dd8938b47955be7cebf7724fa9ae6122f106"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"018a36ff4088cb91ab12cbe44f696d81d1fadd77","date":1591657414,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#merge(SolrInputDocument,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#merge(SolrInputDocument,SolrInputDocument).mjava","sourceNew":"  /**\n   * Merges the fromDoc into the toDoc using the atomic update syntax.\n   * \n   * @param fromDoc SolrInputDocument which will merged into the toDoc\n   * @param toDoc the final SolrInputDocument that will be mutated with the values from the fromDoc atomic commands\n   * @return toDoc with mutated values\n   */\n  @SuppressWarnings({\"unchecked\"})\n  public SolrInputDocument merge(final SolrInputDocument fromDoc, SolrInputDocument toDoc) {\n    for (SolrInputField sif : fromDoc.values()) {\n     Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          switch (key) {\n            case \"add\":\n              doAdd(toDoc, sif, fieldVal);\n              break;\n            case \"set\":\n              doSet(toDoc, sif, fieldVal);\n              break;\n            case \"remove\":\n              doRemove(toDoc, sif, fieldVal);\n              break;\n            case \"removeregex\":\n              doRemoveRegex(toDoc, sif, fieldVal);\n              break;\n            case \"inc\":\n              doInc(toDoc, sif, fieldVal);\n              break;\n            case \"add-distinct\":\n              doAddDistinct(toDoc, sif, fieldVal);\n              break;\n            default:\n              Object id = toDoc.containsKey(idField.getName())? toDoc.getFieldValue(idField.getName()):\n                  fromDoc.getFieldValue(idField.getName());\n              String err = \"Unknown operation for the an atomic update, operation ignored: \" + key;\n              if (id != null) {\n                err = err + \" for id:\" + id;\n              }\n              throw new SolrException(ErrorCode.BAD_REQUEST, err);\n          }\n          // validate that the field being modified is not the id field.\n          if (idField.getName().equals(sif.getName())) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid update of id field: \" + sif);\n          }\n\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        toDoc.put(sif.getName(), sif);\n      }\n    }\n    \n    return toDoc;\n  }\n\n","sourceOld":"  /**\n   * Merges the fromDoc into the toDoc using the atomic update syntax.\n   * \n   * @param fromDoc SolrInputDocument which will merged into the toDoc\n   * @param toDoc the final SolrInputDocument that will be mutated with the values from the fromDoc atomic commands\n   * @return toDoc with mutated values\n   */\n  public SolrInputDocument merge(final SolrInputDocument fromDoc, SolrInputDocument toDoc) {\n    for (SolrInputField sif : fromDoc.values()) {\n     Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          switch (key) {\n            case \"add\":\n              doAdd(toDoc, sif, fieldVal);\n              break;\n            case \"set\":\n              doSet(toDoc, sif, fieldVal);\n              break;\n            case \"remove\":\n              doRemove(toDoc, sif, fieldVal);\n              break;\n            case \"removeregex\":\n              doRemoveRegex(toDoc, sif, fieldVal);\n              break;\n            case \"inc\":\n              doInc(toDoc, sif, fieldVal);\n              break;\n            case \"add-distinct\":\n              doAddDistinct(toDoc, sif, fieldVal);\n              break;\n            default:\n              Object id = toDoc.containsKey(idField.getName())? toDoc.getFieldValue(idField.getName()):\n                  fromDoc.getFieldValue(idField.getName());\n              String err = \"Unknown operation for the an atomic update, operation ignored: \" + key;\n              if (id != null) {\n                err = err + \" for id:\" + id;\n              }\n              throw new SolrException(ErrorCode.BAD_REQUEST, err);\n          }\n          // validate that the field being modified is not the id field.\n          if (idField.getName().equals(sif.getName())) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid update of id field: \" + sif);\n          }\n\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        toDoc.put(sif.getName(), sif);\n      }\n    }\n    \n    return toDoc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"018a36ff4088cb91ab12cbe44f696d81d1fadd77":["bea398c878f7afaa4d36c2d0060392f73688de3e"],"b4d3dd8938b47955be7cebf7724fa9ae6122f106":["2d3b450958a83a29a16e492fbff9d094a9a571b6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bea398c878f7afaa4d36c2d0060392f73688de3e":["b4d3dd8938b47955be7cebf7724fa9ae6122f106"],"2d3b450958a83a29a16e492fbff9d094a9a571b6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["018a36ff4088cb91ab12cbe44f696d81d1fadd77"]},"commit2Childs":{"018a36ff4088cb91ab12cbe44f696d81d1fadd77":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b4d3dd8938b47955be7cebf7724fa9ae6122f106":["bea398c878f7afaa4d36c2d0060392f73688de3e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2d3b450958a83a29a16e492fbff9d094a9a571b6"],"bea398c878f7afaa4d36c2d0060392f73688de3e":["018a36ff4088cb91ab12cbe44f696d81d1fadd77"],"2d3b450958a83a29a16e492fbff9d094a9a571b6":["b4d3dd8938b47955be7cebf7724fa9ae6122f106"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}