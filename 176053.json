{"path":"solr/test-framework/src/java/org/apache/solr/util/SSLTestConfig#buildServerSSLConfig().mjava","commits":[{"id":"1a77e5e21cbd575a8240b0e3926164f15295f4e8","date":1544979500,"type":1,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/util/SSLTestConfig#buildServerSSLConfig().mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/util/SSLTestConfig#buildServerSSLContext().mjava","sourceNew":"  /**\n   * Builds a new SSLContext for jetty servers which have been configured based on the settings of \n   * this object.\n   *\n   * NOTE: Uses a completely insecure {@link SecureRandom} instance to prevent tests from blocking \n   * due to lack of entropy, also explicitly allows the use of self-signed \n   * certificates (since that's what is almost always used during testing).\n   * almost always used during testing). \n   */\n  public SSLConfig buildServerSSLConfig() {\n    if (!isSSLMode()) {\n      return null;\n    }\n\n    return new SSLConfig(isSSLMode(), isClientAuthMode(), null, null, null, null) {\n      @Override\n      public SslContextFactory createContextFactory() {\n        SslContextFactory factory = new SslContextFactory(false);\n        try {\n          SSLContextBuilder builder = SSLContexts.custom();\n          builder.setSecureRandom(NotSecurePsuedoRandom.INSTANCE);\n\n          builder.loadKeyMaterial(buildKeyStore(keyStore, TEST_PASSWORD), TEST_PASSWORD.toCharArray());\n\n          if (isClientAuthMode()) {\n            builder.loadTrustMaterial(buildKeyStore(trustStore, TEST_PASSWORD), new TrustSelfSignedStrategy()).build();\n\n          }\n          factory.setSslContext(builder.build());\n        } catch (Exception e) {\n          throw new RuntimeException(\"ssl context init failure: \" + e.getMessage(), e);\n        }\n        factory.setNeedClientAuth(isClientAuthMode());\n        return factory;\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Builds a new SSLContext for jetty servers which have been configured based on the settings of \n   * this object.\n   *\n   * NOTE: Uses a completely insecure {@link SecureRandom} instance to prevent tests from blocking \n   * due to lack of entropy, also explicitly allows the use of self-signed \n   * certificates (since that's what is almost always used during testing).\n   * almost always used during testing). \n   */\n  public SSLContext buildServerSSLContext() throws KeyManagementException, \n    UnrecoverableKeyException, NoSuchAlgorithmException, KeyStoreException {\n\n    assert isSSLMode();\n    \n    SSLContextBuilder builder = SSLContexts.custom();\n    builder.setSecureRandom(NotSecurePsuedoRandom.INSTANCE);\n\n    builder.loadKeyMaterial(buildKeyStore(keyStore, getKeyStorePassword()), getKeyStorePassword().toCharArray());\n\n    if (isClientAuthMode()) {\n      builder.loadTrustMaterial(buildKeyStore(trustStore, getTrustStorePassword()), new TrustSelfSignedStrategy()).build();\n      \n    }\n\n    return builder.build();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc9b97d0316c4bdce70fd83fa5b21a003e7bd745","date":1560523579,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/util/SSLTestConfig#buildServerSSLConfig().mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/util/SSLTestConfig#buildServerSSLConfig().mjava","sourceNew":"  /**\n   * Builds a new SSLContext for jetty servers which have been configured based on the settings of \n   * this object.\n   *\n   * NOTE: Uses a completely insecure {@link SecureRandom} instance to prevent tests from blocking \n   * due to lack of entropy, also explicitly allows the use of self-signed \n   * certificates (since that's what is almost always used during testing).\n   * almost always used during testing). \n   */\n  public SSLConfig buildServerSSLConfig() {\n    if (!isSSLMode()) {\n      return null;\n    }\n\n    return new SSLConfig(isSSLMode(), isClientAuthMode(), null, null, null, null) {\n      @Override\n      public SslContextFactory createContextFactory() {\n        SslContextFactory.Server factory = new SslContextFactory.Server();\n        try {\n          SSLContextBuilder builder = SSLContexts.custom();\n          builder.setSecureRandom(NotSecurePsuedoRandom.INSTANCE);\n\n          builder.loadKeyMaterial(buildKeyStore(keyStore, TEST_PASSWORD), TEST_PASSWORD.toCharArray());\n\n          if (isClientAuthMode()) {\n            builder.loadTrustMaterial(buildKeyStore(trustStore, TEST_PASSWORD), new TrustSelfSignedStrategy()).build();\n\n          }\n          factory.setSslContext(builder.build());\n        } catch (Exception e) {\n          throw new RuntimeException(\"ssl context init failure: \" + e.getMessage(), e);\n        }\n        factory.setNeedClientAuth(isClientAuthMode());\n        return factory;\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Builds a new SSLContext for jetty servers which have been configured based on the settings of \n   * this object.\n   *\n   * NOTE: Uses a completely insecure {@link SecureRandom} instance to prevent tests from blocking \n   * due to lack of entropy, also explicitly allows the use of self-signed \n   * certificates (since that's what is almost always used during testing).\n   * almost always used during testing). \n   */\n  public SSLConfig buildServerSSLConfig() {\n    if (!isSSLMode()) {\n      return null;\n    }\n\n    return new SSLConfig(isSSLMode(), isClientAuthMode(), null, null, null, null) {\n      @Override\n      public SslContextFactory createContextFactory() {\n        SslContextFactory factory = new SslContextFactory(false);\n        try {\n          SSLContextBuilder builder = SSLContexts.custom();\n          builder.setSecureRandom(NotSecurePsuedoRandom.INSTANCE);\n\n          builder.loadKeyMaterial(buildKeyStore(keyStore, TEST_PASSWORD), TEST_PASSWORD.toCharArray());\n\n          if (isClientAuthMode()) {\n            builder.loadTrustMaterial(buildKeyStore(trustStore, TEST_PASSWORD), new TrustSelfSignedStrategy()).build();\n\n          }\n          factory.setSslContext(builder.build());\n        } catch (Exception e) {\n          throw new RuntimeException(\"ssl context init failure: \" + e.getMessage(), e);\n        }\n        factory.setNeedClientAuth(isClientAuthMode());\n        return factory;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ea0f43f20834b3c8930e074b144aba27a935fee8","date":1576814747,"type":3,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/util/SSLTestConfig#buildServerSSLConfig().mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/util/SSLTestConfig#buildServerSSLConfig().mjava","sourceNew":"  /**\n   * Builds a new SSLContext for jetty servers which have been configured based on the settings of \n   * this object.\n   *\n   * NOTE: Uses a completely insecure {@link SecureRandom} instance to prevent tests from blocking \n   * due to lack of entropy, also explicitly allows the use of self-signed \n   * certificates (since that's what is almost always used during testing).\n   * almost always used during testing). \n   */\n  public SSLConfig buildServerSSLConfig() {\n    if (!isSSLMode()) {\n      return null;\n    }\n\n    return new SSLConfig(isSSLMode(), isClientAuthMode(), null, null, null, null) {\n      @Override\n      public SslContextFactory.Server createContextFactory() {\n        SslContextFactory.Server factory = new SslContextFactory.Server();\n        try {\n          SSLContextBuilder builder = SSLContexts.custom();\n          builder.setSecureRandom(NotSecurePsuedoRandom.INSTANCE);\n\n          builder.loadKeyMaterial(buildKeyStore(keyStore, TEST_PASSWORD), TEST_PASSWORD.toCharArray());\n\n          if (isClientAuthMode()) {\n            builder.loadTrustMaterial(buildKeyStore(trustStore, TEST_PASSWORD), new TrustSelfSignedStrategy()).build();\n\n          }\n          factory.setSslContext(builder.build());\n        } catch (Exception e) {\n          throw new RuntimeException(\"ssl context init failure: \" + e.getMessage(), e);\n        }\n        factory.setNeedClientAuth(isClientAuthMode());\n        return factory;\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Builds a new SSLContext for jetty servers which have been configured based on the settings of \n   * this object.\n   *\n   * NOTE: Uses a completely insecure {@link SecureRandom} instance to prevent tests from blocking \n   * due to lack of entropy, also explicitly allows the use of self-signed \n   * certificates (since that's what is almost always used during testing).\n   * almost always used during testing). \n   */\n  public SSLConfig buildServerSSLConfig() {\n    if (!isSSLMode()) {\n      return null;\n    }\n\n    return new SSLConfig(isSSLMode(), isClientAuthMode(), null, null, null, null) {\n      @Override\n      public SslContextFactory createContextFactory() {\n        SslContextFactory.Server factory = new SslContextFactory.Server();\n        try {\n          SSLContextBuilder builder = SSLContexts.custom();\n          builder.setSecureRandom(NotSecurePsuedoRandom.INSTANCE);\n\n          builder.loadKeyMaterial(buildKeyStore(keyStore, TEST_PASSWORD), TEST_PASSWORD.toCharArray());\n\n          if (isClientAuthMode()) {\n            builder.loadTrustMaterial(buildKeyStore(trustStore, TEST_PASSWORD), new TrustSelfSignedStrategy()).build();\n\n          }\n          factory.setSslContext(builder.build());\n        } catch (Exception e) {\n          throw new RuntimeException(\"ssl context init failure: \" + e.getMessage(), e);\n        }\n        factory.setNeedClientAuth(isClientAuthMode());\n        return factory;\n      }\n    };\n  }\n\n","bugFix":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c66470e527299cc148ad0b3441d08dfb7cb9e03","date":1576859740,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/util/SSLTestConfig#buildServerSSLConfig().mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/util/SSLTestConfig#buildServerSSLConfig().mjava","sourceNew":"  /**\n   * Builds a new SSLContext for jetty servers which have been configured based on the settings of \n   * this object.\n   *\n   * NOTE: Uses a completely insecure {@link SecureRandom} instance to prevent tests from blocking \n   * due to lack of entropy, also explicitly allows the use of self-signed \n   * certificates (since that's what is almost always used during testing).\n   * almost always used during testing). \n   */\n  public SSLConfig buildServerSSLConfig() {\n    if (!isSSLMode()) {\n      return null;\n    }\n\n    return new SSLConfig(isSSLMode(), isClientAuthMode(), null, null, null, null) {\n      @Override\n      public SslContextFactory.Server createContextFactory() {\n        SslContextFactory.Server factory = new SslContextFactory.Server();\n        try {\n          SSLContextBuilder builder = SSLContexts.custom();\n          builder.setSecureRandom(NotSecurePsuedoRandom.INSTANCE);\n\n          builder.loadKeyMaterial(buildKeyStore(keyStore, TEST_PASSWORD), TEST_PASSWORD.toCharArray());\n\n          if (isClientAuthMode()) {\n            builder.loadTrustMaterial(buildKeyStore(trustStore, TEST_PASSWORD), new TrustSelfSignedStrategy()).build();\n\n          }\n          factory.setSslContext(builder.build());\n        } catch (Exception e) {\n          throw new RuntimeException(\"ssl context init failure: \" + e.getMessage(), e);\n        }\n        factory.setNeedClientAuth(isClientAuthMode());\n        return factory;\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Builds a new SSLContext for jetty servers which have been configured based on the settings of \n   * this object.\n   *\n   * NOTE: Uses a completely insecure {@link SecureRandom} instance to prevent tests from blocking \n   * due to lack of entropy, also explicitly allows the use of self-signed \n   * certificates (since that's what is almost always used during testing).\n   * almost always used during testing). \n   */\n  public SSLConfig buildServerSSLConfig() {\n    if (!isSSLMode()) {\n      return null;\n    }\n\n    return new SSLConfig(isSSLMode(), isClientAuthMode(), null, null, null, null) {\n      @Override\n      public SslContextFactory createContextFactory() {\n        SslContextFactory.Server factory = new SslContextFactory.Server();\n        try {\n          SSLContextBuilder builder = SSLContexts.custom();\n          builder.setSecureRandom(NotSecurePsuedoRandom.INSTANCE);\n\n          builder.loadKeyMaterial(buildKeyStore(keyStore, TEST_PASSWORD), TEST_PASSWORD.toCharArray());\n\n          if (isClientAuthMode()) {\n            builder.loadTrustMaterial(buildKeyStore(trustStore, TEST_PASSWORD), new TrustSelfSignedStrategy()).build();\n\n          }\n          factory.setSslContext(builder.build());\n        } catch (Exception e) {\n          throw new RuntimeException(\"ssl context init failure: \" + e.getMessage(), e);\n        }\n        factory.setNeedClientAuth(isClientAuthMode());\n        return factory;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ea0f43f20834b3c8930e074b144aba27a935fee8":["fc9b97d0316c4bdce70fd83fa5b21a003e7bd745"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fc9b97d0316c4bdce70fd83fa5b21a003e7bd745":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"],"4c66470e527299cc148ad0b3441d08dfb7cb9e03":["fc9b97d0316c4bdce70fd83fa5b21a003e7bd745","ea0f43f20834b3c8930e074b144aba27a935fee8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ea0f43f20834b3c8930e074b144aba27a935fee8"]},"commit2Childs":{"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["fc9b97d0316c4bdce70fd83fa5b21a003e7bd745"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"],"ea0f43f20834b3c8930e074b144aba27a935fee8":["4c66470e527299cc148ad0b3441d08dfb7cb9e03","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fc9b97d0316c4bdce70fd83fa5b21a003e7bd745":["ea0f43f20834b3c8930e074b144aba27a935fee8","4c66470e527299cc148ad0b3441d08dfb7cb9e03"],"4c66470e527299cc148ad0b3441d08dfb7cb9e03":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4c66470e527299cc148ad0b3441d08dfb7cb9e03","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}