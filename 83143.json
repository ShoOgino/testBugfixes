{"path":"solr/core/src/test/org/apache/solr/cloud/api/collections/AbstractCloudBackupRestoreTestCase#test().mjava","commits":[{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":1,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/AbstractCloudBackupRestoreTestCase#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AbstractCloudBackupRestoreTestCase#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    boolean isImplicit = random().nextBoolean();\n    boolean doSplitShardOperation = !isImplicit && random().nextBoolean();\n    replFactor = TestUtil.nextInt(random(), 1, 2);\n    numTlogReplicas = TestUtil.nextInt(random(), 0, 1);\n    numPullReplicas = TestUtil.nextInt(random(), 0, 1);\n    \n    CollectionAdminRequest.Create create = isImplicit ?\n      // NOTE: use shard list with same # of shards as NUM_SHARDS; we assume this later\n      CollectionAdminRequest.createCollectionWithImplicitRouter(getCollectionName(), \"conf1\", \"shard1,shard2\", replFactor, numTlogReplicas, numPullReplicas) :\n      CollectionAdminRequest.createCollection(getCollectionName(), \"conf1\", NUM_SHARDS, replFactor, numTlogReplicas, numPullReplicas);\n    \n    if (NUM_SHARDS * (replFactor + numTlogReplicas + numPullReplicas) > cluster.getJettySolrRunners().size() || random().nextBoolean()) {\n      create.setMaxShardsPerNode((int)Math.ceil(NUM_SHARDS * (replFactor + numTlogReplicas + numPullReplicas) / cluster.getJettySolrRunners().size()));//just to assert it survives the restoration\n      if (doSplitShardOperation) {\n        create.setMaxShardsPerNode(create.getMaxShardsPerNode() * 2);\n      }\n    }\n    if (random().nextBoolean()) {\n      create.setAutoAddReplicas(true);//just to assert it survives the restoration\n    }\n    Properties coreProps = new Properties();\n    coreProps.put(\"customKey\", \"customValue\");//just to assert it survives the restoration\n    create.setProperties(coreProps);\n    if (isImplicit) { //implicit router\n      create.setRouterField(\"shard_s\");\n    } else {//composite id router\n      if (random().nextBoolean()) {\n        create.setRouterField(\"shard_s\");\n      }\n    }\n\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.process(solrClient);\n\n    indexDocs(getCollectionName());\n\n    if (doSplitShardOperation) {\n      // shard split the first shard\n      int prevActiveSliceCount = getActiveSliceCount(getCollectionName());\n      CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(getCollectionName());\n      splitShard.setShardName(\"shard1\");\n      splitShard.process(solrClient);\n      // wait until we see one more active slice...\n      for (int i = 0; getActiveSliceCount(getCollectionName()) != prevActiveSliceCount + 1; i++) {\n        assertTrue(i < 30);\n        Thread.sleep(500);\n      }\n      // issue a hard commit.  Split shard does a soft commit which isn't good enough for the backup/snapshooter to see\n      solrClient.commit(getCollectionName());\n    }\n\n    testBackupAndRestore(getCollectionName());\n    testConfigBackupOnly(\"conf1\", getCollectionName());\n    testInvalidPath(getCollectionName());\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    boolean isImplicit = random().nextBoolean();\n    boolean doSplitShardOperation = !isImplicit && random().nextBoolean();\n    replFactor = TestUtil.nextInt(random(), 1, 2);\n    numTlogReplicas = TestUtil.nextInt(random(), 0, 1);\n    numPullReplicas = TestUtil.nextInt(random(), 0, 1);\n    \n    CollectionAdminRequest.Create create = isImplicit ?\n      // NOTE: use shard list with same # of shards as NUM_SHARDS; we assume this later\n      CollectionAdminRequest.createCollectionWithImplicitRouter(getCollectionName(), \"conf1\", \"shard1,shard2\", replFactor, numTlogReplicas, numPullReplicas) :\n      CollectionAdminRequest.createCollection(getCollectionName(), \"conf1\", NUM_SHARDS, replFactor, numTlogReplicas, numPullReplicas);\n    \n    if (NUM_SHARDS * (replFactor + numTlogReplicas + numPullReplicas) > cluster.getJettySolrRunners().size() || random().nextBoolean()) {\n      create.setMaxShardsPerNode((int)Math.ceil(NUM_SHARDS * (replFactor + numTlogReplicas + numPullReplicas) / cluster.getJettySolrRunners().size()));//just to assert it survives the restoration\n      if (doSplitShardOperation) {\n        create.setMaxShardsPerNode(create.getMaxShardsPerNode() * 2);\n      }\n    }\n    if (random().nextBoolean()) {\n      create.setAutoAddReplicas(true);//just to assert it survives the restoration\n    }\n    Properties coreProps = new Properties();\n    coreProps.put(\"customKey\", \"customValue\");//just to assert it survives the restoration\n    create.setProperties(coreProps);\n    if (isImplicit) { //implicit router\n      create.setRouterField(\"shard_s\");\n    } else {//composite id router\n      if (random().nextBoolean()) {\n        create.setRouterField(\"shard_s\");\n      }\n    }\n\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.process(solrClient);\n\n    indexDocs(getCollectionName());\n\n    if (doSplitShardOperation) {\n      // shard split the first shard\n      int prevActiveSliceCount = getActiveSliceCount(getCollectionName());\n      CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(getCollectionName());\n      splitShard.setShardName(\"shard1\");\n      splitShard.process(solrClient);\n      // wait until we see one more active slice...\n      for (int i = 0; getActiveSliceCount(getCollectionName()) != prevActiveSliceCount + 1; i++) {\n        assertTrue(i < 30);\n        Thread.sleep(500);\n      }\n      // issue a hard commit.  Split shard does a soft commit which isn't good enough for the backup/snapshooter to see\n      solrClient.commit(getCollectionName());\n    }\n\n    testBackupAndRestore(getCollectionName());\n    testConfigBackupOnly(\"conf1\", getCollectionName());\n    testInvalidPath(getCollectionName());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/AbstractCloudBackupRestoreTestCase#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AbstractCloudBackupRestoreTestCase#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    boolean isImplicit = random().nextBoolean();\n    boolean doSplitShardOperation = !isImplicit && random().nextBoolean();\n    replFactor = TestUtil.nextInt(random(), 1, 2);\n    numTlogReplicas = TestUtil.nextInt(random(), 0, 1);\n    numPullReplicas = TestUtil.nextInt(random(), 0, 1);\n    \n    CollectionAdminRequest.Create create = isImplicit ?\n      // NOTE: use shard list with same # of shards as NUM_SHARDS; we assume this later\n      CollectionAdminRequest.createCollectionWithImplicitRouter(getCollectionName(), \"conf1\", \"shard1,shard2\", replFactor, numTlogReplicas, numPullReplicas) :\n      CollectionAdminRequest.createCollection(getCollectionName(), \"conf1\", NUM_SHARDS, replFactor, numTlogReplicas, numPullReplicas);\n    \n    if (NUM_SHARDS * (replFactor + numTlogReplicas + numPullReplicas) > cluster.getJettySolrRunners().size() || random().nextBoolean()) {\n      create.setMaxShardsPerNode((int)Math.ceil(NUM_SHARDS * (replFactor + numTlogReplicas + numPullReplicas) / cluster.getJettySolrRunners().size()));//just to assert it survives the restoration\n      if (doSplitShardOperation) {\n        create.setMaxShardsPerNode(create.getMaxShardsPerNode() * 2);\n      }\n    }\n    if (random().nextBoolean()) {\n      create.setAutoAddReplicas(true);//just to assert it survives the restoration\n    }\n    Properties coreProps = new Properties();\n    coreProps.put(\"customKey\", \"customValue\");//just to assert it survives the restoration\n    create.setProperties(coreProps);\n    if (isImplicit) { //implicit router\n      create.setRouterField(\"shard_s\");\n    } else {//composite id router\n      if (random().nextBoolean()) {\n        create.setRouterField(\"shard_s\");\n      }\n    }\n\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.process(solrClient);\n\n    indexDocs(getCollectionName());\n\n    if (doSplitShardOperation) {\n      // shard split the first shard\n      int prevActiveSliceCount = getActiveSliceCount(getCollectionName());\n      CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(getCollectionName());\n      splitShard.setShardName(\"shard1\");\n      splitShard.process(solrClient);\n      // wait until we see one more active slice...\n      for (int i = 0; getActiveSliceCount(getCollectionName()) != prevActiveSliceCount + 1; i++) {\n        assertTrue(i < 30);\n        Thread.sleep(500);\n      }\n      // issue a hard commit.  Split shard does a soft commit which isn't good enough for the backup/snapshooter to see\n      solrClient.commit(getCollectionName());\n    }\n\n    testBackupAndRestore(getCollectionName());\n    testConfigBackupOnly(\"conf1\", getCollectionName());\n    testInvalidPath(getCollectionName());\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    boolean isImplicit = random().nextBoolean();\n    boolean doSplitShardOperation = !isImplicit && random().nextBoolean();\n    replFactor = TestUtil.nextInt(random(), 1, 2);\n    numTlogReplicas = TestUtil.nextInt(random(), 0, 1);\n    numPullReplicas = TestUtil.nextInt(random(), 0, 1);\n    \n    CollectionAdminRequest.Create create = isImplicit ?\n      // NOTE: use shard list with same # of shards as NUM_SHARDS; we assume this later\n      CollectionAdminRequest.createCollectionWithImplicitRouter(getCollectionName(), \"conf1\", \"shard1,shard2\", replFactor, numTlogReplicas, numPullReplicas) :\n      CollectionAdminRequest.createCollection(getCollectionName(), \"conf1\", NUM_SHARDS, replFactor, numTlogReplicas, numPullReplicas);\n    \n    if (NUM_SHARDS * (replFactor + numTlogReplicas + numPullReplicas) > cluster.getJettySolrRunners().size() || random().nextBoolean()) {\n      create.setMaxShardsPerNode((int)Math.ceil(NUM_SHARDS * (replFactor + numTlogReplicas + numPullReplicas) / cluster.getJettySolrRunners().size()));//just to assert it survives the restoration\n      if (doSplitShardOperation) {\n        create.setMaxShardsPerNode(create.getMaxShardsPerNode() * 2);\n      }\n    }\n    if (random().nextBoolean()) {\n      create.setAutoAddReplicas(true);//just to assert it survives the restoration\n    }\n    Properties coreProps = new Properties();\n    coreProps.put(\"customKey\", \"customValue\");//just to assert it survives the restoration\n    create.setProperties(coreProps);\n    if (isImplicit) { //implicit router\n      create.setRouterField(\"shard_s\");\n    } else {//composite id router\n      if (random().nextBoolean()) {\n        create.setRouterField(\"shard_s\");\n      }\n    }\n\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.process(solrClient);\n\n    indexDocs(getCollectionName());\n\n    if (doSplitShardOperation) {\n      // shard split the first shard\n      int prevActiveSliceCount = getActiveSliceCount(getCollectionName());\n      CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(getCollectionName());\n      splitShard.setShardName(\"shard1\");\n      splitShard.process(solrClient);\n      // wait until we see one more active slice...\n      for (int i = 0; getActiveSliceCount(getCollectionName()) != prevActiveSliceCount + 1; i++) {\n        assertTrue(i < 30);\n        Thread.sleep(500);\n      }\n      // issue a hard commit.  Split shard does a soft commit which isn't good enough for the backup/snapshooter to see\n      solrClient.commit(getCollectionName());\n    }\n\n    testBackupAndRestore(getCollectionName());\n    testConfigBackupOnly(\"conf1\", getCollectionName());\n    testInvalidPath(getCollectionName());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"076d58da25128e8a4c511abf07c5d86c4ebddcbf","date":1523546428,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/AbstractCloudBackupRestoreTestCase#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/AbstractCloudBackupRestoreTestCase#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    boolean isImplicit = random().nextBoolean();\n    boolean doSplitShardOperation = !isImplicit && random().nextBoolean();\n    replFactor = TestUtil.nextInt(random(), 1, 2);\n    numTlogReplicas = TestUtil.nextInt(random(), 0, 1);\n    numPullReplicas = TestUtil.nextInt(random(), 0, 1);\n\n    CollectionAdminRequest.Create create = isImplicit ?\n        // NOTE: use shard list with same # of shards as NUM_SHARDS; we assume this later\n        CollectionAdminRequest.createCollectionWithImplicitRouter(getCollectionName(), \"conf1\", \"shard1,shard2\", replFactor, numTlogReplicas, numPullReplicas) :\n        CollectionAdminRequest.createCollection(getCollectionName(), \"conf1\", NUM_SHARDS, replFactor, numTlogReplicas, numPullReplicas);\n\n    if (NUM_SHARDS * (replFactor + numTlogReplicas + numPullReplicas) > cluster.getJettySolrRunners().size() || random().nextBoolean()) {\n      create.setMaxShardsPerNode((int)Math.ceil(NUM_SHARDS * (replFactor + numTlogReplicas + numPullReplicas) / cluster.getJettySolrRunners().size()));//just to assert it survives the restoration\n      if (doSplitShardOperation) {\n        create.setMaxShardsPerNode(create.getMaxShardsPerNode() * 2);\n      }\n    }\n    if (random().nextBoolean()) {\n      create.setAutoAddReplicas(true);//just to assert it survives the restoration\n    }\n    Properties coreProps = new Properties();\n    coreProps.put(\"customKey\", \"customValue\");//just to assert it survives the restoration\n    create.setProperties(coreProps);\n    if (isImplicit) { //implicit router\n      create.setRouterField(\"shard_s\");\n    } else {//composite id router\n      if (random().nextBoolean()) {\n        create.setRouterField(\"shard_s\");\n      }\n    }\n\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.process(solrClient);\n\n    indexDocs(getCollectionName(), false);\n\n    if (doSplitShardOperation) {\n      // shard split the first shard\n      int prevActiveSliceCount = getActiveSliceCount(getCollectionName());\n      CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(getCollectionName());\n      splitShard.setShardName(\"shard1\");\n      splitShard.process(solrClient);\n      // wait until we see one more active slice...\n      for (int i = 0; getActiveSliceCount(getCollectionName()) != prevActiveSliceCount + 1; i++) {\n        assertTrue(i < 30);\n        Thread.sleep(500);\n      }\n      // issue a hard commit.  Split shard does a soft commit which isn't good enough for the backup/snapshooter to see\n      solrClient.commit(getCollectionName());\n    }\n\n    testBackupAndRestore(getCollectionName());\n    testConfigBackupOnly(\"conf1\", getCollectionName());\n    testInvalidPath(getCollectionName());\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    boolean isImplicit = random().nextBoolean();\n    boolean doSplitShardOperation = !isImplicit && random().nextBoolean();\n    replFactor = TestUtil.nextInt(random(), 1, 2);\n    numTlogReplicas = TestUtil.nextInt(random(), 0, 1);\n    numPullReplicas = TestUtil.nextInt(random(), 0, 1);\n    \n    CollectionAdminRequest.Create create = isImplicit ?\n      // NOTE: use shard list with same # of shards as NUM_SHARDS; we assume this later\n      CollectionAdminRequest.createCollectionWithImplicitRouter(getCollectionName(), \"conf1\", \"shard1,shard2\", replFactor, numTlogReplicas, numPullReplicas) :\n      CollectionAdminRequest.createCollection(getCollectionName(), \"conf1\", NUM_SHARDS, replFactor, numTlogReplicas, numPullReplicas);\n    \n    if (NUM_SHARDS * (replFactor + numTlogReplicas + numPullReplicas) > cluster.getJettySolrRunners().size() || random().nextBoolean()) {\n      create.setMaxShardsPerNode((int)Math.ceil(NUM_SHARDS * (replFactor + numTlogReplicas + numPullReplicas) / cluster.getJettySolrRunners().size()));//just to assert it survives the restoration\n      if (doSplitShardOperation) {\n        create.setMaxShardsPerNode(create.getMaxShardsPerNode() * 2);\n      }\n    }\n    if (random().nextBoolean()) {\n      create.setAutoAddReplicas(true);//just to assert it survives the restoration\n    }\n    Properties coreProps = new Properties();\n    coreProps.put(\"customKey\", \"customValue\");//just to assert it survives the restoration\n    create.setProperties(coreProps);\n    if (isImplicit) { //implicit router\n      create.setRouterField(\"shard_s\");\n    } else {//composite id router\n      if (random().nextBoolean()) {\n        create.setRouterField(\"shard_s\");\n      }\n    }\n\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.process(solrClient);\n\n    indexDocs(getCollectionName());\n\n    if (doSplitShardOperation) {\n      // shard split the first shard\n      int prevActiveSliceCount = getActiveSliceCount(getCollectionName());\n      CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(getCollectionName());\n      splitShard.setShardName(\"shard1\");\n      splitShard.process(solrClient);\n      // wait until we see one more active slice...\n      for (int i = 0; getActiveSliceCount(getCollectionName()) != prevActiveSliceCount + 1; i++) {\n        assertTrue(i < 30);\n        Thread.sleep(500);\n      }\n      // issue a hard commit.  Split shard does a soft commit which isn't good enough for the backup/snapshooter to see\n      solrClient.commit(getCollectionName());\n    }\n\n    testBackupAndRestore(getCollectionName());\n    testConfigBackupOnly(\"conf1\", getCollectionName());\n    testInvalidPath(getCollectionName());\n  }\n\n","bugFix":["4c623a7f72be34d6c45bee682028c50327d9e4b7","ac97ea104d893f16aab430d9904473bc1f233f3c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"742168028ecb4838c124d27f836df9637be2f769","date":1529417708,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/AbstractCloudBackupRestoreTestCase#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/AbstractCloudBackupRestoreTestCase#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    boolean isImplicit = random().nextBoolean();\n    boolean doSplitShardOperation = !isImplicit && random().nextBoolean();\n    replFactor = TestUtil.nextInt(random(), 1, 2);\n    numTlogReplicas = TestUtil.nextInt(random(), 0, 1);\n    numPullReplicas = TestUtil.nextInt(random(), 0, 1);\n    int backupReplFactor = replFactor + numPullReplicas + numTlogReplicas;\n\n    CollectionAdminRequest.Create create = isImplicit ?\n        // NOTE: use shard list with same # of shards as NUM_SHARDS; we assume this later\n        CollectionAdminRequest.createCollectionWithImplicitRouter(getCollectionName(), \"conf1\", \"shard1,shard2\", replFactor, numTlogReplicas, numPullReplicas) :\n        CollectionAdminRequest.createCollection(getCollectionName(), \"conf1\", NUM_SHARDS, replFactor, numTlogReplicas, numPullReplicas);\n\n    if (NUM_SHARDS * (backupReplFactor) > cluster.getJettySolrRunners().size() || random().nextBoolean()) {\n      create.setMaxShardsPerNode((int)Math.ceil(NUM_SHARDS * backupReplFactor / (double) cluster.getJettySolrRunners().size()));//just to assert it survives the restoration\n      if (doSplitShardOperation) {\n        create.setMaxShardsPerNode(create.getMaxShardsPerNode() * 2);\n      }\n    }\n    if (random().nextBoolean()) {\n      create.setAutoAddReplicas(true);//just to assert it survives the restoration\n    }\n    Properties coreProps = new Properties();\n    coreProps.put(\"customKey\", \"customValue\");//just to assert it survives the restoration\n    create.setProperties(coreProps);\n    if (isImplicit) { //implicit router\n      create.setRouterField(\"shard_s\");\n    } else {//composite id router\n      if (random().nextBoolean()) {\n        create.setRouterField(\"shard_s\");\n      }\n    }\n\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.process(solrClient);\n\n    indexDocs(getCollectionName(), false);\n\n    if (doSplitShardOperation) {\n      // shard split the first shard\n      int prevActiveSliceCount = getActiveSliceCount(getCollectionName());\n      CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(getCollectionName());\n      splitShard.setShardName(\"shard1\");\n      splitShard.process(solrClient);\n      // wait until we see one more active slice...\n      for (int i = 0; getActiveSliceCount(getCollectionName()) != prevActiveSliceCount + 1; i++) {\n        assertTrue(i < 30);\n        Thread.sleep(500);\n      }\n      // issue a hard commit.  Split shard does a soft commit which isn't good enough for the backup/snapshooter to see\n      solrClient.commit(getCollectionName());\n    }\n\n    testBackupAndRestore(getCollectionName(), backupReplFactor);\n    testConfigBackupOnly(\"conf1\", getCollectionName());\n    testInvalidPath(getCollectionName());\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    boolean isImplicit = random().nextBoolean();\n    boolean doSplitShardOperation = !isImplicit && random().nextBoolean();\n    replFactor = TestUtil.nextInt(random(), 1, 2);\n    numTlogReplicas = TestUtil.nextInt(random(), 0, 1);\n    numPullReplicas = TestUtil.nextInt(random(), 0, 1);\n\n    CollectionAdminRequest.Create create = isImplicit ?\n        // NOTE: use shard list with same # of shards as NUM_SHARDS; we assume this later\n        CollectionAdminRequest.createCollectionWithImplicitRouter(getCollectionName(), \"conf1\", \"shard1,shard2\", replFactor, numTlogReplicas, numPullReplicas) :\n        CollectionAdminRequest.createCollection(getCollectionName(), \"conf1\", NUM_SHARDS, replFactor, numTlogReplicas, numPullReplicas);\n\n    if (NUM_SHARDS * (replFactor + numTlogReplicas + numPullReplicas) > cluster.getJettySolrRunners().size() || random().nextBoolean()) {\n      create.setMaxShardsPerNode((int)Math.ceil(NUM_SHARDS * (replFactor + numTlogReplicas + numPullReplicas) / cluster.getJettySolrRunners().size()));//just to assert it survives the restoration\n      if (doSplitShardOperation) {\n        create.setMaxShardsPerNode(create.getMaxShardsPerNode() * 2);\n      }\n    }\n    if (random().nextBoolean()) {\n      create.setAutoAddReplicas(true);//just to assert it survives the restoration\n    }\n    Properties coreProps = new Properties();\n    coreProps.put(\"customKey\", \"customValue\");//just to assert it survives the restoration\n    create.setProperties(coreProps);\n    if (isImplicit) { //implicit router\n      create.setRouterField(\"shard_s\");\n    } else {//composite id router\n      if (random().nextBoolean()) {\n        create.setRouterField(\"shard_s\");\n      }\n    }\n\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.process(solrClient);\n\n    indexDocs(getCollectionName(), false);\n\n    if (doSplitShardOperation) {\n      // shard split the first shard\n      int prevActiveSliceCount = getActiveSliceCount(getCollectionName());\n      CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(getCollectionName());\n      splitShard.setShardName(\"shard1\");\n      splitShard.process(solrClient);\n      // wait until we see one more active slice...\n      for (int i = 0; getActiveSliceCount(getCollectionName()) != prevActiveSliceCount + 1; i++) {\n        assertTrue(i < 30);\n        Thread.sleep(500);\n      }\n      // issue a hard commit.  Split shard does a soft commit which isn't good enough for the backup/snapshooter to see\n      solrClient.commit(getCollectionName());\n    }\n\n    testBackupAndRestore(getCollectionName());\n    testConfigBackupOnly(\"conf1\", getCollectionName());\n    testInvalidPath(getCollectionName());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"63ae38ccbfadf7f763ed165694f6ae139e167f09","date":1529571076,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/AbstractCloudBackupRestoreTestCase#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/AbstractCloudBackupRestoreTestCase#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    boolean isImplicit = random().nextBoolean();\n    boolean doSplitShardOperation = !isImplicit && random().nextBoolean();\n    replFactor = TestUtil.nextInt(random(), 1, 2);\n    numTlogReplicas = TestUtil.nextInt(random(), 0, 1);\n    numPullReplicas = TestUtil.nextInt(random(), 0, 1);\n    int backupReplFactor = replFactor + numPullReplicas + numTlogReplicas;\n\n    CollectionAdminRequest.Create create = isImplicit ?\n        // NOTE: use shard list with same # of shards as NUM_SHARDS; we assume this later\n        CollectionAdminRequest.createCollectionWithImplicitRouter(getCollectionName(), \"conf1\", \"shard1,shard2\", replFactor, numTlogReplicas, numPullReplicas) :\n        CollectionAdminRequest.createCollection(getCollectionName(), \"conf1\", NUM_SHARDS, replFactor, numTlogReplicas, numPullReplicas);\n\n    if (random().nextBoolean()) {\n      create.setMaxShardsPerNode(-1);\n    } else if (NUM_SHARDS * (backupReplFactor) > cluster.getJettySolrRunners().size() || random().nextBoolean()) {\n      create.setMaxShardsPerNode((int)Math.ceil(NUM_SHARDS * backupReplFactor / (double) cluster.getJettySolrRunners().size()));//just to assert it survives the restoration\n      if (doSplitShardOperation) {\n        create.setMaxShardsPerNode(create.getMaxShardsPerNode() * 2);\n      }\n    }\n    if (random().nextBoolean()) {\n      create.setAutoAddReplicas(true);//just to assert it survives the restoration\n    }\n    Properties coreProps = new Properties();\n    coreProps.put(\"customKey\", \"customValue\");//just to assert it survives the restoration\n    create.setProperties(coreProps);\n    if (isImplicit) { //implicit router\n      create.setRouterField(\"shard_s\");\n    } else {//composite id router\n      if (random().nextBoolean()) {\n        create.setRouterField(\"shard_s\");\n      }\n    }\n\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.process(solrClient);\n\n    indexDocs(getCollectionName(), false);\n\n    if (doSplitShardOperation) {\n      // shard split the first shard\n      int prevActiveSliceCount = getActiveSliceCount(getCollectionName());\n      CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(getCollectionName());\n      splitShard.setShardName(\"shard1\");\n      splitShard.process(solrClient);\n      // wait until we see one more active slice...\n      for (int i = 0; getActiveSliceCount(getCollectionName()) != prevActiveSliceCount + 1; i++) {\n        assertTrue(i < 30);\n        Thread.sleep(500);\n      }\n      // issue a hard commit.  Split shard does a soft commit which isn't good enough for the backup/snapshooter to see\n      solrClient.commit(getCollectionName());\n    }\n\n    testBackupAndRestore(getCollectionName(), backupReplFactor);\n    testConfigBackupOnly(\"conf1\", getCollectionName());\n    testInvalidPath(getCollectionName());\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    boolean isImplicit = random().nextBoolean();\n    boolean doSplitShardOperation = !isImplicit && random().nextBoolean();\n    replFactor = TestUtil.nextInt(random(), 1, 2);\n    numTlogReplicas = TestUtil.nextInt(random(), 0, 1);\n    numPullReplicas = TestUtil.nextInt(random(), 0, 1);\n    int backupReplFactor = replFactor + numPullReplicas + numTlogReplicas;\n\n    CollectionAdminRequest.Create create = isImplicit ?\n        // NOTE: use shard list with same # of shards as NUM_SHARDS; we assume this later\n        CollectionAdminRequest.createCollectionWithImplicitRouter(getCollectionName(), \"conf1\", \"shard1,shard2\", replFactor, numTlogReplicas, numPullReplicas) :\n        CollectionAdminRequest.createCollection(getCollectionName(), \"conf1\", NUM_SHARDS, replFactor, numTlogReplicas, numPullReplicas);\n\n    if (NUM_SHARDS * (backupReplFactor) > cluster.getJettySolrRunners().size() || random().nextBoolean()) {\n      create.setMaxShardsPerNode((int)Math.ceil(NUM_SHARDS * backupReplFactor / (double) cluster.getJettySolrRunners().size()));//just to assert it survives the restoration\n      if (doSplitShardOperation) {\n        create.setMaxShardsPerNode(create.getMaxShardsPerNode() * 2);\n      }\n    }\n    if (random().nextBoolean()) {\n      create.setAutoAddReplicas(true);//just to assert it survives the restoration\n    }\n    Properties coreProps = new Properties();\n    coreProps.put(\"customKey\", \"customValue\");//just to assert it survives the restoration\n    create.setProperties(coreProps);\n    if (isImplicit) { //implicit router\n      create.setRouterField(\"shard_s\");\n    } else {//composite id router\n      if (random().nextBoolean()) {\n        create.setRouterField(\"shard_s\");\n      }\n    }\n\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.process(solrClient);\n\n    indexDocs(getCollectionName(), false);\n\n    if (doSplitShardOperation) {\n      // shard split the first shard\n      int prevActiveSliceCount = getActiveSliceCount(getCollectionName());\n      CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(getCollectionName());\n      splitShard.setShardName(\"shard1\");\n      splitShard.process(solrClient);\n      // wait until we see one more active slice...\n      for (int i = 0; getActiveSliceCount(getCollectionName()) != prevActiveSliceCount + 1; i++) {\n        assertTrue(i < 30);\n        Thread.sleep(500);\n      }\n      // issue a hard commit.  Split shard does a soft commit which isn't good enough for the backup/snapshooter to see\n      solrClient.commit(getCollectionName());\n    }\n\n    testBackupAndRestore(getCollectionName(), backupReplFactor);\n    testConfigBackupOnly(\"conf1\", getCollectionName());\n    testInvalidPath(getCollectionName());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/AbstractCloudBackupRestoreTestCase#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/AbstractCloudBackupRestoreTestCase#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    boolean isImplicit = random().nextBoolean();\n    boolean doSplitShardOperation = !isImplicit && random().nextBoolean();\n    replFactor = TestUtil.nextInt(random(), 1, 2);\n    numTlogReplicas = TestUtil.nextInt(random(), 0, 1);\n    numPullReplicas = TestUtil.nextInt(random(), 0, 1);\n    int backupReplFactor = replFactor + numPullReplicas + numTlogReplicas;\n\n    CollectionAdminRequest.Create create = isImplicit ?\n        // NOTE: use shard list with same # of shards as NUM_SHARDS; we assume this later\n        CollectionAdminRequest.createCollectionWithImplicitRouter(getCollectionName(), \"conf1\", \"shard1,shard2\", replFactor, numTlogReplicas, numPullReplicas) :\n        CollectionAdminRequest.createCollection(getCollectionName(), \"conf1\", NUM_SHARDS, replFactor, numTlogReplicas, numPullReplicas);\n\n    if (random().nextBoolean()) {\n      create.setMaxShardsPerNode(-1);\n    } else if (NUM_SHARDS * (backupReplFactor) > cluster.getJettySolrRunners().size() || random().nextBoolean()) {\n      create.setMaxShardsPerNode((int)Math.ceil(NUM_SHARDS * backupReplFactor / (double) cluster.getJettySolrRunners().size()));//just to assert it survives the restoration\n      if (doSplitShardOperation) {\n        create.setMaxShardsPerNode(create.getMaxShardsPerNode() * 2);\n      }\n    }\n    if (random().nextBoolean()) {\n      create.setAutoAddReplicas(true);//just to assert it survives the restoration\n    }\n    Properties coreProps = new Properties();\n    coreProps.put(\"customKey\", \"customValue\");//just to assert it survives the restoration\n    create.setProperties(coreProps);\n    if (isImplicit) { //implicit router\n      create.setRouterField(\"shard_s\");\n    } else {//composite id router\n      if (random().nextBoolean()) {\n        create.setRouterField(\"shard_s\");\n      }\n    }\n\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.process(solrClient);\n\n    indexDocs(getCollectionName(), false);\n\n    if (doSplitShardOperation) {\n      // shard split the first shard\n      int prevActiveSliceCount = getActiveSliceCount(getCollectionName());\n      CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(getCollectionName());\n      splitShard.setShardName(\"shard1\");\n      splitShard.process(solrClient);\n      // wait until we see one more active slice...\n      for (int i = 0; getActiveSliceCount(getCollectionName()) != prevActiveSliceCount + 1; i++) {\n        assertTrue(i < 30);\n        Thread.sleep(500);\n      }\n      // issue a hard commit.  Split shard does a soft commit which isn't good enough for the backup/snapshooter to see\n      solrClient.commit(getCollectionName());\n    }\n\n    testBackupAndRestore(getCollectionName(), backupReplFactor);\n    testConfigBackupOnly(\"conf1\", getCollectionName());\n    testInvalidPath(getCollectionName());\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    boolean isImplicit = random().nextBoolean();\n    boolean doSplitShardOperation = !isImplicit && random().nextBoolean();\n    replFactor = TestUtil.nextInt(random(), 1, 2);\n    numTlogReplicas = TestUtil.nextInt(random(), 0, 1);\n    numPullReplicas = TestUtil.nextInt(random(), 0, 1);\n\n    CollectionAdminRequest.Create create = isImplicit ?\n        // NOTE: use shard list with same # of shards as NUM_SHARDS; we assume this later\n        CollectionAdminRequest.createCollectionWithImplicitRouter(getCollectionName(), \"conf1\", \"shard1,shard2\", replFactor, numTlogReplicas, numPullReplicas) :\n        CollectionAdminRequest.createCollection(getCollectionName(), \"conf1\", NUM_SHARDS, replFactor, numTlogReplicas, numPullReplicas);\n\n    if (NUM_SHARDS * (replFactor + numTlogReplicas + numPullReplicas) > cluster.getJettySolrRunners().size() || random().nextBoolean()) {\n      create.setMaxShardsPerNode((int)Math.ceil(NUM_SHARDS * (replFactor + numTlogReplicas + numPullReplicas) / cluster.getJettySolrRunners().size()));//just to assert it survives the restoration\n      if (doSplitShardOperation) {\n        create.setMaxShardsPerNode(create.getMaxShardsPerNode() * 2);\n      }\n    }\n    if (random().nextBoolean()) {\n      create.setAutoAddReplicas(true);//just to assert it survives the restoration\n    }\n    Properties coreProps = new Properties();\n    coreProps.put(\"customKey\", \"customValue\");//just to assert it survives the restoration\n    create.setProperties(coreProps);\n    if (isImplicit) { //implicit router\n      create.setRouterField(\"shard_s\");\n    } else {//composite id router\n      if (random().nextBoolean()) {\n        create.setRouterField(\"shard_s\");\n      }\n    }\n\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.process(solrClient);\n\n    indexDocs(getCollectionName(), false);\n\n    if (doSplitShardOperation) {\n      // shard split the first shard\n      int prevActiveSliceCount = getActiveSliceCount(getCollectionName());\n      CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(getCollectionName());\n      splitShard.setShardName(\"shard1\");\n      splitShard.process(solrClient);\n      // wait until we see one more active slice...\n      for (int i = 0; getActiveSliceCount(getCollectionName()) != prevActiveSliceCount + 1; i++) {\n        assertTrue(i < 30);\n        Thread.sleep(500);\n      }\n      // issue a hard commit.  Split shard does a soft commit which isn't good enough for the backup/snapshooter to see\n      solrClient.commit(getCollectionName());\n    }\n\n    testBackupAndRestore(getCollectionName());\n    testConfigBackupOnly(\"conf1\", getCollectionName());\n    testInvalidPath(getCollectionName());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/AbstractCloudBackupRestoreTestCase#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/AbstractCloudBackupRestoreTestCase#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    boolean isImplicit = random().nextBoolean();\n    boolean doSplitShardOperation = !isImplicit && random().nextBoolean();\n    replFactor = TestUtil.nextInt(random(), 1, 2);\n    numTlogReplicas = TestUtil.nextInt(random(), 0, 1);\n    numPullReplicas = TestUtil.nextInt(random(), 0, 1);\n    int backupReplFactor = replFactor + numPullReplicas + numTlogReplicas;\n\n    CollectionAdminRequest.Create create = isImplicit ?\n        // NOTE: use shard list with same # of shards as NUM_SHARDS; we assume this later\n        CollectionAdminRequest.createCollectionWithImplicitRouter(getCollectionName(), \"conf1\", \"shard1,shard2\", replFactor, numTlogReplicas, numPullReplicas) :\n        CollectionAdminRequest.createCollection(getCollectionName(), \"conf1\", NUM_SHARDS, replFactor, numTlogReplicas, numPullReplicas);\n\n    if (random().nextBoolean()) {\n      create.setMaxShardsPerNode(-1);\n    } else if (NUM_SHARDS * (backupReplFactor) > cluster.getJettySolrRunners().size() || random().nextBoolean()) {\n      create.setMaxShardsPerNode((int)Math.ceil(NUM_SHARDS * backupReplFactor / (double) cluster.getJettySolrRunners().size()));//just to assert it survives the restoration\n      if (doSplitShardOperation) {\n        create.setMaxShardsPerNode(create.getMaxShardsPerNode() * 2);\n      }\n    }\n    if (random().nextBoolean()) {\n      create.setAutoAddReplicas(true);//just to assert it survives the restoration\n    }\n    Properties coreProps = new Properties();\n    coreProps.put(\"customKey\", \"customValue\");//just to assert it survives the restoration\n    create.setProperties(coreProps);\n    if (isImplicit) { //implicit router\n      create.setRouterField(\"shard_s\");\n    } else {//composite id router\n      if (random().nextBoolean()) {\n        create.setRouterField(\"shard_s\");\n      }\n    }\n\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.process(solrClient);\n\n    indexDocs(getCollectionName(), false);\n\n    if (doSplitShardOperation) {\n      // shard split the first shard\n      int prevActiveSliceCount = getActiveSliceCount(getCollectionName());\n      CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(getCollectionName());\n      splitShard.setShardName(\"shard1\");\n      splitShard.process(solrClient);\n      // wait until we see one more active slice...\n      for (int i = 0; getActiveSliceCount(getCollectionName()) != prevActiveSliceCount + 1; i++) {\n        assertTrue(i < 30);\n        Thread.sleep(500);\n      }\n      // issue a hard commit.  Split shard does a soft commit which isn't good enough for the backup/snapshooter to see\n      solrClient.commit(getCollectionName());\n    }\n\n    testBackupAndRestore(getCollectionName(), backupReplFactor);\n    testConfigBackupOnly(\"conf1\", getCollectionName());\n    testInvalidPath(getCollectionName());\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    boolean isImplicit = random().nextBoolean();\n    boolean doSplitShardOperation = !isImplicit && random().nextBoolean();\n    replFactor = TestUtil.nextInt(random(), 1, 2);\n    numTlogReplicas = TestUtil.nextInt(random(), 0, 1);\n    numPullReplicas = TestUtil.nextInt(random(), 0, 1);\n\n    CollectionAdminRequest.Create create = isImplicit ?\n        // NOTE: use shard list with same # of shards as NUM_SHARDS; we assume this later\n        CollectionAdminRequest.createCollectionWithImplicitRouter(getCollectionName(), \"conf1\", \"shard1,shard2\", replFactor, numTlogReplicas, numPullReplicas) :\n        CollectionAdminRequest.createCollection(getCollectionName(), \"conf1\", NUM_SHARDS, replFactor, numTlogReplicas, numPullReplicas);\n\n    if (NUM_SHARDS * (replFactor + numTlogReplicas + numPullReplicas) > cluster.getJettySolrRunners().size() || random().nextBoolean()) {\n      create.setMaxShardsPerNode((int)Math.ceil(NUM_SHARDS * (replFactor + numTlogReplicas + numPullReplicas) / cluster.getJettySolrRunners().size()));//just to assert it survives the restoration\n      if (doSplitShardOperation) {\n        create.setMaxShardsPerNode(create.getMaxShardsPerNode() * 2);\n      }\n    }\n    if (random().nextBoolean()) {\n      create.setAutoAddReplicas(true);//just to assert it survives the restoration\n    }\n    Properties coreProps = new Properties();\n    coreProps.put(\"customKey\", \"customValue\");//just to assert it survives the restoration\n    create.setProperties(coreProps);\n    if (isImplicit) { //implicit router\n      create.setRouterField(\"shard_s\");\n    } else {//composite id router\n      if (random().nextBoolean()) {\n        create.setRouterField(\"shard_s\");\n      }\n    }\n\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.process(solrClient);\n\n    indexDocs(getCollectionName(), false);\n\n    if (doSplitShardOperation) {\n      // shard split the first shard\n      int prevActiveSliceCount = getActiveSliceCount(getCollectionName());\n      CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(getCollectionName());\n      splitShard.setShardName(\"shard1\");\n      splitShard.process(solrClient);\n      // wait until we see one more active slice...\n      for (int i = 0; getActiveSliceCount(getCollectionName()) != prevActiveSliceCount + 1; i++) {\n        assertTrue(i < 30);\n        Thread.sleep(500);\n      }\n      // issue a hard commit.  Split shard does a soft commit which isn't good enough for the backup/snapshooter to see\n      solrClient.commit(getCollectionName());\n    }\n\n    testBackupAndRestore(getCollectionName());\n    testConfigBackupOnly(\"conf1\", getCollectionName());\n    testInvalidPath(getCollectionName());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a64d56a8e1a34a05fef090cde8892dd4f00971ff","date":1532203507,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/AbstractCloudBackupRestoreTestCase#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/AbstractCloudBackupRestoreTestCase#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    boolean isImplicit = random().nextBoolean();\n    boolean doSplitShardOperation = !isImplicit && random().nextBoolean();\n    replFactor = TestUtil.nextInt(random(), 1, 2);\n    numTlogReplicas = TestUtil.nextInt(random(), 0, 1);\n    numPullReplicas = TestUtil.nextInt(random(), 0, 1);\n    int backupReplFactor = replFactor + numPullReplicas + numTlogReplicas;\n\n    CollectionAdminRequest.Create create = isImplicit ?\n        // NOTE: use shard list with same # of shards as NUM_SHARDS; we assume this later\n        CollectionAdminRequest.createCollectionWithImplicitRouter(getCollectionName(), \"conf1\", \"shard1,shard2\", replFactor, numTlogReplicas, numPullReplicas) :\n        CollectionAdminRequest.createCollection(getCollectionName(), \"conf1\", NUM_SHARDS, replFactor, numTlogReplicas, numPullReplicas);\n\n    if (random().nextBoolean()) {\n      create.setMaxShardsPerNode(-1);\n    } else if (doSplitShardOperation) {\n      create.setMaxShardsPerNode((int) Math.ceil(NUM_SPLIT_SHARDS * backupReplFactor / (double) cluster.getJettySolrRunners().size()));\n    } else if (NUM_SHARDS * (backupReplFactor) > cluster.getJettySolrRunners().size() || random().nextBoolean()) {\n      create.setMaxShardsPerNode((int) Math.ceil(NUM_SHARDS * backupReplFactor / (double) cluster.getJettySolrRunners().size()));//just to assert it survives the restoration\n    }\n\n    if (random().nextBoolean()) {\n      create.setAutoAddReplicas(true);//just to assert it survives the restoration\n    }\n    Properties coreProps = new Properties();\n    coreProps.put(\"customKey\", \"customValue\");//just to assert it survives the restoration\n    create.setProperties(coreProps);\n    if (isImplicit) { //implicit router\n      create.setRouterField(\"shard_s\");\n    } else {//composite id router\n      if (random().nextBoolean()) {\n        create.setRouterField(\"shard_s\");\n      }\n    }\n\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.process(solrClient);\n\n    indexDocs(getCollectionName(), false);\n\n    if (doSplitShardOperation) {\n      // shard split the first shard\n      int prevActiveSliceCount = getActiveSliceCount(getCollectionName());\n      CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(getCollectionName());\n      splitShard.setShardName(\"shard1\");\n      splitShard.process(solrClient);\n      // wait until we see one more active slice...\n      for (int i = 0; getActiveSliceCount(getCollectionName()) != prevActiveSliceCount + 1; i++) {\n        assertTrue(i < 30);\n        Thread.sleep(500);\n      }\n      // issue a hard commit.  Split shard does a soft commit which isn't good enough for the backup/snapshooter to see\n      solrClient.commit(getCollectionName());\n    }\n\n    testBackupAndRestore(getCollectionName(), backupReplFactor);\n    testConfigBackupOnly(\"conf1\", getCollectionName());\n    testInvalidPath(getCollectionName());\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    boolean isImplicit = random().nextBoolean();\n    boolean doSplitShardOperation = !isImplicit && random().nextBoolean();\n    replFactor = TestUtil.nextInt(random(), 1, 2);\n    numTlogReplicas = TestUtil.nextInt(random(), 0, 1);\n    numPullReplicas = TestUtil.nextInt(random(), 0, 1);\n    int backupReplFactor = replFactor + numPullReplicas + numTlogReplicas;\n\n    CollectionAdminRequest.Create create = isImplicit ?\n        // NOTE: use shard list with same # of shards as NUM_SHARDS; we assume this later\n        CollectionAdminRequest.createCollectionWithImplicitRouter(getCollectionName(), \"conf1\", \"shard1,shard2\", replFactor, numTlogReplicas, numPullReplicas) :\n        CollectionAdminRequest.createCollection(getCollectionName(), \"conf1\", NUM_SHARDS, replFactor, numTlogReplicas, numPullReplicas);\n\n    if (random().nextBoolean()) {\n      create.setMaxShardsPerNode(-1);\n    } else if (NUM_SHARDS * (backupReplFactor) > cluster.getJettySolrRunners().size() || random().nextBoolean()) {\n      create.setMaxShardsPerNode((int)Math.ceil(NUM_SHARDS * backupReplFactor / (double) cluster.getJettySolrRunners().size()));//just to assert it survives the restoration\n      if (doSplitShardOperation) {\n        create.setMaxShardsPerNode(create.getMaxShardsPerNode() * 2);\n      }\n    }\n    if (random().nextBoolean()) {\n      create.setAutoAddReplicas(true);//just to assert it survives the restoration\n    }\n    Properties coreProps = new Properties();\n    coreProps.put(\"customKey\", \"customValue\");//just to assert it survives the restoration\n    create.setProperties(coreProps);\n    if (isImplicit) { //implicit router\n      create.setRouterField(\"shard_s\");\n    } else {//composite id router\n      if (random().nextBoolean()) {\n        create.setRouterField(\"shard_s\");\n      }\n    }\n\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.process(solrClient);\n\n    indexDocs(getCollectionName(), false);\n\n    if (doSplitShardOperation) {\n      // shard split the first shard\n      int prevActiveSliceCount = getActiveSliceCount(getCollectionName());\n      CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(getCollectionName());\n      splitShard.setShardName(\"shard1\");\n      splitShard.process(solrClient);\n      // wait until we see one more active slice...\n      for (int i = 0; getActiveSliceCount(getCollectionName()) != prevActiveSliceCount + 1; i++) {\n        assertTrue(i < 30);\n        Thread.sleep(500);\n      }\n      // issue a hard commit.  Split shard does a soft commit which isn't good enough for the backup/snapshooter to see\n      solrClient.commit(getCollectionName());\n    }\n\n    testBackupAndRestore(getCollectionName(), backupReplFactor);\n    testConfigBackupOnly(\"conf1\", getCollectionName());\n    testInvalidPath(getCollectionName());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab6131420a270c49b653c969cc1dbbaf7d1b36e7","date":1550697886,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/AbstractCloudBackupRestoreTestCase#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/AbstractCloudBackupRestoreTestCase#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    setTestSuffix(\"testok\");\n    boolean isImplicit = random().nextBoolean();\n    boolean doSplitShardOperation = !isImplicit && random().nextBoolean();\n    replFactor = TestUtil.nextInt(random(), 1, 2);\n    numTlogReplicas = TestUtil.nextInt(random(), 0, 1);\n    numPullReplicas = TestUtil.nextInt(random(), 0, 1);\n    int backupReplFactor = replFactor + numPullReplicas + numTlogReplicas;\n\n    CollectionAdminRequest.Create create = isImplicit ?\n        // NOTE: use shard list with same # of shards as NUM_SHARDS; we assume this later\n        CollectionAdminRequest.createCollectionWithImplicitRouter(getCollectionName(), \"conf1\", \"shard1,shard2\", replFactor, numTlogReplicas, numPullReplicas) :\n        CollectionAdminRequest.createCollection(getCollectionName(), \"conf1\", NUM_SHARDS, replFactor, numTlogReplicas, numPullReplicas);\n\n    if (random().nextBoolean()) {\n      create.setMaxShardsPerNode(-1);\n    } else if (doSplitShardOperation) {\n      create.setMaxShardsPerNode((int) Math.ceil(NUM_SPLIT_SHARDS * backupReplFactor / (double) cluster.getJettySolrRunners().size()));\n    } else if (NUM_SHARDS * (backupReplFactor) > cluster.getJettySolrRunners().size() || random().nextBoolean()) {\n      create.setMaxShardsPerNode((int) Math.ceil(NUM_SHARDS * backupReplFactor / (double) cluster.getJettySolrRunners().size()));//just to assert it survives the restoration\n    }\n\n    if (random().nextBoolean()) {\n      create.setAutoAddReplicas(true);//just to assert it survives the restoration\n    }\n    Properties coreProps = new Properties();\n    coreProps.put(\"customKey\", \"customValue\");//just to assert it survives the restoration\n    create.setProperties(coreProps);\n    if (isImplicit) { //implicit router\n      create.setRouterField(\"shard_s\");\n    } else {//composite id router\n      if (random().nextBoolean()) {\n        create.setRouterField(\"shard_s\");\n      }\n    }\n\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.process(solrClient);\n\n    indexDocs(getCollectionName(), false);\n\n    if (doSplitShardOperation) {\n      // shard split the first shard\n      int prevActiveSliceCount = getActiveSliceCount(getCollectionName());\n      CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(getCollectionName());\n      splitShard.setShardName(\"shard1\");\n      splitShard.process(solrClient);\n      // wait until we see one more active slice...\n      for (int i = 0; getActiveSliceCount(getCollectionName()) != prevActiveSliceCount + 1; i++) {\n        assertTrue(i < 30);\n        Thread.sleep(500);\n      }\n      // issue a hard commit.  Split shard does a soft commit which isn't good enough for the backup/snapshooter to see\n      solrClient.commit(getCollectionName());\n    }\n\n    testBackupAndRestore(getCollectionName(), backupReplFactor);\n    testConfigBackupOnly(\"conf1\", getCollectionName());\n    testInvalidPath(getCollectionName());\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    boolean isImplicit = random().nextBoolean();\n    boolean doSplitShardOperation = !isImplicit && random().nextBoolean();\n    replFactor = TestUtil.nextInt(random(), 1, 2);\n    numTlogReplicas = TestUtil.nextInt(random(), 0, 1);\n    numPullReplicas = TestUtil.nextInt(random(), 0, 1);\n    int backupReplFactor = replFactor + numPullReplicas + numTlogReplicas;\n\n    CollectionAdminRequest.Create create = isImplicit ?\n        // NOTE: use shard list with same # of shards as NUM_SHARDS; we assume this later\n        CollectionAdminRequest.createCollectionWithImplicitRouter(getCollectionName(), \"conf1\", \"shard1,shard2\", replFactor, numTlogReplicas, numPullReplicas) :\n        CollectionAdminRequest.createCollection(getCollectionName(), \"conf1\", NUM_SHARDS, replFactor, numTlogReplicas, numPullReplicas);\n\n    if (random().nextBoolean()) {\n      create.setMaxShardsPerNode(-1);\n    } else if (doSplitShardOperation) {\n      create.setMaxShardsPerNode((int) Math.ceil(NUM_SPLIT_SHARDS * backupReplFactor / (double) cluster.getJettySolrRunners().size()));\n    } else if (NUM_SHARDS * (backupReplFactor) > cluster.getJettySolrRunners().size() || random().nextBoolean()) {\n      create.setMaxShardsPerNode((int) Math.ceil(NUM_SHARDS * backupReplFactor / (double) cluster.getJettySolrRunners().size()));//just to assert it survives the restoration\n    }\n\n    if (random().nextBoolean()) {\n      create.setAutoAddReplicas(true);//just to assert it survives the restoration\n    }\n    Properties coreProps = new Properties();\n    coreProps.put(\"customKey\", \"customValue\");//just to assert it survives the restoration\n    create.setProperties(coreProps);\n    if (isImplicit) { //implicit router\n      create.setRouterField(\"shard_s\");\n    } else {//composite id router\n      if (random().nextBoolean()) {\n        create.setRouterField(\"shard_s\");\n      }\n    }\n\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.process(solrClient);\n\n    indexDocs(getCollectionName(), false);\n\n    if (doSplitShardOperation) {\n      // shard split the first shard\n      int prevActiveSliceCount = getActiveSliceCount(getCollectionName());\n      CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(getCollectionName());\n      splitShard.setShardName(\"shard1\");\n      splitShard.process(solrClient);\n      // wait until we see one more active slice...\n      for (int i = 0; getActiveSliceCount(getCollectionName()) != prevActiveSliceCount + 1; i++) {\n        assertTrue(i < 30);\n        Thread.sleep(500);\n      }\n      // issue a hard commit.  Split shard does a soft commit which isn't good enough for the backup/snapshooter to see\n      solrClient.commit(getCollectionName());\n    }\n\n    testBackupAndRestore(getCollectionName(), backupReplFactor);\n    testConfigBackupOnly(\"conf1\", getCollectionName());\n    testInvalidPath(getCollectionName());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/AbstractCloudBackupRestoreTestCase#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/AbstractCloudBackupRestoreTestCase#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    setTestSuffix(\"testok\");\n    boolean isImplicit = random().nextBoolean();\n    boolean doSplitShardOperation = !isImplicit && random().nextBoolean();\n    replFactor = TestUtil.nextInt(random(), 1, 2);\n    numTlogReplicas = TestUtil.nextInt(random(), 0, 1);\n    numPullReplicas = TestUtil.nextInt(random(), 0, 1);\n    int backupReplFactor = replFactor + numPullReplicas + numTlogReplicas;\n\n    CollectionAdminRequest.Create create = isImplicit ?\n        // NOTE: use shard list with same # of shards as NUM_SHARDS; we assume this later\n        CollectionAdminRequest.createCollectionWithImplicitRouter(getCollectionName(), \"conf1\", \"shard1,shard2\", replFactor, numTlogReplicas, numPullReplicas) :\n        CollectionAdminRequest.createCollection(getCollectionName(), \"conf1\", NUM_SHARDS, replFactor, numTlogReplicas, numPullReplicas);\n\n    if (random().nextBoolean()) {\n      create.setAutoAddReplicas(true);//just to assert it survives the restoration\n    }\n    Properties coreProps = new Properties();\n    coreProps.put(\"customKey\", \"customValue\");//just to assert it survives the restoration\n    create.setProperties(coreProps);\n    if (isImplicit) { //implicit router\n      create.setRouterField(\"shard_s\");\n    } else {//composite id router\n      if (random().nextBoolean()) {\n        create.setRouterField(\"shard_s\");\n      }\n    }\n\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.process(solrClient);\n\n    indexDocs(getCollectionName(), false);\n\n    if (doSplitShardOperation) {\n      // shard split the first shard\n      int prevActiveSliceCount = getActiveSliceCount(getCollectionName());\n      CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(getCollectionName());\n      splitShard.setShardName(\"shard1\");\n      splitShard.process(solrClient);\n      // wait until we see one more active slice...\n      for (int i = 0; getActiveSliceCount(getCollectionName()) != prevActiveSliceCount + 1; i++) {\n        assertTrue(i < 30);\n        Thread.sleep(500);\n      }\n      // issue a hard commit.  Split shard does a soft commit which isn't good enough for the backup/snapshooter to see\n      solrClient.commit(getCollectionName());\n    }\n\n    testBackupAndRestore(getCollectionName(), backupReplFactor);\n    testConfigBackupOnly(\"conf1\", getCollectionName());\n    testInvalidPath(getCollectionName());\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    setTestSuffix(\"testok\");\n    boolean isImplicit = random().nextBoolean();\n    boolean doSplitShardOperation = !isImplicit && random().nextBoolean();\n    replFactor = TestUtil.nextInt(random(), 1, 2);\n    numTlogReplicas = TestUtil.nextInt(random(), 0, 1);\n    numPullReplicas = TestUtil.nextInt(random(), 0, 1);\n    int backupReplFactor = replFactor + numPullReplicas + numTlogReplicas;\n\n    CollectionAdminRequest.Create create = isImplicit ?\n        // NOTE: use shard list with same # of shards as NUM_SHARDS; we assume this later\n        CollectionAdminRequest.createCollectionWithImplicitRouter(getCollectionName(), \"conf1\", \"shard1,shard2\", replFactor, numTlogReplicas, numPullReplicas) :\n        CollectionAdminRequest.createCollection(getCollectionName(), \"conf1\", NUM_SHARDS, replFactor, numTlogReplicas, numPullReplicas);\n\n    if (random().nextBoolean()) {\n      create.setMaxShardsPerNode(-1);\n    } else if (doSplitShardOperation) {\n      create.setMaxShardsPerNode((int) Math.ceil(NUM_SPLIT_SHARDS * backupReplFactor / (double) cluster.getJettySolrRunners().size()));\n    } else if (NUM_SHARDS * (backupReplFactor) > cluster.getJettySolrRunners().size() || random().nextBoolean()) {\n      create.setMaxShardsPerNode((int) Math.ceil(NUM_SHARDS * backupReplFactor / (double) cluster.getJettySolrRunners().size()));//just to assert it survives the restoration\n    }\n\n    if (random().nextBoolean()) {\n      create.setAutoAddReplicas(true);//just to assert it survives the restoration\n    }\n    Properties coreProps = new Properties();\n    coreProps.put(\"customKey\", \"customValue\");//just to assert it survives the restoration\n    create.setProperties(coreProps);\n    if (isImplicit) { //implicit router\n      create.setRouterField(\"shard_s\");\n    } else {//composite id router\n      if (random().nextBoolean()) {\n        create.setRouterField(\"shard_s\");\n      }\n    }\n\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.process(solrClient);\n\n    indexDocs(getCollectionName(), false);\n\n    if (doSplitShardOperation) {\n      // shard split the first shard\n      int prevActiveSliceCount = getActiveSliceCount(getCollectionName());\n      CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(getCollectionName());\n      splitShard.setShardName(\"shard1\");\n      splitShard.process(solrClient);\n      // wait until we see one more active slice...\n      for (int i = 0; getActiveSliceCount(getCollectionName()) != prevActiveSliceCount + 1; i++) {\n        assertTrue(i < 30);\n        Thread.sleep(500);\n      }\n      // issue a hard commit.  Split shard does a soft commit which isn't good enough for the backup/snapshooter to see\n      solrClient.commit(getCollectionName());\n    }\n\n    testBackupAndRestore(getCollectionName(), backupReplFactor);\n    testConfigBackupOnly(\"conf1\", getCollectionName());\n    testInvalidPath(getCollectionName());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/AbstractCloudBackupRestoreTestCase#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/AbstractCloudBackupRestoreTestCase#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    setTestSuffix(\"testok\");\n    boolean isImplicit = random().nextBoolean();\n    boolean doSplitShardOperation = !isImplicit && random().nextBoolean();\n    replFactor = TestUtil.nextInt(random(), 1, 2);\n    numTlogReplicas = TestUtil.nextInt(random(), 0, 1);\n    numPullReplicas = TestUtil.nextInt(random(), 0, 1);\n    int backupReplFactor = replFactor + numPullReplicas + numTlogReplicas;\n\n    CollectionAdminRequest.Create create = isImplicit ?\n        // NOTE: use shard list with same # of shards as NUM_SHARDS; we assume this later\n        CollectionAdminRequest.createCollectionWithImplicitRouter(getCollectionName(), \"conf1\", \"shard1,shard2\", replFactor, numTlogReplicas, numPullReplicas) :\n        CollectionAdminRequest.createCollection(getCollectionName(), \"conf1\", NUM_SHARDS, replFactor, numTlogReplicas, numPullReplicas);\n\n    Properties coreProps = new Properties();\n    coreProps.put(\"customKey\", \"customValue\");//just to assert it survives the restoration\n    create.setProperties(coreProps);\n    if (isImplicit) { //implicit router\n      create.setRouterField(\"shard_s\");\n    } else {//composite id router\n      if (random().nextBoolean()) {\n        create.setRouterField(\"shard_s\");\n      }\n    }\n\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.process(solrClient);\n\n    indexDocs(getCollectionName(), false);\n\n    if (doSplitShardOperation) {\n      // shard split the first shard\n      int prevActiveSliceCount = getActiveSliceCount(getCollectionName());\n      CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(getCollectionName());\n      splitShard.setShardName(\"shard1\");\n      splitShard.process(solrClient);\n      // wait until we see one more active slice...\n      for (int i = 0; getActiveSliceCount(getCollectionName()) != prevActiveSliceCount + 1; i++) {\n        assertTrue(i < 30);\n        Thread.sleep(500);\n      }\n      // issue a hard commit.  Split shard does a soft commit which isn't good enough for the backup/snapshooter to see\n      solrClient.commit(getCollectionName());\n    }\n\n    testBackupAndRestore(getCollectionName(), backupReplFactor);\n    testConfigBackupOnly(\"conf1\", getCollectionName());\n    testInvalidPath(getCollectionName());\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    setTestSuffix(\"testok\");\n    boolean isImplicit = random().nextBoolean();\n    boolean doSplitShardOperation = !isImplicit && random().nextBoolean();\n    replFactor = TestUtil.nextInt(random(), 1, 2);\n    numTlogReplicas = TestUtil.nextInt(random(), 0, 1);\n    numPullReplicas = TestUtil.nextInt(random(), 0, 1);\n    int backupReplFactor = replFactor + numPullReplicas + numTlogReplicas;\n\n    CollectionAdminRequest.Create create = isImplicit ?\n        // NOTE: use shard list with same # of shards as NUM_SHARDS; we assume this later\n        CollectionAdminRequest.createCollectionWithImplicitRouter(getCollectionName(), \"conf1\", \"shard1,shard2\", replFactor, numTlogReplicas, numPullReplicas) :\n        CollectionAdminRequest.createCollection(getCollectionName(), \"conf1\", NUM_SHARDS, replFactor, numTlogReplicas, numPullReplicas);\n\n    if (random().nextBoolean()) {\n      create.setAutoAddReplicas(true);//just to assert it survives the restoration\n    }\n    Properties coreProps = new Properties();\n    coreProps.put(\"customKey\", \"customValue\");//just to assert it survives the restoration\n    create.setProperties(coreProps);\n    if (isImplicit) { //implicit router\n      create.setRouterField(\"shard_s\");\n    } else {//composite id router\n      if (random().nextBoolean()) {\n        create.setRouterField(\"shard_s\");\n      }\n    }\n\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.process(solrClient);\n\n    indexDocs(getCollectionName(), false);\n\n    if (doSplitShardOperation) {\n      // shard split the first shard\n      int prevActiveSliceCount = getActiveSliceCount(getCollectionName());\n      CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(getCollectionName());\n      splitShard.setShardName(\"shard1\");\n      splitShard.process(solrClient);\n      // wait until we see one more active slice...\n      for (int i = 0; getActiveSliceCount(getCollectionName()) != prevActiveSliceCount + 1; i++) {\n        assertTrue(i < 30);\n        Thread.sleep(500);\n      }\n      // issue a hard commit.  Split shard does a soft commit which isn't good enough for the backup/snapshooter to see\n      solrClient.commit(getCollectionName());\n    }\n\n    testBackupAndRestore(getCollectionName(), backupReplFactor);\n    testConfigBackupOnly(\"conf1\", getCollectionName());\n    testInvalidPath(getCollectionName());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"a64d56a8e1a34a05fef090cde8892dd4f00971ff":["63ae38ccbfadf7f763ed165694f6ae139e167f09"],"3f504512a03d978990cbff30db0522b354e846db":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"63ae38ccbfadf7f763ed165694f6ae139e167f09":["742168028ecb4838c124d27f836df9637be2f769"],"742168028ecb4838c124d27f836df9637be2f769":["076d58da25128e8a4c511abf07c5d86c4ebddcbf"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["ab6131420a270c49b653c969cc1dbbaf7d1b36e7"],"076d58da25128e8a4c511abf07c5d86c4ebddcbf":["b94236357aaa22b76c10629851fe4e376e0cea82"],"ab6131420a270c49b653c969cc1dbbaf7d1b36e7":["a64d56a8e1a34a05fef090cde8892dd4f00971ff"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["076d58da25128e8a4c511abf07c5d86c4ebddcbf","63ae38ccbfadf7f763ed165694f6ae139e167f09"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["076d58da25128e8a4c511abf07c5d86c4ebddcbf","63ae38ccbfadf7f763ed165694f6ae139e167f09"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["076d58da25128e8a4c511abf07c5d86c4ebddcbf"],"a64d56a8e1a34a05fef090cde8892dd4f00971ff":["ab6131420a270c49b653c969cc1dbbaf7d1b36e7"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"63ae38ccbfadf7f763ed165694f6ae139e167f09":["a64d56a8e1a34a05fef090cde8892dd4f00971ff","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"742168028ecb4838c124d27f836df9637be2f769":["63ae38ccbfadf7f763ed165694f6ae139e167f09"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["3f504512a03d978990cbff30db0522b354e846db"],"076d58da25128e8a4c511abf07c5d86c4ebddcbf":["742168028ecb4838c124d27f836df9637be2f769","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"ab6131420a270c49b653c969cc1dbbaf7d1b36e7":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b94236357aaa22b76c10629851fe4e376e0cea82","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}