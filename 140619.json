{"path":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#SimCloudManager(TimeSource).mjava","commits":[{"id":"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","date":1513252583,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#SimCloudManager(TimeSource).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Create a simulated cluster. This cluster uses the following components:\n   * <ul>\n   *   <li>{@link SimDistribStateManager} with non-shared root node.</li>\n   *   <li>{@link SimClusterStateProvider}</li>\n   *   <li>{@link SimNodeStateProvider}, where node values are automatically initialized when using\n   *   {@link #simAddNode()} method.</li>\n   *   <li>{@link GenericDistributedQueueFactory} that uses {@link SimDistribStateManager} as its storage.</li>\n   *   <li>an instance of {@link AutoScalingHandler} for managing AutoScalingConfig.</li>\n   *   <li>an instance of {@link OverseerTriggerThread} for managing triggers and processing events.</li>\n   * </ul>\n   * @param timeSource time source to use.\n   */\n  public SimCloudManager(TimeSource timeSource) throws Exception {\n    this.stateManager = new SimDistribStateManager(SimDistribStateManager.createNewRootNode());\n    this.loader = new SolrResourceLoader();\n    // init common paths\n    stateManager.makePath(ZkStateReader.CLUSTER_STATE);\n    stateManager.makePath(ZkStateReader.CLUSTER_PROPS);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH);\n    stateManager.makePath(ZkStateReader.LIVE_NODES_ZKNODE);\n    stateManager.makePath(ZkStateReader.ROLES);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_EVENTS_PATH);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_LOST_PATH);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n\n    this.timeSource = timeSource != null ? timeSource : TimeSource.NANO_TIME;\n    this.clusterStateProvider = new SimClusterStateProvider(liveNodesSet, this);\n    this.nodeStateProvider = new SimNodeStateProvider(liveNodesSet, this.stateManager, this.clusterStateProvider, null);\n    this.queueFactory = new GenericDistributedQueueFactory(stateManager);\n    this.simCloudManagerPool = ExecutorUtil.newMDCAwareFixedThreadPool(200, new DefaultSolrThreadFactory(\"simCloudManagerPool\"));\n    this.autoScalingHandler = new AutoScalingHandler(this, loader);\n    triggerThreadGroup = new ThreadGroup(\"Simulated Overseer autoscaling triggers\");\n    OverseerTriggerThread trigger = new OverseerTriggerThread(loader, this,\n        new CloudConfig.CloudConfigBuilder(\"nonexistent\", 0, \"sim\").build());\n    triggerThread = new Overseer.OverseerThread(triggerThreadGroup, trigger, \"Simulated OverseerAutoScalingTriggerThread\");\n    triggerThread.start();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a","date":1527582939,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#SimCloudManager(TimeSource).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#SimCloudManager(TimeSource).mjava","sourceNew":"  /**\n   * Create a simulated cluster. This cluster uses the following components:\n   * <ul>\n   *   <li>{@link SimDistribStateManager} with non-shared root node.</li>\n   *   <li>{@link SimClusterStateProvider}</li>\n   *   <li>{@link SimNodeStateProvider}, where node values are automatically initialized when using\n   *   {@link #simAddNode()} method.</li>\n   *   <li>{@link GenericDistributedQueueFactory} that uses {@link SimDistribStateManager} as its storage.</li>\n   *   <li>an instance of {@link AutoScalingHandler} for managing AutoScalingConfig.</li>\n   *   <li>an instance of {@link OverseerTriggerThread} for managing triggers and processing events.</li>\n   * </ul>\n   * @param timeSource time source to use.\n   */\n  public SimCloudManager(TimeSource timeSource) throws Exception {\n    this.stateManager = new SimDistribStateManager(SimDistribStateManager.createNewRootNode());\n    this.loader = new SolrResourceLoader();\n    // init common paths\n    stateManager.makePath(ZkStateReader.CLUSTER_STATE);\n    stateManager.makePath(ZkStateReader.CLUSTER_PROPS);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH);\n    stateManager.makePath(ZkStateReader.LIVE_NODES_ZKNODE);\n    stateManager.makePath(ZkStateReader.ROLES);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_EVENTS_PATH);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_LOST_PATH);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n    stateManager.makePath(Overseer.OVERSEER_ELECT);\n\n    // register common metrics\n    metricTag = Integer.toHexString(hashCode());\n    String registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm);\n    metricManager.registerAll(registryName, new AltBufferPoolMetricSet(), true, \"buffers\");\n    metricManager.registerAll(registryName, new ClassLoadingGaugeSet(), true, \"classes\");\n    metricManager.registerAll(registryName, new OperatingSystemMetricSet(), true, \"os\");\n    metricManager.registerAll(registryName, new GarbageCollectorMetricSet(), true, \"gc\");\n    metricManager.registerAll(registryName, new MemoryUsageGaugeSet(), true, \"memory\");\n    metricManager.registerAll(registryName, new ThreadStatesGaugeSet(), true, \"threads\"); // todo should we use CachedThreadStatesGaugeSet instead?\n    MetricsMap sysprops = new MetricsMap((detailed, map) -> {\n      System.getProperties().forEach((k, v) -> {\n        map.put(String.valueOf(k), v);\n      });\n    });\n    metricManager.registerGauge(null, registryName, sysprops, metricTag, true, \"properties\", \"system\");\n\n    registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.node);\n    metricManager.registerGauge(null, registryName, () -> new File(\"/\").getUsableSpace(),\n        metricTag, true, \"usableSpace\", SolrInfoBean.Category.CONTAINER.toString(), \"fs\", \"coreRoot\");\n\n    solrClient = new MockSearchableSolrClient() {\n      @Override\n      public NamedList<Object> request(SolrRequest request, String collection) throws SolrServerException, IOException {\n        if (collection != null) {\n          if (request instanceof AbstractUpdateRequest) {\n            ((AbstractUpdateRequest)request).setParam(\"collection\", collection);\n          } else if (request instanceof QueryRequest) {\n            if (request.getPath() != null && (\n                request.getPath().startsWith(\"/admin/autoscaling\") ||\n                request.getPath().startsWith(\"/cluster/autoscaling\") ||\n            request.getPath().startsWith(\"/admin/metrics/history\") ||\n                request.getPath().startsWith(\"/cluster/metrics/history\")\n            )) {\n              // forward it\n              ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n              params.set(\"collection\", collection);\n              request = new QueryRequest(params);\n            } else {\n              // search request\n              return super.request(request, collection);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"when collection != null only UpdateRequest and QueryRequest are supported: request=\" + request + \", collection=\" + collection);\n          }\n        }\n        try {\n          SolrResponse rsp = SimCloudManager.this.request(request);\n          return rsp.getResponse();\n        } catch (UnsupportedOperationException e) {\n          throw new SolrServerException(e);\n        }\n      }\n    };\n\n\n    this.timeSource = timeSource != null ? timeSource : TimeSource.NANO_TIME;\n    this.clusterStateProvider = new SimClusterStateProvider(liveNodesSet, this);\n    this.nodeStateProvider = new SimNodeStateProvider(liveNodesSet, this.stateManager, this.clusterStateProvider, null);\n    this.queueFactory = new GenericDistributedQueueFactory(stateManager);\n    this.simCloudManagerPool = ExecutorUtil.newMDCAwareFixedThreadPool(200, new DefaultSolrThreadFactory(\"simCloudManagerPool\"));\n\n    this.autoScalingHandler = new AutoScalingHandler(this, loader);\n\n\n    triggerThreadGroup = new ThreadGroup(\"Simulated Overseer autoscaling triggers\");\n    OverseerTriggerThread trigger = new OverseerTriggerThread(loader, this,\n        new CloudConfig.CloudConfigBuilder(\"nonexistent\", 0, \"sim\").build());\n    triggerThread = new Overseer.OverseerThread(triggerThreadGroup, trigger, \"Simulated OverseerAutoScalingTriggerThread\");\n    triggerThread.start();\n  }\n\n","sourceOld":"  /**\n   * Create a simulated cluster. This cluster uses the following components:\n   * <ul>\n   *   <li>{@link SimDistribStateManager} with non-shared root node.</li>\n   *   <li>{@link SimClusterStateProvider}</li>\n   *   <li>{@link SimNodeStateProvider}, where node values are automatically initialized when using\n   *   {@link #simAddNode()} method.</li>\n   *   <li>{@link GenericDistributedQueueFactory} that uses {@link SimDistribStateManager} as its storage.</li>\n   *   <li>an instance of {@link AutoScalingHandler} for managing AutoScalingConfig.</li>\n   *   <li>an instance of {@link OverseerTriggerThread} for managing triggers and processing events.</li>\n   * </ul>\n   * @param timeSource time source to use.\n   */\n  public SimCloudManager(TimeSource timeSource) throws Exception {\n    this.stateManager = new SimDistribStateManager(SimDistribStateManager.createNewRootNode());\n    this.loader = new SolrResourceLoader();\n    // init common paths\n    stateManager.makePath(ZkStateReader.CLUSTER_STATE);\n    stateManager.makePath(ZkStateReader.CLUSTER_PROPS);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH);\n    stateManager.makePath(ZkStateReader.LIVE_NODES_ZKNODE);\n    stateManager.makePath(ZkStateReader.ROLES);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_EVENTS_PATH);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_LOST_PATH);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n\n    this.timeSource = timeSource != null ? timeSource : TimeSource.NANO_TIME;\n    this.clusterStateProvider = new SimClusterStateProvider(liveNodesSet, this);\n    this.nodeStateProvider = new SimNodeStateProvider(liveNodesSet, this.stateManager, this.clusterStateProvider, null);\n    this.queueFactory = new GenericDistributedQueueFactory(stateManager);\n    this.simCloudManagerPool = ExecutorUtil.newMDCAwareFixedThreadPool(200, new DefaultSolrThreadFactory(\"simCloudManagerPool\"));\n    this.autoScalingHandler = new AutoScalingHandler(this, loader);\n    triggerThreadGroup = new ThreadGroup(\"Simulated Overseer autoscaling triggers\");\n    OverseerTriggerThread trigger = new OverseerTriggerThread(loader, this,\n        new CloudConfig.CloudConfigBuilder(\"nonexistent\", 0, \"sim\").build());\n    triggerThread = new Overseer.OverseerThread(triggerThreadGroup, trigger, \"Simulated OverseerAutoScalingTriggerThread\");\n    triggerThread.start();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc18bc8ea2e2c1e308757ff50671c774438e9f3e","date":1538052583,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#SimCloudManager(TimeSource).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#SimCloudManager(TimeSource).mjava","sourceNew":"  /**\n   * Create a simulated cluster. This cluster uses the following components:\n   * <ul>\n   *   <li>{@link SimDistribStateManager} with non-shared root node.</li>\n   *   <li>{@link SimClusterStateProvider}</li>\n   *   <li>{@link SimNodeStateProvider}, where node values are automatically initialized when using\n   *   {@link #simAddNode()} method.</li>\n   *   <li>{@link GenericDistributedQueueFactory} that uses {@link SimDistribStateManager} as its storage.</li>\n   *   <li>an instance of {@link AutoScalingHandler} for managing AutoScalingConfig.</li>\n   *   <li>an instance of {@link OverseerTriggerThread} for managing triggers and processing events.</li>\n   * </ul>\n   * @param timeSource time source to use.\n   */\n  public SimCloudManager(TimeSource timeSource) throws Exception {\n    this.stateManager = new SimDistribStateManager(SimDistribStateManager.createNewRootNode());\n    this.loader = new SolrResourceLoader();\n    // init common paths\n    stateManager.makePath(ZkStateReader.CLUSTER_STATE);\n    stateManager.makePath(ZkStateReader.CLUSTER_PROPS);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH);\n    stateManager.makePath(ZkStateReader.LIVE_NODES_ZKNODE);\n    stateManager.makePath(ZkStateReader.ROLES);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_EVENTS_PATH);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_LOST_PATH);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n    stateManager.makePath(Overseer.OVERSEER_ELECT);\n\n    // register common metrics\n    metricTag = Integer.toHexString(hashCode());\n    String registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm);\n    metricManager.registerAll(registryName, new AltBufferPoolMetricSet(), true, \"buffers\");\n    metricManager.registerAll(registryName, new ClassLoadingGaugeSet(), true, \"classes\");\n    metricManager.registerAll(registryName, new OperatingSystemMetricSet(), true, \"os\");\n    metricManager.registerAll(registryName, new GarbageCollectorMetricSet(), true, \"gc\");\n    metricManager.registerAll(registryName, new MemoryUsageGaugeSet(), true, \"memory\");\n    metricManager.registerAll(registryName, new ThreadStatesGaugeSet(), true, \"threads\"); // todo should we use CachedThreadStatesGaugeSet instead?\n    MetricsMap sysprops = new MetricsMap((detailed, map) -> {\n      System.getProperties().forEach((k, v) -> {\n        map.put(String.valueOf(k), v);\n      });\n    });\n    metricManager.registerGauge(null, registryName, sysprops, metricTag, true, \"properties\", \"system\");\n\n    registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.node);\n    metricManager.registerGauge(null, registryName, () -> new File(\"/\").getUsableSpace(),\n        metricTag, true, \"usableSpace\", SolrInfoBean.Category.CONTAINER.toString(), \"fs\", \"coreRoot\");\n\n    solrClient = new MockSearchableSolrClient() {\n      @Override\n      public NamedList<Object> request(SolrRequest request, String collection) throws SolrServerException, IOException {\n        if (collection != null) {\n          if (request instanceof AbstractUpdateRequest) {\n            ((AbstractUpdateRequest)request).setParam(\"collection\", collection);\n          } else if (request instanceof QueryRequest) {\n            if (request.getPath() != null && (\n                request.getPath().startsWith(\"/admin/autoscaling\") ||\n                request.getPath().startsWith(\"/cluster/autoscaling\") ||\n            request.getPath().startsWith(\"/admin/metrics/history\") ||\n                request.getPath().startsWith(\"/cluster/metrics/history\")\n            )) {\n              // forward it\n              ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n              params.set(\"collection\", collection);\n              request = new QueryRequest(params);\n            } else {\n              // search request\n              if (collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n                return super.request(request, collection);\n              } else {\n                // forward it\n                ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n                params.set(\"collection\", collection);\n                request = new QueryRequest(params);\n              }\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"when collection != null only UpdateRequest and QueryRequest are supported: request=\" + request + \", collection=\" + collection);\n          }\n        }\n        try {\n          SolrResponse rsp = SimCloudManager.this.request(request);\n          return rsp.getResponse();\n        } catch (UnsupportedOperationException e) {\n          throw new SolrServerException(e);\n        }\n      }\n    };\n\n\n    this.timeSource = timeSource != null ? timeSource : TimeSource.NANO_TIME;\n    this.clusterStateProvider = new SimClusterStateProvider(liveNodesSet, this);\n    this.nodeStateProvider = new SimNodeStateProvider(liveNodesSet, this.stateManager, this.clusterStateProvider, null);\n    this.queueFactory = new GenericDistributedQueueFactory(stateManager);\n    this.simCloudManagerPool = ExecutorUtil.newMDCAwareFixedThreadPool(200, new DefaultSolrThreadFactory(\"simCloudManagerPool\"));\n\n    this.autoScalingHandler = new AutoScalingHandler(this, loader);\n\n\n    triggerThreadGroup = new ThreadGroup(\"Simulated Overseer autoscaling triggers\");\n    OverseerTriggerThread trigger = new OverseerTriggerThread(loader, this,\n        new CloudConfig.CloudConfigBuilder(\"nonexistent\", 0, \"sim\").build());\n    triggerThread = new Overseer.OverseerThread(triggerThreadGroup, trigger, \"Simulated OverseerAutoScalingTriggerThread\");\n    triggerThread.start();\n  }\n\n","sourceOld":"  /**\n   * Create a simulated cluster. This cluster uses the following components:\n   * <ul>\n   *   <li>{@link SimDistribStateManager} with non-shared root node.</li>\n   *   <li>{@link SimClusterStateProvider}</li>\n   *   <li>{@link SimNodeStateProvider}, where node values are automatically initialized when using\n   *   {@link #simAddNode()} method.</li>\n   *   <li>{@link GenericDistributedQueueFactory} that uses {@link SimDistribStateManager} as its storage.</li>\n   *   <li>an instance of {@link AutoScalingHandler} for managing AutoScalingConfig.</li>\n   *   <li>an instance of {@link OverseerTriggerThread} for managing triggers and processing events.</li>\n   * </ul>\n   * @param timeSource time source to use.\n   */\n  public SimCloudManager(TimeSource timeSource) throws Exception {\n    this.stateManager = new SimDistribStateManager(SimDistribStateManager.createNewRootNode());\n    this.loader = new SolrResourceLoader();\n    // init common paths\n    stateManager.makePath(ZkStateReader.CLUSTER_STATE);\n    stateManager.makePath(ZkStateReader.CLUSTER_PROPS);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH);\n    stateManager.makePath(ZkStateReader.LIVE_NODES_ZKNODE);\n    stateManager.makePath(ZkStateReader.ROLES);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_EVENTS_PATH);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_LOST_PATH);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n    stateManager.makePath(Overseer.OVERSEER_ELECT);\n\n    // register common metrics\n    metricTag = Integer.toHexString(hashCode());\n    String registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm);\n    metricManager.registerAll(registryName, new AltBufferPoolMetricSet(), true, \"buffers\");\n    metricManager.registerAll(registryName, new ClassLoadingGaugeSet(), true, \"classes\");\n    metricManager.registerAll(registryName, new OperatingSystemMetricSet(), true, \"os\");\n    metricManager.registerAll(registryName, new GarbageCollectorMetricSet(), true, \"gc\");\n    metricManager.registerAll(registryName, new MemoryUsageGaugeSet(), true, \"memory\");\n    metricManager.registerAll(registryName, new ThreadStatesGaugeSet(), true, \"threads\"); // todo should we use CachedThreadStatesGaugeSet instead?\n    MetricsMap sysprops = new MetricsMap((detailed, map) -> {\n      System.getProperties().forEach((k, v) -> {\n        map.put(String.valueOf(k), v);\n      });\n    });\n    metricManager.registerGauge(null, registryName, sysprops, metricTag, true, \"properties\", \"system\");\n\n    registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.node);\n    metricManager.registerGauge(null, registryName, () -> new File(\"/\").getUsableSpace(),\n        metricTag, true, \"usableSpace\", SolrInfoBean.Category.CONTAINER.toString(), \"fs\", \"coreRoot\");\n\n    solrClient = new MockSearchableSolrClient() {\n      @Override\n      public NamedList<Object> request(SolrRequest request, String collection) throws SolrServerException, IOException {\n        if (collection != null) {\n          if (request instanceof AbstractUpdateRequest) {\n            ((AbstractUpdateRequest)request).setParam(\"collection\", collection);\n          } else if (request instanceof QueryRequest) {\n            if (request.getPath() != null && (\n                request.getPath().startsWith(\"/admin/autoscaling\") ||\n                request.getPath().startsWith(\"/cluster/autoscaling\") ||\n            request.getPath().startsWith(\"/admin/metrics/history\") ||\n                request.getPath().startsWith(\"/cluster/metrics/history\")\n            )) {\n              // forward it\n              ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n              params.set(\"collection\", collection);\n              request = new QueryRequest(params);\n            } else {\n              // search request\n              return super.request(request, collection);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"when collection != null only UpdateRequest and QueryRequest are supported: request=\" + request + \", collection=\" + collection);\n          }\n        }\n        try {\n          SolrResponse rsp = SimCloudManager.this.request(request);\n          return rsp.getResponse();\n        } catch (UnsupportedOperationException e) {\n          throw new SolrServerException(e);\n        }\n      }\n    };\n\n\n    this.timeSource = timeSource != null ? timeSource : TimeSource.NANO_TIME;\n    this.clusterStateProvider = new SimClusterStateProvider(liveNodesSet, this);\n    this.nodeStateProvider = new SimNodeStateProvider(liveNodesSet, this.stateManager, this.clusterStateProvider, null);\n    this.queueFactory = new GenericDistributedQueueFactory(stateManager);\n    this.simCloudManagerPool = ExecutorUtil.newMDCAwareFixedThreadPool(200, new DefaultSolrThreadFactory(\"simCloudManagerPool\"));\n\n    this.autoScalingHandler = new AutoScalingHandler(this, loader);\n\n\n    triggerThreadGroup = new ThreadGroup(\"Simulated Overseer autoscaling triggers\");\n    OverseerTriggerThread trigger = new OverseerTriggerThread(loader, this,\n        new CloudConfig.CloudConfigBuilder(\"nonexistent\", 0, \"sim\").build());\n    triggerThread = new Overseer.OverseerThread(triggerThreadGroup, trigger, \"Simulated OverseerAutoScalingTriggerThread\");\n    triggerThread.start();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5","date":1556572478,"type":5,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#SimCloudManager(TimeSource).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#SimCloudManager(TimeSource).mjava","sourceNew":"  /**\n   * Create a simulated cluster. This cluster uses the following components:\n   * <ul>\n   *   <li>{@link SimDistribStateManager} with non-shared root node.</li>\n   *   <li>{@link SimClusterStateProvider}</li>\n   *   <li>{@link SimNodeStateProvider}, where node values are automatically initialized when using\n   *   {@link #simAddNode()} method.</li>\n   *   <li>{@link GenericDistributedQueueFactory} that uses {@link SimDistribStateManager} as its storage.</li>\n   *   <li>an instance of {@link AutoScalingHandler} for managing AutoScalingConfig.</li>\n   *   <li>an instance of {@link OverseerTriggerThread} for managing triggers and processing events.</li>\n   * </ul>\n   * @param timeSource time source to use.\n   */\n  public SimCloudManager(TimeSource timeSource) throws Exception {\n    this.stateManager = new SimDistribStateManager(SimDistribStateManager.createNewRootNode());\n    this.loader = new SolrResourceLoader();\n    // init common paths\n    stateManager.makePath(ZkStateReader.CLUSTER_STATE);\n    stateManager.makePath(ZkStateReader.CLUSTER_PROPS);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH);\n    stateManager.makePath(ZkStateReader.LIVE_NODES_ZKNODE);\n    stateManager.makePath(ZkStateReader.ROLES);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_EVENTS_PATH);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_LOST_PATH);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n    stateManager.makePath(Overseer.OVERSEER_ELECT);\n\n    // register common metrics\n    metricTag = Integer.toHexString(hashCode());\n    String registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm);\n    metricManager.registerAll(registryName, new AltBufferPoolMetricSet(), true, \"buffers\");\n    metricManager.registerAll(registryName, new ClassLoadingGaugeSet(), true, \"classes\");\n    metricManager.registerAll(registryName, new OperatingSystemMetricSet(), true, \"os\");\n    metricManager.registerAll(registryName, new GarbageCollectorMetricSet(), true, \"gc\");\n    metricManager.registerAll(registryName, new MemoryUsageGaugeSet(), true, \"memory\");\n    metricManager.registerAll(registryName, new ThreadStatesGaugeSet(), true, \"threads\"); // todo should we use CachedThreadStatesGaugeSet instead?\n    MetricsMap sysprops = new MetricsMap((detailed, map) -> {\n      System.getProperties().forEach((k, v) -> {\n        map.put(String.valueOf(k), v);\n      });\n    });\n    metricManager.registerGauge(null, registryName, sysprops, metricTag, true, \"properties\", \"system\");\n\n    registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.node);\n    metricManager.registerGauge(null, registryName, () -> new File(\"/\").getUsableSpace(),\n        metricTag, true, \"usableSpace\", SolrInfoBean.Category.CONTAINER.toString(), \"fs\", \"coreRoot\");\n\n    solrClient = new MockSearchableSolrClient() {\n      @Override\n      public NamedList<Object> request(SolrRequest request, String collection) throws SolrServerException, IOException {\n        if (collection != null) {\n          if (request instanceof AbstractUpdateRequest) {\n            ((AbstractUpdateRequest)request).setParam(\"collection\", collection);\n          } else if (request instanceof QueryRequest) {\n            if (request.getPath() != null && (\n                request.getPath().startsWith(\"/admin/autoscaling\") ||\n                request.getPath().startsWith(\"/cluster/autoscaling\") ||\n            request.getPath().startsWith(\"/admin/metrics/history\") ||\n                request.getPath().startsWith(\"/cluster/metrics/history\")\n            )) {\n              // forward it\n              ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n              params.set(\"collection\", collection);\n              request = new QueryRequest(params);\n            } else {\n              // search request\n              if (collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n                return super.request(request, collection);\n              } else {\n                // forward it\n                ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n                params.set(\"collection\", collection);\n                request = new QueryRequest(params);\n              }\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"when collection != null only UpdateRequest and QueryRequest are supported: request=\" + request + \", collection=\" + collection);\n          }\n        }\n        try {\n          SolrResponse rsp = SimCloudManager.this.request(request);\n          return rsp.getResponse();\n        } catch (UnsupportedOperationException e) {\n          throw new SolrServerException(e);\n        }\n      }\n    };\n\n\n    this.timeSource = timeSource != null ? timeSource : TimeSource.NANO_TIME;\n    this.clusterStateProvider = new SimClusterStateProvider(liveNodesSet, this);\n    this.nodeStateProvider = new SimNodeStateProvider(liveNodesSet, this.stateManager, this.clusterStateProvider, null);\n    this.queueFactory = new GenericDistributedQueueFactory(stateManager);\n    this.simCloudManagerPool = ExecutorUtil.newMDCAwareFixedThreadPool(200, new DefaultSolrThreadFactory(\"simCloudManagerPool\"));\n\n    this.autoScalingHandler = new AutoScalingHandler(this, loader);\n\n\n    triggerThreadGroup = new ThreadGroup(\"Simulated Overseer autoscaling triggers\");\n    OverseerTriggerThread trigger = new OverseerTriggerThread(loader, this,\n        new CloudConfig.CloudConfigBuilder(\"nonexistent\", 0, \"sim\").build());\n    triggerThread = new Overseer.OverseerThread(triggerThreadGroup, trigger, \"Simulated OverseerAutoScalingTriggerThread\");\n    triggerThread.start();\n  }\n\n","sourceOld":"  /**\n   * Create a simulated cluster. This cluster uses the following components:\n   * <ul>\n   *   <li>{@link SimDistribStateManager} with non-shared root node.</li>\n   *   <li>{@link SimClusterStateProvider}</li>\n   *   <li>{@link SimNodeStateProvider}, where node values are automatically initialized when using\n   *   {@link #simAddNode()} method.</li>\n   *   <li>{@link GenericDistributedQueueFactory} that uses {@link SimDistribStateManager} as its storage.</li>\n   *   <li>an instance of {@link AutoScalingHandler} for managing AutoScalingConfig.</li>\n   *   <li>an instance of {@link OverseerTriggerThread} for managing triggers and processing events.</li>\n   * </ul>\n   * @param timeSource time source to use.\n   */\n  public SimCloudManager(TimeSource timeSource) throws Exception {\n    this.stateManager = new SimDistribStateManager(SimDistribStateManager.createNewRootNode());\n    this.loader = new SolrResourceLoader();\n    // init common paths\n    stateManager.makePath(ZkStateReader.CLUSTER_STATE);\n    stateManager.makePath(ZkStateReader.CLUSTER_PROPS);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH);\n    stateManager.makePath(ZkStateReader.LIVE_NODES_ZKNODE);\n    stateManager.makePath(ZkStateReader.ROLES);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_EVENTS_PATH);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_LOST_PATH);\n    stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n    stateManager.makePath(Overseer.OVERSEER_ELECT);\n\n    // register common metrics\n    metricTag = Integer.toHexString(hashCode());\n    String registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm);\n    metricManager.registerAll(registryName, new AltBufferPoolMetricSet(), true, \"buffers\");\n    metricManager.registerAll(registryName, new ClassLoadingGaugeSet(), true, \"classes\");\n    metricManager.registerAll(registryName, new OperatingSystemMetricSet(), true, \"os\");\n    metricManager.registerAll(registryName, new GarbageCollectorMetricSet(), true, \"gc\");\n    metricManager.registerAll(registryName, new MemoryUsageGaugeSet(), true, \"memory\");\n    metricManager.registerAll(registryName, new ThreadStatesGaugeSet(), true, \"threads\"); // todo should we use CachedThreadStatesGaugeSet instead?\n    MetricsMap sysprops = new MetricsMap((detailed, map) -> {\n      System.getProperties().forEach((k, v) -> {\n        map.put(String.valueOf(k), v);\n      });\n    });\n    metricManager.registerGauge(null, registryName, sysprops, metricTag, true, \"properties\", \"system\");\n\n    registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.node);\n    metricManager.registerGauge(null, registryName, () -> new File(\"/\").getUsableSpace(),\n        metricTag, true, \"usableSpace\", SolrInfoBean.Category.CONTAINER.toString(), \"fs\", \"coreRoot\");\n\n    solrClient = new MockSearchableSolrClient() {\n      @Override\n      public NamedList<Object> request(SolrRequest request, String collection) throws SolrServerException, IOException {\n        if (collection != null) {\n          if (request instanceof AbstractUpdateRequest) {\n            ((AbstractUpdateRequest)request).setParam(\"collection\", collection);\n          } else if (request instanceof QueryRequest) {\n            if (request.getPath() != null && (\n                request.getPath().startsWith(\"/admin/autoscaling\") ||\n                request.getPath().startsWith(\"/cluster/autoscaling\") ||\n            request.getPath().startsWith(\"/admin/metrics/history\") ||\n                request.getPath().startsWith(\"/cluster/metrics/history\")\n            )) {\n              // forward it\n              ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n              params.set(\"collection\", collection);\n              request = new QueryRequest(params);\n            } else {\n              // search request\n              if (collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n                return super.request(request, collection);\n              } else {\n                // forward it\n                ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n                params.set(\"collection\", collection);\n                request = new QueryRequest(params);\n              }\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"when collection != null only UpdateRequest and QueryRequest are supported: request=\" + request + \", collection=\" + collection);\n          }\n        }\n        try {\n          SolrResponse rsp = SimCloudManager.this.request(request);\n          return rsp.getResponse();\n        } catch (UnsupportedOperationException e) {\n          throw new SolrServerException(e);\n        }\n      }\n    };\n\n\n    this.timeSource = timeSource != null ? timeSource : TimeSource.NANO_TIME;\n    this.clusterStateProvider = new SimClusterStateProvider(liveNodesSet, this);\n    this.nodeStateProvider = new SimNodeStateProvider(liveNodesSet, this.stateManager, this.clusterStateProvider, null);\n    this.queueFactory = new GenericDistributedQueueFactory(stateManager);\n    this.simCloudManagerPool = ExecutorUtil.newMDCAwareFixedThreadPool(200, new DefaultSolrThreadFactory(\"simCloudManagerPool\"));\n\n    this.autoScalingHandler = new AutoScalingHandler(this, loader);\n\n\n    triggerThreadGroup = new ThreadGroup(\"Simulated Overseer autoscaling triggers\");\n    OverseerTriggerThread trigger = new OverseerTriggerThread(loader, this,\n        new CloudConfig.CloudConfigBuilder(\"nonexistent\", 0, \"sim\").build());\n    triggerThread = new Overseer.OverseerThread(triggerThreadGroup, trigger, \"Simulated OverseerAutoScalingTriggerThread\");\n    triggerThread.start();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fc18bc8ea2e2c1e308757ff50671c774438e9f3e":["4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a"],"4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["fc18bc8ea2e2c1e308757ff50671c774438e9f3e"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"]},"commit2Childs":{"fc18bc8ea2e2c1e308757ff50671c774438e9f3e":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a":["fc18bc8ea2e2c1e308757ff50671c774438e9f3e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}