{"path":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#maybeStall().mjava","commits":[{"id":"7e13c4018a2a11854a5dc4a7661ba9e2f1132e4b","date":1416355396,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#maybeStall().mjava","pathOld":"/dev/null","sourceNew":"  /** This is invoked by {@link #merge} to possibly stall the incoming\n   *  thread when there are too many merges running or pending.  The \n   *  default behavior is to force this thread, which is producing too\n   *  many segments for merging to keep up, to wait until merges catch\n   *  up. Applications that can take other less drastic measures, such\n   *  as limiting how many threads are allowed to index, can do nothing\n   *  here and throttle elsewhere. */\n\n  protected synchronized void maybeStall() {\n    long startStallTime = 0;\n    while (writer.hasPendingMerges() && mergeThreadCount() >= maxMergeCount) {\n      // This means merging has fallen too far behind: we\n      // have already created maxMergeCount threads, and\n      // now there's at least one more merge pending.\n      // Note that only maxThreadCount of\n      // those created merge threads will actually be\n      // running; the rest will be paused (see\n      // updateMergeThreads).  We stall this producer\n      // thread to prevent creation of new segments,\n      // until merging has caught up:\n      startStallTime = System.currentTimeMillis();\n      if (verbose()) {\n        message(\"    too many merges; stalling...\");\n      }\n      try {\n        wait();\n      } catch (InterruptedException ie) {\n        throw new ThreadInterruptedException(ie);\n      }\n    }\n\n    if (verbose()) {\n      if (startStallTime != 0) {\n        message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["a1346c5dacb766a49ec3b6160a23d2e80073501c","c6cc2915889370c9313ee1741da315e976bdd574"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a1346c5dacb766a49ec3b6160a23d2e80073501c","date":1417857339,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#maybeStall().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#maybeStall().mjava","sourceNew":"  /** This is invoked by {@link #merge} to possibly stall the incoming\n   *  thread when there are too many merges running or pending.  The \n   *  default behavior is to force this thread, which is producing too\n   *  many segments for merging to keep up, to wait until merges catch\n   *  up. Applications that can take other less drastic measures, such\n   *  as limiting how many threads are allowed to index, can do nothing\n   *  here and throttle elsewhere. */\n\n  protected synchronized void maybeStall() {\n    long startStallTime = 0;\n    while (writer.hasPendingMerges() && mergeThreadCount() >= maxMergeCount) {\n      // This means merging has fallen too far behind: we\n      // have already created maxMergeCount threads, and\n      // now there's at least one more merge pending.\n      // Note that only maxThreadCount of\n      // those created merge threads will actually be\n      // running; the rest will be paused (see\n      // updateMergeThreads).  We stall this producer\n      // thread to prevent creation of new segments,\n      // until merging has caught up:\n      startStallTime = System.currentTimeMillis();\n      if (verbose()) {\n        message(\"    too many merges; stalling...\");\n      }\n      try {\n        // Only wait 0.25 seconds, so if all merges are aborted (by IW.rollback) we notice:\n        wait(250);\n      } catch (InterruptedException ie) {\n        throw new ThreadInterruptedException(ie);\n      }\n    }\n\n    if (verbose()) {\n      if (startStallTime != 0) {\n        message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n      }\n    }\n  }\n\n","sourceOld":"  /** This is invoked by {@link #merge} to possibly stall the incoming\n   *  thread when there are too many merges running or pending.  The \n   *  default behavior is to force this thread, which is producing too\n   *  many segments for merging to keep up, to wait until merges catch\n   *  up. Applications that can take other less drastic measures, such\n   *  as limiting how many threads are allowed to index, can do nothing\n   *  here and throttle elsewhere. */\n\n  protected synchronized void maybeStall() {\n    long startStallTime = 0;\n    while (writer.hasPendingMerges() && mergeThreadCount() >= maxMergeCount) {\n      // This means merging has fallen too far behind: we\n      // have already created maxMergeCount threads, and\n      // now there's at least one more merge pending.\n      // Note that only maxThreadCount of\n      // those created merge threads will actually be\n      // running; the rest will be paused (see\n      // updateMergeThreads).  We stall this producer\n      // thread to prevent creation of new segments,\n      // until merging has caught up:\n      startStallTime = System.currentTimeMillis();\n      if (verbose()) {\n        message(\"    too many merges; stalling...\");\n      }\n      try {\n        wait();\n      } catch (InterruptedException ie) {\n        throw new ThreadInterruptedException(ie);\n      }\n    }\n\n    if (verbose()) {\n      if (startStallTime != 0) {\n        message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n      }\n    }\n  }\n\n","bugFix":["7e13c4018a2a11854a5dc4a7661ba9e2f1132e4b"],"bugIntro":["c6cc2915889370c9313ee1741da315e976bdd574"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8985b5ad07c1b5bb28f504744862fc1c56d4c065","date":1419243010,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#maybeStall().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#maybeStall().mjava","sourceNew":"  /** This is invoked by {@link #merge} to possibly stall the incoming\n   *  thread when there are too many merges running or pending.  The \n   *  default behavior is to force this thread, which is producing too\n   *  many segments for merging to keep up, to wait until merges catch\n   *  up. Applications that can take other less drastic measures, such\n   *  as limiting how many threads are allowed to index, can do nothing\n   *  here and throttle elsewhere. */\n\n  protected synchronized void maybeStall() {\n    long startStallTime = 0;\n    while (writer.hasPendingMerges() && mergeThreadCount() >= maxMergeCount) {\n      // This means merging has fallen too far behind: we\n      // have already created maxMergeCount threads, and\n      // now there's at least one more merge pending.\n      // Note that only maxThreadCount of\n      // those created merge threads will actually be\n      // running; the rest will be paused (see\n      // updateMergeThreads).  We stall this producer\n      // thread to prevent creation of new segments,\n      // until merging has caught up:\n      if (verbose() && startStallTime == 0) {\n        message(\"    too many merges; stalling...\");\n      }\n      startStallTime = System.currentTimeMillis();\n      try {\n        // Only wait 0.25 seconds, so if all merges are aborted (by IW.rollback) we notice:\n        wait(250);\n      } catch (InterruptedException ie) {\n        throw new ThreadInterruptedException(ie);\n      }\n    }\n\n    if (verbose()) {\n      if (startStallTime != 0) {\n        message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n      }\n    }\n  }\n\n","sourceOld":"  /** This is invoked by {@link #merge} to possibly stall the incoming\n   *  thread when there are too many merges running or pending.  The \n   *  default behavior is to force this thread, which is producing too\n   *  many segments for merging to keep up, to wait until merges catch\n   *  up. Applications that can take other less drastic measures, such\n   *  as limiting how many threads are allowed to index, can do nothing\n   *  here and throttle elsewhere. */\n\n  protected synchronized void maybeStall() {\n    long startStallTime = 0;\n    while (writer.hasPendingMerges() && mergeThreadCount() >= maxMergeCount) {\n      // This means merging has fallen too far behind: we\n      // have already created maxMergeCount threads, and\n      // now there's at least one more merge pending.\n      // Note that only maxThreadCount of\n      // those created merge threads will actually be\n      // running; the rest will be paused (see\n      // updateMergeThreads).  We stall this producer\n      // thread to prevent creation of new segments,\n      // until merging has caught up:\n      startStallTime = System.currentTimeMillis();\n      if (verbose()) {\n        message(\"    too many merges; stalling...\");\n      }\n      try {\n        // Only wait 0.25 seconds, so if all merges are aborted (by IW.rollback) we notice:\n        wait(250);\n      } catch (InterruptedException ie) {\n        throw new ThreadInterruptedException(ie);\n      }\n    }\n\n    if (verbose()) {\n      if (startStallTime != 0) {\n        message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5faf65b6692f15cca0f87bf8666c87899afc619f","date":1420468108,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#maybeStall(IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#maybeStall().mjava","sourceNew":"  /** This is invoked by {@link #merge} to possibly stall the incoming\n   *  thread when there are too many merges running or pending.  The \n   *  default behavior is to force this thread, which is producing too\n   *  many segments for merging to keep up, to wait until merges catch\n   *  up. Applications that can take other less drastic measures, such\n   *  as limiting how many threads are allowed to index, can do nothing\n   *  here and throttle elsewhere. */\n\n  protected synchronized void maybeStall(IndexWriter writer) {\n    long startStallTime = 0;\n    while (writer.hasPendingMerges() && mergeThreadCount() >= maxMergeCount) {\n      // This means merging has fallen too far behind: we\n      // have already created maxMergeCount threads, and\n      // now there's at least one more merge pending.\n      // Note that only maxThreadCount of\n      // those created merge threads will actually be\n      // running; the rest will be paused (see\n      // updateMergeThreads).  We stall this producer\n      // thread to prevent creation of new segments,\n      // until merging has caught up:\n      if (verbose() && startStallTime == 0) {\n        message(\"    too many merges; stalling...\");\n      }\n      startStallTime = System.currentTimeMillis();\n      try {\n        // Only wait 0.25 seconds, so if all merges are aborted (by IW.rollback) we notice:\n        wait(250);\n      } catch (InterruptedException ie) {\n        throw new ThreadInterruptedException(ie);\n      }\n    }\n\n    if (verbose()) {\n      if (startStallTime != 0) {\n        message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n      }\n    }\n  }\n\n","sourceOld":"  /** This is invoked by {@link #merge} to possibly stall the incoming\n   *  thread when there are too many merges running or pending.  The \n   *  default behavior is to force this thread, which is producing too\n   *  many segments for merging to keep up, to wait until merges catch\n   *  up. Applications that can take other less drastic measures, such\n   *  as limiting how many threads are allowed to index, can do nothing\n   *  here and throttle elsewhere. */\n\n  protected synchronized void maybeStall() {\n    long startStallTime = 0;\n    while (writer.hasPendingMerges() && mergeThreadCount() >= maxMergeCount) {\n      // This means merging has fallen too far behind: we\n      // have already created maxMergeCount threads, and\n      // now there's at least one more merge pending.\n      // Note that only maxThreadCount of\n      // those created merge threads will actually be\n      // running; the rest will be paused (see\n      // updateMergeThreads).  We stall this producer\n      // thread to prevent creation of new segments,\n      // until merging has caught up:\n      if (verbose() && startStallTime == 0) {\n        message(\"    too many merges; stalling...\");\n      }\n      startStallTime = System.currentTimeMillis();\n      try {\n        // Only wait 0.25 seconds, so if all merges are aborted (by IW.rollback) we notice:\n        wait(250);\n      } catch (InterruptedException ie) {\n        throw new ThreadInterruptedException(ie);\n      }\n    }\n\n    if (verbose()) {\n      if (startStallTime != 0) {\n        message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["c6cc2915889370c9313ee1741da315e976bdd574"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a1346c5dacb766a49ec3b6160a23d2e80073501c":["7e13c4018a2a11854a5dc4a7661ba9e2f1132e4b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8985b5ad07c1b5bb28f504744862fc1c56d4c065":["a1346c5dacb766a49ec3b6160a23d2e80073501c"],"7e13c4018a2a11854a5dc4a7661ba9e2f1132e4b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["8985b5ad07c1b5bb28f504744862fc1c56d4c065"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5faf65b6692f15cca0f87bf8666c87899afc619f"]},"commit2Childs":{"a1346c5dacb766a49ec3b6160a23d2e80073501c":["8985b5ad07c1b5bb28f504744862fc1c56d4c065"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7e13c4018a2a11854a5dc4a7661ba9e2f1132e4b"],"7e13c4018a2a11854a5dc4a7661ba9e2f1132e4b":["a1346c5dacb766a49ec3b6160a23d2e80073501c"],"8985b5ad07c1b5bb28f504744862fc1c56d4c065":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}