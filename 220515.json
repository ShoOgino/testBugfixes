{"path":"lucene/core/src/java/org/apache/lucene/store/CompoundFileDirectory#readEntries(IndexInputSlicer,Directory,String).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/CompoundFileDirectory#readEntries(IndexInputSlicer,Directory,String).mjava","pathOld":"lucene/src/java/org/apache/lucene/store/CompoundFileDirectory#readEntries(IndexInputSlicer,Directory,String).mjava","sourceNew":"  /** Helper method that reads CFS entries from an input stream */\n  private static final Map<String, FileEntry> readEntries(\n      IndexInputSlicer handle, Directory dir, String name) throws IOException {\n    // read the first VInt. If it is negative, it's the version number\n    // otherwise it's the count (pre-3.1 indexes)\n    final IndexInput stream = handle.openFullSlice();\n    final Map<String, FileEntry> mapping;\n    boolean success = false;\n    try {\n      final int firstInt = stream.readVInt();\n      if (firstInt == CompoundFileWriter.FORMAT_CURRENT) {\n        IndexInput input = null;\n        try {\n          final String entriesFileName = IndexFileNames.segmentFileName(\n                                                IndexFileNames.stripExtension(name), \"\",\n                                                IndexFileNames.COMPOUND_FILE_ENTRIES_EXTENSION);\n          input = dir.openInput(entriesFileName, IOContext.READONCE);\n          final int readInt = input.readInt(); // unused right now\n          assert readInt == CompoundFileWriter.ENTRY_FORMAT_CURRENT;\n          final int numEntries = input.readVInt();\n          mapping = new HashMap<String, CompoundFileDirectory.FileEntry>(\n              numEntries);\n          for (int i = 0; i < numEntries; i++) {\n            final FileEntry fileEntry = new FileEntry();\n            final String id = input.readString();\n            assert !mapping.containsKey(id): \"id=\" + id + \" was written multiple times in the CFS\";\n            mapping.put(id, fileEntry);\n            fileEntry.offset = input.readLong();\n            fileEntry.length = input.readLong();\n          }\n          return mapping;\n        } finally {\n          IOUtils.close(input);\n        }\n      } else {\n        // TODO remove once 3.x is not supported anymore\n        mapping = readLegacyEntries(stream, firstInt);\n      }\n      success = true;\n      return mapping;\n    } finally {\n      if (success) {\n        IOUtils.close(stream);\n      } else {\n        IOUtils.closeWhileHandlingException(stream);\n      }\n    }\n  }\n\n","sourceOld":"  /** Helper method that reads CFS entries from an input stream */\n  private static final Map<String, FileEntry> readEntries(\n      IndexInputSlicer handle, Directory dir, String name) throws IOException {\n    // read the first VInt. If it is negative, it's the version number\n    // otherwise it's the count (pre-3.1 indexes)\n    final IndexInput stream = handle.openFullSlice();\n    final Map<String, FileEntry> mapping;\n    boolean success = false;\n    try {\n      final int firstInt = stream.readVInt();\n      if (firstInt == CompoundFileWriter.FORMAT_CURRENT) {\n        IndexInput input = null;\n        try {\n          final String entriesFileName = IndexFileNames.segmentFileName(\n                                                IndexFileNames.stripExtension(name), \"\",\n                                                IndexFileNames.COMPOUND_FILE_ENTRIES_EXTENSION);\n          input = dir.openInput(entriesFileName, IOContext.READONCE);\n          final int readInt = input.readInt(); // unused right now\n          assert readInt == CompoundFileWriter.ENTRY_FORMAT_CURRENT;\n          final int numEntries = input.readVInt();\n          mapping = new HashMap<String, CompoundFileDirectory.FileEntry>(\n              numEntries);\n          for (int i = 0; i < numEntries; i++) {\n            final FileEntry fileEntry = new FileEntry();\n            final String id = input.readString();\n            assert !mapping.containsKey(id): \"id=\" + id + \" was written multiple times in the CFS\";\n            mapping.put(id, fileEntry);\n            fileEntry.offset = input.readLong();\n            fileEntry.length = input.readLong();\n          }\n          return mapping;\n        } finally {\n          IOUtils.close(input);\n        }\n      } else {\n        // TODO remove once 3.x is not supported anymore\n        mapping = readLegacyEntries(stream, firstInt);\n      }\n      success = true;\n      return mapping;\n    } finally {\n      if (success) {\n        IOUtils.close(stream);\n      } else {\n        IOUtils.closeWhileHandlingException(stream);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a914aecf1d2ee9c6e6959625e89f2b1b31de7c48","date":1339428391,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/CompoundFileDirectory#readEntries(IndexInputSlicer,Directory,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/CompoundFileDirectory#readEntries(IndexInputSlicer,Directory,String).mjava","sourceNew":"  /** Helper method that reads CFS entries from an input stream */\n  private static final Map<String, FileEntry> readEntries(\n      IndexInputSlicer handle, Directory dir, String name) throws IOException {\n    // read the first VInt. If it is negative, it's the version number\n    // otherwise it's the count (pre-3.1 indexes)\n    final IndexInput stream = handle.openFullSlice();\n    final Map<String, FileEntry> mapping;\n    boolean success = false;\n    try {\n      final int firstInt = stream.readVInt();\n      if (firstInt == CompoundFileWriter.FORMAT_CURRENT) {\n        IndexInput input = null;\n        try {\n          final String entriesFileName = IndexFileNames.segmentFileName(\n                                                IndexFileNames.stripExtension(name), \"\",\n                                                IndexFileNames.COMPOUND_FILE_ENTRIES_EXTENSION);\n          input = dir.openInput(entriesFileName, IOContext.READONCE);\n          final int readInt = input.readInt(); // unused right now\n          assert readInt == CompoundFileWriter.ENTRY_FORMAT_CURRENT;\n          final int numEntries = input.readVInt();\n          mapping = new HashMap<String, CompoundFileDirectory.FileEntry>(\n              numEntries);\n          for (int i = 0; i < numEntries; i++) {\n            final FileEntry fileEntry = new FileEntry();\n            final String id = input.readString();\n            assert !mapping.containsKey(id): \"id=\" + id + \" was written multiple times in the CFS\";\n            mapping.put(id, fileEntry);\n            fileEntry.offset = input.readLong();\n            fileEntry.length = input.readLong();\n          }\n          success = true;\n          return mapping;\n        } finally {\n          IOUtils.close(input);\n        }\n      } else {\n        throw new IndexFormatTooOldException(stream, firstInt, \n            CompoundFileWriter.FORMAT_CURRENT, CompoundFileWriter.FORMAT_CURRENT);\n      }\n    } finally {\n      if (success) {\n        IOUtils.close(stream);\n      } else {\n        IOUtils.closeWhileHandlingException(stream);\n      }\n    }\n  }\n\n","sourceOld":"  /** Helper method that reads CFS entries from an input stream */\n  private static final Map<String, FileEntry> readEntries(\n      IndexInputSlicer handle, Directory dir, String name) throws IOException {\n    // read the first VInt. If it is negative, it's the version number\n    // otherwise it's the count (pre-3.1 indexes)\n    final IndexInput stream = handle.openFullSlice();\n    final Map<String, FileEntry> mapping;\n    boolean success = false;\n    try {\n      final int firstInt = stream.readVInt();\n      if (firstInt == CompoundFileWriter.FORMAT_CURRENT) {\n        IndexInput input = null;\n        try {\n          final String entriesFileName = IndexFileNames.segmentFileName(\n                                                IndexFileNames.stripExtension(name), \"\",\n                                                IndexFileNames.COMPOUND_FILE_ENTRIES_EXTENSION);\n          input = dir.openInput(entriesFileName, IOContext.READONCE);\n          final int readInt = input.readInt(); // unused right now\n          assert readInt == CompoundFileWriter.ENTRY_FORMAT_CURRENT;\n          final int numEntries = input.readVInt();\n          mapping = new HashMap<String, CompoundFileDirectory.FileEntry>(\n              numEntries);\n          for (int i = 0; i < numEntries; i++) {\n            final FileEntry fileEntry = new FileEntry();\n            final String id = input.readString();\n            assert !mapping.containsKey(id): \"id=\" + id + \" was written multiple times in the CFS\";\n            mapping.put(id, fileEntry);\n            fileEntry.offset = input.readLong();\n            fileEntry.length = input.readLong();\n          }\n          return mapping;\n        } finally {\n          IOUtils.close(input);\n        }\n      } else {\n        // TODO remove once 3.x is not supported anymore\n        mapping = readLegacyEntries(stream, firstInt);\n      }\n      success = true;\n      return mapping;\n    } finally {\n      if (success) {\n        IOUtils.close(stream);\n      } else {\n        IOUtils.closeWhileHandlingException(stream);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61c01d39462806d7dce1e381b201c104783ab056","date":1339453993,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/CompoundFileDirectory#readEntries(IndexInputSlicer,Directory,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/CompoundFileDirectory#readEntries(IndexInputSlicer,Directory,String).mjava","sourceNew":"  /** Helper method that reads CFS entries from an input stream */\n  private static final Map<String, FileEntry> readEntries(\n      IndexInputSlicer handle, Directory dir, String name) throws IOException {\n    final IndexInput stream = handle.openFullSlice();\n    final Map<String, FileEntry> mapping;\n    boolean success = false;\n    try {\n      final int firstInt = stream.readInt();\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves. See SegmentInfos which also has this.\n      if (firstInt == CodecUtil.CODEC_MAGIC) {\n        CodecUtil.checkHeaderNoMagic(stream, CompoundFileWriter.DATA_CODEC, \n            CompoundFileWriter.VERSION_START, CompoundFileWriter.VERSION_START);\n        IndexInput input = null;\n        try {\n          final String entriesFileName = IndexFileNames.segmentFileName(\n                                                IndexFileNames.stripExtension(name), \"\",\n                                                IndexFileNames.COMPOUND_FILE_ENTRIES_EXTENSION);\n          input = dir.openInput(entriesFileName, IOContext.READONCE);\n          CodecUtil.checkHeader(input, CompoundFileWriter.ENTRY_CODEC, CompoundFileWriter.VERSION_START, CompoundFileWriter.VERSION_START);\n          final int numEntries = input.readVInt();\n          mapping = new HashMap<String, CompoundFileDirectory.FileEntry>(\n              numEntries);\n          for (int i = 0; i < numEntries; i++) {\n            final FileEntry fileEntry = new FileEntry();\n            final String id = input.readString();\n            assert !mapping.containsKey(id): \"id=\" + id + \" was written multiple times in the CFS\";\n            mapping.put(id, fileEntry);\n            fileEntry.offset = input.readLong();\n            fileEntry.length = input.readLong();\n          }\n          success = true;\n          return mapping;\n        } finally {\n          IOUtils.close(input);\n        }\n      } else {\n        throw new IndexFormatTooOldException(stream, firstInt,\n            CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n    } finally {\n      if (success) {\n        IOUtils.close(stream);\n      } else {\n        IOUtils.closeWhileHandlingException(stream);\n      }\n    }\n  }\n\n","sourceOld":"  /** Helper method that reads CFS entries from an input stream */\n  private static final Map<String, FileEntry> readEntries(\n      IndexInputSlicer handle, Directory dir, String name) throws IOException {\n    // read the first VInt. If it is negative, it's the version number\n    // otherwise it's the count (pre-3.1 indexes)\n    final IndexInput stream = handle.openFullSlice();\n    final Map<String, FileEntry> mapping;\n    boolean success = false;\n    try {\n      final int firstInt = stream.readVInt();\n      if (firstInt == CompoundFileWriter.FORMAT_CURRENT) {\n        IndexInput input = null;\n        try {\n          final String entriesFileName = IndexFileNames.segmentFileName(\n                                                IndexFileNames.stripExtension(name), \"\",\n                                                IndexFileNames.COMPOUND_FILE_ENTRIES_EXTENSION);\n          input = dir.openInput(entriesFileName, IOContext.READONCE);\n          final int readInt = input.readInt(); // unused right now\n          assert readInt == CompoundFileWriter.ENTRY_FORMAT_CURRENT;\n          final int numEntries = input.readVInt();\n          mapping = new HashMap<String, CompoundFileDirectory.FileEntry>(\n              numEntries);\n          for (int i = 0; i < numEntries; i++) {\n            final FileEntry fileEntry = new FileEntry();\n            final String id = input.readString();\n            assert !mapping.containsKey(id): \"id=\" + id + \" was written multiple times in the CFS\";\n            mapping.put(id, fileEntry);\n            fileEntry.offset = input.readLong();\n            fileEntry.length = input.readLong();\n          }\n          success = true;\n          return mapping;\n        } finally {\n          IOUtils.close(input);\n        }\n      } else {\n        throw new IndexFormatTooOldException(stream, firstInt, \n            CompoundFileWriter.FORMAT_CURRENT, CompoundFileWriter.FORMAT_CURRENT);\n      }\n    } finally {\n      if (success) {\n        IOUtils.close(stream);\n      } else {\n        IOUtils.closeWhileHandlingException(stream);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78fab5842d05b1ef8e02366a77f845fab7870bc6","date":1341305040,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/CompoundFileDirectory#readEntries(IndexInputSlicer,Directory,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/CompoundFileDirectory#readEntries(IndexInputSlicer,Directory,String).mjava","sourceNew":"  /** Helper method that reads CFS entries from an input stream */\n  private static final Map<String, FileEntry> readEntries(\n      IndexInputSlicer handle, Directory dir, String name) throws IOException {\n    IOException priorE = null;\n    IndexInput stream = null, entriesStream = null;\n    try {\n      stream = handle.openFullSlice();\n      final int firstInt = stream.readInt();\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves. See SegmentInfos which also has this.\n      if (firstInt == CodecUtil.CODEC_MAGIC) {\n        CodecUtil.checkHeaderNoMagic(stream, CompoundFileWriter.DATA_CODEC, \n            CompoundFileWriter.VERSION_START, CompoundFileWriter.VERSION_START);\n        final String entriesFileName = IndexFileNames.segmentFileName(\n                                              IndexFileNames.stripExtension(name), \"\",\n                                              IndexFileNames.COMPOUND_FILE_ENTRIES_EXTENSION);\n        entriesStream = dir.openInput(entriesFileName, IOContext.READONCE);\n        CodecUtil.checkHeader(entriesStream, CompoundFileWriter.ENTRY_CODEC, CompoundFileWriter.VERSION_START, CompoundFileWriter.VERSION_START);\n        final int numEntries = entriesStream.readVInt();\n        final Map<String, FileEntry> mapping = new HashMap<String,FileEntry>(numEntries);\n        for (int i = 0; i < numEntries; i++) {\n          final FileEntry fileEntry = new FileEntry();\n          final String id = entriesStream.readString();\n          assert !mapping.containsKey(id): \"id=\" + id + \" was written multiple times in the CFS\";\n          mapping.put(id, fileEntry);\n          fileEntry.offset = entriesStream.readLong();\n          fileEntry.length = entriesStream.readLong();\n        }\n        return mapping;\n      } else {\n        throw new IndexFormatTooOldException(stream, firstInt,\n            CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n    } catch (IOException ioe) {\n      priorE = ioe;\n    } finally {\n      IOUtils.closeWhileHandlingException(priorE, stream, entriesStream);\n    }\n    // this is needed until Java 7's real try-with-resources:\n    throw new AssertionError(\"impossible to get here\");\n  }\n\n","sourceOld":"  /** Helper method that reads CFS entries from an input stream */\n  private static final Map<String, FileEntry> readEntries(\n      IndexInputSlicer handle, Directory dir, String name) throws IOException {\n    final IndexInput stream = handle.openFullSlice();\n    final Map<String, FileEntry> mapping;\n    boolean success = false;\n    try {\n      final int firstInt = stream.readInt();\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves. See SegmentInfos which also has this.\n      if (firstInt == CodecUtil.CODEC_MAGIC) {\n        CodecUtil.checkHeaderNoMagic(stream, CompoundFileWriter.DATA_CODEC, \n            CompoundFileWriter.VERSION_START, CompoundFileWriter.VERSION_START);\n        IndexInput input = null;\n        try {\n          final String entriesFileName = IndexFileNames.segmentFileName(\n                                                IndexFileNames.stripExtension(name), \"\",\n                                                IndexFileNames.COMPOUND_FILE_ENTRIES_EXTENSION);\n          input = dir.openInput(entriesFileName, IOContext.READONCE);\n          CodecUtil.checkHeader(input, CompoundFileWriter.ENTRY_CODEC, CompoundFileWriter.VERSION_START, CompoundFileWriter.VERSION_START);\n          final int numEntries = input.readVInt();\n          mapping = new HashMap<String, CompoundFileDirectory.FileEntry>(\n              numEntries);\n          for (int i = 0; i < numEntries; i++) {\n            final FileEntry fileEntry = new FileEntry();\n            final String id = input.readString();\n            assert !mapping.containsKey(id): \"id=\" + id + \" was written multiple times in the CFS\";\n            mapping.put(id, fileEntry);\n            fileEntry.offset = input.readLong();\n            fileEntry.length = input.readLong();\n          }\n          success = true;\n          return mapping;\n        } finally {\n          IOUtils.close(input);\n        }\n      } else {\n        throw new IndexFormatTooOldException(stream, firstInt,\n            CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n    } finally {\n      if (success) {\n        IOUtils.close(stream);\n      } else {\n        IOUtils.closeWhileHandlingException(stream);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/CompoundFileDirectory#readEntries(IndexInputSlicer,Directory,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/CompoundFileDirectory#readEntries(IndexInputSlicer,Directory,String).mjava","sourceNew":"  /** Helper method that reads CFS entries from an input stream */\n  private static final Map<String, FileEntry> readEntries(\n      IndexInputSlicer handle, Directory dir, String name) throws IOException {\n    IOException priorE = null;\n    IndexInput stream = null, entriesStream = null;\n    try {\n      stream = handle.openFullSlice();\n      final int firstInt = stream.readInt();\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves. See SegmentInfos which also has this.\n      if (firstInt == CodecUtil.CODEC_MAGIC) {\n        CodecUtil.checkHeaderNoMagic(stream, CompoundFileWriter.DATA_CODEC, \n            CompoundFileWriter.VERSION_START, CompoundFileWriter.VERSION_START);\n        final String entriesFileName = IndexFileNames.segmentFileName(\n                                              IndexFileNames.stripExtension(name), \"\",\n                                              IndexFileNames.COMPOUND_FILE_ENTRIES_EXTENSION);\n        entriesStream = dir.openInput(entriesFileName, IOContext.READONCE);\n        CodecUtil.checkHeader(entriesStream, CompoundFileWriter.ENTRY_CODEC, CompoundFileWriter.VERSION_START, CompoundFileWriter.VERSION_START);\n        final int numEntries = entriesStream.readVInt();\n        final Map<String, FileEntry> mapping = new HashMap<String,FileEntry>(numEntries);\n        for (int i = 0; i < numEntries; i++) {\n          final FileEntry fileEntry = new FileEntry();\n          final String id = entriesStream.readString();\n          assert !mapping.containsKey(id): \"id=\" + id + \" was written multiple times in the CFS\";\n          mapping.put(id, fileEntry);\n          fileEntry.offset = entriesStream.readLong();\n          fileEntry.length = entriesStream.readLong();\n        }\n        return mapping;\n      } else {\n        throw new IndexFormatTooOldException(stream, firstInt,\n            CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n    } catch (IOException ioe) {\n      priorE = ioe;\n    } finally {\n      IOUtils.closeWhileHandlingException(priorE, stream, entriesStream);\n    }\n    // this is needed until Java 7's real try-with-resources:\n    throw new AssertionError(\"impossible to get here\");\n  }\n\n","sourceOld":"  /** Helper method that reads CFS entries from an input stream */\n  private static final Map<String, FileEntry> readEntries(\n      IndexInputSlicer handle, Directory dir, String name) throws IOException {\n    final IndexInput stream = handle.openFullSlice();\n    final Map<String, FileEntry> mapping;\n    boolean success = false;\n    try {\n      final int firstInt = stream.readInt();\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves. See SegmentInfos which also has this.\n      if (firstInt == CodecUtil.CODEC_MAGIC) {\n        CodecUtil.checkHeaderNoMagic(stream, CompoundFileWriter.DATA_CODEC, \n            CompoundFileWriter.VERSION_START, CompoundFileWriter.VERSION_START);\n        IndexInput input = null;\n        try {\n          final String entriesFileName = IndexFileNames.segmentFileName(\n                                                IndexFileNames.stripExtension(name), \"\",\n                                                IndexFileNames.COMPOUND_FILE_ENTRIES_EXTENSION);\n          input = dir.openInput(entriesFileName, IOContext.READONCE);\n          CodecUtil.checkHeader(input, CompoundFileWriter.ENTRY_CODEC, CompoundFileWriter.VERSION_START, CompoundFileWriter.VERSION_START);\n          final int numEntries = input.readVInt();\n          mapping = new HashMap<String, CompoundFileDirectory.FileEntry>(\n              numEntries);\n          for (int i = 0; i < numEntries; i++) {\n            final FileEntry fileEntry = new FileEntry();\n            final String id = input.readString();\n            assert !mapping.containsKey(id): \"id=\" + id + \" was written multiple times in the CFS\";\n            mapping.put(id, fileEntry);\n            fileEntry.offset = input.readLong();\n            fileEntry.length = input.readLong();\n          }\n          success = true;\n          return mapping;\n        } finally {\n          IOUtils.close(input);\n        }\n      } else {\n        throw new IndexFormatTooOldException(stream, firstInt,\n            CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n    } finally {\n      if (success) {\n        IOUtils.close(stream);\n      } else {\n        IOUtils.closeWhileHandlingException(stream);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78ca5f1d812feb5c151a481774b24a13c785a803","date":1346937096,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/CompoundFileDirectory#readEntries(IndexInputSlicer,Directory,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/CompoundFileDirectory#readEntries(IndexInputSlicer,Directory,String).mjava","sourceNew":"  /** Helper method that reads CFS entries from an input stream */\n  private static final Map<String, FileEntry> readEntries(\n      IndexInputSlicer handle, Directory dir, String name) throws IOException {\n    IOException priorE = null;\n    IndexInput stream = null, entriesStream = null;\n    try {\n      stream = handle.openFullSlice();\n      final int firstInt = stream.readInt();\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves. See SegmentInfos which also has this.\n      if (firstInt == CodecUtil.CODEC_MAGIC) {\n        CodecUtil.checkHeaderNoMagic(stream, CompoundFileWriter.DATA_CODEC, \n            CompoundFileWriter.VERSION_START, CompoundFileWriter.VERSION_START);\n        final String entriesFileName = IndexFileNames.segmentFileName(\n                                              IndexFileNames.stripExtension(name), \"\",\n                                              IndexFileNames.COMPOUND_FILE_ENTRIES_EXTENSION);\n        entriesStream = dir.openInput(entriesFileName, IOContext.READONCE);\n        CodecUtil.checkHeader(entriesStream, CompoundFileWriter.ENTRY_CODEC, CompoundFileWriter.VERSION_START, CompoundFileWriter.VERSION_START);\n        final int numEntries = entriesStream.readVInt();\n        final Map<String, FileEntry> mapping = new HashMap<String,FileEntry>(numEntries);\n        for (int i = 0; i < numEntries; i++) {\n          final FileEntry fileEntry = new FileEntry();\n          final String id = entriesStream.readString();\n          FileEntry previous = mapping.put(id, fileEntry);\n          if (previous != null) {\n            throw new CorruptIndexException(\"Duplicate cfs entry id=\" + id + \" in CFS: \" + entriesStream);\n          }\n          fileEntry.offset = entriesStream.readLong();\n          fileEntry.length = entriesStream.readLong();\n        }\n        return mapping;\n      } else {\n        throw new IndexFormatTooOldException(stream, firstInt,\n            CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n    } catch (IOException ioe) {\n      priorE = ioe;\n    } finally {\n      IOUtils.closeWhileHandlingException(priorE, stream, entriesStream);\n    }\n    // this is needed until Java 7's real try-with-resources:\n    throw new AssertionError(\"impossible to get here\");\n  }\n\n","sourceOld":"  /** Helper method that reads CFS entries from an input stream */\n  private static final Map<String, FileEntry> readEntries(\n      IndexInputSlicer handle, Directory dir, String name) throws IOException {\n    IOException priorE = null;\n    IndexInput stream = null, entriesStream = null;\n    try {\n      stream = handle.openFullSlice();\n      final int firstInt = stream.readInt();\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves. See SegmentInfos which also has this.\n      if (firstInt == CodecUtil.CODEC_MAGIC) {\n        CodecUtil.checkHeaderNoMagic(stream, CompoundFileWriter.DATA_CODEC, \n            CompoundFileWriter.VERSION_START, CompoundFileWriter.VERSION_START);\n        final String entriesFileName = IndexFileNames.segmentFileName(\n                                              IndexFileNames.stripExtension(name), \"\",\n                                              IndexFileNames.COMPOUND_FILE_ENTRIES_EXTENSION);\n        entriesStream = dir.openInput(entriesFileName, IOContext.READONCE);\n        CodecUtil.checkHeader(entriesStream, CompoundFileWriter.ENTRY_CODEC, CompoundFileWriter.VERSION_START, CompoundFileWriter.VERSION_START);\n        final int numEntries = entriesStream.readVInt();\n        final Map<String, FileEntry> mapping = new HashMap<String,FileEntry>(numEntries);\n        for (int i = 0; i < numEntries; i++) {\n          final FileEntry fileEntry = new FileEntry();\n          final String id = entriesStream.readString();\n          assert !mapping.containsKey(id): \"id=\" + id + \" was written multiple times in the CFS\";\n          mapping.put(id, fileEntry);\n          fileEntry.offset = entriesStream.readLong();\n          fileEntry.length = entriesStream.readLong();\n        }\n        return mapping;\n      } else {\n        throw new IndexFormatTooOldException(stream, firstInt,\n            CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n    } catch (IOException ioe) {\n      priorE = ioe;\n    } finally {\n      IOUtils.closeWhileHandlingException(priorE, stream, entriesStream);\n    }\n    // this is needed until Java 7's real try-with-resources:\n    throw new AssertionError(\"impossible to get here\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4e5e734869d76c22acfc12bc53ecbfcc1606c2f5","date":1347072117,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/store/CompoundFileDirectory#readEntries(IndexInputSlicer,Directory,String).mjava","sourceNew":null,"sourceOld":"  /** Helper method that reads CFS entries from an input stream */\n  private static final Map<String, FileEntry> readEntries(\n      IndexInputSlicer handle, Directory dir, String name) throws IOException {\n    IOException priorE = null;\n    IndexInput stream = null, entriesStream = null;\n    try {\n      stream = handle.openFullSlice();\n      final int firstInt = stream.readInt();\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves. See SegmentInfos which also has this.\n      if (firstInt == CodecUtil.CODEC_MAGIC) {\n        CodecUtil.checkHeaderNoMagic(stream, CompoundFileWriter.DATA_CODEC, \n            CompoundFileWriter.VERSION_START, CompoundFileWriter.VERSION_START);\n        final String entriesFileName = IndexFileNames.segmentFileName(\n                                              IndexFileNames.stripExtension(name), \"\",\n                                              IndexFileNames.COMPOUND_FILE_ENTRIES_EXTENSION);\n        entriesStream = dir.openInput(entriesFileName, IOContext.READONCE);\n        CodecUtil.checkHeader(entriesStream, CompoundFileWriter.ENTRY_CODEC, CompoundFileWriter.VERSION_START, CompoundFileWriter.VERSION_START);\n        final int numEntries = entriesStream.readVInt();\n        final Map<String, FileEntry> mapping = new HashMap<String,FileEntry>(numEntries);\n        for (int i = 0; i < numEntries; i++) {\n          final FileEntry fileEntry = new FileEntry();\n          final String id = entriesStream.readString();\n          FileEntry previous = mapping.put(id, fileEntry);\n          if (previous != null) {\n            throw new CorruptIndexException(\"Duplicate cfs entry id=\" + id + \" in CFS: \" + entriesStream);\n          }\n          fileEntry.offset = entriesStream.readLong();\n          fileEntry.length = entriesStream.readLong();\n        }\n        return mapping;\n      } else {\n        throw new IndexFormatTooOldException(stream, firstInt,\n            CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n    } catch (IOException ioe) {\n      priorE = ioe;\n    } finally {\n      IOUtils.closeWhileHandlingException(priorE, stream, entriesStream);\n    }\n    // this is needed until Java 7's real try-with-resources:\n    throw new AssertionError(\"impossible to get here\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4e5e734869d76c22acfc12bc53ecbfcc1606c2f5":["78ca5f1d812feb5c151a481774b24a13c785a803"],"a914aecf1d2ee9c6e6959625e89f2b1b31de7c48":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["61c01d39462806d7dce1e381b201c104783ab056","78fab5842d05b1ef8e02366a77f845fab7870bc6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"78ca5f1d812feb5c151a481774b24a13c785a803":["78fab5842d05b1ef8e02366a77f845fab7870bc6"],"78fab5842d05b1ef8e02366a77f845fab7870bc6":["61c01d39462806d7dce1e381b201c104783ab056"],"61c01d39462806d7dce1e381b201c104783ab056":["a914aecf1d2ee9c6e6959625e89f2b1b31de7c48"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4e5e734869d76c22acfc12bc53ecbfcc1606c2f5"]},"commit2Childs":{"4e5e734869d76c22acfc12bc53ecbfcc1606c2f5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a914aecf1d2ee9c6e6959625e89f2b1b31de7c48":["61c01d39462806d7dce1e381b201c104783ab056"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a914aecf1d2ee9c6e6959625e89f2b1b31de7c48"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"78ca5f1d812feb5c151a481774b24a13c785a803":["4e5e734869d76c22acfc12bc53ecbfcc1606c2f5"],"78fab5842d05b1ef8e02366a77f845fab7870bc6":["fe33227f6805edab2036cbb80645cc4e2d1fa424","78ca5f1d812feb5c151a481774b24a13c785a803"],"61c01d39462806d7dce1e381b201c104783ab056":["fe33227f6805edab2036cbb80645cc4e2d1fa424","78fab5842d05b1ef8e02366a77f845fab7870bc6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}