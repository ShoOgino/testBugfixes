{"path":"lucene/classification/src/java/org/apache/lucene/classification/KNearestFuzzyClassifier#buildListFromTopDocs(TopDocs).mjava","commits":[{"id":"e71b30ca45cace3116f6ee06a0bbcb578707fa52","date":1495110978,"type":0,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestFuzzyClassifier#buildListFromTopDocs(TopDocs).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * build a list of classification results from search results\n   *\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  protected List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.getMaxScore();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      IndexableField storableField = indexSearcher.doc(scoreDoc.doc).getField(classFieldName);\n      if (storableField != null) {\n        BytesRef cl = new BytesRef(storableField.stringValue());\n        //update count\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestFuzzyClassifier#buildListFromTopDocs(TopDocs).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * build a list of classification results from search results\n   *\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  protected List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.getMaxScore();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      IndexableField storableField = indexSearcher.doc(scoreDoc.doc).getField(classFieldName);\n      if (storableField != null) {\n        BytesRef cl = new BytesRef(storableField.stringValue());\n        //update count\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b9626938d906e220bc834fca668189e7cdf4985d","date":1498723309,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestFuzzyClassifier#buildListFromTopDocs(TopDocs).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/KNearestFuzzyClassifier#buildListFromTopDocs(TopDocs).mjava","sourceNew":"  /**\n   * build a list of classification results from search results\n   *\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  private List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.getMaxScore();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      IndexableField storableField = indexSearcher.doc(scoreDoc.doc).getField(classFieldName);\n      if (storableField != null) {\n        BytesRef cl = new BytesRef(storableField.stringValue());\n        //update count\n        classCounts.merge(cl, 1, (a, b) -> a + b);\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","sourceOld":"  /**\n   * build a list of classification results from search results\n   *\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  protected List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.getMaxScore();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      IndexableField storableField = indexSearcher.doc(scoreDoc.doc).getField(classFieldName);\n      if (storableField != null) {\n        BytesRef cl = new BytesRef(storableField.stringValue());\n        //update count\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestFuzzyClassifier#buildListFromTopDocs(TopDocs).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/KNearestFuzzyClassifier#buildListFromTopDocs(TopDocs).mjava","sourceNew":"  /**\n   * build a list of classification results from search results\n   *\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  private List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.getMaxScore();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      IndexableField storableField = indexSearcher.doc(scoreDoc.doc).getField(classFieldName);\n      if (storableField != null) {\n        BytesRef cl = new BytesRef(storableField.stringValue());\n        //update count\n        classCounts.merge(cl, 1, (a, b) -> a + b);\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","sourceOld":"  /**\n   * build a list of classification results from search results\n   *\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  protected List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.getMaxScore();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      IndexableField storableField = indexSearcher.doc(scoreDoc.doc).getField(classFieldName);\n      if (storableField != null) {\n        BytesRef cl = new BytesRef(storableField.stringValue());\n        //update count\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30c8e5574b55d57947e989443dfde611646530ee","date":1499131153,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestFuzzyClassifier#buildListFromTopDocs(TopDocs).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/KNearestFuzzyClassifier#buildListFromTopDocs(TopDocs).mjava","sourceNew":"  /**\n   * build a list of classification results from search results\n   *\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  private List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.getMaxScore();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      IndexableField storableField = indexSearcher.doc(scoreDoc.doc).getField(classFieldName);\n      if (storableField != null) {\n        BytesRef cl = new BytesRef(storableField.stringValue());\n        //update count\n        classCounts.merge(cl, 1, (a, b) -> a + b);\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","sourceOld":"  /**\n   * build a list of classification results from search results\n   *\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  protected List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.getMaxScore();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      IndexableField storableField = indexSearcher.doc(scoreDoc.doc).getField(classFieldName);\n      if (storableField != null) {\n        BytesRef cl = new BytesRef(storableField.stringValue());\n        //update count\n        Integer count = classCounts.get(cl);\n        if (count != null) {\n          classCounts.put(cl, count + 1);\n        } else {\n          classCounts.put(cl, 1);\n        }\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81fff83bdb893c1471efd78f6a9a3ce4f98120b9","date":1531895937,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestFuzzyClassifier#buildListFromTopDocs(TopDocs).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/KNearestFuzzyClassifier#buildListFromTopDocs(TopDocs).mjava","sourceNew":"  /**\n   * build a list of classification results from search results\n   *\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  private List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.totalHits == 0 ? Float.NaN : topDocs.scoreDocs[0].score;\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      IndexableField storableField = indexSearcher.doc(scoreDoc.doc).getField(classFieldName);\n      if (storableField != null) {\n        BytesRef cl = new BytesRef(storableField.stringValue());\n        //update count\n        classCounts.merge(cl, 1, (a, b) -> a + b);\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","sourceOld":"  /**\n   * build a list of classification results from search results\n   *\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  private List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.getMaxScore();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      IndexableField storableField = indexSearcher.doc(scoreDoc.doc).getField(classFieldName);\n      if (storableField != null) {\n        BytesRef cl = new BytesRef(storableField.stringValue());\n        //update count\n        classCounts.merge(cl, 1, (a, b) -> a + b);\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestFuzzyClassifier#buildListFromTopDocs(TopDocs).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/KNearestFuzzyClassifier#buildListFromTopDocs(TopDocs).mjava","sourceNew":"  /**\n   * build a list of classification results from search results\n   *\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  private List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.totalHits == 0 ? Float.NaN : topDocs.scoreDocs[0].score;\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      IndexableField storableField = indexSearcher.doc(scoreDoc.doc).getField(classFieldName);\n      if (storableField != null) {\n        BytesRef cl = new BytesRef(storableField.stringValue());\n        //update count\n        classCounts.merge(cl, 1, (a, b) -> a + b);\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","sourceOld":"  /**\n   * build a list of classification results from search results\n   *\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  private List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.getMaxScore();\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      IndexableField storableField = indexSearcher.doc(scoreDoc.doc).getField(classFieldName);\n      if (storableField != null) {\n        BytesRef cl = new BytesRef(storableField.stringValue());\n        //update count\n        classCounts.merge(cl, 1, (a, b) -> a + b);\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/KNearestFuzzyClassifier#buildListFromTopDocs(TopDocs).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/KNearestFuzzyClassifier#buildListFromTopDocs(TopDocs).mjava","sourceNew":"  /**\n   * build a list of classification results from search results\n   *\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  private List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.totalHits.value == 0 ? Float.NaN : topDocs.scoreDocs[0].score;\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      IndexableField storableField = indexSearcher.doc(scoreDoc.doc).getField(classFieldName);\n      if (storableField != null) {\n        BytesRef cl = new BytesRef(storableField.stringValue());\n        //update count\n        classCounts.merge(cl, 1, (a, b) -> a + b);\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","sourceOld":"  /**\n   * build a list of classification results from search results\n   *\n   * @param topDocs the search results as a {@link TopDocs} object\n   * @return a {@link List} of {@link ClassificationResult}, one for each existing class\n   * @throws IOException if it's not possible to get the stored value of class field\n   */\n  private List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {\n    Map<BytesRef, Integer> classCounts = new HashMap<>();\n    Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs\n    float maxScore = topDocs.totalHits == 0 ? Float.NaN : topDocs.scoreDocs[0].score;\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n      IndexableField storableField = indexSearcher.doc(scoreDoc.doc).getField(classFieldName);\n      if (storableField != null) {\n        BytesRef cl = new BytesRef(storableField.stringValue());\n        //update count\n        classCounts.merge(cl, 1, (a, b) -> a + b);\n        //update boost, the boost is based on the best score\n        Double totalBoost = classBoosts.get(cl);\n        double singleBoost = scoreDoc.score / maxScore;\n        if (totalBoost != null) {\n          classBoosts.put(cl, totalBoost + singleBoost);\n        } else {\n          classBoosts.put(cl, singleBoost);\n        }\n      }\n    }\n    List<ClassificationResult<BytesRef>> returnList = new ArrayList<>();\n    List<ClassificationResult<BytesRef>> temporaryList = new ArrayList<>();\n    int sumdoc = 0;\n    for (Map.Entry<BytesRef, Integer> entry : classCounts.entrySet()) {\n      Integer count = entry.getValue();\n      Double normBoost = classBoosts.get(entry.getKey()) / count; //the boost is normalized to be 0<b<1\n      temporaryList.add(new ClassificationResult<>(entry.getKey().clone(), (count * normBoost) / (double) k));\n      sumdoc += count;\n    }\n\n    //correction\n    if (sumdoc < k) {\n      for (ClassificationResult<BytesRef> cr : temporaryList) {\n        returnList.add(new ClassificationResult<>(cr.getAssignedClass(), cr.getScore() * k / (double) sumdoc));\n      }\n    } else {\n      returnList = temporaryList;\n    }\n    return returnList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e71b30ca45cace3116f6ee06a0bbcb578707fa52":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e71b30ca45cace3116f6ee06a0bbcb578707fa52"],"b9626938d906e220bc834fca668189e7cdf4985d":["e71b30ca45cace3116f6ee06a0bbcb578707fa52"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["28288370235ed02234a64753cdbf0c6ec096304a","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"30c8e5574b55d57947e989443dfde611646530ee":["e9017cf144952056066919f1ebc7897ff9bd71b1","28288370235ed02234a64753cdbf0c6ec096304a"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["28288370235ed02234a64753cdbf0c6ec096304a"],"28288370235ed02234a64753cdbf0c6ec096304a":["e71b30ca45cace3116f6ee06a0bbcb578707fa52","b9626938d906e220bc834fca668189e7cdf4985d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["83788ad129a5154d5c6562c4e8ce3db48793aada"]},"commit2Childs":{"e71b30ca45cace3116f6ee06a0bbcb578707fa52":["e9017cf144952056066919f1ebc7897ff9bd71b1","b9626938d906e220bc834fca668189e7cdf4985d","28288370235ed02234a64753cdbf0c6ec096304a"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["30c8e5574b55d57947e989443dfde611646530ee"],"b9626938d906e220bc834fca668189e7cdf4985d":["28288370235ed02234a64753cdbf0c6ec096304a"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e71b30ca45cace3116f6ee06a0bbcb578707fa52","e9017cf144952056066919f1ebc7897ff9bd71b1"],"30c8e5574b55d57947e989443dfde611646530ee":[],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","83788ad129a5154d5c6562c4e8ce3db48793aada"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"28288370235ed02234a64753cdbf0c6ec096304a":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","30c8e5574b55d57947e989443dfde611646530ee","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","30c8e5574b55d57947e989443dfde611646530ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}