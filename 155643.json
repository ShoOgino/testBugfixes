{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsIndex.MemoryChunkFieldsIndexWriter#writeBlock().mjava","commits":[{"id":"ccd8ff5675189c84a504cdee7da185e2c3ca3164","date":1351698863,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsIndex.MemoryChunkFieldsIndexWriter#writeBlock().mjava","pathOld":"/dev/null","sourceNew":"    private void writeBlock() throws IOException {\n      assert blockChunks > 0;\n      fieldsIndexOut.writeVInt(blockChunks);\n\n      // The trick here is that we only store the difference from the average start\n      // pointer or doc base, this helps save bits per value.\n      // And in order to prevent a few chunks that would be far from the average to\n      // raise the number of bits per value for all of them, we only encode blocks\n      // of 1024 chunks at once\n      // See LUCENE-4512\n\n      // doc bases\n      final int avgChunkDocs;\n      if (blockChunks == 1) {\n        avgChunkDocs = 0;\n      } else {\n        avgChunkDocs = Math.round((float) (blockDocs - docBaseDeltas[blockChunks - 1]) / (blockChunks - 1));\n      }\n      fieldsIndexOut.writeVInt(totalDocs - blockDocs); // docBase\n      fieldsIndexOut.writeVInt(avgChunkDocs);\n      int docBase = 0;\n      long maxDelta = 0;\n      for (int i = 0; i < blockChunks; ++i) {\n        final int delta = docBase - avgChunkDocs * i;\n        maxDelta |= moveSignToLowOrderBit(delta);\n        docBase += docBaseDeltas[i];\n      }\n\n      final int bitsPerDocBase = PackedInts.bitsRequired(maxDelta);\n      fieldsIndexOut.writeVInt(bitsPerDocBase);\n      PackedInts.Writer writer = PackedInts.getWriterNoHeader(fieldsIndexOut,\n          PackedInts.Format.PACKED, blockChunks, bitsPerDocBase, 1);\n      docBase = 0;\n      for (int i = 0; i < blockChunks; ++i) {\n        final long delta = docBase - avgChunkDocs * i;\n        assert PackedInts.bitsRequired(moveSignToLowOrderBit(delta)) <= writer.bitsPerValue();\n        writer.add(moveSignToLowOrderBit(delta));\n        docBase += docBaseDeltas[i];\n      }\n      writer.finish();\n\n      // start pointers\n      fieldsIndexOut.writeVLong(firstStartPointer);\n      final long avgChunkSize;\n      if (blockChunks == 1) {\n        avgChunkSize = 0;\n      } else {\n        avgChunkSize = (maxStartPointer - firstStartPointer) / (blockChunks - 1);\n      }\n      fieldsIndexOut.writeVLong(avgChunkSize);\n      long startPointer = 0;\n      maxDelta = 0;\n      for (int i = 0; i < blockChunks; ++i) {\n        startPointer += startPointerDeltas[i];\n        final long delta = startPointer - avgChunkSize * i;\n        maxDelta |= moveSignToLowOrderBit(delta);\n      }\n\n      final int bitsPerStartPointer = PackedInts.bitsRequired(maxDelta);\n      fieldsIndexOut.writeVInt(bitsPerStartPointer);\n      writer = PackedInts.getWriterNoHeader(fieldsIndexOut, PackedInts.Format.PACKED,\n          blockChunks, bitsPerStartPointer, 1);\n      startPointer = 0;\n      for (int i = 0; i < blockChunks; ++i) {\n        startPointer += startPointerDeltas[i];\n        final long delta = startPointer - avgChunkSize * i;\n        assert PackedInts.bitsRequired(moveSignToLowOrderBit(delta)) <= writer.bitsPerValue();\n        writer.add(moveSignToLowOrderBit(delta));\n      }\n      writer.finish();\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a96cceee825e15cd8e042b683d404086e2a58d1","date":1351872237,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsIndex.MemoryChunkFieldsIndexWriter#writeBlock().mjava","sourceNew":null,"sourceOld":"    private void writeBlock() throws IOException {\n      assert blockChunks > 0;\n      fieldsIndexOut.writeVInt(blockChunks);\n\n      // The trick here is that we only store the difference from the average start\n      // pointer or doc base, this helps save bits per value.\n      // And in order to prevent a few chunks that would be far from the average to\n      // raise the number of bits per value for all of them, we only encode blocks\n      // of 1024 chunks at once\n      // See LUCENE-4512\n\n      // doc bases\n      final int avgChunkDocs;\n      if (blockChunks == 1) {\n        avgChunkDocs = 0;\n      } else {\n        avgChunkDocs = Math.round((float) (blockDocs - docBaseDeltas[blockChunks - 1]) / (blockChunks - 1));\n      }\n      fieldsIndexOut.writeVInt(totalDocs - blockDocs); // docBase\n      fieldsIndexOut.writeVInt(avgChunkDocs);\n      int docBase = 0;\n      long maxDelta = 0;\n      for (int i = 0; i < blockChunks; ++i) {\n        final int delta = docBase - avgChunkDocs * i;\n        maxDelta |= moveSignToLowOrderBit(delta);\n        docBase += docBaseDeltas[i];\n      }\n\n      final int bitsPerDocBase = PackedInts.bitsRequired(maxDelta);\n      fieldsIndexOut.writeVInt(bitsPerDocBase);\n      PackedInts.Writer writer = PackedInts.getWriterNoHeader(fieldsIndexOut,\n          PackedInts.Format.PACKED, blockChunks, bitsPerDocBase, 1);\n      docBase = 0;\n      for (int i = 0; i < blockChunks; ++i) {\n        final long delta = docBase - avgChunkDocs * i;\n        assert PackedInts.bitsRequired(moveSignToLowOrderBit(delta)) <= writer.bitsPerValue();\n        writer.add(moveSignToLowOrderBit(delta));\n        docBase += docBaseDeltas[i];\n      }\n      writer.finish();\n\n      // start pointers\n      fieldsIndexOut.writeVLong(firstStartPointer);\n      final long avgChunkSize;\n      if (blockChunks == 1) {\n        avgChunkSize = 0;\n      } else {\n        avgChunkSize = (maxStartPointer - firstStartPointer) / (blockChunks - 1);\n      }\n      fieldsIndexOut.writeVLong(avgChunkSize);\n      long startPointer = 0;\n      maxDelta = 0;\n      for (int i = 0; i < blockChunks; ++i) {\n        startPointer += startPointerDeltas[i];\n        final long delta = startPointer - avgChunkSize * i;\n        maxDelta |= moveSignToLowOrderBit(delta);\n      }\n\n      final int bitsPerStartPointer = PackedInts.bitsRequired(maxDelta);\n      fieldsIndexOut.writeVInt(bitsPerStartPointer);\n      writer = PackedInts.getWriterNoHeader(fieldsIndexOut, PackedInts.Format.PACKED,\n          blockChunks, bitsPerStartPointer, 1);\n      startPointer = 0;\n      for (int i = 0; i < blockChunks; ++i) {\n        startPointer += startPointerDeltas[i];\n        final long delta = startPointer - avgChunkSize * i;\n        assert PackedInts.bitsRequired(moveSignToLowOrderBit(delta)) <= writer.bitsPerValue();\n        writer.add(moveSignToLowOrderBit(delta));\n      }\n      writer.finish();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0a96cceee825e15cd8e042b683d404086e2a58d1":["ccd8ff5675189c84a504cdee7da185e2c3ca3164"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ccd8ff5675189c84a504cdee7da185e2c3ca3164":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0a96cceee825e15cd8e042b683d404086e2a58d1"]},"commit2Childs":{"0a96cceee825e15cd8e042b683d404086e2a58d1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ccd8ff5675189c84a504cdee7da185e2c3ca3164"],"ccd8ff5675189c84a504cdee7da185e2c3ca3164":["0a96cceee825e15cd8e042b683d404086e2a58d1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}