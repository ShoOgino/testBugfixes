{"path":"solr/core/src/test/org/apache/solr/cloud/TlogReplayBufferedWhileIndexingTest#test().mjava","commits":[{"id":"052e752d13b775cc343d0b8588d38be0113b24ba","date":1454626441,"type":0,"author":"Mark Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TlogReplayBufferedWhileIndexingTest#test().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForRecoveriesToFinish(false);\n    \n    int numThreads = 1;\n    \n    threads = new ArrayList<>(numThreads);\n    \n    ArrayList<JettySolrRunner> allJetty = new ArrayList<>();\n    allJetty.addAll(jettys);\n    allJetty.remove(shardToLeaderJetty.get(\"shard1\").jetty);\n    assert allJetty.size() == 1 : allJetty.size();\n    ChaosMonkey.stop(allJetty.get(0));\n    \n    StoppableIndexingThread indexThread;\n    for (int i = 0; i < numThreads; i++) {\n      indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), false, 50000, 1, false);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n\n    Thread.sleep(2000);\n    \n    ChaosMonkey.start(allJetty.get(0));\n    \n    Thread.sleep(45000);\n  \n    waitForThingsToLevelOut(320);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, cloudClient.getZkStateReader(), false, true);\n    \n    for (StoppableIndexingThread thread : threads) {\n      thread.safeStop();\n      thread.safeStop();\n    }\n    \n    waitForThingsToLevelOut(30);\n\n    checkShardConsistency(false, false);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85639ac489df34a1af4df5f84b90b46c12d03152","date":1454627270,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TlogReplayBufferedWhileIndexingTest#test().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForRecoveriesToFinish(false);\n    \n    int numThreads = 1;\n    \n    threads = new ArrayList<>(numThreads);\n    \n    ArrayList<JettySolrRunner> allJetty = new ArrayList<>();\n    allJetty.addAll(jettys);\n    allJetty.remove(shardToLeaderJetty.get(\"shard1\").jetty);\n    assert allJetty.size() == 1 : allJetty.size();\n    ChaosMonkey.stop(allJetty.get(0));\n    \n    StoppableIndexingThread indexThread;\n    for (int i = 0; i < numThreads; i++) {\n      indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), false, 50000, 1, false);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n\n    Thread.sleep(2000);\n    \n    ChaosMonkey.start(allJetty.get(0));\n    \n    Thread.sleep(45000);\n  \n    waitForThingsToLevelOut(320);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, cloudClient.getZkStateReader(), false, true);\n    \n    for (StoppableIndexingThread thread : threads) {\n      thread.safeStop();\n      thread.safeStop();\n    }\n    \n    waitForThingsToLevelOut(30);\n\n    checkShardConsistency(false, false);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b1704c078ec59838c9d95d5bf5738b393b537494","date":1454693901,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TlogReplayBufferedWhileIndexingTest#test().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForRecoveriesToFinish(false);\n    \n    int numThreads = 1;\n    \n    threads = new ArrayList<>(numThreads);\n    \n    ArrayList<JettySolrRunner> allJetty = new ArrayList<>();\n    allJetty.addAll(jettys);\n    allJetty.remove(shardToLeaderJetty.get(\"shard1\").jetty);\n    assert allJetty.size() == 1 : allJetty.size();\n    ChaosMonkey.stop(allJetty.get(0));\n    \n    StoppableIndexingThread indexThread;\n    for (int i = 0; i < numThreads; i++) {\n      indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), false, 50000, 1, false);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n\n    Thread.sleep(2000);\n    \n    ChaosMonkey.start(allJetty.get(0));\n    \n    Thread.sleep(45000);\n  \n    waitForThingsToLevelOut(320);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, cloudClient.getZkStateReader(), false, true);\n    \n    for (StoppableIndexingThread thread : threads) {\n      thread.safeStop();\n      thread.safeStop();\n    }\n    \n    waitForThingsToLevelOut(30);\n\n    checkShardConsistency(false, false);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TlogReplayBufferedWhileIndexingTest#test().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForRecoveriesToFinish(false);\n    \n    int numThreads = 1;\n    \n    threads = new ArrayList<>(numThreads);\n    \n    ArrayList<JettySolrRunner> allJetty = new ArrayList<>();\n    allJetty.addAll(jettys);\n    allJetty.remove(shardToLeaderJetty.get(\"shard1\").jetty);\n    assert allJetty.size() == 1 : allJetty.size();\n    ChaosMonkey.stop(allJetty.get(0));\n    \n    StoppableIndexingThread indexThread;\n    for (int i = 0; i < numThreads; i++) {\n      indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), false, 50000, 1, false);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n\n    Thread.sleep(2000);\n    \n    ChaosMonkey.start(allJetty.get(0));\n    \n    Thread.sleep(45000);\n  \n    waitForThingsToLevelOut(320);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, cloudClient.getZkStateReader(), false, true);\n    \n    for (StoppableIndexingThread thread : threads) {\n      thread.safeStop();\n      thread.safeStop();\n    }\n    \n    waitForThingsToLevelOut(30);\n\n    checkShardConsistency(false, false);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd9f6c0ea8e68b9769f3620189f200c9232be6a4","date":1455197557,"type":4,"author":"markrmiller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/TlogReplayBufferedWhileIndexingTest#test().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForRecoveriesToFinish(false);\n    \n    int numThreads = 1;\n    \n    threads = new ArrayList<>(numThreads);\n    \n    ArrayList<JettySolrRunner> allJetty = new ArrayList<>();\n    allJetty.addAll(jettys);\n    allJetty.remove(shardToLeaderJetty.get(\"shard1\").jetty);\n    assert allJetty.size() == 1 : allJetty.size();\n    ChaosMonkey.stop(allJetty.get(0));\n    \n    StoppableIndexingThread indexThread;\n    for (int i = 0; i < numThreads; i++) {\n      indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), false, 50000, 1, false);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n\n    Thread.sleep(2000);\n    \n    ChaosMonkey.start(allJetty.get(0));\n    \n    Thread.sleep(45000);\n  \n    waitForThingsToLevelOut(320);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, cloudClient.getZkStateReader(), false, true);\n    \n    for (StoppableIndexingThread thread : threads) {\n      thread.safeStop();\n      thread.safeStop();\n    }\n    \n    waitForThingsToLevelOut(30);\n\n    checkShardConsistency(false, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1b800611029360525d55dc4797bcdfc2a689b7fe","date":1455310686,"type":0,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TlogReplayBufferedWhileIndexingTest#test().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForRecoveriesToFinish(false);\n    \n    int numThreads = 3;\n    \n    threads = new ArrayList<>(numThreads);\n    \n    ArrayList<JettySolrRunner> allJetty = new ArrayList<>();\n    allJetty.addAll(jettys);\n    allJetty.remove(shardToLeaderJetty.get(\"shard1\").jetty);\n    assert allJetty.size() == 1 : allJetty.size();\n    ChaosMonkey.stop(allJetty.get(0));\n    \n    StoppableIndexingThread indexThread;\n    for (int i = 0; i < numThreads; i++) {\n      boolean pauseBetweenUpdates = random().nextBoolean();\n      int batchSize = random().nextInt(4) + 1;\n      indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, 900, batchSize, pauseBetweenUpdates);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n\n    Thread.sleep(2000);\n    \n    ChaosMonkey.start(allJetty.get(0));\n    \n    Thread.sleep(45000);\n  \n    waitForThingsToLevelOut(440);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, cloudClient.getZkStateReader(), false, true);\n    \n    for (StoppableIndexingThread thread : threads) {\n      thread.safeStop();\n    }\n    \n    waitForThingsToLevelOut(30);\n\n    checkShardConsistency(false, false);\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"79638da7bcb06f91cb0ec6c8de7c642ba111b0ca","date":1487532897,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TlogReplayBufferedWhileIndexingTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TlogReplayBufferedWhileIndexingTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForRecoveriesToFinish(false);\n    \n    int numThreads = 3;\n    \n    threads = new ArrayList<>(numThreads);\n    \n    ArrayList<JettySolrRunner> allJetty = new ArrayList<>();\n    allJetty.addAll(jettys);\n    allJetty.remove(shardToLeaderJetty.get(\"shard1\").jetty);\n    assert allJetty.size() == 1 : allJetty.size();\n    ChaosMonkey.stop(allJetty.get(0));\n    \n    StoppableIndexingThread indexThread;\n    for (int i = 0; i < numThreads; i++) {\n      boolean pauseBetweenUpdates = random().nextBoolean();\n      int batchSize = random().nextInt(4) + 1;\n      indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, 900, batchSize, pauseBetweenUpdates);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n\n    Thread.sleep(2000);\n    \n    ChaosMonkey.start(allJetty.get(0));\n    \n    Thread.sleep(45000);\n  \n    waitForThingsToLevelOut(600); // we can insert random update delays, so this can take a while, especially when beasting this test\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, cloudClient.getZkStateReader(), false, true);\n    \n    for (StoppableIndexingThread thread : threads) {\n      thread.safeStop();\n    }\n    \n    waitForThingsToLevelOut(30);\n\n    checkShardConsistency(false, false);\n\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForRecoveriesToFinish(false);\n    \n    int numThreads = 3;\n    \n    threads = new ArrayList<>(numThreads);\n    \n    ArrayList<JettySolrRunner> allJetty = new ArrayList<>();\n    allJetty.addAll(jettys);\n    allJetty.remove(shardToLeaderJetty.get(\"shard1\").jetty);\n    assert allJetty.size() == 1 : allJetty.size();\n    ChaosMonkey.stop(allJetty.get(0));\n    \n    StoppableIndexingThread indexThread;\n    for (int i = 0; i < numThreads; i++) {\n      boolean pauseBetweenUpdates = random().nextBoolean();\n      int batchSize = random().nextInt(4) + 1;\n      indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, 900, batchSize, pauseBetweenUpdates);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n\n    Thread.sleep(2000);\n    \n    ChaosMonkey.start(allJetty.get(0));\n    \n    Thread.sleep(45000);\n  \n    waitForThingsToLevelOut(440);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, cloudClient.getZkStateReader(), false, true);\n    \n    for (StoppableIndexingThread thread : threads) {\n      thread.safeStop();\n    }\n    \n    waitForThingsToLevelOut(30);\n\n    checkShardConsistency(false, false);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TlogReplayBufferedWhileIndexingTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TlogReplayBufferedWhileIndexingTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForRecoveriesToFinish(false);\n    \n    int numThreads = 3;\n    \n    threads = new ArrayList<>(numThreads);\n    \n    ArrayList<JettySolrRunner> allJetty = new ArrayList<>();\n    allJetty.addAll(jettys);\n    allJetty.remove(shardToLeaderJetty.get(\"shard1\").jetty);\n    assert allJetty.size() == 1 : allJetty.size();\n    allJetty.get(0).stop();\n    \n    StoppableIndexingThread indexThread;\n    for (int i = 0; i < numThreads; i++) {\n      boolean pauseBetweenUpdates = random().nextBoolean();\n      int batchSize = random().nextInt(4) + 1;\n      indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, 900, batchSize, pauseBetweenUpdates);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n\n    Thread.sleep(2000);\n    \n    allJetty.get(0).start();\n    \n    Thread.sleep(45000);\n  \n    waitForThingsToLevelOut(600); // we can insert random update delays, so this can take a while, especially when beasting this test\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, cloudClient.getZkStateReader(), false, true);\n    \n    for (StoppableIndexingThread thread : threads) {\n      thread.safeStop();\n    }\n    \n    waitForThingsToLevelOut(30);\n\n    checkShardConsistency(false, false);\n\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForRecoveriesToFinish(false);\n    \n    int numThreads = 3;\n    \n    threads = new ArrayList<>(numThreads);\n    \n    ArrayList<JettySolrRunner> allJetty = new ArrayList<>();\n    allJetty.addAll(jettys);\n    allJetty.remove(shardToLeaderJetty.get(\"shard1\").jetty);\n    assert allJetty.size() == 1 : allJetty.size();\n    ChaosMonkey.stop(allJetty.get(0));\n    \n    StoppableIndexingThread indexThread;\n    for (int i = 0; i < numThreads; i++) {\n      boolean pauseBetweenUpdates = random().nextBoolean();\n      int batchSize = random().nextInt(4) + 1;\n      indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, 900, batchSize, pauseBetweenUpdates);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n\n    Thread.sleep(2000);\n    \n    ChaosMonkey.start(allJetty.get(0));\n    \n    Thread.sleep(45000);\n  \n    waitForThingsToLevelOut(600); // we can insert random update delays, so this can take a while, especially when beasting this test\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, cloudClient.getZkStateReader(), false, true);\n    \n    for (StoppableIndexingThread thread : threads) {\n      thread.safeStop();\n    }\n    \n    waitForThingsToLevelOut(30);\n\n    checkShardConsistency(false, false);\n\n  }\n\n","bugFix":["1b800611029360525d55dc4797bcdfc2a689b7fe"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"add1e7dd742ea533ff4318cea83ca0a1f669f662","date":1585262285,"type":3,"author":"Mike Drob","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TlogReplayBufferedWhileIndexingTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TlogReplayBufferedWhileIndexingTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForRecoveriesToFinish(false);\n    \n    int numThreads = 3;\n    \n    threads = new ArrayList<>(numThreads);\n    \n    ArrayList<JettySolrRunner> allJetty = new ArrayList<>();\n    allJetty.addAll(jettys);\n    allJetty.remove(shardToLeaderJetty.get(\"shard1\").jetty);\n    assert allJetty.size() == 1 : allJetty.size();\n    allJetty.get(0).stop();\n    \n    StoppableIndexingThread indexThread;\n    for (int i = 0; i < numThreads; i++) {\n      boolean pauseBetweenUpdates = random().nextBoolean();\n      int batchSize = random().nextInt(4) + 1;\n      indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, 900, batchSize, pauseBetweenUpdates);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n\n    Thread.sleep(2000);\n    \n    allJetty.get(0).start();\n    \n    Thread.sleep(45000);\n  \n    waitForThingsToLevelOut(); // we can insert random update delays, so this can take a while, especially when beasting this test\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, cloudClient.getZkStateReader(), false, true);\n    \n    for (StoppableIndexingThread thread : threads) {\n      thread.safeStop();\n    }\n    \n    waitForThingsToLevelOut(30, TimeUnit.SECONDS);\n\n    checkShardConsistency(false, false);\n\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForRecoveriesToFinish(false);\n    \n    int numThreads = 3;\n    \n    threads = new ArrayList<>(numThreads);\n    \n    ArrayList<JettySolrRunner> allJetty = new ArrayList<>();\n    allJetty.addAll(jettys);\n    allJetty.remove(shardToLeaderJetty.get(\"shard1\").jetty);\n    assert allJetty.size() == 1 : allJetty.size();\n    allJetty.get(0).stop();\n    \n    StoppableIndexingThread indexThread;\n    for (int i = 0; i < numThreads; i++) {\n      boolean pauseBetweenUpdates = random().nextBoolean();\n      int batchSize = random().nextInt(4) + 1;\n      indexThread = new StoppableIndexingThread(controlClient, cloudClient, Integer.toString(i), true, 900, batchSize, pauseBetweenUpdates);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n\n    Thread.sleep(2000);\n    \n    allJetty.get(0).start();\n    \n    Thread.sleep(45000);\n  \n    waitForThingsToLevelOut(600); // we can insert random update delays, so this can take a while, especially when beasting this test\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(DEFAULT_COLLECTION, cloudClient.getZkStateReader(), false, true);\n    \n    for (StoppableIndexingThread thread : threads) {\n      thread.safeStop();\n    }\n    \n    waitForThingsToLevelOut(30);\n\n    checkShardConsistency(false, false);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["79638da7bcb06f91cb0ec6c8de7c642ba111b0ca"],"79638da7bcb06f91cb0ec6c8de7c642ba111b0ca":["1b800611029360525d55dc4797bcdfc2a689b7fe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","85639ac489df34a1af4df5f84b90b46c12d03152"],"add1e7dd742ea533ff4318cea83ca0a1f669f662":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"bd9f6c0ea8e68b9769f3620189f200c9232be6a4":["85639ac489df34a1af4df5f84b90b46c12d03152"],"052e752d13b775cc343d0b8588d38be0113b24ba":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b1704c078ec59838c9d95d5bf5738b393b537494":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","85639ac489df34a1af4df5f84b90b46c12d03152"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["add1e7dd742ea533ff4318cea83ca0a1f669f662"],"1b800611029360525d55dc4797bcdfc2a689b7fe":["bd9f6c0ea8e68b9769f3620189f200c9232be6a4"],"85639ac489df34a1af4df5f84b90b46c12d03152":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","052e752d13b775cc343d0b8588d38be0113b24ba"]},"commit2Childs":{"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["add1e7dd742ea533ff4318cea83ca0a1f669f662"],"79638da7bcb06f91cb0ec6c8de7c642ba111b0ca":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","052e752d13b775cc343d0b8588d38be0113b24ba","b1704c078ec59838c9d95d5bf5738b393b537494","85639ac489df34a1af4df5f84b90b46c12d03152"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"add1e7dd742ea533ff4318cea83ca0a1f669f662":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bd9f6c0ea8e68b9769f3620189f200c9232be6a4":["1b800611029360525d55dc4797bcdfc2a689b7fe"],"052e752d13b775cc343d0b8588d38be0113b24ba":["85639ac489df34a1af4df5f84b90b46c12d03152"],"b1704c078ec59838c9d95d5bf5738b393b537494":[],"1b800611029360525d55dc4797bcdfc2a689b7fe":["79638da7bcb06f91cb0ec6c8de7c642ba111b0ca"],"85639ac489df34a1af4df5f84b90b46c12d03152":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","bd9f6c0ea8e68b9769f3620189f200c9232be6a4","b1704c078ec59838c9d95d5bf5738b393b537494"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","b1704c078ec59838c9d95d5bf5738b393b537494","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}