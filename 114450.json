{"path":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterPerThreadPool#testCloseWhileNewWritersLocked().mjava","commits":[{"id":"bd3903df1f9f4cfe074c9e72c60e31a9bed0ff72","date":1597413898,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterPerThreadPool#testCloseWhileNewWritersLocked().mjava","pathOld":"/dev/null","sourceNew":"  public void testCloseWhileNewWritersLocked() throws IOException, InterruptedException {\n    try (Directory directory = newDirectory()) {\n      DocumentsWriterPerThreadPool pool = new DocumentsWriterPerThreadPool(() ->\n          new DocumentsWriterPerThread(Version.LATEST.major, \"\", directory, directory,\n              newIndexWriterConfig(), new DocumentsWriterDeleteQueue(null), null, new AtomicLong(), false));\n\n      DocumentsWriterPerThread first = pool.getAndLock();\n      pool.lockNewWriters();\n      CountDownLatch latch = new CountDownLatch(1);\n      Thread t = new Thread(() -> {\n        try {\n          latch.countDown();\n          pool.getAndLock();\n          fail();\n        } catch (AlreadyClosedException e) {\n          // fine\n        } catch (IOException e) {\n          throw new AssertionError(e);\n        }\n      });\n      t.start();\n      latch.await();\n      while (t.getState().equals(Thread.State.WAITING) == false) {\n        Thread.yield();\n      }\n      first.unlock();\n      pool.close();\n      pool.unlockNewWriters();\n      for (DocumentsWriterPerThread perThread : pool.filterAndLock(x -> true)) {\n        assertTrue(pool.checkout(perThread));\n        perThread.unlock();\n      }\n      assertEquals(0, pool.size());\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"49f1924bd448393fbdfef8b5ebed799f938169d3","date":1600069616,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterPerThreadPool#testCloseWhileNewWritersLocked().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterPerThreadPool#testCloseWhileNewWritersLocked().mjava","sourceNew":"  public void testCloseWhileNewWritersLocked() throws IOException, InterruptedException {\n    try (Directory directory = newDirectory()) {\n      DocumentsWriterPerThreadPool pool = new DocumentsWriterPerThreadPool(() ->\n          new DocumentsWriterPerThread(Version.LATEST.major, \"\", directory, directory,\n              newIndexWriterConfig(), new DocumentsWriterDeleteQueue(null), null, new AtomicLong(), false));\n\n      DocumentsWriterPerThread first = pool.getAndLock();\n      pool.lockNewWriters();\n      CountDownLatch latch = new CountDownLatch(1);\n      Thread t = new Thread(() -> {\n        try {\n          latch.countDown();\n          pool.getAndLock();\n          fail();\n        } catch (AlreadyClosedException e) {\n          // fine\n        }\n      });\n      t.start();\n      latch.await();\n      while (t.getState().equals(Thread.State.WAITING) == false) {\n        Thread.yield();\n      }\n      first.unlock();\n      pool.close();\n      pool.unlockNewWriters();\n      for (DocumentsWriterPerThread perThread : pool.filterAndLock(x -> true)) {\n        assertTrue(pool.checkout(perThread));\n        perThread.unlock();\n      }\n      assertEquals(0, pool.size());\n    }\n  }\n\n","sourceOld":"  public void testCloseWhileNewWritersLocked() throws IOException, InterruptedException {\n    try (Directory directory = newDirectory()) {\n      DocumentsWriterPerThreadPool pool = new DocumentsWriterPerThreadPool(() ->\n          new DocumentsWriterPerThread(Version.LATEST.major, \"\", directory, directory,\n              newIndexWriterConfig(), new DocumentsWriterDeleteQueue(null), null, new AtomicLong(), false));\n\n      DocumentsWriterPerThread first = pool.getAndLock();\n      pool.lockNewWriters();\n      CountDownLatch latch = new CountDownLatch(1);\n      Thread t = new Thread(() -> {\n        try {\n          latch.countDown();\n          pool.getAndLock();\n          fail();\n        } catch (AlreadyClosedException e) {\n          // fine\n        } catch (IOException e) {\n          throw new AssertionError(e);\n        }\n      });\n      t.start();\n      latch.await();\n      while (t.getState().equals(Thread.State.WAITING) == false) {\n        Thread.yield();\n      }\n      first.unlock();\n      pool.close();\n      pool.unlockNewWriters();\n      for (DocumentsWriterPerThread perThread : pool.filterAndLock(x -> true)) {\n        assertTrue(pool.checkout(perThread));\n        perThread.unlock();\n      }\n      assertEquals(0, pool.size());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0dcf8f79417865e5028d753e669fae06457e8369","date":1600073240,"type":3,"author":"noblepaul","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterPerThreadPool#testCloseWhileNewWritersLocked().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterPerThreadPool#testCloseWhileNewWritersLocked().mjava","sourceNew":"  public void testCloseWhileNewWritersLocked() throws IOException, InterruptedException {\n    try (Directory directory = newDirectory()) {\n      DocumentsWriterPerThreadPool pool = new DocumentsWriterPerThreadPool(() ->\n          new DocumentsWriterPerThread(Version.LATEST.major, \"\", directory, directory,\n              newIndexWriterConfig(), new DocumentsWriterDeleteQueue(null), null, new AtomicLong(), false));\n\n      DocumentsWriterPerThread first = pool.getAndLock();\n      pool.lockNewWriters();\n      CountDownLatch latch = new CountDownLatch(1);\n      Thread t = new Thread(() -> {\n        try {\n          latch.countDown();\n          pool.getAndLock();\n          fail();\n        } catch (AlreadyClosedException e) {\n          // fine\n        }\n      });\n      t.start();\n      latch.await();\n      while (t.getState().equals(Thread.State.WAITING) == false) {\n        Thread.yield();\n      }\n      first.unlock();\n      pool.close();\n      pool.unlockNewWriters();\n      for (DocumentsWriterPerThread perThread : pool.filterAndLock(x -> true)) {\n        assertTrue(pool.checkout(perThread));\n        perThread.unlock();\n      }\n      assertEquals(0, pool.size());\n    }\n  }\n\n","sourceOld":"  public void testCloseWhileNewWritersLocked() throws IOException, InterruptedException {\n    try (Directory directory = newDirectory()) {\n      DocumentsWriterPerThreadPool pool = new DocumentsWriterPerThreadPool(() ->\n          new DocumentsWriterPerThread(Version.LATEST.major, \"\", directory, directory,\n              newIndexWriterConfig(), new DocumentsWriterDeleteQueue(null), null, new AtomicLong(), false));\n\n      DocumentsWriterPerThread first = pool.getAndLock();\n      pool.lockNewWriters();\n      CountDownLatch latch = new CountDownLatch(1);\n      Thread t = new Thread(() -> {\n        try {\n          latch.countDown();\n          pool.getAndLock();\n          fail();\n        } catch (AlreadyClosedException e) {\n          // fine\n        } catch (IOException e) {\n          throw new AssertionError(e);\n        }\n      });\n      t.start();\n      latch.await();\n      while (t.getState().equals(Thread.State.WAITING) == false) {\n        Thread.yield();\n      }\n      first.unlock();\n      pool.close();\n      pool.unlockNewWriters();\n      for (DocumentsWriterPerThread perThread : pool.filterAndLock(x -> true)) {\n        assertTrue(pool.checkout(perThread));\n        perThread.unlock();\n      }\n      assertEquals(0, pool.size());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"49f1924bd448393fbdfef8b5ebed799f938169d3":["bd3903df1f9f4cfe074c9e72c60e31a9bed0ff72"],"bd3903df1f9f4cfe074c9e72c60e31a9bed0ff72":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0dcf8f79417865e5028d753e669fae06457e8369":["bd3903df1f9f4cfe074c9e72c60e31a9bed0ff72","49f1924bd448393fbdfef8b5ebed799f938169d3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0dcf8f79417865e5028d753e669fae06457e8369"]},"commit2Childs":{"49f1924bd448393fbdfef8b5ebed799f938169d3":["0dcf8f79417865e5028d753e669fae06457e8369"],"bd3903df1f9f4cfe074c9e72c60e31a9bed0ff72":["49f1924bd448393fbdfef8b5ebed799f938169d3","0dcf8f79417865e5028d753e669fae06457e8369"],"0dcf8f79417865e5028d753e669fae06457e8369":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bd3903df1f9f4cfe074c9e72c60e31a9bed0ff72"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}