{"path":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#ReplicaAssigner(List[Rule],Map[String,Integer],List,Map[String,Map[String,Integer]],List[String],CoreContainer,ClusterState).mjava","commits":[{"id":"ec4fc24ecd353171e03bd016c1681cd97476015f","date":1432214672,"type":1,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#ReplicaAssigner(List[Rule],Map[String,Integer],List,Map[String,Map[String,Integer]],List[String],CoreContainer,ClusterState).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#ReplicaAssigner(List[Rule],Map[String,Integer],List,Map[String,Set[String]],List[String],CoreContainer,ClusterState).mjava","sourceNew":"  /**\n   * @param shardVsReplicaCount shard names vs no:of replicas required for each of those shards\n   * @param snitches            snitches details\n   * @param shardVsNodes        The current state of the system. can be an empty map if no nodes\n   *                            are created in this collection till now\n   */\n  public ReplicaAssigner(List<Rule> rules,\n                         Map<String, Integer> shardVsReplicaCount,\n                         List snitches,\n                         Map<String, Map<String, Integer>> shardVsNodes,\n                         List<String> liveNodes,\n                         CoreContainer cc, ClusterState clusterState) {\n    this.rules = rules;\n    for (Rule rule : rules) tagNames.add(rule.tag.name);\n    this.shardVsReplicaCount = shardVsReplicaCount;\n    this.liveNodes = new ArrayList<>(liveNodes);\n    this.nodeVsTags = getTagsForNodes(cc, snitches);\n    this.shardVsNodes = getDeepCopy(shardVsNodes, 2);\n    validateTags(nodeVsTags);\n\n    if (clusterState != null) {\n      for (String s : clusterState.getCollections()) {\n        DocCollection coll = clusterState.getCollection(s);\n        for (Slice slice : coll.getSlices()) {\n          for (Replica replica : slice.getReplicas()) {\n            AtomicInteger count = nodeVsCores.get(replica.getNodeName());\n            if (count == null) nodeVsCores.put(replica.getNodeName(), count = new AtomicInteger());\n            count.incrementAndGet();\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * @param shardVsReplicaCount shard names vs no:of replicas required for each of those shards\n   * @param snitches            snitches details\n   * @param shardVsNodes        The current state of the system. can be an empty map if no nodes\n   *                            are created in this collection till now\n   */\n  public ReplicaAssigner(List<Rule> rules,\n                         Map<String, Integer> shardVsReplicaCount,\n                         List snitches,\n                         Map<String, Set<String>> shardVsNodes,\n                         List<String> liveNodes,\n                         CoreContainer cc, ClusterState clusterState) {\n    this.rules = rules;\n    for (Rule rule : rules) tagNames.add(rule.tag.name);\n    this.shardVsReplicaCount = shardVsReplicaCount;\n    this.liveNodes = new ArrayList<>(liveNodes);\n    this.nodeVsTags = getTagsForNodes(cc, snitches);\n    this.shardVsNodes = getDeepCopy(shardVsNodes, 2);\n    validateTags(nodeVsTags);\n\n    if (clusterState != null) {\n      for (String s : clusterState.getCollections()) {\n        DocCollection coll = clusterState.getCollection(s);\n        for (Slice slice : coll.getSlices()) {\n          for (Replica replica : slice.getReplicas()) {\n            AtomicInteger count = nodeVsCores.get(replica.getNodeName());\n            if (count == null) nodeVsCores.put(replica.getNodeName(), count = new AtomicInteger());\n            count.incrementAndGet();\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5aa6dcd736e5c400d1c763ae8fa2fe5aedb75132","date":1457088757,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#ReplicaAssigner(List[Rule],Map[String,Integer],List,Map[String,Map[String,Integer]],List[String],CoreContainer,ClusterState).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#ReplicaAssigner(List[Rule],Map[String,Integer],List,Map[String,Map[String,Integer]],List[String],CoreContainer,ClusterState).mjava","sourceNew":"  /**\n   * @param shardVsReplicaCount shard names vs no:of replicas required for each of those shards\n   * @param snitches            snitches details\n   * @param shardVsNodes        The current state of the system. can be an empty map if no nodes\n   *                            are created in this collection till now\n   */\n  public ReplicaAssigner(List<Rule> rules,\n                         Map<String, Integer> shardVsReplicaCount,\n                         List snitches,\n                         Map<String, Map<String, Integer>> shardVsNodes,\n                         List<String> participatingLiveNodes,\n                         CoreContainer cc, ClusterState clusterState) {\n    this.rules = rules;\n    for (Rule rule : rules) tagNames.add(rule.tag.name);\n    this.shardVsReplicaCount = shardVsReplicaCount;\n    this.participatingLiveNodes = new ArrayList<>(participatingLiveNodes);\n    this.nodeVsTags = getTagsForNodes(cc, snitches);\n    this.shardVsNodes = getDeepCopy(shardVsNodes, 2);\n    validateTags(nodeVsTags);\n\n    if (clusterState != null) {\n      for (String s : clusterState.getCollections()) {\n        DocCollection coll = clusterState.getCollection(s);\n        for (Slice slice : coll.getSlices()) {\n          for (Replica replica : slice.getReplicas()) {\n            AtomicInteger count = nodeVsCores.get(replica.getNodeName());\n            if (count == null) nodeVsCores.put(replica.getNodeName(), count = new AtomicInteger());\n            count.incrementAndGet();\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * @param shardVsReplicaCount shard names vs no:of replicas required for each of those shards\n   * @param snitches            snitches details\n   * @param shardVsNodes        The current state of the system. can be an empty map if no nodes\n   *                            are created in this collection till now\n   */\n  public ReplicaAssigner(List<Rule> rules,\n                         Map<String, Integer> shardVsReplicaCount,\n                         List snitches,\n                         Map<String, Map<String, Integer>> shardVsNodes,\n                         List<String> liveNodes,\n                         CoreContainer cc, ClusterState clusterState) {\n    this.rules = rules;\n    for (Rule rule : rules) tagNames.add(rule.tag.name);\n    this.shardVsReplicaCount = shardVsReplicaCount;\n    this.liveNodes = new ArrayList<>(liveNodes);\n    this.nodeVsTags = getTagsForNodes(cc, snitches);\n    this.shardVsNodes = getDeepCopy(shardVsNodes, 2);\n    validateTags(nodeVsTags);\n\n    if (clusterState != null) {\n      for (String s : clusterState.getCollections()) {\n        DocCollection coll = clusterState.getCollection(s);\n        for (Slice slice : coll.getSlices()) {\n          for (Replica replica : slice.getReplicas()) {\n            AtomicInteger count = nodeVsCores.get(replica.getNodeName());\n            if (count == null) nodeVsCores.put(replica.getNodeName(), count = new AtomicInteger());\n            count.incrementAndGet();\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":["8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9974f61802aea1d15849a1053f88f5e89fc32b4","date":1462405923,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#ReplicaAssigner(List[Rule],Map[String,Integer],List,Map[String,Map[String,Integer]],List[String],CoreContainer,ClusterState).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#ReplicaAssigner(List[Rule],Map[String,Integer],List,Map[String,Map[String,Integer]],List[String],CoreContainer,ClusterState).mjava","sourceNew":"  /**\n   * @param shardVsReplicaCount shard names vs no:of replicas required for each of those shards\n   * @param snitches            snitches details\n   * @param shardVsNodes        The current state of the system. can be an empty map if no nodes\n   *                            are created in this collection till now\n   */\n  public ReplicaAssigner(List<Rule> rules,\n                         Map<String, Integer> shardVsReplicaCount,\n                         List snitches,\n                         Map<String, Map<String, Integer>> shardVsNodes,\n                         List<String> participatingLiveNodes,\n                         CoreContainer cc, ClusterState clusterState) {\n    this.rules = rules;\n    for (Rule rule : rules) tagNames.add(rule.tag.name);\n    this.shardVsReplicaCount = shardVsReplicaCount;\n    this.participatingLiveNodes = new ArrayList<>(participatingLiveNodes);\n    this.nodeVsTags = getTagsForNodes(cc, snitches);\n    this.shardVsNodes = getDeepCopy(shardVsNodes, 2);\n    validateTags(nodeVsTags);\n\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        DocCollection coll = entry.getValue();\n        for (Slice slice : coll.getSlices()) {\n          for (Replica replica : slice.getReplicas()) {\n            AtomicInteger count = nodeVsCores.get(replica.getNodeName());\n            if (count == null) nodeVsCores.put(replica.getNodeName(), count = new AtomicInteger());\n            count.incrementAndGet();\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * @param shardVsReplicaCount shard names vs no:of replicas required for each of those shards\n   * @param snitches            snitches details\n   * @param shardVsNodes        The current state of the system. can be an empty map if no nodes\n   *                            are created in this collection till now\n   */\n  public ReplicaAssigner(List<Rule> rules,\n                         Map<String, Integer> shardVsReplicaCount,\n                         List snitches,\n                         Map<String, Map<String, Integer>> shardVsNodes,\n                         List<String> participatingLiveNodes,\n                         CoreContainer cc, ClusterState clusterState) {\n    this.rules = rules;\n    for (Rule rule : rules) tagNames.add(rule.tag.name);\n    this.shardVsReplicaCount = shardVsReplicaCount;\n    this.participatingLiveNodes = new ArrayList<>(participatingLiveNodes);\n    this.nodeVsTags = getTagsForNodes(cc, snitches);\n    this.shardVsNodes = getDeepCopy(shardVsNodes, 2);\n    validateTags(nodeVsTags);\n\n    if (clusterState != null) {\n      for (String s : clusterState.getCollections()) {\n        DocCollection coll = clusterState.getCollection(s);\n        for (Slice slice : coll.getSlices()) {\n          for (Replica replica : slice.getReplicas()) {\n            AtomicInteger count = nodeVsCores.get(replica.getNodeName());\n            if (count == null) nodeVsCores.put(replica.getNodeName(), count = new AtomicInteger());\n            count.incrementAndGet();\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"73450c0955930295d34703e7ddbfc6973b7a121a","date":1462431925,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#ReplicaAssigner(List[Rule],Map[String,Integer],List,Map[String,Map[String,Integer]],List[String],CoreContainer,ClusterState).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#ReplicaAssigner(List[Rule],Map[String,Integer],List,Map[String,Map[String,Integer]],List[String],CoreContainer,ClusterState).mjava","sourceNew":"  /**\n   * @param shardVsReplicaCount shard names vs no:of replicas required for each of those shards\n   * @param snitches            snitches details\n   * @param shardVsNodes        The current state of the system. can be an empty map if no nodes\n   *                            are created in this collection till now\n   */\n  public ReplicaAssigner(List<Rule> rules,\n                         Map<String, Integer> shardVsReplicaCount,\n                         List snitches,\n                         Map<String, Map<String, Integer>> shardVsNodes,\n                         List<String> participatingLiveNodes,\n                         CoreContainer cc, ClusterState clusterState) {\n    this.rules = rules;\n    for (Rule rule : rules) tagNames.add(rule.tag.name);\n    this.shardVsReplicaCount = shardVsReplicaCount;\n    this.participatingLiveNodes = new ArrayList<>(participatingLiveNodes);\n    this.nodeVsTags = getTagsForNodes(cc, snitches);\n    this.shardVsNodes = getDeepCopy(shardVsNodes, 2);\n    validateTags(nodeVsTags);\n\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        DocCollection coll = entry.getValue();\n        for (Slice slice : coll.getSlices()) {\n          for (Replica replica : slice.getReplicas()) {\n            AtomicInteger count = nodeVsCores.get(replica.getNodeName());\n            if (count == null) nodeVsCores.put(replica.getNodeName(), count = new AtomicInteger());\n            count.incrementAndGet();\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * @param shardVsReplicaCount shard names vs no:of replicas required for each of those shards\n   * @param snitches            snitches details\n   * @param shardVsNodes        The current state of the system. can be an empty map if no nodes\n   *                            are created in this collection till now\n   */\n  public ReplicaAssigner(List<Rule> rules,\n                         Map<String, Integer> shardVsReplicaCount,\n                         List snitches,\n                         Map<String, Map<String, Integer>> shardVsNodes,\n                         List<String> participatingLiveNodes,\n                         CoreContainer cc, ClusterState clusterState) {\n    this.rules = rules;\n    for (Rule rule : rules) tagNames.add(rule.tag.name);\n    this.shardVsReplicaCount = shardVsReplicaCount;\n    this.participatingLiveNodes = new ArrayList<>(participatingLiveNodes);\n    this.nodeVsTags = getTagsForNodes(cc, snitches);\n    this.shardVsNodes = getDeepCopy(shardVsNodes, 2);\n    validateTags(nodeVsTags);\n\n    if (clusterState != null) {\n      for (String s : clusterState.getCollections()) {\n        DocCollection coll = clusterState.getCollection(s);\n        for (Slice slice : coll.getSlices()) {\n          for (Replica replica : slice.getReplicas()) {\n            AtomicInteger count = nodeVsCores.get(replica.getNodeName());\n            if (count == null) nodeVsCores.put(replica.getNodeName(), count = new AtomicInteger());\n            count.incrementAndGet();\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc08f02757dd10637b16a5c65eaaef839a91a9a","date":1462455462,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#ReplicaAssigner(List[Rule],Map[String,Integer],List,Map[String,Map[String,Integer]],List[String],CoreContainer,ClusterState).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#ReplicaAssigner(List[Rule],Map[String,Integer],List,Map[String,Map[String,Integer]],List[String],CoreContainer,ClusterState).mjava","sourceNew":"  /**\n   * @param shardVsReplicaCount shard names vs no:of replicas required for each of those shards\n   * @param snitches            snitches details\n   * @param shardVsNodes        The current state of the system. can be an empty map if no nodes\n   *                            are created in this collection till now\n   */\n  public ReplicaAssigner(List<Rule> rules,\n                         Map<String, Integer> shardVsReplicaCount,\n                         List snitches,\n                         Map<String, Map<String, Integer>> shardVsNodes,\n                         List<String> participatingLiveNodes,\n                         CoreContainer cc, ClusterState clusterState) {\n    this.rules = rules;\n    for (Rule rule : rules) tagNames.add(rule.tag.name);\n    this.shardVsReplicaCount = shardVsReplicaCount;\n    this.participatingLiveNodes = new ArrayList<>(participatingLiveNodes);\n    this.nodeVsTags = getTagsForNodes(cc, snitches);\n    this.shardVsNodes = getDeepCopy(shardVsNodes, 2);\n    validateTags(nodeVsTags);\n\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        DocCollection coll = entry.getValue();\n        for (Slice slice : coll.getSlices()) {\n          for (Replica replica : slice.getReplicas()) {\n            AtomicInteger count = nodeVsCores.get(replica.getNodeName());\n            if (count == null) nodeVsCores.put(replica.getNodeName(), count = new AtomicInteger());\n            count.incrementAndGet();\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * @param shardVsReplicaCount shard names vs no:of replicas required for each of those shards\n   * @param snitches            snitches details\n   * @param shardVsNodes        The current state of the system. can be an empty map if no nodes\n   *                            are created in this collection till now\n   */\n  public ReplicaAssigner(List<Rule> rules,\n                         Map<String, Integer> shardVsReplicaCount,\n                         List snitches,\n                         Map<String, Map<String, Integer>> shardVsNodes,\n                         List<String> participatingLiveNodes,\n                         CoreContainer cc, ClusterState clusterState) {\n    this.rules = rules;\n    for (Rule rule : rules) tagNames.add(rule.tag.name);\n    this.shardVsReplicaCount = shardVsReplicaCount;\n    this.participatingLiveNodes = new ArrayList<>(participatingLiveNodes);\n    this.nodeVsTags = getTagsForNodes(cc, snitches);\n    this.shardVsNodes = getDeepCopy(shardVsNodes, 2);\n    validateTags(nodeVsTags);\n\n    if (clusterState != null) {\n      for (String s : clusterState.getCollections()) {\n        DocCollection coll = clusterState.getCollection(s);\n        for (Slice slice : coll.getSlices()) {\n          for (Replica replica : slice.getReplicas()) {\n            AtomicInteger count = nodeVsCores.get(replica.getNodeName());\n            if (count == null) nodeVsCores.put(replica.getNodeName(), count = new AtomicInteger());\n            count.incrementAndGet();\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","date":1462576651,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#ReplicaAssigner(List[Rule],Map[String,Integer],List,Map[String,Map[String,Integer]],List[String],CoreContainer,ClusterState).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#ReplicaAssigner(List[Rule],Map[String,Integer],List,Map[String,Map[String,Integer]],List[String],CoreContainer,ClusterState).mjava","sourceNew":"  /**\n   * @param shardVsReplicaCount shard names vs no:of replicas required for each of those shards\n   * @param snitches            snitches details\n   * @param shardVsNodes        The current state of the system. can be an empty map if no nodes\n   *                            are created in this collection till now\n   */\n  public ReplicaAssigner(List<Rule> rules,\n                         Map<String, Integer> shardVsReplicaCount,\n                         List snitches,\n                         Map<String, Map<String, Integer>> shardVsNodes,\n                         List<String> participatingLiveNodes,\n                         CoreContainer cc, ClusterState clusterState) {\n    this.rules = rules;\n    for (Rule rule : rules) tagNames.add(rule.tag.name);\n    this.shardVsReplicaCount = shardVsReplicaCount;\n    this.participatingLiveNodes = new ArrayList<>(participatingLiveNodes);\n    this.nodeVsTags = getTagsForNodes(cc, snitches);\n    this.shardVsNodes = getDeepCopy(shardVsNodes, 2);\n    validateTags(nodeVsTags);\n\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        DocCollection coll = entry.getValue();\n        for (Slice slice : coll.getSlices()) {\n          for (Replica replica : slice.getReplicas()) {\n            AtomicInteger count = nodeVsCores.get(replica.getNodeName());\n            if (count == null) nodeVsCores.put(replica.getNodeName(), count = new AtomicInteger());\n            count.incrementAndGet();\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * @param shardVsReplicaCount shard names vs no:of replicas required for each of those shards\n   * @param snitches            snitches details\n   * @param shardVsNodes        The current state of the system. can be an empty map if no nodes\n   *                            are created in this collection till now\n   */\n  public ReplicaAssigner(List<Rule> rules,\n                         Map<String, Integer> shardVsReplicaCount,\n                         List snitches,\n                         Map<String, Map<String, Integer>> shardVsNodes,\n                         List<String> participatingLiveNodes,\n                         CoreContainer cc, ClusterState clusterState) {\n    this.rules = rules;\n    for (Rule rule : rules) tagNames.add(rule.tag.name);\n    this.shardVsReplicaCount = shardVsReplicaCount;\n    this.participatingLiveNodes = new ArrayList<>(participatingLiveNodes);\n    this.nodeVsTags = getTagsForNodes(cc, snitches);\n    this.shardVsNodes = getDeepCopy(shardVsNodes, 2);\n    validateTags(nodeVsTags);\n\n    if (clusterState != null) {\n      for (String s : clusterState.getCollections()) {\n        DocCollection coll = clusterState.getCollection(s);\n        for (Slice slice : coll.getSlices()) {\n          for (Replica replica : slice.getReplicas()) {\n            AtomicInteger count = nodeVsCores.get(replica.getNodeName());\n            if (count == null) nodeVsCores.put(replica.getNodeName(), count = new AtomicInteger());\n            count.incrementAndGet();\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bf98283bf93e06ee092a158798e6a9d53bb4c747","date":1483715447,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#ReplicaAssigner(List[Rule],Map[String,Integer],List,Map[String,Map[String,Integer]],List[String],CoreContainer,ClusterState).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#ReplicaAssigner(List[Rule],Map[String,Integer],List,Map[String,Map[String,Integer]],List[String],CoreContainer,ClusterState).mjava","sourceNew":"  /**\n   * @param shardVsReplicaCount shard names vs no:of replicas required for each of those shards\n   * @param snitches            snitches details\n   * @param shardVsNodes        The current state of the system. can be an empty map if no nodes\n   *                            are created in this collection till now\n   */\n  public ReplicaAssigner(List<Rule> rules,\n                         Map<String, Integer> shardVsReplicaCount,\n                         List snitches,\n                         Map<String, Map<String, Integer>> shardVsNodes,\n                         List<String> participatingLiveNodes,\n                         CoreContainer cc, ClusterState clusterState) {\n    this.rules = rules;\n    for (Rule rule : rules) tagNames.add(rule.tag.name);\n    this.shardVsReplicaCount = shardVsReplicaCount;\n    this.participatingLiveNodes = new ArrayList<>(participatingLiveNodes);\n    this.nodeVsTags = getTagsForNodes(cc, snitches);\n    this.shardVsNodes = getDeepCopy(shardVsNodes, 2);\n\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        DocCollection coll = entry.getValue();\n        for (Slice slice : coll.getSlices()) {\n          for (Replica replica : slice.getReplicas()) {\n            AtomicInteger count = nodeVsCores.get(replica.getNodeName());\n            if (count == null) nodeVsCores.put(replica.getNodeName(), count = new AtomicInteger());\n            count.incrementAndGet();\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * @param shardVsReplicaCount shard names vs no:of replicas required for each of those shards\n   * @param snitches            snitches details\n   * @param shardVsNodes        The current state of the system. can be an empty map if no nodes\n   *                            are created in this collection till now\n   */\n  public ReplicaAssigner(List<Rule> rules,\n                         Map<String, Integer> shardVsReplicaCount,\n                         List snitches,\n                         Map<String, Map<String, Integer>> shardVsNodes,\n                         List<String> participatingLiveNodes,\n                         CoreContainer cc, ClusterState clusterState) {\n    this.rules = rules;\n    for (Rule rule : rules) tagNames.add(rule.tag.name);\n    this.shardVsReplicaCount = shardVsReplicaCount;\n    this.participatingLiveNodes = new ArrayList<>(participatingLiveNodes);\n    this.nodeVsTags = getTagsForNodes(cc, snitches);\n    this.shardVsNodes = getDeepCopy(shardVsNodes, 2);\n    validateTags(nodeVsTags);\n\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        DocCollection coll = entry.getValue();\n        for (Slice slice : coll.getSlices()) {\n          for (Replica replica : slice.getReplicas()) {\n            AtomicInteger count = nodeVsCores.get(replica.getNodeName());\n            if (count == null) nodeVsCores.put(replica.getNodeName(), count = new AtomicInteger());\n            count.incrementAndGet();\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":["8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"491c9672ec42582fe43960452dbd37f1c80fe0f0","date":1483739222,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#ReplicaAssigner(List[Rule],Map[String,Integer],List,Map[String,Map[String,Integer]],List[String],CoreContainer,ClusterState).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#ReplicaAssigner(List[Rule],Map[String,Integer],List,Map[String,Map[String,Integer]],List[String],CoreContainer,ClusterState).mjava","sourceNew":"  /**\n   * @param shardVsReplicaCount shard names vs no:of replicas required for each of those shards\n   * @param snitches            snitches details\n   * @param shardVsNodes        The current state of the system. can be an empty map if no nodes\n   *                            are created in this collection till now\n   */\n  public ReplicaAssigner(List<Rule> rules,\n                         Map<String, Integer> shardVsReplicaCount,\n                         List snitches,\n                         Map<String, Map<String, Integer>> shardVsNodes,\n                         List<String> participatingLiveNodes,\n                         CoreContainer cc, ClusterState clusterState) {\n    this.rules = rules;\n    for (Rule rule : rules) tagNames.add(rule.tag.name);\n    this.shardVsReplicaCount = shardVsReplicaCount;\n    this.participatingLiveNodes = new ArrayList<>(participatingLiveNodes);\n    this.nodeVsTags = getTagsForNodes(cc, snitches);\n    this.shardVsNodes = getDeepCopy(shardVsNodes, 2);\n\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        DocCollection coll = entry.getValue();\n        for (Slice slice : coll.getSlices()) {\n          for (Replica replica : slice.getReplicas()) {\n            AtomicInteger count = nodeVsCores.get(replica.getNodeName());\n            if (count == null) nodeVsCores.put(replica.getNodeName(), count = new AtomicInteger());\n            count.incrementAndGet();\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * @param shardVsReplicaCount shard names vs no:of replicas required for each of those shards\n   * @param snitches            snitches details\n   * @param shardVsNodes        The current state of the system. can be an empty map if no nodes\n   *                            are created in this collection till now\n   */\n  public ReplicaAssigner(List<Rule> rules,\n                         Map<String, Integer> shardVsReplicaCount,\n                         List snitches,\n                         Map<String, Map<String, Integer>> shardVsNodes,\n                         List<String> participatingLiveNodes,\n                         CoreContainer cc, ClusterState clusterState) {\n    this.rules = rules;\n    for (Rule rule : rules) tagNames.add(rule.tag.name);\n    this.shardVsReplicaCount = shardVsReplicaCount;\n    this.participatingLiveNodes = new ArrayList<>(participatingLiveNodes);\n    this.nodeVsTags = getTagsForNodes(cc, snitches);\n    this.shardVsNodes = getDeepCopy(shardVsNodes, 2);\n    validateTags(nodeVsTags);\n\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        DocCollection coll = entry.getValue();\n        for (Slice slice : coll.getSlices()) {\n          for (Replica replica : slice.getReplicas()) {\n            AtomicInteger count = nodeVsCores.get(replica.getNodeName());\n            if (count == null) nodeVsCores.put(replica.getNodeName(), count = new AtomicInteger());\n            count.incrementAndGet();\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6397103f7076f0b5ee4edf5b3a63c750a072ff65","date":1510231708,"type":5,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#ReplicaAssigner(List[Rule],Map[String,Integer],List,Map[String,Map[String,Integer]],List[String],SolrCloudManager,ClusterState).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#ReplicaAssigner(List[Rule],Map[String,Integer],List,Map[String,Map[String,Integer]],List[String],CoreContainer,ClusterState).mjava","sourceNew":"  /**\n   * @param shardVsReplicaCount shard names vs no:of replicas required for each of those shards\n   * @param snitches            snitches details\n   * @param shardVsNodes        The current state of the system. can be an empty map if no nodes\n   *                            are created in this collection till now\n   */\n  public ReplicaAssigner(List<Rule> rules,\n                         Map<String, Integer> shardVsReplicaCount,\n                         List snitches,\n                         Map<String, Map<String, Integer>> shardVsNodes,\n                         List<String> participatingLiveNodes,\n                         SolrCloudManager cloudManager, ClusterState clusterState) {\n    this.rules = rules;\n    for (Rule rule : rules) tagNames.add(rule.tag.name);\n    this.shardVsReplicaCount = shardVsReplicaCount;\n    this.participatingLiveNodes = new ArrayList<>(participatingLiveNodes);\n    this.nodeVsTags = getTagsForNodes(cloudManager, snitches);\n    this.shardVsNodes = getDeepCopy(shardVsNodes, 2);\n\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        DocCollection coll = entry.getValue();\n        for (Slice slice : coll.getSlices()) {\n          for (Replica replica : slice.getReplicas()) {\n            AtomicInteger count = nodeVsCores.get(replica.getNodeName());\n            if (count == null) nodeVsCores.put(replica.getNodeName(), count = new AtomicInteger());\n            count.incrementAndGet();\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * @param shardVsReplicaCount shard names vs no:of replicas required for each of those shards\n   * @param snitches            snitches details\n   * @param shardVsNodes        The current state of the system. can be an empty map if no nodes\n   *                            are created in this collection till now\n   */\n  public ReplicaAssigner(List<Rule> rules,\n                         Map<String, Integer> shardVsReplicaCount,\n                         List snitches,\n                         Map<String, Map<String, Integer>> shardVsNodes,\n                         List<String> participatingLiveNodes,\n                         CoreContainer cc, ClusterState clusterState) {\n    this.rules = rules;\n    for (Rule rule : rules) tagNames.add(rule.tag.name);\n    this.shardVsReplicaCount = shardVsReplicaCount;\n    this.participatingLiveNodes = new ArrayList<>(participatingLiveNodes);\n    this.nodeVsTags = getTagsForNodes(cc, snitches);\n    this.shardVsNodes = getDeepCopy(shardVsNodes, 2);\n\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        DocCollection coll = entry.getValue();\n        for (Slice slice : coll.getSlices()) {\n          for (Replica replica : slice.getReplicas()) {\n            AtomicInteger count = nodeVsCores.get(replica.getNodeName());\n            if (count == null) nodeVsCores.put(replica.getNodeName(), count = new AtomicInteger());\n            count.incrementAndGet();\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5aa6dcd736e5c400d1c763ae8fa2fe5aedb75132":["ec4fc24ecd353171e03bd016c1681cd97476015f"],"bf98283bf93e06ee092a158798e6a9d53bb4c747":["73450c0955930295d34703e7ddbfc6973b7a121a"],"73450c0955930295d34703e7ddbfc6973b7a121a":["5aa6dcd736e5c400d1c763ae8fa2fe5aedb75132","e9974f61802aea1d15849a1053f88f5e89fc32b4"],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":["5aa6dcd736e5c400d1c763ae8fa2fe5aedb75132","73450c0955930295d34703e7ddbfc6973b7a121a"],"6397103f7076f0b5ee4edf5b3a63c750a072ff65":["bf98283bf93e06ee092a158798e6a9d53bb4c747"],"ec4fc24ecd353171e03bd016c1681cd97476015f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":["5aa6dcd736e5c400d1c763ae8fa2fe5aedb75132","73450c0955930295d34703e7ddbfc6973b7a121a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e9974f61802aea1d15849a1053f88f5e89fc32b4":["5aa6dcd736e5c400d1c763ae8fa2fe5aedb75132"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6397103f7076f0b5ee4edf5b3a63c750a072ff65"],"491c9672ec42582fe43960452dbd37f1c80fe0f0":["7dc08f02757dd10637b16a5c65eaaef839a91a9a","bf98283bf93e06ee092a158798e6a9d53bb4c747"]},"commit2Childs":{"5aa6dcd736e5c400d1c763ae8fa2fe5aedb75132":["73450c0955930295d34703e7ddbfc6973b7a121a","7dc08f02757dd10637b16a5c65eaaef839a91a9a","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","e9974f61802aea1d15849a1053f88f5e89fc32b4"],"bf98283bf93e06ee092a158798e6a9d53bb4c747":["6397103f7076f0b5ee4edf5b3a63c750a072ff65","491c9672ec42582fe43960452dbd37f1c80fe0f0"],"73450c0955930295d34703e7ddbfc6973b7a121a":["bf98283bf93e06ee092a158798e6a9d53bb4c747","7dc08f02757dd10637b16a5c65eaaef839a91a9a","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904"],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":["491c9672ec42582fe43960452dbd37f1c80fe0f0"],"ec4fc24ecd353171e03bd016c1681cd97476015f":["5aa6dcd736e5c400d1c763ae8fa2fe5aedb75132"],"6397103f7076f0b5ee4edf5b3a63c750a072ff65":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ec4fc24ecd353171e03bd016c1681cd97476015f"],"e9974f61802aea1d15849a1053f88f5e89fc32b4":["73450c0955930295d34703e7ddbfc6973b7a121a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"491c9672ec42582fe43960452dbd37f1c80fe0f0":[]},"heads":["a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","cd5edd1f2b162a5cfa08efd17851a07373a96817","491c9672ec42582fe43960452dbd37f1c80fe0f0"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}