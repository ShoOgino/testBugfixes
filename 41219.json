{"path":"src/java/org/apache/lucene/index/DocumentsWriter.ThreadState.FieldData#rehashPostings(int).mjava","commits":[{"id":"4350b17bd363cd13a95171b8df1ca62ea4c3e71c","date":1183562198,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter.ThreadState.FieldData#rehashPostings(int).mjava","pathOld":"/dev/null","sourceNew":"      /** Called when postings hash is too small (> 50%\n       *  occupied) or too large (< 20% occupied). */\n      void rehashPostings(final int newSize) {\n\n        postingsHashMask = newSize-1;\n\n        Posting[] newHash = new Posting[newSize];\n        for(int i=0;i<postingsHashSize;i++) {\n          Posting p0 = postingsHash[i];\n          if (p0 != null) {\n            final int start = p0.textStart & CHAR_BLOCK_MASK;\n            final char[] text = charPool.buffers[p0.textStart >> CHAR_BLOCK_SHIFT];\n            int pos = start;\n            while(text[pos] != 0xffff)\n              pos++;\n            int code = 0;\n            while (pos > start)\n              code = (code*31) + text[--pos];\n\n            int hashPos = code & postingsHashMask;\n            assert hashPos >= 0;\n            if (newHash[hashPos] != null) {\n              final int inc = code*1347|1;\n              do {\n                code += inc;\n                hashPos = code & postingsHashMask;\n              } while (newHash[hashPos] != null);\n            }\n            newHash[hashPos] = p0;\n          }\n        }\n\n        postingsHash = newHash;\n        postingsHashSize = newSize;\n        postingsHashHalfSize = newSize/2;\n      }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["176324efd1eab6bd44a6d81c27c9b3a1a175ba3d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"290ddf70ef4230015d4b5ff6758c630a466d757c","date":1183739680,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter.ThreadState.FieldData#rehashPostings(int).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter.ThreadState.FieldData#rehashPostings(int).mjava","sourceNew":"      /** Called when postings hash is too small (> 50%\n       *  occupied) or too large (< 20% occupied). */\n      void rehashPostings(final int newSize) {\n\n        postingsHashMask = newSize-1;\n\n        Posting[] newHash = new Posting[newSize];\n        for(int i=0;i<postingsHashSize;i++) {\n          Posting p0 = postingsHash[i];\n          if (p0 != null) {\n            final int start = p0.textStart & CHAR_BLOCK_MASK;\n            final char[] text = charPool.buffers[p0.textStart >> CHAR_BLOCK_SHIFT];\n            int pos = start;\n            while(text[pos] != 0xffff)\n              pos++;\n            int code = 0;\n            while (pos > start)\n              code = (code*31) + text[--pos];\n\n            int hashPos = code & postingsHashMask;\n            assert hashPos >= 0;\n            if (newHash[hashPos] != null) {\n              final int inc = code*1347|1;\n              do {\n                code += inc;\n                hashPos = code & postingsHashMask;\n              } while (newHash[hashPos] != null);\n            }\n            newHash[hashPos] = p0;\n          }\n        }\n\n        postingsHash = newHash;\n        postingsHashSize = newSize;\n        postingsHashHalfSize = newSize >> 1;\n      }\n\n","sourceOld":"      /** Called when postings hash is too small (> 50%\n       *  occupied) or too large (< 20% occupied). */\n      void rehashPostings(final int newSize) {\n\n        postingsHashMask = newSize-1;\n\n        Posting[] newHash = new Posting[newSize];\n        for(int i=0;i<postingsHashSize;i++) {\n          Posting p0 = postingsHash[i];\n          if (p0 != null) {\n            final int start = p0.textStart & CHAR_BLOCK_MASK;\n            final char[] text = charPool.buffers[p0.textStart >> CHAR_BLOCK_SHIFT];\n            int pos = start;\n            while(text[pos] != 0xffff)\n              pos++;\n            int code = 0;\n            while (pos > start)\n              code = (code*31) + text[--pos];\n\n            int hashPos = code & postingsHashMask;\n            assert hashPos >= 0;\n            if (newHash[hashPos] != null) {\n              final int inc = code*1347|1;\n              do {\n                code += inc;\n                hashPos = code & postingsHashMask;\n              } while (newHash[hashPos] != null);\n            }\n            newHash[hashPos] = p0;\n          }\n        }\n\n        postingsHash = newHash;\n        postingsHashSize = newSize;\n        postingsHashHalfSize = newSize/2;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"95fcbec956d64aff326919be88d27ba5b60c046e","date":1187017143,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter.ThreadState.FieldData#rehashPostings(int).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter.ThreadState.FieldData#rehashPostings(int).mjava","sourceNew":"      /** Called when postings hash is too small (> 50%\n       *  occupied) or too large (< 20% occupied). */\n      void rehashPostings(final int newSize) {\n\n        postingsHashMask = newSize-1;\n\n        Posting[] newHash = new Posting[newSize];\n        for(int i=0;i<postingsHashSize;i++) {\n          Posting p0 = postingsHash[i];\n          if (p0 != null) {\n            final int start = p0.textStart & CHAR_BLOCK_MASK;\n            final char[] text = charPool.buffers[p0.textStart >> CHAR_BLOCK_SHIFT];\n            int pos = start;\n            while(text[pos] != 0xffff)\n              pos++;\n            int code = 0;\n            while (pos > start)\n              code = (code*31) + text[--pos];\n\n            int hashPos = code & postingsHashMask;\n            assert hashPos >= 0;\n            if (newHash[hashPos] != null) {\n              final int inc = ((code>>8)+code)|1;\n              do {\n                code += inc;\n                hashPos = code & postingsHashMask;\n              } while (newHash[hashPos] != null);\n            }\n            newHash[hashPos] = p0;\n          }\n        }\n\n        postingsHash = newHash;\n        postingsHashSize = newSize;\n        postingsHashHalfSize = newSize >> 1;\n      }\n\n","sourceOld":"      /** Called when postings hash is too small (> 50%\n       *  occupied) or too large (< 20% occupied). */\n      void rehashPostings(final int newSize) {\n\n        postingsHashMask = newSize-1;\n\n        Posting[] newHash = new Posting[newSize];\n        for(int i=0;i<postingsHashSize;i++) {\n          Posting p0 = postingsHash[i];\n          if (p0 != null) {\n            final int start = p0.textStart & CHAR_BLOCK_MASK;\n            final char[] text = charPool.buffers[p0.textStart >> CHAR_BLOCK_SHIFT];\n            int pos = start;\n            while(text[pos] != 0xffff)\n              pos++;\n            int code = 0;\n            while (pos > start)\n              code = (code*31) + text[--pos];\n\n            int hashPos = code & postingsHashMask;\n            assert hashPos >= 0;\n            if (newHash[hashPos] != null) {\n              final int inc = code*1347|1;\n              do {\n                code += inc;\n                hashPos = code & postingsHashMask;\n              } while (newHash[hashPos] != null);\n            }\n            newHash[hashPos] = p0;\n          }\n        }\n\n        postingsHash = newHash;\n        postingsHashSize = newSize;\n        postingsHashHalfSize = newSize >> 1;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"176324efd1eab6bd44a6d81c27c9b3a1a175ba3d","date":1202734547,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter.ThreadState.FieldData#rehashPostings(int).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter.ThreadState.FieldData#rehashPostings(int).mjava","sourceNew":"      /** Called when postings hash is too small (> 50%\n       *  occupied) or too large (< 20% occupied). */\n      void rehashPostings(final int newSize) {\n\n        final int newMask = newSize-1;\n\n        Posting[] newHash = new Posting[newSize];\n        for(int i=0;i<postingsHashSize;i++) {\n          Posting p0 = postingsHash[i];\n          if (p0 != null) {\n            final int start = p0.textStart & CHAR_BLOCK_MASK;\n            final char[] text = charPool.buffers[p0.textStart >> CHAR_BLOCK_SHIFT];\n            int pos = start;\n            while(text[pos] != 0xffff)\n              pos++;\n            int code = 0;\n            while (pos > start)\n              code = (code*31) + text[--pos];\n\n            int hashPos = code & newMask;\n            assert hashPos >= 0;\n            if (newHash[hashPos] != null) {\n              final int inc = ((code>>8)+code)|1;\n              do {\n                code += inc;\n                hashPos = code & newMask;\n              } while (newHash[hashPos] != null);\n            }\n            newHash[hashPos] = p0;\n          }\n        }\n\n        postingsHashMask =  newMask;\n        postingsHash = newHash;\n        postingsHashSize = newSize;\n        postingsHashHalfSize = newSize >> 1;\n      }\n\n","sourceOld":"      /** Called when postings hash is too small (> 50%\n       *  occupied) or too large (< 20% occupied). */\n      void rehashPostings(final int newSize) {\n\n        postingsHashMask = newSize-1;\n\n        Posting[] newHash = new Posting[newSize];\n        for(int i=0;i<postingsHashSize;i++) {\n          Posting p0 = postingsHash[i];\n          if (p0 != null) {\n            final int start = p0.textStart & CHAR_BLOCK_MASK;\n            final char[] text = charPool.buffers[p0.textStart >> CHAR_BLOCK_SHIFT];\n            int pos = start;\n            while(text[pos] != 0xffff)\n              pos++;\n            int code = 0;\n            while (pos > start)\n              code = (code*31) + text[--pos];\n\n            int hashPos = code & postingsHashMask;\n            assert hashPos >= 0;\n            if (newHash[hashPos] != null) {\n              final int inc = ((code>>8)+code)|1;\n              do {\n                code += inc;\n                hashPos = code & postingsHashMask;\n              } while (newHash[hashPos] != null);\n            }\n            newHash[hashPos] = p0;\n          }\n        }\n\n        postingsHash = newHash;\n        postingsHashSize = newSize;\n        postingsHashHalfSize = newSize >> 1;\n      }\n\n","bugFix":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a0af3a442be522899177e5e11384a45a6784a3f","date":1205348952,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter.ThreadState.FieldData#rehashPostings(int).mjava","sourceNew":null,"sourceOld":"      /** Called when postings hash is too small (> 50%\n       *  occupied) or too large (< 20% occupied). */\n      void rehashPostings(final int newSize) {\n\n        final int newMask = newSize-1;\n\n        Posting[] newHash = new Posting[newSize];\n        for(int i=0;i<postingsHashSize;i++) {\n          Posting p0 = postingsHash[i];\n          if (p0 != null) {\n            final int start = p0.textStart & CHAR_BLOCK_MASK;\n            final char[] text = charPool.buffers[p0.textStart >> CHAR_BLOCK_SHIFT];\n            int pos = start;\n            while(text[pos] != 0xffff)\n              pos++;\n            int code = 0;\n            while (pos > start)\n              code = (code*31) + text[--pos];\n\n            int hashPos = code & newMask;\n            assert hashPos >= 0;\n            if (newHash[hashPos] != null) {\n              final int inc = ((code>>8)+code)|1;\n              do {\n                code += inc;\n                hashPos = code & newMask;\n              } while (newHash[hashPos] != null);\n            }\n            newHash[hashPos] = p0;\n          }\n        }\n\n        postingsHashMask =  newMask;\n        postingsHash = newHash;\n        postingsHashSize = newSize;\n        postingsHashHalfSize = newSize >> 1;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"95fcbec956d64aff326919be88d27ba5b60c046e":["290ddf70ef4230015d4b5ff6758c630a466d757c"],"176324efd1eab6bd44a6d81c27c9b3a1a175ba3d":["95fcbec956d64aff326919be88d27ba5b60c046e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5a0af3a442be522899177e5e11384a45a6784a3f":["176324efd1eab6bd44a6d81c27c9b3a1a175ba3d"],"290ddf70ef4230015d4b5ff6758c630a466d757c":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c"],"4350b17bd363cd13a95171b8df1ca62ea4c3e71c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5a0af3a442be522899177e5e11384a45a6784a3f"]},"commit2Childs":{"95fcbec956d64aff326919be88d27ba5b60c046e":["176324efd1eab6bd44a6d81c27c9b3a1a175ba3d"],"176324efd1eab6bd44a6d81c27c9b3a1a175ba3d":["5a0af3a442be522899177e5e11384a45a6784a3f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c"],"290ddf70ef4230015d4b5ff6758c630a466d757c":["95fcbec956d64aff326919be88d27ba5b60c046e"],"5a0af3a442be522899177e5e11384a45a6784a3f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4350b17bd363cd13a95171b8df1ca62ea4c3e71c":["290ddf70ef4230015d4b5ff6758c630a466d757c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}