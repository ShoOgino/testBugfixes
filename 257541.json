{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.StreamRunner#run().mjava","commits":[{"id":"e81698e1493f01874d99b769bc4d9fc9f07555d6","date":1453489635,"type":0,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.StreamRunner#run().mjava","pathOld":"/dev/null","sourceNew":"    public void run() {\n      setStartTime(new Date().getTime());\n      OUTER:\n      while (!getShutdown()) {\n        long now = new Date().getTime();\n        if((now-lastRun) > this.runInterval) {\n          lastRun = now;\n          try {\n            tupleStream.open();\n            INNER:\n            while (true) {\n              Tuple tuple = tupleStream.read();\n              if (tuple.EOF) {\n                break INNER;\n              } else if (!eatTuples) {\n                try {\n                  queue.put(tuple);\n                } catch(InterruptedException e) {\n                  break OUTER;\n                }\n              }\n            }\n          } catch (IOException e) {\n            exception = e;\n            logger.error(\"Error in DaemonStream\", e);\n            break OUTER;\n          } finally {\n            try {\n              tupleStream.close();\n            } catch (IOException e1) {\n              if (exception == null) {\n                exception = e1;\n                logger.error(\"Error in DaemonStream\", e1);\n                break OUTER;\n              }\n            }\n          }\n        }\n        incrementIterations();\n        try {\n          Thread.sleep(sleepMillis);\n        } catch (InterruptedException e) {\n          logger.error(\"Error in DaemonStream\", e);\n          break OUTER;\n        }\n      }\n\n      if(!eatTuples) {\n        Map m = new HashMap();\n        m.put(\"EOF\", true);\n        Tuple tuple = new Tuple(m);\n        queue.offer(tuple);\n      }\n      setStopTime(new Date().getTime());\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["68250d9d6be79df8d09ad8f1cf87472bdc7bdb95","6bb1e55267dc3975be328fddeb53509a50d37457","a25e8cca920f4b24e3fca285ac3b85a8d7ded0ca"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a25e8cca920f4b24e3fca285ac3b85a8d7ded0ca","date":1454895732,"type":3,"author":"jbernste","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.StreamRunner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.StreamRunner#run().mjava","sourceNew":"    public void run() {\n      setStartTime(new Date().getTime());\n      OUTER:\n      while (!getShutdown()) {\n        long now = new Date().getTime();\n        if((now-lastRun) > this.runInterval) {\n          lastRun = now;\n          try {\n            tupleStream.open();\n            INNER:\n            while (true) {\n              Tuple tuple = tupleStream.read();\n              if (tuple.EOF) {\n                break INNER;\n              } else if (!eatTuples) {\n                try {\n                  queue.put(tuple);\n                } catch(InterruptedException e) {\n                  break OUTER;\n                }\n              }\n            }\n          } catch (IOException e) {\n            exception = e;\n            logger.error(\"Error in DaemonStream\", e);\n            break OUTER;\n          } finally {\n            try {\n              tupleStream.close();\n            } catch (IOException e1) {\n              if (exception == null) {\n                exception = e1;\n                logger.error(\"Error in DaemonStream\", e1);\n                break OUTER;\n              }\n            }\n          }\n        }\n        incrementIterations();\n        try {\n          Thread.sleep(sleepMillis);\n        } catch (InterruptedException e) {\n          logger.error(\"Error in DaemonStream\", e);\n          break OUTER;\n        }\n      }\n\n      if(!eatTuples) {\n        Map m = new HashMap();\n        m.put(\"EOF\", true);\n        Tuple tuple = new Tuple(m);\n        try {\n          queue.put(tuple);\n        } catch (InterruptedException e) {\n          logger.error(\"Error in DaemonStream\", e);\n        }\n      }\n      setStopTime(new Date().getTime());\n    }\n\n","sourceOld":"    public void run() {\n      setStartTime(new Date().getTime());\n      OUTER:\n      while (!getShutdown()) {\n        long now = new Date().getTime();\n        if((now-lastRun) > this.runInterval) {\n          lastRun = now;\n          try {\n            tupleStream.open();\n            INNER:\n            while (true) {\n              Tuple tuple = tupleStream.read();\n              if (tuple.EOF) {\n                break INNER;\n              } else if (!eatTuples) {\n                try {\n                  queue.put(tuple);\n                } catch(InterruptedException e) {\n                  break OUTER;\n                }\n              }\n            }\n          } catch (IOException e) {\n            exception = e;\n            logger.error(\"Error in DaemonStream\", e);\n            break OUTER;\n          } finally {\n            try {\n              tupleStream.close();\n            } catch (IOException e1) {\n              if (exception == null) {\n                exception = e1;\n                logger.error(\"Error in DaemonStream\", e1);\n                break OUTER;\n              }\n            }\n          }\n        }\n        incrementIterations();\n        try {\n          Thread.sleep(sleepMillis);\n        } catch (InterruptedException e) {\n          logger.error(\"Error in DaemonStream\", e);\n          break OUTER;\n        }\n      }\n\n      if(!eatTuples) {\n        Map m = new HashMap();\n        m.put(\"EOF\", true);\n        Tuple tuple = new Tuple(m);\n        queue.offer(tuple);\n      }\n      setStopTime(new Date().getTime());\n    }\n\n","bugFix":["e81698e1493f01874d99b769bc4d9fc9f07555d6"],"bugIntro":["68250d9d6be79df8d09ad8f1cf87472bdc7bdb95","6bb1e55267dc3975be328fddeb53509a50d37457"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"68250d9d6be79df8d09ad8f1cf87472bdc7bdb95","date":1456025710,"type":3,"author":"jbernste","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.StreamRunner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.StreamRunner#run().mjava","sourceNew":"    public void run() {\n      int errors = 0;\n      setStartTime(new Date().getTime());\n      OUTER:\n      while (!getShutdown()) {\n        long now = new Date().getTime();\n        if((now-lastRun) > this.runInterval) {\n          lastRun = now;\n          try {\n            tupleStream.open();\n            INNER:\n            while (true) {\n              Tuple tuple = tupleStream.read();\n              if (tuple.EOF) {\n                errors = 0; // Reset errors on successful run.\n                break INNER;\n              } else if (!eatTuples) {\n                try {\n                  queue.put(tuple);\n                } catch(InterruptedException e) {\n                  break OUTER;\n                }\n              }\n            }\n          } catch (IOException e) {\n            exception = e;\n            logger.error(\"Error in DaemonStream:\"+id, e);\n            ++errors;\n            if(errors > 100) {\n              logger.error(\"Too many consectutive errors. Stopping DaemonStream:\"+id);\n              break OUTER;\n            }\n          } catch (Throwable t) {\n            logger.error(\"Fatal Error in DaemonStream:\"+id, t);\n            //For anything other then IOException break out of the loop and shutdown the thread.\n            break OUTER;\n          } finally {\n            try {\n              tupleStream.close();\n            } catch (IOException e1) {\n              if (exception == null) {\n                exception = e1;\n                logger.error(\"Error in DaemonStream:\"+id, e1);\n                break OUTER;\n              }\n            }\n          }\n        }\n        incrementIterations();\n        try {\n          Thread.sleep(sleepMillis);\n        } catch (InterruptedException e) {\n          logger.error(\"Error in DaemonStream:\"+id, e);\n          break OUTER;\n        }\n      }\n\n      if(!eatTuples) {\n        Map m = new HashMap();\n        m.put(\"EOF\", true);\n        Tuple tuple = new Tuple(m);\n        try {\n          queue.put(tuple);\n        } catch (InterruptedException e) {\n          logger.error(\"Error in DaemonStream:\"+id, e);\n        }\n      }\n      setStopTime(new Date().getTime());\n    }\n\n","sourceOld":"    public void run() {\n      setStartTime(new Date().getTime());\n      OUTER:\n      while (!getShutdown()) {\n        long now = new Date().getTime();\n        if((now-lastRun) > this.runInterval) {\n          lastRun = now;\n          try {\n            tupleStream.open();\n            INNER:\n            while (true) {\n              Tuple tuple = tupleStream.read();\n              if (tuple.EOF) {\n                break INNER;\n              } else if (!eatTuples) {\n                try {\n                  queue.put(tuple);\n                } catch(InterruptedException e) {\n                  break OUTER;\n                }\n              }\n            }\n          } catch (IOException e) {\n            exception = e;\n            logger.error(\"Error in DaemonStream\", e);\n            break OUTER;\n          } finally {\n            try {\n              tupleStream.close();\n            } catch (IOException e1) {\n              if (exception == null) {\n                exception = e1;\n                logger.error(\"Error in DaemonStream\", e1);\n                break OUTER;\n              }\n            }\n          }\n        }\n        incrementIterations();\n        try {\n          Thread.sleep(sleepMillis);\n        } catch (InterruptedException e) {\n          logger.error(\"Error in DaemonStream\", e);\n          break OUTER;\n        }\n      }\n\n      if(!eatTuples) {\n        Map m = new HashMap();\n        m.put(\"EOF\", true);\n        Tuple tuple = new Tuple(m);\n        try {\n          queue.put(tuple);\n        } catch (InterruptedException e) {\n          logger.error(\"Error in DaemonStream\", e);\n        }\n      }\n      setStopTime(new Date().getTime());\n    }\n\n","bugFix":["e81698e1493f01874d99b769bc4d9fc9f07555d6","a25e8cca920f4b24e3fca285ac3b85a8d7ded0ca"],"bugIntro":["6bb1e55267dc3975be328fddeb53509a50d37457"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ab3f83fe809caa1d81a4ed52dfa5372723b348d","date":1458525918,"type":3,"author":"jbernste","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.StreamRunner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.StreamRunner#run().mjava","sourceNew":"    public void run() {\n      int errors = 0;\n      setStartTime(new Date().getTime());\n      OUTER:\n      while (!getShutdown()) {\n        long now = new Date().getTime();\n        if ((now - lastRun) > this.runInterval) {\n          lastRun = now;\n          try {\n            tupleStream.open();\n            INNER:\n            while (true) {\n              Tuple tuple = tupleStream.read();\n              if (tuple.EOF) {\n                errors = 0; // Reset errors on successful run.\n                if (tuple.fields.containsKey(\"sleepMillis\")) {\n                  this.sleepMillis = tuple.getLong(\"sleepMillis\");\n                  this.runInterval = -1;\n                }\n                break INNER;\n              } else if (!eatTuples) {\n                try {\n                  queue.put(tuple);\n                } catch (InterruptedException e) {\n                  break OUTER;\n                }\n              }\n            }\n          } catch (IOException e) {\n            e.printStackTrace();\n            exception = e;\n            logger.error(\"Error in DaemonStream:\" + id, e);\n            ++errors;\n            if (errors > 100) {\n              logger.error(\"Too many consectutive errors. Stopping DaemonStream:\" + id);\n              break OUTER;\n            }\n          } catch (Throwable t) {\n            t.printStackTrace();\n            logger.error(\"Fatal Error in DaemonStream:\" + id, t);\n            //For anything other then IOException break out of the loop and shutdown the thread.\n            break OUTER;\n          } finally {\n            try {\n              tupleStream.close();\n            } catch (IOException e1) {\n              if (exception == null) {\n                exception = e1;\n                logger.error(\"Error in DaemonStream:\" + id, e1);\n                break OUTER;\n              }\n            }\n          }\n        }\n        incrementIterations();\n\n        if (sleepMillis > 0) {\n          try {\n            Thread.sleep(sleepMillis);\n          } catch (InterruptedException e) {\n            logger.error(\"Error in DaemonStream:\" + id, e);\n            break OUTER;\n          }\n        }\n      }\n\n      if(!eatTuples) {\n        Map m = new HashMap();\n        m.put(\"EOF\", true);\n        Tuple tuple = new Tuple(m);\n        try {\n          queue.put(tuple);\n        } catch (InterruptedException e) {\n          logger.error(\"Error in DaemonStream:\"+id, e);\n        }\n      }\n      setStopTime(new Date().getTime());\n    }\n\n","sourceOld":"    public void run() {\n      int errors = 0;\n      setStartTime(new Date().getTime());\n      OUTER:\n      while (!getShutdown()) {\n        long now = new Date().getTime();\n        if((now-lastRun) > this.runInterval) {\n          lastRun = now;\n          try {\n            tupleStream.open();\n            INNER:\n            while (true) {\n              Tuple tuple = tupleStream.read();\n              if (tuple.EOF) {\n                errors = 0; // Reset errors on successful run.\n                break INNER;\n              } else if (!eatTuples) {\n                try {\n                  queue.put(tuple);\n                } catch(InterruptedException e) {\n                  break OUTER;\n                }\n              }\n            }\n          } catch (IOException e) {\n            exception = e;\n            logger.error(\"Error in DaemonStream:\"+id, e);\n            ++errors;\n            if(errors > 100) {\n              logger.error(\"Too many consectutive errors. Stopping DaemonStream:\"+id);\n              break OUTER;\n            }\n          } catch (Throwable t) {\n            logger.error(\"Fatal Error in DaemonStream:\"+id, t);\n            //For anything other then IOException break out of the loop and shutdown the thread.\n            break OUTER;\n          } finally {\n            try {\n              tupleStream.close();\n            } catch (IOException e1) {\n              if (exception == null) {\n                exception = e1;\n                logger.error(\"Error in DaemonStream:\"+id, e1);\n                break OUTER;\n              }\n            }\n          }\n        }\n        incrementIterations();\n        try {\n          Thread.sleep(sleepMillis);\n        } catch (InterruptedException e) {\n          logger.error(\"Error in DaemonStream:\"+id, e);\n          break OUTER;\n        }\n      }\n\n      if(!eatTuples) {\n        Map m = new HashMap();\n        m.put(\"EOF\", true);\n        Tuple tuple = new Tuple(m);\n        try {\n          queue.put(tuple);\n        } catch (InterruptedException e) {\n          logger.error(\"Error in DaemonStream:\"+id, e);\n        }\n      }\n      setStopTime(new Date().getTime());\n    }\n\n","bugFix":null,"bugIntro":["6bb1e55267dc3975be328fddeb53509a50d37457"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"32b02c9859f942a81e94e9de09b3816685e83a23","date":1458526778,"type":3,"author":"jbernste","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.StreamRunner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.StreamRunner#run().mjava","sourceNew":"    public void run() {\n      int errors = 0;\n      setStartTime(new Date().getTime());\n      OUTER:\n      while (!getShutdown()) {\n        long now = new Date().getTime();\n        if ((now - lastRun) > this.runInterval) {\n          lastRun = now;\n          try {\n            tupleStream.open();\n            INNER:\n            while (true) {\n              Tuple tuple = tupleStream.read();\n              if (tuple.EOF) {\n                errors = 0; // Reset errors on successful run.\n                if (tuple.fields.containsKey(\"sleepMillis\")) {\n                  this.sleepMillis = tuple.getLong(\"sleepMillis\");\n                  this.runInterval = -1;\n                }\n                break INNER;\n              } else if (!eatTuples) {\n                try {\n                  queue.put(tuple);\n                } catch (InterruptedException e) {\n                  break OUTER;\n                }\n              }\n            }\n          } catch (IOException e) {\n            exception = e;\n            logger.error(\"Error in DaemonStream:\" + id, e);\n            ++errors;\n            if (errors > 100) {\n              logger.error(\"Too many consectutive errors. Stopping DaemonStream:\" + id);\n              break OUTER;\n            }\n          } catch (Throwable t) {\n            logger.error(\"Fatal Error in DaemonStream:\" + id, t);\n            //For anything other then IOException break out of the loop and shutdown the thread.\n            break OUTER;\n          } finally {\n            try {\n              tupleStream.close();\n            } catch (IOException e1) {\n              if (exception == null) {\n                exception = e1;\n                logger.error(\"Error in DaemonStream:\" + id, e1);\n                break OUTER;\n              }\n            }\n          }\n        }\n        incrementIterations();\n\n        if (sleepMillis > 0) {\n          try {\n            Thread.sleep(sleepMillis);\n          } catch (InterruptedException e) {\n            logger.error(\"Error in DaemonStream:\" + id, e);\n            break OUTER;\n          }\n        }\n      }\n\n      if(!eatTuples) {\n        Map m = new HashMap();\n        m.put(\"EOF\", true);\n        Tuple tuple = new Tuple(m);\n        try {\n          queue.put(tuple);\n        } catch (InterruptedException e) {\n          logger.error(\"Error in DaemonStream:\"+id, e);\n        }\n      }\n      setStopTime(new Date().getTime());\n    }\n\n","sourceOld":"    public void run() {\n      int errors = 0;\n      setStartTime(new Date().getTime());\n      OUTER:\n      while (!getShutdown()) {\n        long now = new Date().getTime();\n        if ((now - lastRun) > this.runInterval) {\n          lastRun = now;\n          try {\n            tupleStream.open();\n            INNER:\n            while (true) {\n              Tuple tuple = tupleStream.read();\n              if (tuple.EOF) {\n                errors = 0; // Reset errors on successful run.\n                if (tuple.fields.containsKey(\"sleepMillis\")) {\n                  this.sleepMillis = tuple.getLong(\"sleepMillis\");\n                  this.runInterval = -1;\n                }\n                break INNER;\n              } else if (!eatTuples) {\n                try {\n                  queue.put(tuple);\n                } catch (InterruptedException e) {\n                  break OUTER;\n                }\n              }\n            }\n          } catch (IOException e) {\n            e.printStackTrace();\n            exception = e;\n            logger.error(\"Error in DaemonStream:\" + id, e);\n            ++errors;\n            if (errors > 100) {\n              logger.error(\"Too many consectutive errors. Stopping DaemonStream:\" + id);\n              break OUTER;\n            }\n          } catch (Throwable t) {\n            t.printStackTrace();\n            logger.error(\"Fatal Error in DaemonStream:\" + id, t);\n            //For anything other then IOException break out of the loop and shutdown the thread.\n            break OUTER;\n          } finally {\n            try {\n              tupleStream.close();\n            } catch (IOException e1) {\n              if (exception == null) {\n                exception = e1;\n                logger.error(\"Error in DaemonStream:\" + id, e1);\n                break OUTER;\n              }\n            }\n          }\n        }\n        incrementIterations();\n\n        if (sleepMillis > 0) {\n          try {\n            Thread.sleep(sleepMillis);\n          } catch (InterruptedException e) {\n            logger.error(\"Error in DaemonStream:\" + id, e);\n            break OUTER;\n          }\n        }\n      }\n\n      if(!eatTuples) {\n        Map m = new HashMap();\n        m.put(\"EOF\", true);\n        Tuple tuple = new Tuple(m);\n        try {\n          queue.put(tuple);\n        } catch (InterruptedException e) {\n          logger.error(\"Error in DaemonStream:\"+id, e);\n        }\n      }\n      setStopTime(new Date().getTime());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3ac1075ab5d486199f24ec3a7c07dc9b74606161","date":1476897426,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.StreamRunner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.StreamRunner#run().mjava","sourceNew":"    public void run() {\n      int errors = 0;\n      setStartTime(new Date().getTime());\n      OUTER:\n      while (!getShutdown()) {\n        long now = new Date().getTime();\n        if ((now - lastRun) > this.runInterval) {\n          lastRun = now;\n          try {\n            tupleStream.open();\n            INNER:\n            while (true) {\n              Tuple tuple = tupleStream.read();\n              if (tuple.EOF) {\n                errors = 0; // Reset errors on successful run.\n                if (tuple.fields.containsKey(\"sleepMillis\")) {\n                  this.sleepMillis = tuple.getLong(\"sleepMillis\");\n\n                  if(terminate && sleepMillis > 0) {\n                    //TopicStream provides sleepMillis > 0 if the last run had no Tuples.\n                    //This means the topic queue is empty. Time to terminate.\n                    //Remove ourselves from the daemons map.\n                    if(daemons != null) {\n                      daemons.remove(id);\n                    }\n                    //Break out of the thread loop and end the run.\n                    break OUTER;\n                  }\n\n                  this.runInterval = -1;\n                }\n                break INNER;\n              } else if (!eatTuples) {\n                try {\n                  queue.put(tuple);\n                } catch (InterruptedException e) {\n                  break OUTER;\n                }\n              }\n            }\n          } catch (IOException e) {\n            exception = e;\n            logger.error(\"Error in DaemonStream:\" + id, e);\n            ++errors;\n            if (errors > 100) {\n              logger.error(\"Too many consectutive errors. Stopping DaemonStream:\" + id);\n              break OUTER;\n            }\n          } catch (Throwable t) {\n            logger.error(\"Fatal Error in DaemonStream:\" + id, t);\n            //For anything other then IOException break out of the loop and shutdown the thread.\n            break OUTER;\n          } finally {\n            try {\n              tupleStream.close();\n            } catch (IOException e1) {\n              if (exception == null) {\n                exception = e1;\n                logger.error(\"Error in DaemonStream:\" + id, e1);\n                break OUTER;\n              }\n            }\n          }\n        }\n        incrementIterations();\n\n        if (sleepMillis > 0) {\n          try {\n            Thread.sleep(sleepMillis);\n          } catch (InterruptedException e) {\n            logger.error(\"Error in DaemonStream:\" + id, e);\n            break OUTER;\n          }\n        }\n      }\n\n      if(!eatTuples) {\n        Map m = new HashMap();\n        m.put(\"EOF\", true);\n        Tuple tuple = new Tuple(m);\n        try {\n          queue.put(tuple);\n        } catch (InterruptedException e) {\n          logger.error(\"Error in DaemonStream:\"+id, e);\n        }\n      }\n      setStopTime(new Date().getTime());\n    }\n\n","sourceOld":"    public void run() {\n      int errors = 0;\n      setStartTime(new Date().getTime());\n      OUTER:\n      while (!getShutdown()) {\n        long now = new Date().getTime();\n        if ((now - lastRun) > this.runInterval) {\n          lastRun = now;\n          try {\n            tupleStream.open();\n            INNER:\n            while (true) {\n              Tuple tuple = tupleStream.read();\n              if (tuple.EOF) {\n                errors = 0; // Reset errors on successful run.\n                if (tuple.fields.containsKey(\"sleepMillis\")) {\n                  this.sleepMillis = tuple.getLong(\"sleepMillis\");\n                  this.runInterval = -1;\n                }\n                break INNER;\n              } else if (!eatTuples) {\n                try {\n                  queue.put(tuple);\n                } catch (InterruptedException e) {\n                  break OUTER;\n                }\n              }\n            }\n          } catch (IOException e) {\n            exception = e;\n            logger.error(\"Error in DaemonStream:\" + id, e);\n            ++errors;\n            if (errors > 100) {\n              logger.error(\"Too many consectutive errors. Stopping DaemonStream:\" + id);\n              break OUTER;\n            }\n          } catch (Throwable t) {\n            logger.error(\"Fatal Error in DaemonStream:\" + id, t);\n            //For anything other then IOException break out of the loop and shutdown the thread.\n            break OUTER;\n          } finally {\n            try {\n              tupleStream.close();\n            } catch (IOException e1) {\n              if (exception == null) {\n                exception = e1;\n                logger.error(\"Error in DaemonStream:\" + id, e1);\n                break OUTER;\n              }\n            }\n          }\n        }\n        incrementIterations();\n\n        if (sleepMillis > 0) {\n          try {\n            Thread.sleep(sleepMillis);\n          } catch (InterruptedException e) {\n            logger.error(\"Error in DaemonStream:\" + id, e);\n            break OUTER;\n          }\n        }\n      }\n\n      if(!eatTuples) {\n        Map m = new HashMap();\n        m.put(\"EOF\", true);\n        Tuple tuple = new Tuple(m);\n        try {\n          queue.put(tuple);\n        } catch (InterruptedException e) {\n          logger.error(\"Error in DaemonStream:\"+id, e);\n        }\n      }\n      setStopTime(new Date().getTime());\n    }\n\n","bugFix":null,"bugIntro":["6bb1e55267dc3975be328fddeb53509a50d37457"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2305f39a86a068f1cee6fc5fbdfb760b153ac138","date":1476906991,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.StreamRunner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.StreamRunner#run().mjava","sourceNew":"    public void run() {\n      int errors = 0;\n      setStartTime(new Date().getTime());\n      OUTER:\n      while (!getShutdown()) {\n        long now = new Date().getTime();\n        if ((now - lastRun) > this.runInterval) {\n          lastRun = now;\n          try {\n            tupleStream.open();\n            INNER:\n            while (true) {\n              Tuple tuple = tupleStream.read();\n              if (tuple.EOF) {\n                errors = 0; // Reset errors on successful run.\n                if (tuple.fields.containsKey(\"sleepMillis\")) {\n                  this.sleepMillis = tuple.getLong(\"sleepMillis\");\n\n                  if(terminate && sleepMillis > 0) {\n                    //TopicStream provides sleepMillis > 0 if the last run had no Tuples.\n                    //This means the topic queue is empty. Time to terminate.\n                    //Remove ourselves from the daemons map.\n                    if(daemons != null) {\n                      daemons.remove(id);\n                    }\n                    //Break out of the thread loop and end the run.\n                    break OUTER;\n                  }\n\n                  this.runInterval = -1;\n                }\n                break INNER;\n              } else if (!eatTuples) {\n                try {\n                  queue.put(tuple);\n                } catch (InterruptedException e) {\n                  break OUTER;\n                }\n              }\n            }\n          } catch (IOException e) {\n            exception = e;\n            logger.error(\"Error in DaemonStream:\" + id, e);\n            ++errors;\n            if (errors > 100) {\n              logger.error(\"Too many consectutive errors. Stopping DaemonStream:\" + id);\n              break OUTER;\n            }\n          } catch (Throwable t) {\n            logger.error(\"Fatal Error in DaemonStream:\" + id, t);\n            //For anything other then IOException break out of the loop and shutdown the thread.\n            break OUTER;\n          } finally {\n            try {\n              tupleStream.close();\n            } catch (IOException e1) {\n              if (exception == null) {\n                exception = e1;\n                logger.error(\"Error in DaemonStream:\" + id, e1);\n                break OUTER;\n              }\n            }\n          }\n        }\n        incrementIterations();\n\n        if (sleepMillis > 0) {\n          try {\n            Thread.sleep(sleepMillis);\n          } catch (InterruptedException e) {\n            logger.error(\"Error in DaemonStream:\" + id, e);\n            break OUTER;\n          }\n        }\n      }\n\n      if(!eatTuples) {\n        Map m = new HashMap();\n        m.put(\"EOF\", true);\n        Tuple tuple = new Tuple(m);\n        try {\n          queue.put(tuple);\n        } catch (InterruptedException e) {\n          logger.error(\"Error in DaemonStream:\"+id, e);\n        }\n      }\n      setStopTime(new Date().getTime());\n    }\n\n","sourceOld":"    public void run() {\n      int errors = 0;\n      setStartTime(new Date().getTime());\n      OUTER:\n      while (!getShutdown()) {\n        long now = new Date().getTime();\n        if ((now - lastRun) > this.runInterval) {\n          lastRun = now;\n          try {\n            tupleStream.open();\n            INNER:\n            while (true) {\n              Tuple tuple = tupleStream.read();\n              if (tuple.EOF) {\n                errors = 0; // Reset errors on successful run.\n                if (tuple.fields.containsKey(\"sleepMillis\")) {\n                  this.sleepMillis = tuple.getLong(\"sleepMillis\");\n                  this.runInterval = -1;\n                }\n                break INNER;\n              } else if (!eatTuples) {\n                try {\n                  queue.put(tuple);\n                } catch (InterruptedException e) {\n                  break OUTER;\n                }\n              }\n            }\n          } catch (IOException e) {\n            exception = e;\n            logger.error(\"Error in DaemonStream:\" + id, e);\n            ++errors;\n            if (errors > 100) {\n              logger.error(\"Too many consectutive errors. Stopping DaemonStream:\" + id);\n              break OUTER;\n            }\n          } catch (Throwable t) {\n            logger.error(\"Fatal Error in DaemonStream:\" + id, t);\n            //For anything other then IOException break out of the loop and shutdown the thread.\n            break OUTER;\n          } finally {\n            try {\n              tupleStream.close();\n            } catch (IOException e1) {\n              if (exception == null) {\n                exception = e1;\n                logger.error(\"Error in DaemonStream:\" + id, e1);\n                break OUTER;\n              }\n            }\n          }\n        }\n        incrementIterations();\n\n        if (sleepMillis > 0) {\n          try {\n            Thread.sleep(sleepMillis);\n          } catch (InterruptedException e) {\n            logger.error(\"Error in DaemonStream:\" + id, e);\n            break OUTER;\n          }\n        }\n      }\n\n      if(!eatTuples) {\n        Map m = new HashMap();\n        m.put(\"EOF\", true);\n        Tuple tuple = new Tuple(m);\n        try {\n          queue.put(tuple);\n        } catch (InterruptedException e) {\n          logger.error(\"Error in DaemonStream:\"+id, e);\n        }\n      }\n      setStopTime(new Date().getTime());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.StreamRunner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.StreamRunner#run().mjava","sourceNew":"    public void run() {\n      int errors = 0;\n      setStartTime(new Date().getTime());\n      OUTER:\n      while (!getShutdown()) {\n        long now = new Date().getTime();\n        if ((now - lastRun) > this.runInterval) {\n          lastRun = now;\n          try {\n            tupleStream.open();\n            INNER:\n            while (true) {\n              Tuple tuple = tupleStream.read();\n              if (tuple.EOF) {\n                errors = 0; // Reset errors on successful run.\n                if (tuple.fields.containsKey(\"sleepMillis\")) {\n                  this.sleepMillis = tuple.getLong(\"sleepMillis\");\n\n                  if(terminate && sleepMillis > 0) {\n                    //TopicStream provides sleepMillis > 0 if the last run had no Tuples.\n                    //This means the topic queue is empty. Time to terminate.\n                    //Remove ourselves from the daemons map.\n                    if(daemons != null) {\n                      daemons.remove(id);\n                    }\n                    //Break out of the thread loop and end the run.\n                    break OUTER;\n                  }\n\n                  this.runInterval = -1;\n                }\n                break INNER;\n              } else if (!eatTuples) {\n                try {\n                  queue.put(tuple);\n                } catch (InterruptedException e) {\n                  break OUTER;\n                }\n              }\n            }\n          } catch (IOException e) {\n            exception = e;\n            logger.error(\"Error in DaemonStream:\" + id, e);\n            ++errors;\n            if (errors > 100) {\n              logger.error(\"Too many consectutive errors. Stopping DaemonStream:\" + id);\n              break OUTER;\n            }\n          } catch (Throwable t) {\n            logger.error(\"Fatal Error in DaemonStream:\" + id, t);\n            //For anything other then IOException break out of the loop and shutdown the thread.\n            break OUTER;\n          } finally {\n            try {\n              tupleStream.close();\n            } catch (IOException e1) {\n              if (exception == null) {\n                exception = e1;\n                logger.error(\"Error in DaemonStream:\" + id, e1);\n                break OUTER;\n              }\n            }\n          }\n        }\n        incrementIterations();\n\n        if (sleepMillis > 0) {\n          try {\n            Thread.sleep(sleepMillis);\n          } catch (InterruptedException e) {\n            logger.error(\"Error in DaemonStream:\" + id, e);\n            break OUTER;\n          }\n        }\n      }\n\n      if(!eatTuples) {\n        Map m = new HashMap();\n        m.put(\"EOF\", true);\n        Tuple tuple = new Tuple(m);\n        try {\n          queue.put(tuple);\n        } catch (InterruptedException e) {\n          logger.error(\"Error in DaemonStream:\"+id, e);\n        }\n      }\n      setStopTime(new Date().getTime());\n    }\n\n","sourceOld":"    public void run() {\n      int errors = 0;\n      setStartTime(new Date().getTime());\n      OUTER:\n      while (!getShutdown()) {\n        long now = new Date().getTime();\n        if ((now - lastRun) > this.runInterval) {\n          lastRun = now;\n          try {\n            tupleStream.open();\n            INNER:\n            while (true) {\n              Tuple tuple = tupleStream.read();\n              if (tuple.EOF) {\n                errors = 0; // Reset errors on successful run.\n                if (tuple.fields.containsKey(\"sleepMillis\")) {\n                  this.sleepMillis = tuple.getLong(\"sleepMillis\");\n                  this.runInterval = -1;\n                }\n                break INNER;\n              } else if (!eatTuples) {\n                try {\n                  queue.put(tuple);\n                } catch (InterruptedException e) {\n                  break OUTER;\n                }\n              }\n            }\n          } catch (IOException e) {\n            exception = e;\n            logger.error(\"Error in DaemonStream:\" + id, e);\n            ++errors;\n            if (errors > 100) {\n              logger.error(\"Too many consectutive errors. Stopping DaemonStream:\" + id);\n              break OUTER;\n            }\n          } catch (Throwable t) {\n            logger.error(\"Fatal Error in DaemonStream:\" + id, t);\n            //For anything other then IOException break out of the loop and shutdown the thread.\n            break OUTER;\n          } finally {\n            try {\n              tupleStream.close();\n            } catch (IOException e1) {\n              if (exception == null) {\n                exception = e1;\n                logger.error(\"Error in DaemonStream:\" + id, e1);\n                break OUTER;\n              }\n            }\n          }\n        }\n        incrementIterations();\n\n        if (sleepMillis > 0) {\n          try {\n            Thread.sleep(sleepMillis);\n          } catch (InterruptedException e) {\n            logger.error(\"Error in DaemonStream:\" + id, e);\n            break OUTER;\n          }\n        }\n      }\n\n      if(!eatTuples) {\n        Map m = new HashMap();\n        m.put(\"EOF\", true);\n        Tuple tuple = new Tuple(m);\n        try {\n          queue.put(tuple);\n        } catch (InterruptedException e) {\n          logger.error(\"Error in DaemonStream:\"+id, e);\n        }\n      }\n      setStopTime(new Date().getTime());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.StreamRunner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.StreamRunner#run().mjava","sourceNew":"    public void run() {\n      int errors = 0;\n      setStartTime(new Date().getTime());\n      OUTER:\n      while (!getShutdown()) {\n        long now = new Date().getTime();\n        if ((now - lastRun) > this.runInterval) {\n          lastRun = now;\n          try {\n            tupleStream.open();\n            INNER:\n            while (true) {\n              Tuple tuple = tupleStream.read();\n              if (tuple.EOF) {\n                errors = 0; // Reset errors on successful run.\n                if (tuple.fields.containsKey(\"sleepMillis\")) {\n                  this.sleepMillis = tuple.getLong(\"sleepMillis\");\n\n                  if(terminate && sleepMillis > 0) {\n                    //TopicStream provides sleepMillis > 0 if the last run had no Tuples.\n                    //This means the topic queue is empty. Time to terminate.\n                    //Remove ourselves from the daemons map.\n                    if(daemons != null) {\n                      daemons.remove(id);\n                    }\n                    //Break out of the thread loop and end the run.\n                    break OUTER;\n                  }\n\n                  this.runInterval = -1;\n                }\n                break INNER;\n              } else if (!eatTuples) {\n                try {\n                  queue.put(tuple);\n                } catch (InterruptedException e) {\n                  break OUTER;\n                }\n              }\n            }\n          } catch (IOException e) {\n            exception = e;\n            log.error(\"Error in DaemonStream:\" + id, e);\n            ++errors;\n            if (errors > 100) {\n              log.error(\"Too many consectutive errors. Stopping DaemonStream:\" + id);\n              break OUTER;\n            }\n          } catch (Throwable t) {\n            log.error(\"Fatal Error in DaemonStream:\" + id, t);\n            //For anything other then IOException break out of the loop and shutdown the thread.\n            break OUTER;\n          } finally {\n            try {\n              tupleStream.close();\n            } catch (IOException e1) {\n              if (exception == null) {\n                exception = e1;\n                log.error(\"Error in DaemonStream:\" + id, e1);\n                break OUTER;\n              }\n            }\n          }\n        }\n        incrementIterations();\n\n        if (sleepMillis > 0) {\n          try {\n            Thread.sleep(sleepMillis);\n          } catch (InterruptedException e) {\n            log.error(\"Error in DaemonStream:\" + id, e);\n            break OUTER;\n          }\n        }\n      }\n\n      if(!eatTuples) {\n        Map m = new HashMap();\n        m.put(\"EOF\", true);\n        Tuple tuple = new Tuple(m);\n        try {\n          queue.put(tuple);\n        } catch (InterruptedException e) {\n          log.error(\"Error in DaemonStream:\"+id, e);\n        }\n      }\n      setStopTime(new Date().getTime());\n    }\n\n","sourceOld":"    public void run() {\n      int errors = 0;\n      setStartTime(new Date().getTime());\n      OUTER:\n      while (!getShutdown()) {\n        long now = new Date().getTime();\n        if ((now - lastRun) > this.runInterval) {\n          lastRun = now;\n          try {\n            tupleStream.open();\n            INNER:\n            while (true) {\n              Tuple tuple = tupleStream.read();\n              if (tuple.EOF) {\n                errors = 0; // Reset errors on successful run.\n                if (tuple.fields.containsKey(\"sleepMillis\")) {\n                  this.sleepMillis = tuple.getLong(\"sleepMillis\");\n\n                  if(terminate && sleepMillis > 0) {\n                    //TopicStream provides sleepMillis > 0 if the last run had no Tuples.\n                    //This means the topic queue is empty. Time to terminate.\n                    //Remove ourselves from the daemons map.\n                    if(daemons != null) {\n                      daemons.remove(id);\n                    }\n                    //Break out of the thread loop and end the run.\n                    break OUTER;\n                  }\n\n                  this.runInterval = -1;\n                }\n                break INNER;\n              } else if (!eatTuples) {\n                try {\n                  queue.put(tuple);\n                } catch (InterruptedException e) {\n                  break OUTER;\n                }\n              }\n            }\n          } catch (IOException e) {\n            exception = e;\n            logger.error(\"Error in DaemonStream:\" + id, e);\n            ++errors;\n            if (errors > 100) {\n              logger.error(\"Too many consectutive errors. Stopping DaemonStream:\" + id);\n              break OUTER;\n            }\n          } catch (Throwable t) {\n            logger.error(\"Fatal Error in DaemonStream:\" + id, t);\n            //For anything other then IOException break out of the loop and shutdown the thread.\n            break OUTER;\n          } finally {\n            try {\n              tupleStream.close();\n            } catch (IOException e1) {\n              if (exception == null) {\n                exception = e1;\n                logger.error(\"Error in DaemonStream:\" + id, e1);\n                break OUTER;\n              }\n            }\n          }\n        }\n        incrementIterations();\n\n        if (sleepMillis > 0) {\n          try {\n            Thread.sleep(sleepMillis);\n          } catch (InterruptedException e) {\n            logger.error(\"Error in DaemonStream:\" + id, e);\n            break OUTER;\n          }\n        }\n      }\n\n      if(!eatTuples) {\n        Map m = new HashMap();\n        m.put(\"EOF\", true);\n        Tuple tuple = new Tuple(m);\n        try {\n          queue.put(tuple);\n        } catch (InterruptedException e) {\n          logger.error(\"Error in DaemonStream:\"+id, e);\n        }\n      }\n      setStopTime(new Date().getTime());\n    }\n\n","bugFix":null,"bugIntro":["6bb1e55267dc3975be328fddeb53509a50d37457"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dad6a48950aafc9c2f5dc54740f8c6ab81304203","date":1552999379,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.StreamRunner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.StreamRunner#run().mjava","sourceNew":"    public void run() {\n      int errors = 0;\n      setStartTime(new Date().getTime());\n      OUTER:\n      while (!getShutdown()) {\n        long now = new Date().getTime();\n        if ((now - lastRun) > this.runInterval) {\n          lastRun = now;\n          try {\n            tupleStream.open();\n            INNER:\n            while (true) {\n              Tuple tuple = tupleStream.read();\n              if (tuple.EOF) {\n                errors = 0; // Reset errors on successful run.\n                if (tuple.fields.containsKey(\"sleepMillis\")) {\n                  this.sleepMillis = tuple.getLong(\"sleepMillis\");\n\n                  if(terminate && sleepMillis > 0) {\n                    //TopicStream provides sleepMillis > 0 if the last run had no Tuples.\n                    //This means the topic queue is empty. Time to terminate.\n                    //Remove ourselves from the daemons map.\n                    if(daemons != null) {\n                      daemons.remove(id);\n                    }\n                    //Break out of the thread loop and end the run.\n                    break OUTER;\n                  }\n\n                  this.runInterval = -1;\n                }\n                break INNER;\n              } else if (!eatTuples) {\n                try {\n                  queue.put(tuple);\n                } catch (InterruptedException e) {\n                  break OUTER;\n                }\n              }\n            }\n          } catch (IOException e) {\n            exception = e;\n            log.error(\"Error in DaemonStream:\" + id, e);\n            ++errors;\n            if (errors > 100) {\n              log.error(\"Too many consecutive errors. Stopping DaemonStream:\" + id);\n              break OUTER;\n            }\n          } catch (Throwable t) {\n            log.error(\"Fatal Error in DaemonStream:\" + id, t);\n            //For anything other then IOException break out of the loop and shutdown the thread.\n            break OUTER;\n          } finally {\n            try {\n              tupleStream.close();\n            } catch (IOException e1) {\n              if (exception == null) {\n                exception = e1;\n                log.error(\"Error in DaemonStream:\" + id, e1);\n                break OUTER;\n              }\n            }\n          }\n        }\n        iterations.incrementAndGet();\n\n        if (sleepMillis > 0) {\n          try {\n            Thread.sleep(sleepMillis);\n          } catch (InterruptedException e) {\n            log.error(\"Error in DaemonStream:\" + id, e);\n            break OUTER;\n          }\n        }\n      }\n\n      if(!eatTuples) {\n        Map m = new HashMap();\n        m.put(\"EOF\", true);\n        Tuple tuple = new Tuple(m);\n        try {\n          queue.put(tuple);\n        } catch (InterruptedException e) {\n          log.error(\"Error in DaemonStream:\"+id, e);\n        }\n      }\n      setStopTime(new Date().getTime());\n    }\n\n","sourceOld":"    public void run() {\n      int errors = 0;\n      setStartTime(new Date().getTime());\n      OUTER:\n      while (!getShutdown()) {\n        long now = new Date().getTime();\n        if ((now - lastRun) > this.runInterval) {\n          lastRun = now;\n          try {\n            tupleStream.open();\n            INNER:\n            while (true) {\n              Tuple tuple = tupleStream.read();\n              if (tuple.EOF) {\n                errors = 0; // Reset errors on successful run.\n                if (tuple.fields.containsKey(\"sleepMillis\")) {\n                  this.sleepMillis = tuple.getLong(\"sleepMillis\");\n\n                  if(terminate && sleepMillis > 0) {\n                    //TopicStream provides sleepMillis > 0 if the last run had no Tuples.\n                    //This means the topic queue is empty. Time to terminate.\n                    //Remove ourselves from the daemons map.\n                    if(daemons != null) {\n                      daemons.remove(id);\n                    }\n                    //Break out of the thread loop and end the run.\n                    break OUTER;\n                  }\n\n                  this.runInterval = -1;\n                }\n                break INNER;\n              } else if (!eatTuples) {\n                try {\n                  queue.put(tuple);\n                } catch (InterruptedException e) {\n                  break OUTER;\n                }\n              }\n            }\n          } catch (IOException e) {\n            exception = e;\n            log.error(\"Error in DaemonStream:\" + id, e);\n            ++errors;\n            if (errors > 100) {\n              log.error(\"Too many consectutive errors. Stopping DaemonStream:\" + id);\n              break OUTER;\n            }\n          } catch (Throwable t) {\n            log.error(\"Fatal Error in DaemonStream:\" + id, t);\n            //For anything other then IOException break out of the loop and shutdown the thread.\n            break OUTER;\n          } finally {\n            try {\n              tupleStream.close();\n            } catch (IOException e1) {\n              if (exception == null) {\n                exception = e1;\n                log.error(\"Error in DaemonStream:\" + id, e1);\n                break OUTER;\n              }\n            }\n          }\n        }\n        incrementIterations();\n\n        if (sleepMillis > 0) {\n          try {\n            Thread.sleep(sleepMillis);\n          } catch (InterruptedException e) {\n            log.error(\"Error in DaemonStream:\" + id, e);\n            break OUTER;\n          }\n        }\n      }\n\n      if(!eatTuples) {\n        Map m = new HashMap();\n        m.put(\"EOF\", true);\n        Tuple tuple = new Tuple(m);\n        try {\n          queue.put(tuple);\n        } catch (InterruptedException e) {\n          log.error(\"Error in DaemonStream:\"+id, e);\n        }\n      }\n      setStopTime(new Date().getTime());\n    }\n\n","bugFix":null,"bugIntro":["6bb1e55267dc3975be328fddeb53509a50d37457"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6bb1e55267dc3975be328fddeb53509a50d37457","date":1561474467,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.StreamRunner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.StreamRunner#run().mjava","sourceNew":"    public void run() {\n      executingThread = Thread.currentThread();\n      try {\n        stream();\n      } finally {\n        setShutdown(true);\n        executingThread = null;\n      }\n    }\n\n","sourceOld":"    public void run() {\n      int errors = 0;\n      setStartTime(new Date().getTime());\n      OUTER:\n      while (!getShutdown()) {\n        long now = new Date().getTime();\n        if ((now - lastRun) > this.runInterval) {\n          lastRun = now;\n          try {\n            tupleStream.open();\n            INNER:\n            while (true) {\n              Tuple tuple = tupleStream.read();\n              if (tuple.EOF) {\n                errors = 0; // Reset errors on successful run.\n                if (tuple.fields.containsKey(\"sleepMillis\")) {\n                  this.sleepMillis = tuple.getLong(\"sleepMillis\");\n\n                  if(terminate && sleepMillis > 0) {\n                    //TopicStream provides sleepMillis > 0 if the last run had no Tuples.\n                    //This means the topic queue is empty. Time to terminate.\n                    //Remove ourselves from the daemons map.\n                    if(daemons != null) {\n                      daemons.remove(id);\n                    }\n                    //Break out of the thread loop and end the run.\n                    break OUTER;\n                  }\n\n                  this.runInterval = -1;\n                }\n                break INNER;\n              } else if (!eatTuples) {\n                try {\n                  queue.put(tuple);\n                } catch (InterruptedException e) {\n                  break OUTER;\n                }\n              }\n            }\n          } catch (IOException e) {\n            exception = e;\n            log.error(\"Error in DaemonStream:\" + id, e);\n            ++errors;\n            if (errors > 100) {\n              log.error(\"Too many consecutive errors. Stopping DaemonStream:\" + id);\n              break OUTER;\n            }\n          } catch (Throwable t) {\n            log.error(\"Fatal Error in DaemonStream:\" + id, t);\n            //For anything other then IOException break out of the loop and shutdown the thread.\n            break OUTER;\n          } finally {\n            try {\n              tupleStream.close();\n            } catch (IOException e1) {\n              if (exception == null) {\n                exception = e1;\n                log.error(\"Error in DaemonStream:\" + id, e1);\n                break OUTER;\n              }\n            }\n          }\n        }\n        iterations.incrementAndGet();\n\n        if (sleepMillis > 0) {\n          try {\n            Thread.sleep(sleepMillis);\n          } catch (InterruptedException e) {\n            log.error(\"Error in DaemonStream:\" + id, e);\n            break OUTER;\n          }\n        }\n      }\n\n      if(!eatTuples) {\n        Map m = new HashMap();\n        m.put(\"EOF\", true);\n        Tuple tuple = new Tuple(m);\n        try {\n          queue.put(tuple);\n        } catch (InterruptedException e) {\n          log.error(\"Error in DaemonStream:\"+id, e);\n        }\n      }\n      setStopTime(new Date().getTime());\n    }\n\n","bugFix":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","dad6a48950aafc9c2f5dc54740f8c6ab81304203","e81698e1493f01874d99b769bc4d9fc9f07555d6","5ab3f83fe809caa1d81a4ed52dfa5372723b348d","a25e8cca920f4b24e3fca285ac3b85a8d7ded0ca","3ac1075ab5d486199f24ec3a7c07dc9b74606161","68250d9d6be79df8d09ad8f1cf87472bdc7bdb95"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"68250d9d6be79df8d09ad8f1cf87472bdc7bdb95":["a25e8cca920f4b24e3fca285ac3b85a8d7ded0ca"],"6bb1e55267dc3975be328fddeb53509a50d37457":["dad6a48950aafc9c2f5dc54740f8c6ab81304203"],"dad6a48950aafc9c2f5dc54740f8c6ab81304203":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"e81698e1493f01874d99b769bc4d9fc9f07555d6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3ac1075ab5d486199f24ec3a7c07dc9b74606161":["32b02c9859f942a81e94e9de09b3816685e83a23"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["32b02c9859f942a81e94e9de09b3816685e83a23","2305f39a86a068f1cee6fc5fbdfb760b153ac138"],"2305f39a86a068f1cee6fc5fbdfb760b153ac138":["32b02c9859f942a81e94e9de09b3816685e83a23","3ac1075ab5d486199f24ec3a7c07dc9b74606161"],"a25e8cca920f4b24e3fca285ac3b85a8d7ded0ca":["e81698e1493f01874d99b769bc4d9fc9f07555d6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5ab3f83fe809caa1d81a4ed52dfa5372723b348d":["68250d9d6be79df8d09ad8f1cf87472bdc7bdb95"],"32b02c9859f942a81e94e9de09b3816685e83a23":["5ab3f83fe809caa1d81a4ed52dfa5372723b348d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6bb1e55267dc3975be328fddeb53509a50d37457"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["2305f39a86a068f1cee6fc5fbdfb760b153ac138"]},"commit2Childs":{"68250d9d6be79df8d09ad8f1cf87472bdc7bdb95":["5ab3f83fe809caa1d81a4ed52dfa5372723b348d"],"6bb1e55267dc3975be328fddeb53509a50d37457":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"dad6a48950aafc9c2f5dc54740f8c6ab81304203":["6bb1e55267dc3975be328fddeb53509a50d37457"],"e81698e1493f01874d99b769bc4d9fc9f07555d6":["a25e8cca920f4b24e3fca285ac3b85a8d7ded0ca"],"3ac1075ab5d486199f24ec3a7c07dc9b74606161":["2305f39a86a068f1cee6fc5fbdfb760b153ac138"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"2305f39a86a068f1cee6fc5fbdfb760b153ac138":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"a25e8cca920f4b24e3fca285ac3b85a8d7ded0ca":["68250d9d6be79df8d09ad8f1cf87472bdc7bdb95"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e81698e1493f01874d99b769bc4d9fc9f07555d6"],"5ab3f83fe809caa1d81a4ed52dfa5372723b348d":["32b02c9859f942a81e94e9de09b3816685e83a23"],"32b02c9859f942a81e94e9de09b3816685e83a23":["3ac1075ab5d486199f24ec3a7c07dc9b74606161","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","2305f39a86a068f1cee6fc5fbdfb760b153ac138"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["dad6a48950aafc9c2f5dc54740f8c6ab81304203"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}