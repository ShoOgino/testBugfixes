{"path":"lucene/sandbox/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","commits":[{"id":"05f4c28bc6a6df30868753f35eb802cbff28ce5c","date":1469068146,"type":0,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n      final RangeFieldComparator comparator = new RangeFieldComparator();\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        values.intersect(field,\n            new IntersectVisitor() {\n              DocIdSetBuilder.BulkAdder adder;\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n              @Override\n              public void visit(int docID) throws IOException {\n                adder.add(docID);\n              }\n              @Override\n              public void visit(int docID, byte[] leaf) throws IOException {\n                // add the document iff:\n                if (// target is within cell and queryType is INTERSECTS or CONTAINS:\n                    (comparator.isWithin(leaf) && queryType != QueryType.WITHIN)\n                    // target contains cell and queryType is INTERSECTS or WITHIN:\n                    || (comparator.contains(leaf) && queryType != QueryType.CONTAINS)\n                    // target is not disjoint (crosses) and queryType is INTERSECTS\n                    || (comparator.isDisjoint(leaf) == false && queryType == QueryType.INTERSECTS)) {\n                  adder.add(docID);\n                }\n              }\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                byte[] node = getInternalRange(minPackedValue, maxPackedValue);\n                // compute range relation for BKD traversal\n                if (comparator.isDisjoint(node)) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (comparator.contains(node)) {\n                  // target contains cell; add iff queryType is not a CONTAINS query:\n                  return (queryType == QueryType.CONTAINS) ? Relation.CELL_OUTSIDE_QUERY : Relation.CELL_INSIDE_QUERY;\n                } else if (comparator.isWithin(node)) {\n                  // target within cell; continue traversing:\n                  return Relation.CELL_CROSSES_QUERY;\n                }\n                // target intersects cell; continue traversing:\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = true;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          // if query crosses, docs need to be further scrutinized\n          byte[] range = getInternalRange(values.getMinPackedValue(field), values.getMaxPackedValue(field));\n          // if the internal node is not contained by the query, all docs do not match\n          if (((comparator.contains(range) && queryType == QueryType.CONTAINS)) == false) {\n            allDocsMatch = false;\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator = allDocsMatch == true ?\n            DocIdSetIterator.all(reader.maxDoc()) : buildMatchingDocIdSet(reader, values).iterator();\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      /** get an encoded byte representation of the internal node; this is\n       *  the lower half of the min array and the upper half of the max array */\n      private byte[] getInternalRange(byte[] min, byte[] max) {\n        byte[] range = new byte[min.length];\n        final int dimSize = numDims * bytesPerDim;\n        System.arraycopy(min, 0, range, 0, dimSize);\n        System.arraycopy(max, dimSize, range, dimSize, dimSize);\n        return range;\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["91e78d339fc63f8487cc36dbc676582553f5e622"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3c738d774d160362ecfdc9887a5fa4beb421872b","date":1469112991,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n      final RangeFieldComparator comparator = new RangeFieldComparator();\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        values.intersect(field,\n            new IntersectVisitor() {\n              DocIdSetBuilder.BulkAdder adder;\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n              @Override\n              public void visit(int docID) throws IOException {\n                adder.add(docID);\n              }\n              @Override\n              public void visit(int docID, byte[] leaf) throws IOException {\n                // add the document iff:\n                if (// target is within cell and queryType is INTERSECTS or CONTAINS:\n                    (comparator.isWithin(leaf) && queryType != QueryType.WITHIN)\n                    // target contains cell and queryType is INTERSECTS or WITHIN:\n                    || (comparator.contains(leaf) && queryType != QueryType.CONTAINS)\n                    // target is not disjoint (crosses) and queryType is INTERSECTS\n                    || (comparator.isDisjoint(leaf) == false && queryType == QueryType.INTERSECTS)) {\n                  adder.add(docID);\n                }\n              }\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                byte[] node = getInternalRange(minPackedValue, maxPackedValue);\n                // compute range relation for BKD traversal\n                if (comparator.isDisjoint(node)) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (comparator.contains(node)) {\n                  // target contains cell; add iff queryType is not a CONTAINS query:\n                  return (queryType == QueryType.CONTAINS) ? Relation.CELL_OUTSIDE_QUERY : Relation.CELL_INSIDE_QUERY;\n                } else if (comparator.isWithin(node)) {\n                  // target within cell; continue traversing:\n                  return Relation.CELL_CROSSES_QUERY;\n                }\n                // target intersects cell; continue traversing:\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = true;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          // if query crosses, docs need to be further scrutinized\n          byte[] range = getInternalRange(values.getMinPackedValue(field), values.getMaxPackedValue(field));\n          // if the internal node is not contained by the query, all docs do not match\n          if (((comparator.contains(range) && queryType == QueryType.CONTAINS)) == false) {\n            allDocsMatch = false;\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator = allDocsMatch == true ?\n            DocIdSetIterator.all(reader.maxDoc()) : buildMatchingDocIdSet(reader, values).iterator();\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      /** get an encoded byte representation of the internal node; this is\n       *  the lower half of the min array and the upper half of the max array */\n      private byte[] getInternalRange(byte[] min, byte[] max) {\n        byte[] range = new byte[min.length];\n        final int dimSize = numDims * bytesPerDim;\n        System.arraycopy(min, 0, range, 0, dimSize);\n        System.arraycopy(max, dimSize, range, dimSize, dimSize);\n        return range;\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4e6bfc2c1eac33d890bf4d5638c8e149e1dcbcca","date":1469204477,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n      final RangeFieldComparator comparator = new RangeFieldComparator();\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        values.intersect(field,\n            new IntersectVisitor() {\n              DocIdSetBuilder.BulkAdder adder;\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n              @Override\n              public void visit(int docID) throws IOException {\n                adder.add(docID);\n              }\n              @Override\n              public void visit(int docID, byte[] leaf) throws IOException {\n                // add the document iff:\n                if (Arrays.equals(ranges, leaf)\n                    // target is within cell and queryType is INTERSECTS or CONTAINS:\n                    || (comparator.isWithin(leaf) && queryType != QueryType.WITHIN)\n                    // target contains cell and queryType is INTERSECTS or WITHIN:\n                    || (comparator.contains(leaf) && queryType != QueryType.CONTAINS)\n                    // target is not disjoint (crosses) and queryType is INTERSECTS\n                    || (comparator.isDisjoint(leaf) == false && queryType == QueryType.INTERSECTS)) {\n                  adder.add(docID);\n                }\n              }\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                byte[] node = getInternalRange(minPackedValue, maxPackedValue);\n                // compute range relation for BKD traversal\n                if (comparator.isDisjoint(node)) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (comparator.isWithin(node)) {\n                  // target within cell; continue traversing:\n                  return Relation.CELL_CROSSES_QUERY;\n                } else if (comparator.contains(node)) {\n                  // target contains cell; add iff queryType is not a CONTAINS query:\n                  return (queryType == QueryType.CONTAINS) ? Relation.CELL_OUTSIDE_QUERY : Relation.CELL_INSIDE_QUERY;\n                }\n                // target intersects cell; continue traversing:\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = true;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          // if query crosses, docs need to be further scrutinized\n          byte[] range = getInternalRange(values.getMinPackedValue(field), values.getMaxPackedValue(field));\n          // if the internal node is not equal and not contained by the query, all docs do not match\n          if ((!Arrays.equals(ranges, range)\n              && (comparator.contains(range) && queryType != QueryType.CONTAINS)) == false) {\n            allDocsMatch = false;\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator = allDocsMatch == true ?\n            DocIdSetIterator.all(reader.maxDoc()) : buildMatchingDocIdSet(reader, values).iterator();\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      /** get an encoded byte representation of the internal node; this is\n       *  the lower half of the min array and the upper half of the max array */\n      private byte[] getInternalRange(byte[] min, byte[] max) {\n        byte[] range = new byte[min.length];\n        final int dimSize = numDims * bytesPerDim;\n        System.arraycopy(min, 0, range, 0, dimSize);\n        System.arraycopy(max, dimSize, range, dimSize, dimSize);\n        return range;\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n      final RangeFieldComparator comparator = new RangeFieldComparator();\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        values.intersect(field,\n            new IntersectVisitor() {\n              DocIdSetBuilder.BulkAdder adder;\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n              @Override\n              public void visit(int docID) throws IOException {\n                adder.add(docID);\n              }\n              @Override\n              public void visit(int docID, byte[] leaf) throws IOException {\n                // add the document iff:\n                if (// target is within cell and queryType is INTERSECTS or CONTAINS:\n                    (comparator.isWithin(leaf) && queryType != QueryType.WITHIN)\n                    // target contains cell and queryType is INTERSECTS or WITHIN:\n                    || (comparator.contains(leaf) && queryType != QueryType.CONTAINS)\n                    // target is not disjoint (crosses) and queryType is INTERSECTS\n                    || (comparator.isDisjoint(leaf) == false && queryType == QueryType.INTERSECTS)) {\n                  adder.add(docID);\n                }\n              }\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                byte[] node = getInternalRange(minPackedValue, maxPackedValue);\n                // compute range relation for BKD traversal\n                if (comparator.isDisjoint(node)) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (comparator.contains(node)) {\n                  // target contains cell; add iff queryType is not a CONTAINS query:\n                  return (queryType == QueryType.CONTAINS) ? Relation.CELL_OUTSIDE_QUERY : Relation.CELL_INSIDE_QUERY;\n                } else if (comparator.isWithin(node)) {\n                  // target within cell; continue traversing:\n                  return Relation.CELL_CROSSES_QUERY;\n                }\n                // target intersects cell; continue traversing:\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = true;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          // if query crosses, docs need to be further scrutinized\n          byte[] range = getInternalRange(values.getMinPackedValue(field), values.getMaxPackedValue(field));\n          // if the internal node is not contained by the query, all docs do not match\n          if (((comparator.contains(range) && queryType == QueryType.CONTAINS)) == false) {\n            allDocsMatch = false;\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator = allDocsMatch == true ?\n            DocIdSetIterator.all(reader.maxDoc()) : buildMatchingDocIdSet(reader, values).iterator();\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      /** get an encoded byte representation of the internal node; this is\n       *  the lower half of the min array and the upper half of the max array */\n      private byte[] getInternalRange(byte[] min, byte[] max) {\n        byte[] range = new byte[min.length];\n        final int dimSize = numDims * bytesPerDim;\n        System.arraycopy(min, 0, range, 0, dimSize);\n        System.arraycopy(max, dimSize, range, dimSize, dimSize);\n        return range;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["91e78d339fc63f8487cc36dbc676582553f5e622"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"367f57e2ee85b7f7e28cfe73370a22cf67624f65","date":1476778467,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n      final RangeFieldComparator comparator = new RangeFieldComparator();\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        values.intersect(\n            new IntersectVisitor() {\n              DocIdSetBuilder.BulkAdder adder;\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n              @Override\n              public void visit(int docID) throws IOException {\n                adder.add(docID);\n              }\n              @Override\n              public void visit(int docID, byte[] leaf) throws IOException {\n                // add the document iff:\n                if (Arrays.equals(ranges, leaf)\n                    // target is within cell and queryType is INTERSECTS or CONTAINS:\n                    || (comparator.isWithin(leaf) && queryType != QueryType.WITHIN)\n                    // target contains cell and queryType is INTERSECTS or WITHIN:\n                    || (comparator.contains(leaf) && queryType != QueryType.CONTAINS)\n                    // target is not disjoint (crosses) and queryType is INTERSECTS\n                    || (comparator.isDisjoint(leaf) == false && queryType == QueryType.INTERSECTS)) {\n                  adder.add(docID);\n                }\n              }\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                byte[] node = getInternalRange(minPackedValue, maxPackedValue);\n                // compute range relation for BKD traversal\n                if (comparator.isDisjoint(node)) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (comparator.isWithin(node)) {\n                  // target within cell; continue traversing:\n                  return Relation.CELL_CROSSES_QUERY;\n                } else if (comparator.contains(node)) {\n                  // target contains cell; add iff queryType is not a CONTAINS query:\n                  return (queryType == QueryType.CONTAINS) ? Relation.CELL_OUTSIDE_QUERY : Relation.CELL_INSIDE_QUERY;\n                }\n                // target intersects cell; continue traversing:\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = true;\n        if (values.getDocCount() == reader.maxDoc()) {\n          // if query crosses, docs need to be further scrutinized\n          byte[] range = getInternalRange(values.getMinPackedValue(), values.getMaxPackedValue());\n          // if the internal node is not equal and not contained by the query, all docs do not match\n          if ((!Arrays.equals(ranges, range)\n              && (comparator.contains(range) && queryType != QueryType.CONTAINS)) == false) {\n            allDocsMatch = false;\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator = allDocsMatch == true ?\n            DocIdSetIterator.all(reader.maxDoc()) : buildMatchingDocIdSet(reader, values).iterator();\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      /** get an encoded byte representation of the internal node; this is\n       *  the lower half of the min array and the upper half of the max array */\n      private byte[] getInternalRange(byte[] min, byte[] max) {\n        byte[] range = new byte[min.length];\n        final int dimSize = numDims * bytesPerDim;\n        System.arraycopy(min, 0, range, 0, dimSize);\n        System.arraycopy(max, dimSize, range, dimSize, dimSize);\n        return range;\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n      final RangeFieldComparator comparator = new RangeFieldComparator();\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        values.intersect(field,\n            new IntersectVisitor() {\n              DocIdSetBuilder.BulkAdder adder;\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n              @Override\n              public void visit(int docID) throws IOException {\n                adder.add(docID);\n              }\n              @Override\n              public void visit(int docID, byte[] leaf) throws IOException {\n                // add the document iff:\n                if (Arrays.equals(ranges, leaf)\n                    // target is within cell and queryType is INTERSECTS or CONTAINS:\n                    || (comparator.isWithin(leaf) && queryType != QueryType.WITHIN)\n                    // target contains cell and queryType is INTERSECTS or WITHIN:\n                    || (comparator.contains(leaf) && queryType != QueryType.CONTAINS)\n                    // target is not disjoint (crosses) and queryType is INTERSECTS\n                    || (comparator.isDisjoint(leaf) == false && queryType == QueryType.INTERSECTS)) {\n                  adder.add(docID);\n                }\n              }\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                byte[] node = getInternalRange(minPackedValue, maxPackedValue);\n                // compute range relation for BKD traversal\n                if (comparator.isDisjoint(node)) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (comparator.isWithin(node)) {\n                  // target within cell; continue traversing:\n                  return Relation.CELL_CROSSES_QUERY;\n                } else if (comparator.contains(node)) {\n                  // target contains cell; add iff queryType is not a CONTAINS query:\n                  return (queryType == QueryType.CONTAINS) ? Relation.CELL_OUTSIDE_QUERY : Relation.CELL_INSIDE_QUERY;\n                }\n                // target intersects cell; continue traversing:\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = true;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          // if query crosses, docs need to be further scrutinized\n          byte[] range = getInternalRange(values.getMinPackedValue(field), values.getMaxPackedValue(field));\n          // if the internal node is not equal and not contained by the query, all docs do not match\n          if ((!Arrays.equals(ranges, range)\n              && (comparator.contains(range) && queryType != QueryType.CONTAINS)) == false) {\n            allDocsMatch = false;\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator = allDocsMatch == true ?\n            DocIdSetIterator.all(reader.maxDoc()) : buildMatchingDocIdSet(reader, values).iterator();\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      /** get an encoded byte representation of the internal node; this is\n       *  the lower half of the min array and the upper half of the max array */\n      private byte[] getInternalRange(byte[] min, byte[] max) {\n        byte[] range = new byte[min.length];\n        final int dimSize = numDims * bytesPerDim;\n        System.arraycopy(min, 0, range, 0, dimSize);\n        System.arraycopy(max, dimSize, range, dimSize, dimSize);\n        return range;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["91e78d339fc63f8487cc36dbc676582553f5e622"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n      final RangeFieldComparator comparator = new RangeFieldComparator();\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        values.intersect(\n            new IntersectVisitor() {\n              DocIdSetBuilder.BulkAdder adder;\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n              @Override\n              public void visit(int docID) throws IOException {\n                adder.add(docID);\n              }\n              @Override\n              public void visit(int docID, byte[] leaf) throws IOException {\n                // add the document iff:\n                if (Arrays.equals(ranges, leaf)\n                    // target is within cell and queryType is INTERSECTS or CONTAINS:\n                    || (comparator.isWithin(leaf) && queryType != QueryType.WITHIN)\n                    // target contains cell and queryType is INTERSECTS or WITHIN:\n                    || (comparator.contains(leaf) && queryType != QueryType.CONTAINS)\n                    // target is not disjoint (crosses) and queryType is INTERSECTS\n                    || (comparator.isDisjoint(leaf) == false && queryType == QueryType.INTERSECTS)) {\n                  adder.add(docID);\n                }\n              }\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                byte[] node = getInternalRange(minPackedValue, maxPackedValue);\n                // compute range relation for BKD traversal\n                if (comparator.isDisjoint(node)) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (comparator.isWithin(node)) {\n                  // target within cell; continue traversing:\n                  return Relation.CELL_CROSSES_QUERY;\n                } else if (comparator.contains(node)) {\n                  // target contains cell; add iff queryType is not a CONTAINS query:\n                  return (queryType == QueryType.CONTAINS) ? Relation.CELL_OUTSIDE_QUERY : Relation.CELL_INSIDE_QUERY;\n                }\n                // target intersects cell; continue traversing:\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = true;\n        if (values.getDocCount() == reader.maxDoc()) {\n          // if query crosses, docs need to be further scrutinized\n          byte[] range = getInternalRange(values.getMinPackedValue(), values.getMaxPackedValue());\n          // if the internal node is not equal and not contained by the query, all docs do not match\n          if ((!Arrays.equals(ranges, range)\n              && (comparator.contains(range) && queryType != QueryType.CONTAINS)) == false) {\n            allDocsMatch = false;\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator = allDocsMatch == true ?\n            DocIdSetIterator.all(reader.maxDoc()) : buildMatchingDocIdSet(reader, values).iterator();\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      /** get an encoded byte representation of the internal node; this is\n       *  the lower half of the min array and the upper half of the max array */\n      private byte[] getInternalRange(byte[] min, byte[] max) {\n        byte[] range = new byte[min.length];\n        final int dimSize = numDims * bytesPerDim;\n        System.arraycopy(min, 0, range, 0, dimSize);\n        System.arraycopy(max, dimSize, range, dimSize, dimSize);\n        return range;\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6939810fba802f65f77bcc41069354917202d36f","date":1481663226,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n      final RangeFieldComparator comparator = new RangeFieldComparator();\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        values.intersect(\n            new IntersectVisitor() {\n              DocIdSetBuilder.BulkAdder adder;\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n              @Override\n              public void visit(int docID) throws IOException {\n                adder.add(docID);\n              }\n              @Override\n              public void visit(int docID, byte[] leaf) throws IOException {\n                // add the document iff:\n                if (Arrays.equals(ranges, leaf)\n                    // target is within cell and queryType is INTERSECTS or CONTAINS:\n                    || (comparator.isWithin(leaf) && queryType != QueryType.WITHIN)\n                    // target contains cell and queryType is INTERSECTS or WITHIN:\n                    || (comparator.contains(leaf) && queryType != QueryType.CONTAINS)\n                    // target is not disjoint (crosses) and queryType is INTERSECTS\n                    || (comparator.isDisjoint(leaf) == false && queryType == QueryType.INTERSECTS)) {\n                  adder.add(docID);\n                }\n              }\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                byte[] node = getInternalRange(minPackedValue, maxPackedValue);\n                // compute range relation for BKD traversal\n                if (comparator.isDisjoint(node)) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (comparator.isWithin(node)) {\n                  // target within cell; continue traversing:\n                  return Relation.CELL_CROSSES_QUERY;\n                } else if (comparator.contains(node)) {\n                  // target contains cell; add iff queryType is not a CONTAINS query:\n                  return (queryType == QueryType.CONTAINS) ? Relation.CELL_OUTSIDE_QUERY : Relation.CELL_INSIDE_QUERY;\n                }\n                // target intersects cell; continue traversing:\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = true;\n        if (values.getDocCount() == reader.maxDoc()) {\n          // if query crosses, docs need to be further scrutinized\n          byte[] range = getInternalRange(values.getMinPackedValue(), values.getMaxPackedValue());\n          // if the internal node is not equal and not contained by the query, all docs do not match\n          if ((!Arrays.equals(ranges, range)\n              && (comparator.contains(range) && queryType != QueryType.CONTAINS)) == false) {\n            allDocsMatch = false;\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator = allDocsMatch == true ?\n            DocIdSetIterator.all(reader.maxDoc()) : buildMatchingDocIdSet(reader, values).iterator();\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      /** get an encoded byte representation of the internal node; this is\n       *  the lower half of the min array and the upper half of the max array */\n      private byte[] getInternalRange(byte[] min, byte[] max) {\n        byte[] range = new byte[min.length];\n        final int dimSize = numDims * bytesPerDim;\n        System.arraycopy(min, 0, range, 0, dimSize);\n        System.arraycopy(max, dimSize, range, dimSize, dimSize);\n        return range;\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n      final RangeFieldComparator comparator = new RangeFieldComparator();\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        values.intersect(\n            new IntersectVisitor() {\n              DocIdSetBuilder.BulkAdder adder;\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n              @Override\n              public void visit(int docID) throws IOException {\n                adder.add(docID);\n              }\n              @Override\n              public void visit(int docID, byte[] leaf) throws IOException {\n                // add the document iff:\n                if (Arrays.equals(ranges, leaf)\n                    // target is within cell and queryType is INTERSECTS or CONTAINS:\n                    || (comparator.isWithin(leaf) && queryType != QueryType.WITHIN)\n                    // target contains cell and queryType is INTERSECTS or WITHIN:\n                    || (comparator.contains(leaf) && queryType != QueryType.CONTAINS)\n                    // target is not disjoint (crosses) and queryType is INTERSECTS\n                    || (comparator.isDisjoint(leaf) == false && queryType == QueryType.INTERSECTS)) {\n                  adder.add(docID);\n                }\n              }\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                byte[] node = getInternalRange(minPackedValue, maxPackedValue);\n                // compute range relation for BKD traversal\n                if (comparator.isDisjoint(node)) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (comparator.isWithin(node)) {\n                  // target within cell; continue traversing:\n                  return Relation.CELL_CROSSES_QUERY;\n                } else if (comparator.contains(node)) {\n                  // target contains cell; add iff queryType is not a CONTAINS query:\n                  return (queryType == QueryType.CONTAINS) ? Relation.CELL_OUTSIDE_QUERY : Relation.CELL_INSIDE_QUERY;\n                }\n                // target intersects cell; continue traversing:\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = true;\n        if (values.getDocCount() == reader.maxDoc()) {\n          // if query crosses, docs need to be further scrutinized\n          byte[] range = getInternalRange(values.getMinPackedValue(), values.getMaxPackedValue());\n          // if the internal node is not equal and not contained by the query, all docs do not match\n          if ((!Arrays.equals(ranges, range)\n              && (comparator.contains(range) && queryType != QueryType.CONTAINS)) == false) {\n            allDocsMatch = false;\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator = allDocsMatch == true ?\n            DocIdSetIterator.all(reader.maxDoc()) : buildMatchingDocIdSet(reader, values).iterator();\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      /** get an encoded byte representation of the internal node; this is\n       *  the lower half of the min array and the upper half of the max array */\n      private byte[] getInternalRange(byte[] min, byte[] max) {\n        byte[] range = new byte[min.length];\n        final int dimSize = numDims * bytesPerDim;\n        System.arraycopy(min, 0, range, 0, dimSize);\n        System.arraycopy(max, dimSize, range, dimSize, dimSize);\n        return range;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9856095f7afb5a607bf5e65077615ed91273508c","date":1481837697,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n      final RangeFieldComparator comparator = new RangeFieldComparator();\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        values.intersect(\n            new IntersectVisitor() {\n              DocIdSetBuilder.BulkAdder adder;\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n              @Override\n              public void visit(int docID) throws IOException {\n                adder.add(docID);\n              }\n              @Override\n              public void visit(int docID, byte[] leaf) throws IOException {\n                // add the document iff:\n                if (Arrays.equals(ranges, leaf)\n                    // target is within cell and queryType is INTERSECTS or CONTAINS:\n                    || (comparator.isWithin(leaf) && queryType != QueryType.WITHIN)\n                    // target contains cell and queryType is INTERSECTS or WITHIN:\n                    || (comparator.contains(leaf) && queryType != QueryType.CONTAINS)\n                    // target is not disjoint (crosses) and queryType is INTERSECTS\n                    || (comparator.isDisjoint(leaf) == false && queryType == QueryType.INTERSECTS)) {\n                  adder.add(docID);\n                }\n              }\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                byte[] node = getInternalRange(minPackedValue, maxPackedValue);\n                // compute range relation for BKD traversal\n                if (comparator.isDisjoint(node)) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (comparator.isWithin(node)) {\n                  // target within cell; continue traversing:\n                  return Relation.CELL_CROSSES_QUERY;\n                } else if (comparator.contains(node)) {\n                  // target contains cell; add iff queryType is not a CONTAINS query:\n                  return (queryType == QueryType.CONTAINS) ? Relation.CELL_OUTSIDE_QUERY : Relation.CELL_INSIDE_QUERY;\n                }\n                // target intersects cell; continue traversing:\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = true;\n        if (values.getDocCount() == reader.maxDoc()) {\n          // if query crosses, docs need to be further scrutinized\n          byte[] range = getInternalRange(values.getMinPackedValue(), values.getMaxPackedValue());\n          // if the internal node is not equal and not contained by the query, all docs do not match\n          if ((!Arrays.equals(ranges, range)\n              && (comparator.contains(range) && queryType != QueryType.CONTAINS)) == false) {\n            allDocsMatch = false;\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator = allDocsMatch == true ?\n            DocIdSetIterator.all(reader.maxDoc()) : buildMatchingDocIdSet(reader, values).iterator();\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      /** get an encoded byte representation of the internal node; this is\n       *  the lower half of the min array and the upper half of the max array */\n      private byte[] getInternalRange(byte[] min, byte[] max) {\n        byte[] range = new byte[min.length];\n        final int dimSize = numDims * bytesPerDim;\n        System.arraycopy(min, 0, range, 0, dimSize);\n        System.arraycopy(max, dimSize, range, dimSize, dimSize);\n        return range;\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n      final RangeFieldComparator comparator = new RangeFieldComparator();\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        values.intersect(\n            new IntersectVisitor() {\n              DocIdSetBuilder.BulkAdder adder;\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n              @Override\n              public void visit(int docID) throws IOException {\n                adder.add(docID);\n              }\n              @Override\n              public void visit(int docID, byte[] leaf) throws IOException {\n                // add the document iff:\n                if (Arrays.equals(ranges, leaf)\n                    // target is within cell and queryType is INTERSECTS or CONTAINS:\n                    || (comparator.isWithin(leaf) && queryType != QueryType.WITHIN)\n                    // target contains cell and queryType is INTERSECTS or WITHIN:\n                    || (comparator.contains(leaf) && queryType != QueryType.CONTAINS)\n                    // target is not disjoint (crosses) and queryType is INTERSECTS\n                    || (comparator.isDisjoint(leaf) == false && queryType == QueryType.INTERSECTS)) {\n                  adder.add(docID);\n                }\n              }\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                byte[] node = getInternalRange(minPackedValue, maxPackedValue);\n                // compute range relation for BKD traversal\n                if (comparator.isDisjoint(node)) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (comparator.isWithin(node)) {\n                  // target within cell; continue traversing:\n                  return Relation.CELL_CROSSES_QUERY;\n                } else if (comparator.contains(node)) {\n                  // target contains cell; add iff queryType is not a CONTAINS query:\n                  return (queryType == QueryType.CONTAINS) ? Relation.CELL_OUTSIDE_QUERY : Relation.CELL_INSIDE_QUERY;\n                }\n                // target intersects cell; continue traversing:\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = true;\n        if (values.getDocCount() == reader.maxDoc()) {\n          // if query crosses, docs need to be further scrutinized\n          byte[] range = getInternalRange(values.getMinPackedValue(), values.getMaxPackedValue());\n          // if the internal node is not equal and not contained by the query, all docs do not match\n          if ((!Arrays.equals(ranges, range)\n              && (comparator.contains(range) && queryType != QueryType.CONTAINS)) == false) {\n            allDocsMatch = false;\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator = allDocsMatch == true ?\n            DocIdSetIterator.all(reader.maxDoc()) : buildMatchingDocIdSet(reader, values).iterator();\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      /** get an encoded byte representation of the internal node; this is\n       *  the lower half of the min array and the upper half of the max array */\n      private byte[] getInternalRange(byte[] min, byte[] max) {\n        byte[] range = new byte[min.length];\n        final int dimSize = numDims * bytesPerDim;\n        System.arraycopy(min, 0, range, 0, dimSize);\n        System.arraycopy(max, dimSize, range, dimSize, dimSize);\n        return range;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9dec1cfab325d955644ed528eb211dd09d093086","date":1487270763,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n      final RangeFieldComparator target = new RangeFieldComparator();\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        values.intersect(\n            new IntersectVisitor() {\n              DocIdSetBuilder.BulkAdder adder;\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n              @Override\n              public void visit(int docID) throws IOException {\n                adder.add(docID);\n              }\n              @Override\n              public void visit(int docID, byte[] leaf) throws IOException {\n                if (target.matches(leaf)) {\n                  adder.add(docID);\n                }\n              }\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                byte[] node = getInternalRange(minPackedValue, maxPackedValue);\n                // compute range relation for BKD traversal\n                if (target.intersects(node) == false) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (target.within(node)) {\n                  // target within cell; continue traversing:\n                  return Relation.CELL_CROSSES_QUERY;\n                } else if (target.contains(node)) {\n                  // target contains cell; add iff queryType is not a CONTAINS or CROSSES query:\n                  return (queryType == QueryType.CONTAINS || queryType == QueryType.CROSSES) ?\n                      Relation.CELL_OUTSIDE_QUERY : Relation.CELL_INSIDE_QUERY;\n                }\n                // target intersects cell; continue traversing:\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = true;\n        if (values.getDocCount() == reader.maxDoc()) {\n          // if query crosses, docs need to be further scrutinized\n          byte[] range = getInternalRange(values.getMinPackedValue(), values.getMaxPackedValue());\n          // if the internal node is not equal and not contained by the query, all docs do not match\n          if ((!Arrays.equals(ranges, range)\n              && (target.contains(range) && queryType != QueryType.CONTAINS)) == false) {\n            allDocsMatch = false;\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator = allDocsMatch == true ?\n            DocIdSetIterator.all(reader.maxDoc()) : buildMatchingDocIdSet(reader, values).iterator();\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      /** get an encoded byte representation of the internal node; this is\n       *  the lower half of the min array and the upper half of the max array */\n      private byte[] getInternalRange(byte[] min, byte[] max) {\n        byte[] range = new byte[min.length];\n        final int dimSize = numDims * bytesPerDim;\n        System.arraycopy(min, 0, range, 0, dimSize);\n        System.arraycopy(max, dimSize, range, dimSize, dimSize);\n        return range;\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n      final RangeFieldComparator comparator = new RangeFieldComparator();\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        values.intersect(\n            new IntersectVisitor() {\n              DocIdSetBuilder.BulkAdder adder;\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n              @Override\n              public void visit(int docID) throws IOException {\n                adder.add(docID);\n              }\n              @Override\n              public void visit(int docID, byte[] leaf) throws IOException {\n                // add the document iff:\n                if (Arrays.equals(ranges, leaf)\n                    // target is within cell and queryType is INTERSECTS or CONTAINS:\n                    || (comparator.isWithin(leaf) && queryType != QueryType.WITHIN)\n                    // target contains cell and queryType is INTERSECTS or WITHIN:\n                    || (comparator.contains(leaf) && queryType != QueryType.CONTAINS)\n                    // target is not disjoint (crosses) and queryType is INTERSECTS\n                    || (comparator.isDisjoint(leaf) == false && queryType == QueryType.INTERSECTS)) {\n                  adder.add(docID);\n                }\n              }\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                byte[] node = getInternalRange(minPackedValue, maxPackedValue);\n                // compute range relation for BKD traversal\n                if (comparator.isDisjoint(node)) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (comparator.isWithin(node)) {\n                  // target within cell; continue traversing:\n                  return Relation.CELL_CROSSES_QUERY;\n                } else if (comparator.contains(node)) {\n                  // target contains cell; add iff queryType is not a CONTAINS query:\n                  return (queryType == QueryType.CONTAINS) ? Relation.CELL_OUTSIDE_QUERY : Relation.CELL_INSIDE_QUERY;\n                }\n                // target intersects cell; continue traversing:\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = true;\n        if (values.getDocCount() == reader.maxDoc()) {\n          // if query crosses, docs need to be further scrutinized\n          byte[] range = getInternalRange(values.getMinPackedValue(), values.getMaxPackedValue());\n          // if the internal node is not equal and not contained by the query, all docs do not match\n          if ((!Arrays.equals(ranges, range)\n              && (comparator.contains(range) && queryType != QueryType.CONTAINS)) == false) {\n            allDocsMatch = false;\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator = allDocsMatch == true ?\n            DocIdSetIterator.all(reader.maxDoc()) : buildMatchingDocIdSet(reader, values).iterator();\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      /** get an encoded byte representation of the internal node; this is\n       *  the lower half of the min array and the upper half of the max array */\n      private byte[] getInternalRange(byte[] min, byte[] max) {\n        byte[] range = new byte[min.length];\n        final int dimSize = numDims * bytesPerDim;\n        System.arraycopy(min, 0, range, 0, dimSize);\n        System.arraycopy(max, dimSize, range, dimSize, dimSize);\n        return range;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["91e78d339fc63f8487cc36dbc676582553f5e622"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a612d029b191d7ab214b957b1dae3a4b9fc614bd","date":1487350352,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n      final RangeFieldComparator target = new RangeFieldComparator();\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        values.intersect(\n            new IntersectVisitor() {\n              DocIdSetBuilder.BulkAdder adder;\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n              @Override\n              public void visit(int docID) throws IOException {\n                adder.add(docID);\n              }\n              @Override\n              public void visit(int docID, byte[] leaf) throws IOException {\n                if (target.matches(leaf)) {\n                  adder.add(docID);\n                }\n              }\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                byte[] node = getInternalRange(minPackedValue, maxPackedValue);\n                // compute range relation for BKD traversal\n                if (target.intersects(node) == false) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (target.within(node)) {\n                  // target within cell; continue traversing:\n                  return Relation.CELL_CROSSES_QUERY;\n                } else if (target.contains(node)) {\n                  // target contains cell; add iff queryType is not a CONTAINS or CROSSES query:\n                  return (queryType == QueryType.CONTAINS || queryType == QueryType.CROSSES) ?\n                      Relation.CELL_OUTSIDE_QUERY : Relation.CELL_INSIDE_QUERY;\n                }\n                // target intersects cell; continue traversing:\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = true;\n        if (values.getDocCount() == reader.maxDoc()) {\n          // if query crosses, docs need to be further scrutinized\n          byte[] range = getInternalRange(values.getMinPackedValue(), values.getMaxPackedValue());\n          // if the internal node is not equal and not contained by the query, all docs do not match\n          if (!Arrays.equals(ranges, range)\n              && (!target.contains(range) || queryType != QueryType.WITHIN)) {\n            allDocsMatch = false;\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator = allDocsMatch == true ?\n            DocIdSetIterator.all(reader.maxDoc()) : buildMatchingDocIdSet(reader, values).iterator();\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      /** get an encoded byte representation of the internal node; this is\n       *  the lower half of the min array and the upper half of the max array */\n      private byte[] getInternalRange(byte[] min, byte[] max) {\n        byte[] range = new byte[min.length];\n        final int dimSize = numDims * bytesPerDim;\n        System.arraycopy(min, 0, range, 0, dimSize);\n        System.arraycopy(max, dimSize, range, dimSize, dimSize);\n        return range;\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n      final RangeFieldComparator target = new RangeFieldComparator();\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        values.intersect(\n            new IntersectVisitor() {\n              DocIdSetBuilder.BulkAdder adder;\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n              @Override\n              public void visit(int docID) throws IOException {\n                adder.add(docID);\n              }\n              @Override\n              public void visit(int docID, byte[] leaf) throws IOException {\n                if (target.matches(leaf)) {\n                  adder.add(docID);\n                }\n              }\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                byte[] node = getInternalRange(minPackedValue, maxPackedValue);\n                // compute range relation for BKD traversal\n                if (target.intersects(node) == false) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (target.within(node)) {\n                  // target within cell; continue traversing:\n                  return Relation.CELL_CROSSES_QUERY;\n                } else if (target.contains(node)) {\n                  // target contains cell; add iff queryType is not a CONTAINS or CROSSES query:\n                  return (queryType == QueryType.CONTAINS || queryType == QueryType.CROSSES) ?\n                      Relation.CELL_OUTSIDE_QUERY : Relation.CELL_INSIDE_QUERY;\n                }\n                // target intersects cell; continue traversing:\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = true;\n        if (values.getDocCount() == reader.maxDoc()) {\n          // if query crosses, docs need to be further scrutinized\n          byte[] range = getInternalRange(values.getMinPackedValue(), values.getMaxPackedValue());\n          // if the internal node is not equal and not contained by the query, all docs do not match\n          if ((!Arrays.equals(ranges, range)\n              && (target.contains(range) && queryType != QueryType.CONTAINS)) == false) {\n            allDocsMatch = false;\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator = allDocsMatch == true ?\n            DocIdSetIterator.all(reader.maxDoc()) : buildMatchingDocIdSet(reader, values).iterator();\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      /** get an encoded byte representation of the internal node; this is\n       *  the lower half of the min array and the upper half of the max array */\n      private byte[] getInternalRange(byte[] min, byte[] max) {\n        byte[] range = new byte[min.length];\n        final int dimSize = numDims * bytesPerDim;\n        System.arraycopy(min, 0, range, 0, dimSize);\n        System.arraycopy(max, dimSize, range, dimSize, dimSize);\n        return range;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2ec1a327bcb7e91c018b0c601d542e8482af8890","date":1489279278,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n      final RangeFieldComparator target = new RangeFieldComparator();\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        values.intersect(\n            new IntersectVisitor() {\n              DocIdSetBuilder.BulkAdder adder;\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n              @Override\n              public void visit(int docID) throws IOException {\n                adder.add(docID);\n              }\n              @Override\n              public void visit(int docID, byte[] leaf) throws IOException {\n                if (target.matches(leaf)) {\n                  adder.add(docID);\n                }\n              }\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                byte[] node = getInternalRange(minPackedValue, maxPackedValue);\n                // compute range relation for BKD traversal\n                if (target.intersects(node) == false) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (target.within(node)) {\n                  // target within cell; continue traversing:\n                  return Relation.CELL_CROSSES_QUERY;\n                } else if (target.contains(node)) {\n                  // target contains cell; add iff queryType is not a CONTAINS or CROSSES query:\n                  return (queryType == QueryType.CONTAINS || queryType == QueryType.CROSSES) ?\n                      Relation.CELL_OUTSIDE_QUERY : Relation.CELL_INSIDE_QUERY;\n                }\n                // target intersects cell; continue traversing:\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = true;\n        if (values.getDocCount() == reader.maxDoc()) {\n          // if query crosses, docs need to be further scrutinized\n          byte[] range = getInternalRange(values.getMinPackedValue(), values.getMaxPackedValue());\n          // if the internal node is not equal and not contained by the query, all docs do not match\n          if (queryType == QueryType.CROSSES || (!Arrays.equals(ranges, range)\n              && (target.contains(range) == false || queryType != QueryType.WITHIN))) {\n            allDocsMatch = false;\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator = allDocsMatch == true ?\n            DocIdSetIterator.all(reader.maxDoc()) : buildMatchingDocIdSet(reader, values).iterator();\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      /** get an encoded byte representation of the internal node; this is\n       *  the lower half of the min array and the upper half of the max array */\n      private byte[] getInternalRange(byte[] min, byte[] max) {\n        byte[] range = new byte[min.length];\n        final int dimSize = numDims * bytesPerDim;\n        System.arraycopy(min, 0, range, 0, dimSize);\n        System.arraycopy(max, dimSize, range, dimSize, dimSize);\n        return range;\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n      final RangeFieldComparator target = new RangeFieldComparator();\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        values.intersect(\n            new IntersectVisitor() {\n              DocIdSetBuilder.BulkAdder adder;\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n              @Override\n              public void visit(int docID) throws IOException {\n                adder.add(docID);\n              }\n              @Override\n              public void visit(int docID, byte[] leaf) throws IOException {\n                if (target.matches(leaf)) {\n                  adder.add(docID);\n                }\n              }\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                byte[] node = getInternalRange(minPackedValue, maxPackedValue);\n                // compute range relation for BKD traversal\n                if (target.intersects(node) == false) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (target.within(node)) {\n                  // target within cell; continue traversing:\n                  return Relation.CELL_CROSSES_QUERY;\n                } else if (target.contains(node)) {\n                  // target contains cell; add iff queryType is not a CONTAINS or CROSSES query:\n                  return (queryType == QueryType.CONTAINS || queryType == QueryType.CROSSES) ?\n                      Relation.CELL_OUTSIDE_QUERY : Relation.CELL_INSIDE_QUERY;\n                }\n                // target intersects cell; continue traversing:\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = true;\n        if (values.getDocCount() == reader.maxDoc()) {\n          // if query crosses, docs need to be further scrutinized\n          byte[] range = getInternalRange(values.getMinPackedValue(), values.getMaxPackedValue());\n          // if the internal node is not equal and not contained by the query, all docs do not match\n          if (!Arrays.equals(ranges, range)\n              && (!target.contains(range) || queryType != QueryType.WITHIN)) {\n            allDocsMatch = false;\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator = allDocsMatch == true ?\n            DocIdSetIterator.all(reader.maxDoc()) : buildMatchingDocIdSet(reader, values).iterator();\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      /** get an encoded byte representation of the internal node; this is\n       *  the lower half of the min array and the upper half of the max array */\n      private byte[] getInternalRange(byte[] min, byte[] max) {\n        byte[] range = new byte[min.length];\n        final int dimSize = numDims * bytesPerDim;\n        System.arraycopy(min, 0, range, 0, dimSize);\n        System.arraycopy(max, dimSize, range, dimSize, dimSize);\n        return range;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["91e78d339fc63f8487cc36dbc676582553f5e622"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4a52b01a73cacbd2d360240e72d64c0ba353618f","date":1489389749,"type":5,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n      final RangeFieldComparator target = new RangeFieldComparator();\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        values.intersect(\n            new IntersectVisitor() {\n              DocIdSetBuilder.BulkAdder adder;\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n              @Override\n              public void visit(int docID) throws IOException {\n                adder.add(docID);\n              }\n              @Override\n              public void visit(int docID, byte[] leaf) throws IOException {\n                if (target.matches(leaf)) {\n                  adder.add(docID);\n                }\n              }\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                byte[] node = getInternalRange(minPackedValue, maxPackedValue);\n                // compute range relation for BKD traversal\n                if (target.intersects(node) == false) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (target.within(node)) {\n                  // target within cell; continue traversing:\n                  return Relation.CELL_CROSSES_QUERY;\n                } else if (target.contains(node)) {\n                  // target contains cell; add iff queryType is not a CONTAINS or CROSSES query:\n                  return (queryType == QueryType.CONTAINS || queryType == QueryType.CROSSES) ?\n                      Relation.CELL_OUTSIDE_QUERY : Relation.CELL_INSIDE_QUERY;\n                }\n                // target intersects cell; continue traversing:\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = true;\n        if (values.getDocCount() == reader.maxDoc()) {\n          // if query crosses, docs need to be further scrutinized\n          byte[] range = getInternalRange(values.getMinPackedValue(), values.getMaxPackedValue());\n          // if the internal node is not equal and not contained by the query, all docs do not match\n          if (queryType == QueryType.CROSSES || (!Arrays.equals(ranges, range)\n              && (target.contains(range) == false || queryType != QueryType.WITHIN))) {\n            allDocsMatch = false;\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator = allDocsMatch == true ?\n            DocIdSetIterator.all(reader.maxDoc()) : buildMatchingDocIdSet(reader, values).iterator();\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      /** get an encoded byte representation of the internal node; this is\n       *  the lower half of the min array and the upper half of the max array */\n      private byte[] getInternalRange(byte[] min, byte[] max) {\n        byte[] range = new byte[min.length];\n        final int dimSize = numDims * bytesPerDim;\n        System.arraycopy(min, 0, range, 0, dimSize);\n        System.arraycopy(max, dimSize, range, dimSize, dimSize);\n        return range;\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n      final RangeFieldComparator target = new RangeFieldComparator();\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        values.intersect(\n            new IntersectVisitor() {\n              DocIdSetBuilder.BulkAdder adder;\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n              @Override\n              public void visit(int docID) throws IOException {\n                adder.add(docID);\n              }\n              @Override\n              public void visit(int docID, byte[] leaf) throws IOException {\n                if (target.matches(leaf)) {\n                  adder.add(docID);\n                }\n              }\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                byte[] node = getInternalRange(minPackedValue, maxPackedValue);\n                // compute range relation for BKD traversal\n                if (target.intersects(node) == false) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (target.within(node)) {\n                  // target within cell; continue traversing:\n                  return Relation.CELL_CROSSES_QUERY;\n                } else if (target.contains(node)) {\n                  // target contains cell; add iff queryType is not a CONTAINS or CROSSES query:\n                  return (queryType == QueryType.CONTAINS || queryType == QueryType.CROSSES) ?\n                      Relation.CELL_OUTSIDE_QUERY : Relation.CELL_INSIDE_QUERY;\n                }\n                // target intersects cell; continue traversing:\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = true;\n        if (values.getDocCount() == reader.maxDoc()) {\n          // if query crosses, docs need to be further scrutinized\n          byte[] range = getInternalRange(values.getMinPackedValue(), values.getMaxPackedValue());\n          // if the internal node is not equal and not contained by the query, all docs do not match\n          if (queryType == QueryType.CROSSES || (!Arrays.equals(ranges, range)\n              && (target.contains(range) == false || queryType != QueryType.WITHIN))) {\n            allDocsMatch = false;\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator = allDocsMatch == true ?\n            DocIdSetIterator.all(reader.maxDoc()) : buildMatchingDocIdSet(reader, values).iterator();\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      /** get an encoded byte representation of the internal node; this is\n       *  the lower half of the min array and the upper half of the max array */\n      private byte[] getInternalRange(byte[] min, byte[] max) {\n        byte[] range = new byte[min.length];\n        final int dimSize = numDims * bytesPerDim;\n        System.arraycopy(min, 0, range, 0, dimSize);\n        System.arraycopy(max, dimSize, range, dimSize, dimSize);\n        return range;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"2ec1a327bcb7e91c018b0c601d542e8482af8890":["a612d029b191d7ab214b957b1dae3a4b9fc614bd"],"3c738d774d160362ecfdc9887a5fa4beb421872b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","05f4c28bc6a6df30868753f35eb802cbff28ce5c"],"4a52b01a73cacbd2d360240e72d64c0ba353618f":["2ec1a327bcb7e91c018b0c601d542e8482af8890"],"a612d029b191d7ab214b957b1dae3a4b9fc614bd":["9dec1cfab325d955644ed528eb211dd09d093086"],"6939810fba802f65f77bcc41069354917202d36f":["367f57e2ee85b7f7e28cfe73370a22cf67624f65"],"367f57e2ee85b7f7e28cfe73370a22cf67624f65":["4e6bfc2c1eac33d890bf4d5638c8e149e1dcbcca"],"4e6bfc2c1eac33d890bf4d5638c8e149e1dcbcca":["3c738d774d160362ecfdc9887a5fa4beb421872b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","367f57e2ee85b7f7e28cfe73370a22cf67624f65"],"9dec1cfab325d955644ed528eb211dd09d093086":["6939810fba802f65f77bcc41069354917202d36f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"05f4c28bc6a6df30868753f35eb802cbff28ce5c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9856095f7afb5a607bf5e65077615ed91273508c":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","6939810fba802f65f77bcc41069354917202d36f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4a52b01a73cacbd2d360240e72d64c0ba353618f"]},"commit2Childs":{"2ec1a327bcb7e91c018b0c601d542e8482af8890":["4a52b01a73cacbd2d360240e72d64c0ba353618f"],"3c738d774d160362ecfdc9887a5fa4beb421872b":["4e6bfc2c1eac33d890bf4d5638c8e149e1dcbcca"],"4a52b01a73cacbd2d360240e72d64c0ba353618f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a612d029b191d7ab214b957b1dae3a4b9fc614bd":["2ec1a327bcb7e91c018b0c601d542e8482af8890"],"6939810fba802f65f77bcc41069354917202d36f":["9dec1cfab325d955644ed528eb211dd09d093086","9856095f7afb5a607bf5e65077615ed91273508c"],"367f57e2ee85b7f7e28cfe73370a22cf67624f65":["6939810fba802f65f77bcc41069354917202d36f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"4e6bfc2c1eac33d890bf4d5638c8e149e1dcbcca":["367f57e2ee85b7f7e28cfe73370a22cf67624f65"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["9856095f7afb5a607bf5e65077615ed91273508c"],"9dec1cfab325d955644ed528eb211dd09d093086":["a612d029b191d7ab214b957b1dae3a4b9fc614bd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3c738d774d160362ecfdc9887a5fa4beb421872b","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","05f4c28bc6a6df30868753f35eb802cbff28ce5c"],"05f4c28bc6a6df30868753f35eb802cbff28ce5c":["3c738d774d160362ecfdc9887a5fa4beb421872b"],"9856095f7afb5a607bf5e65077615ed91273508c":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9856095f7afb5a607bf5e65077615ed91273508c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}