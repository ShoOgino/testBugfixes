{"path":"lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase#newTerm(Random,CollectionStatistics).mjava","commits":[{"id":"ad1dc49b5314cfdb82a7ea40d2f92f07fe8cee46","date":1508899684,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase#newTerm(Random,CollectionStatistics).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * returns new random term, that fits within the bounds of the corpus\n   */\n  static TermStatistics newTerm(Random random, CollectionStatistics corpus) {\n    final long docFreq;\n    if (random.nextBoolean()) {\n      // rare term\n      docFreq = 1;\n    } else {\n      // random specificity\n      docFreq = TestUtil.nextLong(random, 1, corpus.docCount());\n    }\n    final long totalTermFreq;\n    if (corpus.sumTotalTermFreq() == -1) {\n      // omitTF\n      totalTermFreq = -1;\n    } else if (random.nextBoolean()) {\n      // no repetition\n      totalTermFreq = docFreq;\n    } else {\n      // random repetition: but can't require docs to have > 2B tokens\n      long upperBound;\n      try {\n        upperBound = Math.min(corpus.sumTotalTermFreq(), Math.multiplyExact(docFreq, Integer.MAX_VALUE));\n      } catch (ArithmeticException overflow) {\n        upperBound = corpus.sumTotalTermFreq();\n      }\n      totalTermFreq = TestUtil.nextLong(random, docFreq, upperBound);\n    }\n    return new TermStatistics(TERM, docFreq, totalTermFreq);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"086ffe31d8fba0110227db122974163709ecc1b4","date":1509678141,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase#newTerm(Random,CollectionStatistics).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase#newTerm(Random,CollectionStatistics).mjava","sourceNew":"  /**\n   * returns new random term, that fits within the bounds of the corpus\n   */\n  static TermStatistics newTerm(Random random, CollectionStatistics corpus) {\n    final long docFreq;\n    if (random.nextBoolean()) {\n      // rare term\n      docFreq = 1;\n    } else {\n      // random specificity\n      docFreq = TestUtil.nextLong(random, 1, corpus.docCount());\n    }\n    final long totalTermFreq;\n    if (corpus.sumTotalTermFreq() == corpus.sumDocFreq()) {\n      // omitTF\n      totalTermFreq = docFreq;\n    } else if (random.nextBoolean()) {\n      // no repetition\n      totalTermFreq = docFreq;\n    } else {\n      // random repetition: but can't require docs to have > 2B tokens\n      long upperBound;\n      try {\n        upperBound = Math.min(corpus.sumTotalTermFreq(), Math.multiplyExact(docFreq, Integer.MAX_VALUE));\n      } catch (ArithmeticException overflow) {\n        upperBound = corpus.sumTotalTermFreq();\n      }\n      totalTermFreq = TestUtil.nextLong(random, docFreq, upperBound);\n    }\n    return new TermStatistics(TERM, docFreq, totalTermFreq);\n  }\n\n","sourceOld":"  /**\n   * returns new random term, that fits within the bounds of the corpus\n   */\n  static TermStatistics newTerm(Random random, CollectionStatistics corpus) {\n    final long docFreq;\n    if (random.nextBoolean()) {\n      // rare term\n      docFreq = 1;\n    } else {\n      // random specificity\n      docFreq = TestUtil.nextLong(random, 1, corpus.docCount());\n    }\n    final long totalTermFreq;\n    if (corpus.sumTotalTermFreq() == -1) {\n      // omitTF\n      totalTermFreq = -1;\n    } else if (random.nextBoolean()) {\n      // no repetition\n      totalTermFreq = docFreq;\n    } else {\n      // random repetition: but can't require docs to have > 2B tokens\n      long upperBound;\n      try {\n        upperBound = Math.min(corpus.sumTotalTermFreq(), Math.multiplyExact(docFreq, Integer.MAX_VALUE));\n      } catch (ArithmeticException overflow) {\n        upperBound = corpus.sumTotalTermFreq();\n      }\n      totalTermFreq = TestUtil.nextLong(random, docFreq, upperBound);\n    }\n    return new TermStatistics(TERM, docFreq, totalTermFreq);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d523b8189b211dd1630166aa77b8c88bb48b3fcc","date":1510144168,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase#newTerm(Random,CollectionStatistics).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase#newTerm(Random,CollectionStatistics).mjava","sourceNew":"  /**\n   * returns new random term, that fits within the bounds of the corpus\n   */\n  static TermStatistics newTerm(Random random, CollectionStatistics corpus) {\n    final long docFreq;\n    if (random.nextBoolean()) {\n      // rare term\n      docFreq = 1;\n    } else {\n      // random specificity\n      docFreq = TestUtil.nextLong(random, 1, corpus.docCount());\n    }\n    final long totalTermFreq;\n    if (corpus.sumTotalTermFreq() == corpus.sumDocFreq()) {\n      // omitTF\n      totalTermFreq = docFreq;\n    } else if (random.nextBoolean()) {\n      // no repetition\n      totalTermFreq = docFreq;\n    } else {\n      // random repetition: but can't require docs to have > 2B tokens\n      long upperBound;\n      try {\n        upperBound = Math.min(corpus.sumTotalTermFreq(), Math.multiplyExact(docFreq, Integer.MAX_VALUE));\n      } catch (ArithmeticException overflow) {\n        upperBound = corpus.sumTotalTermFreq();\n      }\n      totalTermFreq = TestUtil.nextLong(random, docFreq, upperBound);\n    }\n    return new TermStatistics(TERM, docFreq, totalTermFreq);\n  }\n\n","sourceOld":"  /**\n   * returns new random term, that fits within the bounds of the corpus\n   */\n  static TermStatistics newTerm(Random random, CollectionStatistics corpus) {\n    final long docFreq;\n    if (random.nextBoolean()) {\n      // rare term\n      docFreq = 1;\n    } else {\n      // random specificity\n      docFreq = TestUtil.nextLong(random, 1, corpus.docCount());\n    }\n    final long totalTermFreq;\n    if (corpus.sumTotalTermFreq() == -1) {\n      // omitTF\n      totalTermFreq = -1;\n    } else if (random.nextBoolean()) {\n      // no repetition\n      totalTermFreq = docFreq;\n    } else {\n      // random repetition: but can't require docs to have > 2B tokens\n      long upperBound;\n      try {\n        upperBound = Math.min(corpus.sumTotalTermFreq(), Math.multiplyExact(docFreq, Integer.MAX_VALUE));\n      } catch (ArithmeticException overflow) {\n        upperBound = corpus.sumTotalTermFreq();\n      }\n      totalTermFreq = TestUtil.nextLong(random, docFreq, upperBound);\n    }\n    return new TermStatistics(TERM, docFreq, totalTermFreq);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83d379038462cf6dcf64cc9e9a49053c4bb78011","date":1512580797,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase#newTerm(Random,CollectionStatistics).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase#newTerm(Random,CollectionStatistics).mjava","sourceNew":"  /**\n   * returns new random term, that fits within the bounds of the corpus\n   */\n  static TermStatistics newTerm(Random random, CollectionStatistics corpus) {\n    final long docFreq;\n    switch (random.nextInt(3)) {\n      case 0:\n        // rare term\n        docFreq = 1;\n        break;\n      case 1:\n        // common term\n        docFreq = corpus.docCount();\n        break;\n      default:\n        // random specificity\n        docFreq = TestUtil.nextLong(random, 1, corpus.docCount());\n        break;\n    }\n    final long totalTermFreq;\n    // can't require docs to have > 2B tokens\n    long upperBound;\n    try {\n      upperBound = Math.min(corpus.sumTotalTermFreq(), Math.multiplyExact(docFreq, Integer.MAX_VALUE));\n    } catch (ArithmeticException overflow) {\n      upperBound = corpus.sumTotalTermFreq();\n    }\n    if (corpus.sumTotalTermFreq() == corpus.sumDocFreq()) {\n      // omitTF\n      totalTermFreq = docFreq;\n    } else {\n      switch (random.nextInt(3)) {\n        case 0:\n          // no repetition\n          totalTermFreq = docFreq;\n          break;\n        case 1:\n          // maximum repetition\n          totalTermFreq = upperBound;\n          break;\n        default:\n          // random repetition\n          totalTermFreq = TestUtil.nextLong(random, docFreq, upperBound);\n          break;\n      }\n    }\n    return new TermStatistics(TERM, docFreq, totalTermFreq);\n  }\n\n","sourceOld":"  /**\n   * returns new random term, that fits within the bounds of the corpus\n   */\n  static TermStatistics newTerm(Random random, CollectionStatistics corpus) {\n    final long docFreq;\n    if (random.nextBoolean()) {\n      // rare term\n      docFreq = 1;\n    } else {\n      // random specificity\n      docFreq = TestUtil.nextLong(random, 1, corpus.docCount());\n    }\n    final long totalTermFreq;\n    if (corpus.sumTotalTermFreq() == corpus.sumDocFreq()) {\n      // omitTF\n      totalTermFreq = docFreq;\n    } else if (random.nextBoolean()) {\n      // no repetition\n      totalTermFreq = docFreq;\n    } else {\n      // random repetition: but can't require docs to have > 2B tokens\n      long upperBound;\n      try {\n        upperBound = Math.min(corpus.sumTotalTermFreq(), Math.multiplyExact(docFreq, Integer.MAX_VALUE));\n      } catch (ArithmeticException overflow) {\n        upperBound = corpus.sumTotalTermFreq();\n      }\n      totalTermFreq = TestUtil.nextLong(random, docFreq, upperBound);\n    }\n    return new TermStatistics(TERM, docFreq, totalTermFreq);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"83d379038462cf6dcf64cc9e9a49053c4bb78011":["d523b8189b211dd1630166aa77b8c88bb48b3fcc"],"ad1dc49b5314cfdb82a7ea40d2f92f07fe8cee46":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"086ffe31d8fba0110227db122974163709ecc1b4":["ad1dc49b5314cfdb82a7ea40d2f92f07fe8cee46"],"d523b8189b211dd1630166aa77b8c88bb48b3fcc":["ad1dc49b5314cfdb82a7ea40d2f92f07fe8cee46","086ffe31d8fba0110227db122974163709ecc1b4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["83d379038462cf6dcf64cc9e9a49053c4bb78011"]},"commit2Childs":{"83d379038462cf6dcf64cc9e9a49053c4bb78011":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ad1dc49b5314cfdb82a7ea40d2f92f07fe8cee46":["086ffe31d8fba0110227db122974163709ecc1b4","d523b8189b211dd1630166aa77b8c88bb48b3fcc"],"086ffe31d8fba0110227db122974163709ecc1b4":["d523b8189b211dd1630166aa77b8c88bb48b3fcc"],"d523b8189b211dd1630166aa77b8c88bb48b3fcc":["83d379038462cf6dcf64cc9e9a49053c4bb78011"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ad1dc49b5314cfdb82a7ea40d2f92f07fe8cee46"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}