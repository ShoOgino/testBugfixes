{"path":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudHttp2SolrClientTest#stateVersionParamTest().mjava","commits":[{"id":"0544142c22eb88b6d8b3817f2e1190156aa4f9af","date":1551692505,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudHttp2SolrClientTest#stateVersionParamTest().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void stateVersionParamTest() throws Exception {\n    CollectionAdminRequest.createCollection(COLLECTION, \"conf\", 2, 1).process(cluster.getSolrClient());\n    cluster.waitForActiveCollection(COLLECTION, 2, 2);\n\n    DocCollection coll = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n    Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n    SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n    HttpSolrClient.RemoteSolrException sse = null;\n\n    final String url = r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\" + COLLECTION;\n    try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n\n      log.info(\"should work query, result {}\", solrClient.query(q));\n      //no problem\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + coll.getZNodeVersion());\n      log.info(\"2nd query , result {}\", solrClient.query(q));\n      //no error yet good\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n      QueryResponse rsp = solrClient.query(q);\n      Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n      assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n      assertNotNull(m.get(COLLECTION));\n    }\n\n    //now send the request to another node that does not serve the collection\n\n    Set<String> allNodesOfColl = new HashSet<>();\n    for (Slice slice : coll.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n      }\n    }\n    String theNode = null;\n    Set<String> liveNodes = cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes();\n    for (String s : liveNodes) {\n      String n = cluster.getSolrClient().getZkStateReader().getBaseUrlForNodeName(s);\n      if(!allNodesOfColl.contains(n)){\n        theNode = n;\n        break;\n      }\n    }\n    log.info(\"the node which does not serve this collection{} \",theNode);\n    assertNotNull(theNode);\n\n\n    final String solrClientUrl = theNode + \"/\" + COLLECTION;\n    try (SolrClient solrClient = getHttpSolrClient(solrClientUrl)) {\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion()-1));\n      try {\n        QueryResponse rsp = solrClient.query(q);\n        log.info(\"error was expected\");\n      } catch (HttpSolrClient.RemoteSolrException e) {\n        sse = e;\n      }\n      assertNotNull(sse);\n      assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9","date":1574619880,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudHttp2SolrClientTest#stateVersionParamTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudHttp2SolrClientTest#stateVersionParamTest().mjava","sourceNew":"  @Test\n  @SuppressWarnings(\"deprecation\")\n  public void stateVersionParamTest() throws Exception {\n    CollectionAdminRequest.createCollection(COLLECTION, \"conf\", 2, 1).process(cluster.getSolrClient());\n    cluster.waitForActiveCollection(COLLECTION, 2, 2);\n\n    DocCollection coll = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n    Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n    SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n    HttpSolrClient.RemoteSolrException sse = null;\n\n    final String url = r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\" + COLLECTION;\n    try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n\n      log.info(\"should work query, result {}\", solrClient.query(q));\n      //no problem\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + coll.getZNodeVersion());\n      log.info(\"2nd query , result {}\", solrClient.query(q));\n      //no error yet good\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n      QueryResponse rsp = solrClient.query(q);\n      Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n      assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n      assertNotNull(m.get(COLLECTION));\n    }\n\n    //now send the request to another node that does not serve the collection\n\n    Set<String> allNodesOfColl = new HashSet<>();\n    for (Slice slice : coll.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n      }\n    }\n    String theNode = null;\n    Set<String> liveNodes = cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes();\n    for (String s : liveNodes) {\n      String n = cluster.getSolrClient().getZkStateReader().getBaseUrlForNodeName(s);\n      if(!allNodesOfColl.contains(n)){\n        theNode = n;\n        break;\n      }\n    }\n    log.info(\"the node which does not serve this collection{} \",theNode);\n    assertNotNull(theNode);\n\n\n    final String solrClientUrl = theNode + \"/\" + COLLECTION;\n    try (SolrClient solrClient = getHttpSolrClient(solrClientUrl)) {\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion()-1));\n      try {\n        QueryResponse rsp = solrClient.query(q);\n        log.info(\"error was expected\");\n      } catch (HttpSolrClient.RemoteSolrException e) {\n        sse = e;\n      }\n      assertNotNull(sse);\n      assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void stateVersionParamTest() throws Exception {\n    CollectionAdminRequest.createCollection(COLLECTION, \"conf\", 2, 1).process(cluster.getSolrClient());\n    cluster.waitForActiveCollection(COLLECTION, 2, 2);\n\n    DocCollection coll = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n    Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n    SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n    HttpSolrClient.RemoteSolrException sse = null;\n\n    final String url = r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\" + COLLECTION;\n    try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n\n      log.info(\"should work query, result {}\", solrClient.query(q));\n      //no problem\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + coll.getZNodeVersion());\n      log.info(\"2nd query , result {}\", solrClient.query(q));\n      //no error yet good\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n      QueryResponse rsp = solrClient.query(q);\n      Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n      assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n      assertNotNull(m.get(COLLECTION));\n    }\n\n    //now send the request to another node that does not serve the collection\n\n    Set<String> allNodesOfColl = new HashSet<>();\n    for (Slice slice : coll.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n      }\n    }\n    String theNode = null;\n    Set<String> liveNodes = cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes();\n    for (String s : liveNodes) {\n      String n = cluster.getSolrClient().getZkStateReader().getBaseUrlForNodeName(s);\n      if(!allNodesOfColl.contains(n)){\n        theNode = n;\n        break;\n      }\n    }\n    log.info(\"the node which does not serve this collection{} \",theNode);\n    assertNotNull(theNode);\n\n\n    final String solrClientUrl = theNode + \"/\" + COLLECTION;\n    try (SolrClient solrClient = getHttpSolrClient(solrClientUrl)) {\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion()-1));\n      try {\n        QueryResponse rsp = solrClient.query(q);\n        log.info(\"error was expected\");\n      } catch (HttpSolrClient.RemoteSolrException e) {\n        sse = e;\n      }\n      assertNotNull(sse);\n      assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb9c3baacabd473e8ecd6c4948aabacead49b88e","date":1574700980,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudHttp2SolrClientTest#stateVersionParamTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudHttp2SolrClientTest#stateVersionParamTest().mjava","sourceNew":"  @Test\n  public void stateVersionParamTest() throws Exception {\n    CollectionAdminRequest.createCollection(COLLECTION, \"conf\", 2, 1).process(cluster.getSolrClient());\n    cluster.waitForActiveCollection(COLLECTION, 2, 2);\n\n    DocCollection coll = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n    Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n    SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n    HttpSolrClient.RemoteSolrException sse = null;\n\n    final String url = r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\" + COLLECTION;\n    try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n\n      log.info(\"should work query, result {}\", solrClient.query(q));\n      //no problem\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + coll.getZNodeVersion());\n      log.info(\"2nd query , result {}\", solrClient.query(q));\n      //no error yet good\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n      QueryResponse rsp = solrClient.query(q);\n      Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n      assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n      assertNotNull(m.get(COLLECTION));\n    }\n\n    //now send the request to another node that does not serve the collection\n\n    Set<String> allNodesOfColl = new HashSet<>();\n    for (Slice slice : coll.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n      }\n    }\n    String theNode = null;\n    Set<String> liveNodes = cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes();\n    for (String s : liveNodes) {\n      String n = cluster.getSolrClient().getZkStateReader().getBaseUrlForNodeName(s);\n      if(!allNodesOfColl.contains(n)){\n        theNode = n;\n        break;\n      }\n    }\n    log.info(\"the node which does not serve this collection{} \",theNode);\n    assertNotNull(theNode);\n\n\n    final String solrClientUrl = theNode + \"/\" + COLLECTION;\n    try (SolrClient solrClient = getHttpSolrClient(solrClientUrl)) {\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion()-1));\n      try {\n        QueryResponse rsp = solrClient.query(q);\n        log.info(\"error was expected\");\n      } catch (HttpSolrClient.RemoteSolrException e) {\n        sse = e;\n      }\n      assertNotNull(sse);\n      assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n    }\n\n  }\n\n","sourceOld":"  @Test\n  @SuppressWarnings(\"deprecation\")\n  public void stateVersionParamTest() throws Exception {\n    CollectionAdminRequest.createCollection(COLLECTION, \"conf\", 2, 1).process(cluster.getSolrClient());\n    cluster.waitForActiveCollection(COLLECTION, 2, 2);\n\n    DocCollection coll = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n    Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n    SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n    HttpSolrClient.RemoteSolrException sse = null;\n\n    final String url = r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\" + COLLECTION;\n    try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n\n      log.info(\"should work query, result {}\", solrClient.query(q));\n      //no problem\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + coll.getZNodeVersion());\n      log.info(\"2nd query , result {}\", solrClient.query(q));\n      //no error yet good\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n      QueryResponse rsp = solrClient.query(q);\n      Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n      assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n      assertNotNull(m.get(COLLECTION));\n    }\n\n    //now send the request to another node that does not serve the collection\n\n    Set<String> allNodesOfColl = new HashSet<>();\n    for (Slice slice : coll.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n      }\n    }\n    String theNode = null;\n    Set<String> liveNodes = cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes();\n    for (String s : liveNodes) {\n      String n = cluster.getSolrClient().getZkStateReader().getBaseUrlForNodeName(s);\n      if(!allNodesOfColl.contains(n)){\n        theNode = n;\n        break;\n      }\n    }\n    log.info(\"the node which does not serve this collection{} \",theNode);\n    assertNotNull(theNode);\n\n\n    final String solrClientUrl = theNode + \"/\" + COLLECTION;\n    try (SolrClient solrClient = getHttpSolrClient(solrClientUrl)) {\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion()-1));\n      try {\n        QueryResponse rsp = solrClient.query(q);\n        log.info(\"error was expected\");\n      } catch (HttpSolrClient.RemoteSolrException e) {\n        sse = e;\n      }\n      assertNotNull(sse);\n      assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db96734b79e26d948b59f68bd4564c4836a71acf","date":1585375566,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudHttp2SolrClientTest#stateVersionParamTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudHttp2SolrClientTest#stateVersionParamTest().mjava","sourceNew":"  @Test\n  public void stateVersionParamTest() throws Exception {\n    CollectionAdminRequest.createCollection(COLLECTION, \"conf\", 2, 1).process(cluster.getSolrClient());\n    cluster.waitForActiveCollection(COLLECTION, 2, 2);\n\n    DocCollection coll = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n    Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n    SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n    BaseHttpSolrClient.RemoteSolrException sse = null;\n\n    final String url = r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\" + COLLECTION;\n    try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n\n      log.info(\"should work query, result {}\", solrClient.query(q));\n      //no problem\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + coll.getZNodeVersion());\n      log.info(\"2nd query , result {}\", solrClient.query(q));\n      //no error yet good\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n      QueryResponse rsp = solrClient.query(q);\n      Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n      assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n      assertNotNull(m.get(COLLECTION));\n    }\n\n    //now send the request to another node that does not serve the collection\n\n    Set<String> allNodesOfColl = new HashSet<>();\n    for (Slice slice : coll.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n      }\n    }\n    String theNode = null;\n    Set<String> liveNodes = cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes();\n    for (String s : liveNodes) {\n      String n = cluster.getSolrClient().getZkStateReader().getBaseUrlForNodeName(s);\n      if(!allNodesOfColl.contains(n)){\n        theNode = n;\n        break;\n      }\n    }\n    log.info(\"the node which does not serve this collection{} \",theNode);\n    assertNotNull(theNode);\n\n\n    final String solrClientUrl = theNode + \"/\" + COLLECTION;\n    try (SolrClient solrClient = getHttpSolrClient(solrClientUrl)) {\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion()-1));\n      try {\n        QueryResponse rsp = solrClient.query(q);\n        log.info(\"error was expected\");\n      } catch (BaseHttpSolrClient.RemoteSolrException e) {\n        sse = e;\n      }\n      assertNotNull(sse);\n      assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void stateVersionParamTest() throws Exception {\n    CollectionAdminRequest.createCollection(COLLECTION, \"conf\", 2, 1).process(cluster.getSolrClient());\n    cluster.waitForActiveCollection(COLLECTION, 2, 2);\n\n    DocCollection coll = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n    Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n    SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n    HttpSolrClient.RemoteSolrException sse = null;\n\n    final String url = r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\" + COLLECTION;\n    try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n\n      log.info(\"should work query, result {}\", solrClient.query(q));\n      //no problem\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + coll.getZNodeVersion());\n      log.info(\"2nd query , result {}\", solrClient.query(q));\n      //no error yet good\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n      QueryResponse rsp = solrClient.query(q);\n      Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n      assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n      assertNotNull(m.get(COLLECTION));\n    }\n\n    //now send the request to another node that does not serve the collection\n\n    Set<String> allNodesOfColl = new HashSet<>();\n    for (Slice slice : coll.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n      }\n    }\n    String theNode = null;\n    Set<String> liveNodes = cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes();\n    for (String s : liveNodes) {\n      String n = cluster.getSolrClient().getZkStateReader().getBaseUrlForNodeName(s);\n      if(!allNodesOfColl.contains(n)){\n        theNode = n;\n        break;\n      }\n    }\n    log.info(\"the node which does not serve this collection{} \",theNode);\n    assertNotNull(theNode);\n\n\n    final String solrClientUrl = theNode + \"/\" + COLLECTION;\n    try (SolrClient solrClient = getHttpSolrClient(solrClientUrl)) {\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion()-1));\n      try {\n        QueryResponse rsp = solrClient.query(q);\n        log.info(\"error was expected\");\n      } catch (HttpSolrClient.RemoteSolrException e) {\n        sse = e;\n      }\n      assertNotNull(sse);\n      assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6dc613ed6f75d1988140301ee8de8fdb056fa337","date":1588034757,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudHttp2SolrClientTest#stateVersionParamTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudHttp2SolrClientTest#stateVersionParamTest().mjava","sourceNew":"  @Test\n  public void stateVersionParamTest() throws Exception {\n    CollectionAdminRequest.createCollection(COLLECTION, \"conf\", 2, 1).process(cluster.getSolrClient());\n    cluster.waitForActiveCollection(COLLECTION, 2, 2);\n\n    DocCollection coll = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n    Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n    SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n    BaseHttpSolrClient.RemoteSolrException sse = null;\n\n    final String url = r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\" + COLLECTION;\n    try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n\n      if (log.isInfoEnabled()) {\n        log.info(\"should work query, result {}\", solrClient.query(q));\n      }\n      //no problem\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + coll.getZNodeVersion());\n      if (log.isInfoEnabled()) {\n        log.info(\"2nd query , result {}\", solrClient.query(q));\n      }\n      //no error yet good\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n      QueryResponse rsp = solrClient.query(q);\n      Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n      assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n      assertNotNull(m.get(COLLECTION));\n    }\n\n    //now send the request to another node that does not serve the collection\n\n    Set<String> allNodesOfColl = new HashSet<>();\n    for (Slice slice : coll.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n      }\n    }\n    String theNode = null;\n    Set<String> liveNodes = cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes();\n    for (String s : liveNodes) {\n      String n = cluster.getSolrClient().getZkStateReader().getBaseUrlForNodeName(s);\n      if(!allNodesOfColl.contains(n)){\n        theNode = n;\n        break;\n      }\n    }\n    log.info(\"the node which does not serve this collection{} \",theNode);\n    assertNotNull(theNode);\n\n\n    final String solrClientUrl = theNode + \"/\" + COLLECTION;\n    try (SolrClient solrClient = getHttpSolrClient(solrClientUrl)) {\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion()-1));\n      try {\n        QueryResponse rsp = solrClient.query(q);\n        log.info(\"error was expected\");\n      } catch (BaseHttpSolrClient.RemoteSolrException e) {\n        sse = e;\n      }\n      assertNotNull(sse);\n      assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void stateVersionParamTest() throws Exception {\n    CollectionAdminRequest.createCollection(COLLECTION, \"conf\", 2, 1).process(cluster.getSolrClient());\n    cluster.waitForActiveCollection(COLLECTION, 2, 2);\n\n    DocCollection coll = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n    Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n    SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n    BaseHttpSolrClient.RemoteSolrException sse = null;\n\n    final String url = r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\" + COLLECTION;\n    try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n\n      log.info(\"should work query, result {}\", solrClient.query(q));\n      //no problem\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + coll.getZNodeVersion());\n      log.info(\"2nd query , result {}\", solrClient.query(q));\n      //no error yet good\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n      QueryResponse rsp = solrClient.query(q);\n      Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n      assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n      assertNotNull(m.get(COLLECTION));\n    }\n\n    //now send the request to another node that does not serve the collection\n\n    Set<String> allNodesOfColl = new HashSet<>();\n    for (Slice slice : coll.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n      }\n    }\n    String theNode = null;\n    Set<String> liveNodes = cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes();\n    for (String s : liveNodes) {\n      String n = cluster.getSolrClient().getZkStateReader().getBaseUrlForNodeName(s);\n      if(!allNodesOfColl.contains(n)){\n        theNode = n;\n        break;\n      }\n    }\n    log.info(\"the node which does not serve this collection{} \",theNode);\n    assertNotNull(theNode);\n\n\n    final String solrClientUrl = theNode + \"/\" + COLLECTION;\n    try (SolrClient solrClient = getHttpSolrClient(solrClientUrl)) {\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion()-1));\n      try {\n        QueryResponse rsp = solrClient.query(q);\n        log.info(\"error was expected\");\n      } catch (BaseHttpSolrClient.RemoteSolrException e) {\n        sse = e;\n      }\n      assertNotNull(sse);\n      assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ba1b632c041956c93c41aa1143d16a567014891","date":1592328473,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudHttp2SolrClientTest#stateVersionParamTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudHttp2SolrClientTest#stateVersionParamTest().mjava","sourceNew":"  @Test\n  public void stateVersionParamTest() throws Exception {\n    CollectionAdminRequest.createCollection(COLLECTION, \"conf\", 2, 1).process(cluster.getSolrClient());\n    cluster.waitForActiveCollection(COLLECTION, 2, 2);\n\n    DocCollection coll = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n    Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n    SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n    BaseHttpSolrClient.RemoteSolrException sse = null;\n\n    final String url = r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\" + COLLECTION;\n    try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n\n      if (log.isInfoEnabled()) {\n        log.info(\"should work query, result {}\", solrClient.query(q));\n      }\n      //no problem\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + coll.getZNodeVersion());\n      if (log.isInfoEnabled()) {\n        log.info(\"2nd query , result {}\", solrClient.query(q));\n      }\n      //no error yet good\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n      QueryResponse rsp = solrClient.query(q);\n      @SuppressWarnings({\"rawtypes\"})\n      Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n      assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n      assertNotNull(m.get(COLLECTION));\n    }\n\n    //now send the request to another node that does not serve the collection\n\n    Set<String> allNodesOfColl = new HashSet<>();\n    for (Slice slice : coll.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n      }\n    }\n    String theNode = null;\n    Set<String> liveNodes = cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes();\n    for (String s : liveNodes) {\n      String n = cluster.getSolrClient().getZkStateReader().getBaseUrlForNodeName(s);\n      if(!allNodesOfColl.contains(n)){\n        theNode = n;\n        break;\n      }\n    }\n    log.info(\"the node which does not serve this collection{} \",theNode);\n    assertNotNull(theNode);\n\n\n    final String solrClientUrl = theNode + \"/\" + COLLECTION;\n    try (SolrClient solrClient = getHttpSolrClient(solrClientUrl)) {\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion()-1));\n      try {\n        QueryResponse rsp = solrClient.query(q);\n        log.info(\"error was expected\");\n      } catch (BaseHttpSolrClient.RemoteSolrException e) {\n        sse = e;\n      }\n      assertNotNull(sse);\n      assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void stateVersionParamTest() throws Exception {\n    CollectionAdminRequest.createCollection(COLLECTION, \"conf\", 2, 1).process(cluster.getSolrClient());\n    cluster.waitForActiveCollection(COLLECTION, 2, 2);\n\n    DocCollection coll = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n    Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n    SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n    BaseHttpSolrClient.RemoteSolrException sse = null;\n\n    final String url = r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\" + COLLECTION;\n    try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n\n      if (log.isInfoEnabled()) {\n        log.info(\"should work query, result {}\", solrClient.query(q));\n      }\n      //no problem\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + coll.getZNodeVersion());\n      if (log.isInfoEnabled()) {\n        log.info(\"2nd query , result {}\", solrClient.query(q));\n      }\n      //no error yet good\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n      QueryResponse rsp = solrClient.query(q);\n      Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n      assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n      assertNotNull(m.get(COLLECTION));\n    }\n\n    //now send the request to another node that does not serve the collection\n\n    Set<String> allNodesOfColl = new HashSet<>();\n    for (Slice slice : coll.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n      }\n    }\n    String theNode = null;\n    Set<String> liveNodes = cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes();\n    for (String s : liveNodes) {\n      String n = cluster.getSolrClient().getZkStateReader().getBaseUrlForNodeName(s);\n      if(!allNodesOfColl.contains(n)){\n        theNode = n;\n        break;\n      }\n    }\n    log.info(\"the node which does not serve this collection{} \",theNode);\n    assertNotNull(theNode);\n\n\n    final String solrClientUrl = theNode + \"/\" + COLLECTION;\n    try (SolrClient solrClient = getHttpSolrClient(solrClientUrl)) {\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion()-1));\n      try {\n        QueryResponse rsp = solrClient.query(q);\n        log.info(\"error was expected\");\n      } catch (BaseHttpSolrClient.RemoteSolrException e) {\n        sse = e;\n      }\n      assertNotNull(sse);\n      assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9ba1b632c041956c93c41aa1143d16a567014891":["6dc613ed6f75d1988140301ee8de8fdb056fa337"],"6dc613ed6f75d1988140301ee8de8fdb056fa337":["db96734b79e26d948b59f68bd4564c4836a71acf"],"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9":["0544142c22eb88b6d8b3817f2e1190156aa4f9af"],"0544142c22eb88b6d8b3817f2e1190156aa4f9af":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bb9c3baacabd473e8ecd6c4948aabacead49b88e":["a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9"],"db96734b79e26d948b59f68bd4564c4836a71acf":["bb9c3baacabd473e8ecd6c4948aabacead49b88e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9ba1b632c041956c93c41aa1143d16a567014891"]},"commit2Childs":{"9ba1b632c041956c93c41aa1143d16a567014891":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6dc613ed6f75d1988140301ee8de8fdb056fa337":["9ba1b632c041956c93c41aa1143d16a567014891"],"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9":["bb9c3baacabd473e8ecd6c4948aabacead49b88e"],"0544142c22eb88b6d8b3817f2e1190156aa4f9af":["a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0544142c22eb88b6d8b3817f2e1190156aa4f9af"],"bb9c3baacabd473e8ecd6c4948aabacead49b88e":["db96734b79e26d948b59f68bd4564c4836a71acf"],"db96734b79e26d948b59f68bd4564c4836a71acf":["6dc613ed6f75d1988140301ee8de8fdb056fa337"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}