{"path":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterOnJRECrash#checkIndexes(Path).mjava","commits":[{"id":"f4abec28b874149a7223e32cc7a01704c27790de","date":1410644789,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterOnJRECrash#checkIndexes(Path).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Recursively looks for indexes underneath <code>file</code>,\n   * and runs checkindex on them. returns true if it found any indexes.\n   */\n  public boolean checkIndexes(Path path) throws IOException {\n    final AtomicBoolean found = new AtomicBoolean();\n    Files.walkFileTree(path, new SimpleFileVisitor<Path>() {\n      @Override\n      public FileVisitResult postVisitDirectory(Path dirPath, IOException exc) throws IOException {\n        if (exc != null) {\n          throw exc;\n        } else {\n          BaseDirectoryWrapper dir = newFSDirectory(dirPath);\n          dir.setCheckIndexOnClose(false); // don't double-checkindex\n          if (DirectoryReader.indexExists(dir)) {\n            if (VERBOSE) {\n              System.err.println(\"Checking index: \" + dirPath);\n            }\n            // LUCENE-4738: if we crashed while writing first\n            // commit it's possible index will be corrupt (by\n            // design we don't try to be smart about this case\n            // since that too risky):\n            if (SegmentInfos.getLastCommitGeneration(dir) > 1) {\n              TestUtil.checkIndex(dir);\n            }\n            dir.close();\n            found.set(true);\n          }\n          return FileVisitResult.CONTINUE;\n        }\n      }\n    });\n    return found.get();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7582541c80788787198339d618c691589b5611ee","date":1410716511,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterOnJRECrash#checkIndexes(Path).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterOnJRECrash#checkIndexes(Path).mjava","sourceNew":"  /**\n   * Recursively looks for indexes underneath <code>file</code>,\n   * and runs checkindex on them. returns true if it found any indexes.\n   */\n  public boolean checkIndexes(Path path) throws IOException {\n    final AtomicBoolean found = new AtomicBoolean();\n    Files.walkFileTree(path, new SimpleFileVisitor<Path>() {\n      @Override\n      public FileVisitResult postVisitDirectory(Path dirPath, IOException exc) throws IOException {\n        if (exc != null) {\n          throw exc;\n        } else {\n          try (BaseDirectoryWrapper dir = newFSDirectory(dirPath)) {\n            dir.setCheckIndexOnClose(false); // don't double-checkindex\n            if (DirectoryReader.indexExists(dir)) {\n              if (VERBOSE) {\n                System.err.println(\"Checking index: \" + dirPath);\n              }\n              // LUCENE-4738: if we crashed while writing first\n              // commit it's possible index will be corrupt (by\n              // design we don't try to be smart about this case\n              // since that too risky):\n              if (SegmentInfos.getLastCommitGeneration(dir) > 1) {\n                TestUtil.checkIndex(dir);\n              }\n              found.set(true);\n            }\n          }\n          return FileVisitResult.CONTINUE;\n        }\n      }\n    });\n    return found.get();\n  }\n\n","sourceOld":"  /**\n   * Recursively looks for indexes underneath <code>file</code>,\n   * and runs checkindex on them. returns true if it found any indexes.\n   */\n  public boolean checkIndexes(Path path) throws IOException {\n    final AtomicBoolean found = new AtomicBoolean();\n    Files.walkFileTree(path, new SimpleFileVisitor<Path>() {\n      @Override\n      public FileVisitResult postVisitDirectory(Path dirPath, IOException exc) throws IOException {\n        if (exc != null) {\n          throw exc;\n        } else {\n          BaseDirectoryWrapper dir = newFSDirectory(dirPath);\n          dir.setCheckIndexOnClose(false); // don't double-checkindex\n          if (DirectoryReader.indexExists(dir)) {\n            if (VERBOSE) {\n              System.err.println(\"Checking index: \" + dirPath);\n            }\n            // LUCENE-4738: if we crashed while writing first\n            // commit it's possible index will be corrupt (by\n            // design we don't try to be smart about this case\n            // since that too risky):\n            if (SegmentInfos.getLastCommitGeneration(dir) > 1) {\n              TestUtil.checkIndex(dir);\n            }\n            dir.close();\n            found.set(true);\n          }\n          return FileVisitResult.CONTINUE;\n        }\n      }\n    });\n    return found.get();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7582541c80788787198339d618c691589b5611ee":["f4abec28b874149a7223e32cc7a01704c27790de"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f4abec28b874149a7223e32cc7a01704c27790de":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7582541c80788787198339d618c691589b5611ee"]},"commit2Childs":{"7582541c80788787198339d618c691589b5611ee":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f4abec28b874149a7223e32cc7a01704c27790de"],"f4abec28b874149a7223e32cc7a01704c27790de":["7582541c80788787198339d618c691589b5611ee"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}