{"path":"lucene/analysis/kuromoji/src/test/org/apache/lucene/analysis/ja/dict/TokenInfoDictionaryTest#testEnumerateAll().mjava","commits":[{"id":"05feb7eb5e91cb64742ce32b2ca3f02433530446","date":1561602840,"type":1,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/analysis/kuromoji/src/test/org/apache/lucene/analysis/ja/dict/TokenInfoDictionaryTest#testEnumerateAll().mjava","pathOld":"lucene/analysis/kuromoji/src/test/org/apache/lucene/analysis/ja/dict/TestTokenInfoDictionary#testEnumerateAll().mjava","sourceNew":"  /** enumerates the entire FST/lookup data and just does basic sanity checks */\n  public void testEnumerateAll() throws Exception {\n    // just for debugging\n    int numTerms = 0;\n    int numWords = 0;\n    int lastWordId = -1;\n    int lastSourceId = -1;\n    TokenInfoDictionary tid = TokenInfoDictionary.getInstance();\n    ConnectionCosts matrix = ConnectionCosts.getInstance();\n    FST<Long> fst = tid.getFST().getInternalFST();\n    IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n    IntsRefFSTEnum.InputOutput<Long> mapping;\n    IntsRef scratch = new IntsRef();\n    while ((mapping = fstEnum.next()) != null) {\n      numTerms++;\n      IntsRef input = mapping.input;\n      char[] chars = new char[input.length];\n      for (int i = 0; i < chars.length; i++) {\n        chars[i] = (char)input.ints[input.offset+i];\n      }\n      assertTrue(UnicodeUtil.validUTF16String(new String(chars)));\n\n      Long output = mapping.output;\n      int sourceId = output.intValue();\n      // we walk in order, terms, sourceIds, and wordIds should always be increasing\n      assertTrue(sourceId > lastSourceId);\n      lastSourceId = sourceId;\n      tid.lookupWordIds(sourceId, scratch);\n      for (int i = 0; i < scratch.length; i++) {\n        numWords++;\n        int wordId = scratch.ints[scratch.offset+i];\n        assertTrue(wordId > lastWordId);\n        lastWordId = wordId;\n\n        String baseForm = tid.getBaseForm(wordId, chars, 0, chars.length);\n        assertTrue(baseForm == null || UnicodeUtil.validUTF16String(baseForm));\n\n        String inflectionForm = tid.getInflectionForm(wordId);\n        assertTrue(inflectionForm == null || UnicodeUtil.validUTF16String(inflectionForm));\n        if (inflectionForm != null) {\n          // check that it's actually an ipadic inflection form\n          assertNotNull(ToStringUtil.getInflectedFormTranslation(inflectionForm));\n        }\n\n        String inflectionType = tid.getInflectionType(wordId);\n        assertTrue(inflectionType == null || UnicodeUtil.validUTF16String(inflectionType));\n        if (inflectionType != null) {\n          // check that it's actually an ipadic inflection type\n          assertNotNull(ToStringUtil.getInflectionTypeTranslation(inflectionType));\n        }\n\n        int leftId = tid.getLeftId(wordId);\n        int rightId = tid.getRightId(wordId);\n\n        matrix.get(rightId, leftId);\n\n        tid.getWordCost(wordId);\n\n        String pos = tid.getPartOfSpeech(wordId);\n        assertNotNull(pos);\n        assertTrue(UnicodeUtil.validUTF16String(pos));\n        // check that it's actually an ipadic pos tag\n        assertNotNull(ToStringUtil.getPOSTranslation(pos));\n\n        String pronunciation = tid.getPronunciation(wordId, chars, 0, chars.length);\n        assertNotNull(pronunciation);\n        assertTrue(UnicodeUtil.validUTF16String(pronunciation));\n\n        String reading = tid.getReading(wordId, chars, 0, chars.length);\n        assertNotNull(reading);\n        assertTrue(UnicodeUtil.validUTF16String(reading));\n      }\n    }\n    if (VERBOSE) {\n      System.out.println(\"checked \" + numTerms + \" terms, \" + numWords + \" words.\");\n    }\n  }\n\n","sourceOld":"  /** enumerates the entire FST/lookup data and just does basic sanity checks */\n  public void testEnumerateAll() throws Exception {\n    // just for debugging\n    int numTerms = 0;\n    int numWords = 0;\n    int lastWordId = -1;\n    int lastSourceId = -1;\n    TokenInfoDictionary tid = TokenInfoDictionary.getInstance();\n    ConnectionCosts matrix = ConnectionCosts.getInstance();\n    FST<Long> fst = tid.getFST().getInternalFST();\n    IntsRefFSTEnum<Long> fstEnum = new IntsRefFSTEnum<>(fst);\n    InputOutput<Long> mapping;\n    IntsRef scratch = new IntsRef();\n    while ((mapping = fstEnum.next()) != null) {\n      numTerms++;\n      IntsRef input = mapping.input;\n      char chars[] = new char[input.length];\n      for (int i = 0; i < chars.length; i++) {\n        chars[i] = (char)input.ints[input.offset+i];\n      }\n      assertTrue(UnicodeUtil.validUTF16String(new String(chars)));\n      \n      Long output = mapping.output;\n      int sourceId = output.intValue();\n      // we walk in order, terms, sourceIds, and wordIds should always be increasing\n      assertTrue(sourceId > lastSourceId);\n      lastSourceId = sourceId;\n      tid.lookupWordIds(sourceId, scratch);\n      for (int i = 0; i < scratch.length; i++) {\n        numWords++;\n        int wordId = scratch.ints[scratch.offset+i];\n        assertTrue(wordId > lastWordId);\n        lastWordId = wordId;\n         \n        String baseForm = tid.getBaseForm(wordId, chars, 0, chars.length);\n        assertTrue(baseForm == null || UnicodeUtil.validUTF16String(baseForm));\n        \n        String inflectionForm = tid.getInflectionForm(wordId);\n        assertTrue(inflectionForm == null || UnicodeUtil.validUTF16String(inflectionForm));\n        if (inflectionForm != null) {\n          // check that it's actually an ipadic inflection form\n          assertNotNull(ToStringUtil.getInflectedFormTranslation(inflectionForm));          \n        }\n        \n        String inflectionType = tid.getInflectionType(wordId);\n        assertTrue(inflectionType == null || UnicodeUtil.validUTF16String(inflectionType));\n        if (inflectionType != null) {\n          // check that it's actually an ipadic inflection type\n          assertNotNull(ToStringUtil.getInflectionTypeTranslation(inflectionType));\n        }\n        \n        int leftId = tid.getLeftId(wordId);\n        int rightId = tid.getRightId(wordId);\n        \n        matrix.get(rightId, leftId);\n        \n        tid.getWordCost(wordId);\n        \n        String pos = tid.getPartOfSpeech(wordId);\n        assertNotNull(pos);\n        assertTrue(UnicodeUtil.validUTF16String(pos));\n        // check that it's actually an ipadic pos tag\n        assertNotNull(ToStringUtil.getPOSTranslation(pos));\n        \n        String pronunciation = tid.getPronunciation(wordId, chars, 0, chars.length);\n        assertNotNull(pronunciation);\n        assertTrue(UnicodeUtil.validUTF16String(pronunciation));\n        \n        String reading = tid.getReading(wordId, chars, 0, chars.length);\n        assertNotNull(reading);\n        assertTrue(UnicodeUtil.validUTF16String(reading));\n      }\n    }\n    if (VERBOSE) {\n      System.out.println(\"checked \" + numTerms + \" terms, \" + numWords + \" words.\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"05feb7eb5e91cb64742ce32b2ca3f02433530446":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["05feb7eb5e91cb64742ce32b2ca3f02433530446"]},"commit2Childs":{"05feb7eb5e91cb64742ce32b2ca3f02433530446":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["05feb7eb5e91cb64742ce32b2ca3f02433530446"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}