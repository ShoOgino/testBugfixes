{"path":"src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long,TermVectorMapper).mjava","commits":[{"id":"352bfe1fae83b92d1562f01c057bfbe6f5af3ddb","date":1185160645,"type":1,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long,TermVectorMapper).mjava","pathOld":"src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long).mjava","sourceNew":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @param mapper The mapper used to map the TermVector\n   * @return The TermVector located at that position\n   * @throws IOException\n\n   */ \n  private void readTermVector(String field, long tvfPointer, TermVectorMapper mapper)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector. However, this should never occur!\n    if (numTerms == 0) \n      return;\n    \n    boolean storePositions;\n    boolean storeOffsets;\n    \n    if(tvfFormat == TermVectorsWriter.FORMAT_VERSION){\n      byte bits = tvf.readByte();\n      storePositions = (bits & TermVectorsWriter.STORE_POSITIONS_WITH_TERMVECTOR) != 0;\n      storeOffsets = (bits & TermVectorsWriter.STORE_OFFSET_WITH_TERMVECTOR) != 0;\n    }\n    else{\n      tvf.readVInt();\n      storePositions = false;\n      storeOffsets = false;\n    }\n    mapper.setExpectations(field, numTerms, storeOffsets, storePositions);\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    char [] buffer = new char[10];    // init the buffer with a length of 10 character\n    char[] previousBuffer = {};\n    \n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n      if (buffer.length < totalLength) {  // increase buffer\n        buffer = null;    // give a hint to garbage collector\n        buffer = new char[totalLength];\n        \n        if (start > 0)  // just copy if necessary\n          System.arraycopy(previousBuffer, 0, buffer, 0, start);\n      }\n      \n      tvf.readChars(buffer, start, deltaLength);\n      String term = new String(buffer, 0, totalLength);\n      previousBuffer = buffer;\n      int freq = tvf.readVInt();\n      int [] positions = null;\n      if (storePositions) { //read in the positions\n        //does the mapper even care about positions?\n        if (mapper.isIgnoringPositions() == false) {\n          positions = new int[freq];\n          int prevPosition = 0;\n          for (int j = 0; j < freq; j++)\n          {\n            positions[j] = prevPosition + tvf.readVInt();\n            prevPosition = positions[j];\n          }\n        } else {\n          //we need to skip over the positions.  Since these are VInts, I don't believe there is anyway to know for sure how far to skip\n          //\n          for (int j = 0; j < freq; j++)\n          {\n            tvf.readVInt();\n          }\n        }\n      }\n      TermVectorOffsetInfo[] offsets = null;\n      if (storeOffsets) {\n        //does the mapper even care about offsets?\n        if (mapper.isIgnoringOffsets() == false) {\n          offsets = new TermVectorOffsetInfo[freq];\n          int prevOffset = 0;\n          for (int j = 0; j < freq; j++) {\n            int startOffset = prevOffset + tvf.readVInt();\n            int endOffset = startOffset + tvf.readVInt();\n            offsets[j] = new TermVectorOffsetInfo(startOffset, endOffset);\n            prevOffset = endOffset;\n          }\n        } else {\n          for (int j = 0; j < freq; j++){\n            tvf.readVInt();\n            tvf.readVInt();\n          }\n        }\n      }\n      mapper.map(term, freq, offsets, positions);\n    }\n  }\n\n","sourceOld":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @return The TermVector located at that position\n   * @throws IOException\n   */ \n  private SegmentTermVector readTermVector(String field, long tvfPointer)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector. However, this should never occur!\n    if (numTerms == 0) \n      return new SegmentTermVector(field, null, null);\n    \n    boolean storePositions;\n    boolean storeOffsets;\n    \n    if(tvfFormat == TermVectorsWriter.FORMAT_VERSION){\n      byte bits = tvf.readByte();\n      storePositions = (bits & TermVectorsWriter.STORE_POSITIONS_WITH_TERMVECTOR) != 0;\n      storeOffsets = (bits & TermVectorsWriter.STORE_OFFSET_WITH_TERMVECTOR) != 0;\n    }\n    else{\n      tvf.readVInt();\n      storePositions = false;\n      storeOffsets = false;\n    }\n\n    String terms[] = new String[numTerms];\n    int termFreqs[] = new int[numTerms];\n    \n    //  we may not need these, but declare them\n    int positions[][] = null;\n    TermVectorOffsetInfo offsets[][] = null;\n    if(storePositions)\n      positions = new int[numTerms][];\n    if(storeOffsets)\n      offsets = new TermVectorOffsetInfo[numTerms][];\n    \n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    char [] buffer = new char[10];    // init the buffer with a length of 10 character\n    char[] previousBuffer = {};\n    \n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n      if (buffer.length < totalLength) {  // increase buffer\n        buffer = null;    // give a hint to garbage collector\n        buffer = new char[totalLength];\n        \n        if (start > 0)  // just copy if necessary\n          System.arraycopy(previousBuffer, 0, buffer, 0, start);\n      }\n      \n      tvf.readChars(buffer, start, deltaLength);\n      terms[i] = new String(buffer, 0, totalLength);\n      previousBuffer = buffer;\n      int freq = tvf.readVInt();\n      termFreqs[i] = freq;\n      \n      if (storePositions) { //read in the positions\n        int [] pos = new int[freq];\n        positions[i] = pos;\n        int prevPosition = 0;\n        for (int j = 0; j < freq; j++)\n        {\n          pos[j] = prevPosition + tvf.readVInt();\n          prevPosition = pos[j];\n        }\n      }\n      \n      if (storeOffsets) {\n        TermVectorOffsetInfo[] offs = new TermVectorOffsetInfo[freq];\n        offsets[i] = offs;\n        int prevOffset = 0;\n        for (int j = 0; j < freq; j++) {\n          int startOffset = prevOffset + tvf.readVInt();\n          int endOffset = startOffset + tvf.readVInt();\n          offs[j] = new TermVectorOffsetInfo(startOffset, endOffset);\n          prevOffset = endOffset;\n        }\n      }\n    }\n    \n    SegmentTermVector tv;\n    if (storePositions || storeOffsets){\n      tv = new SegmentTermPositionVector(field, terms, termFreqs, positions, offsets);\n    }\n    else {\n      tv = new SegmentTermVector(field, terms, termFreqs);\n    }\n    return tv;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"11764865fb318bf86302eab36bdf9cd00c50c110","date":1190109214,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long,TermVectorMapper).mjava","pathOld":"src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long,TermVectorMapper).mjava","sourceNew":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @param mapper The mapper used to map the TermVector\n   * @return The TermVector located at that position\n   * @throws IOException\n\n   */ \n  private void readTermVector(String field, long tvfPointer, TermVectorMapper mapper)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector. However, this should never occur!\n    if (numTerms == 0) \n      return;\n    \n    boolean storePositions;\n    boolean storeOffsets;\n    \n    if(tvfFormat == FORMAT_VERSION){\n      byte bits = tvf.readByte();\n      storePositions = (bits & STORE_POSITIONS_WITH_TERMVECTOR) != 0;\n      storeOffsets = (bits & STORE_OFFSET_WITH_TERMVECTOR) != 0;\n    }\n    else{\n      tvf.readVInt();\n      storePositions = false;\n      storeOffsets = false;\n    }\n    mapper.setExpectations(field, numTerms, storeOffsets, storePositions);\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    char [] buffer = new char[10];    // init the buffer with a length of 10 character\n    char[] previousBuffer = {};\n    \n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n      if (buffer.length < totalLength) {  // increase buffer\n        buffer = null;    // give a hint to garbage collector\n        buffer = new char[totalLength];\n        \n        if (start > 0)  // just copy if necessary\n          System.arraycopy(previousBuffer, 0, buffer, 0, start);\n      }\n      \n      tvf.readChars(buffer, start, deltaLength);\n      String term = new String(buffer, 0, totalLength);\n      previousBuffer = buffer;\n      int freq = tvf.readVInt();\n      int [] positions = null;\n      if (storePositions) { //read in the positions\n        //does the mapper even care about positions?\n        if (mapper.isIgnoringPositions() == false) {\n          positions = new int[freq];\n          int prevPosition = 0;\n          for (int j = 0; j < freq; j++)\n          {\n            positions[j] = prevPosition + tvf.readVInt();\n            prevPosition = positions[j];\n          }\n        } else {\n          //we need to skip over the positions.  Since these are VInts, I don't believe there is anyway to know for sure how far to skip\n          //\n          for (int j = 0; j < freq; j++)\n          {\n            tvf.readVInt();\n          }\n        }\n      }\n      TermVectorOffsetInfo[] offsets = null;\n      if (storeOffsets) {\n        //does the mapper even care about offsets?\n        if (mapper.isIgnoringOffsets() == false) {\n          offsets = new TermVectorOffsetInfo[freq];\n          int prevOffset = 0;\n          for (int j = 0; j < freq; j++) {\n            int startOffset = prevOffset + tvf.readVInt();\n            int endOffset = startOffset + tvf.readVInt();\n            offsets[j] = new TermVectorOffsetInfo(startOffset, endOffset);\n            prevOffset = endOffset;\n          }\n        } else {\n          for (int j = 0; j < freq; j++){\n            tvf.readVInt();\n            tvf.readVInt();\n          }\n        }\n      }\n      mapper.map(term, freq, offsets, positions);\n    }\n  }\n\n","sourceOld":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @param mapper The mapper used to map the TermVector\n   * @return The TermVector located at that position\n   * @throws IOException\n\n   */ \n  private void readTermVector(String field, long tvfPointer, TermVectorMapper mapper)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector. However, this should never occur!\n    if (numTerms == 0) \n      return;\n    \n    boolean storePositions;\n    boolean storeOffsets;\n    \n    if(tvfFormat == TermVectorsWriter.FORMAT_VERSION){\n      byte bits = tvf.readByte();\n      storePositions = (bits & TermVectorsWriter.STORE_POSITIONS_WITH_TERMVECTOR) != 0;\n      storeOffsets = (bits & TermVectorsWriter.STORE_OFFSET_WITH_TERMVECTOR) != 0;\n    }\n    else{\n      tvf.readVInt();\n      storePositions = false;\n      storeOffsets = false;\n    }\n    mapper.setExpectations(field, numTerms, storeOffsets, storePositions);\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    char [] buffer = new char[10];    // init the buffer with a length of 10 character\n    char[] previousBuffer = {};\n    \n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n      if (buffer.length < totalLength) {  // increase buffer\n        buffer = null;    // give a hint to garbage collector\n        buffer = new char[totalLength];\n        \n        if (start > 0)  // just copy if necessary\n          System.arraycopy(previousBuffer, 0, buffer, 0, start);\n      }\n      \n      tvf.readChars(buffer, start, deltaLength);\n      String term = new String(buffer, 0, totalLength);\n      previousBuffer = buffer;\n      int freq = tvf.readVInt();\n      int [] positions = null;\n      if (storePositions) { //read in the positions\n        //does the mapper even care about positions?\n        if (mapper.isIgnoringPositions() == false) {\n          positions = new int[freq];\n          int prevPosition = 0;\n          for (int j = 0; j < freq; j++)\n          {\n            positions[j] = prevPosition + tvf.readVInt();\n            prevPosition = positions[j];\n          }\n        } else {\n          //we need to skip over the positions.  Since these are VInts, I don't believe there is anyway to know for sure how far to skip\n          //\n          for (int j = 0; j < freq; j++)\n          {\n            tvf.readVInt();\n          }\n        }\n      }\n      TermVectorOffsetInfo[] offsets = null;\n      if (storeOffsets) {\n        //does the mapper even care about offsets?\n        if (mapper.isIgnoringOffsets() == false) {\n          offsets = new TermVectorOffsetInfo[freq];\n          int prevOffset = 0;\n          for (int j = 0; j < freq; j++) {\n            int startOffset = prevOffset + tvf.readVInt();\n            int endOffset = startOffset + tvf.readVInt();\n            offsets[j] = new TermVectorOffsetInfo(startOffset, endOffset);\n            prevOffset = endOffset;\n          }\n        } else {\n          for (int j = 0; j < freq; j++){\n            tvf.readVInt();\n            tvf.readVInt();\n          }\n        }\n      }\n      mapper.map(term, freq, offsets, positions);\n    }\n  }\n\n","bugFix":["352bfe1fae83b92d1562f01c057bfbe6f5af3ddb"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b3d08461c77d39c25ea6ff0cd05b32f948fa2a33","date":1201260752,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long,TermVectorMapper).mjava","pathOld":"src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long,TermVectorMapper).mjava","sourceNew":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @param mapper The mapper used to map the TermVector\n   * @return The TermVector located at that position\n   * @throws IOException\n\n   */ \n  private void readTermVector(String field, long tvfPointer, TermVectorMapper mapper)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector. However, this should never occur!\n    if (numTerms == 0) \n      return;\n    \n    boolean storePositions;\n    boolean storeOffsets;\n    \n    if (format >= FORMAT_VERSION){\n      byte bits = tvf.readByte();\n      storePositions = (bits & STORE_POSITIONS_WITH_TERMVECTOR) != 0;\n      storeOffsets = (bits & STORE_OFFSET_WITH_TERMVECTOR) != 0;\n    }\n    else{\n      tvf.readVInt();\n      storePositions = false;\n      storeOffsets = false;\n    }\n    mapper.setExpectations(field, numTerms, storeOffsets, storePositions);\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    char [] buffer = new char[10];    // init the buffer with a length of 10 character\n    char[] previousBuffer = {};\n    \n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n      if (buffer.length < totalLength) {  // increase buffer\n        buffer = null;    // give a hint to garbage collector\n        buffer = new char[totalLength];\n        \n        if (start > 0)  // just copy if necessary\n          System.arraycopy(previousBuffer, 0, buffer, 0, start);\n      }\n      \n      tvf.readChars(buffer, start, deltaLength);\n      String term = new String(buffer, 0, totalLength);\n      previousBuffer = buffer;\n      int freq = tvf.readVInt();\n      int [] positions = null;\n      if (storePositions) { //read in the positions\n        //does the mapper even care about positions?\n        if (mapper.isIgnoringPositions() == false) {\n          positions = new int[freq];\n          int prevPosition = 0;\n          for (int j = 0; j < freq; j++)\n          {\n            positions[j] = prevPosition + tvf.readVInt();\n            prevPosition = positions[j];\n          }\n        } else {\n          //we need to skip over the positions.  Since these are VInts, I don't believe there is anyway to know for sure how far to skip\n          //\n          for (int j = 0; j < freq; j++)\n          {\n            tvf.readVInt();\n          }\n        }\n      }\n      TermVectorOffsetInfo[] offsets = null;\n      if (storeOffsets) {\n        //does the mapper even care about offsets?\n        if (mapper.isIgnoringOffsets() == false) {\n          offsets = new TermVectorOffsetInfo[freq];\n          int prevOffset = 0;\n          for (int j = 0; j < freq; j++) {\n            int startOffset = prevOffset + tvf.readVInt();\n            int endOffset = startOffset + tvf.readVInt();\n            offsets[j] = new TermVectorOffsetInfo(startOffset, endOffset);\n            prevOffset = endOffset;\n          }\n        } else {\n          for (int j = 0; j < freq; j++){\n            tvf.readVInt();\n            tvf.readVInt();\n          }\n        }\n      }\n      mapper.map(term, freq, offsets, positions);\n    }\n  }\n\n","sourceOld":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @param mapper The mapper used to map the TermVector\n   * @return The TermVector located at that position\n   * @throws IOException\n\n   */ \n  private void readTermVector(String field, long tvfPointer, TermVectorMapper mapper)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector. However, this should never occur!\n    if (numTerms == 0) \n      return;\n    \n    boolean storePositions;\n    boolean storeOffsets;\n    \n    if(tvfFormat == FORMAT_VERSION){\n      byte bits = tvf.readByte();\n      storePositions = (bits & STORE_POSITIONS_WITH_TERMVECTOR) != 0;\n      storeOffsets = (bits & STORE_OFFSET_WITH_TERMVECTOR) != 0;\n    }\n    else{\n      tvf.readVInt();\n      storePositions = false;\n      storeOffsets = false;\n    }\n    mapper.setExpectations(field, numTerms, storeOffsets, storePositions);\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    char [] buffer = new char[10];    // init the buffer with a length of 10 character\n    char[] previousBuffer = {};\n    \n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n      if (buffer.length < totalLength) {  // increase buffer\n        buffer = null;    // give a hint to garbage collector\n        buffer = new char[totalLength];\n        \n        if (start > 0)  // just copy if necessary\n          System.arraycopy(previousBuffer, 0, buffer, 0, start);\n      }\n      \n      tvf.readChars(buffer, start, deltaLength);\n      String term = new String(buffer, 0, totalLength);\n      previousBuffer = buffer;\n      int freq = tvf.readVInt();\n      int [] positions = null;\n      if (storePositions) { //read in the positions\n        //does the mapper even care about positions?\n        if (mapper.isIgnoringPositions() == false) {\n          positions = new int[freq];\n          int prevPosition = 0;\n          for (int j = 0; j < freq; j++)\n          {\n            positions[j] = prevPosition + tvf.readVInt();\n            prevPosition = positions[j];\n          }\n        } else {\n          //we need to skip over the positions.  Since these are VInts, I don't believe there is anyway to know for sure how far to skip\n          //\n          for (int j = 0; j < freq; j++)\n          {\n            tvf.readVInt();\n          }\n        }\n      }\n      TermVectorOffsetInfo[] offsets = null;\n      if (storeOffsets) {\n        //does the mapper even care about offsets?\n        if (mapper.isIgnoringOffsets() == false) {\n          offsets = new TermVectorOffsetInfo[freq];\n          int prevOffset = 0;\n          for (int j = 0; j < freq; j++) {\n            int startOffset = prevOffset + tvf.readVInt();\n            int endOffset = startOffset + tvf.readVInt();\n            offsets[j] = new TermVectorOffsetInfo(startOffset, endOffset);\n            prevOffset = endOffset;\n          }\n        } else {\n          for (int j = 0; j < freq; j++){\n            tvf.readVInt();\n            tvf.readVInt();\n          }\n        }\n      }\n      mapper.map(term, freq, offsets, positions);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dbb7b6f10bff9eedd5c9bc6cf9222ffbb2df74d4","date":1206538765,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long,TermVectorMapper).mjava","pathOld":"src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long,TermVectorMapper).mjava","sourceNew":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @param mapper The mapper used to map the TermVector\n   * @return The TermVector located at that position\n   * @throws IOException\n\n   */ \n  private void readTermVector(String field, long tvfPointer, TermVectorMapper mapper)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector. However, this should never occur!\n    if (numTerms == 0) \n      return;\n    \n    boolean storePositions;\n    boolean storeOffsets;\n    \n    if (format >= FORMAT_VERSION){\n      byte bits = tvf.readByte();\n      storePositions = (bits & STORE_POSITIONS_WITH_TERMVECTOR) != 0;\n      storeOffsets = (bits & STORE_OFFSET_WITH_TERMVECTOR) != 0;\n    }\n    else{\n      tvf.readVInt();\n      storePositions = false;\n      storeOffsets = false;\n    }\n    mapper.setExpectations(field, numTerms, storeOffsets, storePositions);\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    byte[] byteBuffer;\n    char[] charBuffer;\n    final boolean preUTF8 = format < FORMAT_UTF8_LENGTH_IN_BYTES;\n\n    // init the buffers\n    if (preUTF8) {\n      charBuffer = new char[10];\n      byteBuffer = null;\n    } else {\n      charBuffer = null;\n      byteBuffer = new byte[20];\n    }\n\n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n\n      final String term;\n      \n      if (preUTF8) {\n        // Term stored as java chars\n        if (charBuffer.length < totalLength) {\n          char[] newCharBuffer = new char[(int) (1.5*totalLength)];\n          System.arraycopy(charBuffer, 0, newCharBuffer, 0, start);\n          charBuffer = newCharBuffer;\n        }\n        tvf.readChars(charBuffer, start, deltaLength);\n        term = new String(charBuffer, 0, totalLength);\n      } else {\n        // Term stored as utf8 bytes\n        if (byteBuffer.length < totalLength) {\n          byte[] newByteBuffer = new byte[(int) (1.5*totalLength)];\n          System.arraycopy(byteBuffer, 0, newByteBuffer, 0, start);\n          byteBuffer = newByteBuffer;\n        }\n        tvf.readBytes(byteBuffer, start, deltaLength);\n        term = new String(byteBuffer, 0, totalLength, \"UTF-8\");\n      }\n      int freq = tvf.readVInt();\n      int [] positions = null;\n      if (storePositions) { //read in the positions\n        //does the mapper even care about positions?\n        if (mapper.isIgnoringPositions() == false) {\n          positions = new int[freq];\n          int prevPosition = 0;\n          for (int j = 0; j < freq; j++)\n          {\n            positions[j] = prevPosition + tvf.readVInt();\n            prevPosition = positions[j];\n          }\n        } else {\n          //we need to skip over the positions.  Since these are VInts, I don't believe there is anyway to know for sure how far to skip\n          //\n          for (int j = 0; j < freq; j++)\n          {\n            tvf.readVInt();\n          }\n        }\n      }\n      TermVectorOffsetInfo[] offsets = null;\n      if (storeOffsets) {\n        //does the mapper even care about offsets?\n        if (mapper.isIgnoringOffsets() == false) {\n          offsets = new TermVectorOffsetInfo[freq];\n          int prevOffset = 0;\n          for (int j = 0; j < freq; j++) {\n            int startOffset = prevOffset + tvf.readVInt();\n            int endOffset = startOffset + tvf.readVInt();\n            offsets[j] = new TermVectorOffsetInfo(startOffset, endOffset);\n            prevOffset = endOffset;\n          }\n        } else {\n          for (int j = 0; j < freq; j++){\n            tvf.readVInt();\n            tvf.readVInt();\n          }\n        }\n      }\n      mapper.map(term, freq, offsets, positions);\n    }\n  }\n\n","sourceOld":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @param mapper The mapper used to map the TermVector\n   * @return The TermVector located at that position\n   * @throws IOException\n\n   */ \n  private void readTermVector(String field, long tvfPointer, TermVectorMapper mapper)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector. However, this should never occur!\n    if (numTerms == 0) \n      return;\n    \n    boolean storePositions;\n    boolean storeOffsets;\n    \n    if (format >= FORMAT_VERSION){\n      byte bits = tvf.readByte();\n      storePositions = (bits & STORE_POSITIONS_WITH_TERMVECTOR) != 0;\n      storeOffsets = (bits & STORE_OFFSET_WITH_TERMVECTOR) != 0;\n    }\n    else{\n      tvf.readVInt();\n      storePositions = false;\n      storeOffsets = false;\n    }\n    mapper.setExpectations(field, numTerms, storeOffsets, storePositions);\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    char [] buffer = new char[10];    // init the buffer with a length of 10 character\n    char[] previousBuffer = {};\n    \n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n      if (buffer.length < totalLength) {  // increase buffer\n        buffer = null;    // give a hint to garbage collector\n        buffer = new char[totalLength];\n        \n        if (start > 0)  // just copy if necessary\n          System.arraycopy(previousBuffer, 0, buffer, 0, start);\n      }\n      \n      tvf.readChars(buffer, start, deltaLength);\n      String term = new String(buffer, 0, totalLength);\n      previousBuffer = buffer;\n      int freq = tvf.readVInt();\n      int [] positions = null;\n      if (storePositions) { //read in the positions\n        //does the mapper even care about positions?\n        if (mapper.isIgnoringPositions() == false) {\n          positions = new int[freq];\n          int prevPosition = 0;\n          for (int j = 0; j < freq; j++)\n          {\n            positions[j] = prevPosition + tvf.readVInt();\n            prevPosition = positions[j];\n          }\n        } else {\n          //we need to skip over the positions.  Since these are VInts, I don't believe there is anyway to know for sure how far to skip\n          //\n          for (int j = 0; j < freq; j++)\n          {\n            tvf.readVInt();\n          }\n        }\n      }\n      TermVectorOffsetInfo[] offsets = null;\n      if (storeOffsets) {\n        //does the mapper even care about offsets?\n        if (mapper.isIgnoringOffsets() == false) {\n          offsets = new TermVectorOffsetInfo[freq];\n          int prevOffset = 0;\n          for (int j = 0; j < freq; j++) {\n            int startOffset = prevOffset + tvf.readVInt();\n            int endOffset = startOffset + tvf.readVInt();\n            offsets[j] = new TermVectorOffsetInfo(startOffset, endOffset);\n            prevOffset = endOffset;\n          }\n        } else {\n          for (int j = 0; j < freq; j++){\n            tvf.readVInt();\n            tvf.readVInt();\n          }\n        }\n      }\n      mapper.map(term, freq, offsets, positions);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ba4883c8bf955a8f0828b86cdb1be02a28c54f2","date":1210988873,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long,TermVectorMapper).mjava","pathOld":"src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long,TermVectorMapper).mjava","sourceNew":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @param mapper The mapper used to map the TermVector\n   * @throws IOException\n   */ \n  private void readTermVector(String field, long tvfPointer, TermVectorMapper mapper)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector. However, this should never occur!\n    if (numTerms == 0) \n      return;\n    \n    boolean storePositions;\n    boolean storeOffsets;\n    \n    if (format >= FORMAT_VERSION){\n      byte bits = tvf.readByte();\n      storePositions = (bits & STORE_POSITIONS_WITH_TERMVECTOR) != 0;\n      storeOffsets = (bits & STORE_OFFSET_WITH_TERMVECTOR) != 0;\n    }\n    else{\n      tvf.readVInt();\n      storePositions = false;\n      storeOffsets = false;\n    }\n    mapper.setExpectations(field, numTerms, storeOffsets, storePositions);\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    byte[] byteBuffer;\n    char[] charBuffer;\n    final boolean preUTF8 = format < FORMAT_UTF8_LENGTH_IN_BYTES;\n\n    // init the buffers\n    if (preUTF8) {\n      charBuffer = new char[10];\n      byteBuffer = null;\n    } else {\n      charBuffer = null;\n      byteBuffer = new byte[20];\n    }\n\n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n\n      final String term;\n      \n      if (preUTF8) {\n        // Term stored as java chars\n        if (charBuffer.length < totalLength) {\n          char[] newCharBuffer = new char[(int) (1.5*totalLength)];\n          System.arraycopy(charBuffer, 0, newCharBuffer, 0, start);\n          charBuffer = newCharBuffer;\n        }\n        tvf.readChars(charBuffer, start, deltaLength);\n        term = new String(charBuffer, 0, totalLength);\n      } else {\n        // Term stored as utf8 bytes\n        if (byteBuffer.length < totalLength) {\n          byte[] newByteBuffer = new byte[(int) (1.5*totalLength)];\n          System.arraycopy(byteBuffer, 0, newByteBuffer, 0, start);\n          byteBuffer = newByteBuffer;\n        }\n        tvf.readBytes(byteBuffer, start, deltaLength);\n        term = new String(byteBuffer, 0, totalLength, \"UTF-8\");\n      }\n      int freq = tvf.readVInt();\n      int [] positions = null;\n      if (storePositions) { //read in the positions\n        //does the mapper even care about positions?\n        if (mapper.isIgnoringPositions() == false) {\n          positions = new int[freq];\n          int prevPosition = 0;\n          for (int j = 0; j < freq; j++)\n          {\n            positions[j] = prevPosition + tvf.readVInt();\n            prevPosition = positions[j];\n          }\n        } else {\n          //we need to skip over the positions.  Since these are VInts, I don't believe there is anyway to know for sure how far to skip\n          //\n          for (int j = 0; j < freq; j++)\n          {\n            tvf.readVInt();\n          }\n        }\n      }\n      TermVectorOffsetInfo[] offsets = null;\n      if (storeOffsets) {\n        //does the mapper even care about offsets?\n        if (mapper.isIgnoringOffsets() == false) {\n          offsets = new TermVectorOffsetInfo[freq];\n          int prevOffset = 0;\n          for (int j = 0; j < freq; j++) {\n            int startOffset = prevOffset + tvf.readVInt();\n            int endOffset = startOffset + tvf.readVInt();\n            offsets[j] = new TermVectorOffsetInfo(startOffset, endOffset);\n            prevOffset = endOffset;\n          }\n        } else {\n          for (int j = 0; j < freq; j++){\n            tvf.readVInt();\n            tvf.readVInt();\n          }\n        }\n      }\n      mapper.map(term, freq, offsets, positions);\n    }\n  }\n\n","sourceOld":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @param mapper The mapper used to map the TermVector\n   * @return The TermVector located at that position\n   * @throws IOException\n\n   */ \n  private void readTermVector(String field, long tvfPointer, TermVectorMapper mapper)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector. However, this should never occur!\n    if (numTerms == 0) \n      return;\n    \n    boolean storePositions;\n    boolean storeOffsets;\n    \n    if (format >= FORMAT_VERSION){\n      byte bits = tvf.readByte();\n      storePositions = (bits & STORE_POSITIONS_WITH_TERMVECTOR) != 0;\n      storeOffsets = (bits & STORE_OFFSET_WITH_TERMVECTOR) != 0;\n    }\n    else{\n      tvf.readVInt();\n      storePositions = false;\n      storeOffsets = false;\n    }\n    mapper.setExpectations(field, numTerms, storeOffsets, storePositions);\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    byte[] byteBuffer;\n    char[] charBuffer;\n    final boolean preUTF8 = format < FORMAT_UTF8_LENGTH_IN_BYTES;\n\n    // init the buffers\n    if (preUTF8) {\n      charBuffer = new char[10];\n      byteBuffer = null;\n    } else {\n      charBuffer = null;\n      byteBuffer = new byte[20];\n    }\n\n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n\n      final String term;\n      \n      if (preUTF8) {\n        // Term stored as java chars\n        if (charBuffer.length < totalLength) {\n          char[] newCharBuffer = new char[(int) (1.5*totalLength)];\n          System.arraycopy(charBuffer, 0, newCharBuffer, 0, start);\n          charBuffer = newCharBuffer;\n        }\n        tvf.readChars(charBuffer, start, deltaLength);\n        term = new String(charBuffer, 0, totalLength);\n      } else {\n        // Term stored as utf8 bytes\n        if (byteBuffer.length < totalLength) {\n          byte[] newByteBuffer = new byte[(int) (1.5*totalLength)];\n          System.arraycopy(byteBuffer, 0, newByteBuffer, 0, start);\n          byteBuffer = newByteBuffer;\n        }\n        tvf.readBytes(byteBuffer, start, deltaLength);\n        term = new String(byteBuffer, 0, totalLength, \"UTF-8\");\n      }\n      int freq = tvf.readVInt();\n      int [] positions = null;\n      if (storePositions) { //read in the positions\n        //does the mapper even care about positions?\n        if (mapper.isIgnoringPositions() == false) {\n          positions = new int[freq];\n          int prevPosition = 0;\n          for (int j = 0; j < freq; j++)\n          {\n            positions[j] = prevPosition + tvf.readVInt();\n            prevPosition = positions[j];\n          }\n        } else {\n          //we need to skip over the positions.  Since these are VInts, I don't believe there is anyway to know for sure how far to skip\n          //\n          for (int j = 0; j < freq; j++)\n          {\n            tvf.readVInt();\n          }\n        }\n      }\n      TermVectorOffsetInfo[] offsets = null;\n      if (storeOffsets) {\n        //does the mapper even care about offsets?\n        if (mapper.isIgnoringOffsets() == false) {\n          offsets = new TermVectorOffsetInfo[freq];\n          int prevOffset = 0;\n          for (int j = 0; j < freq; j++) {\n            int startOffset = prevOffset + tvf.readVInt();\n            int endOffset = startOffset + tvf.readVInt();\n            offsets[j] = new TermVectorOffsetInfo(startOffset, endOffset);\n            prevOffset = endOffset;\n          }\n        } else {\n          for (int j = 0; j < freq; j++){\n            tvf.readVInt();\n            tvf.readVInt();\n          }\n        }\n      }\n      mapper.map(term, freq, offsets, positions);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a43a81875fea76763cb9f1ff5a41f2c5b79a6585","date":1264678816,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long,TermVectorMapper).mjava","pathOld":"src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long,TermVectorMapper).mjava","sourceNew":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @param mapper The mapper used to map the TermVector\n   * @throws IOException\n   */ \n  private void readTermVector(String field, long tvfPointer, TermVectorMapper mapper)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector. However, this should never occur!\n    if (numTerms == 0) \n      return;\n    \n    boolean storePositions;\n    boolean storeOffsets;\n    \n    if (format >= FORMAT_VERSION){\n      byte bits = tvf.readByte();\n      storePositions = (bits & STORE_POSITIONS_WITH_TERMVECTOR) != 0;\n      storeOffsets = (bits & STORE_OFFSET_WITH_TERMVECTOR) != 0;\n    }\n    else{\n      tvf.readVInt();\n      storePositions = false;\n      storeOffsets = false;\n    }\n    mapper.setExpectations(field, numTerms, storeOffsets, storePositions);\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    byte[] byteBuffer;\n    char[] charBuffer;\n    final boolean preUTF8 = format < FORMAT_UTF8_LENGTH_IN_BYTES;\n\n    // init the buffers\n    if (preUTF8) {\n      charBuffer = new char[10];\n      byteBuffer = null;\n    } else {\n      charBuffer = null;\n      byteBuffer = new byte[20];\n    }\n\n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n\n      final String term;\n      \n      if (preUTF8) {\n        // Term stored as java chars\n        if (charBuffer.length < totalLength) {\n          charBuffer = ArrayUtil.grow(charBuffer, totalLength);\n        }\n        tvf.readChars(charBuffer, start, deltaLength);\n        term = new String(charBuffer, 0, totalLength);\n      } else {\n        // Term stored as utf8 bytes\n        if (byteBuffer.length < totalLength) {\n          byteBuffer = ArrayUtil.grow(byteBuffer, totalLength);\n        }\n        tvf.readBytes(byteBuffer, start, deltaLength);\n        term = new String(byteBuffer, 0, totalLength, \"UTF-8\");\n      }\n      int freq = tvf.readVInt();\n      int [] positions = null;\n      if (storePositions) { //read in the positions\n        //does the mapper even care about positions?\n        if (mapper.isIgnoringPositions() == false) {\n          positions = new int[freq];\n          int prevPosition = 0;\n          for (int j = 0; j < freq; j++)\n          {\n            positions[j] = prevPosition + tvf.readVInt();\n            prevPosition = positions[j];\n          }\n        } else {\n          //we need to skip over the positions.  Since these are VInts, I don't believe there is anyway to know for sure how far to skip\n          //\n          for (int j = 0; j < freq; j++)\n          {\n            tvf.readVInt();\n          }\n        }\n      }\n      TermVectorOffsetInfo[] offsets = null;\n      if (storeOffsets) {\n        //does the mapper even care about offsets?\n        if (mapper.isIgnoringOffsets() == false) {\n          offsets = new TermVectorOffsetInfo[freq];\n          int prevOffset = 0;\n          for (int j = 0; j < freq; j++) {\n            int startOffset = prevOffset + tvf.readVInt();\n            int endOffset = startOffset + tvf.readVInt();\n            offsets[j] = new TermVectorOffsetInfo(startOffset, endOffset);\n            prevOffset = endOffset;\n          }\n        } else {\n          for (int j = 0; j < freq; j++){\n            tvf.readVInt();\n            tvf.readVInt();\n          }\n        }\n      }\n      mapper.map(term, freq, offsets, positions);\n    }\n  }\n\n","sourceOld":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @param mapper The mapper used to map the TermVector\n   * @throws IOException\n   */ \n  private void readTermVector(String field, long tvfPointer, TermVectorMapper mapper)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector. However, this should never occur!\n    if (numTerms == 0) \n      return;\n    \n    boolean storePositions;\n    boolean storeOffsets;\n    \n    if (format >= FORMAT_VERSION){\n      byte bits = tvf.readByte();\n      storePositions = (bits & STORE_POSITIONS_WITH_TERMVECTOR) != 0;\n      storeOffsets = (bits & STORE_OFFSET_WITH_TERMVECTOR) != 0;\n    }\n    else{\n      tvf.readVInt();\n      storePositions = false;\n      storeOffsets = false;\n    }\n    mapper.setExpectations(field, numTerms, storeOffsets, storePositions);\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    byte[] byteBuffer;\n    char[] charBuffer;\n    final boolean preUTF8 = format < FORMAT_UTF8_LENGTH_IN_BYTES;\n\n    // init the buffers\n    if (preUTF8) {\n      charBuffer = new char[10];\n      byteBuffer = null;\n    } else {\n      charBuffer = null;\n      byteBuffer = new byte[20];\n    }\n\n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n\n      final String term;\n      \n      if (preUTF8) {\n        // Term stored as java chars\n        if (charBuffer.length < totalLength) {\n          char[] newCharBuffer = new char[(int) (1.5*totalLength)];\n          System.arraycopy(charBuffer, 0, newCharBuffer, 0, start);\n          charBuffer = newCharBuffer;\n        }\n        tvf.readChars(charBuffer, start, deltaLength);\n        term = new String(charBuffer, 0, totalLength);\n      } else {\n        // Term stored as utf8 bytes\n        if (byteBuffer.length < totalLength) {\n          byte[] newByteBuffer = new byte[(int) (1.5*totalLength)];\n          System.arraycopy(byteBuffer, 0, newByteBuffer, 0, start);\n          byteBuffer = newByteBuffer;\n        }\n        tvf.readBytes(byteBuffer, start, deltaLength);\n        term = new String(byteBuffer, 0, totalLength, \"UTF-8\");\n      }\n      int freq = tvf.readVInt();\n      int [] positions = null;\n      if (storePositions) { //read in the positions\n        //does the mapper even care about positions?\n        if (mapper.isIgnoringPositions() == false) {\n          positions = new int[freq];\n          int prevPosition = 0;\n          for (int j = 0; j < freq; j++)\n          {\n            positions[j] = prevPosition + tvf.readVInt();\n            prevPosition = positions[j];\n          }\n        } else {\n          //we need to skip over the positions.  Since these are VInts, I don't believe there is anyway to know for sure how far to skip\n          //\n          for (int j = 0; j < freq; j++)\n          {\n            tvf.readVInt();\n          }\n        }\n      }\n      TermVectorOffsetInfo[] offsets = null;\n      if (storeOffsets) {\n        //does the mapper even care about offsets?\n        if (mapper.isIgnoringOffsets() == false) {\n          offsets = new TermVectorOffsetInfo[freq];\n          int prevOffset = 0;\n          for (int j = 0; j < freq; j++) {\n            int startOffset = prevOffset + tvf.readVInt();\n            int endOffset = startOffset + tvf.readVInt();\n            offsets[j] = new TermVectorOffsetInfo(startOffset, endOffset);\n            prevOffset = endOffset;\n          }\n        } else {\n          for (int j = 0; j < freq; j++){\n            tvf.readVInt();\n            tvf.readVInt();\n          }\n        }\n      }\n      mapper.map(term, freq, offsets, positions);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long,TermVectorMapper).mjava","pathOld":"src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long,TermVectorMapper).mjava","sourceNew":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @param mapper The mapper used to map the TermVector\n   * @throws IOException\n   */ \n  private void readTermVector(String field, long tvfPointer, TermVectorMapper mapper)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector. However, this should never occur!\n    if (numTerms == 0) \n      return;\n    \n    boolean storePositions;\n    boolean storeOffsets;\n    \n    if (format >= FORMAT_VERSION){\n      byte bits = tvf.readByte();\n      storePositions = (bits & STORE_POSITIONS_WITH_TERMVECTOR) != 0;\n      storeOffsets = (bits & STORE_OFFSET_WITH_TERMVECTOR) != 0;\n    }\n    else{\n      tvf.readVInt();\n      storePositions = false;\n      storeOffsets = false;\n    }\n    mapper.setExpectations(field, numTerms, storeOffsets, storePositions);\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    byte[] byteBuffer;\n    char[] charBuffer;\n    final boolean preUTF8 = format < FORMAT_UTF8_LENGTH_IN_BYTES;\n\n    // init the buffers\n    if (preUTF8) {\n      charBuffer = new char[10];\n      byteBuffer = null;\n    } else {\n      charBuffer = null;\n      byteBuffer = new byte[20];\n    }\n\n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n\n      final String term;\n      \n      if (preUTF8) {\n        // Term stored as java chars\n        if (charBuffer.length < totalLength) {\n          charBuffer = ArrayUtil.grow(charBuffer, totalLength);\n        }\n        tvf.readChars(charBuffer, start, deltaLength);\n        term = new String(charBuffer, 0, totalLength);\n      } else {\n        // Term stored as utf8 bytes\n        if (byteBuffer.length < totalLength) {\n          byteBuffer = ArrayUtil.grow(byteBuffer, totalLength);\n        }\n        tvf.readBytes(byteBuffer, start, deltaLength);\n        term = new String(byteBuffer, 0, totalLength, \"UTF-8\");\n      }\n      int freq = tvf.readVInt();\n      int [] positions = null;\n      if (storePositions) { //read in the positions\n        //does the mapper even care about positions?\n        if (mapper.isIgnoringPositions() == false) {\n          positions = new int[freq];\n          int prevPosition = 0;\n          for (int j = 0; j < freq; j++)\n          {\n            positions[j] = prevPosition + tvf.readVInt();\n            prevPosition = positions[j];\n          }\n        } else {\n          //we need to skip over the positions.  Since these are VInts, I don't believe there is anyway to know for sure how far to skip\n          //\n          for (int j = 0; j < freq; j++)\n          {\n            tvf.readVInt();\n          }\n        }\n      }\n      TermVectorOffsetInfo[] offsets = null;\n      if (storeOffsets) {\n        //does the mapper even care about offsets?\n        if (mapper.isIgnoringOffsets() == false) {\n          offsets = new TermVectorOffsetInfo[freq];\n          int prevOffset = 0;\n          for (int j = 0; j < freq; j++) {\n            int startOffset = prevOffset + tvf.readVInt();\n            int endOffset = startOffset + tvf.readVInt();\n            offsets[j] = new TermVectorOffsetInfo(startOffset, endOffset);\n            prevOffset = endOffset;\n          }\n        } else {\n          for (int j = 0; j < freq; j++){\n            tvf.readVInt();\n            tvf.readVInt();\n          }\n        }\n      }\n      mapper.map(term, freq, offsets, positions);\n    }\n  }\n\n","sourceOld":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @param mapper The mapper used to map the TermVector\n   * @throws IOException\n   */ \n  private void readTermVector(String field, long tvfPointer, TermVectorMapper mapper)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector. However, this should never occur!\n    if (numTerms == 0) \n      return;\n    \n    boolean storePositions;\n    boolean storeOffsets;\n    \n    if (format >= FORMAT_VERSION){\n      byte bits = tvf.readByte();\n      storePositions = (bits & STORE_POSITIONS_WITH_TERMVECTOR) != 0;\n      storeOffsets = (bits & STORE_OFFSET_WITH_TERMVECTOR) != 0;\n    }\n    else{\n      tvf.readVInt();\n      storePositions = false;\n      storeOffsets = false;\n    }\n    mapper.setExpectations(field, numTerms, storeOffsets, storePositions);\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    byte[] byteBuffer;\n    char[] charBuffer;\n    final boolean preUTF8 = format < FORMAT_UTF8_LENGTH_IN_BYTES;\n\n    // init the buffers\n    if (preUTF8) {\n      charBuffer = new char[10];\n      byteBuffer = null;\n    } else {\n      charBuffer = null;\n      byteBuffer = new byte[20];\n    }\n\n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n\n      final String term;\n      \n      if (preUTF8) {\n        // Term stored as java chars\n        if (charBuffer.length < totalLength) {\n          charBuffer = ArrayUtil.grow(charBuffer, totalLength);\n        }\n        tvf.readChars(charBuffer, start, deltaLength);\n        term = new String(charBuffer, 0, totalLength);\n      } else {\n        // Term stored as utf8 bytes\n        if (byteBuffer.length < totalLength) {\n          byteBuffer = ArrayUtil.grow(byteBuffer, totalLength);\n        }\n        tvf.readBytes(byteBuffer, start, deltaLength);\n        term = new String(byteBuffer, 0, totalLength, \"UTF-8\");\n      }\n      int freq = tvf.readVInt();\n      int [] positions = null;\n      if (storePositions) { //read in the positions\n        //does the mapper even care about positions?\n        if (mapper.isIgnoringPositions() == false) {\n          positions = new int[freq];\n          int prevPosition = 0;\n          for (int j = 0; j < freq; j++)\n          {\n            positions[j] = prevPosition + tvf.readVInt();\n            prevPosition = positions[j];\n          }\n        } else {\n          //we need to skip over the positions.  Since these are VInts, I don't believe there is anyway to know for sure how far to skip\n          //\n          for (int j = 0; j < freq; j++)\n          {\n            tvf.readVInt();\n          }\n        }\n      }\n      TermVectorOffsetInfo[] offsets = null;\n      if (storeOffsets) {\n        //does the mapper even care about offsets?\n        if (mapper.isIgnoringOffsets() == false) {\n          offsets = new TermVectorOffsetInfo[freq];\n          int prevOffset = 0;\n          for (int j = 0; j < freq; j++) {\n            int startOffset = prevOffset + tvf.readVInt();\n            int endOffset = startOffset + tvf.readVInt();\n            offsets[j] = new TermVectorOffsetInfo(startOffset, endOffset);\n            prevOffset = endOffset;\n          }\n        } else {\n          for (int j = 0; j < freq; j++){\n            tvf.readVInt();\n            tvf.readVInt();\n          }\n        }\n      }\n      mapper.map(term, freq, offsets, positions);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b3d08461c77d39c25ea6ff0cd05b32f948fa2a33":["11764865fb318bf86302eab36bdf9cd00c50c110"],"4ba4883c8bf955a8f0828b86cdb1be02a28c54f2":["dbb7b6f10bff9eedd5c9bc6cf9222ffbb2df74d4"],"352bfe1fae83b92d1562f01c057bfbe6f5af3ddb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"11764865fb318bf86302eab36bdf9cd00c50c110":["352bfe1fae83b92d1562f01c057bfbe6f5af3ddb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"dbb7b6f10bff9eedd5c9bc6cf9222ffbb2df74d4":["b3d08461c77d39c25ea6ff0cd05b32f948fa2a33"],"a43a81875fea76763cb9f1ff5a41f2c5b79a6585":["4ba4883c8bf955a8f0828b86cdb1be02a28c54f2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a43a81875fea76763cb9f1ff5a41f2c5b79a6585"]},"commit2Childs":{"b3d08461c77d39c25ea6ff0cd05b32f948fa2a33":["dbb7b6f10bff9eedd5c9bc6cf9222ffbb2df74d4"],"4ba4883c8bf955a8f0828b86cdb1be02a28c54f2":["a43a81875fea76763cb9f1ff5a41f2c5b79a6585"],"352bfe1fae83b92d1562f01c057bfbe6f5af3ddb":["11764865fb318bf86302eab36bdf9cd00c50c110"],"11764865fb318bf86302eab36bdf9cd00c50c110":["b3d08461c77d39c25ea6ff0cd05b32f948fa2a33"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["352bfe1fae83b92d1562f01c057bfbe6f5af3ddb"],"dbb7b6f10bff9eedd5c9bc6cf9222ffbb2df74d4":["4ba4883c8bf955a8f0828b86cdb1be02a28c54f2"],"a43a81875fea76763cb9f1ff5a41f2c5b79a6585":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}