{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#release(SegmentReader,boolean).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#release(SegmentReader,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#release(SegmentReader,boolean).mjava","sourceNew":"    /**\n     * Release the segment reader (i.e. decRef it and close if there\n     * are no more references).  If drop is true then we\n     * remove this entry from the pool.\n     * @param sr\n     * @throws IOException\n     */\n    public synchronized void release(SegmentReader sr, boolean drop) throws IOException {\n      // Drop caller's ref; for an external reader (not\n      // pooled), this decRef will close it\n      //System.out.println(\"pool.release seg=\" + sr.getSegmentInfo() + \" rc=\" + sr.getRefCount() + \" drop=\" + drop);\n      sr.decRef();\n\n      final ReadersAndLiveDocs rld = readerMap.get(sr.getSegmentInfo());\n\n      if (rld != null && (drop || (!poolReaders && !rld.anyOutsideRefs(sr)))) {\n\n        // Discard (don't save) changes when we are dropping\n        // the reader; this is used only on the sub-readers\n        // after a successful merge.  If deletes had\n        // accumulated on those sub-readers while the merge\n        // is running, by now we have carried forward those\n        // deletes onto the newly merged segment, so we can\n        // discard them on the sub-readers:\n\n        if (!drop) {\n          if (rld.writeLiveDocs(directory)) {\n            assert infoIsLive(sr.getSegmentInfo());\n            // Must checkpoint w/ deleter, because we just\n            // created created new _X_N.del file.\n            deleter.checkpoint(segmentInfos, false);\n          }\n        }\n\n        if (!rld.removeReader(sr, drop)) {\n          //System.out.println(\"DROP seg=\" + rld.info + \" \" + readerMap.size() + \" in pool\");\n          readerMap.remove(sr.getSegmentInfo());\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Release the segment reader (i.e. decRef it and close if there\n     * are no more references).  If drop is true then we\n     * remove this entry from the pool.\n     * @param sr\n     * @throws IOException\n     */\n    public synchronized void release(SegmentReader sr, boolean drop) throws IOException {\n      // Drop caller's ref; for an external reader (not\n      // pooled), this decRef will close it\n      //System.out.println(\"pool.release seg=\" + sr.getSegmentInfo() + \" rc=\" + sr.getRefCount() + \" drop=\" + drop);\n      sr.decRef();\n\n      final ReadersAndLiveDocs rld = readerMap.get(sr.getSegmentInfo());\n\n      if (rld != null && (drop || (!poolReaders && !rld.anyOutsideRefs(sr)))) {\n\n        // Discard (don't save) changes when we are dropping\n        // the reader; this is used only on the sub-readers\n        // after a successful merge.  If deletes had\n        // accumulated on those sub-readers while the merge\n        // is running, by now we have carried forward those\n        // deletes onto the newly merged segment, so we can\n        // discard them on the sub-readers:\n\n        if (!drop) {\n          if (rld.writeLiveDocs(directory)) {\n            assert infoIsLive(sr.getSegmentInfo());\n            // Must checkpoint w/ deleter, because we just\n            // created created new _X_N.del file.\n            deleter.checkpoint(segmentInfos, false);\n          }\n        }\n\n        if (!rld.removeReader(sr, drop)) {\n          //System.out.println(\"DROP seg=\" + rld.info + \" \" + readerMap.size() + \" in pool\");\n          readerMap.remove(sr.getSegmentInfo());\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae695f21c50b03702b5d0fa2543d5af844bb7cd3","date":1331554994,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#release(SegmentReader,boolean).mjava","sourceNew":null,"sourceOld":"    /**\n     * Release the segment reader (i.e. decRef it and close if there\n     * are no more references).  If drop is true then we\n     * remove this entry from the pool.\n     * @param sr\n     * @throws IOException\n     */\n    public synchronized void release(SegmentReader sr, boolean drop) throws IOException {\n      // Drop caller's ref; for an external reader (not\n      // pooled), this decRef will close it\n      //System.out.println(\"pool.release seg=\" + sr.getSegmentInfo() + \" rc=\" + sr.getRefCount() + \" drop=\" + drop);\n      sr.decRef();\n\n      final ReadersAndLiveDocs rld = readerMap.get(sr.getSegmentInfo());\n\n      if (rld != null && (drop || (!poolReaders && !rld.anyOutsideRefs(sr)))) {\n\n        // Discard (don't save) changes when we are dropping\n        // the reader; this is used only on the sub-readers\n        // after a successful merge.  If deletes had\n        // accumulated on those sub-readers while the merge\n        // is running, by now we have carried forward those\n        // deletes onto the newly merged segment, so we can\n        // discard them on the sub-readers:\n\n        if (!drop) {\n          if (rld.writeLiveDocs(directory)) {\n            assert infoIsLive(sr.getSegmentInfo());\n            // Must checkpoint w/ deleter, because we just\n            // created created new _X_N.del file.\n            deleter.checkpoint(segmentInfos, false);\n          }\n        }\n\n        if (!rld.removeReader(sr, drop)) {\n          //System.out.println(\"DROP seg=\" + rld.info + \" \" + readerMap.size() + \" in pool\");\n          readerMap.remove(sr.getSegmentInfo());\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":4,"author":"Ryan McKinley","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#release(SegmentReader,boolean).mjava","sourceNew":null,"sourceOld":"    /**\n     * Release the segment reader (i.e. decRef it and close if there\n     * are no more references).  If drop is true then we\n     * remove this entry from the pool.\n     * @param sr\n     * @throws IOException\n     */\n    public synchronized void release(SegmentReader sr, boolean drop) throws IOException {\n      // Drop caller's ref; for an external reader (not\n      // pooled), this decRef will close it\n      //System.out.println(\"pool.release seg=\" + sr.getSegmentInfo() + \" rc=\" + sr.getRefCount() + \" drop=\" + drop);\n      sr.decRef();\n\n      final ReadersAndLiveDocs rld = readerMap.get(sr.getSegmentInfo());\n\n      if (rld != null && (drop || (!poolReaders && !rld.anyOutsideRefs(sr)))) {\n\n        // Discard (don't save) changes when we are dropping\n        // the reader; this is used only on the sub-readers\n        // after a successful merge.  If deletes had\n        // accumulated on those sub-readers while the merge\n        // is running, by now we have carried forward those\n        // deletes onto the newly merged segment, so we can\n        // discard them on the sub-readers:\n\n        if (!drop) {\n          if (rld.writeLiveDocs(directory)) {\n            assert infoIsLive(sr.getSegmentInfo());\n            // Must checkpoint w/ deleter, because we just\n            // created created new _X_N.del file.\n            deleter.checkpoint(segmentInfos, false);\n          }\n        }\n\n        if (!rld.removeReader(sr, drop)) {\n          //System.out.println(\"DROP seg=\" + rld.info + \" \" + readerMap.size() + \" in pool\");\n          readerMap.remove(sr.getSegmentInfo());\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"38e3b736c7ca086d61b7dbb841c905ee115490da":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ae695f21c50b03702b5d0fa2543d5af844bb7cd3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ae695f21c50b03702b5d0fa2543d5af844bb7cd3"]},"commit2Childs":{"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["38e3b736c7ca086d61b7dbb841c905ee115490da","ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"ae695f21c50b03702b5d0fa2543d5af844bb7cd3":["38e3b736c7ca086d61b7dbb841c905ee115490da","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["38e3b736c7ca086d61b7dbb841c905ee115490da","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}