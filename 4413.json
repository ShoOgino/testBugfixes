{"path":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldParser[FacetRequest]#parseAndValidateSort(FacetField,Map[String,Object],String).mjava","commits":[{"id":"055706edcc08dfbacd42d8ed4144209d3dc05b67","date":1569388195,"type":0,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldParser[FacetRequest]#parseAndValidateSort(FacetField,Map[String,Object],String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Parses, validates and returns the {@link FacetRequest.FacetSort} for given sortParam\n   * and facet field\n   * <p>\n   *   Currently, supported sort specifications are 'mystat desc' OR {mystat: 'desc'}\n   *   index - This is equivalent to 'index asc'\n   *   count - This is equivalent to 'count desc'\n   * </p>\n   *\n   * @param facet {@link FacetField} for which sort needs to be parsed and validated\n   * @param args map containing the sortVal for given sortParam\n   * @param sortParam parameter for which sort needs to parsed and validated\n   * @return parsed facet sort\n   */\n  private static FacetRequest.FacetSort parseAndValidateSort(FacetField facet, Map<String, Object> args, String sortParam) {\n    Object sort = args.get(sortParam);\n    if (sort == null) {\n      return null;\n    }\n\n    FacetRequest.FacetSort facetSort = null;\n\n    if (sort instanceof String) {\n      String sortStr = (String)sort;\n      if (sortStr.endsWith(\" asc\")) {\n        facetSort =  new FacetRequest.FacetSort(sortStr.substring(0, sortStr.length()-\" asc\".length()),\n            FacetRequest.SortDirection.asc);\n      } else if (sortStr.endsWith(\" desc\")) {\n        facetSort =  new FacetRequest.FacetSort(sortStr.substring(0, sortStr.length()-\" desc\".length()),\n            FacetRequest.SortDirection.desc);\n      } else {\n        facetSort =  new FacetRequest.FacetSort(sortStr,\n            // default direction for \"index\" is ascending\n            (\"index\".equals(sortStr)\n                ? FacetRequest.SortDirection.asc\n                : FacetRequest.SortDirection.desc));\n      }\n    } else if (sort instanceof Map) {\n      // { myvar : 'desc' }\n      Optional<Map.Entry<String,Object>> optional = ((Map<String,Object>)sort).entrySet().stream().findFirst();\n      if (optional.isPresent()) {\n        Map.Entry<String, Object> entry = optional.get();\n        facetSort = new FacetRequest.FacetSort(entry.getKey(), FacetRequest.SortDirection.fromObj(entry.getValue()));\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Expected string/map for '\" + sortParam +\"', received \"+ sort.getClass().getSimpleName() + \"=\" + sort);\n    }\n\n    Map<String, AggValueSource> facetStats = facet.facetStats;\n    // validate facet sort\n    boolean isValidSort = facetSort == null ||\n        \"index\".equals(facetSort.sortVariable) ||\n        \"count\".equals(facetSort.sortVariable) ||\n        (facetStats != null && facetStats.containsKey(facetSort.sortVariable));\n\n    if (!isValidSort) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Invalid \" + sortParam + \" option '\" + sort + \"' for field '\" + facet.field + \"'\");\n    }\n    return facetSort;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"248f6ecc900c3a5633fd5ca6f564ea8b717720da","date":1588863846,"type":4,"author":"Mike Drob","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldParser[FacetRequest]#parseAndValidateSort(FacetField,Map[String,Object],String).mjava","sourceNew":null,"sourceOld":"  /**\n   * Parses, validates and returns the {@link FacetRequest.FacetSort} for given sortParam\n   * and facet field\n   * <p>\n   *   Currently, supported sort specifications are 'mystat desc' OR {mystat: 'desc'}\n   *   index - This is equivalent to 'index asc'\n   *   count - This is equivalent to 'count desc'\n   * </p>\n   *\n   * @param facet {@link FacetField} for which sort needs to be parsed and validated\n   * @param args map containing the sortVal for given sortParam\n   * @param sortParam parameter for which sort needs to parsed and validated\n   * @return parsed facet sort\n   */\n  private static FacetRequest.FacetSort parseAndValidateSort(FacetField facet, Map<String, Object> args, String sortParam) {\n    Object sort = args.get(sortParam);\n    if (sort == null) {\n      return null;\n    }\n\n    FacetRequest.FacetSort facetSort = null;\n\n    if (sort instanceof String) {\n      String sortStr = (String)sort;\n      if (sortStr.endsWith(\" asc\")) {\n        facetSort =  new FacetRequest.FacetSort(sortStr.substring(0, sortStr.length()-\" asc\".length()),\n            FacetRequest.SortDirection.asc);\n      } else if (sortStr.endsWith(\" desc\")) {\n        facetSort =  new FacetRequest.FacetSort(sortStr.substring(0, sortStr.length()-\" desc\".length()),\n            FacetRequest.SortDirection.desc);\n      } else {\n        facetSort =  new FacetRequest.FacetSort(sortStr,\n            // default direction for \"index\" is ascending\n            (\"index\".equals(sortStr)\n                ? FacetRequest.SortDirection.asc\n                : FacetRequest.SortDirection.desc));\n      }\n    } else if (sort instanceof Map) {\n      // { myvar : 'desc' }\n      Optional<Map.Entry<String,Object>> optional = ((Map<String,Object>)sort).entrySet().stream().findFirst();\n      if (optional.isPresent()) {\n        Map.Entry<String, Object> entry = optional.get();\n        facetSort = new FacetRequest.FacetSort(entry.getKey(), FacetRequest.SortDirection.fromObj(entry.getValue()));\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Expected string/map for '\" + sortParam +\"', received \"+ sort.getClass().getSimpleName() + \"=\" + sort);\n    }\n\n    Map<String, AggValueSource> facetStats = facet.facetStats;\n    // validate facet sort\n    boolean isValidSort = facetSort == null ||\n        \"index\".equals(facetSort.sortVariable) ||\n        \"count\".equals(facetSort.sortVariable) ||\n        (facetStats != null && facetStats.containsKey(facetSort.sortVariable));\n\n    if (!isValidSort) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Invalid \" + sortParam + \" option '\" + sort + \"' for field '\" + facet.field + \"'\");\n    }\n    return facetSort;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"055706edcc08dfbacd42d8ed4144209d3dc05b67":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"248f6ecc900c3a5633fd5ca6f564ea8b717720da":["055706edcc08dfbacd42d8ed4144209d3dc05b67"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["248f6ecc900c3a5633fd5ca6f564ea8b717720da"]},"commit2Childs":{"055706edcc08dfbacd42d8ed4144209d3dc05b67":["248f6ecc900c3a5633fd5ca6f564ea8b717720da"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["055706edcc08dfbacd42d8ed4144209d3dc05b67"],"248f6ecc900c3a5633fd5ca6f564ea8b717720da":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}