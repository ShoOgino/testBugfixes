{"path":"lucene/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","commits":[{"id":"c00afe74a80796ed1f30a9509b150ff104746a1f","date":1312881735,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","pathOld":"/dev/null","sourceNew":"  ThreadState obtainAndLock() {\n    final ThreadState perThread = perThreadPool.getAndLock(Thread\n        .currentThread(), documentsWriter);\n    if (perThread.isActive()\n        && perThread.perThread.deleteQueue != documentsWriter.deleteQueue) {\n      // There is a flush-all in process and this DWPT is\n      // now stale -- enroll it for flush and try for\n      // another DWPT:\n      addFlushableState(perThread);\n    }\n    // simply return the ThreadState even in a flush all case sine we already hold the lock\n    return perThread;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["c74a3c6b6b8a3b81dd75c470d0a77bc7b3711351"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c74a3c6b6b8a3b81dd75c470d0a77bc7b3711351","date":1315855085,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","sourceNew":"  ThreadState obtainAndLock() {\n    final ThreadState perThread = perThreadPool.getAndLock(Thread\n        .currentThread(), documentsWriter);\n    boolean success = false;\n    try {\n      if (perThread.isActive()\n          && perThread.perThread.deleteQueue != documentsWriter.deleteQueue) {\n        // There is a flush-all in process and this DWPT is\n        // now stale -- enroll it for flush and try for\n        // another DWPT:\n        addFlushableState(perThread);\n      }\n      success = true;\n      // simply return the ThreadState even in a flush all case sine we already hold the lock\n      return perThread;\n    } finally {\n      if (!success) { // make sure we unlock if this fails\n        perThread.unlock();\n      }\n    }\n  }\n\n","sourceOld":"  ThreadState obtainAndLock() {\n    final ThreadState perThread = perThreadPool.getAndLock(Thread\n        .currentThread(), documentsWriter);\n    if (perThread.isActive()\n        && perThread.perThread.deleteQueue != documentsWriter.deleteQueue) {\n      // There is a flush-all in process and this DWPT is\n      // now stale -- enroll it for flush and try for\n      // another DWPT:\n      addFlushableState(perThread);\n    }\n    // simply return the ThreadState even in a flush all case sine we already hold the lock\n    return perThread;\n  }\n\n","bugFix":["c00afe74a80796ed1f30a9509b150ff104746a1f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","sourceNew":"  ThreadState obtainAndLock() {\n    final ThreadState perThread = perThreadPool.getAndLock(Thread\n        .currentThread(), documentsWriter);\n    boolean success = false;\n    try {\n      if (perThread.isActive()\n          && perThread.perThread.deleteQueue != documentsWriter.deleteQueue) {\n        // There is a flush-all in process and this DWPT is\n        // now stale -- enroll it for flush and try for\n        // another DWPT:\n        addFlushableState(perThread);\n      }\n      success = true;\n      // simply return the ThreadState even in a flush all case sine we already hold the lock\n      return perThread;\n    } finally {\n      if (!success) { // make sure we unlock if this fails\n        perThread.unlock();\n      }\n    }\n  }\n\n","sourceOld":"  ThreadState obtainAndLock() {\n    final ThreadState perThread = perThreadPool.getAndLock(Thread\n        .currentThread(), documentsWriter);\n    boolean success = false;\n    try {\n      if (perThread.isActive()\n          && perThread.perThread.deleteQueue != documentsWriter.deleteQueue) {\n        // There is a flush-all in process and this DWPT is\n        // now stale -- enroll it for flush and try for\n        // another DWPT:\n        addFlushableState(perThread);\n      }\n      success = true;\n      // simply return the ThreadState even in a flush all case sine we already hold the lock\n      return perThread;\n    } finally {\n      if (!success) { // make sure we unlock if this fails\n        perThread.unlock();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["c74a3c6b6b8a3b81dd75c470d0a77bc7b3711351"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c74a3c6b6b8a3b81dd75c470d0a77bc7b3711351":["c00afe74a80796ed1f30a9509b150ff104746a1f"],"c00afe74a80796ed1f30a9509b150ff104746a1f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c00afe74a80796ed1f30a9509b150ff104746a1f"],"c74a3c6b6b8a3b81dd75c470d0a77bc7b3711351":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"c00afe74a80796ed1f30a9509b150ff104746a1f":["c74a3c6b6b8a3b81dd75c470d0a77bc7b3711351"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}