{"path":"lucene/src/test/org/apache/lucene/index/TestTermsEnum#testRandomSeeks(IndexReader,String...).mjava","commits":[{"id":"60ba444201d2570214b6fcf1d15600dc1a01f548","date":1313868045,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestTermsEnum#testRandomSeeks(IndexReader,String...).mjava","pathOld":"/dev/null","sourceNew":"  private void testRandomSeeks(IndexReader r, String... validTermStrings) throws IOException {\n    final BytesRef[] validTerms = new BytesRef[validTermStrings.length];\n    for(int termIDX=0;termIDX<validTermStrings.length;termIDX++) {\n      validTerms[termIDX] = new BytesRef(validTermStrings[termIDX]);\n    }\n    Arrays.sort(validTerms);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + validTerms.length + \" terms:\");\n      for(BytesRef t : validTerms) {\n        System.out.println(\"  \" + t.utf8ToString() + \" \" + t);\n      }\n    }\n    final TermsEnum te = MultiFields.getTerms(r, FIELD).iterator();\n\n    final int END_LOC = -validTerms.length-1;\n    \n    final List<TermAndState> termStates = new ArrayList<TermAndState>();\n\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n\n      final BytesRef t;\n      int loc;\n      final TermState termState;\n      if (random.nextInt(6) == 4) {\n        // pick term that doens't exist:\n        t = getNonExistTerm(validTerms);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: invalid term=\" + t.utf8ToString());\n        }\n        loc = Arrays.binarySearch(validTerms, t);\n      } else if (termStates.size() != 0 && random.nextInt(4) == 1) {\n        final TermAndState ts = termStates.get(random.nextInt(termStates.size()));\n        t = ts.term;\n        loc = Arrays.binarySearch(validTerms, t);\n        assertTrue(loc >= 0);\n        termState = ts.state;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid termState term=\" + t.utf8ToString());\n        }\n      } else {\n        // pick valid term\n        loc = random.nextInt(validTerms.length);\n        t = new BytesRef(validTerms[loc]);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid term=\" + t.utf8ToString());\n        }\n      }\n\n      // seekCeil or seekExact:\n      final boolean doSeekExact = random.nextBoolean();\n      if (termState != null) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact termState\");\n        }\n        te.seekExact(t, termState);\n      } else if (doSeekExact) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact\");\n        }\n        assertEquals(loc >= 0, te.seekExact(t, random.nextBoolean()));\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  seekCeil\");\n        }\n\n        final TermsEnum.SeekStatus result = te.seekCeil(t, random.nextBoolean());\n        if (VERBOSE) {\n          System.out.println(\"  got \" + result);\n        }\n\n        if (loc >= 0) {\n          assertEquals(TermsEnum.SeekStatus.FOUND, result);\n        } else if (loc == END_LOC) {\n          assertEquals(TermsEnum.SeekStatus.END, result);\n        } else {\n          assert loc >= -validTerms.length;\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, result);\n        }\n      }\n\n      if (loc >= 0) {\n        assertEquals(t, te.term());\n      } else if (doSeekExact) {\n        // TermsEnum is unpositioned if seekExact returns false\n        continue;\n      } else if (loc == END_LOC) {\n        continue;\n      } else {\n        loc = -loc-1;\n        assertEquals(validTerms[loc], te.term());\n      }\n\n      // Do a bunch of next's after the seek\n      final int numNext = random.nextInt(validTerms.length);\n\n      for(int nextCount=0;nextCount<numNext;nextCount++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: next loc=\" + loc + \" of \" + validTerms.length);\n        }\n        final BytesRef t2 = te.next();\n        loc++;\n        if (loc == validTerms.length) {\n          assertNull(t2);\n          break;\n        } else {\n          assertEquals(validTerms[loc], t2);\n          if (random.nextInt(40) == 17 && termStates.size() < 100) {\n            termStates.add(new TermAndState(validTerms[loc], te.termState()));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc749c053615f5871f3b95715fe292f34e70a53","date":1321470575,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestTermsEnum#testRandomSeeks(IndexReader,String...).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestTermsEnum#testRandomSeeks(IndexReader,String...).mjava","sourceNew":"  private void testRandomSeeks(IndexReader r, String... validTermStrings) throws IOException {\n    final BytesRef[] validTerms = new BytesRef[validTermStrings.length];\n    for(int termIDX=0;termIDX<validTermStrings.length;termIDX++) {\n      validTerms[termIDX] = new BytesRef(validTermStrings[termIDX]);\n    }\n    Arrays.sort(validTerms);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + validTerms.length + \" terms:\");\n      for(BytesRef t : validTerms) {\n        System.out.println(\"  \" + t.utf8ToString() + \" \" + t);\n      }\n    }\n    final TermsEnum te = MultiFields.getTerms(r, FIELD).iterator(null);\n\n    final int END_LOC = -validTerms.length-1;\n    \n    final List<TermAndState> termStates = new ArrayList<TermAndState>();\n\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n\n      final BytesRef t;\n      int loc;\n      final TermState termState;\n      if (random.nextInt(6) == 4) {\n        // pick term that doens't exist:\n        t = getNonExistTerm(validTerms);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: invalid term=\" + t.utf8ToString());\n        }\n        loc = Arrays.binarySearch(validTerms, t);\n      } else if (termStates.size() != 0 && random.nextInt(4) == 1) {\n        final TermAndState ts = termStates.get(random.nextInt(termStates.size()));\n        t = ts.term;\n        loc = Arrays.binarySearch(validTerms, t);\n        assertTrue(loc >= 0);\n        termState = ts.state;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid termState term=\" + t.utf8ToString());\n        }\n      } else {\n        // pick valid term\n        loc = random.nextInt(validTerms.length);\n        t = new BytesRef(validTerms[loc]);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid term=\" + t.utf8ToString());\n        }\n      }\n\n      // seekCeil or seekExact:\n      final boolean doSeekExact = random.nextBoolean();\n      if (termState != null) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact termState\");\n        }\n        te.seekExact(t, termState);\n      } else if (doSeekExact) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact\");\n        }\n        assertEquals(loc >= 0, te.seekExact(t, random.nextBoolean()));\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  seekCeil\");\n        }\n\n        final TermsEnum.SeekStatus result = te.seekCeil(t, random.nextBoolean());\n        if (VERBOSE) {\n          System.out.println(\"  got \" + result);\n        }\n\n        if (loc >= 0) {\n          assertEquals(TermsEnum.SeekStatus.FOUND, result);\n        } else if (loc == END_LOC) {\n          assertEquals(TermsEnum.SeekStatus.END, result);\n        } else {\n          assert loc >= -validTerms.length;\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, result);\n        }\n      }\n\n      if (loc >= 0) {\n        assertEquals(t, te.term());\n      } else if (doSeekExact) {\n        // TermsEnum is unpositioned if seekExact returns false\n        continue;\n      } else if (loc == END_LOC) {\n        continue;\n      } else {\n        loc = -loc-1;\n        assertEquals(validTerms[loc], te.term());\n      }\n\n      // Do a bunch of next's after the seek\n      final int numNext = random.nextInt(validTerms.length);\n\n      for(int nextCount=0;nextCount<numNext;nextCount++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: next loc=\" + loc + \" of \" + validTerms.length);\n        }\n        final BytesRef t2 = te.next();\n        loc++;\n        if (loc == validTerms.length) {\n          assertNull(t2);\n          break;\n        } else {\n          assertEquals(validTerms[loc], t2);\n          if (random.nextInt(40) == 17 && termStates.size() < 100) {\n            termStates.add(new TermAndState(validTerms[loc], te.termState()));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void testRandomSeeks(IndexReader r, String... validTermStrings) throws IOException {\n    final BytesRef[] validTerms = new BytesRef[validTermStrings.length];\n    for(int termIDX=0;termIDX<validTermStrings.length;termIDX++) {\n      validTerms[termIDX] = new BytesRef(validTermStrings[termIDX]);\n    }\n    Arrays.sort(validTerms);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + validTerms.length + \" terms:\");\n      for(BytesRef t : validTerms) {\n        System.out.println(\"  \" + t.utf8ToString() + \" \" + t);\n      }\n    }\n    final TermsEnum te = MultiFields.getTerms(r, FIELD).iterator();\n\n    final int END_LOC = -validTerms.length-1;\n    \n    final List<TermAndState> termStates = new ArrayList<TermAndState>();\n\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n\n      final BytesRef t;\n      int loc;\n      final TermState termState;\n      if (random.nextInt(6) == 4) {\n        // pick term that doens't exist:\n        t = getNonExistTerm(validTerms);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: invalid term=\" + t.utf8ToString());\n        }\n        loc = Arrays.binarySearch(validTerms, t);\n      } else if (termStates.size() != 0 && random.nextInt(4) == 1) {\n        final TermAndState ts = termStates.get(random.nextInt(termStates.size()));\n        t = ts.term;\n        loc = Arrays.binarySearch(validTerms, t);\n        assertTrue(loc >= 0);\n        termState = ts.state;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid termState term=\" + t.utf8ToString());\n        }\n      } else {\n        // pick valid term\n        loc = random.nextInt(validTerms.length);\n        t = new BytesRef(validTerms[loc]);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid term=\" + t.utf8ToString());\n        }\n      }\n\n      // seekCeil or seekExact:\n      final boolean doSeekExact = random.nextBoolean();\n      if (termState != null) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact termState\");\n        }\n        te.seekExact(t, termState);\n      } else if (doSeekExact) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact\");\n        }\n        assertEquals(loc >= 0, te.seekExact(t, random.nextBoolean()));\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  seekCeil\");\n        }\n\n        final TermsEnum.SeekStatus result = te.seekCeil(t, random.nextBoolean());\n        if (VERBOSE) {\n          System.out.println(\"  got \" + result);\n        }\n\n        if (loc >= 0) {\n          assertEquals(TermsEnum.SeekStatus.FOUND, result);\n        } else if (loc == END_LOC) {\n          assertEquals(TermsEnum.SeekStatus.END, result);\n        } else {\n          assert loc >= -validTerms.length;\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, result);\n        }\n      }\n\n      if (loc >= 0) {\n        assertEquals(t, te.term());\n      } else if (doSeekExact) {\n        // TermsEnum is unpositioned if seekExact returns false\n        continue;\n      } else if (loc == END_LOC) {\n        continue;\n      } else {\n        loc = -loc-1;\n        assertEquals(validTerms[loc], te.term());\n      }\n\n      // Do a bunch of next's after the seek\n      final int numNext = random.nextInt(validTerms.length);\n\n      for(int nextCount=0;nextCount<numNext;nextCount++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: next loc=\" + loc + \" of \" + validTerms.length);\n        }\n        final BytesRef t2 = te.next();\n        loc++;\n        if (loc == validTerms.length) {\n          assertNull(t2);\n          break;\n        } else {\n          assertEquals(validTerms[loc], t2);\n          if (random.nextInt(40) == 17 && termStates.size() < 100) {\n            termStates.add(new TermAndState(validTerms[loc], te.termState()));\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e6e919043fa85ee891123768dd655a98edbbf63c","date":1322225413,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestTermsEnum#testRandomSeeks(IndexReader,String...).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestTermsEnum#testRandomSeeks(IndexReader,String...).mjava","sourceNew":"  private void testRandomSeeks(IndexReader r, String... validTermStrings) throws IOException {\n    final BytesRef[] validTerms = new BytesRef[validTermStrings.length];\n    for(int termIDX=0;termIDX<validTermStrings.length;termIDX++) {\n      validTerms[termIDX] = new BytesRef(validTermStrings[termIDX]);\n    }\n    Arrays.sort(validTerms);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + validTerms.length + \" terms:\");\n      for(BytesRef t : validTerms) {\n        System.out.println(\"  \" + t.utf8ToString() + \" \" + t);\n      }\n    }\n    final TermsEnum te = MultiFields.getTerms(r, FIELD).iterator(null);\n\n    final int END_LOC = -validTerms.length-1;\n    \n    final List<TermAndState> termStates = new ArrayList<TermAndState>();\n\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n\n      final BytesRef t;\n      int loc;\n      final TermState termState;\n      if (random.nextInt(6) == 4) {\n        // pick term that doens't exist:\n        t = getNonExistTerm(validTerms);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: invalid term=\" + t.utf8ToString());\n        }\n        loc = Arrays.binarySearch(validTerms, t);\n      } else if (termStates.size() != 0 && random.nextInt(4) == 1) {\n        final TermAndState ts = termStates.get(random.nextInt(termStates.size()));\n        t = ts.term;\n        loc = Arrays.binarySearch(validTerms, t);\n        assertTrue(loc >= 0);\n        termState = ts.state;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid termState term=\" + t.utf8ToString());\n        }\n      } else {\n        // pick valid term\n        loc = random.nextInt(validTerms.length);\n        t = BytesRef.deepCopyOf(validTerms[loc]);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid term=\" + t.utf8ToString());\n        }\n      }\n\n      // seekCeil or seekExact:\n      final boolean doSeekExact = random.nextBoolean();\n      if (termState != null) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact termState\");\n        }\n        te.seekExact(t, termState);\n      } else if (doSeekExact) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact\");\n        }\n        assertEquals(loc >= 0, te.seekExact(t, random.nextBoolean()));\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  seekCeil\");\n        }\n\n        final TermsEnum.SeekStatus result = te.seekCeil(t, random.nextBoolean());\n        if (VERBOSE) {\n          System.out.println(\"  got \" + result);\n        }\n\n        if (loc >= 0) {\n          assertEquals(TermsEnum.SeekStatus.FOUND, result);\n        } else if (loc == END_LOC) {\n          assertEquals(TermsEnum.SeekStatus.END, result);\n        } else {\n          assert loc >= -validTerms.length;\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, result);\n        }\n      }\n\n      if (loc >= 0) {\n        assertEquals(t, te.term());\n      } else if (doSeekExact) {\n        // TermsEnum is unpositioned if seekExact returns false\n        continue;\n      } else if (loc == END_LOC) {\n        continue;\n      } else {\n        loc = -loc-1;\n        assertEquals(validTerms[loc], te.term());\n      }\n\n      // Do a bunch of next's after the seek\n      final int numNext = random.nextInt(validTerms.length);\n\n      for(int nextCount=0;nextCount<numNext;nextCount++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: next loc=\" + loc + \" of \" + validTerms.length);\n        }\n        final BytesRef t2 = te.next();\n        loc++;\n        if (loc == validTerms.length) {\n          assertNull(t2);\n          break;\n        } else {\n          assertEquals(validTerms[loc], t2);\n          if (random.nextInt(40) == 17 && termStates.size() < 100) {\n            termStates.add(new TermAndState(validTerms[loc], te.termState()));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void testRandomSeeks(IndexReader r, String... validTermStrings) throws IOException {\n    final BytesRef[] validTerms = new BytesRef[validTermStrings.length];\n    for(int termIDX=0;termIDX<validTermStrings.length;termIDX++) {\n      validTerms[termIDX] = new BytesRef(validTermStrings[termIDX]);\n    }\n    Arrays.sort(validTerms);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + validTerms.length + \" terms:\");\n      for(BytesRef t : validTerms) {\n        System.out.println(\"  \" + t.utf8ToString() + \" \" + t);\n      }\n    }\n    final TermsEnum te = MultiFields.getTerms(r, FIELD).iterator(null);\n\n    final int END_LOC = -validTerms.length-1;\n    \n    final List<TermAndState> termStates = new ArrayList<TermAndState>();\n\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n\n      final BytesRef t;\n      int loc;\n      final TermState termState;\n      if (random.nextInt(6) == 4) {\n        // pick term that doens't exist:\n        t = getNonExistTerm(validTerms);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: invalid term=\" + t.utf8ToString());\n        }\n        loc = Arrays.binarySearch(validTerms, t);\n      } else if (termStates.size() != 0 && random.nextInt(4) == 1) {\n        final TermAndState ts = termStates.get(random.nextInt(termStates.size()));\n        t = ts.term;\n        loc = Arrays.binarySearch(validTerms, t);\n        assertTrue(loc >= 0);\n        termState = ts.state;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid termState term=\" + t.utf8ToString());\n        }\n      } else {\n        // pick valid term\n        loc = random.nextInt(validTerms.length);\n        t = new BytesRef(validTerms[loc]);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid term=\" + t.utf8ToString());\n        }\n      }\n\n      // seekCeil or seekExact:\n      final boolean doSeekExact = random.nextBoolean();\n      if (termState != null) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact termState\");\n        }\n        te.seekExact(t, termState);\n      } else if (doSeekExact) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact\");\n        }\n        assertEquals(loc >= 0, te.seekExact(t, random.nextBoolean()));\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  seekCeil\");\n        }\n\n        final TermsEnum.SeekStatus result = te.seekCeil(t, random.nextBoolean());\n        if (VERBOSE) {\n          System.out.println(\"  got \" + result);\n        }\n\n        if (loc >= 0) {\n          assertEquals(TermsEnum.SeekStatus.FOUND, result);\n        } else if (loc == END_LOC) {\n          assertEquals(TermsEnum.SeekStatus.END, result);\n        } else {\n          assert loc >= -validTerms.length;\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, result);\n        }\n      }\n\n      if (loc >= 0) {\n        assertEquals(t, te.term());\n      } else if (doSeekExact) {\n        // TermsEnum is unpositioned if seekExact returns false\n        continue;\n      } else if (loc == END_LOC) {\n        continue;\n      } else {\n        loc = -loc-1;\n        assertEquals(validTerms[loc], te.term());\n      }\n\n      // Do a bunch of next's after the seek\n      final int numNext = random.nextInt(validTerms.length);\n\n      for(int nextCount=0;nextCount<numNext;nextCount++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: next loc=\" + loc + \" of \" + validTerms.length);\n        }\n        final BytesRef t2 = te.next();\n        loc++;\n        if (loc == validTerms.length) {\n          assertNull(t2);\n          break;\n        } else {\n          assertEquals(validTerms[loc], t2);\n          if (random.nextInt(40) == 17 && termStates.size() < 100) {\n            termStates.add(new TermAndState(validTerms[loc], te.termState()));\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testRandomSeeks(IndexReader,String...).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestTermsEnum#testRandomSeeks(IndexReader,String...).mjava","sourceNew":"  private void testRandomSeeks(IndexReader r, String... validTermStrings) throws IOException {\n    final BytesRef[] validTerms = new BytesRef[validTermStrings.length];\n    for(int termIDX=0;termIDX<validTermStrings.length;termIDX++) {\n      validTerms[termIDX] = new BytesRef(validTermStrings[termIDX]);\n    }\n    Arrays.sort(validTerms);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + validTerms.length + \" terms:\");\n      for(BytesRef t : validTerms) {\n        System.out.println(\"  \" + t.utf8ToString() + \" \" + t);\n      }\n    }\n    final TermsEnum te = MultiFields.getTerms(r, FIELD).iterator(null);\n\n    final int END_LOC = -validTerms.length-1;\n    \n    final List<TermAndState> termStates = new ArrayList<TermAndState>();\n\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n\n      final BytesRef t;\n      int loc;\n      final TermState termState;\n      if (random.nextInt(6) == 4) {\n        // pick term that doens't exist:\n        t = getNonExistTerm(validTerms);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: invalid term=\" + t.utf8ToString());\n        }\n        loc = Arrays.binarySearch(validTerms, t);\n      } else if (termStates.size() != 0 && random.nextInt(4) == 1) {\n        final TermAndState ts = termStates.get(random.nextInt(termStates.size()));\n        t = ts.term;\n        loc = Arrays.binarySearch(validTerms, t);\n        assertTrue(loc >= 0);\n        termState = ts.state;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid termState term=\" + t.utf8ToString());\n        }\n      } else {\n        // pick valid term\n        loc = random.nextInt(validTerms.length);\n        t = BytesRef.deepCopyOf(validTerms[loc]);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid term=\" + t.utf8ToString());\n        }\n      }\n\n      // seekCeil or seekExact:\n      final boolean doSeekExact = random.nextBoolean();\n      if (termState != null) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact termState\");\n        }\n        te.seekExact(t, termState);\n      } else if (doSeekExact) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact\");\n        }\n        assertEquals(loc >= 0, te.seekExact(t, random.nextBoolean()));\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  seekCeil\");\n        }\n\n        final TermsEnum.SeekStatus result = te.seekCeil(t, random.nextBoolean());\n        if (VERBOSE) {\n          System.out.println(\"  got \" + result);\n        }\n\n        if (loc >= 0) {\n          assertEquals(TermsEnum.SeekStatus.FOUND, result);\n        } else if (loc == END_LOC) {\n          assertEquals(TermsEnum.SeekStatus.END, result);\n        } else {\n          assert loc >= -validTerms.length;\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, result);\n        }\n      }\n\n      if (loc >= 0) {\n        assertEquals(t, te.term());\n      } else if (doSeekExact) {\n        // TermsEnum is unpositioned if seekExact returns false\n        continue;\n      } else if (loc == END_LOC) {\n        continue;\n      } else {\n        loc = -loc-1;\n        assertEquals(validTerms[loc], te.term());\n      }\n\n      // Do a bunch of next's after the seek\n      final int numNext = random.nextInt(validTerms.length);\n\n      for(int nextCount=0;nextCount<numNext;nextCount++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: next loc=\" + loc + \" of \" + validTerms.length);\n        }\n        final BytesRef t2 = te.next();\n        loc++;\n        if (loc == validTerms.length) {\n          assertNull(t2);\n          break;\n        } else {\n          assertEquals(validTerms[loc], t2);\n          if (random.nextInt(40) == 17 && termStates.size() < 100) {\n            termStates.add(new TermAndState(validTerms[loc], te.termState()));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void testRandomSeeks(IndexReader r, String... validTermStrings) throws IOException {\n    final BytesRef[] validTerms = new BytesRef[validTermStrings.length];\n    for(int termIDX=0;termIDX<validTermStrings.length;termIDX++) {\n      validTerms[termIDX] = new BytesRef(validTermStrings[termIDX]);\n    }\n    Arrays.sort(validTerms);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + validTerms.length + \" terms:\");\n      for(BytesRef t : validTerms) {\n        System.out.println(\"  \" + t.utf8ToString() + \" \" + t);\n      }\n    }\n    final TermsEnum te = MultiFields.getTerms(r, FIELD).iterator(null);\n\n    final int END_LOC = -validTerms.length-1;\n    \n    final List<TermAndState> termStates = new ArrayList<TermAndState>();\n\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n\n      final BytesRef t;\n      int loc;\n      final TermState termState;\n      if (random.nextInt(6) == 4) {\n        // pick term that doens't exist:\n        t = getNonExistTerm(validTerms);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: invalid term=\" + t.utf8ToString());\n        }\n        loc = Arrays.binarySearch(validTerms, t);\n      } else if (termStates.size() != 0 && random.nextInt(4) == 1) {\n        final TermAndState ts = termStates.get(random.nextInt(termStates.size()));\n        t = ts.term;\n        loc = Arrays.binarySearch(validTerms, t);\n        assertTrue(loc >= 0);\n        termState = ts.state;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid termState term=\" + t.utf8ToString());\n        }\n      } else {\n        // pick valid term\n        loc = random.nextInt(validTerms.length);\n        t = BytesRef.deepCopyOf(validTerms[loc]);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid term=\" + t.utf8ToString());\n        }\n      }\n\n      // seekCeil or seekExact:\n      final boolean doSeekExact = random.nextBoolean();\n      if (termState != null) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact termState\");\n        }\n        te.seekExact(t, termState);\n      } else if (doSeekExact) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact\");\n        }\n        assertEquals(loc >= 0, te.seekExact(t, random.nextBoolean()));\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  seekCeil\");\n        }\n\n        final TermsEnum.SeekStatus result = te.seekCeil(t, random.nextBoolean());\n        if (VERBOSE) {\n          System.out.println(\"  got \" + result);\n        }\n\n        if (loc >= 0) {\n          assertEquals(TermsEnum.SeekStatus.FOUND, result);\n        } else if (loc == END_LOC) {\n          assertEquals(TermsEnum.SeekStatus.END, result);\n        } else {\n          assert loc >= -validTerms.length;\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, result);\n        }\n      }\n\n      if (loc >= 0) {\n        assertEquals(t, te.term());\n      } else if (doSeekExact) {\n        // TermsEnum is unpositioned if seekExact returns false\n        continue;\n      } else if (loc == END_LOC) {\n        continue;\n      } else {\n        loc = -loc-1;\n        assertEquals(validTerms[loc], te.term());\n      }\n\n      // Do a bunch of next's after the seek\n      final int numNext = random.nextInt(validTerms.length);\n\n      for(int nextCount=0;nextCount<numNext;nextCount++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: next loc=\" + loc + \" of \" + validTerms.length);\n        }\n        final BytesRef t2 = te.next();\n        loc++;\n        if (loc == validTerms.length) {\n          assertNull(t2);\n          break;\n        } else {\n          assertEquals(validTerms[loc], t2);\n          if (random.nextInt(40) == 17 && termStates.size() < 100) {\n            termStates.add(new TermAndState(validTerms[loc], te.termState()));\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["e6e919043fa85ee891123768dd655a98edbbf63c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cc749c053615f5871f3b95715fe292f34e70a53":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"e6e919043fa85ee891123768dd655a98edbbf63c":["3cc749c053615f5871f3b95715fe292f34e70a53"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["3cc749c053615f5871f3b95715fe292f34e70a53"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"3cc749c053615f5871f3b95715fe292f34e70a53":["e6e919043fa85ee891123768dd655a98edbbf63c"],"e6e919043fa85ee891123768dd655a98edbbf63c":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}