{"path":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ccc08aa684aee4964baee0644a6ba047bfd70829","date":1316263707,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    if (groupSort == null) {\n      groupSort = new Sort();\n    }\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(\"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["9567a7c3443a4d2f26e2bae683fb25265bc6f7ed"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0414a20d73ebe5c96a6e7e70e337083ec37f01fd","date":1316542523,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    if (groupSort == null) {\n      groupSort = new Sort();\n    }\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(\"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    if (groupSort == null) {\n      groupSort = new Sort();\n    }\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(\"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9567a7c3443a4d2f26e2bae683fb25265bc6f7ed","date":1323438543,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    if (groupSort == null) {\n      groupSort = Sort.RELEVANCE;\n    }\n\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    if (sortWithinGroup == null) {\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(\"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    if (groupSort == null) {\n      groupSort = new Sort();\n    }\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(\"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","bugFix":["ccc08aa684aee4964baee0644a6ba047bfd70829"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ff99371bc1f34bf1a2ccdb754940ee5fe5cc2565","date":1323540308,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    if (groupSort == null) {\n      groupSort = Sort.RELEVANCE;\n    }\n\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    if (sortWithinGroup == null) {\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(\"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    if (groupSort == null) {\n      groupSort = new Sort();\n    }\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(\"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"50eb25774a5690a93352e49e7732b8008c5e681e","date":1328112094,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      rb.setScoreDoc(parser.getPaging());\n      \n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    if (groupSort == null) {\n      groupSort = Sort.RELEVANCE;\n    }\n\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    if (sortWithinGroup == null) {\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(\"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    if (groupSort == null) {\n      groupSort = Sort.RELEVANCE;\n    }\n\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    if (sortWithinGroup == null) {\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(\"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"197070b7f9191af8b5d8598b579393d4a67e32f0","date":1341843740,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      rb.setScoreDoc(parser.getPaging());\n      \n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    if (groupSort == null) {\n      groupSort = Sort.RELEVANCE;\n    }\n\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    if (sortWithinGroup == null) {\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(Locale.ROOT, \"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      rb.setScoreDoc(parser.getPaging());\n      \n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    if (groupSort == null) {\n      groupSort = Sort.RELEVANCE;\n    }\n\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    if (sortWithinGroup == null) {\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(\"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2acf500f78aa12b92e371fd89c719291986b6b90","date":1341846236,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      rb.setScoreDoc(parser.getPaging());\n      \n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    if (groupSort == null) {\n      groupSort = Sort.RELEVANCE;\n    }\n\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    if (sortWithinGroup == null) {\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(Locale.ROOT, \"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      rb.setScoreDoc(parser.getPaging());\n      \n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    if (groupSort == null) {\n      groupSort = Sort.RELEVANCE;\n    }\n\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    if (sortWithinGroup == null) {\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(\"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"46d8ada1fff8d18cb197c38c7983225162599948","date":1341853497,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      rb.setScoreDoc(parser.getPaging());\n      \n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    if (groupSort == null) {\n      groupSort = Sort.RELEVANCE;\n    }\n\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    if (sortWithinGroup == null) {\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(Locale.ROOT, \"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      rb.setScoreDoc(parser.getPaging());\n      \n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    if (groupSort == null) {\n      groupSort = Sort.RELEVANCE;\n    }\n\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    if (sortWithinGroup == null) {\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(\"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      rb.setScoreDoc(parser.getPaging());\n      \n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    if (groupSort == null) {\n      groupSort = Sort.RELEVANCE;\n    }\n\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    if (sortWithinGroup == null) {\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(Locale.ROOT, \"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      rb.setScoreDoc(parser.getPaging());\n      \n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    if (groupSort == null) {\n      groupSort = Sort.RELEVANCE;\n    }\n\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    if (sortWithinGroup == null) {\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(\"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cdb67100dc016748799a77218aa409478372d79","date":1353699950,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      rb.setScoreDoc(parser.getPaging());\n      \n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    if (groupSort == null) {\n      groupSort = Sort.RELEVANCE;\n    }\n\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    if (sortWithinGroup == null) {\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(Locale.ROOT, \"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      rb.setScoreDoc(parser.getPaging());\n      \n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    if (groupSort == null) {\n      groupSort = Sort.RELEVANCE;\n    }\n\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    if (sortWithinGroup == null) {\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(Locale.ROOT, \"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      rb.setScoreDoc(parser.getPaging());\n      \n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    if (groupSort == null) {\n      groupSort = Sort.RELEVANCE;\n    }\n\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    if (sortWithinGroup == null) {\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(Locale.ROOT, \"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      rb.setScoreDoc(parser.getPaging());\n      \n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    if (groupSort == null) {\n      groupSort = Sort.RELEVANCE;\n    }\n\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    if (sortWithinGroup == null) {\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(Locale.ROOT, \"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d17ffdbce80d3dce181982a9cd16f4f90bc8619a","date":1357583592,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      rb.setScoreDoc(parser.getPaging());\n      \n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    if (groupSort == null) {\n      groupSort = Sort.RELEVANCE;\n    }\n\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    if (sortWithinGroup == null) {\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(Locale.ROOT, \"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      rb.setScoreDoc(parser.getPaging());\n      \n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    if (groupSort == null) {\n      groupSort = Sort.RELEVANCE;\n    }\n\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    if (sortWithinGroup == null) {\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(Locale.ROOT, \"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      rb.setScoreDoc(parser.getPaging());\n      \n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    if (groupSort == null) {\n      groupSort = Sort.RELEVANCE;\n    }\n\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    if (sortWithinGroup == null) {\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(Locale.ROOT, \"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new ReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      rb.setScoreDoc(parser.getPaging());\n      \n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    if (groupSort == null) {\n      groupSort = Sort.RELEVANCE;\n    }\n\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    if (sortWithinGroup == null) {\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(Locale.ROOT, \"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"08970e5b8411182a29412c177eff67ec1110095b","date":1366640815,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      rb.setScoreDoc(parser.getPaging());\n      \n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    if (groupSort == null) {\n      groupSort = Sort.RELEVANCE;\n    }\n\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    if (sortWithinGroup == null) {\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(Locale.ROOT, \"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      rb.setScoreDoc(parser.getPaging());\n      \n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    if (groupSort == null) {\n      groupSort = Sort.RELEVANCE;\n    }\n\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    if (sortWithinGroup == null) {\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(Locale.ROOT, \"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c88221aeda5571321ba2bf95de2a7348401230cf","date":1373312382,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      rb.setScoreDoc(parser.getPaging());\n      \n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<Query>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    if (groupSort == null) {\n      groupSort = Sort.RELEVANCE;\n    }\n\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    if (sortWithinGroup == null) {\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(Locale.ROOT, \"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      rb.setScoreDoc(parser.getPaging());\n      \n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    if (groupSort == null) {\n      groupSort = Sort.RELEVANCE;\n    }\n\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    if (sortWithinGroup == null) {\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(Locale.ROOT, \"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","bugFix":["5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76","b785b1f61f30f94f0708b16d7f2eee3ee23194ef"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      rb.setScoreDoc(parser.getPaging());\n      \n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<Query>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    if (groupSort == null) {\n      groupSort = Sort.RELEVANCE;\n    }\n\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    if (sortWithinGroup == null) {\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(Locale.ROOT, \"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      rb.setScoreDoc(parser.getPaging());\n      \n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        if (filters==null) {\n          filters = new ArrayList<Query>(fqs.length);\n        }\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    if (groupSort == null) {\n      groupSort = Sort.RELEVANCE;\n    }\n\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    if (sortWithinGroup == null) {\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(Locale.ROOT, \"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"02453e8d9fe1bde22dc7676145ad809cb1dbfcad","date":1386084179,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      rb.setScoreDoc(parser.getPaging());\n      \n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<Query>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    if (groupSort == null) {\n      groupSort = Sort.RELEVANCE;\n    }\n\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSortSpec(groupSortStr, req).getSort());\n    if (sortWithinGroup == null) {\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(Locale.ROOT, \"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      rb.setScoreDoc(parser.getPaging());\n      \n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<Query>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    if (groupSort == null) {\n      groupSort = Sort.RELEVANCE;\n    }\n\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    if (sortWithinGroup == null) {\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(Locale.ROOT, \"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      rb.setScoreDoc(parser.getPaging());\n      \n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<Query>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    if (groupSort == null) {\n      groupSort = Sort.RELEVANCE;\n    }\n\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSortSpec(groupSortStr, req).getSort());\n    if (sortWithinGroup == null) {\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(Locale.ROOT, \"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      rb.setScoreDoc(parser.getPaging());\n      \n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<Query>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    if (groupSort == null) {\n      groupSort = Sort.RELEVANCE;\n    }\n\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSort(groupSortStr, req));\n    if (sortWithinGroup == null) {\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(Locale.ROOT, \"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d5bc8e25f59990525f5beb14afe9c96240dcf4a2","date":1389042945,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      \n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<Query>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      rb.setScoreDoc(parser.getPaging());\n      \n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<Query>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    boolean grouping = params.getBool(GroupParams.GROUP, false);\n    if (!grouping) {\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    GroupingSpecification groupingSpec = new GroupingSpecification();\n    rb.setGroupingSpec(groupingSpec);\n\n    //TODO: move weighting of sort\n    Sort groupSort = searcher.weightSort(cmd.getSort());\n    if (groupSort == null) {\n      groupSort = Sort.RELEVANCE;\n    }\n\n    // groupSort defaults to sort\n    String groupSortStr = params.get(GroupParams.GROUP_SORT);\n    //TODO: move weighting of sort\n    Sort sortWithinGroup = groupSortStr == null ?  groupSort : searcher.weightSort(QueryParsing.parseSortSpec(groupSortStr, req).getSort());\n    if (sortWithinGroup == null) {\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    groupingSpec.setSortWithinGroup(sortWithinGroup);\n    groupingSpec.setGroupSort(groupSort);\n\n    String formatStr = params.get(GroupParams.GROUP_FORMAT, Grouping.Format.grouped.name());\n    Grouping.Format responseFormat;\n    try {\n       responseFormat = Grouping.Format.valueOf(formatStr);\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, String.format(Locale.ROOT, \"Illegal %s parameter\", GroupParams.GROUP_FORMAT));\n    }\n    groupingSpec.setResponseFormat(responseFormat);\n\n    groupingSpec.setFields(params.getParams(GroupParams.GROUP_FIELD));\n    groupingSpec.setQueries(params.getParams(GroupParams.GROUP_QUERY));\n    groupingSpec.setFunctions(params.getParams(GroupParams.GROUP_FUNC));\n    groupingSpec.setGroupOffset(params.getInt(GroupParams.GROUP_OFFSET, 0));\n    groupingSpec.setGroupLimit(params.getInt(GroupParams.GROUP_LIMIT, 1));\n    groupingSpec.setOffset(rb.getSortSpec().getOffset());\n    groupingSpec.setLimit(rb.getSortSpec().getCount());\n    groupingSpec.setIncludeGroupCount(params.getBool(GroupParams.GROUP_TOTAL_COUNT, false));\n    groupingSpec.setMain(params.getBool(GroupParams.GROUP_MAIN, false));\n    groupingSpec.setNeedScore((cmd.getFlags() & SolrIndexSearcher.GET_SCORES) != 0);\n    groupingSpec.setTruncateGroups(params.getBool(GroupParams.GROUP_TRUNCATE, false));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      \n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      \n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<Query>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c70567cc1ae757045c80cb458b0b2a2ffcf0141","date":1400098332,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n\n      if(q instanceof RankQuery) {\n        MergeStrategy mergeStrategy = ((RankQuery)q).getMergeStrategy();\n        if(mergeStrategy != null) {\n          rb.addMergeStrategy(mergeStrategy);\n          if(mergeStrategy.handlesMergeFields()) {\n            rb.mergeFieldHandler = mergeStrategy;\n          }\n        }\n      }\n\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      \n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      \n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ccc69a67d5c846a04c7f71e28cb1914e3af895f3","date":1400252660,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n\n      if(q instanceof RankQuery) {\n        MergeStrategy mergeStrategy = ((RankQuery)q).getMergeStrategy();\n        if(mergeStrategy != null) {\n          rb.addMergeStrategy(mergeStrategy);\n          if(mergeStrategy.handlesMergeFields()) {\n            rb.mergeFieldHandler = mergeStrategy;\n          }\n        }\n      }\n\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      \n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      \n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c218ef5584c663e78bdaf8391f826546f5bc73c1","date":1401196755,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n\n      rb.setQuery( q );\n\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setQuery(rankQuery.wrap(q)); //Wrap the RankQuery around the main query.\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      \n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n\n      if(q instanceof RankQuery) {\n        MergeStrategy mergeStrategy = ((RankQuery)q).getMergeStrategy();\n        if(mergeStrategy != null) {\n          rb.addMergeStrategy(mergeStrategy);\n          if(mergeStrategy.handlesMergeFields()) {\n            rb.mergeFieldHandler = mergeStrategy;\n          }\n        }\n      }\n\n      rb.setQuery( q );\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      \n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    }\n  }\n\n","bugFix":null,"bugIntro":["eaa9c67a05a203ff23b684274f05fcc22d38dfb3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"02b85e1409bc02521b64db6daeddf08cdd3974c2","date":1401246133,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      \n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n\n      rb.setQuery( q );\n\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setQuery(rankQuery.wrap(q)); //Wrap the RankQuery around the main query.\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      \n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ba39ba201a572fd944ed71d888de0cd4f2957af","date":1404307334,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();        \n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n      \n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c7e0383a0a3421b9f6f61002dd4f6fb39bf71285","date":1427227523,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getQueryCommand().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getQueryCommand().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f68d01cf19df971dcdcb05e30247f4ad7ec9747","date":1434611645,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getQueryCommand().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new BooleanQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getQueryCommand().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e5b55cbdbc5dfead52f0b8b98d5867dcbacc39c4","date":1443729405,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getSortSpec().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getQueryCommand().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cc5ee54a993d26579e3fe1f8f2a696b46b61c48f","date":1470751445,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getSortSpec().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getSortSpec().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8bca25eefa1f2205e2b0ef713701dc3a0fecd702","date":1470810578,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getSortSpec().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getSortSpec().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getSortSpec().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getSortSpec().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07cbaf0735458446c429df54ba816915e8a1f638","date":1476738812,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSortSpec(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getSortSpec().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getSortSpec().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSortSpec(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getSortSpec().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSort(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, null, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getSortSpec().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68c354ba50abc8ed5c5fe98901e61d68f93952bb","date":1479836000,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSortSpec(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, req);\n            fqp.setIsFilter(true);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getSortSpec().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSortSpec(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getSortSpec().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"727bb765ff2542275f6d31f67be18d7104bae148","date":1480353976,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSortSpec(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, req);\n            fqp.setIsFilter(true);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getSortSpec().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSortSpec(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<Query>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, req);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getSortSpec().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46dc9ac8b3e748407baaef82453138ff3974480c","date":1484789241,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSortSpec(true) );\n      for (SchemaField sf:rb.getSortSpec().getSchemaFields()) {\n        if (sf != null && sf.getType().isPointField() && !sf.hasDocValues()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"Can't sort on a point field without docValues\");\n        }\n      }\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, req);\n            fqp.setIsFilter(true);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getSortSpec().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSortSpec(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, req);\n            fqp.setIsFilter(true);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getSortSpec().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","bugFix":null,"bugIntro":["79900e89f08cc17c4bcf49789dd61a2236ee7840"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"90a682dc1bfd188ef61cc28373c7f5d700b4ac75","date":1485186128,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSortSpec(true) );\n      for (SchemaField sf:rb.getSortSpec().getSchemaFields()) {\n        if (sf != null && sf.getType().isPointField() && !sf.hasDocValues()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"Can't sort on a point field without docValues\");\n        }\n      }\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, req);\n            fqp.setIsFilter(true);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getSortSpec().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSortSpec(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, req);\n            fqp.setIsFilter(true);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getSortSpec().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"79900e89f08cc17c4bcf49789dd61a2236ee7840","date":1492541915,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSortSpec(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, req);\n            fqp.setIsFilter(true);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getSortSpec().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSortSpec(true) );\n      for (SchemaField sf:rb.getSortSpec().getSchemaFields()) {\n        if (sf != null && sf.getType().isPointField() && !sf.hasDocValues()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"Can't sort on a point field without docValues\");\n        }\n      }\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, req);\n            fqp.setIsFilter(true);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getSortSpec().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","bugFix":["46dc9ac8b3e748407baaef82453138ff3974480c"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSortSpec(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, req);\n            fqp.setIsFilter(true);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getSortSpec().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSortSpec(true) );\n      for (SchemaField sf:rb.getSortSpec().getSchemaFields()) {\n        if (sf != null && sf.getType().isPointField() && !sf.hasDocValues()) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"Can't sort on a point field without docValues\");\n        }\n      }\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, req);\n            fqp.setIsFilter(true);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getSortSpec().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eaa9c67a05a203ff23b684274f05fcc22d38dfb3","date":1515440645,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSortSpec(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, req);\n            fqp.setIsFilter(true);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getSortSpec().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSortSpec(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, req);\n            fqp.setIsFilter(true);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getSortSpec().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","bugFix":["c218ef5584c663e78bdaf8391f826546f5bc73c1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSortSpec(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, req);\n            fqp.setIsFilter(true);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getSortSpec().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, defType, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSortSpec(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, req);\n            fqp.setIsFilter(true);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getSortSpec().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"92ebaade309baf9560fb8102d941bd5d8534a825","date":1579168338,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSortSpec(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, req);\n            fqp.setIsFilter(true);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError | FuzzyTermsEnum.FuzzyTermsException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getSortSpec().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSortSpec(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, req);\n            fqp.setIsFilter(true);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getSortSpec().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","bugFix":null,"bugIntro":["79788042790c9ded974d85e96aae1b2b3f0ca735"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"79788042790c9ded974d85e96aae1b2b3f0ca735","date":1588891768,"type":3,"author":"Mike Drob","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSortSpec(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, req);\n            fqp.setIsFilter(true);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getSortSpec().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrQueryResponse rsp = rb.rsp;\n\n    // Set field flags    \n    ReturnFields returnFields = new SolrReturnFields( req );\n    rsp.setReturnFields( returnFields );\n    int flags = 0;\n    if (returnFields.wantsScore()) {\n      flags |= SolrIndexSearcher.GET_SCORES;\n    }\n    rb.setFieldFlags( flags );\n\n    String defType = params.get(QueryParsing.DEFTYPE, QParserPlugin.DEFAULT_QTYPE);\n\n    // get it from the response builder to give a different component a chance\n    // to set it.\n    String queryString = rb.getQueryString();\n    if (queryString == null) {\n      // this is the normal way it's set.\n      queryString = params.get( CommonParams.Q );\n      rb.setQueryString(queryString);\n    }\n\n    try {\n      QParser parser = QParser.getParser(rb.getQueryString(), defType, req);\n      Query q = parser.getQuery();\n      if (q == null) {\n        // normalize a null query to a query that matches nothing\n        q = new MatchNoDocsQuery();\n      }\n\n      rb.setQuery( q );\n\n      String rankQueryString = rb.req.getParams().get(CommonParams.RQ);\n      if(rankQueryString != null) {\n        QParser rqparser = QParser.getParser(rankQueryString, req);\n        Query rq = rqparser.getQuery();\n        if(rq instanceof RankQuery) {\n          RankQuery rankQuery = (RankQuery)rq;\n          rb.setRankQuery(rankQuery);\n          MergeStrategy mergeStrategy = rankQuery.getMergeStrategy();\n          if(mergeStrategy != null) {\n            rb.addMergeStrategy(mergeStrategy);\n            if(mergeStrategy.handlesMergeFields()) {\n              rb.mergeFieldHandler = mergeStrategy;\n            }\n          }\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\"rq parameter must be a RankQuery\");\n        }\n      }\n\n      rb.setSortSpec( parser.getSortSpec(true) );\n      rb.setQparser(parser);\n\n      final String cursorStr = rb.req.getParams().get(CursorMarkParams.CURSOR_MARK_PARAM);\n      if (null != cursorStr) {\n        final CursorMark cursorMark = new CursorMark(rb.req.getSchema(),\n                                                     rb.getSortSpec());\n        cursorMark.parseSerializedTotem(cursorStr);\n        rb.setCursorMark(cursorMark);\n      }\n\n      String[] fqs = req.getParams().getParams(CommonParams.FQ);\n      if (fqs!=null && fqs.length!=0) {\n        List<Query> filters = rb.getFilters();\n        // if filters already exists, make a copy instead of modifying the original\n        filters = filters == null ? new ArrayList<>(fqs.length) : new ArrayList<>(filters);\n        for (String fq : fqs) {\n          if (fq != null && fq.trim().length()!=0) {\n            QParser fqp = QParser.getParser(fq, req);\n            fqp.setIsFilter(true);\n            filters.add(fqp.getQuery());\n          }\n        }\n        // only set the filters if they are not empty otherwise\n        // fq=&someotherParam= will trigger all docs filter for every request \n        // if filter cache is disabled\n        if (!filters.isEmpty()) {\n          rb.setFilters( filters );\n        }\n      }\n    } catch (SyntaxError | FuzzyTermsEnum.FuzzyTermsException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    if (params.getBool(GroupParams.GROUP, false)) {\n      prepareGrouping(rb);\n    } else {\n      //Validate only in case of non-grouping search.\n      if(rb.getSortSpec().getCount() < 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'rows' parameter cannot be negative\");\n      }\n    }\n\n    //Input validation.\n    if (rb.getSortSpec().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n  }\n\n","bugFix":["92ebaade309baf9560fb8102d941bd5d8534a825"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["79900e89f08cc17c4bcf49789dd61a2236ee7840","eaa9c67a05a203ff23b684274f05fcc22d38dfb3"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["08970e5b8411182a29412c177eff67ec1110095b","c88221aeda5571321ba2bf95de2a7348401230cf"],"07cbaf0735458446c429df54ba816915e8a1f638":["8bca25eefa1f2205e2b0ef713701dc3a0fecd702"],"2acf500f78aa12b92e371fd89c719291986b6b90":["50eb25774a5690a93352e49e7732b8008c5e681e","197070b7f9191af8b5d8598b579393d4a67e32f0"],"c7e0383a0a3421b9f6f61002dd4f6fb39bf71285":["5ba39ba201a572fd944ed71d888de0cd4f2957af"],"9567a7c3443a4d2f26e2bae683fb25265bc6f7ed":["0414a20d73ebe5c96a6e7e70e337083ec37f01fd"],"ff99371bc1f34bf1a2ccdb754940ee5fe5cc2565":["0414a20d73ebe5c96a6e7e70e337083ec37f01fd","9567a7c3443a4d2f26e2bae683fb25265bc6f7ed"],"197070b7f9191af8b5d8598b579393d4a67e32f0":["50eb25774a5690a93352e49e7732b8008c5e681e"],"d17ffdbce80d3dce181982a9cd16f4f90bc8619a":["3cdb67100dc016748799a77218aa409478372d79"],"46dc9ac8b3e748407baaef82453138ff3974480c":["68c354ba50abc8ed5c5fe98901e61d68f93952bb"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["50eb25774a5690a93352e49e7732b8008c5e681e","2acf500f78aa12b92e371fd89c719291986b6b90"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["c88221aeda5571321ba2bf95de2a7348401230cf","02453e8d9fe1bde22dc7676145ad809cb1dbfcad"],"e5b55cbdbc5dfead52f0b8b98d5867dcbacc39c4":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["46dc9ac8b3e748407baaef82453138ff3974480c"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","d17ffdbce80d3dce181982a9cd16f4f90bc8619a"],"6c70567cc1ae757045c80cb458b0b2a2ffcf0141":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"ccc08aa684aee4964baee0644a6ba047bfd70829":["c26f00b574427b55127e869b935845554afde1fa"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"d5bc8e25f59990525f5beb14afe9c96240dcf4a2":["02453e8d9fe1bde22dc7676145ad809cb1dbfcad"],"79900e89f08cc17c4bcf49789dd61a2236ee7840":["46dc9ac8b3e748407baaef82453138ff3974480c"],"08970e5b8411182a29412c177eff67ec1110095b":["d17ffdbce80d3dce181982a9cd16f4f90bc8619a"],"eaa9c67a05a203ff23b684274f05fcc22d38dfb3":["79900e89f08cc17c4bcf49789dd61a2236ee7840"],"ccc69a67d5c846a04c7f71e28cb1914e3af895f3":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","6c70567cc1ae757045c80cb458b0b2a2ffcf0141"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["c7e0383a0a3421b9f6f61002dd4f6fb39bf71285"],"8bca25eefa1f2205e2b0ef713701dc3a0fecd702":["e5b55cbdbc5dfead52f0b8b98d5867dcbacc39c4","cc5ee54a993d26579e3fe1f8f2a696b46b61c48f"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["5ba39ba201a572fd944ed71d888de0cd4f2957af","c7e0383a0a3421b9f6f61002dd4f6fb39bf71285"],"02453e8d9fe1bde22dc7676145ad809cb1dbfcad":["c88221aeda5571321ba2bf95de2a7348401230cf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c88221aeda5571321ba2bf95de2a7348401230cf":["08970e5b8411182a29412c177eff67ec1110095b"],"50eb25774a5690a93352e49e7732b8008c5e681e":["9567a7c3443a4d2f26e2bae683fb25265bc6f7ed"],"92ebaade309baf9560fb8102d941bd5d8534a825":["b94236357aaa22b76c10629851fe4e376e0cea82"],"02b85e1409bc02521b64db6daeddf08cdd3974c2":["c218ef5584c663e78bdaf8391f826546f5bc73c1"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["d5bc8e25f59990525f5beb14afe9c96240dcf4a2"],"79788042790c9ded974d85e96aae1b2b3f0ca735":["92ebaade309baf9560fb8102d941bd5d8534a825"],"c218ef5584c663e78bdaf8391f826546f5bc73c1":["6c70567cc1ae757045c80cb458b0b2a2ffcf0141"],"3cdb67100dc016748799a77218aa409478372d79":["2acf500f78aa12b92e371fd89c719291986b6b90"],"407687e67faf6e1f02a211ca078d8e3eed631027":["2acf500f78aa12b92e371fd89c719291986b6b90","3cdb67100dc016748799a77218aa409478372d79"],"cc5ee54a993d26579e3fe1f8f2a696b46b61c48f":["e5b55cbdbc5dfead52f0b8b98d5867dcbacc39c4"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["e5b55cbdbc5dfead52f0b8b98d5867dcbacc39c4","07cbaf0735458446c429df54ba816915e8a1f638"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":["727bb765ff2542275f6d31f67be18d7104bae148","46dc9ac8b3e748407baaef82453138ff3974480c"],"46d8ada1fff8d18cb197c38c7983225162599948":["50eb25774a5690a93352e49e7732b8008c5e681e","2acf500f78aa12b92e371fd89c719291986b6b90"],"0414a20d73ebe5c96a6e7e70e337083ec37f01fd":["ccc08aa684aee4964baee0644a6ba047bfd70829"],"727bb765ff2542275f6d31f67be18d7104bae148":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","68c354ba50abc8ed5c5fe98901e61d68f93952bb"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"68c354ba50abc8ed5c5fe98901e61d68f93952bb":["07cbaf0735458446c429df54ba816915e8a1f638"],"5ba39ba201a572fd944ed71d888de0cd4f2957af":["02b85e1409bc02521b64db6daeddf08cdd3974c2"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["e5b55cbdbc5dfead52f0b8b98d5867dcbacc39c4","8bca25eefa1f2205e2b0ef713701dc3a0fecd702"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["79788042790c9ded974d85e96aae1b2b3f0ca735"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["92ebaade309baf9560fb8102d941bd5d8534a825"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"07cbaf0735458446c429df54ba816915e8a1f638":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","68c354ba50abc8ed5c5fe98901e61d68f93952bb"],"2acf500f78aa12b92e371fd89c719291986b6b90":["fe33227f6805edab2036cbb80645cc4e2d1fa424","3cdb67100dc016748799a77218aa409478372d79","407687e67faf6e1f02a211ca078d8e3eed631027","46d8ada1fff8d18cb197c38c7983225162599948"],"c7e0383a0a3421b9f6f61002dd4f6fb39bf71285":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"9567a7c3443a4d2f26e2bae683fb25265bc6f7ed":["ff99371bc1f34bf1a2ccdb754940ee5fe5cc2565","50eb25774a5690a93352e49e7732b8008c5e681e"],"ff99371bc1f34bf1a2ccdb754940ee5fe5cc2565":[],"197070b7f9191af8b5d8598b579393d4a67e32f0":["2acf500f78aa12b92e371fd89c719291986b6b90"],"d17ffdbce80d3dce181982a9cd16f4f90bc8619a":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","08970e5b8411182a29412c177eff67ec1110095b"],"46dc9ac8b3e748407baaef82453138ff3974480c":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","79900e89f08cc17c4bcf49789dd61a2236ee7840","90a682dc1bfd188ef61cc28373c7f5d700b4ac75"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"e5b55cbdbc5dfead52f0b8b98d5867dcbacc39c4":["8bca25eefa1f2205e2b0ef713701dc3a0fecd702","cc5ee54a993d26579e3fe1f8f2a696b46b61c48f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":[],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"6c70567cc1ae757045c80cb458b0b2a2ffcf0141":["ccc69a67d5c846a04c7f71e28cb1914e3af895f3","c218ef5584c663e78bdaf8391f826546f5bc73c1"],"ccc08aa684aee4964baee0644a6ba047bfd70829":["0414a20d73ebe5c96a6e7e70e337083ec37f01fd"],"c26f00b574427b55127e869b935845554afde1fa":["ccc08aa684aee4964baee0644a6ba047bfd70829"],"d5bc8e25f59990525f5beb14afe9c96240dcf4a2":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"79900e89f08cc17c4bcf49789dd61a2236ee7840":["b94236357aaa22b76c10629851fe4e376e0cea82","eaa9c67a05a203ff23b684274f05fcc22d38dfb3"],"eaa9c67a05a203ff23b684274f05fcc22d38dfb3":["b94236357aaa22b76c10629851fe4e376e0cea82"],"08970e5b8411182a29412c177eff67ec1110095b":["37a0f60745e53927c4c876cfe5b5a58170f0646c","c88221aeda5571321ba2bf95de2a7348401230cf"],"ccc69a67d5c846a04c7f71e28cb1914e3af895f3":[],"8bca25eefa1f2205e2b0ef713701dc3a0fecd702":["07cbaf0735458446c429df54ba816915e8a1f638","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["e5b55cbdbc5dfead52f0b8b98d5867dcbacc39c4"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"02453e8d9fe1bde22dc7676145ad809cb1dbfcad":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","d5bc8e25f59990525f5beb14afe9c96240dcf4a2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"c88221aeda5571321ba2bf95de2a7348401230cf":["37a0f60745e53927c4c876cfe5b5a58170f0646c","74f45af4339b0daf7a95c820ab88c1aea74fbce0","02453e8d9fe1bde22dc7676145ad809cb1dbfcad"],"50eb25774a5690a93352e49e7732b8008c5e681e":["2acf500f78aa12b92e371fd89c719291986b6b90","197070b7f9191af8b5d8598b579393d4a67e32f0","fe33227f6805edab2036cbb80645cc4e2d1fa424","46d8ada1fff8d18cb197c38c7983225162599948"],"92ebaade309baf9560fb8102d941bd5d8534a825":["79788042790c9ded974d85e96aae1b2b3f0ca735"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6c70567cc1ae757045c80cb458b0b2a2ffcf0141","ccc69a67d5c846a04c7f71e28cb1914e3af895f3"],"02b85e1409bc02521b64db6daeddf08cdd3974c2":["5ba39ba201a572fd944ed71d888de0cd4f2957af"],"79788042790c9ded974d85e96aae1b2b3f0ca735":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb67100dc016748799a77218aa409478372d79":["d17ffdbce80d3dce181982a9cd16f4f90bc8619a","407687e67faf6e1f02a211ca078d8e3eed631027"],"c218ef5584c663e78bdaf8391f826546f5bc73c1":["02b85e1409bc02521b64db6daeddf08cdd3974c2"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"cc5ee54a993d26579e3fe1f8f2a696b46b61c48f":["8bca25eefa1f2205e2b0ef713701dc3a0fecd702"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["727bb765ff2542275f6d31f67be18d7104bae148"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":[],"46d8ada1fff8d18cb197c38c7983225162599948":[],"0414a20d73ebe5c96a6e7e70e337083ec37f01fd":["9567a7c3443a4d2f26e2bae683fb25265bc6f7ed","ff99371bc1f34bf1a2ccdb754940ee5fe5cc2565"],"727bb765ff2542275f6d31f67be18d7104bae148":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"5ba39ba201a572fd944ed71d888de0cd4f2957af":["c7e0383a0a3421b9f6f61002dd4f6fb39bf71285","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"68c354ba50abc8ed5c5fe98901e61d68f93952bb":["46dc9ac8b3e748407baaef82453138ff3974480c","727bb765ff2542275f6d31f67be18d7104bae148"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","ff99371bc1f34bf1a2ccdb754940ee5fe5cc2565","fe33227f6805edab2036cbb80645cc4e2d1fa424","74f45af4339b0daf7a95c820ab88c1aea74fbce0","54ca69905c5d9d1529286f06ab1d12c68f6c13cb","d3fcb70cf561547c7bb1506e0cf32ca7b1287064","ccc69a67d5c846a04c7f71e28cb1914e3af895f3","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","90a682dc1bfd188ef61cc28373c7f5d700b4ac75","46d8ada1fff8d18cb197c38c7983225162599948","a258fbb26824fd104ed795e5d9033d2d040049ee","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}