{"path":"src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","commits":[{"id":"4f483a44e10befaaa6da11d433e2eb0f52829eec","date":1175273998,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","pathOld":"/dev/null","sourceNew":"  public void testCSV() throws Exception {\n    lrf.args.put(\"version\",\"2.0\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:101\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='my_s'][.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\");\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"39fe916f708b7a41a8b8f6572f135e2cb4d66aed","date":1175360846,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","pathOld":"src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","sourceNew":"  public void testCSV() throws Exception {\n    lrf.args.put(\"version\",\"2.0\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:101\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='my_s'][.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\");\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n\n  }\n\n","sourceOld":"  public void testCSV() throws Exception {\n    lrf.args.put(\"version\",\"2.0\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:101\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='my_s'][.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\");\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0ffb19816b9fdb274ff9ba1773474003ae2ebd8","date":1196647530,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","pathOld":"src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","sourceNew":"  public void testCSV() throws Exception {\n    lrf.args.put(\"version\",\"2.0\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:101\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='my_s'][.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\");\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n\n  }\n\n","sourceOld":"  public void testCSV() throws Exception {\n    lrf.args.put(\"version\",\"2.0\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:101\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='my_s'][.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\");\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bddf871b13db29360a473667cf42e0b0e2572572","date":1199634230,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","pathOld":"src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","sourceNew":"  public void testCSV() throws Exception {\n    lrf.args.put(\"version\",\"2.0\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:101\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='my_s'][.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//str[@name='str_s'][.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","sourceOld":"  public void testCSV() throws Exception {\n    lrf.args.put(\"version\",\"2.0\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:101\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='my_s'][.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\");\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","pathOld":"src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","sourceNew":"  public void testCSV() throws Exception {\n    lrf.args.put(\"version\",\"2.0\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:101\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='my_s'][.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//str[@name='str_s'][.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","sourceOld":"  public void testCSV() throws Exception {\n    lrf.args.put(\"version\",\"2.0\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:101\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//str[@name='my_s'][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='my_s'][.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s'])=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//str[@name='my_s'][.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//str[@name='str_s'][.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//str[@name='str_s'][.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//str[@name='str_s'][.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//str[@name='str_s'][.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//str[@name='str_s'][.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bddf871b13db29360a473667cf42e0b0e2572572":["b0ffb19816b9fdb274ff9ba1773474003ae2ebd8"],"b0ffb19816b9fdb274ff9ba1773474003ae2ebd8":["39fe916f708b7a41a8b8f6572f135e2cb4d66aed"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"ad94625fb8d088209f46650c8097196fec67f00c":["bddf871b13db29360a473667cf42e0b0e2572572"],"39fe916f708b7a41a8b8f6572f135e2cb4d66aed":["4f483a44e10befaaa6da11d433e2eb0f52829eec"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4f483a44e10befaaa6da11d433e2eb0f52829eec":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"]},"commit2Childs":{"bddf871b13db29360a473667cf42e0b0e2572572":["ad94625fb8d088209f46650c8097196fec67f00c"],"b0ffb19816b9fdb274ff9ba1773474003ae2ebd8":["bddf871b13db29360a473667cf42e0b0e2572572"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["4f483a44e10befaaa6da11d433e2eb0f52829eec"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"39fe916f708b7a41a8b8f6572f135e2cb4d66aed":["b0ffb19816b9fdb274ff9ba1773474003ae2ebd8"],"4f483a44e10befaaa6da11d433e2eb0f52829eec":["39fe916f708b7a41a8b8f6572f135e2cb4d66aed"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}