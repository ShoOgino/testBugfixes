{"path":"lucene/core/src/java/org/apache/lucene/codecs/SimpleDVConsumer#mergeSortedField(FieldInfo,MergeState,List[SortedDocValues]).mjava","commits":[{"id":"4b53a9a930ee01857178a1b512fbab24642f3fa8","date":1354471097,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/SimpleDVConsumer#mergeSortedField(FieldInfo,MergeState,List[SortedDocValues]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/SimpleDVConsumer#mergeSortedField(MergeState).mjava","sourceNew":"  public void mergeSortedField(FieldInfo fieldInfo, MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    SortedDocValuesConsumer.Merger merger = new SortedDocValuesConsumer.Merger();\n    merger.merge(mergeState, toMerge);\n    SortedDocValuesConsumer consumer = addSortedField(fieldInfo, merger.numMergedTerms, merger.fixedLength >= 0, merger.maxLength);\n    consumer.merge(mergeState, merger);\n  }\n\n","sourceOld":"  protected void mergeSortedField(MergeState mergeState) throws IOException {\n    SortedDocValuesConsumer.Merger merger = new SortedDocValuesConsumer.Merger();\n    merger.merge(mergeState);\n    SortedDocValuesConsumer consumer = addSortedField(mergeState.fieldInfo, merger.numMergedTerms, merger.fixedLength >= 0, merger.maxLength);\n    consumer.merge(mergeState, merger);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1ed9002c5afac843c7f2d04d88e74b40d627e1af","date":1357602069,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/SimpleDVConsumer#mergeSortedField(FieldInfo,MergeState,List[SortedDocValues]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/SimpleDVConsumer#mergeSortedField(FieldInfo,MergeState,List[SortedDocValues]).mjava","sourceNew":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    final SortedBytesMerger merger = new SortedBytesMerger();\n\n    // Does the heavy lifting to merge sort all \"live\" ords:\n    merger.merge(mergeState, toMerge);\n\n    addSortedField(fieldInfo,\n\n                   // ord -> value\n                   new Iterable<BytesRef>() {\n                     @Override\n                     public Iterator<BytesRef> iterator() {\n                       return new Iterator<BytesRef>() {\n                         int ordUpto;\n\n                         @Override\n                         public boolean hasNext() {\n                           return ordUpto < merger.mergedTerms.size();\n                         }\n\n                         @Override\n                         public void remove() {\n                           throw new UnsupportedOperationException();\n                         }\n\n                         @Override\n                         public BytesRef next() {\n                           return merger.mergedTerms.get(ordUpto++);\n                         }\n                       };\n                     }\n                   },\n\n                   // doc -> ord\n                    new Iterable<Number>() {\n                      @Override\n                      public Iterator<Number> iterator() {\n                        return new Iterator<Number>() {\n                          int readerUpto = -1;\n                          int docIDUpto;\n                          int nextValue;\n                          SortedBytesMerger.SegmentState currentReader;\n                          Bits currentLiveDocs;\n                          boolean nextIsSet;\n\n                          @Override\n                          public boolean hasNext() {\n                            return nextIsSet || setNext();\n                          }\n\n                          @Override\n                          public void remove() {\n                            throw new UnsupportedOperationException();\n                          }\n\n                          @Override\n                          public Number next() {\n                            if (!hasNext()) {\n                              throw new NoSuchElementException();\n                            }\n                            assert nextIsSet;\n                            nextIsSet = false;\n                            // nocommit make a mutable number\n                            return nextValue;\n                          }\n\n                          private boolean setNext() {\n                            while (true) {\n                              if (readerUpto == merger.segStates.size()) {\n                                return false;\n                              }\n\n                              if (currentReader == null || docIDUpto == currentReader.reader.maxDoc()) {\n                                readerUpto++;\n                                if (readerUpto < merger.segStates.size()) {\n                                  currentReader = merger.segStates.get(readerUpto);\n                                  currentLiveDocs = currentReader.reader.getLiveDocs();\n                                }\n                                docIDUpto = 0;\n                                continue;\n                              }\n\n                              if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                                nextIsSet = true;\n                                int segOrd = currentReader.values.getOrd(docIDUpto);\n                                nextValue = currentReader.segOrdToMergedOrd[segOrd];\n                                docIDUpto++;\n                                return true;\n                              }\n\n                              docIDUpto++;\n                            }\n                          }\n                        };\n                      }\n                    });\n\n  }\n\n","sourceOld":"  public void mergeSortedField(FieldInfo fieldInfo, MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    SortedDocValuesConsumer.Merger merger = new SortedDocValuesConsumer.Merger();\n    merger.merge(mergeState, toMerge);\n    SortedDocValuesConsumer consumer = addSortedField(fieldInfo, merger.numMergedTerms, merger.fixedLength >= 0, merger.maxLength);\n    consumer.merge(mergeState, merger);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200","date":1358521790,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer#mergeSortedField(FieldInfo,MergeState,List[SortedDocValues]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/SimpleDVConsumer#mergeSortedField(FieldInfo,MergeState,List[SortedDocValues]).mjava","sourceNew":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    final SortedBytesMerger merger = new SortedBytesMerger();\n\n    // Does the heavy lifting to merge sort all \"live\" ords:\n    merger.merge(mergeState, toMerge);\n\n    addSortedField(fieldInfo,\n\n                   // ord -> value\n                   new Iterable<BytesRef>() {\n                     @Override\n                     public Iterator<BytesRef> iterator() {\n                       return new Iterator<BytesRef>() {\n                         int ordUpto;\n\n                         @Override\n                         public boolean hasNext() {\n                           return ordUpto < merger.mergedTerms.size();\n                         }\n\n                         @Override\n                         public void remove() {\n                           throw new UnsupportedOperationException();\n                         }\n\n                         @Override\n                         public BytesRef next() {\n                           return merger.mergedTerms.get(ordUpto++);\n                         }\n                       };\n                     }\n                   },\n\n                   // doc -> ord\n                    new Iterable<Number>() {\n                      @Override\n                      public Iterator<Number> iterator() {\n                        return new Iterator<Number>() {\n                          int readerUpto = -1;\n                          int docIDUpto;\n                          int nextValue;\n                          SortedBytesMerger.SegmentState currentReader;\n                          Bits currentLiveDocs;\n                          boolean nextIsSet;\n\n                          @Override\n                          public boolean hasNext() {\n                            return nextIsSet || setNext();\n                          }\n\n                          @Override\n                          public void remove() {\n                            throw new UnsupportedOperationException();\n                          }\n\n                          @Override\n                          public Number next() {\n                            if (!hasNext()) {\n                              throw new NoSuchElementException();\n                            }\n                            assert nextIsSet;\n                            nextIsSet = false;\n                            // nocommit make a mutable number\n                            return nextValue;\n                          }\n\n                          private boolean setNext() {\n                            while (true) {\n                              if (readerUpto == merger.segStates.size()) {\n                                return false;\n                              }\n\n                              if (currentReader == null || docIDUpto == currentReader.reader.maxDoc()) {\n                                readerUpto++;\n                                if (readerUpto < merger.segStates.size()) {\n                                  currentReader = merger.segStates.get(readerUpto);\n                                  currentLiveDocs = currentReader.reader.getLiveDocs();\n                                }\n                                docIDUpto = 0;\n                                continue;\n                              }\n\n                              if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                                nextIsSet = true;\n                                int segOrd = currentReader.values.getOrd(docIDUpto);\n                                nextValue = currentReader.segOrdToMergedOrd[segOrd];\n                                docIDUpto++;\n                                return true;\n                              }\n\n                              docIDUpto++;\n                            }\n                          }\n                        };\n                      }\n                    });\n\n  }\n\n","sourceOld":"  public void mergeSortedField(FieldInfo fieldInfo, final MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {\n    final SortedBytesMerger merger = new SortedBytesMerger();\n\n    // Does the heavy lifting to merge sort all \"live\" ords:\n    merger.merge(mergeState, toMerge);\n\n    addSortedField(fieldInfo,\n\n                   // ord -> value\n                   new Iterable<BytesRef>() {\n                     @Override\n                     public Iterator<BytesRef> iterator() {\n                       return new Iterator<BytesRef>() {\n                         int ordUpto;\n\n                         @Override\n                         public boolean hasNext() {\n                           return ordUpto < merger.mergedTerms.size();\n                         }\n\n                         @Override\n                         public void remove() {\n                           throw new UnsupportedOperationException();\n                         }\n\n                         @Override\n                         public BytesRef next() {\n                           return merger.mergedTerms.get(ordUpto++);\n                         }\n                       };\n                     }\n                   },\n\n                   // doc -> ord\n                    new Iterable<Number>() {\n                      @Override\n                      public Iterator<Number> iterator() {\n                        return new Iterator<Number>() {\n                          int readerUpto = -1;\n                          int docIDUpto;\n                          int nextValue;\n                          SortedBytesMerger.SegmentState currentReader;\n                          Bits currentLiveDocs;\n                          boolean nextIsSet;\n\n                          @Override\n                          public boolean hasNext() {\n                            return nextIsSet || setNext();\n                          }\n\n                          @Override\n                          public void remove() {\n                            throw new UnsupportedOperationException();\n                          }\n\n                          @Override\n                          public Number next() {\n                            if (!hasNext()) {\n                              throw new NoSuchElementException();\n                            }\n                            assert nextIsSet;\n                            nextIsSet = false;\n                            // nocommit make a mutable number\n                            return nextValue;\n                          }\n\n                          private boolean setNext() {\n                            while (true) {\n                              if (readerUpto == merger.segStates.size()) {\n                                return false;\n                              }\n\n                              if (currentReader == null || docIDUpto == currentReader.reader.maxDoc()) {\n                                readerUpto++;\n                                if (readerUpto < merger.segStates.size()) {\n                                  currentReader = merger.segStates.get(readerUpto);\n                                  currentLiveDocs = currentReader.reader.getLiveDocs();\n                                }\n                                docIDUpto = 0;\n                                continue;\n                              }\n\n                              if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                                nextIsSet = true;\n                                int segOrd = currentReader.values.getOrd(docIDUpto);\n                                nextValue = currentReader.segOrdToMergedOrd[segOrd];\n                                docIDUpto++;\n                                return true;\n                              }\n\n                              docIDUpto++;\n                            }\n                          }\n                        };\n                      }\n                    });\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200":["1ed9002c5afac843c7f2d04d88e74b40d627e1af"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4b53a9a930ee01857178a1b512fbab24642f3fa8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1ed9002c5afac843c7f2d04d88e74b40d627e1af":["4b53a9a930ee01857178a1b512fbab24642f3fa8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4b53a9a930ee01857178a1b512fbab24642f3fa8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4b53a9a930ee01857178a1b512fbab24642f3fa8":["1ed9002c5afac843c7f2d04d88e74b40d627e1af"],"1ed9002c5afac843c7f2d04d88e74b40d627e1af":["b8acf0807ca5f38beda8e0f7d5ab46ff39f81200"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b8acf0807ca5f38beda8e0f7d5ab46ff39f81200","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}