{"path":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","pathOld":"/dev/null","sourceNew":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<List<Update>>(logList.size());\n      deleteByQueryList = new ArrayList<Update>();\n      updates = new HashMap<Long,Update>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<Update>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = reader.next();\n            if (o==null) break;\n            try {\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int oper = (Integer)entry.get(0);\n              long version = (Long) entry.get(1);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n                  \n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  }\n                  \n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["e99829242bceda4cf974ec0eb5d82d713615b3da","0833b652ff242e439e7c2e346fb3b6601fb0a3d3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","pathOld":"/dev/null","sourceNew":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<List<Update>>(logList.size());\n      deleteByQueryList = new ArrayList<Update>();\n      updates = new HashMap<Long,Update>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<Update>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = reader.next();\n            if (o==null) break;\n            try {\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int oper = (Integer)entry.get(0);\n              long version = (Long) entry.get(1);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n                  \n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  }\n                  \n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","pathOld":"/dev/null","sourceNew":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<List<Update>>(logList.size());\n      deleteByQueryList = new ArrayList<Update>();\n      updates = new HashMap<Long,Update>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<Update>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = reader.next();\n            if (o==null) break;\n            try {\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int oper = (Integer)entry.get(0);\n              long version = (Long) entry.get(1);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n                  \n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  }\n                  \n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"414ae8f6c01f0259255c532b2bd51b03000c2480","date":1329623863,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","sourceNew":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<List<Update>>(logList.size());\n      deleteByQueryList = new ArrayList<Update>();\n      deleteList = new ArrayList<DeleteUpdate>();\n      updates = new HashMap<Long,Update>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<Update>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = reader.next();\n            if (o==null) break;\n            try {\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int oper = (Integer)entry.get(0);\n              long version = (Long) entry.get(1);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n                  \n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n                  \n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","sourceOld":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<List<Update>>(logList.size());\n      deleteByQueryList = new ArrayList<Update>();\n      updates = new HashMap<Long,Update>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<Update>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = reader.next();\n            if (o==null) break;\n            try {\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int oper = (Integer)entry.get(0);\n              long version = (Long) entry.get(1);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n                  \n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  }\n                  \n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e99829242bceda4cf974ec0eb5d82d713615b3da","date":1337646971,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","sourceNew":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<List<Update>>(logList.size());\n      deleteByQueryList = new ArrayList<Update>();\n      deleteList = new ArrayList<DeleteUpdate>();\n      updates = new HashMap<Long,Update>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<Update>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = reader.next();\n            if (o==null) break;\n            try {\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(0);\n              if (latestOperation == 0) {\n                latestOperation = opAndFlags;\n              }\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(1);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n                  \n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n                  \n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","sourceOld":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<List<Update>>(logList.size());\n      deleteByQueryList = new ArrayList<Update>();\n      deleteList = new ArrayList<DeleteUpdate>();\n      updates = new HashMap<Long,Update>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<Update>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = reader.next();\n            if (o==null) break;\n            try {\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int oper = (Integer)entry.get(0);\n              long version = (Long) entry.get(1);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n                  \n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n                  \n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3599646b4d4c346cf74d334813488b8b337b5bf5","date":1337790261,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","sourceNew":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<List<Update>>(logList.size());\n      deleteByQueryList = new ArrayList<Update>();\n      deleteList = new ArrayList<DeleteUpdate>();\n      updates = new HashMap<Long,Update>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<Update>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = reader.next();\n            if (o==null) break;\n            try {\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(0);\n              if (latestOperation == 0) {\n                latestOperation = opAndFlags;\n              }\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(1);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n                  \n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n                  \n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","sourceOld":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<List<Update>>(logList.size());\n      deleteByQueryList = new ArrayList<Update>();\n      deleteList = new ArrayList<DeleteUpdate>();\n      updates = new HashMap<Long,Update>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<Update>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = reader.next();\n            if (o==null) break;\n            try {\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int oper = (Integer)entry.get(0);\n              long version = (Long) entry.get(1);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n                  \n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n                  \n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0833b652ff242e439e7c2e346fb3b6601fb0a3d3","date":1359141451,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","sourceNew":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<List<Update>>(logList.size());\n      deleteByQueryList = new ArrayList<Update>();\n      deleteList = new ArrayList<DeleteUpdate>();\n      updates = new HashMap<Long,Update>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<Update>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n              \n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(0);\n              if (latestOperation == 0) {\n                latestOperation = opAndFlags;\n              }\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(1);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n                  \n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n                  \n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","sourceOld":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<List<Update>>(logList.size());\n      deleteByQueryList = new ArrayList<Update>();\n      deleteList = new ArrayList<DeleteUpdate>();\n      updates = new HashMap<Long,Update>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<Update>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = reader.next();\n            if (o==null) break;\n            try {\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(0);\n              if (latestOperation == 0) {\n                latestOperation = opAndFlags;\n              }\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(1);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n                  \n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n                  \n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd45d4a2ee01a1932d33eec42f5272c2402da679","date":1359316912,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","sourceNew":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<List<Update>>(logList.size());\n      deleteByQueryList = new ArrayList<Update>();\n      deleteList = new ArrayList<DeleteUpdate>();\n      updates = new HashMap<Long,Update>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<Update>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n              \n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(0);\n              if (latestOperation == 0) {\n                latestOperation = opAndFlags;\n              }\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(1);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n                  \n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n                  \n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","sourceOld":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<List<Update>>(logList.size());\n      deleteByQueryList = new ArrayList<Update>();\n      deleteList = new ArrayList<DeleteUpdate>();\n      updates = new HashMap<Long,Update>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<Update>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = reader.next();\n            if (o==null) break;\n            try {\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(0);\n              if (latestOperation == 0) {\n                latestOperation = opAndFlags;\n              }\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(1);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n                  \n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n                  \n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09aa6810f7773e562ee1780fc2f29c47fbe8d25b","date":1369928061,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","sourceNew":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<List<Update>>(logList.size());\n      deleteByQueryList = new ArrayList<Update>();\n      deleteList = new ArrayList<DeleteUpdate>();\n      updates = new HashMap<Long,Update>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<Update>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n              \n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(0);\n              if (latestOperation == 0) {\n                latestOperation = opAndFlags;\n              }\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(1);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n                  \n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n                  \n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","sourceOld":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<List<Update>>(logList.size());\n      deleteByQueryList = new ArrayList<Update>();\n      deleteList = new ArrayList<DeleteUpdate>();\n      updates = new HashMap<Long,Update>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<Update>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n              \n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(0);\n              if (latestOperation == 0) {\n                latestOperation = opAndFlags;\n              }\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(1);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n                  \n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n                  \n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","sourceNew":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<>(logList.size());\n      deleteByQueryList = new ArrayList<>();\n      deleteList = new ArrayList<>();\n      updates = new HashMap<>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n              \n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(0);\n              if (latestOperation == 0) {\n                latestOperation = opAndFlags;\n              }\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(1);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n                  \n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n                  \n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","sourceOld":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<List<Update>>(logList.size());\n      deleteByQueryList = new ArrayList<Update>();\n      deleteList = new ArrayList<DeleteUpdate>();\n      updates = new HashMap<Long,Update>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<Update>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n              \n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(0);\n              if (latestOperation == 0) {\n                latestOperation = opAndFlags;\n              }\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(1);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n                  \n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n                  \n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86290366cefc1b9d4eced13b430858c4a4c0421d","date":1432321109,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","sourceNew":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<>(logList.size());\n      deleteByQueryList = new ArrayList<>();\n      deleteList = new ArrayList<>();\n      updates = new HashMap<>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(0);\n              if (latestOperation == 0) {\n                latestOperation = opAndFlags;\n              }\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(1);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n\n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n\n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","sourceOld":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<>(logList.size());\n      deleteByQueryList = new ArrayList<>();\n      deleteList = new ArrayList<>();\n      updates = new HashMap<>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n              \n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(0);\n              if (latestOperation == 0) {\n                latestOperation = opAndFlags;\n              }\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(1);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n                  \n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n                  \n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"415bbbe7da8065dd3c477bdc3c703c6425622998","date":1485393793,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","sourceNew":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<>(logList.size());\n      deleteByQueryList = new ArrayList<>();\n      deleteList = new ArrayList<>();\n      updates = new HashMap<>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(UpdateLog.FLAGS_IDX);\n              if (latestOperation == 0) {\n                latestOperation = opAndFlags;\n              }\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.UPDATE_INPLACE:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  if (oper == UpdateLog.UPDATE_INPLACE && entry.size() == 5) {\n                    update.previousVersion = (Long) entry.get(UpdateLog.PREV_VERSION_IDX);\n                  }\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n\n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(entry.size()-1)));\n                  }\n\n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","sourceOld":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<>(logList.size());\n      deleteByQueryList = new ArrayList<>();\n      deleteList = new ArrayList<>();\n      updates = new HashMap<>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(0);\n              if (latestOperation == 0) {\n                latestOperation = opAndFlags;\n              }\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(1);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n\n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n\n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","bugFix":null,"bugIntro":["d030a7298c5397ab744a356c18ccda17f76f77f7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"598b5d23aa7c9732bf473c21a9cd309c44599394","date":1485530378,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","sourceNew":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<>(logList.size());\n      deleteByQueryList = new ArrayList<>();\n      deleteList = new ArrayList<>();\n      updates = new HashMap<>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(UpdateLog.FLAGS_IDX);\n              if (latestOperation == 0) {\n                latestOperation = opAndFlags;\n              }\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.UPDATE_INPLACE:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  if (oper == UpdateLog.UPDATE_INPLACE && entry.size() == 5) {\n                    update.previousVersion = (Long) entry.get(UpdateLog.PREV_VERSION_IDX);\n                  }\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n\n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(entry.size()-1)));\n                  }\n\n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","sourceOld":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<>(logList.size());\n      deleteByQueryList = new ArrayList<>();\n      deleteList = new ArrayList<>();\n      updates = new HashMap<>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(0);\n              if (latestOperation == 0) {\n                latestOperation = opAndFlags;\n              }\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(1);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n\n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n\n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d030a7298c5397ab744a356c18ccda17f76f77f7","date":1521234228,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","sourceNew":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<>(logList.size());\n      deleteByQueryList = new ArrayList<>();\n      deleteList = new ArrayList<>();\n      updates = new HashMap<>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(UpdateLog.FLAGS_IDX);\n              if (latestOperation == 0) {\n                latestOperation = opAndFlags;\n              }\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.UPDATE_INPLACE:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  if (oper == UpdateLog.UPDATE_INPLACE) {\n                    if ((update.log instanceof CdcrTransactionLog && entry.size() == 6) ||\n                        (!(update.log instanceof CdcrTransactionLog) && entry.size() == 5)) {\n                      update.previousVersion = (Long) entry.get(UpdateLog.PREV_VERSION_IDX);\n                    }\n                  }\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n\n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n\n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","sourceOld":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<>(logList.size());\n      deleteByQueryList = new ArrayList<>();\n      deleteList = new ArrayList<>();\n      updates = new HashMap<>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(UpdateLog.FLAGS_IDX);\n              if (latestOperation == 0) {\n                latestOperation = opAndFlags;\n              }\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.UPDATE_INPLACE:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  if (oper == UpdateLog.UPDATE_INPLACE && entry.size() == 5) {\n                    update.previousVersion = (Long) entry.get(UpdateLog.PREV_VERSION_IDX);\n                  }\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n\n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(entry.size()-1)));\n                  }\n\n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","bugFix":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"203e3fcf513c02ee2c07015f2ce277e26dc60907","date":1521404157,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","sourceNew":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<>(logList.size());\n      deleteByQueryList = new ArrayList<>();\n      deleteList = new ArrayList<>();\n      updates = new HashMap<>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(UpdateLog.FLAGS_IDX);\n              if (latestOperation == 0) {\n                latestOperation = opAndFlags;\n              }\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.UPDATE_INPLACE:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  if (oper == UpdateLog.UPDATE_INPLACE) {\n                    if ((update.log instanceof CdcrTransactionLog && entry.size() == 6) ||\n                        (!(update.log instanceof CdcrTransactionLog) && entry.size() == 5)) {\n                      update.previousVersion = (Long) entry.get(UpdateLog.PREV_VERSION_IDX);\n                    }\n                  }\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n\n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n\n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","sourceOld":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<>(logList.size());\n      deleteByQueryList = new ArrayList<>();\n      deleteList = new ArrayList<>();\n      updates = new HashMap<>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(UpdateLog.FLAGS_IDX);\n              if (latestOperation == 0) {\n                latestOperation = opAndFlags;\n              }\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.UPDATE_INPLACE:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  if (oper == UpdateLog.UPDATE_INPLACE && entry.size() == 5) {\n                    update.previousVersion = (Long) entry.get(UpdateLog.PREV_VERSION_IDX);\n                  }\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n\n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(entry.size()-1)));\n                  }\n\n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1455c941cc4ce652efc776fc23471b0e499246f6","date":1528086751,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","sourceNew":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<>(logList.size());\n      deleteByQueryList = new ArrayList<>();\n      deleteList = new ArrayList<>();\n      updates = new HashMap<>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(UpdateLog.FLAGS_IDX);\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.UPDATE_INPLACE:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  if (oper == UpdateLog.UPDATE_INPLACE) {\n                    if ((update.log instanceof CdcrTransactionLog && entry.size() == 6) ||\n                        (!(update.log instanceof CdcrTransactionLog) && entry.size() == 5)) {\n                      update.previousVersion = (Long) entry.get(UpdateLog.PREV_VERSION_IDX);\n                    }\n                  }\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n\n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n\n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","sourceOld":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<>(logList.size());\n      deleteByQueryList = new ArrayList<>();\n      deleteList = new ArrayList<>();\n      updates = new HashMap<>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(UpdateLog.FLAGS_IDX);\n              if (latestOperation == 0) {\n                latestOperation = opAndFlags;\n              }\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.UPDATE_INPLACE:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  if (oper == UpdateLog.UPDATE_INPLACE) {\n                    if ((update.log instanceof CdcrTransactionLog && entry.size() == 6) ||\n                        (!(update.log instanceof CdcrTransactionLog) && entry.size() == 5)) {\n                      update.previousVersion = (Long) entry.get(UpdateLog.PREV_VERSION_IDX);\n                    }\n                  }\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n\n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n\n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","sourceNew":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<>(logList.size());\n      deleteByQueryList = new ArrayList<>();\n      deleteList = new ArrayList<>();\n      updates = new HashMap<>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(UpdateLog.FLAGS_IDX);\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.UPDATE_INPLACE:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  if (oper == UpdateLog.UPDATE_INPLACE) {\n                    if ((update.log instanceof CdcrTransactionLog && entry.size() == 6) ||\n                        (!(update.log instanceof CdcrTransactionLog) && entry.size() == 5)) {\n                      update.previousVersion = (Long) entry.get(UpdateLog.PREV_VERSION_IDX);\n                    }\n                  }\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n\n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n\n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","sourceOld":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<>(logList.size());\n      deleteByQueryList = new ArrayList<>();\n      deleteList = new ArrayList<>();\n      updates = new HashMap<>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(UpdateLog.FLAGS_IDX);\n              if (latestOperation == 0) {\n                latestOperation = opAndFlags;\n              }\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.UPDATE_INPLACE:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  if (oper == UpdateLog.UPDATE_INPLACE) {\n                    if ((update.log instanceof CdcrTransactionLog && entry.size() == 6) ||\n                        (!(update.log instanceof CdcrTransactionLog) && entry.size() == 5)) {\n                      update.previousVersion = (Long) entry.get(UpdateLog.PREV_VERSION_IDX);\n                    }\n                  }\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n\n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n\n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","sourceNew":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<>(logList.size());\n      deleteByQueryList = new ArrayList<>();\n      deleteList = new ArrayList<>();\n      updates = new HashMap<>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(UpdateLog.FLAGS_IDX);\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.UPDATE_INPLACE:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  if (oper == UpdateLog.UPDATE_INPLACE) {\n                    if ((update.log instanceof CdcrTransactionLog && entry.size() == 6) ||\n                        (!(update.log instanceof CdcrTransactionLog) && entry.size() == 5)) {\n                      update.previousVersion = (Long) entry.get(UpdateLog.PREV_VERSION_IDX);\n                    }\n                  }\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n\n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n\n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","sourceOld":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<>(logList.size());\n      deleteByQueryList = new ArrayList<>();\n      deleteList = new ArrayList<>();\n      updates = new HashMap<>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(UpdateLog.FLAGS_IDX);\n              if (latestOperation == 0) {\n                latestOperation = opAndFlags;\n              }\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.UPDATE_INPLACE:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  if (oper == UpdateLog.UPDATE_INPLACE) {\n                    if ((update.log instanceof CdcrTransactionLog && entry.size() == 6) ||\n                        (!(update.log instanceof CdcrTransactionLog) && entry.size() == 5)) {\n                      update.previousVersion = (Long) entry.get(UpdateLog.PREV_VERSION_IDX);\n                    }\n                  }\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n\n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n\n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7","date":1529486762,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","sourceNew":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<>(logList.size());\n      deleteByQueryList = new ArrayList<>();\n      deleteList = new ArrayList<>();\n      updates = new HashMap<>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(UpdateLog.FLAGS_IDX);\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n              if (oldLog.isBuffer) bufferUpdates.add(version);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.UPDATE_INPLACE:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  if (oper == UpdateLog.UPDATE_INPLACE) {\n                    if ((update.log instanceof CdcrTransactionLog && entry.size() == 6) ||\n                        (!(update.log instanceof CdcrTransactionLog) && entry.size() == 5)) {\n                      update.previousVersion = (Long) entry.get(UpdateLog.PREV_VERSION_IDX);\n                    }\n                  }\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n\n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n\n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","sourceOld":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<>(logList.size());\n      deleteByQueryList = new ArrayList<>();\n      deleteList = new ArrayList<>();\n      updates = new HashMap<>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(UpdateLog.FLAGS_IDX);\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.UPDATE_INPLACE:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  if (oper == UpdateLog.UPDATE_INPLACE) {\n                    if ((update.log instanceof CdcrTransactionLog && entry.size() == 6) ||\n                        (!(update.log instanceof CdcrTransactionLog) && entry.size() == 5)) {\n                      update.previousVersion = (Long) entry.get(UpdateLog.PREV_VERSION_IDX);\n                    }\n                  }\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n\n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n\n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","sourceNew":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<>(logList.size());\n      deleteByQueryList = new ArrayList<>();\n      deleteList = new ArrayList<>();\n      updates = new HashMap<>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(UpdateLog.FLAGS_IDX);\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n              if (oldLog.isBuffer) bufferUpdates.add(version);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.UPDATE_INPLACE:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  if (oper == UpdateLog.UPDATE_INPLACE) {\n                    if ((update.log instanceof CdcrTransactionLog && entry.size() == 6) ||\n                        (!(update.log instanceof CdcrTransactionLog) && entry.size() == 5)) {\n                      update.previousVersion = (Long) entry.get(UpdateLog.PREV_VERSION_IDX);\n                    }\n                  }\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n\n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n\n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","sourceOld":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<>(logList.size());\n      deleteByQueryList = new ArrayList<>();\n      deleteList = new ArrayList<>();\n      updates = new HashMap<>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(UpdateLog.FLAGS_IDX);\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.UPDATE_INPLACE:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  if (oper == UpdateLog.UPDATE_INPLACE) {\n                    if ((update.log instanceof CdcrTransactionLog && entry.size() == 6) ||\n                        (!(update.log instanceof CdcrTransactionLog) && entry.size() == 5)) {\n                      update.previousVersion = (Long) entry.get(UpdateLog.PREV_VERSION_IDX);\n                    }\n                  }\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n\n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n\n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","sourceNew":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<>(logList.size());\n      deleteByQueryList = new ArrayList<>();\n      deleteList = new ArrayList<>();\n      updates = new HashMap<>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(UpdateLog.FLAGS_IDX);\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n              if (oldLog.isBuffer) bufferUpdates.add(version);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.UPDATE_INPLACE:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  if (oper == UpdateLog.UPDATE_INPLACE) {\n                    if ((update.log instanceof CdcrTransactionLog && entry.size() == 6) ||\n                        (!(update.log instanceof CdcrTransactionLog) && entry.size() == 5)) {\n                      update.previousVersion = (Long) entry.get(UpdateLog.PREV_VERSION_IDX);\n                    }\n                  }\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n\n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n\n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","sourceOld":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<>(logList.size());\n      deleteByQueryList = new ArrayList<>();\n      deleteList = new ArrayList<>();\n      updates = new HashMap<>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(UpdateLog.FLAGS_IDX);\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.UPDATE_INPLACE:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  if (oper == UpdateLog.UPDATE_INPLACE) {\n                    if ((update.log instanceof CdcrTransactionLog && entry.size() == 6) ||\n                        (!(update.log instanceof CdcrTransactionLog) && entry.size() == 5)) {\n                      update.previousVersion = (Long) entry.get(UpdateLog.PREV_VERSION_IDX);\n                    }\n                  }\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n\n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n\n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"937e5dc6b617c88318d91081cef76bfbfc4d89ad","date":1544528734,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","sourceNew":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<>(logList.size());\n      deleteByQueryList = new ArrayList<>();\n      deleteList = new ArrayList<>();\n      updates = new HashMap<>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(UpdateLog.FLAGS_IDX);\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n              if (oldLog.isBuffer) bufferUpdates.add(version);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.UPDATE_INPLACE:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  if (oper == UpdateLog.UPDATE_INPLACE) {\n                    if ((update.log instanceof CdcrTransactionLog && entry.size() == 6) ||\n                        (!(update.log instanceof CdcrTransactionLog) && entry.size() == 5)) {\n                      update.previousVersion = (Long) entry.get(UpdateLog.PREV_VERSION_IDX);\n                    }\n                  }\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n\n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n\n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException | AssertionError e) { // catch AssertionError to handle certain test failures correctly\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","sourceOld":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<>(logList.size());\n      deleteByQueryList = new ArrayList<>();\n      deleteList = new ArrayList<>();\n      updates = new HashMap<>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(UpdateLog.FLAGS_IDX);\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n              if (oldLog.isBuffer) bufferUpdates.add(version);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.UPDATE_INPLACE:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  if (oper == UpdateLog.UPDATE_INPLACE) {\n                    if ((update.log instanceof CdcrTransactionLog && entry.size() == 6) ||\n                        (!(update.log instanceof CdcrTransactionLog) && entry.size() == 5)) {\n                      update.previousVersion = (Long) entry.get(UpdateLog.PREV_VERSION_IDX);\n                    }\n                  }\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n\n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n\n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException e) {\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"740d649f013f07efbeb73ca854f106c60166e7c0","date":1587431295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","sourceNew":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<>(logList.size());\n      deleteByQueryList = new ArrayList<>();\n      deleteList = new ArrayList<>();\n      updates = new HashMap<>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(UpdateLog.FLAGS_IDX);\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n              if (oldLog.isBuffer) bufferUpdates.add(version);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.UPDATE_INPLACE:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  if (oper == UpdateLog.UPDATE_INPLACE) {\n                    if ((update.log instanceof CdcrTransactionLog && entry.size() == 6) ||\n                        (!(update.log instanceof CdcrTransactionLog) && entry.size() == 5)) {\n                      update.previousVersion = (Long) entry.get(UpdateLog.PREV_VERSION_IDX);\n                    }\n                  }\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n\n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n\n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry={}\", o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException | AssertionError e) { // catch AssertionError to handle certain test failures correctly\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","sourceOld":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<>(logList.size());\n      deleteByQueryList = new ArrayList<>();\n      deleteList = new ArrayList<>();\n      updates = new HashMap<>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(UpdateLog.FLAGS_IDX);\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n              if (oldLog.isBuffer) bufferUpdates.add(version);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.UPDATE_INPLACE:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  if (oper == UpdateLog.UPDATE_INPLACE) {\n                    if ((update.log instanceof CdcrTransactionLog && entry.size() == 6) ||\n                        (!(update.log instanceof CdcrTransactionLog) && entry.size() == 5)) {\n                      update.previousVersion = (Long) entry.get(UpdateLog.PREV_VERSION_IDX);\n                    }\n                  }\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n\n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n\n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException | AssertionError e) { // catch AssertionError to handle certain test failures correctly\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"018a36ff4088cb91ab12cbe44f696d81d1fadd77","date":1591657414,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","sourceNew":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<>(logList.size());\n      deleteByQueryList = new ArrayList<>();\n      deleteList = new ArrayList<>();\n      updates = new HashMap<>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              @SuppressWarnings({\"rawtypes\"})\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(UpdateLog.FLAGS_IDX);\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n              if (oldLog.isBuffer) bufferUpdates.add(version);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.UPDATE_INPLACE:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  if (oper == UpdateLog.UPDATE_INPLACE) {\n                    if ((update.log instanceof CdcrTransactionLog && entry.size() == 6) ||\n                        (!(update.log instanceof CdcrTransactionLog) && entry.size() == 5)) {\n                      update.previousVersion = (Long) entry.get(UpdateLog.PREV_VERSION_IDX);\n                    }\n                  }\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n\n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n\n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry={}\", o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException | AssertionError e) { // catch AssertionError to handle certain test failures correctly\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","sourceOld":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<>(logList.size());\n      deleteByQueryList = new ArrayList<>();\n      deleteList = new ArrayList<>();\n      updates = new HashMap<>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(UpdateLog.FLAGS_IDX);\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n              if (oldLog.isBuffer) bufferUpdates.add(version);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.UPDATE_INPLACE:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  if (oper == UpdateLog.UPDATE_INPLACE) {\n                    if ((update.log instanceof CdcrTransactionLog && entry.size() == 6) ||\n                        (!(update.log instanceof CdcrTransactionLog) && entry.size() == 5)) {\n                      update.previousVersion = (Long) entry.get(UpdateLog.PREV_VERSION_IDX);\n                    }\n                  }\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n\n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n\n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry={}\", o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException | AssertionError e) { // catch AssertionError to handle certain test failures correctly\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"23ec6d2969d61cadbfd0a5452e9be1f9999e8aa1","date":1598647393,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog.RecentUpdates#update().mjava","sourceNew":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<>(logList.size());\n      deleteByQueryList = new ArrayList<>();\n      deleteList = new ArrayList<>();\n      updates = new HashMap<>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              @SuppressWarnings({\"rawtypes\"})\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(UpdateLog.FLAGS_IDX);\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n              if (oldLog.isBuffer) bufferUpdates.add(version);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.UPDATE_INPLACE:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  if (oper == UpdateLog.UPDATE_INPLACE) {\n                    if (entry.size() == 5) {\n                      update.previousVersion = (Long) entry.get(UpdateLog.PREV_VERSION_IDX);\n                    }\n                  }\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n\n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n\n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry={}\", o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException | AssertionError e) { // catch AssertionError to handle certain test failures correctly\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","sourceOld":"    private void update() {\n      int numUpdates = 0;\n      updateList = new ArrayList<>(logList.size());\n      deleteByQueryList = new ArrayList<>();\n      deleteList = new ArrayList<>();\n      updates = new HashMap<>(numRecordsToKeep);\n\n      for (TransactionLog oldLog : logList) {\n        List<Update> updatesForLog = new ArrayList<>();\n\n        TransactionLog.ReverseReader reader = null;\n        try {\n          reader = oldLog.getReverseReader();\n\n          while (numUpdates < numRecordsToKeep) {\n            Object o = null;\n            try {\n              o = reader.next();\n              if (o==null) break;\n\n              // should currently be a List<Oper,Ver,Doc/Id>\n              @SuppressWarnings({\"rawtypes\"})\n              List entry = (List)o;\n\n              // TODO: refactor this out so we get common error handling\n              int opAndFlags = (Integer)entry.get(UpdateLog.FLAGS_IDX);\n              int oper = opAndFlags & UpdateLog.OPERATION_MASK;\n              long version = (Long) entry.get(UpdateLog.VERSION_IDX);\n\n              if (oldLog.isBuffer) bufferUpdates.add(version);\n\n              switch (oper) {\n                case UpdateLog.ADD:\n                case UpdateLog.UPDATE_INPLACE:\n                case UpdateLog.DELETE:\n                case UpdateLog.DELETE_BY_QUERY:\n                  Update update = new Update();\n                  update.log = oldLog;\n                  update.pointer = reader.position();\n                  update.version = version;\n\n                  if (oper == UpdateLog.UPDATE_INPLACE) {\n                    if ((update.log instanceof CdcrTransactionLog && entry.size() == 6) ||\n                        (!(update.log instanceof CdcrTransactionLog) && entry.size() == 5)) {\n                      update.previousVersion = (Long) entry.get(UpdateLog.PREV_VERSION_IDX);\n                    }\n                  }\n                  updatesForLog.add(update);\n                  updates.put(version, update);\n\n                  if (oper == UpdateLog.DELETE_BY_QUERY) {\n                    deleteByQueryList.add(update);\n                  } else if (oper == UpdateLog.DELETE) {\n                    deleteList.add(new DeleteUpdate(version, (byte[])entry.get(2)));\n                  }\n\n                  break;\n\n                case UpdateLog.COMMIT:\n                  break;\n                default:\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n              }\n            } catch (ClassCastException cl) {\n              log.warn(\"Unexpected log entry or corrupt log.  Entry={}\", o, cl);\n              // would be caused by a corrupt transaction log\n            } catch (Exception ex) {\n              log.warn(\"Exception reverse reading log\", ex);\n              break;\n            }\n\n            numUpdates++;\n          }\n\n        } catch (IOException | AssertionError e) { // catch AssertionError to handle certain test failures correctly\n          // failure to read a log record isn't fatal\n          log.error(\"Exception reading versions from log\",e);\n        } finally {\n          if (reader != null) reader.close();\n        }\n\n        updateList.add(updatesForLog);\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"598b5d23aa7c9732bf473c21a9cd309c44599394":["86290366cefc1b9d4eced13b430858c4a4c0421d","415bbbe7da8065dd3c477bdc3c703c6425622998"],"018a36ff4088cb91ab12cbe44f696d81d1fadd77":["740d649f013f07efbeb73ca854f106c60166e7c0"],"740d649f013f07efbeb73ca854f106c60166e7c0":["937e5dc6b617c88318d91081cef76bfbfc4d89ad"],"dd45d4a2ee01a1932d33eec42f5272c2402da679":["e99829242bceda4cf974ec0eb5d82d713615b3da","0833b652ff242e439e7c2e346fb3b6601fb0a3d3"],"1455c941cc4ce652efc776fc23471b0e499246f6":["203e3fcf513c02ee2c07015f2ce277e26dc60907"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["b70042a8a492f7054d480ccdd2be9796510d4327","ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["203e3fcf513c02ee2c07015f2ce277e26dc60907","1455c941cc4ce652efc776fc23471b0e499246f6"],"3599646b4d4c346cf74d334813488b8b337b5bf5":["414ae8f6c01f0259255c532b2bd51b03000c2480","e99829242bceda4cf974ec0eb5d82d713615b3da"],"0833b652ff242e439e7c2e346fb3b6601fb0a3d3":["e99829242bceda4cf974ec0eb5d82d713615b3da"],"e99829242bceda4cf974ec0eb5d82d713615b3da":["414ae8f6c01f0259255c532b2bd51b03000c2480"],"ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7":["1455c941cc4ce652efc776fc23471b0e499246f6"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["f592209545c71895260367152601e9200399776d","ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7"],"415bbbe7da8065dd3c477bdc3c703c6425622998":["86290366cefc1b9d4eced13b430858c4a4c0421d"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["09aa6810f7773e562ee1780fc2f29c47fbe8d25b"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"203e3fcf513c02ee2c07015f2ce277e26dc60907":["415bbbe7da8065dd3c477bdc3c703c6425622998","d030a7298c5397ab744a356c18ccda17f76f77f7"],"937e5dc6b617c88318d91081cef76bfbfc4d89ad":["ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7"],"09aa6810f7773e562ee1780fc2f29c47fbe8d25b":["0833b652ff242e439e7c2e346fb3b6601fb0a3d3"],"86290366cefc1b9d4eced13b430858c4a4c0421d":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"d030a7298c5397ab744a356c18ccda17f76f77f7":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"23ec6d2969d61cadbfd0a5452e9be1f9999e8aa1":["018a36ff4088cb91ab12cbe44f696d81d1fadd77"],"f592209545c71895260367152601e9200399776d":["203e3fcf513c02ee2c07015f2ce277e26dc60907","1455c941cc4ce652efc776fc23471b0e499246f6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["23ec6d2969d61cadbfd0a5452e9be1f9999e8aa1"],"414ae8f6c01f0259255c532b2bd51b03000c2480":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"]},"commit2Childs":{"598b5d23aa7c9732bf473c21a9cd309c44599394":[],"018a36ff4088cb91ab12cbe44f696d81d1fadd77":["23ec6d2969d61cadbfd0a5452e9be1f9999e8aa1"],"740d649f013f07efbeb73ca854f106c60166e7c0":["018a36ff4088cb91ab12cbe44f696d81d1fadd77"],"dd45d4a2ee01a1932d33eec42f5272c2402da679":[],"1455c941cc4ce652efc776fc23471b0e499246f6":["b70042a8a492f7054d480ccdd2be9796510d4327","ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7","f592209545c71895260367152601e9200399776d"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"3599646b4d4c346cf74d334813488b8b337b5bf5":[],"e99829242bceda4cf974ec0eb5d82d713615b3da":["dd45d4a2ee01a1932d33eec42f5272c2402da679","3599646b4d4c346cf74d334813488b8b337b5bf5","0833b652ff242e439e7c2e346fb3b6601fb0a3d3"],"0833b652ff242e439e7c2e346fb3b6601fb0a3d3":["dd45d4a2ee01a1932d33eec42f5272c2402da679","09aa6810f7773e562ee1780fc2f29c47fbe8d25b"],"ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","937e5dc6b617c88318d91081cef76bfbfc4d89ad"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[],"415bbbe7da8065dd3c477bdc3c703c6425622998":["598b5d23aa7c9732bf473c21a9cd309c44599394","203e3fcf513c02ee2c07015f2ce277e26dc60907","d030a7298c5397ab744a356c18ccda17f76f77f7"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["86290366cefc1b9d4eced13b430858c4a4c0421d"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"203e3fcf513c02ee2c07015f2ce277e26dc60907":["1455c941cc4ce652efc776fc23471b0e499246f6","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d"],"937e5dc6b617c88318d91081cef76bfbfc4d89ad":["740d649f013f07efbeb73ca854f106c60166e7c0"],"09aa6810f7773e562ee1780fc2f29c47fbe8d25b":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"86290366cefc1b9d4eced13b430858c4a4c0421d":["598b5d23aa7c9732bf473c21a9cd309c44599394","415bbbe7da8065dd3c477bdc3c703c6425622998"],"d030a7298c5397ab744a356c18ccda17f76f77f7":["203e3fcf513c02ee2c07015f2ce277e26dc60907"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","414ae8f6c01f0259255c532b2bd51b03000c2480"],"f592209545c71895260367152601e9200399776d":["7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"23ec6d2969d61cadbfd0a5452e9be1f9999e8aa1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"414ae8f6c01f0259255c532b2bd51b03000c2480":["3599646b4d4c346cf74d334813488b8b337b5bf5","e99829242bceda4cf974ec0eb5d82d713615b3da"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["598b5d23aa7c9732bf473c21a9cd309c44599394","dd45d4a2ee01a1932d33eec42f5272c2402da679","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","0d22ac6a4146774c1bc8400160fc0b6150294e92","3599646b4d4c346cf74d334813488b8b337b5bf5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}