{"path":"solr/core/src/test/org/apache/solr/update/SolrCmdDistributorTest#testRetryNodeAgainstBadAddress().mjava","commits":[{"id":"28b49bc3bf9043888cb4243e659f6898fe2a95a9","date":1385594113,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/SolrCmdDistributorTest#testRetryNodeAgainstBadAddress().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/SolrCmdDistributorTest#testRetryNode().mjava","sourceNew":"  private void testRetryNodeAgainstBadAddress() throws SolrServerException, IOException {\n    // Test RetryNode\n    SolrCmdDistributor cmdDistrib = new SolrCmdDistributor(updateShardHandler);\n    final HttpSolrServer solrclient = (HttpSolrServer) clients.get(0);\n    long numFoundBefore = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    \n    ArrayList<Node> nodes = new ArrayList<Node>();\n\n    ZkNodeProps nodeProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, \"[ff01::114]:33332\" + context, ZkStateReader.CORE_NAME_PROP, \"\");\n    RetryNode retryNode = new RetryNode(new ZkCoreNodeProps(nodeProps), null, \"collection1\", \"shard1\") {\n      @Override\n      public boolean checkRetry() {\n        ZkNodeProps leaderProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, solrclient.getBaseURL(),\n            ZkStateReader.CORE_NAME_PROP, \"\");\n        this.nodeProps = new ZkCoreNodeProps(leaderProps);\n\n        return true;\n      }\n    };\n    \n\n    nodes.add(retryNode);\n    \n    \n    AddUpdateCommand cmd = new AddUpdateCommand(null);\n    cmd.solrDoc = sdoc(\"id\", id.incrementAndGet());\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    cmdDistrib.distribAdd(cmd, nodes, params);\n    \n    CommitUpdateCommand ccmd = new CommitUpdateCommand(null, false);\n    params = new ModifiableSolrParams();\n    params.set(DistributedUpdateProcessor.COMMIT_END_POINT, true);\n    cmdDistrib.distribCommit(ccmd, nodes, params);\n    cmdDistrib.finish();\n    \n    long numFoundAfter = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    \n    // different OS's will throw different exceptions for the bad address above\n    if (numFoundBefore != numFoundAfter) {\n      assertEquals(0, cmdDistrib.getErrors().size());\n      assertEquals(numFoundBefore + 1, numFoundAfter);\n    } else {\n      // we will get java.net.SocketException: Network is unreachable and not retry\n      assertEquals(numFoundBefore, numFoundAfter);\n      \n      assertEquals(1, cmdDistrib.getErrors().size());\n    }\n    \n  }\n\n","sourceOld":"  private void testRetryNode() throws SolrServerException, IOException {\n    // Test RetryNode\n    SolrCmdDistributor cmdDistrib = new SolrCmdDistributor(updateShardHandler);\n    final HttpSolrServer solrclient = (HttpSolrServer) clients.get(0);\n    long numFoundBefore = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    \n    ArrayList<Node> nodes = new ArrayList<Node>();\n\n    ZkNodeProps nodeProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, \"[ff01::114]:33332\" + context, ZkStateReader.CORE_NAME_PROP, \"\");\n    RetryNode retryNode = new RetryNode(new ZkCoreNodeProps(nodeProps), null, \"collection1\", \"shard1\") {\n      @Override\n      public boolean checkRetry() {\n        ZkNodeProps leaderProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, solrclient.getBaseURL(),\n            ZkStateReader.CORE_NAME_PROP, \"\");\n        this.nodeProps = new ZkCoreNodeProps(leaderProps);\n\n        return true;\n      }\n    };\n    \n\n    nodes.add(retryNode);\n    \n    \n    AddUpdateCommand cmd = new AddUpdateCommand(null);\n    cmd.solrDoc = sdoc(\"id\", id.incrementAndGet());\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    cmdDistrib.distribAdd(cmd, nodes, params);\n    \n    CommitUpdateCommand ccmd = new CommitUpdateCommand(null, false);\n    params = new ModifiableSolrParams();\n    params.set(DistributedUpdateProcessor.COMMIT_END_POINT, true);\n    cmdDistrib.distribCommit(ccmd, nodes, params);\n    cmdDistrib.finish();\n    \n    long numFoundAfter = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    \n    // we will get java.net.SocketException: Network is unreachable and not retry\n    assertEquals(numFoundBefore, numFoundAfter);\n    \n    assertEquals(1, cmdDistrib.getErrors().size());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1dd6595120fba7e99fcec70759c6cdea9a071b3","date":1385615716,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/SolrCmdDistributorTest#testRetryNodeAgainstBadAddress().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/SolrCmdDistributorTest#testRetryNodeAgainstBadAddress().mjava","sourceNew":"  private void testRetryNodeAgainstBadAddress() throws SolrServerException, IOException {\n    // Test RetryNode\n    SolrCmdDistributor cmdDistrib = new SolrCmdDistributor(updateShardHandler);\n    final HttpSolrServer solrclient = (HttpSolrServer) clients.get(0);\n    long numFoundBefore = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    \n    ArrayList<Node> nodes = new ArrayList<Node>();\n\n    ZkNodeProps nodeProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, \"[ff01::114]:33332\" + context, ZkStateReader.CORE_NAME_PROP, \"\");\n    RetryNode retryNode = new RetryNode(new ZkCoreNodeProps(nodeProps), null, \"collection1\", \"shard1\", \"locahost\") {\n      @Override\n      public boolean checkRetry() {\n        ZkNodeProps leaderProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, solrclient.getBaseURL(),\n            ZkStateReader.CORE_NAME_PROP, \"\");\n        this.nodeProps = new ZkCoreNodeProps(leaderProps);\n\n        return true;\n      }\n    };\n    \n\n    nodes.add(retryNode);\n    \n    \n    AddUpdateCommand cmd = new AddUpdateCommand(null);\n    cmd.solrDoc = sdoc(\"id\", id.incrementAndGet());\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    cmdDistrib.distribAdd(cmd, nodes, params);\n    \n    CommitUpdateCommand ccmd = new CommitUpdateCommand(null, false);\n    params = new ModifiableSolrParams();\n    params.set(DistributedUpdateProcessor.COMMIT_END_POINT, true);\n    cmdDistrib.distribCommit(ccmd, nodes, params);\n    cmdDistrib.finish();\n    \n    long numFoundAfter = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    \n    // different OS's will throw different exceptions for the bad address above\n    if (numFoundBefore != numFoundAfter) {\n      assertEquals(0, cmdDistrib.getErrors().size());\n      assertEquals(numFoundBefore + 1, numFoundAfter);\n    } else {\n      // we will get java.net.SocketException: Network is unreachable and not retry\n      assertEquals(numFoundBefore, numFoundAfter);\n      \n      assertEquals(1, cmdDistrib.getErrors().size());\n    }\n    \n  }\n\n","sourceOld":"  private void testRetryNodeAgainstBadAddress() throws SolrServerException, IOException {\n    // Test RetryNode\n    SolrCmdDistributor cmdDistrib = new SolrCmdDistributor(updateShardHandler);\n    final HttpSolrServer solrclient = (HttpSolrServer) clients.get(0);\n    long numFoundBefore = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    \n    ArrayList<Node> nodes = new ArrayList<Node>();\n\n    ZkNodeProps nodeProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, \"[ff01::114]:33332\" + context, ZkStateReader.CORE_NAME_PROP, \"\");\n    RetryNode retryNode = new RetryNode(new ZkCoreNodeProps(nodeProps), null, \"collection1\", \"shard1\") {\n      @Override\n      public boolean checkRetry() {\n        ZkNodeProps leaderProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, solrclient.getBaseURL(),\n            ZkStateReader.CORE_NAME_PROP, \"\");\n        this.nodeProps = new ZkCoreNodeProps(leaderProps);\n\n        return true;\n      }\n    };\n    \n\n    nodes.add(retryNode);\n    \n    \n    AddUpdateCommand cmd = new AddUpdateCommand(null);\n    cmd.solrDoc = sdoc(\"id\", id.incrementAndGet());\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    cmdDistrib.distribAdd(cmd, nodes, params);\n    \n    CommitUpdateCommand ccmd = new CommitUpdateCommand(null, false);\n    params = new ModifiableSolrParams();\n    params.set(DistributedUpdateProcessor.COMMIT_END_POINT, true);\n    cmdDistrib.distribCommit(ccmd, nodes, params);\n    cmdDistrib.finish();\n    \n    long numFoundAfter = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    \n    // different OS's will throw different exceptions for the bad address above\n    if (numFoundBefore != numFoundAfter) {\n      assertEquals(0, cmdDistrib.getErrors().size());\n      assertEquals(numFoundBefore + 1, numFoundAfter);\n    } else {\n      // we will get java.net.SocketException: Network is unreachable and not retry\n      assertEquals(numFoundBefore, numFoundAfter);\n      \n      assertEquals(1, cmdDistrib.getErrors().size());\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ce545e833f5334e245fb71d83c3460ef83c2d5e","date":1385773467,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/SolrCmdDistributorTest#testRetryNodeAgainstBadAddress().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/SolrCmdDistributorTest#testRetryNodeAgainstBadAddress().mjava","sourceNew":"  private void testRetryNodeAgainstBadAddress() throws SolrServerException, IOException {\n    // Test RetryNode\n    SolrCmdDistributor cmdDistrib = new SolrCmdDistributor(updateShardHandler);\n    final HttpSolrServer solrclient = (HttpSolrServer) clients.get(0);\n    long numFoundBefore = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    \n    ArrayList<Node> nodes = new ArrayList<Node>();\n\n    ZkNodeProps nodeProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, \"[ff01::114]:33332\" + context, ZkStateReader.CORE_NAME_PROP, \"\");\n    RetryNode retryNode = new RetryNode(new ZkCoreNodeProps(nodeProps), null, \"collection1\", \"shard1\") {\n      @Override\n      public boolean checkRetry() {\n        ZkNodeProps leaderProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, solrclient.getBaseURL(),\n            ZkStateReader.CORE_NAME_PROP, \"\");\n        this.nodeProps = new ZkCoreNodeProps(leaderProps);\n\n        return true;\n      }\n    };\n    \n\n    nodes.add(retryNode);\n    \n    \n    AddUpdateCommand cmd = new AddUpdateCommand(null);\n    cmd.solrDoc = sdoc(\"id\", id.incrementAndGet());\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    cmdDistrib.distribAdd(cmd, nodes, params);\n    \n    CommitUpdateCommand ccmd = new CommitUpdateCommand(null, false);\n    params = new ModifiableSolrParams();\n    params.set(DistributedUpdateProcessor.COMMIT_END_POINT, true);\n    cmdDistrib.distribCommit(ccmd, nodes, params);\n    cmdDistrib.finish();\n    \n    long numFoundAfter = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    \n    // different OS's will throw different exceptions for the bad address above\n    if (numFoundBefore != numFoundAfter) {\n      assertEquals(0, cmdDistrib.getErrors().size());\n      assertEquals(numFoundBefore + 1, numFoundAfter);\n    } else {\n      // we will get java.net.SocketException: Network is unreachable and not retry\n      assertEquals(numFoundBefore, numFoundAfter);\n      \n      assertEquals(1, cmdDistrib.getErrors().size());\n    }\n    \n  }\n\n","sourceOld":"  private void testRetryNodeAgainstBadAddress() throws SolrServerException, IOException {\n    // Test RetryNode\n    SolrCmdDistributor cmdDistrib = new SolrCmdDistributor(updateShardHandler);\n    final HttpSolrServer solrclient = (HttpSolrServer) clients.get(0);\n    long numFoundBefore = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    \n    ArrayList<Node> nodes = new ArrayList<Node>();\n\n    ZkNodeProps nodeProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, \"[ff01::114]:33332\" + context, ZkStateReader.CORE_NAME_PROP, \"\");\n    RetryNode retryNode = new RetryNode(new ZkCoreNodeProps(nodeProps), null, \"collection1\", \"shard1\", \"locahost\") {\n      @Override\n      public boolean checkRetry() {\n        ZkNodeProps leaderProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, solrclient.getBaseURL(),\n            ZkStateReader.CORE_NAME_PROP, \"\");\n        this.nodeProps = new ZkCoreNodeProps(leaderProps);\n\n        return true;\n      }\n    };\n    \n\n    nodes.add(retryNode);\n    \n    \n    AddUpdateCommand cmd = new AddUpdateCommand(null);\n    cmd.solrDoc = sdoc(\"id\", id.incrementAndGet());\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    cmdDistrib.distribAdd(cmd, nodes, params);\n    \n    CommitUpdateCommand ccmd = new CommitUpdateCommand(null, false);\n    params = new ModifiableSolrParams();\n    params.set(DistributedUpdateProcessor.COMMIT_END_POINT, true);\n    cmdDistrib.distribCommit(ccmd, nodes, params);\n    cmdDistrib.finish();\n    \n    long numFoundAfter = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    \n    // different OS's will throw different exceptions for the bad address above\n    if (numFoundBefore != numFoundAfter) {\n      assertEquals(0, cmdDistrib.getErrors().size());\n      assertEquals(numFoundBefore + 1, numFoundAfter);\n    } else {\n      // we will get java.net.SocketException: Network is unreachable and not retry\n      assertEquals(numFoundBefore, numFoundAfter);\n      \n      assertEquals(1, cmdDistrib.getErrors().size());\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/SolrCmdDistributorTest#testRetryNodeAgainstBadAddress().mjava","pathOld":"/dev/null","sourceNew":"  private void testRetryNodeAgainstBadAddress() throws SolrServerException, IOException {\n    // Test RetryNode\n    SolrCmdDistributor cmdDistrib = new SolrCmdDistributor(updateShardHandler);\n    final HttpSolrServer solrclient = (HttpSolrServer) clients.get(0);\n    long numFoundBefore = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    \n    ArrayList<Node> nodes = new ArrayList<Node>();\n\n    ZkNodeProps nodeProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, \"[ff01::114]:33332\" + context, ZkStateReader.CORE_NAME_PROP, \"\");\n    RetryNode retryNode = new RetryNode(new ZkCoreNodeProps(nodeProps), null, \"collection1\", \"shard1\") {\n      @Override\n      public boolean checkRetry() {\n        ZkNodeProps leaderProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, solrclient.getBaseURL(),\n            ZkStateReader.CORE_NAME_PROP, \"\");\n        this.nodeProps = new ZkCoreNodeProps(leaderProps);\n\n        return true;\n      }\n    };\n    \n\n    nodes.add(retryNode);\n    \n    \n    AddUpdateCommand cmd = new AddUpdateCommand(null);\n    cmd.solrDoc = sdoc(\"id\", id.incrementAndGet());\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    cmdDistrib.distribAdd(cmd, nodes, params);\n    \n    CommitUpdateCommand ccmd = new CommitUpdateCommand(null, false);\n    params = new ModifiableSolrParams();\n    params.set(DistributedUpdateProcessor.COMMIT_END_POINT, true);\n    cmdDistrib.distribCommit(ccmd, nodes, params);\n    cmdDistrib.finish();\n    \n    long numFoundAfter = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    \n    // different OS's will throw different exceptions for the bad address above\n    if (numFoundBefore != numFoundAfter) {\n      assertEquals(0, cmdDistrib.getErrors().size());\n      assertEquals(numFoundBefore + 1, numFoundAfter);\n    } else {\n      // we will get java.net.SocketException: Network is unreachable and not retry\n      assertEquals(numFoundBefore, numFoundAfter);\n      \n      assertEquals(1, cmdDistrib.getErrors().size());\n    }\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/SolrCmdDistributorTest#testRetryNodeAgainstBadAddress().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/SolrCmdDistributorTest#testRetryNodeAgainstBadAddress().mjava","sourceNew":"  private void testRetryNodeAgainstBadAddress() throws SolrServerException, IOException {\n    // Test RetryNode\n    SolrCmdDistributor cmdDistrib = new SolrCmdDistributor(updateShardHandler);\n    final HttpSolrServer solrclient = (HttpSolrServer) clients.get(0);\n    long numFoundBefore = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    \n    ArrayList<Node> nodes = new ArrayList<>();\n\n    ZkNodeProps nodeProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, \"[ff01::114]:33332\" + context, ZkStateReader.CORE_NAME_PROP, \"\");\n    RetryNode retryNode = new RetryNode(new ZkCoreNodeProps(nodeProps), null, \"collection1\", \"shard1\") {\n      @Override\n      public boolean checkRetry() {\n        ZkNodeProps leaderProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, solrclient.getBaseURL(),\n            ZkStateReader.CORE_NAME_PROP, \"\");\n        this.nodeProps = new ZkCoreNodeProps(leaderProps);\n\n        return true;\n      }\n    };\n    \n\n    nodes.add(retryNode);\n    \n    \n    AddUpdateCommand cmd = new AddUpdateCommand(null);\n    cmd.solrDoc = sdoc(\"id\", id.incrementAndGet());\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    cmdDistrib.distribAdd(cmd, nodes, params);\n    \n    CommitUpdateCommand ccmd = new CommitUpdateCommand(null, false);\n    params = new ModifiableSolrParams();\n    params.set(DistributedUpdateProcessor.COMMIT_END_POINT, true);\n    cmdDistrib.distribCommit(ccmd, nodes, params);\n    cmdDistrib.finish();\n    \n    long numFoundAfter = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    \n    // different OS's will throw different exceptions for the bad address above\n    if (numFoundBefore != numFoundAfter) {\n      assertEquals(0, cmdDistrib.getErrors().size());\n      assertEquals(numFoundBefore + 1, numFoundAfter);\n    } else {\n      // we will get java.net.SocketException: Network is unreachable and not retry\n      assertEquals(numFoundBefore, numFoundAfter);\n      \n      assertEquals(1, cmdDistrib.getErrors().size());\n    }\n    \n  }\n\n","sourceOld":"  private void testRetryNodeAgainstBadAddress() throws SolrServerException, IOException {\n    // Test RetryNode\n    SolrCmdDistributor cmdDistrib = new SolrCmdDistributor(updateShardHandler);\n    final HttpSolrServer solrclient = (HttpSolrServer) clients.get(0);\n    long numFoundBefore = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    \n    ArrayList<Node> nodes = new ArrayList<Node>();\n\n    ZkNodeProps nodeProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, \"[ff01::114]:33332\" + context, ZkStateReader.CORE_NAME_PROP, \"\");\n    RetryNode retryNode = new RetryNode(new ZkCoreNodeProps(nodeProps), null, \"collection1\", \"shard1\") {\n      @Override\n      public boolean checkRetry() {\n        ZkNodeProps leaderProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, solrclient.getBaseURL(),\n            ZkStateReader.CORE_NAME_PROP, \"\");\n        this.nodeProps = new ZkCoreNodeProps(leaderProps);\n\n        return true;\n      }\n    };\n    \n\n    nodes.add(retryNode);\n    \n    \n    AddUpdateCommand cmd = new AddUpdateCommand(null);\n    cmd.solrDoc = sdoc(\"id\", id.incrementAndGet());\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    cmdDistrib.distribAdd(cmd, nodes, params);\n    \n    CommitUpdateCommand ccmd = new CommitUpdateCommand(null, false);\n    params = new ModifiableSolrParams();\n    params.set(DistributedUpdateProcessor.COMMIT_END_POINT, true);\n    cmdDistrib.distribCommit(ccmd, nodes, params);\n    cmdDistrib.finish();\n    \n    long numFoundAfter = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    \n    // different OS's will throw different exceptions for the bad address above\n    if (numFoundBefore != numFoundAfter) {\n      assertEquals(0, cmdDistrib.getErrors().size());\n      assertEquals(numFoundBefore + 1, numFoundAfter);\n    } else {\n      // we will get java.net.SocketException: Network is unreachable and not retry\n      assertEquals(numFoundBefore, numFoundAfter);\n      \n      assertEquals(1, cmdDistrib.getErrors().size());\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/SolrCmdDistributorTest#testRetryNodeAgainstBadAddress().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/SolrCmdDistributorTest#testRetryNodeAgainstBadAddress().mjava","sourceNew":"  private void testRetryNodeAgainstBadAddress() throws SolrServerException, IOException {\n    // Test RetryNode\n    SolrCmdDistributor cmdDistrib = new SolrCmdDistributor(updateShardHandler);\n    final HttpSolrClient solrclient = (HttpSolrClient) clients.get(0);\n    long numFoundBefore = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    \n    ArrayList<Node> nodes = new ArrayList<>();\n\n    ZkNodeProps nodeProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, \"[ff01::114]:33332\" + context, ZkStateReader.CORE_NAME_PROP, \"\");\n    RetryNode retryNode = new RetryNode(new ZkCoreNodeProps(nodeProps), null, \"collection1\", \"shard1\") {\n      @Override\n      public boolean checkRetry() {\n        ZkNodeProps leaderProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, solrclient.getBaseURL(),\n            ZkStateReader.CORE_NAME_PROP, \"\");\n        this.nodeProps = new ZkCoreNodeProps(leaderProps);\n\n        return true;\n      }\n    };\n    \n\n    nodes.add(retryNode);\n    \n    \n    AddUpdateCommand cmd = new AddUpdateCommand(null);\n    cmd.solrDoc = sdoc(\"id\", id.incrementAndGet());\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    cmdDistrib.distribAdd(cmd, nodes, params);\n    \n    CommitUpdateCommand ccmd = new CommitUpdateCommand(null, false);\n    params = new ModifiableSolrParams();\n    params.set(DistributedUpdateProcessor.COMMIT_END_POINT, true);\n    cmdDistrib.distribCommit(ccmd, nodes, params);\n    cmdDistrib.finish();\n    \n    long numFoundAfter = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    \n    // different OS's will throw different exceptions for the bad address above\n    if (numFoundBefore != numFoundAfter) {\n      assertEquals(0, cmdDistrib.getErrors().size());\n      assertEquals(numFoundBefore + 1, numFoundAfter);\n    } else {\n      // we will get java.net.SocketException: Network is unreachable and not retry\n      assertEquals(numFoundBefore, numFoundAfter);\n      \n      assertEquals(1, cmdDistrib.getErrors().size());\n    }\n    \n  }\n\n","sourceOld":"  private void testRetryNodeAgainstBadAddress() throws SolrServerException, IOException {\n    // Test RetryNode\n    SolrCmdDistributor cmdDistrib = new SolrCmdDistributor(updateShardHandler);\n    final HttpSolrServer solrclient = (HttpSolrServer) clients.get(0);\n    long numFoundBefore = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    \n    ArrayList<Node> nodes = new ArrayList<>();\n\n    ZkNodeProps nodeProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, \"[ff01::114]:33332\" + context, ZkStateReader.CORE_NAME_PROP, \"\");\n    RetryNode retryNode = new RetryNode(new ZkCoreNodeProps(nodeProps), null, \"collection1\", \"shard1\") {\n      @Override\n      public boolean checkRetry() {\n        ZkNodeProps leaderProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, solrclient.getBaseURL(),\n            ZkStateReader.CORE_NAME_PROP, \"\");\n        this.nodeProps = new ZkCoreNodeProps(leaderProps);\n\n        return true;\n      }\n    };\n    \n\n    nodes.add(retryNode);\n    \n    \n    AddUpdateCommand cmd = new AddUpdateCommand(null);\n    cmd.solrDoc = sdoc(\"id\", id.incrementAndGet());\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    cmdDistrib.distribAdd(cmd, nodes, params);\n    \n    CommitUpdateCommand ccmd = new CommitUpdateCommand(null, false);\n    params = new ModifiableSolrParams();\n    params.set(DistributedUpdateProcessor.COMMIT_END_POINT, true);\n    cmdDistrib.distribCommit(ccmd, nodes, params);\n    cmdDistrib.finish();\n    \n    long numFoundAfter = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    \n    // different OS's will throw different exceptions for the bad address above\n    if (numFoundBefore != numFoundAfter) {\n      assertEquals(0, cmdDistrib.getErrors().size());\n      assertEquals(numFoundBefore + 1, numFoundAfter);\n    } else {\n      // we will get java.net.SocketException: Network is unreachable and not retry\n      assertEquals(numFoundBefore, numFoundAfter);\n      \n      assertEquals(1, cmdDistrib.getErrors().size());\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f15af35d55d70c34451f9df5edeaeff6b31f8cbe","date":1519625627,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/SolrCmdDistributorTest#testRetryNodeAgainstBadAddress().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/SolrCmdDistributorTest#testRetryNodeAgainstBadAddress().mjava","sourceNew":"  private void testRetryNodeAgainstBadAddress() throws SolrServerException, IOException {\n    // Test RetryNode\n    try (SolrCmdDistributor cmdDistrib = new SolrCmdDistributor(updateShardHandler)) {\n      final HttpSolrClient solrclient = (HttpSolrClient) clients.get(0);\n      long numFoundBefore = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n          .getNumFound();\n\n      ArrayList<Node> nodes = new ArrayList<>();\n\n      ZkNodeProps nodeProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, \"[ff01::114]:33332\" + context, ZkStateReader.CORE_NAME_PROP, \"\");\n      RetryNode retryNode = new RetryNode(new ZkCoreNodeProps(nodeProps), null, \"collection1\", \"shard1\") {\n        @Override\n        public boolean checkRetry() {\n          ZkNodeProps leaderProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, solrclient.getBaseURL(),\n              ZkStateReader.CORE_NAME_PROP, \"\");\n          this.nodeProps = new ZkCoreNodeProps(leaderProps);\n\n          return true;\n        }\n      };\n\n\n      nodes.add(retryNode);\n\n\n      AddUpdateCommand cmd = new AddUpdateCommand(null);\n      cmd.solrDoc = sdoc(\"id\", id.incrementAndGet());\n      ModifiableSolrParams params = new ModifiableSolrParams();\n\n      cmdDistrib.distribAdd(cmd, nodes, params);\n\n      CommitUpdateCommand ccmd = new CommitUpdateCommand(null, false);\n      params = new ModifiableSolrParams();\n      params.set(DistributedUpdateProcessor.COMMIT_END_POINT, true);\n      cmdDistrib.distribCommit(ccmd, nodes, params);\n      cmdDistrib.finish();\n\n      long numFoundAfter = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n          .getNumFound();\n\n      // different OS's will throw different exceptions for the bad address above\n      if (numFoundBefore != numFoundAfter) {\n        assertEquals(0, cmdDistrib.getErrors().size());\n        assertEquals(numFoundBefore + 1, numFoundAfter);\n      } else {\n        // we will get java.net.SocketException: Network is unreachable and not retry\n        assertEquals(numFoundBefore, numFoundAfter);\n\n        assertEquals(1, cmdDistrib.getErrors().size());\n      }\n    }\n  }\n\n","sourceOld":"  private void testRetryNodeAgainstBadAddress() throws SolrServerException, IOException {\n    // Test RetryNode\n    SolrCmdDistributor cmdDistrib = new SolrCmdDistributor(updateShardHandler);\n    final HttpSolrClient solrclient = (HttpSolrClient) clients.get(0);\n    long numFoundBefore = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    \n    ArrayList<Node> nodes = new ArrayList<>();\n\n    ZkNodeProps nodeProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, \"[ff01::114]:33332\" + context, ZkStateReader.CORE_NAME_PROP, \"\");\n    RetryNode retryNode = new RetryNode(new ZkCoreNodeProps(nodeProps), null, \"collection1\", \"shard1\") {\n      @Override\n      public boolean checkRetry() {\n        ZkNodeProps leaderProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, solrclient.getBaseURL(),\n            ZkStateReader.CORE_NAME_PROP, \"\");\n        this.nodeProps = new ZkCoreNodeProps(leaderProps);\n\n        return true;\n      }\n    };\n    \n\n    nodes.add(retryNode);\n    \n    \n    AddUpdateCommand cmd = new AddUpdateCommand(null);\n    cmd.solrDoc = sdoc(\"id\", id.incrementAndGet());\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    cmdDistrib.distribAdd(cmd, nodes, params);\n    \n    CommitUpdateCommand ccmd = new CommitUpdateCommand(null, false);\n    params = new ModifiableSolrParams();\n    params.set(DistributedUpdateProcessor.COMMIT_END_POINT, true);\n    cmdDistrib.distribCommit(ccmd, nodes, params);\n    cmdDistrib.finish();\n    \n    long numFoundAfter = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n        .getNumFound();\n    \n    // different OS's will throw different exceptions for the bad address above\n    if (numFoundBefore != numFoundAfter) {\n      assertEquals(0, cmdDistrib.getErrors().size());\n      assertEquals(numFoundBefore + 1, numFoundAfter);\n    } else {\n      // we will get java.net.SocketException: Network is unreachable and not retry\n      assertEquals(numFoundBefore, numFoundAfter);\n      \n      assertEquals(1, cmdDistrib.getErrors().size());\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":["c0cf9c2ec975506bab465b6b2be92cb9bffc84d3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c0cf9c2ec975506bab465b6b2be92cb9bffc84d3","date":1533596209,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/SolrCmdDistributorTest#testRetryNodeAgainstBadAddress().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/SolrCmdDistributorTest#testRetryNodeAgainstBadAddress().mjava","sourceNew":"  private void testRetryNodeAgainstBadAddress() throws SolrServerException, IOException {\n    // Test RetryNode\n    try (SolrCmdDistributor cmdDistrib = new SolrCmdDistributor(updateShardHandler)) {\n      final HttpSolrClient solrclient = (HttpSolrClient) clients.get(0);\n      long numFoundBefore = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n          .getNumFound();\n\n      ArrayList<Node> nodes = new ArrayList<>();\n\n      ZkNodeProps nodeProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, \"[ff01::114]:33332\" + context, ZkStateReader.CORE_NAME_PROP, \"\");\n      ForwardNode retryNode = new ForwardNode(new ZkCoreNodeProps(nodeProps), null, \"collection1\", \"shard1\", 5) {\n        @Override\n        public boolean checkRetry(Error err) {\n          ZkNodeProps leaderProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, solrclient.getBaseURL(),\n              ZkStateReader.CORE_NAME_PROP, \"\");\n          this.nodeProps = new ZkCoreNodeProps(leaderProps);\n\n          return super.checkRetry(err);\n        }\n      };\n\n\n      nodes.add(retryNode);\n\n\n      AddUpdateCommand cmd = new AddUpdateCommand(null);\n      cmd.solrDoc = sdoc(\"id\", id.incrementAndGet());\n      ModifiableSolrParams params = new ModifiableSolrParams();\n\n      cmdDistrib.distribAdd(cmd, nodes, params);\n\n      CommitUpdateCommand ccmd = new CommitUpdateCommand(null, false);\n      params = new ModifiableSolrParams();\n      params.set(DistributedUpdateProcessor.COMMIT_END_POINT, true);\n      cmdDistrib.distribCommit(ccmd, nodes, params);\n      cmdDistrib.finish();\n\n      long numFoundAfter = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n          .getNumFound();\n\n      // different OS's will throw different exceptions for the bad address above\n      if (numFoundBefore != numFoundAfter) {\n        assertEquals(0, cmdDistrib.getErrors().size());\n        assertEquals(numFoundBefore + 1, numFoundAfter);\n      } else {\n        // we will get java.net.SocketException: Network is unreachable and not retry\n        assertEquals(numFoundBefore, numFoundAfter);\n\n        assertEquals(1, cmdDistrib.getErrors().size());\n      }\n    }\n  }\n\n","sourceOld":"  private void testRetryNodeAgainstBadAddress() throws SolrServerException, IOException {\n    // Test RetryNode\n    try (SolrCmdDistributor cmdDistrib = new SolrCmdDistributor(updateShardHandler)) {\n      final HttpSolrClient solrclient = (HttpSolrClient) clients.get(0);\n      long numFoundBefore = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n          .getNumFound();\n\n      ArrayList<Node> nodes = new ArrayList<>();\n\n      ZkNodeProps nodeProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, \"[ff01::114]:33332\" + context, ZkStateReader.CORE_NAME_PROP, \"\");\n      RetryNode retryNode = new RetryNode(new ZkCoreNodeProps(nodeProps), null, \"collection1\", \"shard1\") {\n        @Override\n        public boolean checkRetry() {\n          ZkNodeProps leaderProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, solrclient.getBaseURL(),\n              ZkStateReader.CORE_NAME_PROP, \"\");\n          this.nodeProps = new ZkCoreNodeProps(leaderProps);\n\n          return true;\n        }\n      };\n\n\n      nodes.add(retryNode);\n\n\n      AddUpdateCommand cmd = new AddUpdateCommand(null);\n      cmd.solrDoc = sdoc(\"id\", id.incrementAndGet());\n      ModifiableSolrParams params = new ModifiableSolrParams();\n\n      cmdDistrib.distribAdd(cmd, nodes, params);\n\n      CommitUpdateCommand ccmd = new CommitUpdateCommand(null, false);\n      params = new ModifiableSolrParams();\n      params.set(DistributedUpdateProcessor.COMMIT_END_POINT, true);\n      cmdDistrib.distribCommit(ccmd, nodes, params);\n      cmdDistrib.finish();\n\n      long numFoundAfter = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n          .getNumFound();\n\n      // different OS's will throw different exceptions for the bad address above\n      if (numFoundBefore != numFoundAfter) {\n        assertEquals(0, cmdDistrib.getErrors().size());\n        assertEquals(numFoundBefore + 1, numFoundAfter);\n      } else {\n        // we will get java.net.SocketException: Network is unreachable and not retry\n        assertEquals(numFoundBefore, numFoundAfter);\n\n        assertEquals(1, cmdDistrib.getErrors().size());\n      }\n    }\n  }\n\n","bugFix":["f15af35d55d70c34451f9df5edeaeff6b31f8cbe"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc78b7d15e7b8627fa6d1b946da3a39f0225508d","date":1576086705,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/SolrCmdDistributorTest#testRetryNodeAgainstBadAddress().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/SolrCmdDistributorTest#testRetryNodeAgainstBadAddress().mjava","sourceNew":"  private void testRetryNodeAgainstBadAddress() throws SolrServerException, IOException {\n    // Test RetryNode\n    try (SolrCmdDistributor cmdDistrib = new SolrCmdDistributor(updateShardHandler)) {\n      final HttpSolrClient solrclient = (HttpSolrClient) clients.get(0);\n      long numFoundBefore = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n          .getNumFound();\n\n      ArrayList<Node> nodes = new ArrayList<>();\n\n      ZkNodeProps nodeProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, DEAD_HOST_1 + context, ZkStateReader.CORE_NAME_PROP, \"\");\n      ForwardNode retryNode = new ForwardNode(new ZkCoreNodeProps(nodeProps), null, \"collection1\", \"shard1\", 5) {\n        @Override\n        public boolean checkRetry(Error err) {\n          ZkNodeProps leaderProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, solrclient.getBaseURL(),\n              ZkStateReader.CORE_NAME_PROP, \"\");\n          this.nodeProps = new ZkCoreNodeProps(leaderProps);\n\n          return super.checkRetry(err);\n        }\n      };\n\n\n      nodes.add(retryNode);\n\n\n      AddUpdateCommand cmd = new AddUpdateCommand(null);\n      cmd.solrDoc = sdoc(\"id\", id.incrementAndGet());\n      ModifiableSolrParams params = new ModifiableSolrParams();\n\n      cmdDistrib.distribAdd(cmd, nodes, params);\n\n      CommitUpdateCommand ccmd = new CommitUpdateCommand(null, false);\n      params = new ModifiableSolrParams();\n      params.set(DistributedUpdateProcessor.COMMIT_END_POINT, true);\n      cmdDistrib.distribCommit(ccmd, nodes, params);\n      cmdDistrib.finish();\n\n      long numFoundAfter = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n          .getNumFound();\n\n      // different OS's will throw different exceptions for the bad address above\n      if (numFoundBefore != numFoundAfter) {\n        assertEquals(0, cmdDistrib.getErrors().size());\n        assertEquals(numFoundBefore + 1, numFoundAfter);\n      } else {\n        // we will get java.net.SocketException: Network is unreachable and not retry\n        assertEquals(numFoundBefore, numFoundAfter);\n\n        assertEquals(1, cmdDistrib.getErrors().size());\n      }\n    }\n  }\n\n","sourceOld":"  private void testRetryNodeAgainstBadAddress() throws SolrServerException, IOException {\n    // Test RetryNode\n    try (SolrCmdDistributor cmdDistrib = new SolrCmdDistributor(updateShardHandler)) {\n      final HttpSolrClient solrclient = (HttpSolrClient) clients.get(0);\n      long numFoundBefore = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n          .getNumFound();\n\n      ArrayList<Node> nodes = new ArrayList<>();\n\n      ZkNodeProps nodeProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, \"[ff01::114]:33332\" + context, ZkStateReader.CORE_NAME_PROP, \"\");\n      ForwardNode retryNode = new ForwardNode(new ZkCoreNodeProps(nodeProps), null, \"collection1\", \"shard1\", 5) {\n        @Override\n        public boolean checkRetry(Error err) {\n          ZkNodeProps leaderProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, solrclient.getBaseURL(),\n              ZkStateReader.CORE_NAME_PROP, \"\");\n          this.nodeProps = new ZkCoreNodeProps(leaderProps);\n\n          return super.checkRetry(err);\n        }\n      };\n\n\n      nodes.add(retryNode);\n\n\n      AddUpdateCommand cmd = new AddUpdateCommand(null);\n      cmd.solrDoc = sdoc(\"id\", id.incrementAndGet());\n      ModifiableSolrParams params = new ModifiableSolrParams();\n\n      cmdDistrib.distribAdd(cmd, nodes, params);\n\n      CommitUpdateCommand ccmd = new CommitUpdateCommand(null, false);\n      params = new ModifiableSolrParams();\n      params.set(DistributedUpdateProcessor.COMMIT_END_POINT, true);\n      cmdDistrib.distribCommit(ccmd, nodes, params);\n      cmdDistrib.finish();\n\n      long numFoundAfter = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n          .getNumFound();\n\n      // different OS's will throw different exceptions for the bad address above\n      if (numFoundBefore != numFoundAfter) {\n        assertEquals(0, cmdDistrib.getErrors().size());\n        assertEquals(numFoundBefore + 1, numFoundAfter);\n      } else {\n        // we will get java.net.SocketException: Network is unreachable and not retry\n        assertEquals(numFoundBefore, numFoundAfter);\n\n        assertEquals(1, cmdDistrib.getErrors().size());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df724d84dab24a0cc54bec95a8680867adc7f171","date":1576156608,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/SolrCmdDistributorTest#testRetryNodeAgainstBadAddress().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/SolrCmdDistributorTest#testRetryNodeAgainstBadAddress().mjava","sourceNew":"  private void testRetryNodeAgainstBadAddress() throws SolrServerException, IOException {\n    // Test RetryNode\n    try (SolrCmdDistributor cmdDistrib = new SolrCmdDistributor(updateShardHandler)) {\n      final HttpSolrClient solrclient = (HttpSolrClient) clients.get(0);\n      long numFoundBefore = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n          .getNumFound();\n\n      ArrayList<Node> nodes = new ArrayList<>();\n\n      ZkNodeProps nodeProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, DEAD_HOST_1 + context, ZkStateReader.CORE_NAME_PROP, \"\");\n      ForwardNode retryNode = new ForwardNode(new ZkCoreNodeProps(nodeProps), null, \"collection1\", \"shard1\", 5) {\n        @Override\n        public boolean checkRetry(Error err) {\n          ZkNodeProps leaderProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, solrclient.getBaseURL(),\n              ZkStateReader.CORE_NAME_PROP, \"\");\n          this.nodeProps = new ZkCoreNodeProps(leaderProps);\n\n          return super.checkRetry(err);\n        }\n      };\n\n\n      nodes.add(retryNode);\n\n\n      AddUpdateCommand cmd = new AddUpdateCommand(null);\n      cmd.solrDoc = sdoc(\"id\", id.incrementAndGet());\n      ModifiableSolrParams params = new ModifiableSolrParams();\n\n      cmdDistrib.distribAdd(cmd, nodes, params);\n\n      CommitUpdateCommand ccmd = new CommitUpdateCommand(null, false);\n      params = new ModifiableSolrParams();\n      params.set(DistributedUpdateProcessor.COMMIT_END_POINT, true);\n      cmdDistrib.distribCommit(ccmd, nodes, params);\n      cmdDistrib.finish();\n\n      long numFoundAfter = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n          .getNumFound();\n\n      // different OS's will throw different exceptions for the bad address above\n      if (numFoundBefore != numFoundAfter) {\n        assertEquals(0, cmdDistrib.getErrors().size());\n        assertEquals(numFoundBefore + 1, numFoundAfter);\n      } else {\n        // we will get java.net.SocketException: Network is unreachable and not retry\n        assertEquals(numFoundBefore, numFoundAfter);\n\n        assertEquals(1, cmdDistrib.getErrors().size());\n      }\n    }\n  }\n\n","sourceOld":"  private void testRetryNodeAgainstBadAddress() throws SolrServerException, IOException {\n    // Test RetryNode\n    try (SolrCmdDistributor cmdDistrib = new SolrCmdDistributor(updateShardHandler)) {\n      final HttpSolrClient solrclient = (HttpSolrClient) clients.get(0);\n      long numFoundBefore = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n          .getNumFound();\n\n      ArrayList<Node> nodes = new ArrayList<>();\n\n      ZkNodeProps nodeProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, \"[ff01::114]:33332\" + context, ZkStateReader.CORE_NAME_PROP, \"\");\n      ForwardNode retryNode = new ForwardNode(new ZkCoreNodeProps(nodeProps), null, \"collection1\", \"shard1\", 5) {\n        @Override\n        public boolean checkRetry(Error err) {\n          ZkNodeProps leaderProps = new ZkNodeProps(ZkStateReader.BASE_URL_PROP, solrclient.getBaseURL(),\n              ZkStateReader.CORE_NAME_PROP, \"\");\n          this.nodeProps = new ZkCoreNodeProps(leaderProps);\n\n          return super.checkRetry(err);\n        }\n      };\n\n\n      nodes.add(retryNode);\n\n\n      AddUpdateCommand cmd = new AddUpdateCommand(null);\n      cmd.solrDoc = sdoc(\"id\", id.incrementAndGet());\n      ModifiableSolrParams params = new ModifiableSolrParams();\n\n      cmdDistrib.distribAdd(cmd, nodes, params);\n\n      CommitUpdateCommand ccmd = new CommitUpdateCommand(null, false);\n      params = new ModifiableSolrParams();\n      params.set(DistributedUpdateProcessor.COMMIT_END_POINT, true);\n      cmdDistrib.distribCommit(ccmd, nodes, params);\n      cmdDistrib.finish();\n\n      long numFoundAfter = solrclient.query(new SolrQuery(\"*:*\")).getResults()\n          .getNumFound();\n\n      // different OS's will throw different exceptions for the bad address above\n      if (numFoundBefore != numFoundAfter) {\n        assertEquals(0, cmdDistrib.getErrors().size());\n        assertEquals(numFoundBefore + 1, numFoundAfter);\n      } else {\n        // we will get java.net.SocketException: Network is unreachable and not retry\n        assertEquals(numFoundBefore, numFoundAfter);\n\n        assertEquals(1, cmdDistrib.getErrors().size());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"df724d84dab24a0cc54bec95a8680867adc7f171":["c0cf9c2ec975506bab465b6b2be92cb9bffc84d3","bc78b7d15e7b8627fa6d1b946da3a39f0225508d"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["9ce545e833f5334e245fb71d83c3460ef83c2d5e"],"9ce545e833f5334e245fb71d83c3460ef83c2d5e":["c1dd6595120fba7e99fcec70759c6cdea9a071b3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"28b49bc3bf9043888cb4243e659f6898fe2a95a9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9ce545e833f5334e245fb71d83c3460ef83c2d5e"],"bafca15d8e408346a67f4282ad1143b88023893b":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"c1dd6595120fba7e99fcec70759c6cdea9a071b3":["28b49bc3bf9043888cb4243e659f6898fe2a95a9"],"f15af35d55d70c34451f9df5edeaeff6b31f8cbe":["bafca15d8e408346a67f4282ad1143b88023893b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bc78b7d15e7b8627fa6d1b946da3a39f0225508d"],"bc78b7d15e7b8627fa6d1b946da3a39f0225508d":["c0cf9c2ec975506bab465b6b2be92cb9bffc84d3"],"c0cf9c2ec975506bab465b6b2be92cb9bffc84d3":["f15af35d55d70c34451f9df5edeaeff6b31f8cbe"]},"commit2Childs":{"df724d84dab24a0cc54bec95a8680867adc7f171":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["bafca15d8e408346a67f4282ad1143b88023893b"],"9ce545e833f5334e245fb71d83c3460ef83c2d5e":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["28b49bc3bf9043888cb4243e659f6898fe2a95a9","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"28b49bc3bf9043888cb4243e659f6898fe2a95a9":["c1dd6595120fba7e99fcec70759c6cdea9a071b3"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"c1dd6595120fba7e99fcec70759c6cdea9a071b3":["9ce545e833f5334e245fb71d83c3460ef83c2d5e"],"bafca15d8e408346a67f4282ad1143b88023893b":["f15af35d55d70c34451f9df5edeaeff6b31f8cbe"],"f15af35d55d70c34451f9df5edeaeff6b31f8cbe":["c0cf9c2ec975506bab465b6b2be92cb9bffc84d3"],"c0cf9c2ec975506bab465b6b2be92cb9bffc84d3":["df724d84dab24a0cc54bec95a8680867adc7f171","bc78b7d15e7b8627fa6d1b946da3a39f0225508d"],"bc78b7d15e7b8627fa6d1b946da3a39f0225508d":["df724d84dab24a0cc54bec95a8680867adc7f171","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["df724d84dab24a0cc54bec95a8680867adc7f171","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}