{"path":"solr/core/src/test/org/apache/solr/core/snapshots/TestSolrCloudSnapshots#testSnapshots().mjava","commits":[{"id":"424ac616f0aeeb2a3c8b6b94084255a0bcab9628","date":1477057622,"type":0,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/core/snapshots/TestSolrCloudSnapshots#testSnapshots().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testSnapshots() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String collectionName = \"SolrCloudSnapshots\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, \"conf1\", NUM_SHARDS, NUM_REPLICAS);\n    create.process(solrClient);\n\n    int nDocs = BackupRestoreUtils.indexDocs(cluster.getSolrClient(), collectionName, docsSeed);\n    BackupRestoreUtils.verifyDocs(nDocs, solrClient, collectionName);\n\n    String commitName = TestUtil.randomSimpleString(random(), 1, 5);\n\n    // Verify if snapshot creation works with replica failures.\n    boolean replicaFailures = usually();\n    Optional<String> stoppedCoreName = Optional.empty();\n    if (replicaFailures) {\n      // Here the assumption is that Solr will spread the replicas uniformly across nodes.\n      // If this is not true for some reason, then we will need to add some logic to find a\n      // node with a single replica.\n      this.cluster.getRandomJetty(random()).stop();\n\n      // Sleep a bit for allowing ZK watch to fire.\n      Thread.sleep(5000);\n\n      // Figure out if at-least one replica is \"down\".\n      DocCollection collState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n      for (Slice s : collState.getSlices()) {\n        for (Replica replica : s.getReplicas()) {\n          if (replica.getState() == State.DOWN) {\n            stoppedCoreName = Optional.of(replica.getCoreName());\n          }\n        }\n      }\n    }\n\n    int expectedCoresWithSnapshot = stoppedCoreName.isPresent() ? (NUM_SHARDS * NUM_REPLICAS) - 1 : (NUM_SHARDS * NUM_REPLICAS);\n\n    CollectionAdminRequest.CreateSnapshot createSnap = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName);\n    createSnap.process(solrClient);\n\n    Collection<CollectionSnapshotMetaData> collectionSnaps = listCollectionSnapshots(solrClient, collectionName);\n    assertEquals(1, collectionSnaps.size());\n    CollectionSnapshotMetaData meta = collectionSnaps.iterator().next();\n    assertEquals(commitName, meta.getName());\n    assertEquals(CollectionSnapshotMetaData.SnapshotStatus.Successful, meta.getStatus());\n    assertEquals(expectedCoresWithSnapshot, meta.getReplicaSnapshots().size());\n    Map<String, CoreSnapshotMetaData> snapshotByCoreName = meta.getReplicaSnapshots().stream()\n        .collect(Collectors.toMap(CoreSnapshotMetaData::getCoreName, Function.identity()));\n\n    DocCollection collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(2, collectionState.getActiveSlices().size());\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      assertEquals(2, shard.getReplicas().size());\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot is not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        assertTrue(snapshotByCoreName.containsKey(coreName));\n        CoreSnapshotMetaData coreSnapshot = snapshotByCoreName.get(coreName);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertTrue(\"Snapshot not created for core \" + coreName, metaData.isPresent());\n          assertEquals(coreSnapshot.getIndexDirPath(), metaData.get().getIndexDirPath());\n          assertEquals(coreSnapshot.getGenerationNumber(), metaData.get().getGenerationNumber());\n        }\n      }\n    }\n\n    // Delete all documents.\n    {\n      solrClient.deleteByQuery(collectionName, \"*:*\");\n      solrClient.commit(collectionName);\n      BackupRestoreUtils.verifyDocs(0, solrClient, collectionName);\n    }\n\n    String backupLocation = createTempDir().toFile().getAbsolutePath();\n    String backupName = \"mytestbackup\";\n    String restoreCollectionName = collectionName + \"_restored\";\n\n    //Create a backup using the earlier created snapshot.\n    {\n      CollectionAdminRequest.Backup backup = CollectionAdminRequest.backupCollection(collectionName, backupName)\n          .setLocation(backupLocation).setCommitName(commitName);\n      if (random().nextBoolean()) {\n        assertEquals(0, backup.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, backup.processAndWait(solrClient, 30));//async\n      }\n    }\n\n    // Restore backup.\n    {\n      CollectionAdminRequest.Restore restore = CollectionAdminRequest.restoreCollection(restoreCollectionName, backupName)\n          .setLocation(backupLocation);\n      if (random().nextBoolean()) {\n        assertEquals(0, restore.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, restore.processAndWait(solrClient, 30));//async\n      }\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(\n          restoreCollectionName, cluster.getSolrClient().getZkStateReader(), log.isDebugEnabled(), true, 30);\n      BackupRestoreUtils.verifyDocs(nDocs, solrClient, restoreCollectionName);\n    }\n\n    // Verify if the snapshot deletion works correctly when one or more replicas containing the snapshot are\n    // deleted\n    boolean replicaDeletion = rarely();\n    if (replicaDeletion) {\n      CoreSnapshotMetaData replicaToDelete = null;\n      for (String shardId : meta.getShards()) {\n        List<CoreSnapshotMetaData> replicas = meta.getReplicaSnapshotsForShard(shardId);\n        if (replicas.size() > 1) {\n          int r_index = random().nextInt(replicas.size());\n          replicaToDelete = replicas.get(r_index);\n        }\n      }\n\n      if (replicaToDelete != null) {\n        collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n        for (Slice s : collectionState.getSlices()) {\n          for (Replica r : s.getReplicas()) {\n            if (r.getCoreName().equals(replicaToDelete.getCoreName())) {\n              log.info(\"Deleting replica {}\", r);\n              CollectionAdminRequest.DeleteReplica delReplica = CollectionAdminRequest.deleteReplica(collectionName,\n                  replicaToDelete.getShardId(), r.getName());\n              delReplica.process(solrClient);\n              // The replica deletion will cleanup the snapshot meta-data.\n              snapshotByCoreName.remove(r.getCoreName());\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // Delete snapshot\n    CollectionAdminRequest.DeleteSnapshot deleteSnap = new CollectionAdminRequest.DeleteSnapshot(collectionName, commitName);\n    deleteSnap.process(solrClient);\n\n    // Wait for a while so that the clusterstate.json updates are propagated to the client side.\n    Thread.sleep(2000);\n    collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot was not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertFalse(\"Snapshot not deleted for core \" + coreName, metaData.isPresent());\n          // Remove the entry for core if the snapshot is deleted successfully.\n          snapshotByCoreName.remove(coreName);\n        }\n      }\n    }\n\n    // Verify all core-level snapshots are deleted.\n    assertTrue(\"The cores remaining \" + snapshotByCoreName, snapshotByCoreName.isEmpty());\n    assertTrue(listCollectionSnapshots(solrClient, collectionName).isEmpty());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"80d0e6d59ae23f4a6f30eaf40bfb40742300287f","date":1477598926,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/core/snapshots/TestSolrCloudSnapshots#testSnapshots().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testSnapshots() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String collectionName = \"SolrCloudSnapshots\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, \"conf1\", NUM_SHARDS, NUM_REPLICAS);\n    create.process(solrClient);\n\n    int nDocs = BackupRestoreUtils.indexDocs(cluster.getSolrClient(), collectionName, docsSeed);\n    BackupRestoreUtils.verifyDocs(nDocs, solrClient, collectionName);\n\n    String commitName = TestUtil.randomSimpleString(random(), 1, 5);\n\n    // Verify if snapshot creation works with replica failures.\n    boolean replicaFailures = usually();\n    Optional<String> stoppedCoreName = Optional.empty();\n    if (replicaFailures) {\n      // Here the assumption is that Solr will spread the replicas uniformly across nodes.\n      // If this is not true for some reason, then we will need to add some logic to find a\n      // node with a single replica.\n      this.cluster.getRandomJetty(random()).stop();\n\n      // Sleep a bit for allowing ZK watch to fire.\n      Thread.sleep(5000);\n\n      // Figure out if at-least one replica is \"down\".\n      DocCollection collState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n      for (Slice s : collState.getSlices()) {\n        for (Replica replica : s.getReplicas()) {\n          if (replica.getState() == State.DOWN) {\n            stoppedCoreName = Optional.of(replica.getCoreName());\n          }\n        }\n      }\n    }\n\n    int expectedCoresWithSnapshot = stoppedCoreName.isPresent() ? (NUM_SHARDS * NUM_REPLICAS) - 1 : (NUM_SHARDS * NUM_REPLICAS);\n\n    CollectionAdminRequest.CreateSnapshot createSnap = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName);\n    createSnap.process(solrClient);\n\n    Collection<CollectionSnapshotMetaData> collectionSnaps = listCollectionSnapshots(solrClient, collectionName);\n    assertEquals(1, collectionSnaps.size());\n    CollectionSnapshotMetaData meta = collectionSnaps.iterator().next();\n    assertEquals(commitName, meta.getName());\n    assertEquals(CollectionSnapshotMetaData.SnapshotStatus.Successful, meta.getStatus());\n    assertEquals(expectedCoresWithSnapshot, meta.getReplicaSnapshots().size());\n    Map<String, CoreSnapshotMetaData> snapshotByCoreName = meta.getReplicaSnapshots().stream()\n        .collect(Collectors.toMap(CoreSnapshotMetaData::getCoreName, Function.identity()));\n\n    DocCollection collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(2, collectionState.getActiveSlices().size());\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      assertEquals(2, shard.getReplicas().size());\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot is not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        assertTrue(snapshotByCoreName.containsKey(coreName));\n        CoreSnapshotMetaData coreSnapshot = snapshotByCoreName.get(coreName);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertTrue(\"Snapshot not created for core \" + coreName, metaData.isPresent());\n          assertEquals(coreSnapshot.getIndexDirPath(), metaData.get().getIndexDirPath());\n          assertEquals(coreSnapshot.getGenerationNumber(), metaData.get().getGenerationNumber());\n        }\n      }\n    }\n\n    // Delete all documents.\n    {\n      solrClient.deleteByQuery(collectionName, \"*:*\");\n      solrClient.commit(collectionName);\n      BackupRestoreUtils.verifyDocs(0, solrClient, collectionName);\n    }\n\n    String backupLocation = createTempDir().toFile().getAbsolutePath();\n    String backupName = \"mytestbackup\";\n    String restoreCollectionName = collectionName + \"_restored\";\n\n    //Create a backup using the earlier created snapshot.\n    {\n      CollectionAdminRequest.Backup backup = CollectionAdminRequest.backupCollection(collectionName, backupName)\n          .setLocation(backupLocation).setCommitName(commitName);\n      if (random().nextBoolean()) {\n        assertEquals(0, backup.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, backup.processAndWait(solrClient, 30));//async\n      }\n    }\n\n    // Restore backup.\n    {\n      CollectionAdminRequest.Restore restore = CollectionAdminRequest.restoreCollection(restoreCollectionName, backupName)\n          .setLocation(backupLocation);\n      if (random().nextBoolean()) {\n        assertEquals(0, restore.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, restore.processAndWait(solrClient, 30));//async\n      }\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(\n          restoreCollectionName, cluster.getSolrClient().getZkStateReader(), log.isDebugEnabled(), true, 30);\n      BackupRestoreUtils.verifyDocs(nDocs, solrClient, restoreCollectionName);\n    }\n\n    // Verify if the snapshot deletion works correctly when one or more replicas containing the snapshot are\n    // deleted\n    boolean replicaDeletion = rarely();\n    if (replicaDeletion) {\n      CoreSnapshotMetaData replicaToDelete = null;\n      for (String shardId : meta.getShards()) {\n        List<CoreSnapshotMetaData> replicas = meta.getReplicaSnapshotsForShard(shardId);\n        if (replicas.size() > 1) {\n          int r_index = random().nextInt(replicas.size());\n          replicaToDelete = replicas.get(r_index);\n        }\n      }\n\n      if (replicaToDelete != null) {\n        collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n        for (Slice s : collectionState.getSlices()) {\n          for (Replica r : s.getReplicas()) {\n            if (r.getCoreName().equals(replicaToDelete.getCoreName())) {\n              log.info(\"Deleting replica {}\", r);\n              CollectionAdminRequest.DeleteReplica delReplica = CollectionAdminRequest.deleteReplica(collectionName,\n                  replicaToDelete.getShardId(), r.getName());\n              delReplica.process(solrClient);\n              // The replica deletion will cleanup the snapshot meta-data.\n              snapshotByCoreName.remove(r.getCoreName());\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // Delete snapshot\n    CollectionAdminRequest.DeleteSnapshot deleteSnap = new CollectionAdminRequest.DeleteSnapshot(collectionName, commitName);\n    deleteSnap.process(solrClient);\n\n    // Wait for a while so that the clusterstate.json updates are propagated to the client side.\n    Thread.sleep(2000);\n    collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot was not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertFalse(\"Snapshot not deleted for core \" + coreName, metaData.isPresent());\n          // Remove the entry for core if the snapshot is deleted successfully.\n          snapshotByCoreName.remove(coreName);\n        }\n      }\n    }\n\n    // Verify all core-level snapshots are deleted.\n    assertTrue(\"The cores remaining \" + snapshotByCoreName, snapshotByCoreName.isEmpty());\n    assertTrue(listCollectionSnapshots(solrClient, collectionName).isEmpty());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"23ee9ee847c92f9e0395e1ff6655ec464e0a57a2","date":1485828282,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/core/snapshots/TestSolrCloudSnapshots#testSnapshots().mjava","pathOld":"solr/core/src/test/org/apache/solr/core/snapshots/TestSolrCloudSnapshots#testSnapshots().mjava","sourceNew":"  @Test\n  public void testSnapshots() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String collectionName = \"SolrCloudSnapshots\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, \"conf1\", NUM_SHARDS, NUM_REPLICAS);\n    create.process(solrClient);\n\n    int nDocs = BackupRestoreUtils.indexDocs(cluster.getSolrClient(), collectionName, docsSeed);\n    BackupRestoreUtils.verifyDocs(nDocs, solrClient, collectionName);\n\n    String commitName = TestUtil.randomSimpleString(random(), 1, 5);\n\n    // Verify if snapshot creation works with replica failures.\n    boolean replicaFailures = usually();\n    Optional<String> stoppedCoreName = Optional.empty();\n    if (replicaFailures) {\n      // Here the assumption is that Solr will spread the replicas uniformly across nodes.\n      // If this is not true for some reason, then we will need to add some logic to find a\n      // node with a single replica.\n      this.cluster.getRandomJetty(random()).stop();\n\n      // Sleep a bit for allowing ZK watch to fire.\n      Thread.sleep(5000);\n\n      // Figure out if at-least one replica is \"down\".\n      DocCollection collState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n      for (Slice s : collState.getSlices()) {\n        for (Replica replica : s.getReplicas()) {\n          if (replica.getState() == State.DOWN) {\n            stoppedCoreName = Optional.of(replica.getCoreName());\n          }\n        }\n      }\n    }\n\n    int expectedCoresWithSnapshot = stoppedCoreName.isPresent() ? (NUM_SHARDS * NUM_REPLICAS) - 1 : (NUM_SHARDS * NUM_REPLICAS);\n\n    CollectionAdminRequest.CreateSnapshot createSnap = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName);\n    createSnap.process(solrClient);\n\n    Collection<CollectionSnapshotMetaData> collectionSnaps = listCollectionSnapshots(solrClient, collectionName);\n    assertEquals(1, collectionSnaps.size());\n    CollectionSnapshotMetaData meta = collectionSnaps.iterator().next();\n    assertEquals(commitName, meta.getName());\n    assertEquals(CollectionSnapshotMetaData.SnapshotStatus.Successful, meta.getStatus());\n    assertEquals(expectedCoresWithSnapshot, meta.getReplicaSnapshots().size());\n    Map<String, CoreSnapshotMetaData> snapshotByCoreName = meta.getReplicaSnapshots().stream()\n        .collect(Collectors.toMap(CoreSnapshotMetaData::getCoreName, Function.identity()));\n\n    DocCollection collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(2, collectionState.getActiveSlices().size());\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      assertEquals(2, shard.getReplicas().size());\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot is not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        assertTrue(snapshotByCoreName.containsKey(coreName));\n        CoreSnapshotMetaData coreSnapshot = snapshotByCoreName.get(coreName);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertTrue(\"Snapshot not created for core \" + coreName, metaData.isPresent());\n          assertEquals(coreSnapshot.getIndexDirPath(), metaData.get().getIndexDirPath());\n          assertEquals(coreSnapshot.getGenerationNumber(), metaData.get().getGenerationNumber());\n        }\n      }\n    }\n\n    // Delete all documents.\n    {\n      solrClient.deleteByQuery(collectionName, \"*:*\");\n      solrClient.commit(collectionName);\n      BackupRestoreUtils.verifyDocs(0, solrClient, collectionName);\n    }\n\n    String backupLocation = createTempDir().toFile().getAbsolutePath();\n    String backupName = \"mytestbackup\";\n    String restoreCollectionName = collectionName + \"_restored\";\n\n    //Create a backup using the earlier created snapshot.\n    {\n      CollectionAdminRequest.Backup backup = CollectionAdminRequest.backupCollection(collectionName, backupName)\n          .setLocation(backupLocation).setCommitName(commitName);\n      if (random().nextBoolean()) {\n        assertEquals(0, backup.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, backup.processAndWait(solrClient, 30));//async\n      }\n    }\n\n    // Restore backup.\n    {\n      CollectionAdminRequest.Restore restore = CollectionAdminRequest.restoreCollection(restoreCollectionName, backupName)\n          .setLocation(backupLocation);\n      if (random().nextBoolean()) {\n        assertEquals(0, restore.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, restore.processAndWait(solrClient, 30));//async\n      }\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(\n          restoreCollectionName, cluster.getSolrClient().getZkStateReader(), log.isDebugEnabled(), true, 30);\n      BackupRestoreUtils.verifyDocs(nDocs, solrClient, restoreCollectionName);\n    }\n\n    // Verify if the snapshot deletion works correctly when one or more replicas containing the snapshot are\n    // deleted\n    boolean replicaDeletion = rarely();\n    if (replicaDeletion) {\n      CoreSnapshotMetaData replicaToDelete = null;\n      for (String shardId : meta.getShards()) {\n        List<CoreSnapshotMetaData> replicas = meta.getReplicaSnapshotsForShard(shardId);\n        if (replicas.size() > 1) {\n          int r_index = random().nextInt(replicas.size());\n          replicaToDelete = replicas.get(r_index);\n        }\n      }\n\n      if (replicaToDelete != null) {\n        collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n        for (Slice s : collectionState.getSlices()) {\n          for (Replica r : s.getReplicas()) {\n            if (r.getCoreName().equals(replicaToDelete.getCoreName())) {\n              log.info(\"Deleting replica {}\", r);\n              CollectionAdminRequest.DeleteReplica delReplica = CollectionAdminRequest.deleteReplica(collectionName,\n                  replicaToDelete.getShardId(), r.getName());\n              delReplica.process(solrClient);\n              // The replica deletion will cleanup the snapshot meta-data.\n              snapshotByCoreName.remove(r.getCoreName());\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // Delete snapshot\n    CollectionAdminRequest.DeleteSnapshot deleteSnap = new CollectionAdminRequest.DeleteSnapshot(collectionName, commitName);\n    deleteSnap.process(solrClient);\n\n    // Wait for a while so that the clusterstate.json updates are propagated to the client side.\n    Thread.sleep(2000);\n    collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot was not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertFalse(\"Snapshot not deleted for core \" + coreName, metaData.isPresent());\n          // Remove the entry for core if the snapshot is deleted successfully.\n          snapshotByCoreName.remove(coreName);\n        }\n      }\n    }\n\n    // Verify all core-level snapshots are deleted.\n    assertTrue(\"The cores remaining \" + snapshotByCoreName, snapshotByCoreName.isEmpty());\n    assertTrue(listCollectionSnapshots(solrClient, collectionName).isEmpty());\n\n    // Verify if the collection deletion result in proper cleanup of snapshot metadata.\n    {\n      String commitName_2 = commitName + \"_2\";\n\n      CollectionAdminRequest.CreateSnapshot createSnap_2 = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName_2);\n      assertEquals(0, createSnap_2.process(solrClient).getStatus());\n\n      Collection<CollectionSnapshotMetaData> collectionSnaps_2 = listCollectionSnapshots(solrClient, collectionName);\n      assertEquals(1, collectionSnaps.size());\n      assertEquals(commitName_2, collectionSnaps_2.iterator().next().getName());\n\n      // Delete collection\n      CollectionAdminRequest.Delete deleteCol = CollectionAdminRequest.deleteCollection(collectionName);\n      assertEquals(0, deleteCol.process(solrClient).getStatus());\n      assertTrue(SolrSnapshotManager.listSnapshots(solrClient.getZkStateReader().getZkClient(), collectionName).isEmpty());\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSnapshots() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String collectionName = \"SolrCloudSnapshots\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, \"conf1\", NUM_SHARDS, NUM_REPLICAS);\n    create.process(solrClient);\n\n    int nDocs = BackupRestoreUtils.indexDocs(cluster.getSolrClient(), collectionName, docsSeed);\n    BackupRestoreUtils.verifyDocs(nDocs, solrClient, collectionName);\n\n    String commitName = TestUtil.randomSimpleString(random(), 1, 5);\n\n    // Verify if snapshot creation works with replica failures.\n    boolean replicaFailures = usually();\n    Optional<String> stoppedCoreName = Optional.empty();\n    if (replicaFailures) {\n      // Here the assumption is that Solr will spread the replicas uniformly across nodes.\n      // If this is not true for some reason, then we will need to add some logic to find a\n      // node with a single replica.\n      this.cluster.getRandomJetty(random()).stop();\n\n      // Sleep a bit for allowing ZK watch to fire.\n      Thread.sleep(5000);\n\n      // Figure out if at-least one replica is \"down\".\n      DocCollection collState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n      for (Slice s : collState.getSlices()) {\n        for (Replica replica : s.getReplicas()) {\n          if (replica.getState() == State.DOWN) {\n            stoppedCoreName = Optional.of(replica.getCoreName());\n          }\n        }\n      }\n    }\n\n    int expectedCoresWithSnapshot = stoppedCoreName.isPresent() ? (NUM_SHARDS * NUM_REPLICAS) - 1 : (NUM_SHARDS * NUM_REPLICAS);\n\n    CollectionAdminRequest.CreateSnapshot createSnap = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName);\n    createSnap.process(solrClient);\n\n    Collection<CollectionSnapshotMetaData> collectionSnaps = listCollectionSnapshots(solrClient, collectionName);\n    assertEquals(1, collectionSnaps.size());\n    CollectionSnapshotMetaData meta = collectionSnaps.iterator().next();\n    assertEquals(commitName, meta.getName());\n    assertEquals(CollectionSnapshotMetaData.SnapshotStatus.Successful, meta.getStatus());\n    assertEquals(expectedCoresWithSnapshot, meta.getReplicaSnapshots().size());\n    Map<String, CoreSnapshotMetaData> snapshotByCoreName = meta.getReplicaSnapshots().stream()\n        .collect(Collectors.toMap(CoreSnapshotMetaData::getCoreName, Function.identity()));\n\n    DocCollection collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(2, collectionState.getActiveSlices().size());\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      assertEquals(2, shard.getReplicas().size());\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot is not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        assertTrue(snapshotByCoreName.containsKey(coreName));\n        CoreSnapshotMetaData coreSnapshot = snapshotByCoreName.get(coreName);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertTrue(\"Snapshot not created for core \" + coreName, metaData.isPresent());\n          assertEquals(coreSnapshot.getIndexDirPath(), metaData.get().getIndexDirPath());\n          assertEquals(coreSnapshot.getGenerationNumber(), metaData.get().getGenerationNumber());\n        }\n      }\n    }\n\n    // Delete all documents.\n    {\n      solrClient.deleteByQuery(collectionName, \"*:*\");\n      solrClient.commit(collectionName);\n      BackupRestoreUtils.verifyDocs(0, solrClient, collectionName);\n    }\n\n    String backupLocation = createTempDir().toFile().getAbsolutePath();\n    String backupName = \"mytestbackup\";\n    String restoreCollectionName = collectionName + \"_restored\";\n\n    //Create a backup using the earlier created snapshot.\n    {\n      CollectionAdminRequest.Backup backup = CollectionAdminRequest.backupCollection(collectionName, backupName)\n          .setLocation(backupLocation).setCommitName(commitName);\n      if (random().nextBoolean()) {\n        assertEquals(0, backup.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, backup.processAndWait(solrClient, 30));//async\n      }\n    }\n\n    // Restore backup.\n    {\n      CollectionAdminRequest.Restore restore = CollectionAdminRequest.restoreCollection(restoreCollectionName, backupName)\n          .setLocation(backupLocation);\n      if (random().nextBoolean()) {\n        assertEquals(0, restore.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, restore.processAndWait(solrClient, 30));//async\n      }\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(\n          restoreCollectionName, cluster.getSolrClient().getZkStateReader(), log.isDebugEnabled(), true, 30);\n      BackupRestoreUtils.verifyDocs(nDocs, solrClient, restoreCollectionName);\n    }\n\n    // Verify if the snapshot deletion works correctly when one or more replicas containing the snapshot are\n    // deleted\n    boolean replicaDeletion = rarely();\n    if (replicaDeletion) {\n      CoreSnapshotMetaData replicaToDelete = null;\n      for (String shardId : meta.getShards()) {\n        List<CoreSnapshotMetaData> replicas = meta.getReplicaSnapshotsForShard(shardId);\n        if (replicas.size() > 1) {\n          int r_index = random().nextInt(replicas.size());\n          replicaToDelete = replicas.get(r_index);\n        }\n      }\n\n      if (replicaToDelete != null) {\n        collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n        for (Slice s : collectionState.getSlices()) {\n          for (Replica r : s.getReplicas()) {\n            if (r.getCoreName().equals(replicaToDelete.getCoreName())) {\n              log.info(\"Deleting replica {}\", r);\n              CollectionAdminRequest.DeleteReplica delReplica = CollectionAdminRequest.deleteReplica(collectionName,\n                  replicaToDelete.getShardId(), r.getName());\n              delReplica.process(solrClient);\n              // The replica deletion will cleanup the snapshot meta-data.\n              snapshotByCoreName.remove(r.getCoreName());\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // Delete snapshot\n    CollectionAdminRequest.DeleteSnapshot deleteSnap = new CollectionAdminRequest.DeleteSnapshot(collectionName, commitName);\n    deleteSnap.process(solrClient);\n\n    // Wait for a while so that the clusterstate.json updates are propagated to the client side.\n    Thread.sleep(2000);\n    collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot was not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertFalse(\"Snapshot not deleted for core \" + coreName, metaData.isPresent());\n          // Remove the entry for core if the snapshot is deleted successfully.\n          snapshotByCoreName.remove(coreName);\n        }\n      }\n    }\n\n    // Verify all core-level snapshots are deleted.\n    assertTrue(\"The cores remaining \" + snapshotByCoreName, snapshotByCoreName.isEmpty());\n    assertTrue(listCollectionSnapshots(solrClient, collectionName).isEmpty());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c3523a0ab04c3002eee3896c75ea5f10f388bcc","date":1485968422,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/core/snapshots/TestSolrCloudSnapshots#testSnapshots().mjava","pathOld":"solr/core/src/test/org/apache/solr/core/snapshots/TestSolrCloudSnapshots#testSnapshots().mjava","sourceNew":"  @Test\n  public void testSnapshots() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String collectionName = \"SolrCloudSnapshots\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, \"conf1\", NUM_SHARDS, NUM_REPLICAS);\n    create.process(solrClient);\n\n    int nDocs = BackupRestoreUtils.indexDocs(cluster.getSolrClient(), collectionName, docsSeed);\n    BackupRestoreUtils.verifyDocs(nDocs, solrClient, collectionName);\n\n    String commitName = TestUtil.randomSimpleString(random(), 1, 5);\n\n    // Verify if snapshot creation works with replica failures.\n    boolean replicaFailures = usually();\n    Optional<String> stoppedCoreName = Optional.empty();\n    if (replicaFailures) {\n      // Here the assumption is that Solr will spread the replicas uniformly across nodes.\n      // If this is not true for some reason, then we will need to add some logic to find a\n      // node with a single replica.\n      this.cluster.getRandomJetty(random()).stop();\n\n      // Sleep a bit for allowing ZK watch to fire.\n      Thread.sleep(5000);\n\n      // Figure out if at-least one replica is \"down\".\n      DocCollection collState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n      for (Slice s : collState.getSlices()) {\n        for (Replica replica : s.getReplicas()) {\n          if (replica.getState() == State.DOWN) {\n            stoppedCoreName = Optional.of(replica.getCoreName());\n          }\n        }\n      }\n    }\n\n    int expectedCoresWithSnapshot = stoppedCoreName.isPresent() ? (NUM_SHARDS * NUM_REPLICAS) - 1 : (NUM_SHARDS * NUM_REPLICAS);\n\n    CollectionAdminRequest.CreateSnapshot createSnap = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName);\n    createSnap.process(solrClient);\n\n    Collection<CollectionSnapshotMetaData> collectionSnaps = listCollectionSnapshots(solrClient, collectionName);\n    assertEquals(1, collectionSnaps.size());\n    CollectionSnapshotMetaData meta = collectionSnaps.iterator().next();\n    assertEquals(commitName, meta.getName());\n    assertEquals(CollectionSnapshotMetaData.SnapshotStatus.Successful, meta.getStatus());\n    assertEquals(expectedCoresWithSnapshot, meta.getReplicaSnapshots().size());\n    Map<String, CoreSnapshotMetaData> snapshotByCoreName = meta.getReplicaSnapshots().stream()\n        .collect(Collectors.toMap(CoreSnapshotMetaData::getCoreName, Function.identity()));\n\n    DocCollection collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(2, collectionState.getActiveSlices().size());\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      assertEquals(2, shard.getReplicas().size());\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot is not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        assertTrue(snapshotByCoreName.containsKey(coreName));\n        CoreSnapshotMetaData coreSnapshot = snapshotByCoreName.get(coreName);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertTrue(\"Snapshot not created for core \" + coreName, metaData.isPresent());\n          assertEquals(coreSnapshot.getIndexDirPath(), metaData.get().getIndexDirPath());\n          assertEquals(coreSnapshot.getGenerationNumber(), metaData.get().getGenerationNumber());\n        }\n      }\n    }\n\n    // Delete all documents.\n    {\n      solrClient.deleteByQuery(collectionName, \"*:*\");\n      solrClient.commit(collectionName);\n      BackupRestoreUtils.verifyDocs(0, solrClient, collectionName);\n    }\n\n    String backupLocation = createTempDir().toFile().getAbsolutePath();\n    String backupName = \"mytestbackup\";\n    String restoreCollectionName = collectionName + \"_restored\";\n\n    //Create a backup using the earlier created snapshot.\n    {\n      CollectionAdminRequest.Backup backup = CollectionAdminRequest.backupCollection(collectionName, backupName)\n          .setLocation(backupLocation).setCommitName(commitName);\n      if (random().nextBoolean()) {\n        assertEquals(0, backup.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, backup.processAndWait(solrClient, 30));//async\n      }\n    }\n\n    // Restore backup.\n    {\n      CollectionAdminRequest.Restore restore = CollectionAdminRequest.restoreCollection(restoreCollectionName, backupName)\n          .setLocation(backupLocation);\n      if (random().nextBoolean()) {\n        assertEquals(0, restore.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, restore.processAndWait(solrClient, 30));//async\n      }\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(\n          restoreCollectionName, cluster.getSolrClient().getZkStateReader(), log.isDebugEnabled(), true, 30);\n      BackupRestoreUtils.verifyDocs(nDocs, solrClient, restoreCollectionName);\n    }\n\n    // Verify if the snapshot deletion works correctly when one or more replicas containing the snapshot are\n    // deleted\n    boolean replicaDeletion = rarely();\n    if (replicaDeletion) {\n      CoreSnapshotMetaData replicaToDelete = null;\n      for (String shardId : meta.getShards()) {\n        List<CoreSnapshotMetaData> replicas = meta.getReplicaSnapshotsForShard(shardId);\n        if (replicas.size() > 1) {\n          int r_index = random().nextInt(replicas.size());\n          replicaToDelete = replicas.get(r_index);\n        }\n      }\n\n      if (replicaToDelete != null) {\n        collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n        for (Slice s : collectionState.getSlices()) {\n          for (Replica r : s.getReplicas()) {\n            if (r.getCoreName().equals(replicaToDelete.getCoreName())) {\n              log.info(\"Deleting replica {}\", r);\n              CollectionAdminRequest.DeleteReplica delReplica = CollectionAdminRequest.deleteReplica(collectionName,\n                  replicaToDelete.getShardId(), r.getName());\n              delReplica.process(solrClient);\n              // The replica deletion will cleanup the snapshot meta-data.\n              snapshotByCoreName.remove(r.getCoreName());\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // Delete snapshot\n    CollectionAdminRequest.DeleteSnapshot deleteSnap = new CollectionAdminRequest.DeleteSnapshot(collectionName, commitName);\n    deleteSnap.process(solrClient);\n\n    // Wait for a while so that the clusterstate.json updates are propagated to the client side.\n    Thread.sleep(2000);\n    collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot was not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertFalse(\"Snapshot not deleted for core \" + coreName, metaData.isPresent());\n          // Remove the entry for core if the snapshot is deleted successfully.\n          snapshotByCoreName.remove(coreName);\n        }\n      }\n    }\n\n    // Verify all core-level snapshots are deleted.\n    assertTrue(\"The cores remaining \" + snapshotByCoreName, snapshotByCoreName.isEmpty());\n    assertTrue(listCollectionSnapshots(solrClient, collectionName).isEmpty());\n\n    // Verify if the collection deletion result in proper cleanup of snapshot metadata.\n    {\n      String commitName_2 = commitName + \"_2\";\n\n      CollectionAdminRequest.CreateSnapshot createSnap_2 = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName_2);\n      assertEquals(0, createSnap_2.process(solrClient).getStatus());\n\n      Collection<CollectionSnapshotMetaData> collectionSnaps_2 = listCollectionSnapshots(solrClient, collectionName);\n      assertEquals(1, collectionSnaps.size());\n      assertEquals(commitName_2, collectionSnaps_2.iterator().next().getName());\n\n      // Delete collection\n      CollectionAdminRequest.Delete deleteCol = CollectionAdminRequest.deleteCollection(collectionName);\n      assertEquals(0, deleteCol.process(solrClient).getStatus());\n      assertTrue(SolrSnapshotManager.listSnapshots(solrClient.getZkStateReader().getZkClient(), collectionName).isEmpty());\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSnapshots() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String collectionName = \"SolrCloudSnapshots\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, \"conf1\", NUM_SHARDS, NUM_REPLICAS);\n    create.process(solrClient);\n\n    int nDocs = BackupRestoreUtils.indexDocs(cluster.getSolrClient(), collectionName, docsSeed);\n    BackupRestoreUtils.verifyDocs(nDocs, solrClient, collectionName);\n\n    String commitName = TestUtil.randomSimpleString(random(), 1, 5);\n\n    // Verify if snapshot creation works with replica failures.\n    boolean replicaFailures = usually();\n    Optional<String> stoppedCoreName = Optional.empty();\n    if (replicaFailures) {\n      // Here the assumption is that Solr will spread the replicas uniformly across nodes.\n      // If this is not true for some reason, then we will need to add some logic to find a\n      // node with a single replica.\n      this.cluster.getRandomJetty(random()).stop();\n\n      // Sleep a bit for allowing ZK watch to fire.\n      Thread.sleep(5000);\n\n      // Figure out if at-least one replica is \"down\".\n      DocCollection collState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n      for (Slice s : collState.getSlices()) {\n        for (Replica replica : s.getReplicas()) {\n          if (replica.getState() == State.DOWN) {\n            stoppedCoreName = Optional.of(replica.getCoreName());\n          }\n        }\n      }\n    }\n\n    int expectedCoresWithSnapshot = stoppedCoreName.isPresent() ? (NUM_SHARDS * NUM_REPLICAS) - 1 : (NUM_SHARDS * NUM_REPLICAS);\n\n    CollectionAdminRequest.CreateSnapshot createSnap = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName);\n    createSnap.process(solrClient);\n\n    Collection<CollectionSnapshotMetaData> collectionSnaps = listCollectionSnapshots(solrClient, collectionName);\n    assertEquals(1, collectionSnaps.size());\n    CollectionSnapshotMetaData meta = collectionSnaps.iterator().next();\n    assertEquals(commitName, meta.getName());\n    assertEquals(CollectionSnapshotMetaData.SnapshotStatus.Successful, meta.getStatus());\n    assertEquals(expectedCoresWithSnapshot, meta.getReplicaSnapshots().size());\n    Map<String, CoreSnapshotMetaData> snapshotByCoreName = meta.getReplicaSnapshots().stream()\n        .collect(Collectors.toMap(CoreSnapshotMetaData::getCoreName, Function.identity()));\n\n    DocCollection collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(2, collectionState.getActiveSlices().size());\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      assertEquals(2, shard.getReplicas().size());\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot is not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        assertTrue(snapshotByCoreName.containsKey(coreName));\n        CoreSnapshotMetaData coreSnapshot = snapshotByCoreName.get(coreName);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertTrue(\"Snapshot not created for core \" + coreName, metaData.isPresent());\n          assertEquals(coreSnapshot.getIndexDirPath(), metaData.get().getIndexDirPath());\n          assertEquals(coreSnapshot.getGenerationNumber(), metaData.get().getGenerationNumber());\n        }\n      }\n    }\n\n    // Delete all documents.\n    {\n      solrClient.deleteByQuery(collectionName, \"*:*\");\n      solrClient.commit(collectionName);\n      BackupRestoreUtils.verifyDocs(0, solrClient, collectionName);\n    }\n\n    String backupLocation = createTempDir().toFile().getAbsolutePath();\n    String backupName = \"mytestbackup\";\n    String restoreCollectionName = collectionName + \"_restored\";\n\n    //Create a backup using the earlier created snapshot.\n    {\n      CollectionAdminRequest.Backup backup = CollectionAdminRequest.backupCollection(collectionName, backupName)\n          .setLocation(backupLocation).setCommitName(commitName);\n      if (random().nextBoolean()) {\n        assertEquals(0, backup.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, backup.processAndWait(solrClient, 30));//async\n      }\n    }\n\n    // Restore backup.\n    {\n      CollectionAdminRequest.Restore restore = CollectionAdminRequest.restoreCollection(restoreCollectionName, backupName)\n          .setLocation(backupLocation);\n      if (random().nextBoolean()) {\n        assertEquals(0, restore.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, restore.processAndWait(solrClient, 30));//async\n      }\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(\n          restoreCollectionName, cluster.getSolrClient().getZkStateReader(), log.isDebugEnabled(), true, 30);\n      BackupRestoreUtils.verifyDocs(nDocs, solrClient, restoreCollectionName);\n    }\n\n    // Verify if the snapshot deletion works correctly when one or more replicas containing the snapshot are\n    // deleted\n    boolean replicaDeletion = rarely();\n    if (replicaDeletion) {\n      CoreSnapshotMetaData replicaToDelete = null;\n      for (String shardId : meta.getShards()) {\n        List<CoreSnapshotMetaData> replicas = meta.getReplicaSnapshotsForShard(shardId);\n        if (replicas.size() > 1) {\n          int r_index = random().nextInt(replicas.size());\n          replicaToDelete = replicas.get(r_index);\n        }\n      }\n\n      if (replicaToDelete != null) {\n        collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n        for (Slice s : collectionState.getSlices()) {\n          for (Replica r : s.getReplicas()) {\n            if (r.getCoreName().equals(replicaToDelete.getCoreName())) {\n              log.info(\"Deleting replica {}\", r);\n              CollectionAdminRequest.DeleteReplica delReplica = CollectionAdminRequest.deleteReplica(collectionName,\n                  replicaToDelete.getShardId(), r.getName());\n              delReplica.process(solrClient);\n              // The replica deletion will cleanup the snapshot meta-data.\n              snapshotByCoreName.remove(r.getCoreName());\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // Delete snapshot\n    CollectionAdminRequest.DeleteSnapshot deleteSnap = new CollectionAdminRequest.DeleteSnapshot(collectionName, commitName);\n    deleteSnap.process(solrClient);\n\n    // Wait for a while so that the clusterstate.json updates are propagated to the client side.\n    Thread.sleep(2000);\n    collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot was not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertFalse(\"Snapshot not deleted for core \" + coreName, metaData.isPresent());\n          // Remove the entry for core if the snapshot is deleted successfully.\n          snapshotByCoreName.remove(coreName);\n        }\n      }\n    }\n\n    // Verify all core-level snapshots are deleted.\n    assertTrue(\"The cores remaining \" + snapshotByCoreName, snapshotByCoreName.isEmpty());\n    assertTrue(listCollectionSnapshots(solrClient, collectionName).isEmpty());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d18dd44acd824af8b51a5994c9475b32b094fb76","date":1494427167,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/core/snapshots/TestSolrCloudSnapshots#testSnapshots().mjava","pathOld":"solr/core/src/test/org/apache/solr/core/snapshots/TestSolrCloudSnapshots#testSnapshots().mjava","sourceNew":"  @Test\n  public void testSnapshots() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String collectionName = \"SolrCloudSnapshots\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, \"conf1\", NUM_SHARDS, NUM_REPLICAS);\n    create.process(solrClient);\n\n    int nDocs = BackupRestoreUtils.indexDocs(cluster.getSolrClient(), collectionName, docsSeed);\n    BackupRestoreUtils.verifyDocs(nDocs, solrClient, collectionName);\n\n    String commitName = TestUtil.randomSimpleString(random(), 1, 5);\n\n    // Verify if snapshot creation works with replica failures.\n    boolean replicaFailures = usually();\n    Optional<String> stoppedCoreName = Optional.empty();\n    if (replicaFailures) {\n      // Here the assumption is that Solr will spread the replicas uniformly across nodes.\n      // If this is not true for some reason, then we will need to add some logic to find a\n      // node with a single replica.\n      this.cluster.getRandomJetty(random()).stop();\n\n      // Sleep a bit for allowing ZK watch to fire.\n      Thread.sleep(5000);\n\n      // Figure out if at-least one replica is \"down\".\n      DocCollection collState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n      for (Slice s : collState.getSlices()) {\n        for (Replica replica : s.getReplicas()) {\n          if (replica.getState() == State.DOWN) {\n            stoppedCoreName = Optional.of(replica.getCoreName());\n          }\n        }\n      }\n    }\n\n    int expectedCoresWithSnapshot = stoppedCoreName.isPresent() ? (NUM_SHARDS * NUM_REPLICAS) - 1 : (NUM_SHARDS * NUM_REPLICAS);\n\n    CollectionAdminRequest.CreateSnapshot createSnap = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName);\n    createSnap.process(solrClient);\n\n    Collection<CollectionSnapshotMetaData> collectionSnaps = listCollectionSnapshots(solrClient, collectionName);\n    assertEquals(1, collectionSnaps.size());\n    CollectionSnapshotMetaData meta = collectionSnaps.iterator().next();\n    assertEquals(commitName, meta.getName());\n    assertEquals(CollectionSnapshotMetaData.SnapshotStatus.Successful, meta.getStatus());\n    assertEquals(expectedCoresWithSnapshot, meta.getReplicaSnapshots().size());\n    Map<String, CoreSnapshotMetaData> snapshotByCoreName = meta.getReplicaSnapshots().stream()\n        .collect(Collectors.toMap(CoreSnapshotMetaData::getCoreName, Function.identity()));\n\n    DocCollection collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(2, collectionState.getActiveSlices().size());\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      assertEquals(2, shard.getReplicas().size());\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot is not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        assertTrue(snapshotByCoreName.containsKey(coreName));\n        CoreSnapshotMetaData coreSnapshot = snapshotByCoreName.get(coreName);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertTrue(\"Snapshot not created for core \" + coreName, metaData.isPresent());\n          assertEquals(coreSnapshot.getIndexDirPath(), metaData.get().getIndexDirPath());\n          assertEquals(coreSnapshot.getGenerationNumber(), metaData.get().getGenerationNumber());\n        }\n      }\n    }\n\n    // Delete all documents.\n    {\n      solrClient.deleteByQuery(collectionName, \"*:*\");\n      solrClient.commit(collectionName);\n      BackupRestoreUtils.verifyDocs(0, solrClient, collectionName);\n    }\n\n    String backupLocation = createTempDir().toFile().getAbsolutePath();\n    String backupName = \"mytestbackup\";\n    String restoreCollectionName = collectionName + \"_restored\";\n\n    //Create a backup using the earlier created snapshot.\n    {\n      CollectionAdminRequest.Backup backup = CollectionAdminRequest.backupCollection(collectionName, backupName)\n          .setLocation(backupLocation).setCommitName(commitName);\n      if (random().nextBoolean()) {\n        assertEquals(0, backup.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, backup.processAndWait(solrClient, 30));//async\n      }\n    }\n\n    // Restore backup.\n    {\n      CollectionAdminRequest.Restore restore = CollectionAdminRequest.restoreCollection(restoreCollectionName, backupName)\n          .setLocation(backupLocation);\n      if (replicaFailures) {\n        // In this case one of the Solr servers would be down. Hence we need to increase\n        // max_shards_per_node property for restore command to succeed.\n        restore.setMaxShardsPerNode(2);\n      }\n      if (random().nextBoolean()) {\n        assertEquals(0, restore.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, restore.processAndWait(solrClient, 30));//async\n      }\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(\n          restoreCollectionName, cluster.getSolrClient().getZkStateReader(), log.isDebugEnabled(), true, 30);\n      BackupRestoreUtils.verifyDocs(nDocs, solrClient, restoreCollectionName);\n    }\n\n    // Verify if the snapshot deletion works correctly when one or more replicas containing the snapshot are\n    // deleted\n    boolean replicaDeletion = rarely();\n    if (replicaDeletion) {\n      CoreSnapshotMetaData replicaToDelete = null;\n      for (String shardId : meta.getShards()) {\n        List<CoreSnapshotMetaData> replicas = meta.getReplicaSnapshotsForShard(shardId);\n        if (replicas.size() > 1) {\n          int r_index = random().nextInt(replicas.size());\n          replicaToDelete = replicas.get(r_index);\n        }\n      }\n\n      if (replicaToDelete != null) {\n        collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n        for (Slice s : collectionState.getSlices()) {\n          for (Replica r : s.getReplicas()) {\n            if (r.getCoreName().equals(replicaToDelete.getCoreName())) {\n              log.info(\"Deleting replica {}\", r);\n              CollectionAdminRequest.DeleteReplica delReplica = CollectionAdminRequest.deleteReplica(collectionName,\n                  replicaToDelete.getShardId(), r.getName());\n              delReplica.process(solrClient);\n              // The replica deletion will cleanup the snapshot meta-data.\n              snapshotByCoreName.remove(r.getCoreName());\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // Delete snapshot\n    CollectionAdminRequest.DeleteSnapshot deleteSnap = new CollectionAdminRequest.DeleteSnapshot(collectionName, commitName);\n    deleteSnap.process(solrClient);\n\n    // Wait for a while so that the clusterstate.json updates are propagated to the client side.\n    Thread.sleep(2000);\n    collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot was not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertFalse(\"Snapshot not deleted for core \" + coreName, metaData.isPresent());\n          // Remove the entry for core if the snapshot is deleted successfully.\n          snapshotByCoreName.remove(coreName);\n        }\n      }\n    }\n\n    // Verify all core-level snapshots are deleted.\n    assertTrue(\"The cores remaining \" + snapshotByCoreName, snapshotByCoreName.isEmpty());\n    assertTrue(listCollectionSnapshots(solrClient, collectionName).isEmpty());\n\n    // Verify if the collection deletion result in proper cleanup of snapshot metadata.\n    {\n      String commitName_2 = commitName + \"_2\";\n\n      CollectionAdminRequest.CreateSnapshot createSnap_2 = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName_2);\n      assertEquals(0, createSnap_2.process(solrClient).getStatus());\n\n      Collection<CollectionSnapshotMetaData> collectionSnaps_2 = listCollectionSnapshots(solrClient, collectionName);\n      assertEquals(1, collectionSnaps.size());\n      assertEquals(commitName_2, collectionSnaps_2.iterator().next().getName());\n\n      // Delete collection\n      CollectionAdminRequest.Delete deleteCol = CollectionAdminRequest.deleteCollection(collectionName);\n      assertEquals(0, deleteCol.process(solrClient).getStatus());\n      assertTrue(SolrSnapshotManager.listSnapshots(solrClient.getZkStateReader().getZkClient(), collectionName).isEmpty());\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSnapshots() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String collectionName = \"SolrCloudSnapshots\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, \"conf1\", NUM_SHARDS, NUM_REPLICAS);\n    create.process(solrClient);\n\n    int nDocs = BackupRestoreUtils.indexDocs(cluster.getSolrClient(), collectionName, docsSeed);\n    BackupRestoreUtils.verifyDocs(nDocs, solrClient, collectionName);\n\n    String commitName = TestUtil.randomSimpleString(random(), 1, 5);\n\n    // Verify if snapshot creation works with replica failures.\n    boolean replicaFailures = usually();\n    Optional<String> stoppedCoreName = Optional.empty();\n    if (replicaFailures) {\n      // Here the assumption is that Solr will spread the replicas uniformly across nodes.\n      // If this is not true for some reason, then we will need to add some logic to find a\n      // node with a single replica.\n      this.cluster.getRandomJetty(random()).stop();\n\n      // Sleep a bit for allowing ZK watch to fire.\n      Thread.sleep(5000);\n\n      // Figure out if at-least one replica is \"down\".\n      DocCollection collState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n      for (Slice s : collState.getSlices()) {\n        for (Replica replica : s.getReplicas()) {\n          if (replica.getState() == State.DOWN) {\n            stoppedCoreName = Optional.of(replica.getCoreName());\n          }\n        }\n      }\n    }\n\n    int expectedCoresWithSnapshot = stoppedCoreName.isPresent() ? (NUM_SHARDS * NUM_REPLICAS) - 1 : (NUM_SHARDS * NUM_REPLICAS);\n\n    CollectionAdminRequest.CreateSnapshot createSnap = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName);\n    createSnap.process(solrClient);\n\n    Collection<CollectionSnapshotMetaData> collectionSnaps = listCollectionSnapshots(solrClient, collectionName);\n    assertEquals(1, collectionSnaps.size());\n    CollectionSnapshotMetaData meta = collectionSnaps.iterator().next();\n    assertEquals(commitName, meta.getName());\n    assertEquals(CollectionSnapshotMetaData.SnapshotStatus.Successful, meta.getStatus());\n    assertEquals(expectedCoresWithSnapshot, meta.getReplicaSnapshots().size());\n    Map<String, CoreSnapshotMetaData> snapshotByCoreName = meta.getReplicaSnapshots().stream()\n        .collect(Collectors.toMap(CoreSnapshotMetaData::getCoreName, Function.identity()));\n\n    DocCollection collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(2, collectionState.getActiveSlices().size());\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      assertEquals(2, shard.getReplicas().size());\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot is not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        assertTrue(snapshotByCoreName.containsKey(coreName));\n        CoreSnapshotMetaData coreSnapshot = snapshotByCoreName.get(coreName);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertTrue(\"Snapshot not created for core \" + coreName, metaData.isPresent());\n          assertEquals(coreSnapshot.getIndexDirPath(), metaData.get().getIndexDirPath());\n          assertEquals(coreSnapshot.getGenerationNumber(), metaData.get().getGenerationNumber());\n        }\n      }\n    }\n\n    // Delete all documents.\n    {\n      solrClient.deleteByQuery(collectionName, \"*:*\");\n      solrClient.commit(collectionName);\n      BackupRestoreUtils.verifyDocs(0, solrClient, collectionName);\n    }\n\n    String backupLocation = createTempDir().toFile().getAbsolutePath();\n    String backupName = \"mytestbackup\";\n    String restoreCollectionName = collectionName + \"_restored\";\n\n    //Create a backup using the earlier created snapshot.\n    {\n      CollectionAdminRequest.Backup backup = CollectionAdminRequest.backupCollection(collectionName, backupName)\n          .setLocation(backupLocation).setCommitName(commitName);\n      if (random().nextBoolean()) {\n        assertEquals(0, backup.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, backup.processAndWait(solrClient, 30));//async\n      }\n    }\n\n    // Restore backup.\n    {\n      CollectionAdminRequest.Restore restore = CollectionAdminRequest.restoreCollection(restoreCollectionName, backupName)\n          .setLocation(backupLocation);\n      if (random().nextBoolean()) {\n        assertEquals(0, restore.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, restore.processAndWait(solrClient, 30));//async\n      }\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(\n          restoreCollectionName, cluster.getSolrClient().getZkStateReader(), log.isDebugEnabled(), true, 30);\n      BackupRestoreUtils.verifyDocs(nDocs, solrClient, restoreCollectionName);\n    }\n\n    // Verify if the snapshot deletion works correctly when one or more replicas containing the snapshot are\n    // deleted\n    boolean replicaDeletion = rarely();\n    if (replicaDeletion) {\n      CoreSnapshotMetaData replicaToDelete = null;\n      for (String shardId : meta.getShards()) {\n        List<CoreSnapshotMetaData> replicas = meta.getReplicaSnapshotsForShard(shardId);\n        if (replicas.size() > 1) {\n          int r_index = random().nextInt(replicas.size());\n          replicaToDelete = replicas.get(r_index);\n        }\n      }\n\n      if (replicaToDelete != null) {\n        collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n        for (Slice s : collectionState.getSlices()) {\n          for (Replica r : s.getReplicas()) {\n            if (r.getCoreName().equals(replicaToDelete.getCoreName())) {\n              log.info(\"Deleting replica {}\", r);\n              CollectionAdminRequest.DeleteReplica delReplica = CollectionAdminRequest.deleteReplica(collectionName,\n                  replicaToDelete.getShardId(), r.getName());\n              delReplica.process(solrClient);\n              // The replica deletion will cleanup the snapshot meta-data.\n              snapshotByCoreName.remove(r.getCoreName());\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // Delete snapshot\n    CollectionAdminRequest.DeleteSnapshot deleteSnap = new CollectionAdminRequest.DeleteSnapshot(collectionName, commitName);\n    deleteSnap.process(solrClient);\n\n    // Wait for a while so that the clusterstate.json updates are propagated to the client side.\n    Thread.sleep(2000);\n    collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot was not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertFalse(\"Snapshot not deleted for core \" + coreName, metaData.isPresent());\n          // Remove the entry for core if the snapshot is deleted successfully.\n          snapshotByCoreName.remove(coreName);\n        }\n      }\n    }\n\n    // Verify all core-level snapshots are deleted.\n    assertTrue(\"The cores remaining \" + snapshotByCoreName, snapshotByCoreName.isEmpty());\n    assertTrue(listCollectionSnapshots(solrClient, collectionName).isEmpty());\n\n    // Verify if the collection deletion result in proper cleanup of snapshot metadata.\n    {\n      String commitName_2 = commitName + \"_2\";\n\n      CollectionAdminRequest.CreateSnapshot createSnap_2 = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName_2);\n      assertEquals(0, createSnap_2.process(solrClient).getStatus());\n\n      Collection<CollectionSnapshotMetaData> collectionSnaps_2 = listCollectionSnapshots(solrClient, collectionName);\n      assertEquals(1, collectionSnaps.size());\n      assertEquals(commitName_2, collectionSnaps_2.iterator().next().getName());\n\n      // Delete collection\n      CollectionAdminRequest.Delete deleteCol = CollectionAdminRequest.deleteCollection(collectionName);\n      assertEquals(0, deleteCol.process(solrClient).getStatus());\n      assertTrue(SolrSnapshotManager.listSnapshots(solrClient.getZkStateReader().getZkClient(), collectionName).isEmpty());\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b31ebc7a867ddea79d438a8fca876a94e644d11a","date":1494496172,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/core/snapshots/TestSolrCloudSnapshots#testSnapshots().mjava","pathOld":"solr/core/src/test/org/apache/solr/core/snapshots/TestSolrCloudSnapshots#testSnapshots().mjava","sourceNew":"  @Test\n  public void testSnapshots() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String collectionName = \"SolrCloudSnapshots\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, \"conf1\", NUM_SHARDS, NUM_REPLICAS);\n    create.process(solrClient);\n\n    int nDocs = BackupRestoreUtils.indexDocs(cluster.getSolrClient(), collectionName, docsSeed);\n    BackupRestoreUtils.verifyDocs(nDocs, solrClient, collectionName);\n\n    String commitName = TestUtil.randomSimpleString(random(), 1, 5);\n\n    // Verify if snapshot creation works with replica failures.\n    boolean replicaFailures = usually();\n    Optional<String> stoppedCoreName = Optional.empty();\n    if (replicaFailures) {\n      // Here the assumption is that Solr will spread the replicas uniformly across nodes.\n      // If this is not true for some reason, then we will need to add some logic to find a\n      // node with a single replica.\n      this.cluster.getRandomJetty(random()).stop();\n\n      // Sleep a bit for allowing ZK watch to fire.\n      Thread.sleep(5000);\n\n      // Figure out if at-least one replica is \"down\".\n      DocCollection collState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n      for (Slice s : collState.getSlices()) {\n        for (Replica replica : s.getReplicas()) {\n          if (replica.getState() == State.DOWN) {\n            stoppedCoreName = Optional.of(replica.getCoreName());\n          }\n        }\n      }\n    }\n\n    int expectedCoresWithSnapshot = stoppedCoreName.isPresent() ? (NUM_SHARDS * NUM_REPLICAS) - 1 : (NUM_SHARDS * NUM_REPLICAS);\n\n    CollectionAdminRequest.CreateSnapshot createSnap = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName);\n    createSnap.process(solrClient);\n\n    Collection<CollectionSnapshotMetaData> collectionSnaps = listCollectionSnapshots(solrClient, collectionName);\n    assertEquals(1, collectionSnaps.size());\n    CollectionSnapshotMetaData meta = collectionSnaps.iterator().next();\n    assertEquals(commitName, meta.getName());\n    assertEquals(CollectionSnapshotMetaData.SnapshotStatus.Successful, meta.getStatus());\n    assertEquals(expectedCoresWithSnapshot, meta.getReplicaSnapshots().size());\n    Map<String, CoreSnapshotMetaData> snapshotByCoreName = meta.getReplicaSnapshots().stream()\n        .collect(Collectors.toMap(CoreSnapshotMetaData::getCoreName, Function.identity()));\n\n    DocCollection collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(2, collectionState.getActiveSlices().size());\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      assertEquals(2, shard.getReplicas().size());\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot is not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        assertTrue(snapshotByCoreName.containsKey(coreName));\n        CoreSnapshotMetaData coreSnapshot = snapshotByCoreName.get(coreName);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertTrue(\"Snapshot not created for core \" + coreName, metaData.isPresent());\n          assertEquals(coreSnapshot.getIndexDirPath(), metaData.get().getIndexDirPath());\n          assertEquals(coreSnapshot.getGenerationNumber(), metaData.get().getGenerationNumber());\n        }\n      }\n    }\n\n    // Delete all documents.\n    {\n      solrClient.deleteByQuery(collectionName, \"*:*\");\n      solrClient.commit(collectionName);\n      BackupRestoreUtils.verifyDocs(0, solrClient, collectionName);\n    }\n\n    String backupLocation = createTempDir().toFile().getAbsolutePath();\n    String backupName = \"mytestbackup\";\n    String restoreCollectionName = collectionName + \"_restored\";\n\n    //Create a backup using the earlier created snapshot.\n    {\n      CollectionAdminRequest.Backup backup = CollectionAdminRequest.backupCollection(collectionName, backupName)\n          .setLocation(backupLocation).setCommitName(commitName);\n      if (random().nextBoolean()) {\n        assertEquals(0, backup.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, backup.processAndWait(solrClient, 30));//async\n      }\n    }\n\n    // Restore backup.\n    {\n      CollectionAdminRequest.Restore restore = CollectionAdminRequest.restoreCollection(restoreCollectionName, backupName)\n          .setLocation(backupLocation);\n      if (replicaFailures) {\n        // In this case one of the Solr servers would be down. Hence we need to increase\n        // max_shards_per_node property for restore command to succeed.\n        restore.setMaxShardsPerNode(2);\n      }\n      if (random().nextBoolean()) {\n        assertEquals(0, restore.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, restore.processAndWait(solrClient, 30));//async\n      }\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(\n          restoreCollectionName, cluster.getSolrClient().getZkStateReader(), log.isDebugEnabled(), true, 30);\n      BackupRestoreUtils.verifyDocs(nDocs, solrClient, restoreCollectionName);\n    }\n\n    // Verify if the snapshot deletion works correctly when one or more replicas containing the snapshot are\n    // deleted\n    boolean replicaDeletion = rarely();\n    if (replicaDeletion) {\n      CoreSnapshotMetaData replicaToDelete = null;\n      for (String shardId : meta.getShards()) {\n        List<CoreSnapshotMetaData> replicas = meta.getReplicaSnapshotsForShard(shardId);\n        if (replicas.size() > 1) {\n          int r_index = random().nextInt(replicas.size());\n          replicaToDelete = replicas.get(r_index);\n        }\n      }\n\n      if (replicaToDelete != null) {\n        collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n        for (Slice s : collectionState.getSlices()) {\n          for (Replica r : s.getReplicas()) {\n            if (r.getCoreName().equals(replicaToDelete.getCoreName())) {\n              log.info(\"Deleting replica {}\", r);\n              CollectionAdminRequest.DeleteReplica delReplica = CollectionAdminRequest.deleteReplica(collectionName,\n                  replicaToDelete.getShardId(), r.getName());\n              delReplica.process(solrClient);\n              // The replica deletion will cleanup the snapshot meta-data.\n              snapshotByCoreName.remove(r.getCoreName());\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // Delete snapshot\n    CollectionAdminRequest.DeleteSnapshot deleteSnap = new CollectionAdminRequest.DeleteSnapshot(collectionName, commitName);\n    deleteSnap.process(solrClient);\n\n    // Wait for a while so that the clusterstate.json updates are propagated to the client side.\n    Thread.sleep(2000);\n    collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot was not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertFalse(\"Snapshot not deleted for core \" + coreName, metaData.isPresent());\n          // Remove the entry for core if the snapshot is deleted successfully.\n          snapshotByCoreName.remove(coreName);\n        }\n      }\n    }\n\n    // Verify all core-level snapshots are deleted.\n    assertTrue(\"The cores remaining \" + snapshotByCoreName, snapshotByCoreName.isEmpty());\n    assertTrue(listCollectionSnapshots(solrClient, collectionName).isEmpty());\n\n    // Verify if the collection deletion result in proper cleanup of snapshot metadata.\n    {\n      String commitName_2 = commitName + \"_2\";\n\n      CollectionAdminRequest.CreateSnapshot createSnap_2 = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName_2);\n      assertEquals(0, createSnap_2.process(solrClient).getStatus());\n\n      Collection<CollectionSnapshotMetaData> collectionSnaps_2 = listCollectionSnapshots(solrClient, collectionName);\n      assertEquals(1, collectionSnaps.size());\n      assertEquals(commitName_2, collectionSnaps_2.iterator().next().getName());\n\n      // Delete collection\n      CollectionAdminRequest.Delete deleteCol = CollectionAdminRequest.deleteCollection(collectionName);\n      assertEquals(0, deleteCol.process(solrClient).getStatus());\n      assertTrue(SolrSnapshotManager.listSnapshots(solrClient.getZkStateReader().getZkClient(), collectionName).isEmpty());\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSnapshots() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String collectionName = \"SolrCloudSnapshots\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, \"conf1\", NUM_SHARDS, NUM_REPLICAS);\n    create.process(solrClient);\n\n    int nDocs = BackupRestoreUtils.indexDocs(cluster.getSolrClient(), collectionName, docsSeed);\n    BackupRestoreUtils.verifyDocs(nDocs, solrClient, collectionName);\n\n    String commitName = TestUtil.randomSimpleString(random(), 1, 5);\n\n    // Verify if snapshot creation works with replica failures.\n    boolean replicaFailures = usually();\n    Optional<String> stoppedCoreName = Optional.empty();\n    if (replicaFailures) {\n      // Here the assumption is that Solr will spread the replicas uniformly across nodes.\n      // If this is not true for some reason, then we will need to add some logic to find a\n      // node with a single replica.\n      this.cluster.getRandomJetty(random()).stop();\n\n      // Sleep a bit for allowing ZK watch to fire.\n      Thread.sleep(5000);\n\n      // Figure out if at-least one replica is \"down\".\n      DocCollection collState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n      for (Slice s : collState.getSlices()) {\n        for (Replica replica : s.getReplicas()) {\n          if (replica.getState() == State.DOWN) {\n            stoppedCoreName = Optional.of(replica.getCoreName());\n          }\n        }\n      }\n    }\n\n    int expectedCoresWithSnapshot = stoppedCoreName.isPresent() ? (NUM_SHARDS * NUM_REPLICAS) - 1 : (NUM_SHARDS * NUM_REPLICAS);\n\n    CollectionAdminRequest.CreateSnapshot createSnap = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName);\n    createSnap.process(solrClient);\n\n    Collection<CollectionSnapshotMetaData> collectionSnaps = listCollectionSnapshots(solrClient, collectionName);\n    assertEquals(1, collectionSnaps.size());\n    CollectionSnapshotMetaData meta = collectionSnaps.iterator().next();\n    assertEquals(commitName, meta.getName());\n    assertEquals(CollectionSnapshotMetaData.SnapshotStatus.Successful, meta.getStatus());\n    assertEquals(expectedCoresWithSnapshot, meta.getReplicaSnapshots().size());\n    Map<String, CoreSnapshotMetaData> snapshotByCoreName = meta.getReplicaSnapshots().stream()\n        .collect(Collectors.toMap(CoreSnapshotMetaData::getCoreName, Function.identity()));\n\n    DocCollection collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(2, collectionState.getActiveSlices().size());\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      assertEquals(2, shard.getReplicas().size());\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot is not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        assertTrue(snapshotByCoreName.containsKey(coreName));\n        CoreSnapshotMetaData coreSnapshot = snapshotByCoreName.get(coreName);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertTrue(\"Snapshot not created for core \" + coreName, metaData.isPresent());\n          assertEquals(coreSnapshot.getIndexDirPath(), metaData.get().getIndexDirPath());\n          assertEquals(coreSnapshot.getGenerationNumber(), metaData.get().getGenerationNumber());\n        }\n      }\n    }\n\n    // Delete all documents.\n    {\n      solrClient.deleteByQuery(collectionName, \"*:*\");\n      solrClient.commit(collectionName);\n      BackupRestoreUtils.verifyDocs(0, solrClient, collectionName);\n    }\n\n    String backupLocation = createTempDir().toFile().getAbsolutePath();\n    String backupName = \"mytestbackup\";\n    String restoreCollectionName = collectionName + \"_restored\";\n\n    //Create a backup using the earlier created snapshot.\n    {\n      CollectionAdminRequest.Backup backup = CollectionAdminRequest.backupCollection(collectionName, backupName)\n          .setLocation(backupLocation).setCommitName(commitName);\n      if (random().nextBoolean()) {\n        assertEquals(0, backup.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, backup.processAndWait(solrClient, 30));//async\n      }\n    }\n\n    // Restore backup.\n    {\n      CollectionAdminRequest.Restore restore = CollectionAdminRequest.restoreCollection(restoreCollectionName, backupName)\n          .setLocation(backupLocation);\n      if (random().nextBoolean()) {\n        assertEquals(0, restore.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, restore.processAndWait(solrClient, 30));//async\n      }\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(\n          restoreCollectionName, cluster.getSolrClient().getZkStateReader(), log.isDebugEnabled(), true, 30);\n      BackupRestoreUtils.verifyDocs(nDocs, solrClient, restoreCollectionName);\n    }\n\n    // Verify if the snapshot deletion works correctly when one or more replicas containing the snapshot are\n    // deleted\n    boolean replicaDeletion = rarely();\n    if (replicaDeletion) {\n      CoreSnapshotMetaData replicaToDelete = null;\n      for (String shardId : meta.getShards()) {\n        List<CoreSnapshotMetaData> replicas = meta.getReplicaSnapshotsForShard(shardId);\n        if (replicas.size() > 1) {\n          int r_index = random().nextInt(replicas.size());\n          replicaToDelete = replicas.get(r_index);\n        }\n      }\n\n      if (replicaToDelete != null) {\n        collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n        for (Slice s : collectionState.getSlices()) {\n          for (Replica r : s.getReplicas()) {\n            if (r.getCoreName().equals(replicaToDelete.getCoreName())) {\n              log.info(\"Deleting replica {}\", r);\n              CollectionAdminRequest.DeleteReplica delReplica = CollectionAdminRequest.deleteReplica(collectionName,\n                  replicaToDelete.getShardId(), r.getName());\n              delReplica.process(solrClient);\n              // The replica deletion will cleanup the snapshot meta-data.\n              snapshotByCoreName.remove(r.getCoreName());\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // Delete snapshot\n    CollectionAdminRequest.DeleteSnapshot deleteSnap = new CollectionAdminRequest.DeleteSnapshot(collectionName, commitName);\n    deleteSnap.process(solrClient);\n\n    // Wait for a while so that the clusterstate.json updates are propagated to the client side.\n    Thread.sleep(2000);\n    collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot was not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertFalse(\"Snapshot not deleted for core \" + coreName, metaData.isPresent());\n          // Remove the entry for core if the snapshot is deleted successfully.\n          snapshotByCoreName.remove(coreName);\n        }\n      }\n    }\n\n    // Verify all core-level snapshots are deleted.\n    assertTrue(\"The cores remaining \" + snapshotByCoreName, snapshotByCoreName.isEmpty());\n    assertTrue(listCollectionSnapshots(solrClient, collectionName).isEmpty());\n\n    // Verify if the collection deletion result in proper cleanup of snapshot metadata.\n    {\n      String commitName_2 = commitName + \"_2\";\n\n      CollectionAdminRequest.CreateSnapshot createSnap_2 = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName_2);\n      assertEquals(0, createSnap_2.process(solrClient).getStatus());\n\n      Collection<CollectionSnapshotMetaData> collectionSnaps_2 = listCollectionSnapshots(solrClient, collectionName);\n      assertEquals(1, collectionSnaps.size());\n      assertEquals(commitName_2, collectionSnaps_2.iterator().next().getName());\n\n      // Delete collection\n      CollectionAdminRequest.Delete deleteCol = CollectionAdminRequest.deleteCollection(collectionName);\n      assertEquals(0, deleteCol.process(solrClient).getStatus());\n      assertTrue(SolrSnapshotManager.listSnapshots(solrClient.getZkStateReader().getZkClient(), collectionName).isEmpty());\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/core/snapshots/TestSolrCloudSnapshots#testSnapshots().mjava","pathOld":"solr/core/src/test/org/apache/solr/core/snapshots/TestSolrCloudSnapshots#testSnapshots().mjava","sourceNew":"  @Test\n  public void testSnapshots() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String collectionName = \"SolrCloudSnapshots\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, \"conf1\", NUM_SHARDS, NUM_REPLICAS);\n    create.process(solrClient);\n\n    int nDocs = BackupRestoreUtils.indexDocs(cluster.getSolrClient(), collectionName, docsSeed);\n    BackupRestoreUtils.verifyDocs(nDocs, solrClient, collectionName);\n\n    String commitName = TestUtil.randomSimpleString(random(), 1, 5);\n\n    // Verify if snapshot creation works with replica failures.\n    boolean replicaFailures = usually();\n    Optional<String> stoppedCoreName = Optional.empty();\n    if (replicaFailures) {\n      // Here the assumption is that Solr will spread the replicas uniformly across nodes.\n      // If this is not true for some reason, then we will need to add some logic to find a\n      // node with a single replica.\n      this.cluster.getRandomJetty(random()).stop();\n\n      // Sleep a bit for allowing ZK watch to fire.\n      Thread.sleep(5000);\n\n      // Figure out if at-least one replica is \"down\".\n      DocCollection collState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n      for (Slice s : collState.getSlices()) {\n        for (Replica replica : s.getReplicas()) {\n          if (replica.getState() == State.DOWN) {\n            stoppedCoreName = Optional.of(replica.getCoreName());\n          }\n        }\n      }\n    }\n\n    int expectedCoresWithSnapshot = stoppedCoreName.isPresent() ? (NUM_SHARDS * NUM_REPLICAS) - 1 : (NUM_SHARDS * NUM_REPLICAS);\n\n    CollectionAdminRequest.CreateSnapshot createSnap = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName);\n    createSnap.process(solrClient);\n\n    Collection<CollectionSnapshotMetaData> collectionSnaps = listCollectionSnapshots(solrClient, collectionName);\n    assertEquals(1, collectionSnaps.size());\n    CollectionSnapshotMetaData meta = collectionSnaps.iterator().next();\n    assertEquals(commitName, meta.getName());\n    assertEquals(CollectionSnapshotMetaData.SnapshotStatus.Successful, meta.getStatus());\n    assertEquals(expectedCoresWithSnapshot, meta.getReplicaSnapshots().size());\n    Map<String, CoreSnapshotMetaData> snapshotByCoreName = meta.getReplicaSnapshots().stream()\n        .collect(Collectors.toMap(CoreSnapshotMetaData::getCoreName, Function.identity()));\n\n    DocCollection collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(2, collectionState.getActiveSlices().size());\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      assertEquals(2, shard.getReplicas().size());\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot is not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        assertTrue(snapshotByCoreName.containsKey(coreName));\n        CoreSnapshotMetaData coreSnapshot = snapshotByCoreName.get(coreName);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertTrue(\"Snapshot not created for core \" + coreName, metaData.isPresent());\n          assertEquals(coreSnapshot.getIndexDirPath(), metaData.get().getIndexDirPath());\n          assertEquals(coreSnapshot.getGenerationNumber(), metaData.get().getGenerationNumber());\n        }\n      }\n    }\n\n    // Delete all documents.\n    {\n      solrClient.deleteByQuery(collectionName, \"*:*\");\n      solrClient.commit(collectionName);\n      BackupRestoreUtils.verifyDocs(0, solrClient, collectionName);\n    }\n\n    String backupLocation = createTempDir().toFile().getAbsolutePath();\n    String backupName = \"mytestbackup\";\n    String restoreCollectionName = collectionName + \"_restored\";\n\n    //Create a backup using the earlier created snapshot.\n    {\n      CollectionAdminRequest.Backup backup = CollectionAdminRequest.backupCollection(collectionName, backupName)\n          .setLocation(backupLocation).setCommitName(commitName);\n      if (random().nextBoolean()) {\n        assertEquals(0, backup.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, backup.processAndWait(solrClient, 30));//async\n      }\n    }\n\n    // Restore backup.\n    {\n      CollectionAdminRequest.Restore restore = CollectionAdminRequest.restoreCollection(restoreCollectionName, backupName)\n          .setLocation(backupLocation);\n      if (replicaFailures) {\n        // In this case one of the Solr servers would be down. Hence we need to increase\n        // max_shards_per_node property for restore command to succeed.\n        restore.setMaxShardsPerNode(2);\n      }\n      if (random().nextBoolean()) {\n        assertEquals(0, restore.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, restore.processAndWait(solrClient, 30));//async\n      }\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(\n          restoreCollectionName, cluster.getSolrClient().getZkStateReader(), log.isDebugEnabled(), true, 30);\n      BackupRestoreUtils.verifyDocs(nDocs, solrClient, restoreCollectionName);\n    }\n\n    // Verify if the snapshot deletion works correctly when one or more replicas containing the snapshot are\n    // deleted\n    boolean replicaDeletion = rarely();\n    if (replicaDeletion) {\n      CoreSnapshotMetaData replicaToDelete = null;\n      for (String shardId : meta.getShards()) {\n        List<CoreSnapshotMetaData> replicas = meta.getReplicaSnapshotsForShard(shardId);\n        if (replicas.size() > 1) {\n          int r_index = random().nextInt(replicas.size());\n          replicaToDelete = replicas.get(r_index);\n        }\n      }\n\n      if (replicaToDelete != null) {\n        collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n        for (Slice s : collectionState.getSlices()) {\n          for (Replica r : s.getReplicas()) {\n            if (r.getCoreName().equals(replicaToDelete.getCoreName())) {\n              log.info(\"Deleting replica {}\", r);\n              CollectionAdminRequest.DeleteReplica delReplica = CollectionAdminRequest.deleteReplica(collectionName,\n                  replicaToDelete.getShardId(), r.getName());\n              delReplica.process(solrClient);\n              // The replica deletion will cleanup the snapshot meta-data.\n              snapshotByCoreName.remove(r.getCoreName());\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // Delete snapshot\n    CollectionAdminRequest.DeleteSnapshot deleteSnap = new CollectionAdminRequest.DeleteSnapshot(collectionName, commitName);\n    deleteSnap.process(solrClient);\n\n    // Wait for a while so that the clusterstate.json updates are propagated to the client side.\n    Thread.sleep(2000);\n    collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot was not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertFalse(\"Snapshot not deleted for core \" + coreName, metaData.isPresent());\n          // Remove the entry for core if the snapshot is deleted successfully.\n          snapshotByCoreName.remove(coreName);\n        }\n      }\n    }\n\n    // Verify all core-level snapshots are deleted.\n    assertTrue(\"The cores remaining \" + snapshotByCoreName, snapshotByCoreName.isEmpty());\n    assertTrue(listCollectionSnapshots(solrClient, collectionName).isEmpty());\n\n    // Verify if the collection deletion result in proper cleanup of snapshot metadata.\n    {\n      String commitName_2 = commitName + \"_2\";\n\n      CollectionAdminRequest.CreateSnapshot createSnap_2 = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName_2);\n      assertEquals(0, createSnap_2.process(solrClient).getStatus());\n\n      Collection<CollectionSnapshotMetaData> collectionSnaps_2 = listCollectionSnapshots(solrClient, collectionName);\n      assertEquals(1, collectionSnaps.size());\n      assertEquals(commitName_2, collectionSnaps_2.iterator().next().getName());\n\n      // Delete collection\n      CollectionAdminRequest.Delete deleteCol = CollectionAdminRequest.deleteCollection(collectionName);\n      assertEquals(0, deleteCol.process(solrClient).getStatus());\n      assertTrue(SolrSnapshotManager.listSnapshots(solrClient.getZkStateReader().getZkClient(), collectionName).isEmpty());\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSnapshots() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String collectionName = \"SolrCloudSnapshots\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, \"conf1\", NUM_SHARDS, NUM_REPLICAS);\n    create.process(solrClient);\n\n    int nDocs = BackupRestoreUtils.indexDocs(cluster.getSolrClient(), collectionName, docsSeed);\n    BackupRestoreUtils.verifyDocs(nDocs, solrClient, collectionName);\n\n    String commitName = TestUtil.randomSimpleString(random(), 1, 5);\n\n    // Verify if snapshot creation works with replica failures.\n    boolean replicaFailures = usually();\n    Optional<String> stoppedCoreName = Optional.empty();\n    if (replicaFailures) {\n      // Here the assumption is that Solr will spread the replicas uniformly across nodes.\n      // If this is not true for some reason, then we will need to add some logic to find a\n      // node with a single replica.\n      this.cluster.getRandomJetty(random()).stop();\n\n      // Sleep a bit for allowing ZK watch to fire.\n      Thread.sleep(5000);\n\n      // Figure out if at-least one replica is \"down\".\n      DocCollection collState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n      for (Slice s : collState.getSlices()) {\n        for (Replica replica : s.getReplicas()) {\n          if (replica.getState() == State.DOWN) {\n            stoppedCoreName = Optional.of(replica.getCoreName());\n          }\n        }\n      }\n    }\n\n    int expectedCoresWithSnapshot = stoppedCoreName.isPresent() ? (NUM_SHARDS * NUM_REPLICAS) - 1 : (NUM_SHARDS * NUM_REPLICAS);\n\n    CollectionAdminRequest.CreateSnapshot createSnap = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName);\n    createSnap.process(solrClient);\n\n    Collection<CollectionSnapshotMetaData> collectionSnaps = listCollectionSnapshots(solrClient, collectionName);\n    assertEquals(1, collectionSnaps.size());\n    CollectionSnapshotMetaData meta = collectionSnaps.iterator().next();\n    assertEquals(commitName, meta.getName());\n    assertEquals(CollectionSnapshotMetaData.SnapshotStatus.Successful, meta.getStatus());\n    assertEquals(expectedCoresWithSnapshot, meta.getReplicaSnapshots().size());\n    Map<String, CoreSnapshotMetaData> snapshotByCoreName = meta.getReplicaSnapshots().stream()\n        .collect(Collectors.toMap(CoreSnapshotMetaData::getCoreName, Function.identity()));\n\n    DocCollection collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(2, collectionState.getActiveSlices().size());\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      assertEquals(2, shard.getReplicas().size());\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot is not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        assertTrue(snapshotByCoreName.containsKey(coreName));\n        CoreSnapshotMetaData coreSnapshot = snapshotByCoreName.get(coreName);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertTrue(\"Snapshot not created for core \" + coreName, metaData.isPresent());\n          assertEquals(coreSnapshot.getIndexDirPath(), metaData.get().getIndexDirPath());\n          assertEquals(coreSnapshot.getGenerationNumber(), metaData.get().getGenerationNumber());\n        }\n      }\n    }\n\n    // Delete all documents.\n    {\n      solrClient.deleteByQuery(collectionName, \"*:*\");\n      solrClient.commit(collectionName);\n      BackupRestoreUtils.verifyDocs(0, solrClient, collectionName);\n    }\n\n    String backupLocation = createTempDir().toFile().getAbsolutePath();\n    String backupName = \"mytestbackup\";\n    String restoreCollectionName = collectionName + \"_restored\";\n\n    //Create a backup using the earlier created snapshot.\n    {\n      CollectionAdminRequest.Backup backup = CollectionAdminRequest.backupCollection(collectionName, backupName)\n          .setLocation(backupLocation).setCommitName(commitName);\n      if (random().nextBoolean()) {\n        assertEquals(0, backup.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, backup.processAndWait(solrClient, 30));//async\n      }\n    }\n\n    // Restore backup.\n    {\n      CollectionAdminRequest.Restore restore = CollectionAdminRequest.restoreCollection(restoreCollectionName, backupName)\n          .setLocation(backupLocation);\n      if (random().nextBoolean()) {\n        assertEquals(0, restore.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, restore.processAndWait(solrClient, 30));//async\n      }\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(\n          restoreCollectionName, cluster.getSolrClient().getZkStateReader(), log.isDebugEnabled(), true, 30);\n      BackupRestoreUtils.verifyDocs(nDocs, solrClient, restoreCollectionName);\n    }\n\n    // Verify if the snapshot deletion works correctly when one or more replicas containing the snapshot are\n    // deleted\n    boolean replicaDeletion = rarely();\n    if (replicaDeletion) {\n      CoreSnapshotMetaData replicaToDelete = null;\n      for (String shardId : meta.getShards()) {\n        List<CoreSnapshotMetaData> replicas = meta.getReplicaSnapshotsForShard(shardId);\n        if (replicas.size() > 1) {\n          int r_index = random().nextInt(replicas.size());\n          replicaToDelete = replicas.get(r_index);\n        }\n      }\n\n      if (replicaToDelete != null) {\n        collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n        for (Slice s : collectionState.getSlices()) {\n          for (Replica r : s.getReplicas()) {\n            if (r.getCoreName().equals(replicaToDelete.getCoreName())) {\n              log.info(\"Deleting replica {}\", r);\n              CollectionAdminRequest.DeleteReplica delReplica = CollectionAdminRequest.deleteReplica(collectionName,\n                  replicaToDelete.getShardId(), r.getName());\n              delReplica.process(solrClient);\n              // The replica deletion will cleanup the snapshot meta-data.\n              snapshotByCoreName.remove(r.getCoreName());\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // Delete snapshot\n    CollectionAdminRequest.DeleteSnapshot deleteSnap = new CollectionAdminRequest.DeleteSnapshot(collectionName, commitName);\n    deleteSnap.process(solrClient);\n\n    // Wait for a while so that the clusterstate.json updates are propagated to the client side.\n    Thread.sleep(2000);\n    collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot was not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertFalse(\"Snapshot not deleted for core \" + coreName, metaData.isPresent());\n          // Remove the entry for core if the snapshot is deleted successfully.\n          snapshotByCoreName.remove(coreName);\n        }\n      }\n    }\n\n    // Verify all core-level snapshots are deleted.\n    assertTrue(\"The cores remaining \" + snapshotByCoreName, snapshotByCoreName.isEmpty());\n    assertTrue(listCollectionSnapshots(solrClient, collectionName).isEmpty());\n\n    // Verify if the collection deletion result in proper cleanup of snapshot metadata.\n    {\n      String commitName_2 = commitName + \"_2\";\n\n      CollectionAdminRequest.CreateSnapshot createSnap_2 = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName_2);\n      assertEquals(0, createSnap_2.process(solrClient).getStatus());\n\n      Collection<CollectionSnapshotMetaData> collectionSnaps_2 = listCollectionSnapshots(solrClient, collectionName);\n      assertEquals(1, collectionSnaps.size());\n      assertEquals(commitName_2, collectionSnaps_2.iterator().next().getName());\n\n      // Delete collection\n      CollectionAdminRequest.Delete deleteCol = CollectionAdminRequest.deleteCollection(collectionName);\n      assertEquals(0, deleteCol.process(solrClient).getStatus());\n      assertTrue(SolrSnapshotManager.listSnapshots(solrClient.getZkStateReader().getZkClient(), collectionName).isEmpty());\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"de3459a54b4c8751d9ef19b035577e2418064be7","date":1520297996,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/core/snapshots/TestSolrCloudSnapshots#testSnapshots().mjava","pathOld":"solr/core/src/test/org/apache/solr/core/snapshots/TestSolrCloudSnapshots#testSnapshots().mjava","sourceNew":"  @Test\n  public void testSnapshots() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String collectionName = \"SolrCloudSnapshots\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, \"conf1\", NUM_SHARDS, NUM_REPLICAS);\n    create.process(solrClient);\n\n    int nDocs = BackupRestoreUtils.indexDocs(cluster.getSolrClient(), collectionName, docsSeed);\n    BackupRestoreUtils.verifyDocs(nDocs, solrClient, collectionName);\n\n    // Set a collection property\n    final boolean collectionPropertySet = usually();\n    if (collectionPropertySet) {\n      CollectionAdminRequest.CollectionProp setProperty = CollectionAdminRequest.setCollectionProperty(collectionName, \"test.property\", \"test.value\");\n      setProperty.process(solrClient);\n    }\n\n    String commitName = TestUtil.randomSimpleString(random(), 1, 5);\n\n    // Verify if snapshot creation works with replica failures.\n    boolean replicaFailures = usually();\n    Optional<String> stoppedCoreName = Optional.empty();\n    if (replicaFailures) {\n      // Here the assumption is that Solr will spread the replicas uniformly across nodes.\n      // If this is not true for some reason, then we will need to add some logic to find a\n      // node with a single replica.\n      this.cluster.getRandomJetty(random()).stop();\n\n      // Sleep a bit for allowing ZK watch to fire.\n      Thread.sleep(5000);\n\n      // Figure out if at-least one replica is \"down\".\n      DocCollection collState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n      for (Slice s : collState.getSlices()) {\n        for (Replica replica : s.getReplicas()) {\n          if (replica.getState() == State.DOWN) {\n            stoppedCoreName = Optional.of(replica.getCoreName());\n          }\n        }\n      }\n    }\n\n    int expectedCoresWithSnapshot = stoppedCoreName.isPresent() ? (NUM_SHARDS * NUM_REPLICAS) - 1 : (NUM_SHARDS * NUM_REPLICAS);\n\n    CollectionAdminRequest.CreateSnapshot createSnap = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName);\n    createSnap.process(solrClient);\n\n    Collection<CollectionSnapshotMetaData> collectionSnaps = listCollectionSnapshots(solrClient, collectionName);\n    assertEquals(1, collectionSnaps.size());\n    CollectionSnapshotMetaData meta = collectionSnaps.iterator().next();\n    assertEquals(commitName, meta.getName());\n    assertEquals(CollectionSnapshotMetaData.SnapshotStatus.Successful, meta.getStatus());\n    assertEquals(expectedCoresWithSnapshot, meta.getReplicaSnapshots().size());\n    Map<String, CoreSnapshotMetaData> snapshotByCoreName = meta.getReplicaSnapshots().stream()\n        .collect(Collectors.toMap(CoreSnapshotMetaData::getCoreName, Function.identity()));\n\n    DocCollection collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(2, collectionState.getActiveSlices().size());\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      assertEquals(2, shard.getReplicas().size());\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot is not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        assertTrue(snapshotByCoreName.containsKey(coreName));\n        CoreSnapshotMetaData coreSnapshot = snapshotByCoreName.get(coreName);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertTrue(\"Snapshot not created for core \" + coreName, metaData.isPresent());\n          assertEquals(coreSnapshot.getIndexDirPath(), metaData.get().getIndexDirPath());\n          assertEquals(coreSnapshot.getGenerationNumber(), metaData.get().getGenerationNumber());\n        }\n      }\n    }\n\n    // Delete all documents.\n    {\n      solrClient.deleteByQuery(collectionName, \"*:*\");\n      solrClient.commit(collectionName);\n      BackupRestoreUtils.verifyDocs(0, solrClient, collectionName);\n    }\n\n    String backupLocation = createTempDir().toFile().getAbsolutePath();\n    String backupName = \"mytestbackup\";\n    String restoreCollectionName = collectionName + \"_restored\";\n\n    //Create a backup using the earlier created snapshot.\n    {\n      CollectionAdminRequest.Backup backup = CollectionAdminRequest.backupCollection(collectionName, backupName)\n          .setLocation(backupLocation).setCommitName(commitName);\n      if (random().nextBoolean()) {\n        assertEquals(0, backup.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, backup.processAndWait(solrClient, 30));//async\n      }\n    }\n\n    // Restore backup.\n    {\n      CollectionAdminRequest.Restore restore = CollectionAdminRequest.restoreCollection(restoreCollectionName, backupName)\n          .setLocation(backupLocation);\n      if (replicaFailures) {\n        // In this case one of the Solr servers would be down. Hence we need to increase\n        // max_shards_per_node property for restore command to succeed.\n        restore.setMaxShardsPerNode(2);\n      }\n      if (random().nextBoolean()) {\n        assertEquals(0, restore.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, restore.processAndWait(solrClient, 30));//async\n      }\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(\n          restoreCollectionName, cluster.getSolrClient().getZkStateReader(), log.isDebugEnabled(), true, 30);\n      BackupRestoreUtils.verifyDocs(nDocs, solrClient, restoreCollectionName);\n    }\n\n    // Check collection property\n    Map<String, String> collectionProperties = solrClient.getZkStateReader().getCollectionProperties(restoreCollectionName);\n    if (collectionPropertySet) {\n      assertEquals(\"Snapshot restore hasn't restored collection properties\", \"test.value\", collectionProperties.get(\"test.property\"));\n    } else {\n      assertNull(\"Collection property shouldn't be present\", collectionProperties.get(\"test.property\"));\n    }\n\n    // Verify if the snapshot deletion works correctly when one or more replicas containing the snapshot are\n    // deleted\n    boolean replicaDeletion = rarely();\n    if (replicaDeletion) {\n      CoreSnapshotMetaData replicaToDelete = null;\n      for (String shardId : meta.getShards()) {\n        List<CoreSnapshotMetaData> replicas = meta.getReplicaSnapshotsForShard(shardId);\n        if (replicas.size() > 1) {\n          int r_index = random().nextInt(replicas.size());\n          replicaToDelete = replicas.get(r_index);\n        }\n      }\n\n      if (replicaToDelete != null) {\n        collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n        for (Slice s : collectionState.getSlices()) {\n          for (Replica r : s.getReplicas()) {\n            if (r.getCoreName().equals(replicaToDelete.getCoreName())) {\n              log.info(\"Deleting replica {}\", r);\n              CollectionAdminRequest.DeleteReplica delReplica = CollectionAdminRequest.deleteReplica(collectionName,\n                  replicaToDelete.getShardId(), r.getName());\n              delReplica.process(solrClient);\n              // The replica deletion will cleanup the snapshot meta-data.\n              snapshotByCoreName.remove(r.getCoreName());\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // Delete snapshot\n    CollectionAdminRequest.DeleteSnapshot deleteSnap = new CollectionAdminRequest.DeleteSnapshot(collectionName, commitName);\n    deleteSnap.process(solrClient);\n\n    // Wait for a while so that the clusterstate.json updates are propagated to the client side.\n    Thread.sleep(2000);\n    collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot was not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertFalse(\"Snapshot not deleted for core \" + coreName, metaData.isPresent());\n          // Remove the entry for core if the snapshot is deleted successfully.\n          snapshotByCoreName.remove(coreName);\n        }\n      }\n    }\n\n    // Verify all core-level snapshots are deleted.\n    assertTrue(\"The cores remaining \" + snapshotByCoreName, snapshotByCoreName.isEmpty());\n    assertTrue(listCollectionSnapshots(solrClient, collectionName).isEmpty());\n\n    // Verify if the collection deletion result in proper cleanup of snapshot metadata.\n    {\n      String commitName_2 = commitName + \"_2\";\n\n      CollectionAdminRequest.CreateSnapshot createSnap_2 = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName_2);\n      assertEquals(0, createSnap_2.process(solrClient).getStatus());\n\n      Collection<CollectionSnapshotMetaData> collectionSnaps_2 = listCollectionSnapshots(solrClient, collectionName);\n      assertEquals(1, collectionSnaps.size());\n      assertEquals(commitName_2, collectionSnaps_2.iterator().next().getName());\n\n      // Delete collection\n      CollectionAdminRequest.Delete deleteCol = CollectionAdminRequest.deleteCollection(collectionName);\n      assertEquals(0, deleteCol.process(solrClient).getStatus());\n      assertTrue(SolrSnapshotManager.listSnapshots(solrClient.getZkStateReader().getZkClient(), collectionName).isEmpty());\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSnapshots() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String collectionName = \"SolrCloudSnapshots\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, \"conf1\", NUM_SHARDS, NUM_REPLICAS);\n    create.process(solrClient);\n\n    int nDocs = BackupRestoreUtils.indexDocs(cluster.getSolrClient(), collectionName, docsSeed);\n    BackupRestoreUtils.verifyDocs(nDocs, solrClient, collectionName);\n\n    String commitName = TestUtil.randomSimpleString(random(), 1, 5);\n\n    // Verify if snapshot creation works with replica failures.\n    boolean replicaFailures = usually();\n    Optional<String> stoppedCoreName = Optional.empty();\n    if (replicaFailures) {\n      // Here the assumption is that Solr will spread the replicas uniformly across nodes.\n      // If this is not true for some reason, then we will need to add some logic to find a\n      // node with a single replica.\n      this.cluster.getRandomJetty(random()).stop();\n\n      // Sleep a bit for allowing ZK watch to fire.\n      Thread.sleep(5000);\n\n      // Figure out if at-least one replica is \"down\".\n      DocCollection collState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n      for (Slice s : collState.getSlices()) {\n        for (Replica replica : s.getReplicas()) {\n          if (replica.getState() == State.DOWN) {\n            stoppedCoreName = Optional.of(replica.getCoreName());\n          }\n        }\n      }\n    }\n\n    int expectedCoresWithSnapshot = stoppedCoreName.isPresent() ? (NUM_SHARDS * NUM_REPLICAS) - 1 : (NUM_SHARDS * NUM_REPLICAS);\n\n    CollectionAdminRequest.CreateSnapshot createSnap = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName);\n    createSnap.process(solrClient);\n\n    Collection<CollectionSnapshotMetaData> collectionSnaps = listCollectionSnapshots(solrClient, collectionName);\n    assertEquals(1, collectionSnaps.size());\n    CollectionSnapshotMetaData meta = collectionSnaps.iterator().next();\n    assertEquals(commitName, meta.getName());\n    assertEquals(CollectionSnapshotMetaData.SnapshotStatus.Successful, meta.getStatus());\n    assertEquals(expectedCoresWithSnapshot, meta.getReplicaSnapshots().size());\n    Map<String, CoreSnapshotMetaData> snapshotByCoreName = meta.getReplicaSnapshots().stream()\n        .collect(Collectors.toMap(CoreSnapshotMetaData::getCoreName, Function.identity()));\n\n    DocCollection collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(2, collectionState.getActiveSlices().size());\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      assertEquals(2, shard.getReplicas().size());\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot is not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        assertTrue(snapshotByCoreName.containsKey(coreName));\n        CoreSnapshotMetaData coreSnapshot = snapshotByCoreName.get(coreName);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertTrue(\"Snapshot not created for core \" + coreName, metaData.isPresent());\n          assertEquals(coreSnapshot.getIndexDirPath(), metaData.get().getIndexDirPath());\n          assertEquals(coreSnapshot.getGenerationNumber(), metaData.get().getGenerationNumber());\n        }\n      }\n    }\n\n    // Delete all documents.\n    {\n      solrClient.deleteByQuery(collectionName, \"*:*\");\n      solrClient.commit(collectionName);\n      BackupRestoreUtils.verifyDocs(0, solrClient, collectionName);\n    }\n\n    String backupLocation = createTempDir().toFile().getAbsolutePath();\n    String backupName = \"mytestbackup\";\n    String restoreCollectionName = collectionName + \"_restored\";\n\n    //Create a backup using the earlier created snapshot.\n    {\n      CollectionAdminRequest.Backup backup = CollectionAdminRequest.backupCollection(collectionName, backupName)\n          .setLocation(backupLocation).setCommitName(commitName);\n      if (random().nextBoolean()) {\n        assertEquals(0, backup.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, backup.processAndWait(solrClient, 30));//async\n      }\n    }\n\n    // Restore backup.\n    {\n      CollectionAdminRequest.Restore restore = CollectionAdminRequest.restoreCollection(restoreCollectionName, backupName)\n          .setLocation(backupLocation);\n      if (replicaFailures) {\n        // In this case one of the Solr servers would be down. Hence we need to increase\n        // max_shards_per_node property for restore command to succeed.\n        restore.setMaxShardsPerNode(2);\n      }\n      if (random().nextBoolean()) {\n        assertEquals(0, restore.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, restore.processAndWait(solrClient, 30));//async\n      }\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(\n          restoreCollectionName, cluster.getSolrClient().getZkStateReader(), log.isDebugEnabled(), true, 30);\n      BackupRestoreUtils.verifyDocs(nDocs, solrClient, restoreCollectionName);\n    }\n\n    // Verify if the snapshot deletion works correctly when one or more replicas containing the snapshot are\n    // deleted\n    boolean replicaDeletion = rarely();\n    if (replicaDeletion) {\n      CoreSnapshotMetaData replicaToDelete = null;\n      for (String shardId : meta.getShards()) {\n        List<CoreSnapshotMetaData> replicas = meta.getReplicaSnapshotsForShard(shardId);\n        if (replicas.size() > 1) {\n          int r_index = random().nextInt(replicas.size());\n          replicaToDelete = replicas.get(r_index);\n        }\n      }\n\n      if (replicaToDelete != null) {\n        collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n        for (Slice s : collectionState.getSlices()) {\n          for (Replica r : s.getReplicas()) {\n            if (r.getCoreName().equals(replicaToDelete.getCoreName())) {\n              log.info(\"Deleting replica {}\", r);\n              CollectionAdminRequest.DeleteReplica delReplica = CollectionAdminRequest.deleteReplica(collectionName,\n                  replicaToDelete.getShardId(), r.getName());\n              delReplica.process(solrClient);\n              // The replica deletion will cleanup the snapshot meta-data.\n              snapshotByCoreName.remove(r.getCoreName());\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // Delete snapshot\n    CollectionAdminRequest.DeleteSnapshot deleteSnap = new CollectionAdminRequest.DeleteSnapshot(collectionName, commitName);\n    deleteSnap.process(solrClient);\n\n    // Wait for a while so that the clusterstate.json updates are propagated to the client side.\n    Thread.sleep(2000);\n    collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot was not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertFalse(\"Snapshot not deleted for core \" + coreName, metaData.isPresent());\n          // Remove the entry for core if the snapshot is deleted successfully.\n          snapshotByCoreName.remove(coreName);\n        }\n      }\n    }\n\n    // Verify all core-level snapshots are deleted.\n    assertTrue(\"The cores remaining \" + snapshotByCoreName, snapshotByCoreName.isEmpty());\n    assertTrue(listCollectionSnapshots(solrClient, collectionName).isEmpty());\n\n    // Verify if the collection deletion result in proper cleanup of snapshot metadata.\n    {\n      String commitName_2 = commitName + \"_2\";\n\n      CollectionAdminRequest.CreateSnapshot createSnap_2 = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName_2);\n      assertEquals(0, createSnap_2.process(solrClient).getStatus());\n\n      Collection<CollectionSnapshotMetaData> collectionSnaps_2 = listCollectionSnapshots(solrClient, collectionName);\n      assertEquals(1, collectionSnaps.size());\n      assertEquals(commitName_2, collectionSnaps_2.iterator().next().getName());\n\n      // Delete collection\n      CollectionAdminRequest.Delete deleteCol = CollectionAdminRequest.deleteCollection(collectionName);\n      assertEquals(0, deleteCol.process(solrClient).getStatus());\n      assertTrue(SolrSnapshotManager.listSnapshots(solrClient.getZkStateReader().getZkClient(), collectionName).isEmpty());\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/core/snapshots/TestSolrCloudSnapshots#testSnapshots().mjava","pathOld":"solr/core/src/test/org/apache/solr/core/snapshots/TestSolrCloudSnapshots#testSnapshots().mjava","sourceNew":"  @Test\n  public void testSnapshots() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String collectionName = \"SolrCloudSnapshots\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, \"conf1\", NUM_SHARDS, NUM_REPLICAS);\n    create.process(solrClient);\n    cluster.waitForActiveCollection(collectionName, NUM_SHARDS, NUM_SHARDS * NUM_REPLICAS);\n\n    int nDocs = BackupRestoreUtils.indexDocs(cluster.getSolrClient(), collectionName, docsSeed);\n    BackupRestoreUtils.verifyDocs(nDocs, solrClient, collectionName);\n\n    // Set a collection property\n    final boolean collectionPropertySet = usually();\n    if (collectionPropertySet) {\n      CollectionAdminRequest.CollectionProp setProperty = CollectionAdminRequest.setCollectionProperty(collectionName, \"test.property\", \"test.value\");\n      setProperty.process(solrClient);\n    }\n\n    String commitName = TestUtil.randomSimpleString(random(), 1, 5);\n\n    // Verify if snapshot creation works with replica failures.\n    boolean replicaFailures = usually();\n    Optional<String> stoppedCoreName = Optional.empty();\n    if (replicaFailures) {\n      // Here the assumption is that Solr will spread the replicas uniformly across nodes.\n      // If this is not true for some reason, then we will need to add some logic to find a\n      // node with a single replica.\n      this.cluster.getRandomJetty(random()).stop();\n\n      // Sleep a bit for allowing ZK watch to fire.\n      Thread.sleep(5000);\n\n      // Figure out if at-least one replica is \"down\".\n      DocCollection collState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n      for (Slice s : collState.getSlices()) {\n        for (Replica replica : s.getReplicas()) {\n          if (replica.getState() == State.DOWN) {\n            stoppedCoreName = Optional.of(replica.getCoreName());\n          }\n        }\n      }\n    }\n\n    int expectedCoresWithSnapshot = stoppedCoreName.isPresent() ? (NUM_SHARDS * NUM_REPLICAS) - 1 : (NUM_SHARDS * NUM_REPLICAS);\n\n    CollectionAdminRequest.CreateSnapshot createSnap = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName);\n    createSnap.process(solrClient);\n\n    Collection<CollectionSnapshotMetaData> collectionSnaps = listCollectionSnapshots(solrClient, collectionName);\n    assertEquals(1, collectionSnaps.size());\n    CollectionSnapshotMetaData meta = collectionSnaps.iterator().next();\n    assertEquals(commitName, meta.getName());\n    assertEquals(CollectionSnapshotMetaData.SnapshotStatus.Successful, meta.getStatus());\n    assertEquals(expectedCoresWithSnapshot, meta.getReplicaSnapshots().size());\n    Map<String, CoreSnapshotMetaData> snapshotByCoreName = meta.getReplicaSnapshots().stream()\n        .collect(Collectors.toMap(CoreSnapshotMetaData::getCoreName, Function.identity()));\n\n    DocCollection collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(2, collectionState.getActiveSlices().size());\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      assertEquals(2, shard.getReplicas().size());\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot is not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        assertTrue(snapshotByCoreName.containsKey(coreName));\n        CoreSnapshotMetaData coreSnapshot = snapshotByCoreName.get(coreName);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertTrue(\"Snapshot not created for core \" + coreName, metaData.isPresent());\n          assertEquals(coreSnapshot.getIndexDirPath(), metaData.get().getIndexDirPath());\n          assertEquals(coreSnapshot.getGenerationNumber(), metaData.get().getGenerationNumber());\n        }\n      }\n    }\n\n    // Delete all documents.\n    {\n      solrClient.deleteByQuery(collectionName, \"*:*\");\n      solrClient.commit(collectionName);\n      BackupRestoreUtils.verifyDocs(0, solrClient, collectionName);\n    }\n\n    String backupLocation = createTempDir().toFile().getAbsolutePath();\n    String backupName = \"mytestbackup\";\n    String restoreCollectionName = collectionName + \"_restored\";\n\n    //Create a backup using the earlier created snapshot.\n    {\n      CollectionAdminRequest.Backup backup = CollectionAdminRequest.backupCollection(collectionName, backupName)\n          .setLocation(backupLocation).setCommitName(commitName);\n      if (random().nextBoolean()) {\n        assertEquals(0, backup.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, backup.processAndWait(solrClient, 30));//async\n      }\n    }\n\n    // Restore backup.\n    {\n      CollectionAdminRequest.Restore restore = CollectionAdminRequest.restoreCollection(restoreCollectionName, backupName)\n          .setLocation(backupLocation);\n      if (replicaFailures) {\n        // In this case one of the Solr servers would be down. Hence we need to increase\n        // max_shards_per_node property for restore command to succeed.\n        restore.setMaxShardsPerNode(2);\n      }\n      if (random().nextBoolean()) {\n        assertEquals(0, restore.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, restore.processAndWait(solrClient, 30));//async\n      }\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(\n          restoreCollectionName, cluster.getSolrClient().getZkStateReader(), log.isDebugEnabled(), true, 30);\n      BackupRestoreUtils.verifyDocs(nDocs, solrClient, restoreCollectionName);\n    }\n\n    // Check collection property\n    Map<String, String> collectionProperties = solrClient.getZkStateReader().getCollectionProperties(restoreCollectionName);\n    if (collectionPropertySet) {\n      assertEquals(\"Snapshot restore hasn't restored collection properties\", \"test.value\", collectionProperties.get(\"test.property\"));\n    } else {\n      assertNull(\"Collection property shouldn't be present\", collectionProperties.get(\"test.property\"));\n    }\n\n    // Verify if the snapshot deletion works correctly when one or more replicas containing the snapshot are\n    // deleted\n    boolean replicaDeletion = rarely();\n    if (replicaDeletion) {\n      CoreSnapshotMetaData replicaToDelete = null;\n      for (String shardId : meta.getShards()) {\n        List<CoreSnapshotMetaData> replicas = meta.getReplicaSnapshotsForShard(shardId);\n        if (replicas.size() > 1) {\n          int r_index = random().nextInt(replicas.size());\n          replicaToDelete = replicas.get(r_index);\n        }\n      }\n\n      if (replicaToDelete != null) {\n        collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n        for (Slice s : collectionState.getSlices()) {\n          for (Replica r : s.getReplicas()) {\n            if (r.getCoreName().equals(replicaToDelete.getCoreName())) {\n              log.info(\"Deleting replica {}\", r);\n              CollectionAdminRequest.DeleteReplica delReplica = CollectionAdminRequest.deleteReplica(collectionName,\n                  replicaToDelete.getShardId(), r.getName());\n              delReplica.process(solrClient);\n              // The replica deletion will cleanup the snapshot meta-data.\n              snapshotByCoreName.remove(r.getCoreName());\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // Delete snapshot\n    CollectionAdminRequest.DeleteSnapshot deleteSnap = new CollectionAdminRequest.DeleteSnapshot(collectionName, commitName);\n    deleteSnap.process(solrClient);\n\n    // Wait for a while so that the clusterstate.json updates are propagated to the client side.\n    Thread.sleep(2000);\n    collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot was not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertFalse(\"Snapshot not deleted for core \" + coreName, metaData.isPresent());\n          // Remove the entry for core if the snapshot is deleted successfully.\n          snapshotByCoreName.remove(coreName);\n        }\n      }\n    }\n\n    // Verify all core-level snapshots are deleted.\n    assertTrue(\"The cores remaining \" + snapshotByCoreName, snapshotByCoreName.isEmpty());\n    assertTrue(listCollectionSnapshots(solrClient, collectionName).isEmpty());\n\n    // Verify if the collection deletion result in proper cleanup of snapshot metadata.\n    {\n      String commitName_2 = commitName + \"_2\";\n\n      CollectionAdminRequest.CreateSnapshot createSnap_2 = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName_2);\n      assertEquals(0, createSnap_2.process(solrClient).getStatus());\n\n      Collection<CollectionSnapshotMetaData> collectionSnaps_2 = listCollectionSnapshots(solrClient, collectionName);\n      assertEquals(1, collectionSnaps.size());\n      assertEquals(commitName_2, collectionSnaps_2.iterator().next().getName());\n\n      // Delete collection\n      CollectionAdminRequest.Delete deleteCol = CollectionAdminRequest.deleteCollection(collectionName);\n      assertEquals(0, deleteCol.process(solrClient).getStatus());\n      assertTrue(SolrSnapshotManager.listSnapshots(solrClient.getZkStateReader().getZkClient(), collectionName).isEmpty());\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSnapshots() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String collectionName = \"SolrCloudSnapshots\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, \"conf1\", NUM_SHARDS, NUM_REPLICAS);\n    create.process(solrClient);\n\n    int nDocs = BackupRestoreUtils.indexDocs(cluster.getSolrClient(), collectionName, docsSeed);\n    BackupRestoreUtils.verifyDocs(nDocs, solrClient, collectionName);\n\n    // Set a collection property\n    final boolean collectionPropertySet = usually();\n    if (collectionPropertySet) {\n      CollectionAdminRequest.CollectionProp setProperty = CollectionAdminRequest.setCollectionProperty(collectionName, \"test.property\", \"test.value\");\n      setProperty.process(solrClient);\n    }\n\n    String commitName = TestUtil.randomSimpleString(random(), 1, 5);\n\n    // Verify if snapshot creation works with replica failures.\n    boolean replicaFailures = usually();\n    Optional<String> stoppedCoreName = Optional.empty();\n    if (replicaFailures) {\n      // Here the assumption is that Solr will spread the replicas uniformly across nodes.\n      // If this is not true for some reason, then we will need to add some logic to find a\n      // node with a single replica.\n      this.cluster.getRandomJetty(random()).stop();\n\n      // Sleep a bit for allowing ZK watch to fire.\n      Thread.sleep(5000);\n\n      // Figure out if at-least one replica is \"down\".\n      DocCollection collState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n      for (Slice s : collState.getSlices()) {\n        for (Replica replica : s.getReplicas()) {\n          if (replica.getState() == State.DOWN) {\n            stoppedCoreName = Optional.of(replica.getCoreName());\n          }\n        }\n      }\n    }\n\n    int expectedCoresWithSnapshot = stoppedCoreName.isPresent() ? (NUM_SHARDS * NUM_REPLICAS) - 1 : (NUM_SHARDS * NUM_REPLICAS);\n\n    CollectionAdminRequest.CreateSnapshot createSnap = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName);\n    createSnap.process(solrClient);\n\n    Collection<CollectionSnapshotMetaData> collectionSnaps = listCollectionSnapshots(solrClient, collectionName);\n    assertEquals(1, collectionSnaps.size());\n    CollectionSnapshotMetaData meta = collectionSnaps.iterator().next();\n    assertEquals(commitName, meta.getName());\n    assertEquals(CollectionSnapshotMetaData.SnapshotStatus.Successful, meta.getStatus());\n    assertEquals(expectedCoresWithSnapshot, meta.getReplicaSnapshots().size());\n    Map<String, CoreSnapshotMetaData> snapshotByCoreName = meta.getReplicaSnapshots().stream()\n        .collect(Collectors.toMap(CoreSnapshotMetaData::getCoreName, Function.identity()));\n\n    DocCollection collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(2, collectionState.getActiveSlices().size());\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      assertEquals(2, shard.getReplicas().size());\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot is not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        assertTrue(snapshotByCoreName.containsKey(coreName));\n        CoreSnapshotMetaData coreSnapshot = snapshotByCoreName.get(coreName);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertTrue(\"Snapshot not created for core \" + coreName, metaData.isPresent());\n          assertEquals(coreSnapshot.getIndexDirPath(), metaData.get().getIndexDirPath());\n          assertEquals(coreSnapshot.getGenerationNumber(), metaData.get().getGenerationNumber());\n        }\n      }\n    }\n\n    // Delete all documents.\n    {\n      solrClient.deleteByQuery(collectionName, \"*:*\");\n      solrClient.commit(collectionName);\n      BackupRestoreUtils.verifyDocs(0, solrClient, collectionName);\n    }\n\n    String backupLocation = createTempDir().toFile().getAbsolutePath();\n    String backupName = \"mytestbackup\";\n    String restoreCollectionName = collectionName + \"_restored\";\n\n    //Create a backup using the earlier created snapshot.\n    {\n      CollectionAdminRequest.Backup backup = CollectionAdminRequest.backupCollection(collectionName, backupName)\n          .setLocation(backupLocation).setCommitName(commitName);\n      if (random().nextBoolean()) {\n        assertEquals(0, backup.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, backup.processAndWait(solrClient, 30));//async\n      }\n    }\n\n    // Restore backup.\n    {\n      CollectionAdminRequest.Restore restore = CollectionAdminRequest.restoreCollection(restoreCollectionName, backupName)\n          .setLocation(backupLocation);\n      if (replicaFailures) {\n        // In this case one of the Solr servers would be down. Hence we need to increase\n        // max_shards_per_node property for restore command to succeed.\n        restore.setMaxShardsPerNode(2);\n      }\n      if (random().nextBoolean()) {\n        assertEquals(0, restore.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, restore.processAndWait(solrClient, 30));//async\n      }\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(\n          restoreCollectionName, cluster.getSolrClient().getZkStateReader(), log.isDebugEnabled(), true, 30);\n      BackupRestoreUtils.verifyDocs(nDocs, solrClient, restoreCollectionName);\n    }\n\n    // Check collection property\n    Map<String, String> collectionProperties = solrClient.getZkStateReader().getCollectionProperties(restoreCollectionName);\n    if (collectionPropertySet) {\n      assertEquals(\"Snapshot restore hasn't restored collection properties\", \"test.value\", collectionProperties.get(\"test.property\"));\n    } else {\n      assertNull(\"Collection property shouldn't be present\", collectionProperties.get(\"test.property\"));\n    }\n\n    // Verify if the snapshot deletion works correctly when one or more replicas containing the snapshot are\n    // deleted\n    boolean replicaDeletion = rarely();\n    if (replicaDeletion) {\n      CoreSnapshotMetaData replicaToDelete = null;\n      for (String shardId : meta.getShards()) {\n        List<CoreSnapshotMetaData> replicas = meta.getReplicaSnapshotsForShard(shardId);\n        if (replicas.size() > 1) {\n          int r_index = random().nextInt(replicas.size());\n          replicaToDelete = replicas.get(r_index);\n        }\n      }\n\n      if (replicaToDelete != null) {\n        collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n        for (Slice s : collectionState.getSlices()) {\n          for (Replica r : s.getReplicas()) {\n            if (r.getCoreName().equals(replicaToDelete.getCoreName())) {\n              log.info(\"Deleting replica {}\", r);\n              CollectionAdminRequest.DeleteReplica delReplica = CollectionAdminRequest.deleteReplica(collectionName,\n                  replicaToDelete.getShardId(), r.getName());\n              delReplica.process(solrClient);\n              // The replica deletion will cleanup the snapshot meta-data.\n              snapshotByCoreName.remove(r.getCoreName());\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // Delete snapshot\n    CollectionAdminRequest.DeleteSnapshot deleteSnap = new CollectionAdminRequest.DeleteSnapshot(collectionName, commitName);\n    deleteSnap.process(solrClient);\n\n    // Wait for a while so that the clusterstate.json updates are propagated to the client side.\n    Thread.sleep(2000);\n    collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot was not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertFalse(\"Snapshot not deleted for core \" + coreName, metaData.isPresent());\n          // Remove the entry for core if the snapshot is deleted successfully.\n          snapshotByCoreName.remove(coreName);\n        }\n      }\n    }\n\n    // Verify all core-level snapshots are deleted.\n    assertTrue(\"The cores remaining \" + snapshotByCoreName, snapshotByCoreName.isEmpty());\n    assertTrue(listCollectionSnapshots(solrClient, collectionName).isEmpty());\n\n    // Verify if the collection deletion result in proper cleanup of snapshot metadata.\n    {\n      String commitName_2 = commitName + \"_2\";\n\n      CollectionAdminRequest.CreateSnapshot createSnap_2 = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName_2);\n      assertEquals(0, createSnap_2.process(solrClient).getStatus());\n\n      Collection<CollectionSnapshotMetaData> collectionSnaps_2 = listCollectionSnapshots(solrClient, collectionName);\n      assertEquals(1, collectionSnaps.size());\n      assertEquals(commitName_2, collectionSnaps_2.iterator().next().getName());\n\n      // Delete collection\n      CollectionAdminRequest.Delete deleteCol = CollectionAdminRequest.deleteCollection(collectionName);\n      assertEquals(0, deleteCol.process(solrClient).getStatus());\n      assertTrue(SolrSnapshotManager.listSnapshots(solrClient.getZkStateReader().getZkClient(), collectionName).isEmpty());\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ad9c35f926b4bf8da0336d1300efc709c8d5a56","date":1591729157,"type":3,"author":"murblanc","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/core/snapshots/TestSolrCloudSnapshots#testSnapshots().mjava","pathOld":"solr/core/src/test/org/apache/solr/core/snapshots/TestSolrCloudSnapshots#testSnapshots().mjava","sourceNew":"  @Test\n  public void testSnapshots() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String collectionName = \"SolrCloudSnapshots\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, \"conf1\", NUM_SHARDS, NUM_REPLICAS);\n    create.process(solrClient);\n    cluster.waitForActiveCollection(collectionName, NUM_SHARDS, NUM_SHARDS * NUM_REPLICAS);\n\n    int nDocs = BackupRestoreUtils.indexDocs(cluster.getSolrClient(), collectionName, docsSeed);\n    BackupRestoreUtils.verifyDocs(nDocs, solrClient, collectionName);\n\n    // Set a collection property\n    final boolean collectionPropertySet = usually();\n    if (collectionPropertySet) {\n      CollectionAdminRequest.CollectionProp setProperty = CollectionAdminRequest.setCollectionProperty(collectionName, \"test.property\", \"test.value\");\n      setProperty.process(solrClient);\n    }\n\n    String commitName = TestUtil.randomSimpleString(random(), 1, 5);\n\n    // Verify if snapshot creation works with replica failures.\n    boolean replicaFailures = usually();\n    Optional<String> stoppedCoreName = Optional.empty();\n    if (replicaFailures) {\n      // Here the assumption is that Solr will spread the replicas uniformly across nodes.\n      // If this is not true for some reason, then we will need to add some logic to find a\n      // node with a single replica.\n      this.cluster.getRandomJetty(random()).stop();\n\n      // Sleep a bit for allowing ZK watch to fire.\n      Thread.sleep(5000);\n\n      // Figure out if at-least one replica is \"down\".\n      DocCollection collState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n      for (Slice s : collState.getSlices()) {\n        for (Replica replica : s.getReplicas()) {\n          if (replica.getState() == State.DOWN) {\n            stoppedCoreName = Optional.of(replica.getCoreName());\n          }\n        }\n      }\n    }\n\n    int expectedCoresWithSnapshot = stoppedCoreName.isPresent() ? (NUM_SHARDS * NUM_REPLICAS) - 1 : (NUM_SHARDS * NUM_REPLICAS);\n\n    CollectionAdminRequest.CreateSnapshot createSnap = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName);\n    createSnap.process(solrClient);\n\n    Collection<CollectionSnapshotMetaData> collectionSnaps = listCollectionSnapshots(solrClient, collectionName);\n    assertEquals(1, collectionSnaps.size());\n    CollectionSnapshotMetaData meta = collectionSnaps.iterator().next();\n    assertEquals(commitName, meta.getName());\n    assertEquals(CollectionSnapshotMetaData.SnapshotStatus.Successful, meta.getStatus());\n    assertEquals(expectedCoresWithSnapshot, meta.getReplicaSnapshots().size());\n    Map<String, CoreSnapshotMetaData> snapshotByCoreName = meta.getReplicaSnapshots().stream()\n        .collect(Collectors.toMap(CoreSnapshotMetaData::getCoreName, Function.identity()));\n\n    DocCollection collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(2, collectionState.getActiveSlices().size());\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      assertEquals(2, shard.getReplicas().size());\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot is not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        assertTrue(snapshotByCoreName.containsKey(coreName));\n        CoreSnapshotMetaData coreSnapshot = snapshotByCoreName.get(coreName);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertTrue(\"Snapshot not created for core \" + coreName, metaData.isPresent());\n          assertEquals(coreSnapshot.getIndexDirPath(), metaData.get().getIndexDirPath());\n          assertEquals(coreSnapshot.getGenerationNumber(), metaData.get().getGenerationNumber());\n        }\n      }\n    }\n\n    // Delete all documents.\n    {\n      solrClient.deleteByQuery(collectionName, \"*:*\");\n      solrClient.commit(collectionName);\n      BackupRestoreUtils.verifyDocs(0, solrClient, collectionName);\n    }\n\n    String backupLocation = createTempDir().toFile().getAbsolutePath();\n    String backupName = \"mytestbackup\";\n    String restoreCollectionName = collectionName + \"_restored\";\n\n    //Create a backup using the earlier created snapshot.\n    {\n      CollectionAdminRequest.Backup backup = CollectionAdminRequest.backupCollection(collectionName, backupName)\n          .setLocation(backupLocation).setCommitName(commitName);\n      if (random().nextBoolean()) {\n        assertEquals(0, backup.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, backup.processAndWait(solrClient, 30));//async\n      }\n    }\n\n    // Restore backup.\n    {\n      CollectionAdminRequest.Restore restore = CollectionAdminRequest.restoreCollection(restoreCollectionName, backupName)\n          .setLocation(backupLocation);\n      if (replicaFailures) {\n        // In this case one of the Solr servers would be down. Hence we need to increase\n        // max_shards_per_node property for restore command to succeed.\n        restore.setMaxShardsPerNode(2);\n      }\n      if (random().nextBoolean()) {\n        assertEquals(0, restore.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, restore.processAndWait(solrClient, 30));//async\n      }\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(\n          restoreCollectionName, cluster.getSolrClient().getZkStateReader(), log.isDebugEnabled(), true, 30);\n      BackupRestoreUtils.verifyDocs(nDocs, solrClient, restoreCollectionName);\n    }\n\n    // Check collection property\n    Map<String, String> collectionProperties = solrClient.getZkStateReader().getCollectionProperties(restoreCollectionName);\n    if (collectionPropertySet) {\n      assertEquals(\"Snapshot restore hasn't restored collection properties\", \"test.value\", collectionProperties.get(\"test.property\"));\n    } else {\n      assertNull(\"Collection property shouldn't be present\", collectionProperties.get(\"test.property\"));\n    }\n\n    // Verify if the snapshot deletion works correctly when one or more replicas containing the snapshot are\n    // deleted\n    boolean replicaDeletion = rarely();\n    if (replicaDeletion) {\n      CoreSnapshotMetaData replicaToDelete = null;\n      for (String shardId : meta.getShards()) {\n        List<CoreSnapshotMetaData> replicas = meta.getReplicaSnapshotsForShard(shardId);\n        if (replicas.size() > 1) {\n          int r_index = random().nextInt(replicas.size());\n          replicaToDelete = replicas.get(r_index);\n        }\n      }\n\n      if (replicaToDelete != null) {\n        collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n        for (Slice s : collectionState.getSlices()) {\n          for (Replica r : s.getReplicas()) {\n            if (r.getCoreName().equals(replicaToDelete.getCoreName())) {\n              log.info(\"Deleting replica {}\", r);\n              CollectionAdminRequest.DeleteReplica delReplica = CollectionAdminRequest.deleteReplica(collectionName,\n                  replicaToDelete.getShardId(), r.getName());\n              delReplica.process(solrClient);\n              // The replica deletion will cleanup the snapshot meta-data.\n              snapshotByCoreName.remove(r.getCoreName());\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // Delete snapshot\n    CollectionAdminRequest.DeleteSnapshot deleteSnap = new CollectionAdminRequest.DeleteSnapshot(collectionName, commitName);\n    deleteSnap.process(solrClient);\n\n    // Wait for a while so that the cluster state updates are propagated to the client side.\n    Thread.sleep(2000);\n    collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot was not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertFalse(\"Snapshot not deleted for core \" + coreName, metaData.isPresent());\n          // Remove the entry for core if the snapshot is deleted successfully.\n          snapshotByCoreName.remove(coreName);\n        }\n      }\n    }\n\n    // Verify all core-level snapshots are deleted.\n    assertTrue(\"The cores remaining \" + snapshotByCoreName, snapshotByCoreName.isEmpty());\n    assertTrue(listCollectionSnapshots(solrClient, collectionName).isEmpty());\n\n    // Verify if the collection deletion result in proper cleanup of snapshot metadata.\n    {\n      String commitName_2 = commitName + \"_2\";\n\n      CollectionAdminRequest.CreateSnapshot createSnap_2 = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName_2);\n      assertEquals(0, createSnap_2.process(solrClient).getStatus());\n\n      Collection<CollectionSnapshotMetaData> collectionSnaps_2 = listCollectionSnapshots(solrClient, collectionName);\n      assertEquals(1, collectionSnaps.size());\n      assertEquals(commitName_2, collectionSnaps_2.iterator().next().getName());\n\n      // Delete collection\n      CollectionAdminRequest.Delete deleteCol = CollectionAdminRequest.deleteCollection(collectionName);\n      assertEquals(0, deleteCol.process(solrClient).getStatus());\n      assertTrue(SolrSnapshotManager.listSnapshots(solrClient.getZkStateReader().getZkClient(), collectionName).isEmpty());\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSnapshots() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String collectionName = \"SolrCloudSnapshots\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, \"conf1\", NUM_SHARDS, NUM_REPLICAS);\n    create.process(solrClient);\n    cluster.waitForActiveCollection(collectionName, NUM_SHARDS, NUM_SHARDS * NUM_REPLICAS);\n\n    int nDocs = BackupRestoreUtils.indexDocs(cluster.getSolrClient(), collectionName, docsSeed);\n    BackupRestoreUtils.verifyDocs(nDocs, solrClient, collectionName);\n\n    // Set a collection property\n    final boolean collectionPropertySet = usually();\n    if (collectionPropertySet) {\n      CollectionAdminRequest.CollectionProp setProperty = CollectionAdminRequest.setCollectionProperty(collectionName, \"test.property\", \"test.value\");\n      setProperty.process(solrClient);\n    }\n\n    String commitName = TestUtil.randomSimpleString(random(), 1, 5);\n\n    // Verify if snapshot creation works with replica failures.\n    boolean replicaFailures = usually();\n    Optional<String> stoppedCoreName = Optional.empty();\n    if (replicaFailures) {\n      // Here the assumption is that Solr will spread the replicas uniformly across nodes.\n      // If this is not true for some reason, then we will need to add some logic to find a\n      // node with a single replica.\n      this.cluster.getRandomJetty(random()).stop();\n\n      // Sleep a bit for allowing ZK watch to fire.\n      Thread.sleep(5000);\n\n      // Figure out if at-least one replica is \"down\".\n      DocCollection collState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n      for (Slice s : collState.getSlices()) {\n        for (Replica replica : s.getReplicas()) {\n          if (replica.getState() == State.DOWN) {\n            stoppedCoreName = Optional.of(replica.getCoreName());\n          }\n        }\n      }\n    }\n\n    int expectedCoresWithSnapshot = stoppedCoreName.isPresent() ? (NUM_SHARDS * NUM_REPLICAS) - 1 : (NUM_SHARDS * NUM_REPLICAS);\n\n    CollectionAdminRequest.CreateSnapshot createSnap = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName);\n    createSnap.process(solrClient);\n\n    Collection<CollectionSnapshotMetaData> collectionSnaps = listCollectionSnapshots(solrClient, collectionName);\n    assertEquals(1, collectionSnaps.size());\n    CollectionSnapshotMetaData meta = collectionSnaps.iterator().next();\n    assertEquals(commitName, meta.getName());\n    assertEquals(CollectionSnapshotMetaData.SnapshotStatus.Successful, meta.getStatus());\n    assertEquals(expectedCoresWithSnapshot, meta.getReplicaSnapshots().size());\n    Map<String, CoreSnapshotMetaData> snapshotByCoreName = meta.getReplicaSnapshots().stream()\n        .collect(Collectors.toMap(CoreSnapshotMetaData::getCoreName, Function.identity()));\n\n    DocCollection collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(2, collectionState.getActiveSlices().size());\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      assertEquals(2, shard.getReplicas().size());\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot is not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        assertTrue(snapshotByCoreName.containsKey(coreName));\n        CoreSnapshotMetaData coreSnapshot = snapshotByCoreName.get(coreName);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertTrue(\"Snapshot not created for core \" + coreName, metaData.isPresent());\n          assertEquals(coreSnapshot.getIndexDirPath(), metaData.get().getIndexDirPath());\n          assertEquals(coreSnapshot.getGenerationNumber(), metaData.get().getGenerationNumber());\n        }\n      }\n    }\n\n    // Delete all documents.\n    {\n      solrClient.deleteByQuery(collectionName, \"*:*\");\n      solrClient.commit(collectionName);\n      BackupRestoreUtils.verifyDocs(0, solrClient, collectionName);\n    }\n\n    String backupLocation = createTempDir().toFile().getAbsolutePath();\n    String backupName = \"mytestbackup\";\n    String restoreCollectionName = collectionName + \"_restored\";\n\n    //Create a backup using the earlier created snapshot.\n    {\n      CollectionAdminRequest.Backup backup = CollectionAdminRequest.backupCollection(collectionName, backupName)\n          .setLocation(backupLocation).setCommitName(commitName);\n      if (random().nextBoolean()) {\n        assertEquals(0, backup.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, backup.processAndWait(solrClient, 30));//async\n      }\n    }\n\n    // Restore backup.\n    {\n      CollectionAdminRequest.Restore restore = CollectionAdminRequest.restoreCollection(restoreCollectionName, backupName)\n          .setLocation(backupLocation);\n      if (replicaFailures) {\n        // In this case one of the Solr servers would be down. Hence we need to increase\n        // max_shards_per_node property for restore command to succeed.\n        restore.setMaxShardsPerNode(2);\n      }\n      if (random().nextBoolean()) {\n        assertEquals(0, restore.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, restore.processAndWait(solrClient, 30));//async\n      }\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(\n          restoreCollectionName, cluster.getSolrClient().getZkStateReader(), log.isDebugEnabled(), true, 30);\n      BackupRestoreUtils.verifyDocs(nDocs, solrClient, restoreCollectionName);\n    }\n\n    // Check collection property\n    Map<String, String> collectionProperties = solrClient.getZkStateReader().getCollectionProperties(restoreCollectionName);\n    if (collectionPropertySet) {\n      assertEquals(\"Snapshot restore hasn't restored collection properties\", \"test.value\", collectionProperties.get(\"test.property\"));\n    } else {\n      assertNull(\"Collection property shouldn't be present\", collectionProperties.get(\"test.property\"));\n    }\n\n    // Verify if the snapshot deletion works correctly when one or more replicas containing the snapshot are\n    // deleted\n    boolean replicaDeletion = rarely();\n    if (replicaDeletion) {\n      CoreSnapshotMetaData replicaToDelete = null;\n      for (String shardId : meta.getShards()) {\n        List<CoreSnapshotMetaData> replicas = meta.getReplicaSnapshotsForShard(shardId);\n        if (replicas.size() > 1) {\n          int r_index = random().nextInt(replicas.size());\n          replicaToDelete = replicas.get(r_index);\n        }\n      }\n\n      if (replicaToDelete != null) {\n        collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n        for (Slice s : collectionState.getSlices()) {\n          for (Replica r : s.getReplicas()) {\n            if (r.getCoreName().equals(replicaToDelete.getCoreName())) {\n              log.info(\"Deleting replica {}\", r);\n              CollectionAdminRequest.DeleteReplica delReplica = CollectionAdminRequest.deleteReplica(collectionName,\n                  replicaToDelete.getShardId(), r.getName());\n              delReplica.process(solrClient);\n              // The replica deletion will cleanup the snapshot meta-data.\n              snapshotByCoreName.remove(r.getCoreName());\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // Delete snapshot\n    CollectionAdminRequest.DeleteSnapshot deleteSnap = new CollectionAdminRequest.DeleteSnapshot(collectionName, commitName);\n    deleteSnap.process(solrClient);\n\n    // Wait for a while so that the clusterstate.json updates are propagated to the client side.\n    Thread.sleep(2000);\n    collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot was not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertFalse(\"Snapshot not deleted for core \" + coreName, metaData.isPresent());\n          // Remove the entry for core if the snapshot is deleted successfully.\n          snapshotByCoreName.remove(coreName);\n        }\n      }\n    }\n\n    // Verify all core-level snapshots are deleted.\n    assertTrue(\"The cores remaining \" + snapshotByCoreName, snapshotByCoreName.isEmpty());\n    assertTrue(listCollectionSnapshots(solrClient, collectionName).isEmpty());\n\n    // Verify if the collection deletion result in proper cleanup of snapshot metadata.\n    {\n      String commitName_2 = commitName + \"_2\";\n\n      CollectionAdminRequest.CreateSnapshot createSnap_2 = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName_2);\n      assertEquals(0, createSnap_2.process(solrClient).getStatus());\n\n      Collection<CollectionSnapshotMetaData> collectionSnaps_2 = listCollectionSnapshots(solrClient, collectionName);\n      assertEquals(1, collectionSnaps.size());\n      assertEquals(commitName_2, collectionSnaps_2.iterator().next().getName());\n\n      // Delete collection\n      CollectionAdminRequest.Delete deleteCol = CollectionAdminRequest.deleteCollection(collectionName);\n      assertEquals(0, deleteCol.process(solrClient).getStatus());\n      assertTrue(SolrSnapshotManager.listSnapshots(solrClient.getZkStateReader().getZkClient(), collectionName).isEmpty());\n    }\n\n  }\n\n","bugFix":["424ac616f0aeeb2a3c8b6b94084255a0bcab9628"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9dd6cf7e1b30a14801c9e290183b875c6801bbe9","date":1591734817,"type":3,"author":"Mike Drob","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/core/snapshots/TestSolrCloudSnapshots#testSnapshots().mjava","pathOld":"solr/core/src/test/org/apache/solr/core/snapshots/TestSolrCloudSnapshots#testSnapshots().mjava","sourceNew":"  @Test\n  public void testSnapshots() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String collectionName = \"SolrCloudSnapshots\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, \"conf1\", NUM_SHARDS, NUM_REPLICAS);\n    create.process(solrClient);\n    cluster.waitForActiveCollection(collectionName, NUM_SHARDS, NUM_SHARDS * NUM_REPLICAS);\n\n    int nDocs = BackupRestoreUtils.indexDocs(cluster.getSolrClient(), collectionName, docsSeed);\n    BackupRestoreUtils.verifyDocs(nDocs, solrClient, collectionName);\n\n    // Set a collection property\n    final boolean collectionPropertySet = usually();\n    if (collectionPropertySet) {\n      CollectionAdminRequest.CollectionProp setProperty = CollectionAdminRequest.setCollectionProperty(collectionName, \"test.property\", \"test.value\");\n      setProperty.process(solrClient);\n    }\n\n    String commitName = TestUtil.randomSimpleString(random(), 1, 5);\n\n    // Verify if snapshot creation works with replica failures.\n    boolean replicaFailures = usually();\n    Optional<String> stoppedCoreName = Optional.empty();\n    if (replicaFailures) {\n      // Here the assumption is that Solr will spread the replicas uniformly across nodes.\n      // If this is not true for some reason, then we will need to add some logic to find a\n      // node with a single replica.\n      cluster.getRandomJetty(random()).stop();\n\n      // Sleep a bit for allowing ZK watch to fire.\n      Thread.sleep(5000);\n\n      // Figure out if at-least one replica is \"down\".\n      DocCollection collState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n      for (Slice s : collState.getSlices()) {\n        for (Replica replica : s.getReplicas()) {\n          if (replica.getState() == State.DOWN) {\n            stoppedCoreName = Optional.of(replica.getCoreName());\n          }\n        }\n      }\n    }\n\n    int expectedCoresWithSnapshot = stoppedCoreName.isPresent() ? (NUM_SHARDS * NUM_REPLICAS) - 1 : (NUM_SHARDS * NUM_REPLICAS);\n\n    CollectionAdminRequest.CreateSnapshot createSnap = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName);\n    createSnap.process(solrClient);\n\n    Collection<CollectionSnapshotMetaData> collectionSnaps = listCollectionSnapshots(solrClient, collectionName);\n    assertEquals(1, collectionSnaps.size());\n    CollectionSnapshotMetaData meta = collectionSnaps.iterator().next();\n    assertEquals(commitName, meta.getName());\n    assertEquals(CollectionSnapshotMetaData.SnapshotStatus.Successful, meta.getStatus());\n    assertEquals(expectedCoresWithSnapshot, meta.getReplicaSnapshots().size());\n    Map<String, CoreSnapshotMetaData> snapshotByCoreName = meta.getReplicaSnapshots().stream()\n        .collect(Collectors.toMap(CoreSnapshotMetaData::getCoreName, Function.identity()));\n\n    DocCollection collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(2, collectionState.getActiveSlices().size());\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      assertEquals(2, shard.getReplicas().size());\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot is not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        assertTrue(snapshotByCoreName.containsKey(coreName));\n        CoreSnapshotMetaData coreSnapshot = snapshotByCoreName.get(coreName);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertTrue(\"Snapshot not created for core \" + coreName, metaData.isPresent());\n          assertEquals(coreSnapshot.getIndexDirPath(), metaData.get().getIndexDirPath());\n          assertEquals(coreSnapshot.getGenerationNumber(), metaData.get().getGenerationNumber());\n        }\n      }\n    }\n\n    // Delete all documents.\n    {\n      solrClient.deleteByQuery(collectionName, \"*:*\");\n      solrClient.commit(collectionName);\n      BackupRestoreUtils.verifyDocs(0, solrClient, collectionName);\n    }\n\n    String backupLocation = createTempDir().toFile().getAbsolutePath();\n    String backupName = \"mytestbackup\";\n    String restoreCollectionName = collectionName + \"_restored\";\n\n    //Create a backup using the earlier created snapshot.\n    {\n      CollectionAdminRequest.Backup backup = CollectionAdminRequest.backupCollection(collectionName, backupName)\n          .setLocation(backupLocation).setCommitName(commitName);\n      if (random().nextBoolean()) {\n        assertEquals(0, backup.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, backup.processAndWait(solrClient, 30));//async\n      }\n    }\n\n    // Restore backup.\n    {\n      CollectionAdminRequest.Restore restore = CollectionAdminRequest.restoreCollection(restoreCollectionName, backupName)\n          .setLocation(backupLocation);\n      if (replicaFailures) {\n        // In this case one of the Solr servers would be down. Hence we need to increase\n        // max_shards_per_node property for restore command to succeed.\n        restore.setMaxShardsPerNode(2);\n      }\n      if (random().nextBoolean()) {\n        assertEquals(0, restore.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, restore.processAndWait(solrClient, 30));//async\n      }\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(\n          restoreCollectionName, cluster.getSolrClient().getZkStateReader(), log.isDebugEnabled(), true, 30);\n      BackupRestoreUtils.verifyDocs(nDocs, solrClient, restoreCollectionName);\n    }\n\n    // Check collection property\n    Map<String, String> collectionProperties = solrClient.getZkStateReader().getCollectionProperties(restoreCollectionName);\n    if (collectionPropertySet) {\n      assertEquals(\"Snapshot restore hasn't restored collection properties\", \"test.value\", collectionProperties.get(\"test.property\"));\n    } else {\n      assertNull(\"Collection property shouldn't be present\", collectionProperties.get(\"test.property\"));\n    }\n\n    // Verify if the snapshot deletion works correctly when one or more replicas containing the snapshot are\n    // deleted\n    boolean replicaDeletion = rarely();\n    if (replicaDeletion) {\n      CoreSnapshotMetaData replicaToDelete = null;\n      for (String shardId : meta.getShards()) {\n        List<CoreSnapshotMetaData> replicas = meta.getReplicaSnapshotsForShard(shardId);\n        if (replicas.size() > 1) {\n          int r_index = random().nextInt(replicas.size());\n          replicaToDelete = replicas.get(r_index);\n        }\n      }\n\n      if (replicaToDelete != null) {\n        collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n        for (Slice s : collectionState.getSlices()) {\n          for (Replica r : s.getReplicas()) {\n            if (r.getCoreName().equals(replicaToDelete.getCoreName())) {\n              log.info(\"Deleting replica {}\", r);\n              CollectionAdminRequest.DeleteReplica delReplica = CollectionAdminRequest.deleteReplica(collectionName,\n                  replicaToDelete.getShardId(), r.getName());\n              delReplica.process(solrClient);\n              // The replica deletion will cleanup the snapshot meta-data.\n              snapshotByCoreName.remove(r.getCoreName());\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // Delete snapshot\n    CollectionAdminRequest.DeleteSnapshot deleteSnap = new CollectionAdminRequest.DeleteSnapshot(collectionName, commitName);\n    deleteSnap.process(solrClient);\n\n    // Wait for a while so that the cluster state updates are propagated to the client side.\n    Thread.sleep(2000);\n    collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot was not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertFalse(\"Snapshot not deleted for core \" + coreName, metaData.isPresent());\n          // Remove the entry for core if the snapshot is deleted successfully.\n          snapshotByCoreName.remove(coreName);\n        }\n      }\n    }\n\n    // Verify all core-level snapshots are deleted.\n    assertTrue(\"The cores remaining \" + snapshotByCoreName, snapshotByCoreName.isEmpty());\n    assertTrue(listCollectionSnapshots(solrClient, collectionName).isEmpty());\n\n    // Verify if the collection deletion result in proper cleanup of snapshot metadata.\n    {\n      String commitName_2 = commitName + \"_2\";\n\n      CollectionAdminRequest.CreateSnapshot createSnap_2 = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName_2);\n      assertEquals(0, createSnap_2.process(solrClient).getStatus());\n\n      Collection<CollectionSnapshotMetaData> collectionSnaps_2 = listCollectionSnapshots(solrClient, collectionName);\n      assertEquals(1, collectionSnaps.size());\n      assertEquals(commitName_2, collectionSnaps_2.iterator().next().getName());\n\n      // Delete collection\n      CollectionAdminRequest.Delete deleteCol = CollectionAdminRequest.deleteCollection(collectionName);\n      assertEquals(0, deleteCol.process(solrClient).getStatus());\n      assertTrue(SolrSnapshotManager.listSnapshots(solrClient.getZkStateReader().getZkClient(), collectionName).isEmpty());\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSnapshots() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String collectionName = \"SolrCloudSnapshots\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, \"conf1\", NUM_SHARDS, NUM_REPLICAS);\n    create.process(solrClient);\n    cluster.waitForActiveCollection(collectionName, NUM_SHARDS, NUM_SHARDS * NUM_REPLICAS);\n\n    int nDocs = BackupRestoreUtils.indexDocs(cluster.getSolrClient(), collectionName, docsSeed);\n    BackupRestoreUtils.verifyDocs(nDocs, solrClient, collectionName);\n\n    // Set a collection property\n    final boolean collectionPropertySet = usually();\n    if (collectionPropertySet) {\n      CollectionAdminRequest.CollectionProp setProperty = CollectionAdminRequest.setCollectionProperty(collectionName, \"test.property\", \"test.value\");\n      setProperty.process(solrClient);\n    }\n\n    String commitName = TestUtil.randomSimpleString(random(), 1, 5);\n\n    // Verify if snapshot creation works with replica failures.\n    boolean replicaFailures = usually();\n    Optional<String> stoppedCoreName = Optional.empty();\n    if (replicaFailures) {\n      // Here the assumption is that Solr will spread the replicas uniformly across nodes.\n      // If this is not true for some reason, then we will need to add some logic to find a\n      // node with a single replica.\n      this.cluster.getRandomJetty(random()).stop();\n\n      // Sleep a bit for allowing ZK watch to fire.\n      Thread.sleep(5000);\n\n      // Figure out if at-least one replica is \"down\".\n      DocCollection collState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n      for (Slice s : collState.getSlices()) {\n        for (Replica replica : s.getReplicas()) {\n          if (replica.getState() == State.DOWN) {\n            stoppedCoreName = Optional.of(replica.getCoreName());\n          }\n        }\n      }\n    }\n\n    int expectedCoresWithSnapshot = stoppedCoreName.isPresent() ? (NUM_SHARDS * NUM_REPLICAS) - 1 : (NUM_SHARDS * NUM_REPLICAS);\n\n    CollectionAdminRequest.CreateSnapshot createSnap = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName);\n    createSnap.process(solrClient);\n\n    Collection<CollectionSnapshotMetaData> collectionSnaps = listCollectionSnapshots(solrClient, collectionName);\n    assertEquals(1, collectionSnaps.size());\n    CollectionSnapshotMetaData meta = collectionSnaps.iterator().next();\n    assertEquals(commitName, meta.getName());\n    assertEquals(CollectionSnapshotMetaData.SnapshotStatus.Successful, meta.getStatus());\n    assertEquals(expectedCoresWithSnapshot, meta.getReplicaSnapshots().size());\n    Map<String, CoreSnapshotMetaData> snapshotByCoreName = meta.getReplicaSnapshots().stream()\n        .collect(Collectors.toMap(CoreSnapshotMetaData::getCoreName, Function.identity()));\n\n    DocCollection collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(2, collectionState.getActiveSlices().size());\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      assertEquals(2, shard.getReplicas().size());\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot is not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        assertTrue(snapshotByCoreName.containsKey(coreName));\n        CoreSnapshotMetaData coreSnapshot = snapshotByCoreName.get(coreName);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertTrue(\"Snapshot not created for core \" + coreName, metaData.isPresent());\n          assertEquals(coreSnapshot.getIndexDirPath(), metaData.get().getIndexDirPath());\n          assertEquals(coreSnapshot.getGenerationNumber(), metaData.get().getGenerationNumber());\n        }\n      }\n    }\n\n    // Delete all documents.\n    {\n      solrClient.deleteByQuery(collectionName, \"*:*\");\n      solrClient.commit(collectionName);\n      BackupRestoreUtils.verifyDocs(0, solrClient, collectionName);\n    }\n\n    String backupLocation = createTempDir().toFile().getAbsolutePath();\n    String backupName = \"mytestbackup\";\n    String restoreCollectionName = collectionName + \"_restored\";\n\n    //Create a backup using the earlier created snapshot.\n    {\n      CollectionAdminRequest.Backup backup = CollectionAdminRequest.backupCollection(collectionName, backupName)\n          .setLocation(backupLocation).setCommitName(commitName);\n      if (random().nextBoolean()) {\n        assertEquals(0, backup.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, backup.processAndWait(solrClient, 30));//async\n      }\n    }\n\n    // Restore backup.\n    {\n      CollectionAdminRequest.Restore restore = CollectionAdminRequest.restoreCollection(restoreCollectionName, backupName)\n          .setLocation(backupLocation);\n      if (replicaFailures) {\n        // In this case one of the Solr servers would be down. Hence we need to increase\n        // max_shards_per_node property for restore command to succeed.\n        restore.setMaxShardsPerNode(2);\n      }\n      if (random().nextBoolean()) {\n        assertEquals(0, restore.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, restore.processAndWait(solrClient, 30));//async\n      }\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(\n          restoreCollectionName, cluster.getSolrClient().getZkStateReader(), log.isDebugEnabled(), true, 30);\n      BackupRestoreUtils.verifyDocs(nDocs, solrClient, restoreCollectionName);\n    }\n\n    // Check collection property\n    Map<String, String> collectionProperties = solrClient.getZkStateReader().getCollectionProperties(restoreCollectionName);\n    if (collectionPropertySet) {\n      assertEquals(\"Snapshot restore hasn't restored collection properties\", \"test.value\", collectionProperties.get(\"test.property\"));\n    } else {\n      assertNull(\"Collection property shouldn't be present\", collectionProperties.get(\"test.property\"));\n    }\n\n    // Verify if the snapshot deletion works correctly when one or more replicas containing the snapshot are\n    // deleted\n    boolean replicaDeletion = rarely();\n    if (replicaDeletion) {\n      CoreSnapshotMetaData replicaToDelete = null;\n      for (String shardId : meta.getShards()) {\n        List<CoreSnapshotMetaData> replicas = meta.getReplicaSnapshotsForShard(shardId);\n        if (replicas.size() > 1) {\n          int r_index = random().nextInt(replicas.size());\n          replicaToDelete = replicas.get(r_index);\n        }\n      }\n\n      if (replicaToDelete != null) {\n        collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n        for (Slice s : collectionState.getSlices()) {\n          for (Replica r : s.getReplicas()) {\n            if (r.getCoreName().equals(replicaToDelete.getCoreName())) {\n              log.info(\"Deleting replica {}\", r);\n              CollectionAdminRequest.DeleteReplica delReplica = CollectionAdminRequest.deleteReplica(collectionName,\n                  replicaToDelete.getShardId(), r.getName());\n              delReplica.process(solrClient);\n              // The replica deletion will cleanup the snapshot meta-data.\n              snapshotByCoreName.remove(r.getCoreName());\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // Delete snapshot\n    CollectionAdminRequest.DeleteSnapshot deleteSnap = new CollectionAdminRequest.DeleteSnapshot(collectionName, commitName);\n    deleteSnap.process(solrClient);\n\n    // Wait for a while so that the cluster state updates are propagated to the client side.\n    Thread.sleep(2000);\n    collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot was not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertFalse(\"Snapshot not deleted for core \" + coreName, metaData.isPresent());\n          // Remove the entry for core if the snapshot is deleted successfully.\n          snapshotByCoreName.remove(coreName);\n        }\n      }\n    }\n\n    // Verify all core-level snapshots are deleted.\n    assertTrue(\"The cores remaining \" + snapshotByCoreName, snapshotByCoreName.isEmpty());\n    assertTrue(listCollectionSnapshots(solrClient, collectionName).isEmpty());\n\n    // Verify if the collection deletion result in proper cleanup of snapshot metadata.\n    {\n      String commitName_2 = commitName + \"_2\";\n\n      CollectionAdminRequest.CreateSnapshot createSnap_2 = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName_2);\n      assertEquals(0, createSnap_2.process(solrClient).getStatus());\n\n      Collection<CollectionSnapshotMetaData> collectionSnaps_2 = listCollectionSnapshots(solrClient, collectionName);\n      assertEquals(1, collectionSnaps.size());\n      assertEquals(commitName_2, collectionSnaps_2.iterator().next().getName());\n\n      // Delete collection\n      CollectionAdminRequest.Delete deleteCol = CollectionAdminRequest.deleteCollection(collectionName);\n      assertEquals(0, deleteCol.process(solrClient).getStatus());\n      assertTrue(SolrSnapshotManager.listSnapshots(solrClient.getZkStateReader().getZkClient(), collectionName).isEmpty());\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/core/snapshots/TestSolrCloudSnapshots#testSnapshots().mjava","pathOld":"solr/core/src/test/org/apache/solr/core/snapshots/TestSolrCloudSnapshots#testSnapshots().mjava","sourceNew":"  @Test\n  public void testSnapshots() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String collectionName = \"SolrCloudSnapshots\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, \"conf1\", NUM_SHARDS, NUM_REPLICAS);\n    create.process(solrClient);\n    cluster.waitForActiveCollection(collectionName, NUM_SHARDS, NUM_SHARDS * NUM_REPLICAS);\n\n    int nDocs = BackupRestoreUtils.indexDocs(cluster.getSolrClient(), collectionName, docsSeed);\n    BackupRestoreUtils.verifyDocs(nDocs, solrClient, collectionName);\n\n    // Set a collection property\n    final boolean collectionPropertySet = usually();\n    if (collectionPropertySet) {\n      CollectionAdminRequest.CollectionProp setProperty = CollectionAdminRequest.setCollectionProperty(collectionName, \"test.property\", \"test.value\");\n      setProperty.process(solrClient);\n    }\n\n    String commitName = TestUtil.randomSimpleString(random(), 1, 5);\n\n    // Verify if snapshot creation works with replica failures.\n    boolean replicaFailures = usually();\n    Optional<String> stoppedCoreName = Optional.empty();\n    if (replicaFailures) {\n      // Here the assumption is that Solr will spread the replicas uniformly across nodes.\n      // If this is not true for some reason, then we will need to add some logic to find a\n      // node with a single replica.\n      cluster.getRandomJetty(random()).stop();\n\n      // Sleep a bit for allowing ZK watch to fire.\n      Thread.sleep(5000);\n\n      // Figure out if at-least one replica is \"down\".\n      DocCollection collState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n      for (Slice s : collState.getSlices()) {\n        for (Replica replica : s.getReplicas()) {\n          if (replica.getState() == State.DOWN) {\n            stoppedCoreName = Optional.of(replica.getCoreName());\n          }\n        }\n      }\n    }\n\n    int expectedCoresWithSnapshot = stoppedCoreName.isPresent() ? (NUM_SHARDS * NUM_REPLICAS) - 1 : (NUM_SHARDS * NUM_REPLICAS);\n\n    CollectionAdminRequest.CreateSnapshot createSnap = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName);\n    createSnap.process(solrClient);\n\n    Collection<CollectionSnapshotMetaData> collectionSnaps = listCollectionSnapshots(solrClient, collectionName);\n    assertEquals(1, collectionSnaps.size());\n    CollectionSnapshotMetaData meta = collectionSnaps.iterator().next();\n    assertEquals(commitName, meta.getName());\n    assertEquals(CollectionSnapshotMetaData.SnapshotStatus.Successful, meta.getStatus());\n    assertEquals(expectedCoresWithSnapshot, meta.getReplicaSnapshots().size());\n    Map<String, CoreSnapshotMetaData> snapshotByCoreName = meta.getReplicaSnapshots().stream()\n        .collect(Collectors.toMap(CoreSnapshotMetaData::getCoreName, Function.identity()));\n\n    DocCollection collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(2, collectionState.getActiveSlices().size());\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      assertEquals(2, shard.getReplicas().size());\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot is not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        assertTrue(snapshotByCoreName.containsKey(coreName));\n        CoreSnapshotMetaData coreSnapshot = snapshotByCoreName.get(coreName);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertTrue(\"Snapshot not created for core \" + coreName, metaData.isPresent());\n          assertEquals(coreSnapshot.getIndexDirPath(), metaData.get().getIndexDirPath());\n          assertEquals(coreSnapshot.getGenerationNumber(), metaData.get().getGenerationNumber());\n        }\n      }\n    }\n\n    // Delete all documents.\n    {\n      solrClient.deleteByQuery(collectionName, \"*:*\");\n      solrClient.commit(collectionName);\n      BackupRestoreUtils.verifyDocs(0, solrClient, collectionName);\n    }\n\n    String backupLocation = createTempDir().toFile().getAbsolutePath();\n    String backupName = \"mytestbackup\";\n    String restoreCollectionName = collectionName + \"_restored\";\n\n    //Create a backup using the earlier created snapshot.\n    {\n      CollectionAdminRequest.Backup backup = CollectionAdminRequest.backupCollection(collectionName, backupName)\n          .setLocation(backupLocation).setCommitName(commitName);\n      if (random().nextBoolean()) {\n        assertEquals(0, backup.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, backup.processAndWait(solrClient, 30));//async\n      }\n    }\n\n    // Restore backup.\n    {\n      CollectionAdminRequest.Restore restore = CollectionAdminRequest.restoreCollection(restoreCollectionName, backupName)\n          .setLocation(backupLocation);\n//      if (replicaFailures) {\n//        // In this case one of the Solr servers would be down. Hence we need to increase\n//        // max_shards_per_node property for restore command to succeed.\n//        restore.setMaxShardsPerNode(2);\n//      }\n      if (random().nextBoolean()) {\n        assertEquals(0, restore.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, restore.processAndWait(solrClient, 30));//async\n      }\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(\n          restoreCollectionName, cluster.getSolrClient().getZkStateReader(), log.isDebugEnabled(), true, 30);\n      BackupRestoreUtils.verifyDocs(nDocs, solrClient, restoreCollectionName);\n    }\n\n    // Check collection property\n    Map<String, String> collectionProperties = solrClient.getZkStateReader().getCollectionProperties(restoreCollectionName);\n    if (collectionPropertySet) {\n      assertEquals(\"Snapshot restore hasn't restored collection properties\", \"test.value\", collectionProperties.get(\"test.property\"));\n    } else {\n      assertNull(\"Collection property shouldn't be present\", collectionProperties.get(\"test.property\"));\n    }\n\n    // Verify if the snapshot deletion works correctly when one or more replicas containing the snapshot are\n    // deleted\n    boolean replicaDeletion = rarely();\n    if (replicaDeletion) {\n      CoreSnapshotMetaData replicaToDelete = null;\n      for (String shardId : meta.getShards()) {\n        List<CoreSnapshotMetaData> replicas = meta.getReplicaSnapshotsForShard(shardId);\n        if (replicas.size() > 1) {\n          int r_index = random().nextInt(replicas.size());\n          replicaToDelete = replicas.get(r_index);\n        }\n      }\n\n      if (replicaToDelete != null) {\n        collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n        for (Slice s : collectionState.getSlices()) {\n          for (Replica r : s.getReplicas()) {\n            if (r.getCoreName().equals(replicaToDelete.getCoreName())) {\n              log.info(\"Deleting replica {}\", r);\n              CollectionAdminRequest.DeleteReplica delReplica = CollectionAdminRequest.deleteReplica(collectionName,\n                  replicaToDelete.getShardId(), r.getName());\n              delReplica.process(solrClient);\n              // The replica deletion will cleanup the snapshot meta-data.\n              snapshotByCoreName.remove(r.getCoreName());\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // Delete snapshot\n    CollectionAdminRequest.DeleteSnapshot deleteSnap = new CollectionAdminRequest.DeleteSnapshot(collectionName, commitName);\n    deleteSnap.process(solrClient);\n\n    // Wait for a while so that the cluster state updates are propagated to the client side.\n    Thread.sleep(2000);\n    collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot was not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertFalse(\"Snapshot not deleted for core \" + coreName, metaData.isPresent());\n          // Remove the entry for core if the snapshot is deleted successfully.\n          snapshotByCoreName.remove(coreName);\n        }\n      }\n    }\n\n    // Verify all core-level snapshots are deleted.\n    assertTrue(\"The cores remaining \" + snapshotByCoreName, snapshotByCoreName.isEmpty());\n    assertTrue(listCollectionSnapshots(solrClient, collectionName).isEmpty());\n\n    // Verify if the collection deletion result in proper cleanup of snapshot metadata.\n    {\n      String commitName_2 = commitName + \"_2\";\n\n      CollectionAdminRequest.CreateSnapshot createSnap_2 = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName_2);\n      assertEquals(0, createSnap_2.process(solrClient).getStatus());\n\n      Collection<CollectionSnapshotMetaData> collectionSnaps_2 = listCollectionSnapshots(solrClient, collectionName);\n      assertEquals(1, collectionSnaps.size());\n      assertEquals(commitName_2, collectionSnaps_2.iterator().next().getName());\n\n      // Delete collection\n      CollectionAdminRequest.Delete deleteCol = CollectionAdminRequest.deleteCollection(collectionName);\n      assertEquals(0, deleteCol.process(solrClient).getStatus());\n      assertTrue(SolrSnapshotManager.listSnapshots(solrClient.getZkStateReader().getZkClient(), collectionName).isEmpty());\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSnapshots() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String collectionName = \"SolrCloudSnapshots\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, \"conf1\", NUM_SHARDS, NUM_REPLICAS);\n    create.process(solrClient);\n    cluster.waitForActiveCollection(collectionName, NUM_SHARDS, NUM_SHARDS * NUM_REPLICAS);\n\n    int nDocs = BackupRestoreUtils.indexDocs(cluster.getSolrClient(), collectionName, docsSeed);\n    BackupRestoreUtils.verifyDocs(nDocs, solrClient, collectionName);\n\n    // Set a collection property\n    final boolean collectionPropertySet = usually();\n    if (collectionPropertySet) {\n      CollectionAdminRequest.CollectionProp setProperty = CollectionAdminRequest.setCollectionProperty(collectionName, \"test.property\", \"test.value\");\n      setProperty.process(solrClient);\n    }\n\n    String commitName = TestUtil.randomSimpleString(random(), 1, 5);\n\n    // Verify if snapshot creation works with replica failures.\n    boolean replicaFailures = usually();\n    Optional<String> stoppedCoreName = Optional.empty();\n    if (replicaFailures) {\n      // Here the assumption is that Solr will spread the replicas uniformly across nodes.\n      // If this is not true for some reason, then we will need to add some logic to find a\n      // node with a single replica.\n      cluster.getRandomJetty(random()).stop();\n\n      // Sleep a bit for allowing ZK watch to fire.\n      Thread.sleep(5000);\n\n      // Figure out if at-least one replica is \"down\".\n      DocCollection collState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n      for (Slice s : collState.getSlices()) {\n        for (Replica replica : s.getReplicas()) {\n          if (replica.getState() == State.DOWN) {\n            stoppedCoreName = Optional.of(replica.getCoreName());\n          }\n        }\n      }\n    }\n\n    int expectedCoresWithSnapshot = stoppedCoreName.isPresent() ? (NUM_SHARDS * NUM_REPLICAS) - 1 : (NUM_SHARDS * NUM_REPLICAS);\n\n    CollectionAdminRequest.CreateSnapshot createSnap = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName);\n    createSnap.process(solrClient);\n\n    Collection<CollectionSnapshotMetaData> collectionSnaps = listCollectionSnapshots(solrClient, collectionName);\n    assertEquals(1, collectionSnaps.size());\n    CollectionSnapshotMetaData meta = collectionSnaps.iterator().next();\n    assertEquals(commitName, meta.getName());\n    assertEquals(CollectionSnapshotMetaData.SnapshotStatus.Successful, meta.getStatus());\n    assertEquals(expectedCoresWithSnapshot, meta.getReplicaSnapshots().size());\n    Map<String, CoreSnapshotMetaData> snapshotByCoreName = meta.getReplicaSnapshots().stream()\n        .collect(Collectors.toMap(CoreSnapshotMetaData::getCoreName, Function.identity()));\n\n    DocCollection collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(2, collectionState.getActiveSlices().size());\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      assertEquals(2, shard.getReplicas().size());\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot is not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        assertTrue(snapshotByCoreName.containsKey(coreName));\n        CoreSnapshotMetaData coreSnapshot = snapshotByCoreName.get(coreName);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertTrue(\"Snapshot not created for core \" + coreName, metaData.isPresent());\n          assertEquals(coreSnapshot.getIndexDirPath(), metaData.get().getIndexDirPath());\n          assertEquals(coreSnapshot.getGenerationNumber(), metaData.get().getGenerationNumber());\n        }\n      }\n    }\n\n    // Delete all documents.\n    {\n      solrClient.deleteByQuery(collectionName, \"*:*\");\n      solrClient.commit(collectionName);\n      BackupRestoreUtils.verifyDocs(0, solrClient, collectionName);\n    }\n\n    String backupLocation = createTempDir().toFile().getAbsolutePath();\n    String backupName = \"mytestbackup\";\n    String restoreCollectionName = collectionName + \"_restored\";\n\n    //Create a backup using the earlier created snapshot.\n    {\n      CollectionAdminRequest.Backup backup = CollectionAdminRequest.backupCollection(collectionName, backupName)\n          .setLocation(backupLocation).setCommitName(commitName);\n      if (random().nextBoolean()) {\n        assertEquals(0, backup.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, backup.processAndWait(solrClient, 30));//async\n      }\n    }\n\n    // Restore backup.\n    {\n      CollectionAdminRequest.Restore restore = CollectionAdminRequest.restoreCollection(restoreCollectionName, backupName)\n          .setLocation(backupLocation);\n      if (replicaFailures) {\n        // In this case one of the Solr servers would be down. Hence we need to increase\n        // max_shards_per_node property for restore command to succeed.\n        restore.setMaxShardsPerNode(2);\n      }\n      if (random().nextBoolean()) {\n        assertEquals(0, restore.process(solrClient).getStatus());\n      } else {\n        assertEquals(RequestStatusState.COMPLETED, restore.processAndWait(solrClient, 30));//async\n      }\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(\n          restoreCollectionName, cluster.getSolrClient().getZkStateReader(), log.isDebugEnabled(), true, 30);\n      BackupRestoreUtils.verifyDocs(nDocs, solrClient, restoreCollectionName);\n    }\n\n    // Check collection property\n    Map<String, String> collectionProperties = solrClient.getZkStateReader().getCollectionProperties(restoreCollectionName);\n    if (collectionPropertySet) {\n      assertEquals(\"Snapshot restore hasn't restored collection properties\", \"test.value\", collectionProperties.get(\"test.property\"));\n    } else {\n      assertNull(\"Collection property shouldn't be present\", collectionProperties.get(\"test.property\"));\n    }\n\n    // Verify if the snapshot deletion works correctly when one or more replicas containing the snapshot are\n    // deleted\n    boolean replicaDeletion = rarely();\n    if (replicaDeletion) {\n      CoreSnapshotMetaData replicaToDelete = null;\n      for (String shardId : meta.getShards()) {\n        List<CoreSnapshotMetaData> replicas = meta.getReplicaSnapshotsForShard(shardId);\n        if (replicas.size() > 1) {\n          int r_index = random().nextInt(replicas.size());\n          replicaToDelete = replicas.get(r_index);\n        }\n      }\n\n      if (replicaToDelete != null) {\n        collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n        for (Slice s : collectionState.getSlices()) {\n          for (Replica r : s.getReplicas()) {\n            if (r.getCoreName().equals(replicaToDelete.getCoreName())) {\n              log.info(\"Deleting replica {}\", r);\n              CollectionAdminRequest.DeleteReplica delReplica = CollectionAdminRequest.deleteReplica(collectionName,\n                  replicaToDelete.getShardId(), r.getName());\n              delReplica.process(solrClient);\n              // The replica deletion will cleanup the snapshot meta-data.\n              snapshotByCoreName.remove(r.getCoreName());\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // Delete snapshot\n    CollectionAdminRequest.DeleteSnapshot deleteSnap = new CollectionAdminRequest.DeleteSnapshot(collectionName, commitName);\n    deleteSnap.process(solrClient);\n\n    // Wait for a while so that the cluster state updates are propagated to the client side.\n    Thread.sleep(2000);\n    collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n\n    for ( Slice shard : collectionState.getActiveSlices() ) {\n      for (Replica replica : shard.getReplicas()) {\n        if (stoppedCoreName.isPresent() && stoppedCoreName.get().equals(replica.getCoreName())) {\n          continue; // We know that the snapshot was not created for this replica.\n        }\n\n        String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n        String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        try (SolrClient adminClient = getHttpSolrClient(replicaBaseUrl)) {\n          Collection<SnapshotMetaData> snapshots = listCoreSnapshots(adminClient, coreName);\n          Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n          assertFalse(\"Snapshot not deleted for core \" + coreName, metaData.isPresent());\n          // Remove the entry for core if the snapshot is deleted successfully.\n          snapshotByCoreName.remove(coreName);\n        }\n      }\n    }\n\n    // Verify all core-level snapshots are deleted.\n    assertTrue(\"The cores remaining \" + snapshotByCoreName, snapshotByCoreName.isEmpty());\n    assertTrue(listCollectionSnapshots(solrClient, collectionName).isEmpty());\n\n    // Verify if the collection deletion result in proper cleanup of snapshot metadata.\n    {\n      String commitName_2 = commitName + \"_2\";\n\n      CollectionAdminRequest.CreateSnapshot createSnap_2 = new CollectionAdminRequest.CreateSnapshot(collectionName, commitName_2);\n      assertEquals(0, createSnap_2.process(solrClient).getStatus());\n\n      Collection<CollectionSnapshotMetaData> collectionSnaps_2 = listCollectionSnapshots(solrClient, collectionName);\n      assertEquals(1, collectionSnaps.size());\n      assertEquals(commitName_2, collectionSnaps_2.iterator().next().getName());\n\n      // Delete collection\n      CollectionAdminRequest.Delete deleteCol = CollectionAdminRequest.deleteCollection(collectionName);\n      assertEquals(0, deleteCol.process(solrClient).getStatus());\n      assertTrue(SolrSnapshotManager.listSnapshots(solrClient.getZkStateReader().getZkClient(), collectionName).isEmpty());\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"b31ebc7a867ddea79d438a8fca876a94e644d11a":["23ee9ee847c92f9e0395e1ff6655ec464e0a57a2","d18dd44acd824af8b51a5994c9475b32b094fb76"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["de3459a54b4c8751d9ef19b035577e2418064be7"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f","23ee9ee847c92f9e0395e1ff6655ec464e0a57a2"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["9dd6cf7e1b30a14801c9e290183b875c6801bbe9"],"9dd6cf7e1b30a14801c9e290183b875c6801bbe9":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"d18dd44acd824af8b51a5994c9475b32b094fb76":["23ee9ee847c92f9e0395e1ff6655ec464e0a57a2"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["23ee9ee847c92f9e0395e1ff6655ec464e0a57a2","d18dd44acd824af8b51a5994c9475b32b094fb76"],"de3459a54b4c8751d9ef19b035577e2418064be7":["d18dd44acd824af8b51a5994c9475b32b094fb76"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","424ac616f0aeeb2a3c8b6b94084255a0bcab9628"],"23ee9ee847c92f9e0395e1ff6655ec464e0a57a2":["424ac616f0aeeb2a3c8b6b94084255a0bcab9628"],"424ac616f0aeeb2a3c8b6b94084255a0bcab9628":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"]},"commit2Childs":{"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["9dd6cf7e1b30a14801c9e290183b875c6801bbe9"],"b31ebc7a867ddea79d438a8fca876a94e644d11a":[],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":[],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d18dd44acd824af8b51a5994c9475b32b094fb76":["b31ebc7a867ddea79d438a8fca876a94e644d11a","e9017cf144952056066919f1ebc7897ff9bd71b1","de3459a54b4c8751d9ef19b035577e2418064be7"],"9dd6cf7e1b30a14801c9e290183b875c6801bbe9":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"de3459a54b4c8751d9ef19b035577e2418064be7":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f","424ac616f0aeeb2a3c8b6b94084255a0bcab9628"],"23ee9ee847c92f9e0395e1ff6655ec464e0a57a2":["b31ebc7a867ddea79d438a8fca876a94e644d11a","7c3523a0ab04c3002eee3896c75ea5f10f388bcc","d18dd44acd824af8b51a5994c9475b32b094fb76","e9017cf144952056066919f1ebc7897ff9bd71b1"],"424ac616f0aeeb2a3c8b6b94084255a0bcab9628":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f","23ee9ee847c92f9e0395e1ff6655ec464e0a57a2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b31ebc7a867ddea79d438a8fca876a94e644d11a","7c3523a0ab04c3002eee3896c75ea5f10f388bcc","e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}