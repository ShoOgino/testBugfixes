{"path":"lucene/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFields#Lucene3xFields(Directory,FieldInfos,SegmentInfo,IOContext,int).mjava","commits":[{"id":"a0ae5e3ed1232483b7b8a014f175a5fe43595982","date":1324062192,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFields#Lucene3xFields(Directory,FieldInfos,SegmentInfo,IOContext,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/lucene3x/Lucene3xFields#Lucene3xFields(Directory,FieldInfos,SegmentInfo,IOContext,int).mjava","sourceNew":"  public Lucene3xFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, IOContext context, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, context, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.context = context;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.FREQ_EXTENSION), context);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (fi.indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.PROX_EXTENSION), context);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","sourceOld":"  public Lucene3xFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, IOContext context, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, context, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.context = context;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.FREQ_EXTENSION), context);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (fi.indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.PROX_EXTENSION), context);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFields#Lucene3xFields(Directory,FieldInfos,SegmentInfo,IOContext,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFields#Lucene3xFields(Directory,FieldInfos,SegmentInfo,IOContext,int).mjava","sourceNew":"  public Lucene3xFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, IOContext context, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, context, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.context = context;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.FREQ_EXTENSION), context);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (fi.indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.PROX_EXTENSION), context);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","sourceOld":"  public Lucene3xFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, IOContext context, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, context, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.context = context;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.FREQ_EXTENSION), context);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (fi.indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.PROX_EXTENSION), context);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}