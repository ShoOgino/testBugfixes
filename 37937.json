{"path":"solr/core/src/java/org/apache/solr/schema/SortableTextField#createFields(SchemaField,Object).mjava","commits":[{"id":"09db84b25dda87b73022d145a68f14c86a3a552d","date":1517506829,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/SortableTextField#createFields(SchemaField,Object).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public List<IndexableField> createFields(SchemaField field, Object value) {\n    IndexableField f = createField( field, value);\n    if (! field.hasDocValues()) {\n      return Collections.singletonList(f);\n    }\n    final String origString = value.toString();\n    final int origLegth = origString.length();\n    final boolean truncate = maxCharsForDocValues < origLegth;\n    if (field.useDocValuesAsStored() && truncate) {\n      // if the user has explicitly configured useDocValuesAsStored, we need a special\n      // check to fail docs where the values are too long -- we don't want to silently\n      // accept and then have search queries returning partial values\n      throw new SolrException\n        (SolrException.ErrorCode.BAD_REQUEST,\n         \"Can not use field \" + field.getName() + \" with values longer then maxCharsForDocValues=\" +\n         maxCharsForDocValues + \" when useDocValuesAsStored=true (length=\" + origLegth + \")\");\n    }\n    final BytesRef bytes = new BytesRef(truncate ? origString.subSequence(0, maxCharsForDocValues) : origString);\n                                        \n    final IndexableField docval = field.multiValued()\n      ? new SortedSetDocValuesField(field.getName(), bytes)\n      : new SortedDocValuesField(field.getName(), bytes);\n    \n    if (null == f) {\n      return Collections.singletonList(docval);\n    } \n    return Arrays.asList(f, docval);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d9f201f4a83c0b998ddd639fb08a61da2313bfa","date":1547001881,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/SortableTextField#createFields(SchemaField,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SortableTextField#createFields(SchemaField,Object).mjava","sourceNew":"  @Override\n  public List<IndexableField> createFields(SchemaField field, Object value) {\n    IndexableField f = createField( field, value);\n    if (! field.hasDocValues()) {\n      return Collections.singletonList(f);\n    }\n    if (value instanceof ByteArrayUtf8CharSequence) {\n      ByteArrayUtf8CharSequence utf8 = (ByteArrayUtf8CharSequence) value;\n      if (utf8.size() < maxCharsForDocValues) {\n        BytesRef bytes = new BytesRef(utf8.getBuf(), utf8.offset(), utf8.size());\n        return getIndexableFields(field, f, bytes);\n      }\n    }\n    final String origString = value.toString();\n    final int origLegth = origString.length();\n    final boolean truncate = maxCharsForDocValues < origLegth;\n    if (field.useDocValuesAsStored() && truncate) {\n      // if the user has explicitly configured useDocValuesAsStored, we need a special\n      // check to fail docs where the values are too long -- we don't want to silently\n      // accept and then have search queries returning partial values\n      throw new SolrException\n        (SolrException.ErrorCode.BAD_REQUEST,\n         \"Can not use field \" + field.getName() + \" with values longer then maxCharsForDocValues=\" +\n         maxCharsForDocValues + \" when useDocValuesAsStored=true (length=\" + origLegth + \")\");\n    }\n    final BytesRef bytes = new BytesRef(truncate ? origString.subSequence(0, maxCharsForDocValues) : origString);\n\n    return getIndexableFields(field, f, bytes);\n  }\n\n","sourceOld":"  @Override\n  public List<IndexableField> createFields(SchemaField field, Object value) {\n    IndexableField f = createField( field, value);\n    if (! field.hasDocValues()) {\n      return Collections.singletonList(f);\n    }\n    final String origString = value.toString();\n    final int origLegth = origString.length();\n    final boolean truncate = maxCharsForDocValues < origLegth;\n    if (field.useDocValuesAsStored() && truncate) {\n      // if the user has explicitly configured useDocValuesAsStored, we need a special\n      // check to fail docs where the values are too long -- we don't want to silently\n      // accept and then have search queries returning partial values\n      throw new SolrException\n        (SolrException.ErrorCode.BAD_REQUEST,\n         \"Can not use field \" + field.getName() + \" with values longer then maxCharsForDocValues=\" +\n         maxCharsForDocValues + \" when useDocValuesAsStored=true (length=\" + origLegth + \")\");\n    }\n    final BytesRef bytes = new BytesRef(truncate ? origString.subSequence(0, maxCharsForDocValues) : origString);\n                                        \n    final IndexableField docval = field.multiValued()\n      ? new SortedSetDocValuesField(field.getName(), bytes)\n      : new SortedDocValuesField(field.getName(), bytes);\n    \n    if (null == f) {\n      return Collections.singletonList(docval);\n    } \n    return Arrays.asList(f, docval);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"09db84b25dda87b73022d145a68f14c86a3a552d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4d9f201f4a83c0b998ddd639fb08a61da2313bfa":["09db84b25dda87b73022d145a68f14c86a3a552d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4d9f201f4a83c0b998ddd639fb08a61da2313bfa"]},"commit2Childs":{"09db84b25dda87b73022d145a68f14c86a3a552d":["4d9f201f4a83c0b998ddd639fb08a61da2313bfa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["09db84b25dda87b73022d145a68f14c86a3a552d"],"4d9f201f4a83c0b998ddd639fb08a61da2313bfa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}