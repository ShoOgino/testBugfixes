{"path":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedDeletes#FrozenBufferedDeletes(BufferedDeletes,boolean).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedDeletes#FrozenBufferedDeletes(BufferedDeletes,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/FrozenBufferedDeletes#FrozenBufferedDeletes(BufferedDeletes,boolean).mjava","sourceNew":"  public FrozenBufferedDeletes(BufferedDeletes deletes, boolean isSegmentPrivate) {\n    this.isSegmentPrivate = isSegmentPrivate;\n    assert !isSegmentPrivate || deletes.terms.size() == 0 : \"segment private package should only have del queries\"; \n    Term termsArray[] = deletes.terms.keySet().toArray(new Term[deletes.terms.size()]);\n    termCount = termsArray.length;\n    ArrayUtil.mergeSort(termsArray);\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    for (Term term : termsArray) {\n      builder.add(term);\n    }\n    terms = builder.finish();\n    \n    queries = new Query[deletes.queries.size()];\n    queryLimits = new int[deletes.queries.size()];\n    int upto = 0;\n    for(Map.Entry<Query,Integer> ent : deletes.queries.entrySet()) {\n      queries[upto] = ent.getKey();\n      queryLimits[upto] = ent.getValue();\n      upto++;\n    }\n\n    bytesUsed = (int) terms.getSizeInBytes() + queries.length * BYTES_PER_DEL_QUERY;\n    numTermDeletes = deletes.numTermDeletes.get();\n  }\n\n","sourceOld":"  public FrozenBufferedDeletes(BufferedDeletes deletes, boolean isSegmentPrivate) {\n    this.isSegmentPrivate = isSegmentPrivate;\n    assert !isSegmentPrivate || deletes.terms.size() == 0 : \"segment private package should only have del queries\"; \n    Term termsArray[] = deletes.terms.keySet().toArray(new Term[deletes.terms.size()]);\n    termCount = termsArray.length;\n    ArrayUtil.mergeSort(termsArray);\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    for (Term term : termsArray) {\n      builder.add(term);\n    }\n    terms = builder.finish();\n    \n    queries = new Query[deletes.queries.size()];\n    queryLimits = new int[deletes.queries.size()];\n    int upto = 0;\n    for(Map.Entry<Query,Integer> ent : deletes.queries.entrySet()) {\n      queries[upto] = ent.getKey();\n      queryLimits[upto] = ent.getValue();\n      upto++;\n    }\n\n    bytesUsed = (int) terms.getSizeInBytes() + queries.length * BYTES_PER_DEL_QUERY;\n    numTermDeletes = deletes.numTermDeletes.get();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dcc555744b1a581a4beccd0b75f8d3fe49735a2f","date":1367588265,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedDeletes#FrozenBufferedDeletes(BufferedDeletes,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedDeletes#FrozenBufferedDeletes(BufferedDeletes,boolean).mjava","sourceNew":"  public FrozenBufferedDeletes(BufferedDeletes deletes, boolean isSegmentPrivate) {\n    this.isSegmentPrivate = isSegmentPrivate;\n    assert !isSegmentPrivate || deletes.terms.size() == 0 : \"segment private package should only have del queries\"; \n    Term termsArray[] = deletes.terms.keySet().toArray(new Term[deletes.terms.size()]);\n    termCount = termsArray.length;\n    ArrayUtil.timSort(termsArray);\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    for (Term term : termsArray) {\n      builder.add(term);\n    }\n    terms = builder.finish();\n    \n    queries = new Query[deletes.queries.size()];\n    queryLimits = new int[deletes.queries.size()];\n    int upto = 0;\n    for(Map.Entry<Query,Integer> ent : deletes.queries.entrySet()) {\n      queries[upto] = ent.getKey();\n      queryLimits[upto] = ent.getValue();\n      upto++;\n    }\n\n    bytesUsed = (int) terms.getSizeInBytes() + queries.length * BYTES_PER_DEL_QUERY;\n    numTermDeletes = deletes.numTermDeletes.get();\n  }\n\n","sourceOld":"  public FrozenBufferedDeletes(BufferedDeletes deletes, boolean isSegmentPrivate) {\n    this.isSegmentPrivate = isSegmentPrivate;\n    assert !isSegmentPrivate || deletes.terms.size() == 0 : \"segment private package should only have del queries\"; \n    Term termsArray[] = deletes.terms.keySet().toArray(new Term[deletes.terms.size()]);\n    termCount = termsArray.length;\n    ArrayUtil.mergeSort(termsArray);\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    for (Term term : termsArray) {\n      builder.add(term);\n    }\n    terms = builder.finish();\n    \n    queries = new Query[deletes.queries.size()];\n    queryLimits = new int[deletes.queries.size()];\n    int upto = 0;\n    for(Map.Entry<Query,Integer> ent : deletes.queries.entrySet()) {\n      queries[upto] = ent.getKey();\n      queryLimits[upto] = ent.getValue();\n      upto++;\n    }\n\n    bytesUsed = (int) terms.getSizeInBytes() + queries.length * BYTES_PER_DEL_QUERY;\n    numTermDeletes = deletes.numTermDeletes.get();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e072d0b1fc19e0533d8ce432eed245196bca6fde","date":1379265112,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedDeletes#FrozenBufferedDeletes(BufferedDeletes,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedDeletes#FrozenBufferedDeletes(BufferedDeletes,boolean).mjava","sourceNew":"  public FrozenBufferedDeletes(BufferedDeletes deletes, boolean isSegmentPrivate) {\n    this.isSegmentPrivate = isSegmentPrivate;\n    assert !isSegmentPrivate || deletes.terms.size() == 0 : \"segment private package should only have del queries\"; \n    Term termsArray[] = deletes.terms.keySet().toArray(new Term[deletes.terms.size()]);\n    termCount = termsArray.length;\n    ArrayUtil.timSort(termsArray);\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    for (Term term : termsArray) {\n      builder.add(term);\n    }\n    terms = builder.finish();\n    \n    queries = new Query[deletes.queries.size()];\n    queryLimits = new int[deletes.queries.size()];\n    int upto = 0;\n    for(Map.Entry<Query,Integer> ent : deletes.queries.entrySet()) {\n      queries[upto] = ent.getKey();\n      queryLimits[upto] = ent.getValue();\n      upto++;\n    }\n\n    List<NumericUpdate> allUpdates = new ArrayList<NumericUpdate>();\n    int numericUpdatesSize = 0;\n    for (Map<String,NumericUpdate> fieldUpdates : deletes.numericUpdates.values()) {\n      for (NumericUpdate update : fieldUpdates.values()) {\n        allUpdates.add(update);\n        numericUpdatesSize += update.sizeInBytes();\n      }\n    }\n    updates = allUpdates.toArray(new NumericUpdate[allUpdates.size()]);\n    \n    bytesUsed = (int) terms.getSizeInBytes() + queries.length * BYTES_PER_DEL_QUERY + numericUpdatesSize + updates.length * RamUsageEstimator.NUM_BYTES_OBJECT_REF;\n    numTermDeletes = deletes.numTermDeletes.get();\n  }\n\n","sourceOld":"  public FrozenBufferedDeletes(BufferedDeletes deletes, boolean isSegmentPrivate) {\n    this.isSegmentPrivate = isSegmentPrivate;\n    assert !isSegmentPrivate || deletes.terms.size() == 0 : \"segment private package should only have del queries\"; \n    Term termsArray[] = deletes.terms.keySet().toArray(new Term[deletes.terms.size()]);\n    termCount = termsArray.length;\n    ArrayUtil.timSort(termsArray);\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    for (Term term : termsArray) {\n      builder.add(term);\n    }\n    terms = builder.finish();\n    \n    queries = new Query[deletes.queries.size()];\n    queryLimits = new int[deletes.queries.size()];\n    int upto = 0;\n    for(Map.Entry<Query,Integer> ent : deletes.queries.entrySet()) {\n      queries[upto] = ent.getKey();\n      queryLimits[upto] = ent.getValue();\n      upto++;\n    }\n\n    bytesUsed = (int) terms.getSizeInBytes() + queries.length * BYTES_PER_DEL_QUERY;\n    numTermDeletes = deletes.numTermDeletes.get();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1cff1deb788b9babb942b20707a93e1ab902ce37","date":1380805349,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedDeletes#FrozenBufferedDeletes(BufferedDeletes,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedDeletes#FrozenBufferedDeletes(BufferedDeletes,boolean).mjava","sourceNew":"  public FrozenBufferedDeletes(BufferedDeletes deletes, boolean isSegmentPrivate) {\n    this.isSegmentPrivate = isSegmentPrivate;\n    assert !isSegmentPrivate || deletes.terms.size() == 0 : \"segment private package should only have del queries\"; \n    Term termsArray[] = deletes.terms.keySet().toArray(new Term[deletes.terms.size()]);\n    termCount = termsArray.length;\n    ArrayUtil.timSort(termsArray);\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    for (Term term : termsArray) {\n      builder.add(term);\n    }\n    terms = builder.finish();\n    \n    queries = new Query[deletes.queries.size()];\n    queryLimits = new int[deletes.queries.size()];\n    int upto = 0;\n    for(Map.Entry<Query,Integer> ent : deletes.queries.entrySet()) {\n      queries[upto] = ent.getKey();\n      queryLimits[upto] = ent.getValue();\n      upto++;\n    }\n\n    // TODO if a Term affects multiple fields, we could keep the updates key'd by Term\n    // so that it maps to all fields it affects, sorted by their docUpto, and traverse\n    // that Term only once, applying the update to all fields that still need to be\n    // updated. \n    List<NumericUpdate> allUpdates = new ArrayList<NumericUpdate>();\n    int numericUpdatesSize = 0;\n    for (LinkedHashMap<Term,NumericUpdate> fieldUpdates : deletes.numericUpdates.values()) {\n      for (NumericUpdate update : fieldUpdates.values()) {\n        allUpdates.add(update);\n        numericUpdatesSize += update.sizeInBytes();\n      }\n    }\n    updates = allUpdates.toArray(new NumericUpdate[allUpdates.size()]);\n    \n    bytesUsed = (int) terms.getSizeInBytes() + queries.length * BYTES_PER_DEL_QUERY + numericUpdatesSize + updates.length * RamUsageEstimator.NUM_BYTES_OBJECT_REF;\n    numTermDeletes = deletes.numTermDeletes.get();\n  }\n\n","sourceOld":"  public FrozenBufferedDeletes(BufferedDeletes deletes, boolean isSegmentPrivate) {\n    this.isSegmentPrivate = isSegmentPrivate;\n    assert !isSegmentPrivate || deletes.terms.size() == 0 : \"segment private package should only have del queries\"; \n    Term termsArray[] = deletes.terms.keySet().toArray(new Term[deletes.terms.size()]);\n    termCount = termsArray.length;\n    ArrayUtil.timSort(termsArray);\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    for (Term term : termsArray) {\n      builder.add(term);\n    }\n    terms = builder.finish();\n    \n    queries = new Query[deletes.queries.size()];\n    queryLimits = new int[deletes.queries.size()];\n    int upto = 0;\n    for(Map.Entry<Query,Integer> ent : deletes.queries.entrySet()) {\n      queries[upto] = ent.getKey();\n      queryLimits[upto] = ent.getValue();\n      upto++;\n    }\n\n    List<NumericUpdate> allUpdates = new ArrayList<NumericUpdate>();\n    int numericUpdatesSize = 0;\n    for (Map<String,NumericUpdate> fieldUpdates : deletes.numericUpdates.values()) {\n      for (NumericUpdate update : fieldUpdates.values()) {\n        allUpdates.add(update);\n        numericUpdatesSize += update.sizeInBytes();\n      }\n    }\n    updates = allUpdates.toArray(new NumericUpdate[allUpdates.size()]);\n    \n    bytesUsed = (int) terms.getSizeInBytes() + queries.length * BYTES_PER_DEL_QUERY + numericUpdatesSize + updates.length * RamUsageEstimator.NUM_BYTES_OBJECT_REF;\n    numTermDeletes = deletes.numTermDeletes.get();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","date":1383367127,"type":5,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedUpdates#FrozenBufferedUpdates(BufferedUpdates,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedDeletes#FrozenBufferedDeletes(BufferedDeletes,boolean).mjava","sourceNew":"  public FrozenBufferedUpdates(BufferedUpdates deletes, boolean isSegmentPrivate) {\n    this.isSegmentPrivate = isSegmentPrivate;\n    assert !isSegmentPrivate || deletes.terms.size() == 0 : \"segment private package should only have del queries\"; \n    Term termsArray[] = deletes.terms.keySet().toArray(new Term[deletes.terms.size()]);\n    termCount = termsArray.length;\n    ArrayUtil.timSort(termsArray);\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    for (Term term : termsArray) {\n      builder.add(term);\n    }\n    terms = builder.finish();\n    \n    queries = new Query[deletes.queries.size()];\n    queryLimits = new int[deletes.queries.size()];\n    int upto = 0;\n    for(Map.Entry<Query,Integer> ent : deletes.queries.entrySet()) {\n      queries[upto] = ent.getKey();\n      queryLimits[upto] = ent.getValue();\n      upto++;\n    }\n\n    // TODO if a Term affects multiple fields, we could keep the updates key'd by Term\n    // so that it maps to all fields it affects, sorted by their docUpto, and traverse\n    // that Term only once, applying the update to all fields that still need to be\n    // updated. \n    List<NumericUpdate> allUpdates = new ArrayList<NumericUpdate>();\n    int numericUpdatesSize = 0;\n    for (LinkedHashMap<Term,NumericUpdate> fieldUpdates : deletes.numericUpdates.values()) {\n      for (NumericUpdate update : fieldUpdates.values()) {\n        allUpdates.add(update);\n        numericUpdatesSize += update.sizeInBytes();\n      }\n    }\n    updates = allUpdates.toArray(new NumericUpdate[allUpdates.size()]);\n    \n    bytesUsed = (int) terms.getSizeInBytes() + queries.length * BYTES_PER_DEL_QUERY + numericUpdatesSize + updates.length * RamUsageEstimator.NUM_BYTES_OBJECT_REF;\n    numTermDeletes = deletes.numTermDeletes.get();\n  }\n\n","sourceOld":"  public FrozenBufferedDeletes(BufferedDeletes deletes, boolean isSegmentPrivate) {\n    this.isSegmentPrivate = isSegmentPrivate;\n    assert !isSegmentPrivate || deletes.terms.size() == 0 : \"segment private package should only have del queries\"; \n    Term termsArray[] = deletes.terms.keySet().toArray(new Term[deletes.terms.size()]);\n    termCount = termsArray.length;\n    ArrayUtil.timSort(termsArray);\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    for (Term term : termsArray) {\n      builder.add(term);\n    }\n    terms = builder.finish();\n    \n    queries = new Query[deletes.queries.size()];\n    queryLimits = new int[deletes.queries.size()];\n    int upto = 0;\n    for(Map.Entry<Query,Integer> ent : deletes.queries.entrySet()) {\n      queries[upto] = ent.getKey();\n      queryLimits[upto] = ent.getValue();\n      upto++;\n    }\n\n    // TODO if a Term affects multiple fields, we could keep the updates key'd by Term\n    // so that it maps to all fields it affects, sorted by their docUpto, and traverse\n    // that Term only once, applying the update to all fields that still need to be\n    // updated. \n    List<NumericUpdate> allUpdates = new ArrayList<NumericUpdate>();\n    int numericUpdatesSize = 0;\n    for (LinkedHashMap<Term,NumericUpdate> fieldUpdates : deletes.numericUpdates.values()) {\n      for (NumericUpdate update : fieldUpdates.values()) {\n        allUpdates.add(update);\n        numericUpdatesSize += update.sizeInBytes();\n      }\n    }\n    updates = allUpdates.toArray(new NumericUpdate[allUpdates.size()]);\n    \n    bytesUsed = (int) terms.getSizeInBytes() + queries.length * BYTES_PER_DEL_QUERY + numericUpdatesSize + updates.length * RamUsageEstimator.NUM_BYTES_OBJECT_REF;\n    numTermDeletes = deletes.numTermDeletes.get();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e072d0b1fc19e0533d8ce432eed245196bca6fde":["dcc555744b1a581a4beccd0b75f8d3fe49735a2f"],"1cff1deb788b9babb942b20707a93e1ab902ce37":["e072d0b1fc19e0533d8ce432eed245196bca6fde"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["1cff1deb788b9babb942b20707a93e1ab902ce37"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"dcc555744b1a581a4beccd0b75f8d3fe49735a2f":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"]},"commit2Childs":{"e072d0b1fc19e0533d8ce432eed245196bca6fde":["1cff1deb788b9babb942b20707a93e1ab902ce37"],"1cff1deb788b9babb942b20707a93e1ab902ce37":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["dcc555744b1a581a4beccd0b75f8d3fe49735a2f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"dcc555744b1a581a4beccd0b75f8d3fe49735a2f":["e072d0b1fc19e0533d8ce432eed245196bca6fde"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}