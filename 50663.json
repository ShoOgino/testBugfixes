{"path":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudDistribCmdsTest#testThatCantForwardToLeaderFails().mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudDistribCmdsTest#testThatCantForwardToLeaderFails().mjava","pathOld":"/dev/null","sourceNew":"  private void testThatCantForwardToLeaderFails() throws InterruptedException,\n      Exception, TimeoutException, IOException, KeeperException {\n    ZkNodeProps props = zkStateReader.getLeaderProps(DEFAULT_COLLECTION, \"shard1\");\n    \n    chaosMonkey.stopShard(\"shard1\");\n\n    // fake that the leader is still advertised\n    String leaderPath = ZkStateReader.getShardLeadersPath(DEFAULT_COLLECTION, \"shard1\");\n    SolrZkClient zkClient = new SolrZkClient(zkServer.getZkAddress(), 10000);\n    int fails = 0;\n    try {\n      zkClient.makePath(leaderPath, ZkStateReader.toJSON(props),\n          CreateMode.EPHEMERAL, true);\n      for (int i = 200; i < 210; i++) {\n        try {\n          index_specific(cloudClient, id, i);\n        } catch (SolrException e) {\n          // expected\n          fails++;\n          break;\n        } catch (SolrServerException e) {\n          // expected\n          fails++;\n          break;\n        }\n      }\n    } finally {\n      zkClient.close();\n    }\n    \n    assertTrue(\"A whole shard is down - some of these should fail\", fails > 0);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudDistribCmdsTest#testThatCantForwardToLeaderFails().mjava","pathOld":"/dev/null","sourceNew":"  private void testThatCantForwardToLeaderFails() throws InterruptedException,\n      Exception, TimeoutException, IOException, KeeperException {\n    ZkNodeProps props = zkStateReader.getLeaderProps(DEFAULT_COLLECTION, \"shard1\");\n    \n    chaosMonkey.stopShard(\"shard1\");\n\n    // fake that the leader is still advertised\n    String leaderPath = ZkStateReader.getShardLeadersPath(DEFAULT_COLLECTION, \"shard1\");\n    SolrZkClient zkClient = new SolrZkClient(zkServer.getZkAddress(), 10000);\n    int fails = 0;\n    try {\n      zkClient.makePath(leaderPath, ZkStateReader.toJSON(props),\n          CreateMode.EPHEMERAL, true);\n      for (int i = 200; i < 210; i++) {\n        try {\n          index_specific(cloudClient, id, i);\n        } catch (SolrException e) {\n          // expected\n          fails++;\n          break;\n        } catch (SolrServerException e) {\n          // expected\n          fails++;\n          break;\n        }\n      }\n    } finally {\n      zkClient.close();\n    }\n    \n    assertTrue(\"A whole shard is down - some of these should fail\", fails > 0);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudDistribCmdsTest#testThatCantForwardToLeaderFails().mjava","pathOld":"/dev/null","sourceNew":"  private void testThatCantForwardToLeaderFails() throws InterruptedException,\n      Exception, TimeoutException, IOException, KeeperException {\n    ZkNodeProps props = zkStateReader.getLeaderProps(DEFAULT_COLLECTION, \"shard1\");\n    \n    chaosMonkey.stopShard(\"shard1\");\n\n    // fake that the leader is still advertised\n    String leaderPath = ZkStateReader.getShardLeadersPath(DEFAULT_COLLECTION, \"shard1\");\n    SolrZkClient zkClient = new SolrZkClient(zkServer.getZkAddress(), 10000);\n    int fails = 0;\n    try {\n      zkClient.makePath(leaderPath, ZkStateReader.toJSON(props),\n          CreateMode.EPHEMERAL, true);\n      for (int i = 200; i < 210; i++) {\n        try {\n          index_specific(cloudClient, id, i);\n        } catch (SolrException e) {\n          // expected\n          fails++;\n          break;\n        } catch (SolrServerException e) {\n          // expected\n          fails++;\n          break;\n        }\n      }\n    } finally {\n      zkClient.close();\n    }\n    \n    assertTrue(\"A whole shard is down - some of these should fail\", fails > 0);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudDistribCmdsTest#testThatCantForwardToLeaderFails().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudDistribCmdsTest#testThatCantForwardToLeaderFails().mjava","sourceNew":"  private void testThatCantForwardToLeaderFails() throws Exception {\n    ZkNodeProps props = zkStateReader.getLeaderProps(DEFAULT_COLLECTION, \"shard1\");\n    \n    chaosMonkey.stopShard(\"shard1\");\n\n    // fake that the leader is still advertised\n    String leaderPath = ZkStateReader.getShardLeadersPath(DEFAULT_COLLECTION, \"shard1\");\n    SolrZkClient zkClient = new SolrZkClient(zkServer.getZkAddress(), 10000);\n    int fails = 0;\n    try {\n      zkClient.makePath(leaderPath, ZkStateReader.toJSON(props),\n          CreateMode.EPHEMERAL, true);\n      for (int i = 200; i < 210; i++) {\n        try {\n          index_specific(cloudClient, id, i);\n        } catch (SolrException e) {\n          // expected\n          fails++;\n          break;\n        } catch (SolrServerException e) {\n          // expected\n          fails++;\n          break;\n        }\n      }\n    } finally {\n      zkClient.close();\n    }\n    \n    assertTrue(\"A whole shard is down - some of these should fail\", fails > 0);\n  }\n\n","sourceOld":"  private void testThatCantForwardToLeaderFails() throws InterruptedException,\n      Exception, TimeoutException, IOException, KeeperException {\n    ZkNodeProps props = zkStateReader.getLeaderProps(DEFAULT_COLLECTION, \"shard1\");\n    \n    chaosMonkey.stopShard(\"shard1\");\n\n    // fake that the leader is still advertised\n    String leaderPath = ZkStateReader.getShardLeadersPath(DEFAULT_COLLECTION, \"shard1\");\n    SolrZkClient zkClient = new SolrZkClient(zkServer.getZkAddress(), 10000);\n    int fails = 0;\n    try {\n      zkClient.makePath(leaderPath, ZkStateReader.toJSON(props),\n          CreateMode.EPHEMERAL, true);\n      for (int i = 200; i < 210; i++) {\n        try {\n          index_specific(cloudClient, id, i);\n        } catch (SolrException e) {\n          // expected\n          fails++;\n          break;\n        } catch (SolrServerException e) {\n          // expected\n          fails++;\n          break;\n        }\n      }\n    } finally {\n      zkClient.close();\n    }\n    \n    assertTrue(\"A whole shard is down - some of these should fail\", fails > 0);\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudDistribCmdsTest#testThatCantForwardToLeaderFails().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudDistribCmdsTest#testThatCantForwardToLeaderFails().mjava","sourceNew":"  private void testThatCantForwardToLeaderFails() throws Exception {\n    ZkNodeProps props = zkStateReader.getLeaderProps(DEFAULT_COLLECTION, \"shard1\");\n    \n    chaosMonkey.stopShard(\"shard1\");\n\n    // fake that the leader is still advertised\n    String leaderPath = ZkStateReader.getShardLeadersPath(DEFAULT_COLLECTION, \"shard1\");\n    SolrZkClient zkClient = new SolrZkClient(zkServer.getZkAddress(), 10000);\n    int fails = 0;\n    try {\n      zkClient.makePath(leaderPath, ZkStateReader.toJSON(props),\n          CreateMode.EPHEMERAL, true);\n      for (int i = 200; i < 210; i++) {\n        try {\n          index_specific(cloudClient, id, i);\n        } catch (SolrException e) {\n          // expected\n          fails++;\n          break;\n        } catch (SolrServerException e) {\n          // expected\n          fails++;\n          break;\n        }\n      }\n    } finally {\n      zkClient.close();\n    }\n    \n    assertTrue(\"A whole shard is down - some of these should fail\", fails > 0);\n  }\n\n","sourceOld":"  private void testThatCantForwardToLeaderFails() throws InterruptedException,\n      Exception, TimeoutException, IOException, KeeperException {\n    ZkNodeProps props = zkStateReader.getLeaderProps(DEFAULT_COLLECTION, \"shard1\");\n    \n    chaosMonkey.stopShard(\"shard1\");\n\n    // fake that the leader is still advertised\n    String leaderPath = ZkStateReader.getShardLeadersPath(DEFAULT_COLLECTION, \"shard1\");\n    SolrZkClient zkClient = new SolrZkClient(zkServer.getZkAddress(), 10000);\n    int fails = 0;\n    try {\n      zkClient.makePath(leaderPath, ZkStateReader.toJSON(props),\n          CreateMode.EPHEMERAL, true);\n      for (int i = 200; i < 210; i++) {\n        try {\n          index_specific(cloudClient, id, i);\n        } catch (SolrException e) {\n          // expected\n          fails++;\n          break;\n        } catch (SolrServerException e) {\n          // expected\n          fails++;\n          break;\n        }\n      }\n    } finally {\n      zkClient.close();\n    }\n    \n    assertTrue(\"A whole shard is down - some of these should fail\", fails > 0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9405f486872f1e416304dfe389741f4ee2f8a4d","date":1351276739,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudDistribCmdsTest#testThatCantForwardToLeaderFails().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudDistribCmdsTest#testThatCantForwardToLeaderFails().mjava","sourceNew":"  private void testThatCantForwardToLeaderFails() throws Exception {\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    ZkNodeProps props = zkStateReader.getLeaderProps(DEFAULT_COLLECTION, \"shard1\");\n    \n    chaosMonkey.stopShard(\"shard1\");\n\n    // fake that the leader is still advertised\n    String leaderPath = ZkStateReader.getShardLeadersPath(DEFAULT_COLLECTION, \"shard1\");\n    SolrZkClient zkClient = new SolrZkClient(zkServer.getZkAddress(), 10000);\n    int fails = 0;\n    try {\n      zkClient.makePath(leaderPath, ZkStateReader.toJSON(props),\n          CreateMode.EPHEMERAL, true);\n      for (int i = 200; i < 210; i++) {\n        try {\n          index_specific(cloudClient, id, i);\n        } catch (SolrException e) {\n          // expected\n          fails++;\n          break;\n        } catch (SolrServerException e) {\n          // expected\n          fails++;\n          break;\n        }\n      }\n    } finally {\n      zkClient.close();\n    }\n    \n    assertTrue(\"A whole shard is down - some of these should fail\", fails > 0);\n  }\n\n","sourceOld":"  private void testThatCantForwardToLeaderFails() throws Exception {\n    ZkNodeProps props = zkStateReader.getLeaderProps(DEFAULT_COLLECTION, \"shard1\");\n    \n    chaosMonkey.stopShard(\"shard1\");\n\n    // fake that the leader is still advertised\n    String leaderPath = ZkStateReader.getShardLeadersPath(DEFAULT_COLLECTION, \"shard1\");\n    SolrZkClient zkClient = new SolrZkClient(zkServer.getZkAddress(), 10000);\n    int fails = 0;\n    try {\n      zkClient.makePath(leaderPath, ZkStateReader.toJSON(props),\n          CreateMode.EPHEMERAL, true);\n      for (int i = 200; i < 210; i++) {\n        try {\n          index_specific(cloudClient, id, i);\n        } catch (SolrException e) {\n          // expected\n          fails++;\n          break;\n        } catch (SolrServerException e) {\n          // expected\n          fails++;\n          break;\n        }\n      }\n    } finally {\n      zkClient.close();\n    }\n    \n    assertTrue(\"A whole shard is down - some of these should fail\", fails > 0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f2126b84bd093fa3d921582a109a0ee578c28126","date":1351522501,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudDistribCmdsTest#testThatCantForwardToLeaderFails().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudDistribCmdsTest#testThatCantForwardToLeaderFails().mjava","sourceNew":"  private void testThatCantForwardToLeaderFails() throws Exception {\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    ZkNodeProps props = zkStateReader.getLeaderProps(DEFAULT_COLLECTION, \"shard1\");\n    \n    chaosMonkey.stopShard(\"shard1\");\n\n    // fake that the leader is still advertised\n    String leaderPath = ZkStateReader.getShardLeadersPath(DEFAULT_COLLECTION, \"shard1\");\n    SolrZkClient zkClient = new SolrZkClient(zkServer.getZkAddress(), 10000);\n    int fails = 0;\n    try {\n      zkClient.makePath(leaderPath, ZkStateReader.toJSON(props),\n          CreateMode.EPHEMERAL, true);\n      for (int i = 200; i < 210; i++) {\n        try {\n          index_specific(cloudClient, id, i);\n        } catch (SolrException e) {\n          // expected\n          fails++;\n          break;\n        } catch (SolrServerException e) {\n          // expected\n          fails++;\n          break;\n        }\n      }\n    } finally {\n      zkClient.close();\n    }\n    \n    assertTrue(\"A whole shard is down - some of these should fail\", fails > 0);\n  }\n\n","sourceOld":"  private void testThatCantForwardToLeaderFails() throws Exception {\n    ZkNodeProps props = zkStateReader.getLeaderProps(DEFAULT_COLLECTION, \"shard1\");\n    \n    chaosMonkey.stopShard(\"shard1\");\n\n    // fake that the leader is still advertised\n    String leaderPath = ZkStateReader.getShardLeadersPath(DEFAULT_COLLECTION, \"shard1\");\n    SolrZkClient zkClient = new SolrZkClient(zkServer.getZkAddress(), 10000);\n    int fails = 0;\n    try {\n      zkClient.makePath(leaderPath, ZkStateReader.toJSON(props),\n          CreateMode.EPHEMERAL, true);\n      for (int i = 200; i < 210; i++) {\n        try {\n          index_specific(cloudClient, id, i);\n        } catch (SolrException e) {\n          // expected\n          fails++;\n          break;\n        } catch (SolrServerException e) {\n          // expected\n          fails++;\n          break;\n        }\n      }\n    } finally {\n      zkClient.close();\n    }\n    \n    assertTrue(\"A whole shard is down - some of these should fail\", fails > 0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56a558aa5aadd60ae850d1ab090098bc63bdfaf9","date":1355245333,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudDistribCmdsTest#testThatCantForwardToLeaderFails().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudDistribCmdsTest#testThatCantForwardToLeaderFails().mjava","sourceNew":"  private void testThatCantForwardToLeaderFails() throws Exception {\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    ZkNodeProps props = zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard1\");\n    \n    chaosMonkey.stopShard(\"shard1\");\n\n    // fake that the leader is still advertised\n    String leaderPath = ZkStateReader.getShardLeadersPath(DEFAULT_COLLECTION, \"shard1\");\n    SolrZkClient zkClient = new SolrZkClient(zkServer.getZkAddress(), 10000);\n    int fails = 0;\n    try {\n      zkClient.makePath(leaderPath, ZkStateReader.toJSON(props),\n          CreateMode.EPHEMERAL, true);\n      for (int i = 200; i < 210; i++) {\n        try {\n          index_specific(cloudClient, id, i);\n        } catch (SolrException e) {\n          // expected\n          fails++;\n          break;\n        } catch (SolrServerException e) {\n          // expected\n          fails++;\n          break;\n        }\n      }\n    } finally {\n      zkClient.close();\n    }\n    \n    assertTrue(\"A whole shard is down - some of these should fail\", fails > 0);\n  }\n\n","sourceOld":"  private void testThatCantForwardToLeaderFails() throws Exception {\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    ZkNodeProps props = zkStateReader.getLeaderProps(DEFAULT_COLLECTION, \"shard1\");\n    \n    chaosMonkey.stopShard(\"shard1\");\n\n    // fake that the leader is still advertised\n    String leaderPath = ZkStateReader.getShardLeadersPath(DEFAULT_COLLECTION, \"shard1\");\n    SolrZkClient zkClient = new SolrZkClient(zkServer.getZkAddress(), 10000);\n    int fails = 0;\n    try {\n      zkClient.makePath(leaderPath, ZkStateReader.toJSON(props),\n          CreateMode.EPHEMERAL, true);\n      for (int i = 200; i < 210; i++) {\n        try {\n          index_specific(cloudClient, id, i);\n        } catch (SolrException e) {\n          // expected\n          fails++;\n          break;\n        } catch (SolrServerException e) {\n          // expected\n          fails++;\n          break;\n        }\n      }\n    } finally {\n      zkClient.close();\n    }\n    \n    assertTrue(\"A whole shard is down - some of these should fail\", fails > 0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudDistribCmdsTest#testThatCantForwardToLeaderFails().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudDistribCmdsTest#testThatCantForwardToLeaderFails().mjava","sourceNew":"  private void testThatCantForwardToLeaderFails() throws Exception {\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    ZkNodeProps props = zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard1\");\n    \n    chaosMonkey.stopShard(\"shard1\");\n\n    // fake that the leader is still advertised\n    String leaderPath = ZkStateReader.getShardLeadersPath(DEFAULT_COLLECTION, \"shard1\");\n    SolrZkClient zkClient = new SolrZkClient(zkServer.getZkAddress(), 10000);\n    int fails = 0;\n    try {\n      zkClient.makePath(leaderPath, ZkStateReader.toJSON(props),\n          CreateMode.EPHEMERAL, true);\n      for (int i = 200; i < 210; i++) {\n        try {\n          index_specific(cloudClient, id, i);\n        } catch (SolrException e) {\n          // expected\n          fails++;\n          break;\n        } catch (SolrServerException e) {\n          // expected\n          fails++;\n          break;\n        }\n      }\n    } finally {\n      zkClient.close();\n    }\n    \n    assertTrue(\"A whole shard is down - some of these should fail\", fails > 0);\n  }\n\n","sourceOld":"  private void testThatCantForwardToLeaderFails() throws Exception {\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    ZkNodeProps props = zkStateReader.getLeaderProps(DEFAULT_COLLECTION, \"shard1\");\n    \n    chaosMonkey.stopShard(\"shard1\");\n\n    // fake that the leader is still advertised\n    String leaderPath = ZkStateReader.getShardLeadersPath(DEFAULT_COLLECTION, \"shard1\");\n    SolrZkClient zkClient = new SolrZkClient(zkServer.getZkAddress(), 10000);\n    int fails = 0;\n    try {\n      zkClient.makePath(leaderPath, ZkStateReader.toJSON(props),\n          CreateMode.EPHEMERAL, true);\n      for (int i = 200; i < 210; i++) {\n        try {\n          index_specific(cloudClient, id, i);\n        } catch (SolrException e) {\n          // expected\n          fails++;\n          break;\n        } catch (SolrServerException e) {\n          // expected\n          fails++;\n          break;\n        }\n      }\n    } finally {\n      zkClient.close();\n    }\n    \n    assertTrue(\"A whole shard is down - some of these should fail\", fails > 0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ca2b77e0c13ce25852abbdf65e17a1f2bb003cb","date":1390584048,"type":5,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudDistribCmdsTest#testThatCantForwardToLeaderFails(long).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudDistribCmdsTest#testThatCantForwardToLeaderFails().mjava","sourceNew":"  private long testThatCantForwardToLeaderFails(long docId) throws Exception {\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    ZkNodeProps props = zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard1\");\n    \n    chaosMonkey.stopShard(\"shard1\");\n    \n    Thread.sleep(1000);\n    \n    // fake that the leader is still advertised\n    String leaderPath = ZkStateReader.getShardLeadersPath(DEFAULT_COLLECTION, \"shard1\");\n    SolrZkClient zkClient = new SolrZkClient(zkServer.getZkAddress(), 10000);\n    int fails = 0;\n    try {\n      zkClient.makePath(leaderPath, ZkStateReader.toJSON(props),\n          CreateMode.EPHEMERAL, true);\n      for (int i = 0; i < 200; i++) {\n        try {\n          index_specific(shardToJetty.get(\"shard2\").get(0).client.solrClient, id, docId++);\n        } catch (SolrException e) {\n          // expected\n          fails++;\n          break;\n        } catch (SolrServerException e) {\n          // expected\n          fails++;\n          break;\n        }\n      }\n    } finally {\n      zkClient.close();\n    }\n\n    assertTrue(\"A whole shard is down - some of these should fail\", fails > 0);\n    return docId;\n  }\n\n","sourceOld":"  private void testThatCantForwardToLeaderFails() throws Exception {\n    ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n    ZkNodeProps props = zkStateReader.getLeaderRetry(DEFAULT_COLLECTION, \"shard1\");\n    \n    chaosMonkey.stopShard(\"shard1\");\n\n    // fake that the leader is still advertised\n    String leaderPath = ZkStateReader.getShardLeadersPath(DEFAULT_COLLECTION, \"shard1\");\n    SolrZkClient zkClient = new SolrZkClient(zkServer.getZkAddress(), 10000);\n    int fails = 0;\n    try {\n      zkClient.makePath(leaderPath, ZkStateReader.toJSON(props),\n          CreateMode.EPHEMERAL, true);\n      for (int i = 200; i < 210; i++) {\n        try {\n          index_specific(cloudClient, id, i);\n        } catch (SolrException e) {\n          // expected\n          fails++;\n          break;\n        } catch (SolrServerException e) {\n          // expected\n          fails++;\n          break;\n        }\n      }\n    } finally {\n      zkClient.close();\n    }\n    \n    assertTrue(\"A whole shard is down - some of these should fail\", fails > 0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a29b6e8b148762c68adf55b9d2c2aa5ae411a5b","date":1576537086,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudDistribCmdsTest#testThatCantForwardToLeaderFails().mjava","pathOld":"/dev/null","sourceNew":"  public void testThatCantForwardToLeaderFails() throws Exception {\n    final CloudSolrClient cloudClient = cluster.getSolrClient();\n    final String collectionName = \"test_collection_\" + NAME_COUNTER.getAndIncrement();\n    cloudClient.setDefaultCollection(collectionName);\n    \n    // get a random node for use in our collection before creating the one we'll partition..\n    final JettySolrRunner otherLeader = cluster.getRandomJetty(random());\n    // pick a (second) random node (which may be the same) for sending updates to\n    // (if it's the same, we're testing routing from another shard, if diff we're testing routing\n    // from a non-collection node)\n    final String indexingUrl = cluster.getRandomJetty(random()).getProxyBaseUrl() + \"/\" + collectionName;\n\n    // create a new node for the purpose of killing it...\n    final JettySolrRunner leaderToPartition = cluster.startJettySolrRunner();\n    try {\n      cluster.waitForNode(leaderToPartition, DEFAULT_TIMEOUT);\n\n      // HACK: we have to stop the node in order to enable the proxy, in order to then restart the node\n      // (in order to then \"partition it\" later via the proxy)\n      final SocketProxy proxy = new SocketProxy();\n      cluster.stopJettySolrRunner(leaderToPartition);\n      cluster.waitForJettyToStop(leaderToPartition);\n      leaderToPartition.setProxyPort(proxy.getListenPort());\n      cluster.startJettySolrRunner(leaderToPartition);\n      proxy.open(leaderToPartition.getBaseUrl().toURI());\n      try {\n        log.info(\"leaderToPartition's Proxy: {}\", proxy);\n        \n        cluster.waitForNode(leaderToPartition, DEFAULT_TIMEOUT);\n        // create a 2x1 collection using a nodeSet that includes our leaderToPartition...\n        assertEquals(RequestStatusState.COMPLETED,\n                     CollectionAdminRequest.createCollection(collectionName, 2, 1)\n                     .setCreateNodeSet(leaderToPartition.getNodeName() + \",\" + otherLeader.getNodeName())\n                     .processAndWait(cloudClient, DEFAULT_TIMEOUT));\n        \n        cloudClient.waitForState(collectionName, DEFAULT_TIMEOUT, TimeUnit.SECONDS,\n                                 (n, c) -> DocCollection.isFullyActive(n, c, 2, 1));\n        \n        { // HACK: Check the leaderProps for the shard hosted on the node we're going to kill...\n          final Replica leaderProps = cloudClient.getZkStateReader()\n            .getClusterState().getCollection(collectionName)\n            .getLeaderReplicas(leaderToPartition.getNodeName()).get(0);\n          \n          // No point in this test if these aren't true...\n          assertNotNull(\"Sanity check: leaderProps isn't a leader?: \" + leaderProps.toString(),\n                        leaderProps.getStr(Slice.LEADER));\n          assertTrue(\"Sanity check: leaderProps isn't using the proxy port?: \" + leaderProps.toString(),\n                     leaderProps.getCoreUrl().contains(\"\"+proxy.getListenPort()));\n        }\n        \n        // create client to send our updates to...\n        try (HttpSolrClient indexClient = getHttpSolrClient(indexingUrl)) {\n          \n          // Sanity check: we should be able to send a bunch of updates that work right now...\n          for (int i = 0; i < 100; i++) {\n            final UpdateResponse rsp = indexClient.add\n              (sdoc(\"id\", i, \"text_t\", TestUtil.randomRealisticUnicodeString(random(), 200)));\n            assertEquals(0, rsp.getStatus());\n          }\n\n          log.info(\"Closing leaderToPartition's proxy: {}\", proxy);\n          proxy.close(); // NOTE: can't use halfClose, won't ensure a garunteed failure\n          \n          final SolrException e = expectThrows(SolrException.class, () -> {\n              // start at 50 so that we have some \"updates\" to previous docs and some \"adds\"...\n              for (int i = 50; i < 250; i++) {\n                // Pure random odds of all of these docs belonging to the live shard are 1 in 2**200...\n                // Except we know the hashing algorithm isn't purely random,\n                // So the actual odds are \"0\" unless the hashing algorithm is changed to suck badly...\n                final UpdateResponse rsp = indexClient.add\n                (sdoc(\"id\", i, \"text_t\", TestUtil.randomRealisticUnicodeString(random(), 200)));\n                // if the update didn't throw an exception, it better be a success..\n                assertEquals(0, rsp.getStatus());\n              }\n            });\n          assertEquals(500, e.code());\n        }\n      } finally {\n        proxy.close(); // don't leak this port\n      }\n    } finally {\n      cluster.stopJettySolrRunner(leaderToPartition); // don't let this jetty bleed into other tests\n      cluster.waitForJettyToStop(leaderToPartition);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b945b8f5bba0303382bc69d60c0c287714f23328","date":1576586294,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudDistribCmdsTest#testThatCantForwardToLeaderFails().mjava","pathOld":"/dev/null","sourceNew":"  public void testThatCantForwardToLeaderFails() throws Exception {\n    final CloudSolrClient cloudClient = cluster.getSolrClient();\n    final String collectionName = \"test_collection_\" + NAME_COUNTER.getAndIncrement();\n    cloudClient.setDefaultCollection(collectionName);\n    \n    // get a random node for use in our collection before creating the one we'll partition..\n    final JettySolrRunner otherLeader = cluster.getRandomJetty(random());\n    // pick a (second) random node (which may be the same) for sending updates to\n    // (if it's the same, we're testing routing from another shard, if diff we're testing routing\n    // from a non-collection node)\n    final String indexingUrl = cluster.getRandomJetty(random()).getProxyBaseUrl() + \"/\" + collectionName;\n\n    // create a new node for the purpose of killing it...\n    final JettySolrRunner leaderToPartition = cluster.startJettySolrRunner();\n    try {\n      cluster.waitForNode(leaderToPartition, DEFAULT_TIMEOUT);\n\n      // HACK: we have to stop the node in order to enable the proxy, in order to then restart the node\n      // (in order to then \"partition it\" later via the proxy)\n      final SocketProxy proxy = new SocketProxy();\n      cluster.stopJettySolrRunner(leaderToPartition);\n      cluster.waitForJettyToStop(leaderToPartition);\n      leaderToPartition.setProxyPort(proxy.getListenPort());\n      cluster.startJettySolrRunner(leaderToPartition);\n      proxy.open(leaderToPartition.getBaseUrl().toURI());\n      try {\n        log.info(\"leaderToPartition's Proxy: {}\", proxy);\n        \n        cluster.waitForNode(leaderToPartition, DEFAULT_TIMEOUT);\n        // create a 2x1 collection using a nodeSet that includes our leaderToPartition...\n        assertEquals(RequestStatusState.COMPLETED,\n                     CollectionAdminRequest.createCollection(collectionName, 2, 1)\n                     .setCreateNodeSet(leaderToPartition.getNodeName() + \",\" + otherLeader.getNodeName())\n                     .processAndWait(cloudClient, DEFAULT_TIMEOUT));\n        \n        cloudClient.waitForState(collectionName, DEFAULT_TIMEOUT, TimeUnit.SECONDS,\n                                 (n, c) -> DocCollection.isFullyActive(n, c, 2, 1));\n        \n        { // HACK: Check the leaderProps for the shard hosted on the node we're going to kill...\n          final Replica leaderProps = cloudClient.getZkStateReader()\n            .getClusterState().getCollection(collectionName)\n            .getLeaderReplicas(leaderToPartition.getNodeName()).get(0);\n          \n          // No point in this test if these aren't true...\n          assertNotNull(\"Sanity check: leaderProps isn't a leader?: \" + leaderProps.toString(),\n                        leaderProps.getStr(Slice.LEADER));\n          assertTrue(\"Sanity check: leaderProps isn't using the proxy port?: \" + leaderProps.toString(),\n                     leaderProps.getCoreUrl().contains(\"\"+proxy.getListenPort()));\n        }\n        \n        // create client to send our updates to...\n        try (HttpSolrClient indexClient = getHttpSolrClient(indexingUrl)) {\n          \n          // Sanity check: we should be able to send a bunch of updates that work right now...\n          for (int i = 0; i < 100; i++) {\n            final UpdateResponse rsp = indexClient.add\n              (sdoc(\"id\", i, \"text_t\", TestUtil.randomRealisticUnicodeString(random(), 200)));\n            assertEquals(0, rsp.getStatus());\n          }\n\n          log.info(\"Closing leaderToPartition's proxy: {}\", proxy);\n          proxy.close(); // NOTE: can't use halfClose, won't ensure a garunteed failure\n          \n          final SolrException e = expectThrows(SolrException.class, () -> {\n              // start at 50 so that we have some \"updates\" to previous docs and some \"adds\"...\n              for (int i = 50; i < 250; i++) {\n                // Pure random odds of all of these docs belonging to the live shard are 1 in 2**200...\n                // Except we know the hashing algorithm isn't purely random,\n                // So the actual odds are \"0\" unless the hashing algorithm is changed to suck badly...\n                final UpdateResponse rsp = indexClient.add\n                (sdoc(\"id\", i, \"text_t\", TestUtil.randomRealisticUnicodeString(random(), 200)));\n                // if the update didn't throw an exception, it better be a success..\n                assertEquals(0, rsp.getStatus());\n              }\n            });\n          assertEquals(500, e.code());\n        }\n      } finally {\n        proxy.close(); // don't leak this port\n      }\n    } finally {\n      cluster.stopJettySolrRunner(leaderToPartition); // don't let this jetty bleed into other tests\n      cluster.waitForJettyToStop(leaderToPartition);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0ca2b77e0c13ce25852abbdf65e17a1f2bb003cb":["56a558aa5aadd60ae850d1ab090098bc63bdfaf9"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["d9405f486872f1e416304dfe389741f4ee2f8a4d","56a558aa5aadd60ae850d1ab090098bc63bdfaf9"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"b945b8f5bba0303382bc69d60c0c287714f23328":["0ca2b77e0c13ce25852abbdf65e17a1f2bb003cb","0a29b6e8b148762c68adf55b9d2c2aa5ae411a5b"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"f2126b84bd093fa3d921582a109a0ee578c28126":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","d9405f486872f1e416304dfe389741f4ee2f8a4d"],"56a558aa5aadd60ae850d1ab090098bc63bdfaf9":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0a29b6e8b148762c68adf55b9d2c2aa5ae411a5b"],"0a29b6e8b148762c68adf55b9d2c2aa5ae411a5b":["0ca2b77e0c13ce25852abbdf65e17a1f2bb003cb"]},"commit2Childs":{"0ca2b77e0c13ce25852abbdf65e17a1f2bb003cb":["b945b8f5bba0303382bc69d60c0c287714f23328","0a29b6e8b148762c68adf55b9d2c2aa5ae411a5b"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","f2126b84bd093fa3d921582a109a0ee578c28126","56a558aa5aadd60ae850d1ab090098bc63bdfaf9"],"b945b8f5bba0303382bc69d60c0c287714f23328":[],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","fe33227f6805edab2036cbb80645cc4e2d1fa424","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["d9405f486872f1e416304dfe389741f4ee2f8a4d","fe33227f6805edab2036cbb80645cc4e2d1fa424","f2126b84bd093fa3d921582a109a0ee578c28126"],"f2126b84bd093fa3d921582a109a0ee578c28126":[],"56a558aa5aadd60ae850d1ab090098bc63bdfaf9":["0ca2b77e0c13ce25852abbdf65e17a1f2bb003cb","d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"0a29b6e8b148762c68adf55b9d2c2aa5ae411a5b":["b945b8f5bba0303382bc69d60c0c287714f23328","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","b945b8f5bba0303382bc69d60c0c287714f23328","0d22ac6a4146774c1bc8400160fc0b6150294e92","fe33227f6805edab2036cbb80645cc4e2d1fa424","f2126b84bd093fa3d921582a109a0ee578c28126","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}