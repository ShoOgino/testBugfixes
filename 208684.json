{"path":"solr/test-framework/src/java/org/apache/solr/SolrTestCaseJ4#json(SolrInputDocument,CharArr).mjava","commits":[{"id":"9a862f08ffeb00b03b4c641de86b167b1d6f7cd1","date":1402094642,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/SolrTestCaseJ4#json(SolrInputDocument,CharArr).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Appends to the <code>out</code> array with JSON from the <code>doc</code>.\n   * Doesn't currently handle boosts, but does recursively handle child documents\n   */\n  public static void json(SolrInputDocument doc, CharArr out) {\n    try {\n      out.append('{');\n      boolean firstField = true;\n      for (SolrInputField sfield : doc) {\n        if (firstField) firstField=false;\n        else out.append(',');\n        JSONUtil.writeString(sfield.getName(), 0, sfield.getName().length(), out);\n        out.append(':');\n\n        if (sfield.getValueCount() > 1) {\n          out.append('[');\n          boolean firstVal = true;\n          for (Object val : sfield) {\n            if (firstVal) firstVal=false;\n            else out.append(',');\n            out.append(JSONUtil.toJSON(val));\n          }\n          out.append(']');\n        } else {\n          out.append(JSONUtil.toJSON(sfield.getValue()));\n        }\n      }\n\n      boolean firstChildDoc = true;\n      if(doc.hasChildDocuments()) {\n        out.append(\",\\\"_childDocuments_\\\": [\");\n        List<SolrInputDocument> childDocuments = doc.getChildDocuments();\n        for(SolrInputDocument childDocument : childDocuments) {\n          if (firstChildDoc) firstChildDoc=false;\n          else out.append(',');\n          json(childDocument, out);\n        }\n        out.append(']');\n      }\n      out.append('}');\n    } catch (IOException e) {\n      // should never happen\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07749612bed4eb54dd05255c1434c301133310c1","date":1554879779,"type":3,"author":"Moshe","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/SolrTestCaseJ4#json(SolrInputDocument,CharArr).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/SolrTestCaseJ4#json(SolrInputDocument,CharArr).mjava","sourceNew":"  /**\n   * Appends to the <code>out</code> array with JSON from the <code>doc</code>.\n   * Doesn't currently handle boosts, but does recursively handle child documents\n   */\n  public static void json(SolrInputDocument doc, CharArr out) {\n    try {\n      out.append('{');\n      boolean firstField = true;\n      for (SolrInputField sfield : doc) {\n        if (firstField) firstField=false;\n        else out.append(',');\n        JSONUtil.writeString(sfield.getName(), 0, sfield.getName().length(), out);\n        out.append(':');\n\n        if (sfield.getValueCount() > 1) {\n          out.append('[');\n          boolean firstVal = true;\n          for (Object val : sfield) {\n            if (firstVal) firstVal=false;\n            else out.append(',');\n            if(val instanceof SolrInputDocument) {\n              json((SolrInputDocument) val, out);\n            }\n            out.append(JSONUtil.toJSON(val));\n          }\n          out.append(']');\n        } else if(sfield.getValue() instanceof SolrInputDocument) {\n          json((SolrInputDocument) sfield.getValue(), out);\n        } else if (sfield.getValue() instanceof Map) {\n          Map<String, Object> valMap = (Map<String, Object>) sfield.getValue();\n          Set<String> childDocsKeys = valMap.entrySet().stream().filter(record -> isChildDoc(record.getValue()))\n              .map(Entry::getKey).collect(Collectors.toSet());\n          if(childDocsKeys.size() > 0) {\n            Map<String, Object> newMap = new HashMap<>();\n            for(Entry<String, Object> entry: valMap.entrySet()) {\n              String keyName = entry.getKey();\n              Object val = entry.getValue();\n              if(childDocsKeys.contains(keyName)) {\n                if(val instanceof Collection) {\n                  val = ((Collection) val).stream().map(e -> toSolrDoc((SolrInputDocument) e)).collect(Collectors.toList());\n                } else {\n                  val = toSolrDoc((SolrInputDocument) val);\n                }\n              }\n              newMap.put(keyName, val);\n            }\n            valMap = newMap;\n          }\n          out.append(JSONUtil.toJSON(valMap));\n        } else {\n          out.append(JSONUtil.toJSON(sfield.getValue()));\n        }\n      }\n\n      boolean firstChildDoc = true;\n      if(doc.hasChildDocuments()) {\n        out.append(\",\\\"_childDocuments_\\\": [\");\n        List<SolrInputDocument> childDocuments = doc.getChildDocuments();\n        for(SolrInputDocument childDocument : childDocuments) {\n          if (firstChildDoc) firstChildDoc=false;\n          else out.append(',');\n          json(childDocument, out);\n        }\n        out.append(']');\n      }\n      out.append('}');\n    } catch (IOException e) {\n      // should never happen\n    }\n  }\n\n","sourceOld":"  /**\n   * Appends to the <code>out</code> array with JSON from the <code>doc</code>.\n   * Doesn't currently handle boosts, but does recursively handle child documents\n   */\n  public static void json(SolrInputDocument doc, CharArr out) {\n    try {\n      out.append('{');\n      boolean firstField = true;\n      for (SolrInputField sfield : doc) {\n        if (firstField) firstField=false;\n        else out.append(',');\n        JSONUtil.writeString(sfield.getName(), 0, sfield.getName().length(), out);\n        out.append(':');\n\n        if (sfield.getValueCount() > 1) {\n          out.append('[');\n          boolean firstVal = true;\n          for (Object val : sfield) {\n            if (firstVal) firstVal=false;\n            else out.append(',');\n            out.append(JSONUtil.toJSON(val));\n          }\n          out.append(']');\n        } else {\n          out.append(JSONUtil.toJSON(sfield.getValue()));\n        }\n      }\n\n      boolean firstChildDoc = true;\n      if(doc.hasChildDocuments()) {\n        out.append(\",\\\"_childDocuments_\\\": [\");\n        List<SolrInputDocument> childDocuments = doc.getChildDocuments();\n        for(SolrInputDocument childDocument : childDocuments) {\n          if (firstChildDoc) firstChildDoc=false;\n          else out.append(',');\n          json(childDocument, out);\n        }\n        out.append(']');\n      }\n      out.append('}');\n    } catch (IOException e) {\n      // should never happen\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6809a6d7924df2c864d6a5863944aff9dfeb372c","date":1591826750,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/SolrTestCaseJ4#json(SolrInputDocument,CharArr).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/SolrTestCaseJ4#json(SolrInputDocument,CharArr).mjava","sourceNew":"  /**\n   * Appends to the <code>out</code> array with JSON from the <code>doc</code>.\n   * Doesn't currently handle boosts, but does recursively handle child documents\n   */\n  @SuppressWarnings({\"unchecked\"})\n  public static void json(SolrInputDocument doc, CharArr out) {\n    try {\n      out.append('{');\n      boolean firstField = true;\n      for (SolrInputField sfield : doc) {\n        if (firstField) firstField=false;\n        else out.append(',');\n        JSONUtil.writeString(sfield.getName(), 0, sfield.getName().length(), out);\n        out.append(':');\n\n        if (sfield.getValueCount() > 1) {\n          out.append('[');\n          boolean firstVal = true;\n          for (Object val : sfield) {\n            if (firstVal) firstVal=false;\n            else out.append(',');\n            if(val instanceof SolrInputDocument) {\n              json((SolrInputDocument) val, out);\n            }\n            out.append(JSONUtil.toJSON(val));\n          }\n          out.append(']');\n        } else if(sfield.getValue() instanceof SolrInputDocument) {\n          json((SolrInputDocument) sfield.getValue(), out);\n        } else if (sfield.getValue() instanceof Map) {\n          Map<String, Object> valMap = (Map<String, Object>) sfield.getValue();\n          Set<String> childDocsKeys = valMap.entrySet().stream().filter(record -> isChildDoc(record.getValue()))\n              .map(Entry::getKey).collect(Collectors.toSet());\n          if(childDocsKeys.size() > 0) {\n            Map<String, Object> newMap = new HashMap<>();\n            for(Entry<String, Object> entry: valMap.entrySet()) {\n              String keyName = entry.getKey();\n              Object val = entry.getValue();\n              if(childDocsKeys.contains(keyName)) {\n                if(val instanceof Collection) {\n                  val = ((Collection) val).stream().map(e -> toSolrDoc((SolrInputDocument) e)).collect(Collectors.toList());\n                } else {\n                  val = toSolrDoc((SolrInputDocument) val);\n                }\n              }\n              newMap.put(keyName, val);\n            }\n            valMap = newMap;\n          }\n          out.append(JSONUtil.toJSON(valMap));\n        } else {\n          out.append(JSONUtil.toJSON(sfield.getValue()));\n        }\n      }\n\n      boolean firstChildDoc = true;\n      if(doc.hasChildDocuments()) {\n        out.append(\",\\\"_childDocuments_\\\": [\");\n        List<SolrInputDocument> childDocuments = doc.getChildDocuments();\n        for(SolrInputDocument childDocument : childDocuments) {\n          if (firstChildDoc) firstChildDoc=false;\n          else out.append(',');\n          json(childDocument, out);\n        }\n        out.append(']');\n      }\n      out.append('}');\n    } catch (IOException e) {\n      // should never happen\n    }\n  }\n\n","sourceOld":"  /**\n   * Appends to the <code>out</code> array with JSON from the <code>doc</code>.\n   * Doesn't currently handle boosts, but does recursively handle child documents\n   */\n  public static void json(SolrInputDocument doc, CharArr out) {\n    try {\n      out.append('{');\n      boolean firstField = true;\n      for (SolrInputField sfield : doc) {\n        if (firstField) firstField=false;\n        else out.append(',');\n        JSONUtil.writeString(sfield.getName(), 0, sfield.getName().length(), out);\n        out.append(':');\n\n        if (sfield.getValueCount() > 1) {\n          out.append('[');\n          boolean firstVal = true;\n          for (Object val : sfield) {\n            if (firstVal) firstVal=false;\n            else out.append(',');\n            if(val instanceof SolrInputDocument) {\n              json((SolrInputDocument) val, out);\n            }\n            out.append(JSONUtil.toJSON(val));\n          }\n          out.append(']');\n        } else if(sfield.getValue() instanceof SolrInputDocument) {\n          json((SolrInputDocument) sfield.getValue(), out);\n        } else if (sfield.getValue() instanceof Map) {\n          Map<String, Object> valMap = (Map<String, Object>) sfield.getValue();\n          Set<String> childDocsKeys = valMap.entrySet().stream().filter(record -> isChildDoc(record.getValue()))\n              .map(Entry::getKey).collect(Collectors.toSet());\n          if(childDocsKeys.size() > 0) {\n            Map<String, Object> newMap = new HashMap<>();\n            for(Entry<String, Object> entry: valMap.entrySet()) {\n              String keyName = entry.getKey();\n              Object val = entry.getValue();\n              if(childDocsKeys.contains(keyName)) {\n                if(val instanceof Collection) {\n                  val = ((Collection) val).stream().map(e -> toSolrDoc((SolrInputDocument) e)).collect(Collectors.toList());\n                } else {\n                  val = toSolrDoc((SolrInputDocument) val);\n                }\n              }\n              newMap.put(keyName, val);\n            }\n            valMap = newMap;\n          }\n          out.append(JSONUtil.toJSON(valMap));\n        } else {\n          out.append(JSONUtil.toJSON(sfield.getValue()));\n        }\n      }\n\n      boolean firstChildDoc = true;\n      if(doc.hasChildDocuments()) {\n        out.append(\",\\\"_childDocuments_\\\": [\");\n        List<SolrInputDocument> childDocuments = doc.getChildDocuments();\n        for(SolrInputDocument childDocument : childDocuments) {\n          if (firstChildDoc) firstChildDoc=false;\n          else out.append(',');\n          json(childDocument, out);\n        }\n        out.append(']');\n      }\n      out.append('}');\n    } catch (IOException e) {\n      // should never happen\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6809a6d7924df2c864d6a5863944aff9dfeb372c":["07749612bed4eb54dd05255c1434c301133310c1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9a862f08ffeb00b03b4c641de86b167b1d6f7cd1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"07749612bed4eb54dd05255c1434c301133310c1":["9a862f08ffeb00b03b4c641de86b167b1d6f7cd1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6809a6d7924df2c864d6a5863944aff9dfeb372c"]},"commit2Childs":{"6809a6d7924df2c864d6a5863944aff9dfeb372c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9a862f08ffeb00b03b4c641de86b167b1d6f7cd1"],"9a862f08ffeb00b03b4c641de86b167b1d6f7cd1":["07749612bed4eb54dd05255c1434c301133310c1"],"07749612bed4eb54dd05255c1434c301133310c1":["6809a6d7924df2c864d6a5863944aff9dfeb372c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}