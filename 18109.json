{"path":"solr/core/src/java/org/apache/solr/handler/SnapPuller.DirectoryFileFetcher#getStream().mjava","commits":[{"id":"d9405f486872f1e416304dfe389741f4ee2f8a4d","date":1351276739,"type":2,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller.DirectoryFileFetcher#getStream().mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller.FileFetcher#getStream().mjava","sourceNew":"    /**\n     * Open a new stream using HttpClient\n     */\n    FastInputStream getStream() throws IOException {\n      SolrServer s = new HttpSolrServer(masterUrl, myHttpClient, null);  //XXX use shardhandler\n      ModifiableSolrParams params = new ModifiableSolrParams();\n\n//    //the method is command=filecontent\n      params.set(COMMAND, CMD_GET_FILE);\n      params.set(GENERATION, Long.toString(indexGen));\n      params.set(CommonParams.QT, \"/replication\");\n      //add the version to download. This is used to reserve the download\n      if (isConf) {\n        //set cf instead of file for config file\n        params.set(CONF_FILE_SHORT, fileName);\n      } else {\n        params.set(FILE, fileName);\n      }\n      if (useInternal) {\n        params.set(COMPRESSION, \"true\"); \n      }\n      //use checksum\n      if (this.includeChecksum) {\n        params.set(CHECKSUM, true);\n      }\n      //wt=filestream this is a custom protocol\n      params.set(CommonParams.WT, FILE_STREAM);\n        // This happen if there is a failure there is a retry. the offset=<sizedownloaded> ensures that\n        // the server starts from the offset\n      if (bytesDownloaded > 0) {\n        params.set(OFFSET, Long.toString(bytesDownloaded));\n      }\n      \n\n      NamedList response;\n      InputStream is = null;\n      try {\n        QueryRequest req = new QueryRequest(params);\n        response = s.request(req);\n        is = (InputStream) response.get(\"stream\");\n        if(useInternal) {\n          is = new InflaterInputStream(is);\n        }\n        return new FastInputStream(is);\n      } catch (Throwable t) {\n        //close stream on error\n        IOUtils.closeQuietly(is);\n        throw new IOException(\"Could not download file '\" + fileName + \"'\", t);\n      }\n    }\n\n","sourceOld":"    /**\n     * Open a new stream using HttpClient\n     */\n    FastInputStream getStream() throws IOException {\n      SolrServer s = new HttpSolrServer(masterUrl, myHttpClient, null);  //XXX use shardhandler\n      ModifiableSolrParams params = new ModifiableSolrParams();\n\n//    //the method is command=filecontent\n      params.set(COMMAND, CMD_GET_FILE);\n      params.set(GENERATION, Long.toString(indexGen));\n      params.set(CommonParams.QT, \"/replication\");\n      //add the version to download. This is used to reserve the download\n      if (isConf) {\n        //set cf instead of file for config file\n        params.set(CONF_FILE_SHORT, fileName);\n      } else {\n        params.set(FILE, fileName);\n      }\n      if (useInternal) {\n        params.set(COMPRESSION, \"true\"); \n      }\n      //use checksum\n      if (this.includeChecksum) {\n        params.set(CHECKSUM, true);\n      }\n      //wt=filestream this is a custom protocol\n      params.set(CommonParams.WT, FILE_STREAM);\n        // This happen if there is a failure there is a retry. the offset=<sizedownloaded> ensures that\n        // the server starts from the offset\n      if (bytesDownloaded > 0) {\n        params.set(OFFSET, Long.toString(bytesDownloaded));\n      }\n      \n\n      NamedList response;\n      InputStream is = null;\n      try {\n        QueryRequest req = new QueryRequest(params);\n        response = s.request(req);\n        is = (InputStream) response.get(\"stream\");\n        if(useInternal) {\n          is = new InflaterInputStream(is);\n        }\n        return new FastInputStream(is);\n      } catch (Throwable t) {\n        //close stream on error\n        IOUtils.closeQuietly(is);\n        throw new IOException(\"Could not download file '\" + fileName + \"'\", t);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f2126b84bd093fa3d921582a109a0ee578c28126","date":1351522501,"type":2,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller.DirectoryFileFetcher#getStream().mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller.FileFetcher#getStream().mjava","sourceNew":"    /**\n     * Open a new stream using HttpClient\n     */\n    FastInputStream getStream() throws IOException {\n      SolrServer s = new HttpSolrServer(masterUrl, myHttpClient, null);  //XXX use shardhandler\n      ModifiableSolrParams params = new ModifiableSolrParams();\n\n//    //the method is command=filecontent\n      params.set(COMMAND, CMD_GET_FILE);\n      params.set(GENERATION, Long.toString(indexGen));\n      params.set(CommonParams.QT, \"/replication\");\n      //add the version to download. This is used to reserve the download\n      if (isConf) {\n        //set cf instead of file for config file\n        params.set(CONF_FILE_SHORT, fileName);\n      } else {\n        params.set(FILE, fileName);\n      }\n      if (useInternal) {\n        params.set(COMPRESSION, \"true\"); \n      }\n      //use checksum\n      if (this.includeChecksum) {\n        params.set(CHECKSUM, true);\n      }\n      //wt=filestream this is a custom protocol\n      params.set(CommonParams.WT, FILE_STREAM);\n        // This happen if there is a failure there is a retry. the offset=<sizedownloaded> ensures that\n        // the server starts from the offset\n      if (bytesDownloaded > 0) {\n        params.set(OFFSET, Long.toString(bytesDownloaded));\n      }\n      \n\n      NamedList response;\n      InputStream is = null;\n      try {\n        QueryRequest req = new QueryRequest(params);\n        response = s.request(req);\n        is = (InputStream) response.get(\"stream\");\n        if(useInternal) {\n          is = new InflaterInputStream(is);\n        }\n        return new FastInputStream(is);\n      } catch (Throwable t) {\n        //close stream on error\n        IOUtils.closeQuietly(is);\n        throw new IOException(\"Could not download file '\" + fileName + \"'\", t);\n      }\n    }\n\n","sourceOld":"    /**\n     * Open a new stream using HttpClient\n     */\n    FastInputStream getStream() throws IOException {\n      SolrServer s = new HttpSolrServer(masterUrl, myHttpClient, null);  //XXX use shardhandler\n      ModifiableSolrParams params = new ModifiableSolrParams();\n\n//    //the method is command=filecontent\n      params.set(COMMAND, CMD_GET_FILE);\n      params.set(GENERATION, Long.toString(indexGen));\n      params.set(CommonParams.QT, \"/replication\");\n      //add the version to download. This is used to reserve the download\n      if (isConf) {\n        //set cf instead of file for config file\n        params.set(CONF_FILE_SHORT, fileName);\n      } else {\n        params.set(FILE, fileName);\n      }\n      if (useInternal) {\n        params.set(COMPRESSION, \"true\"); \n      }\n      //use checksum\n      if (this.includeChecksum) {\n        params.set(CHECKSUM, true);\n      }\n      //wt=filestream this is a custom protocol\n      params.set(CommonParams.WT, FILE_STREAM);\n        // This happen if there is a failure there is a retry. the offset=<sizedownloaded> ensures that\n        // the server starts from the offset\n      if (bytesDownloaded > 0) {\n        params.set(OFFSET, Long.toString(bytesDownloaded));\n      }\n      \n\n      NamedList response;\n      InputStream is = null;\n      try {\n        QueryRequest req = new QueryRequest(params);\n        response = s.request(req);\n        is = (InputStream) response.get(\"stream\");\n        if(useInternal) {\n          is = new InflaterInputStream(is);\n        }\n        return new FastInputStream(is);\n      } catch (Throwable t) {\n        //close stream on error\n        IOUtils.closeQuietly(is);\n        throw new IOException(\"Could not download file '\" + fileName + \"'\", t);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7af2cbf9ce9ef2d2be705276fa4b9aec41b5f452","date":1359901062,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller.DirectoryFileFetcher#getStream().mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller.DirectoryFileFetcher#getStream().mjava","sourceNew":"    /**\n     * Open a new stream using HttpClient\n     */\n    FastInputStream getStream() throws IOException {\n      HttpSolrServer s = new HttpSolrServer(masterUrl, myHttpClient, null);  //XXX use shardhandler\n      s.setSoTimeout(60000);\n      s.setConnectionTimeout(15000);\n      ModifiableSolrParams params = new ModifiableSolrParams();\n\n//    //the method is command=filecontent\n      params.set(COMMAND, CMD_GET_FILE);\n      params.set(GENERATION, Long.toString(indexGen));\n      params.set(CommonParams.QT, \"/replication\");\n      //add the version to download. This is used to reserve the download\n      if (isConf) {\n        //set cf instead of file for config file\n        params.set(CONF_FILE_SHORT, fileName);\n      } else {\n        params.set(FILE, fileName);\n      }\n      if (useInternal) {\n        params.set(COMPRESSION, \"true\"); \n      }\n      //use checksum\n      if (this.includeChecksum) {\n        params.set(CHECKSUM, true);\n      }\n      //wt=filestream this is a custom protocol\n      params.set(CommonParams.WT, FILE_STREAM);\n        // This happen if there is a failure there is a retry. the offset=<sizedownloaded> ensures that\n        // the server starts from the offset\n      if (bytesDownloaded > 0) {\n        params.set(OFFSET, Long.toString(bytesDownloaded));\n      }\n      \n\n      NamedList response;\n      InputStream is = null;\n      try {\n        QueryRequest req = new QueryRequest(params);\n        response = s.request(req);\n        is = (InputStream) response.get(\"stream\");\n        if(useInternal) {\n          is = new InflaterInputStream(is);\n        }\n        return new FastInputStream(is);\n      } catch (Throwable t) {\n        //close stream on error\n        IOUtils.closeQuietly(is);\n        throw new IOException(\"Could not download file '\" + fileName + \"'\", t);\n      }\n    }\n\n","sourceOld":"    /**\n     * Open a new stream using HttpClient\n     */\n    FastInputStream getStream() throws IOException {\n      SolrServer s = new HttpSolrServer(masterUrl, myHttpClient, null);  //XXX use shardhandler\n      ModifiableSolrParams params = new ModifiableSolrParams();\n\n//    //the method is command=filecontent\n      params.set(COMMAND, CMD_GET_FILE);\n      params.set(GENERATION, Long.toString(indexGen));\n      params.set(CommonParams.QT, \"/replication\");\n      //add the version to download. This is used to reserve the download\n      if (isConf) {\n        //set cf instead of file for config file\n        params.set(CONF_FILE_SHORT, fileName);\n      } else {\n        params.set(FILE, fileName);\n      }\n      if (useInternal) {\n        params.set(COMPRESSION, \"true\"); \n      }\n      //use checksum\n      if (this.includeChecksum) {\n        params.set(CHECKSUM, true);\n      }\n      //wt=filestream this is a custom protocol\n      params.set(CommonParams.WT, FILE_STREAM);\n        // This happen if there is a failure there is a retry. the offset=<sizedownloaded> ensures that\n        // the server starts from the offset\n      if (bytesDownloaded > 0) {\n        params.set(OFFSET, Long.toString(bytesDownloaded));\n      }\n      \n\n      NamedList response;\n      InputStream is = null;\n      try {\n        QueryRequest req = new QueryRequest(params);\n        response = s.request(req);\n        is = (InputStream) response.get(\"stream\");\n        if(useInternal) {\n          is = new InflaterInputStream(is);\n        }\n        return new FastInputStream(is);\n      } catch (Throwable t) {\n        //close stream on error\n        IOUtils.closeQuietly(is);\n        throw new IOException(\"Could not download file '\" + fileName + \"'\", t);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3e4d4ec39bf5396230748ca859ff05ab024b6fc5","date":1360112310,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller.DirectoryFileFetcher#getStream().mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller.DirectoryFileFetcher#getStream().mjava","sourceNew":"    /**\n     * Open a new stream using HttpClient\n     */\n    FastInputStream getStream() throws IOException {\n      HttpSolrServer s = new HttpSolrServer(masterUrl, myHttpClient, null);  //XXX use shardhandler\n      s.setSoTimeout(60000);\n      s.setConnectionTimeout(15000);\n      ModifiableSolrParams params = new ModifiableSolrParams();\n\n//    //the method is command=filecontent\n      params.set(COMMAND, CMD_GET_FILE);\n      params.set(GENERATION, Long.toString(indexGen));\n      params.set(CommonParams.QT, \"/replication\");\n      //add the version to download. This is used to reserve the download\n      if (isConf) {\n        //set cf instead of file for config file\n        params.set(CONF_FILE_SHORT, fileName);\n      } else {\n        params.set(FILE, fileName);\n      }\n      if (useInternal) {\n        params.set(COMPRESSION, \"true\"); \n      }\n      //use checksum\n      if (this.includeChecksum) {\n        params.set(CHECKSUM, true);\n      }\n      //wt=filestream this is a custom protocol\n      params.set(CommonParams.WT, FILE_STREAM);\n        // This happen if there is a failure there is a retry. the offset=<sizedownloaded> ensures that\n        // the server starts from the offset\n      if (bytesDownloaded > 0) {\n        params.set(OFFSET, Long.toString(bytesDownloaded));\n      }\n      \n\n      NamedList response;\n      InputStream is = null;\n      try {\n        QueryRequest req = new QueryRequest(params);\n        response = s.request(req);\n        is = (InputStream) response.get(\"stream\");\n        if(useInternal) {\n          is = new InflaterInputStream(is);\n        }\n        return new FastInputStream(is);\n      } catch (Throwable t) {\n        //close stream on error\n        IOUtils.closeQuietly(is);\n        throw new IOException(\"Could not download file '\" + fileName + \"'\", t);\n      }\n    }\n\n","sourceOld":"    /**\n     * Open a new stream using HttpClient\n     */\n    FastInputStream getStream() throws IOException {\n      SolrServer s = new HttpSolrServer(masterUrl, myHttpClient, null);  //XXX use shardhandler\n      ModifiableSolrParams params = new ModifiableSolrParams();\n\n//    //the method is command=filecontent\n      params.set(COMMAND, CMD_GET_FILE);\n      params.set(GENERATION, Long.toString(indexGen));\n      params.set(CommonParams.QT, \"/replication\");\n      //add the version to download. This is used to reserve the download\n      if (isConf) {\n        //set cf instead of file for config file\n        params.set(CONF_FILE_SHORT, fileName);\n      } else {\n        params.set(FILE, fileName);\n      }\n      if (useInternal) {\n        params.set(COMPRESSION, \"true\"); \n      }\n      //use checksum\n      if (this.includeChecksum) {\n        params.set(CHECKSUM, true);\n      }\n      //wt=filestream this is a custom protocol\n      params.set(CommonParams.WT, FILE_STREAM);\n        // This happen if there is a failure there is a retry. the offset=<sizedownloaded> ensures that\n        // the server starts from the offset\n      if (bytesDownloaded > 0) {\n        params.set(OFFSET, Long.toString(bytesDownloaded));\n      }\n      \n\n      NamedList response;\n      InputStream is = null;\n      try {\n        QueryRequest req = new QueryRequest(params);\n        response = s.request(req);\n        is = (InputStream) response.get(\"stream\");\n        if(useInternal) {\n          is = new InflaterInputStream(is);\n        }\n        return new FastInputStream(is);\n      } catch (Throwable t) {\n        //close stream on error\n        IOUtils.closeQuietly(is);\n        throw new IOException(\"Could not download file '\" + fileName + \"'\", t);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2d750082a4223c20902ef11ff6a9831d55738ea4","date":1382309916,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller.DirectoryFileFetcher#getStream().mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller.DirectoryFileFetcher#getStream().mjava","sourceNew":"    /**\n     * Open a new stream using HttpClient\n     */\n    FastInputStream getStream() throws IOException {\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n\n//    //the method is command=filecontent\n      params.set(COMMAND, CMD_GET_FILE);\n      params.set(GENERATION, Long.toString(indexGen));\n      params.set(CommonParams.QT, \"/replication\");\n      //add the version to download. This is used to reserve the download\n      if (isConf) {\n        //set cf instead of file for config file\n        params.set(CONF_FILE_SHORT, fileName);\n      } else {\n        params.set(FILE, fileName);\n      }\n      if (useInternal) {\n        params.set(COMPRESSION, \"true\"); \n      }\n      //use checksum\n      if (this.includeChecksum) {\n        params.set(CHECKSUM, true);\n      }\n      //wt=filestream this is a custom protocol\n      params.set(CommonParams.WT, FILE_STREAM);\n        // This happen if there is a failure there is a retry. the offset=<sizedownloaded> ensures that\n        // the server starts from the offset\n      if (bytesDownloaded > 0) {\n        params.set(OFFSET, Long.toString(bytesDownloaded));\n      }\n      \n\n      NamedList response;\n      InputStream is = null;\n      \n      HttpSolrServer s = new HttpSolrServer(masterUrl, myHttpClient, null);  //XXX use shardhandler\n      try {\n        s.setSoTimeout(60000);\n        s.setConnectionTimeout(15000);\n        QueryRequest req = new QueryRequest(params);\n        response = s.request(req);\n        is = (InputStream) response.get(\"stream\");\n        if(useInternal) {\n          is = new InflaterInputStream(is);\n        }\n        return new FastInputStream(is);\n      } catch (Throwable t) {\n        //close stream on error\n        IOUtils.closeQuietly(is);\n        throw new IOException(\"Could not download file '\" + fileName + \"'\", t);\n      } finally {\n        s.shutdown();\n      }\n    }\n\n","sourceOld":"    /**\n     * Open a new stream using HttpClient\n     */\n    FastInputStream getStream() throws IOException {\n      HttpSolrServer s = new HttpSolrServer(masterUrl, myHttpClient, null);  //XXX use shardhandler\n      s.setSoTimeout(60000);\n      s.setConnectionTimeout(15000);\n      ModifiableSolrParams params = new ModifiableSolrParams();\n\n//    //the method is command=filecontent\n      params.set(COMMAND, CMD_GET_FILE);\n      params.set(GENERATION, Long.toString(indexGen));\n      params.set(CommonParams.QT, \"/replication\");\n      //add the version to download. This is used to reserve the download\n      if (isConf) {\n        //set cf instead of file for config file\n        params.set(CONF_FILE_SHORT, fileName);\n      } else {\n        params.set(FILE, fileName);\n      }\n      if (useInternal) {\n        params.set(COMPRESSION, \"true\"); \n      }\n      //use checksum\n      if (this.includeChecksum) {\n        params.set(CHECKSUM, true);\n      }\n      //wt=filestream this is a custom protocol\n      params.set(CommonParams.WT, FILE_STREAM);\n        // This happen if there is a failure there is a retry. the offset=<sizedownloaded> ensures that\n        // the server starts from the offset\n      if (bytesDownloaded > 0) {\n        params.set(OFFSET, Long.toString(bytesDownloaded));\n      }\n      \n\n      NamedList response;\n      InputStream is = null;\n      try {\n        QueryRequest req = new QueryRequest(params);\n        response = s.request(req);\n        is = (InputStream) response.get(\"stream\");\n        if(useInternal) {\n          is = new InflaterInputStream(is);\n        }\n        return new FastInputStream(is);\n      } catch (Throwable t) {\n        //close stream on error\n        IOUtils.closeQuietly(is);\n        throw new IOException(\"Could not download file '\" + fileName + \"'\", t);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","date":1389633998,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller.DirectoryFileFetcher#getStream().mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller.DirectoryFileFetcher#getStream().mjava","sourceNew":"    /**\n     * Open a new stream using HttpClient\n     */\n    FastInputStream getStream() throws IOException {\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n\n//    //the method is command=filecontent\n      params.set(COMMAND, CMD_GET_FILE);\n      params.set(GENERATION, Long.toString(indexGen));\n      params.set(CommonParams.QT, \"/replication\");\n      //add the version to download. This is used to reserve the download\n      if (isConf) {\n        //set cf instead of file for config file\n        params.set(CONF_FILE_SHORT, fileName);\n      } else {\n        params.set(FILE, fileName);\n      }\n      if (useInternal) {\n        params.set(COMPRESSION, \"true\"); \n      }\n      //use checksum\n      if (this.includeChecksum) {\n        params.set(CHECKSUM, true);\n      }\n      //wt=filestream this is a custom protocol\n      params.set(CommonParams.WT, FILE_STREAM);\n        // This happen if there is a failure there is a retry. the offset=<sizedownloaded> ensures that\n        // the server starts from the offset\n      if (bytesDownloaded > 0) {\n        params.set(OFFSET, Long.toString(bytesDownloaded));\n      }\n      \n\n      NamedList response;\n      InputStream is = null;\n      \n      HttpSolrServer s = new HttpSolrServer(masterUrl, myHttpClient, null);  //XXX use shardhandler\n      try {\n        s.setSoTimeout(60000);\n        s.setConnectionTimeout(15000);\n        QueryRequest req = new QueryRequest(params);\n        response = s.request(req);\n        is = (InputStream) response.get(\"stream\");\n        if(useInternal) {\n          is = new InflaterInputStream(is);\n        }\n        return new FastInputStream(is);\n      } catch (Exception e) {\n        //close stream on error\n        IOUtils.closeQuietly(is);\n        throw new IOException(\"Could not download file '\" + fileName + \"'\", e);\n      } finally {\n        s.shutdown();\n      }\n    }\n\n","sourceOld":"    /**\n     * Open a new stream using HttpClient\n     */\n    FastInputStream getStream() throws IOException {\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n\n//    //the method is command=filecontent\n      params.set(COMMAND, CMD_GET_FILE);\n      params.set(GENERATION, Long.toString(indexGen));\n      params.set(CommonParams.QT, \"/replication\");\n      //add the version to download. This is used to reserve the download\n      if (isConf) {\n        //set cf instead of file for config file\n        params.set(CONF_FILE_SHORT, fileName);\n      } else {\n        params.set(FILE, fileName);\n      }\n      if (useInternal) {\n        params.set(COMPRESSION, \"true\"); \n      }\n      //use checksum\n      if (this.includeChecksum) {\n        params.set(CHECKSUM, true);\n      }\n      //wt=filestream this is a custom protocol\n      params.set(CommonParams.WT, FILE_STREAM);\n        // This happen if there is a failure there is a retry. the offset=<sizedownloaded> ensures that\n        // the server starts from the offset\n      if (bytesDownloaded > 0) {\n        params.set(OFFSET, Long.toString(bytesDownloaded));\n      }\n      \n\n      NamedList response;\n      InputStream is = null;\n      \n      HttpSolrServer s = new HttpSolrServer(masterUrl, myHttpClient, null);  //XXX use shardhandler\n      try {\n        s.setSoTimeout(60000);\n        s.setConnectionTimeout(15000);\n        QueryRequest req = new QueryRequest(params);\n        response = s.request(req);\n        is = (InputStream) response.get(\"stream\");\n        if(useInternal) {\n          is = new InflaterInputStream(is);\n        }\n        return new FastInputStream(is);\n      } catch (Throwable t) {\n        //close stream on error\n        IOUtils.closeQuietly(is);\n        throw new IOException(\"Could not download file '\" + fileName + \"'\", t);\n      } finally {\n        s.shutdown();\n      }\n    }\n\n","bugFix":["f2425308ebcd91b538a601df94ae1551ccaab2bb"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller.DirectoryFileFetcher#getStream().mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller.DirectoryFileFetcher#getStream().mjava","sourceNew":"    /**\n     * Open a new stream using HttpClient\n     */\n    FastInputStream getStream() throws IOException {\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n\n//    //the method is command=filecontent\n      params.set(COMMAND, CMD_GET_FILE);\n      params.set(GENERATION, Long.toString(indexGen));\n      params.set(CommonParams.QT, \"/replication\");\n      //add the version to download. This is used to reserve the download\n      if (isConf) {\n        //set cf instead of file for config file\n        params.set(CONF_FILE_SHORT, fileName);\n      } else {\n        params.set(FILE, fileName);\n      }\n      if (useInternal) {\n        params.set(COMPRESSION, \"true\"); \n      }\n      //use checksum\n      if (this.includeChecksum) {\n        params.set(CHECKSUM, true);\n      }\n      //wt=filestream this is a custom protocol\n      params.set(CommonParams.WT, FILE_STREAM);\n        // This happen if there is a failure there is a retry. the offset=<sizedownloaded> ensures that\n        // the server starts from the offset\n      if (bytesDownloaded > 0) {\n        params.set(OFFSET, Long.toString(bytesDownloaded));\n      }\n      \n\n      NamedList response;\n      InputStream is = null;\n      \n      HttpSolrClient client = new HttpSolrClient(masterUrl, myHttpClient, null);  //XXX use shardhandler\n      try {\n        client.setSoTimeout(60000);\n        client.setConnectionTimeout(15000);\n        QueryRequest req = new QueryRequest(params);\n        response = client.request(req);\n        is = (InputStream) response.get(\"stream\");\n        if(useInternal) {\n          is = new InflaterInputStream(is);\n        }\n        return new FastInputStream(is);\n      } catch (Exception e) {\n        //close stream on error\n        IOUtils.closeQuietly(is);\n        throw new IOException(\"Could not download file '\" + fileName + \"'\", e);\n      } finally {\n        client.shutdown();\n      }\n    }\n\n","sourceOld":"    /**\n     * Open a new stream using HttpClient\n     */\n    FastInputStream getStream() throws IOException {\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n\n//    //the method is command=filecontent\n      params.set(COMMAND, CMD_GET_FILE);\n      params.set(GENERATION, Long.toString(indexGen));\n      params.set(CommonParams.QT, \"/replication\");\n      //add the version to download. This is used to reserve the download\n      if (isConf) {\n        //set cf instead of file for config file\n        params.set(CONF_FILE_SHORT, fileName);\n      } else {\n        params.set(FILE, fileName);\n      }\n      if (useInternal) {\n        params.set(COMPRESSION, \"true\"); \n      }\n      //use checksum\n      if (this.includeChecksum) {\n        params.set(CHECKSUM, true);\n      }\n      //wt=filestream this is a custom protocol\n      params.set(CommonParams.WT, FILE_STREAM);\n        // This happen if there is a failure there is a retry. the offset=<sizedownloaded> ensures that\n        // the server starts from the offset\n      if (bytesDownloaded > 0) {\n        params.set(OFFSET, Long.toString(bytesDownloaded));\n      }\n      \n\n      NamedList response;\n      InputStream is = null;\n      \n      HttpSolrServer s = new HttpSolrServer(masterUrl, myHttpClient, null);  //XXX use shardhandler\n      try {\n        s.setSoTimeout(60000);\n        s.setConnectionTimeout(15000);\n        QueryRequest req = new QueryRequest(params);\n        response = s.request(req);\n        is = (InputStream) response.get(\"stream\");\n        if(useInternal) {\n          is = new InflaterInputStream(is);\n        }\n        return new FastInputStream(is);\n      } catch (Exception e) {\n        //close stream on error\n        IOUtils.closeQuietly(is);\n        throw new IOException(\"Could not download file '\" + fileName + \"'\", e);\n      } finally {\n        s.shutdown();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dea8e36e8c36d610840396c282a5affe3f722f4e","date":1422297045,"type":5,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller.FileFetcher#getStream().mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller.DirectoryFileFetcher#getStream().mjava","sourceNew":"    /**\n     * Open a new stream using HttpClient\n     */\n    private FastInputStream getStream() throws IOException {\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n\n//    //the method is command=filecontent\n      params.set(COMMAND, CMD_GET_FILE);\n      params.set(GENERATION, Long.toString(indexGen));\n      params.set(CommonParams.QT, \"/replication\");\n      //add the version to download. This is used to reserve the download\n      if (isConf) {\n        //set cf instead of file for config file\n        params.set(CONF_FILE_SHORT, fileName);\n      } else {\n        params.set(FILE, fileName);\n      }\n      if (useInternal) {\n        params.set(COMPRESSION, \"true\");\n      }\n      //use checksum\n      if (this.includeChecksum) {\n        params.set(CHECKSUM, true);\n      }\n      //wt=filestream this is a custom protocol\n      params.set(CommonParams.WT, FILE_STREAM);\n      // This happen if there is a failure there is a retry. the offset=<sizedownloaded> ensures that\n      // the server starts from the offset\n      if (bytesDownloaded > 0) {\n        params.set(OFFSET, Long.toString(bytesDownloaded));\n      }\n\n\n      NamedList response;\n      InputStream is = null;\n\n      HttpSolrClient client = new HttpSolrClient(masterUrl, myHttpClient, null);  //XXX use shardhandler\n      try {\n        client.setSoTimeout(60000);\n        client.setConnectionTimeout(15000);\n        QueryRequest req = new QueryRequest(params);\n        response = client.request(req);\n        is = (InputStream) response.get(\"stream\");\n        if(useInternal) {\n          is = new InflaterInputStream(is);\n        }\n        return new FastInputStream(is);\n      } catch (Exception e) {\n        //close stream on error\n        IOUtils.closeQuietly(is);\n        throw new IOException(\"Could not download file '\" + fileName + \"'\", e);\n      } finally {\n        client.shutdown();\n      }\n    }\n\n","sourceOld":"    /**\n     * Open a new stream using HttpClient\n     */\n    FastInputStream getStream() throws IOException {\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n\n//    //the method is command=filecontent\n      params.set(COMMAND, CMD_GET_FILE);\n      params.set(GENERATION, Long.toString(indexGen));\n      params.set(CommonParams.QT, \"/replication\");\n      //add the version to download. This is used to reserve the download\n      if (isConf) {\n        //set cf instead of file for config file\n        params.set(CONF_FILE_SHORT, fileName);\n      } else {\n        params.set(FILE, fileName);\n      }\n      if (useInternal) {\n        params.set(COMPRESSION, \"true\"); \n      }\n      //use checksum\n      if (this.includeChecksum) {\n        params.set(CHECKSUM, true);\n      }\n      //wt=filestream this is a custom protocol\n      params.set(CommonParams.WT, FILE_STREAM);\n        // This happen if there is a failure there is a retry. the offset=<sizedownloaded> ensures that\n        // the server starts from the offset\n      if (bytesDownloaded > 0) {\n        params.set(OFFSET, Long.toString(bytesDownloaded));\n      }\n      \n\n      NamedList response;\n      InputStream is = null;\n      \n      HttpSolrClient client = new HttpSolrClient(masterUrl, myHttpClient, null);  //XXX use shardhandler\n      try {\n        client.setSoTimeout(60000);\n        client.setConnectionTimeout(15000);\n        QueryRequest req = new QueryRequest(params);\n        response = client.request(req);\n        is = (InputStream) response.get(\"stream\");\n        if(useInternal) {\n          is = new InflaterInputStream(is);\n        }\n        return new FastInputStream(is);\n      } catch (Exception e) {\n        //close stream on error\n        IOUtils.closeQuietly(is);\n        throw new IOException(\"Could not download file '\" + fileName + \"'\", e);\n      } finally {\n        client.shutdown();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"3e4d4ec39bf5396230748ca859ff05ab024b6fc5":["d9405f486872f1e416304dfe389741f4ee2f8a4d","7af2cbf9ce9ef2d2be705276fa4b9aec41b5f452"],"dea8e36e8c36d610840396c282a5affe3f722f4e":["bafca15d8e408346a67f4282ad1143b88023893b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2d750082a4223c20902ef11ff6a9831d55738ea4":["7af2cbf9ce9ef2d2be705276fa4b9aec41b5f452"],"bafca15d8e408346a67f4282ad1143b88023893b":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f2126b84bd093fa3d921582a109a0ee578c28126":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d9405f486872f1e416304dfe389741f4ee2f8a4d"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["2d750082a4223c20902ef11ff6a9831d55738ea4"],"7af2cbf9ce9ef2d2be705276fa4b9aec41b5f452":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["dea8e36e8c36d610840396c282a5affe3f722f4e"]},"commit2Childs":{"3e4d4ec39bf5396230748ca859ff05ab024b6fc5":[],"dea8e36e8c36d610840396c282a5affe3f722f4e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d9405f486872f1e416304dfe389741f4ee2f8a4d","f2126b84bd093fa3d921582a109a0ee578c28126"],"2d750082a4223c20902ef11ff6a9831d55738ea4":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"bafca15d8e408346a67f4282ad1143b88023893b":["dea8e36e8c36d610840396c282a5affe3f722f4e"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["3e4d4ec39bf5396230748ca859ff05ab024b6fc5","f2126b84bd093fa3d921582a109a0ee578c28126","7af2cbf9ce9ef2d2be705276fa4b9aec41b5f452"],"f2126b84bd093fa3d921582a109a0ee578c28126":[],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["bafca15d8e408346a67f4282ad1143b88023893b"],"7af2cbf9ce9ef2d2be705276fa4b9aec41b5f452":["3e4d4ec39bf5396230748ca859ff05ab024b6fc5","2d750082a4223c20902ef11ff6a9831d55738ea4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3e4d4ec39bf5396230748ca859ff05ab024b6fc5","f2126b84bd093fa3d921582a109a0ee578c28126","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}