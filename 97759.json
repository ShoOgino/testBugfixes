{"path":"lucene/core/src/java/org/apache/lucene/search/FilteredQuery#rewrite(IndexReader).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FilteredQuery#rewrite(IndexReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FilteredQuery#rewrite(IndexReader).mjava","sourceNew":"  /** Rewrites the query. If the wrapped is an instance of\n   * {@link MatchAllDocsQuery} it returns a {@link ConstantScoreQuery}. Otherwise\n   * it returns a new {@code FilteredQuery} wrapping the rewritten query. */\n  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    final Query queryRewritten = query.rewrite(reader);\n    \n    if (queryRewritten instanceof MatchAllDocsQuery) {\n      // Special case: If the query is a MatchAllDocsQuery, we only\n      // return a CSQ(filter).\n      final Query rewritten = new ConstantScoreQuery(filter);\n      // Combine boost of MatchAllDocsQuery and the wrapped rewritten query:\n      rewritten.setBoost(this.getBoost() * queryRewritten.getBoost());\n      return rewritten;\n    }\n    \n    if (queryRewritten != query) {\n      // rewrite to a new FilteredQuery wrapping the rewritten query\n      final Query rewritten = new FilteredQuery(queryRewritten, filter);\n      rewritten.setBoost(this.getBoost());\n      return rewritten;\n    } else {\n      // nothing to rewrite, we are done!\n      return this;\n    }\n  }\n\n","sourceOld":"  /** Rewrites the query. If the wrapped is an instance of\n   * {@link MatchAllDocsQuery} it returns a {@link ConstantScoreQuery}. Otherwise\n   * it returns a new {@code FilteredQuery} wrapping the rewritten query. */\n  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    final Query queryRewritten = query.rewrite(reader);\n    \n    if (queryRewritten instanceof MatchAllDocsQuery) {\n      // Special case: If the query is a MatchAllDocsQuery, we only\n      // return a CSQ(filter).\n      final Query rewritten = new ConstantScoreQuery(filter);\n      // Combine boost of MatchAllDocsQuery and the wrapped rewritten query:\n      rewritten.setBoost(this.getBoost() * queryRewritten.getBoost());\n      return rewritten;\n    }\n    \n    if (queryRewritten != query) {\n      // rewrite to a new FilteredQuery wrapping the rewritten query\n      final Query rewritten = new FilteredQuery(queryRewritten, filter);\n      rewritten.setBoost(this.getBoost());\n      return rewritten;\n    } else {\n      // nothing to rewrite, we are done!\n      return this;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9eb3122482ef235fbee3d696501977399ec0af6f","date":1358856510,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FilteredQuery#rewrite(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FilteredQuery#rewrite(IndexReader).mjava","sourceNew":"  /** Rewrites the query. If the wrapped is an instance of\n   * {@link MatchAllDocsQuery} it returns a {@link ConstantScoreQuery}. Otherwise\n   * it returns a new {@code FilteredQuery} wrapping the rewritten query. */\n  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    final Query queryRewritten = query.rewrite(reader);\n    \n    if (queryRewritten instanceof MatchAllDocsQuery) {\n      // Special case: If the query is a MatchAllDocsQuery, we only\n      // return a CSQ(filter).\n      final Query rewritten = new ConstantScoreQuery(filter);\n      // Combine boost of MatchAllDocsQuery and the wrapped rewritten query:\n      rewritten.setBoost(this.getBoost() * queryRewritten.getBoost());\n      return rewritten;\n    }\n    \n    if (queryRewritten != query) {\n      // rewrite to a new FilteredQuery wrapping the rewritten query\n      final Query rewritten = new FilteredQuery(queryRewritten, filter, strategy);\n      rewritten.setBoost(this.getBoost());\n      return rewritten;\n    } else {\n      // nothing to rewrite, we are done!\n      return this;\n    }\n  }\n\n","sourceOld":"  /** Rewrites the query. If the wrapped is an instance of\n   * {@link MatchAllDocsQuery} it returns a {@link ConstantScoreQuery}. Otherwise\n   * it returns a new {@code FilteredQuery} wrapping the rewritten query. */\n  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    final Query queryRewritten = query.rewrite(reader);\n    \n    if (queryRewritten instanceof MatchAllDocsQuery) {\n      // Special case: If the query is a MatchAllDocsQuery, we only\n      // return a CSQ(filter).\n      final Query rewritten = new ConstantScoreQuery(filter);\n      // Combine boost of MatchAllDocsQuery and the wrapped rewritten query:\n      rewritten.setBoost(this.getBoost() * queryRewritten.getBoost());\n      return rewritten;\n    }\n    \n    if (queryRewritten != query) {\n      // rewrite to a new FilteredQuery wrapping the rewritten query\n      final Query rewritten = new FilteredQuery(queryRewritten, filter);\n      rewritten.setBoost(this.getBoost());\n      return rewritten;\n    } else {\n      // nothing to rewrite, we are done!\n      return this;\n    }\n  }\n\n","bugFix":["586cf43028f4cae848088bc127a6e4d6773ce9aa"],"bugIntro":["8249072f13ea4354ab7635c2d7a59cc682806dab"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b2d5244a676b83c2d551c3746e8181588ba619e1","date":1359031414,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FilteredQuery#rewrite(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FilteredQuery#rewrite(IndexReader).mjava","sourceNew":"  /** Rewrites the query. If the wrapped is an instance of\n   * {@link MatchAllDocsQuery} it returns a {@link ConstantScoreQuery}. Otherwise\n   * it returns a new {@code FilteredQuery} wrapping the rewritten query. */\n  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    final Query queryRewritten = query.rewrite(reader);\n    \n    if (queryRewritten instanceof MatchAllDocsQuery) {\n      // Special case: If the query is a MatchAllDocsQuery, we only\n      // return a CSQ(filter).\n      final Query rewritten = new ConstantScoreQuery(filter);\n      // Combine boost of MatchAllDocsQuery and the wrapped rewritten query:\n      rewritten.setBoost(this.getBoost() * queryRewritten.getBoost());\n      return rewritten;\n    }\n    \n    if (queryRewritten != query) {\n      // rewrite to a new FilteredQuery wrapping the rewritten query\n      final Query rewritten = new FilteredQuery(queryRewritten, filter, strategy);\n      rewritten.setBoost(this.getBoost());\n      return rewritten;\n    } else {\n      // nothing to rewrite, we are done!\n      return this;\n    }\n  }\n\n","sourceOld":"  /** Rewrites the query. If the wrapped is an instance of\n   * {@link MatchAllDocsQuery} it returns a {@link ConstantScoreQuery}. Otherwise\n   * it returns a new {@code FilteredQuery} wrapping the rewritten query. */\n  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    final Query queryRewritten = query.rewrite(reader);\n    \n    if (queryRewritten instanceof MatchAllDocsQuery) {\n      // Special case: If the query is a MatchAllDocsQuery, we only\n      // return a CSQ(filter).\n      final Query rewritten = new ConstantScoreQuery(filter);\n      // Combine boost of MatchAllDocsQuery and the wrapped rewritten query:\n      rewritten.setBoost(this.getBoost() * queryRewritten.getBoost());\n      return rewritten;\n    }\n    \n    if (queryRewritten != query) {\n      // rewrite to a new FilteredQuery wrapping the rewritten query\n      final Query rewritten = new FilteredQuery(queryRewritten, filter);\n      rewritten.setBoost(this.getBoost());\n      return rewritten;\n    } else {\n      // nothing to rewrite, we are done!\n      return this;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"40640359164f629dd440a47df2e145d084ce9645","date":1391711808,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FilteredQuery#rewrite(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FilteredQuery#rewrite(IndexReader).mjava","sourceNew":"  /** Rewrites the query. If the wrapped is an instance of\n   * {@link MatchAllDocsQuery} it returns a {@link ConstantScoreQuery}. Otherwise\n   * it returns a new {@code FilteredQuery} wrapping the rewritten query. */\n  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    final Query queryRewritten = query.rewrite(reader);\n    \n    if (queryRewritten != query) {\n      // rewrite to a new FilteredQuery wrapping the rewritten query\n      final Query rewritten = new FilteredQuery(queryRewritten, filter, strategy);\n      rewritten.setBoost(this.getBoost());\n      return rewritten;\n    } else {\n      // nothing to rewrite, we are done!\n      return this;\n    }\n  }\n\n","sourceOld":"  /** Rewrites the query. If the wrapped is an instance of\n   * {@link MatchAllDocsQuery} it returns a {@link ConstantScoreQuery}. Otherwise\n   * it returns a new {@code FilteredQuery} wrapping the rewritten query. */\n  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    final Query queryRewritten = query.rewrite(reader);\n    \n    if (queryRewritten instanceof MatchAllDocsQuery) {\n      // Special case: If the query is a MatchAllDocsQuery, we only\n      // return a CSQ(filter).\n      final Query rewritten = new ConstantScoreQuery(filter);\n      // Combine boost of MatchAllDocsQuery and the wrapped rewritten query:\n      rewritten.setBoost(this.getBoost() * queryRewritten.getBoost());\n      return rewritten;\n    }\n    \n    if (queryRewritten != query) {\n      // rewrite to a new FilteredQuery wrapping the rewritten query\n      final Query rewritten = new FilteredQuery(queryRewritten, filter, strategy);\n      rewritten.setBoost(this.getBoost());\n      return rewritten;\n    } else {\n      // nothing to rewrite, we are done!\n      return this;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bcf6334db27a9662c6121404be1f1da2598c58a8","date":1424866078,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FilteredQuery#rewrite(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FilteredQuery#rewrite(IndexReader).mjava","sourceNew":"  /** Rewrites the query. If the wrapped is an instance of\n   * {@link MatchAllDocsQuery} it returns a {@link ConstantScoreQuery}. Otherwise\n   * it returns a new {@code FilteredQuery} wrapping the rewritten query. */\n  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (filter instanceof QueryWrapperFilter) {\n      // In that case the filter does not implement random-access anyway so\n      // we want to take advantage of approximations\n      BooleanQuery rewritten = new BooleanQuery();\n      rewritten.add(query, Occur.MUST);\n      rewritten.add(((QueryWrapperFilter) filter).getQuery(), Occur.FILTER);\n      rewritten.setBoost(getBoost());\n      return rewritten;\n    }\n\n    final Query queryRewritten = query.rewrite(reader);\n    \n    if (queryRewritten != query) {\n      // rewrite to a new FilteredQuery wrapping the rewritten query\n      final Query rewritten = new FilteredQuery(queryRewritten, filter, strategy);\n      rewritten.setBoost(this.getBoost());\n      return rewritten;\n    } else {\n      // nothing to rewrite, we are done!\n      return this;\n    }\n  }\n\n","sourceOld":"  /** Rewrites the query. If the wrapped is an instance of\n   * {@link MatchAllDocsQuery} it returns a {@link ConstantScoreQuery}. Otherwise\n   * it returns a new {@code FilteredQuery} wrapping the rewritten query. */\n  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    final Query queryRewritten = query.rewrite(reader);\n    \n    if (queryRewritten != query) {\n      // rewrite to a new FilteredQuery wrapping the rewritten query\n      final Query rewritten = new FilteredQuery(queryRewritten, filter, strategy);\n      rewritten.setBoost(this.getBoost());\n      return rewritten;\n    } else {\n      // nothing to rewrite, we are done!\n      return this;\n    }\n  }\n\n","bugFix":null,"bugIntro":["8249072f13ea4354ab7635c2d7a59cc682806dab"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"297694897f6cc250f8df8843d76d43efd171dbcd","date":1426101649,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FilteredQuery#rewrite(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FilteredQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (filter instanceof QueryWrapperFilter) {\n      // In that case the filter does not implement random-access anyway so\n      // we want to take advantage of approximations\n      BooleanQuery rewritten = new BooleanQuery();\n      rewritten.add(query, Occur.MUST);\n      rewritten.add(((QueryWrapperFilter) filter).getQuery(), Occur.FILTER);\n      rewritten.setBoost(getBoost());\n      return rewritten;\n    }\n\n    final Query queryRewritten = query.rewrite(reader);\n    \n    if (queryRewritten != query) {\n      // rewrite to a new FilteredQuery wrapping the rewritten query\n      final Query rewritten = new FilteredQuery(queryRewritten, filter, strategy);\n      rewritten.setBoost(this.getBoost());\n      return rewritten;\n    } else {\n      // nothing to rewrite, we are done!\n      return this;\n    }\n  }\n\n","sourceOld":"  /** Rewrites the query. If the wrapped is an instance of\n   * {@link MatchAllDocsQuery} it returns a {@link ConstantScoreQuery}. Otherwise\n   * it returns a new {@code FilteredQuery} wrapping the rewritten query. */\n  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (filter instanceof QueryWrapperFilter) {\n      // In that case the filter does not implement random-access anyway so\n      // we want to take advantage of approximations\n      BooleanQuery rewritten = new BooleanQuery();\n      rewritten.add(query, Occur.MUST);\n      rewritten.add(((QueryWrapperFilter) filter).getQuery(), Occur.FILTER);\n      rewritten.setBoost(getBoost());\n      return rewritten;\n    }\n\n    final Query queryRewritten = query.rewrite(reader);\n    \n    if (queryRewritten != query) {\n      // rewrite to a new FilteredQuery wrapping the rewritten query\n      final Query rewritten = new FilteredQuery(queryRewritten, filter, strategy);\n      rewritten.setBoost(this.getBoost());\n      return rewritten;\n    } else {\n      // nothing to rewrite, we are done!\n      return this;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FilteredQuery#rewrite(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FilteredQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (filter instanceof QueryWrapperFilter) {\n      // In that case the filter does not implement random-access anyway so\n      // we want to take advantage of approximations\n      BooleanQuery rewritten = new BooleanQuery();\n      rewritten.add(query, Occur.MUST);\n      rewritten.add(((QueryWrapperFilter) filter).getQuery(), Occur.FILTER);\n      rewritten.setBoost(getBoost());\n      return rewritten;\n    }\n\n    final Query queryRewritten = query.rewrite(reader);\n    \n    if (queryRewritten != query) {\n      // rewrite to a new FilteredQuery wrapping the rewritten query\n      final Query rewritten = new FilteredQuery(queryRewritten, filter, strategy);\n      rewritten.setBoost(this.getBoost());\n      return rewritten;\n    } else {\n      // nothing to rewrite, we are done!\n      return this;\n    }\n  }\n\n","sourceOld":"  /** Rewrites the query. If the wrapped is an instance of\n   * {@link MatchAllDocsQuery} it returns a {@link ConstantScoreQuery}. Otherwise\n   * it returns a new {@code FilteredQuery} wrapping the rewritten query. */\n  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    final Query queryRewritten = query.rewrite(reader);\n    \n    if (queryRewritten != query) {\n      // rewrite to a new FilteredQuery wrapping the rewritten query\n      final Query rewritten = new FilteredQuery(queryRewritten, filter, strategy);\n      rewritten.setBoost(this.getBoost());\n      return rewritten;\n    } else {\n      // nothing to rewrite, we are done!\n      return this;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8249072f13ea4354ab7635c2d7a59cc682806dab","date":1429649774,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FilteredQuery#rewrite(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FilteredQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    final Query queryRewritten = query.rewrite(reader);\n    final Query filterRewritten = filter.rewrite(reader);\n    \n    if (queryRewritten != query || filterRewritten != filter) {\n      // rewrite to a new FilteredQuery wrapping the rewritten query/filter\n      if (filterRewritten instanceof Filter) {\n        final Query rewritten = new FilteredQuery(queryRewritten, (Filter) filterRewritten, strategy);\n        rewritten.setBoost(this.getBoost());\n        return rewritten;\n      } else {\n        // In that case the filter does not implement random-access anyway so\n        // we want to take advantage of approximations\n        BooleanQuery rewritten = new BooleanQuery();\n        rewritten.add(queryRewritten, Occur.MUST);\n        rewritten.add(filterRewritten, Occur.FILTER);\n        rewritten.setBoost(getBoost());\n        return rewritten;\n      }\n    }\n    // nothing to rewrite, we are done!\n    return this;\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (filter instanceof QueryWrapperFilter) {\n      // In that case the filter does not implement random-access anyway so\n      // we want to take advantage of approximations\n      BooleanQuery rewritten = new BooleanQuery();\n      rewritten.add(query, Occur.MUST);\n      rewritten.add(((QueryWrapperFilter) filter).getQuery(), Occur.FILTER);\n      rewritten.setBoost(getBoost());\n      return rewritten;\n    }\n\n    final Query queryRewritten = query.rewrite(reader);\n    \n    if (queryRewritten != query) {\n      // rewrite to a new FilteredQuery wrapping the rewritten query\n      final Query rewritten = new FilteredQuery(queryRewritten, filter, strategy);\n      rewritten.setBoost(this.getBoost());\n      return rewritten;\n    } else {\n      // nothing to rewrite, we are done!\n      return this;\n    }\n  }\n\n","bugFix":["9eb3122482ef235fbee3d696501977399ec0af6f","bcf6334db27a9662c6121404be1f1da2598c58a8","882e7a09e9b2251a8c9734723709dbc9865a986d","586cf43028f4cae848088bc127a6e4d6773ce9aa"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f68d01cf19df971dcdcb05e30247f4ad7ec9747","date":1434611645,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FilteredQuery#rewrite(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FilteredQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    final Query queryRewritten = query.rewrite(reader);\n    final Query filterRewritten = filter.rewrite(reader);\n    \n    if (queryRewritten != query || filterRewritten != filter) {\n      // rewrite to a new FilteredQuery wrapping the rewritten query/filter\n      if (filterRewritten instanceof Filter) {\n        final Query rewritten = new FilteredQuery(queryRewritten, (Filter) filterRewritten, strategy);\n        rewritten.setBoost(this.getBoost());\n        return rewritten;\n      } else {\n        // In that case the filter does not implement random-access anyway so\n        // we want to take advantage of approximations\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        builder.add(queryRewritten, Occur.MUST);\n        builder.add(filterRewritten, Occur.FILTER);\n        BooleanQuery rewritten = builder.build();\n        rewritten.setBoost(getBoost());\n        return rewritten;\n      }\n    }\n    // nothing to rewrite, we are done!\n    return this;\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    final Query queryRewritten = query.rewrite(reader);\n    final Query filterRewritten = filter.rewrite(reader);\n    \n    if (queryRewritten != query || filterRewritten != filter) {\n      // rewrite to a new FilteredQuery wrapping the rewritten query/filter\n      if (filterRewritten instanceof Filter) {\n        final Query rewritten = new FilteredQuery(queryRewritten, (Filter) filterRewritten, strategy);\n        rewritten.setBoost(this.getBoost());\n        return rewritten;\n      } else {\n        // In that case the filter does not implement random-access anyway so\n        // we want to take advantage of approximations\n        BooleanQuery rewritten = new BooleanQuery();\n        rewritten.add(queryRewritten, Occur.MUST);\n        rewritten.add(filterRewritten, Occur.FILTER);\n        rewritten.setBoost(getBoost());\n        return rewritten;\n      }\n    }\n    // nothing to rewrite, we are done!\n    return this;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1db68e96dd908fcd79ef809095822736aa601d08","date":1434630596,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/search/FilteredQuery#rewrite(IndexReader).mjava","sourceNew":null,"sourceOld":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    final Query queryRewritten = query.rewrite(reader);\n    final Query filterRewritten = filter.rewrite(reader);\n    \n    if (queryRewritten != query || filterRewritten != filter) {\n      // rewrite to a new FilteredQuery wrapping the rewritten query/filter\n      if (filterRewritten instanceof Filter) {\n        final Query rewritten = new FilteredQuery(queryRewritten, (Filter) filterRewritten, strategy);\n        rewritten.setBoost(this.getBoost());\n        return rewritten;\n      } else {\n        // In that case the filter does not implement random-access anyway so\n        // we want to take advantage of approximations\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        builder.add(queryRewritten, Occur.MUST);\n        builder.add(filterRewritten, Occur.FILTER);\n        BooleanQuery rewritten = builder.build();\n        rewritten.setBoost(getBoost());\n        return rewritten;\n      }\n    }\n    // nothing to rewrite, we are done!\n    return this;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["8249072f13ea4354ab7635c2d7a59cc682806dab"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["40640359164f629dd440a47df2e145d084ce9645","297694897f6cc250f8df8843d76d43efd171dbcd"],"1db68e96dd908fcd79ef809095822736aa601d08":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8249072f13ea4354ab7635c2d7a59cc682806dab":["297694897f6cc250f8df8843d76d43efd171dbcd"],"297694897f6cc250f8df8843d76d43efd171dbcd":["bcf6334db27a9662c6121404be1f1da2598c58a8"],"bcf6334db27a9662c6121404be1f1da2598c58a8":["40640359164f629dd440a47df2e145d084ce9645"],"40640359164f629dd440a47df2e145d084ce9645":["9eb3122482ef235fbee3d696501977399ec0af6f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1db68e96dd908fcd79ef809095822736aa601d08"],"9eb3122482ef235fbee3d696501977399ec0af6f":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"b2d5244a676b83c2d551c3746e8181588ba619e1":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","9eb3122482ef235fbee3d696501977399ec0af6f"]},"commit2Childs":{"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["1db68e96dd908fcd79ef809095822736aa601d08"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"1db68e96dd908fcd79ef809095822736aa601d08":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["9eb3122482ef235fbee3d696501977399ec0af6f","b2d5244a676b83c2d551c3746e8181588ba619e1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"8249072f13ea4354ab7635c2d7a59cc682806dab":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"297694897f6cc250f8df8843d76d43efd171dbcd":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","8249072f13ea4354ab7635c2d7a59cc682806dab"],"bcf6334db27a9662c6121404be1f1da2598c58a8":["297694897f6cc250f8df8843d76d43efd171dbcd"],"40640359164f629dd440a47df2e145d084ce9645":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","bcf6334db27a9662c6121404be1f1da2598c58a8"],"9eb3122482ef235fbee3d696501977399ec0af6f":["40640359164f629dd440a47df2e145d084ce9645","b2d5244a676b83c2d551c3746e8181588ba619e1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b2d5244a676b83c2d551c3746e8181588ba619e1":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817","b2d5244a676b83c2d551c3746e8181588ba619e1"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}