{"path":"lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery#toString(String).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery#toString(String).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/MultiPhraseQuery#toString(String).mjava","sourceNew":"  /** Prints a user-readable version of this query. */\n  @Override\n  public final String toString(String f) {\n    StringBuilder buffer = new StringBuilder();\n    if (field == null || !field.equals(f)) {\n      buffer.append(field);\n      buffer.append(\":\");\n    }\n\n    buffer.append(\"\\\"\");\n    Iterator<Term[]> i = termArrays.iterator();\n    while (i.hasNext()) {\n      Term[] terms = i.next();\n      if (terms.length > 1) {\n        buffer.append(\"(\");\n        for (int j = 0; j < terms.length; j++) {\n          buffer.append(terms[j].text());\n          if (j < terms.length-1)\n            buffer.append(\" \");\n        }\n        buffer.append(\")\");\n      } else {\n        buffer.append(terms[0].text());\n      }\n      if (i.hasNext())\n        buffer.append(\" \");\n    }\n    buffer.append(\"\\\"\");\n\n    if (slop != 0) {\n      buffer.append(\"~\");\n      buffer.append(slop);\n    }\n\n    buffer.append(ToStringUtils.boost(getBoost()));\n\n    return buffer.toString();\n  }\n\n","sourceOld":"  /** Prints a user-readable version of this query. */\n  @Override\n  public final String toString(String f) {\n    StringBuilder buffer = new StringBuilder();\n    if (field == null || !field.equals(f)) {\n      buffer.append(field);\n      buffer.append(\":\");\n    }\n\n    buffer.append(\"\\\"\");\n    Iterator<Term[]> i = termArrays.iterator();\n    while (i.hasNext()) {\n      Term[] terms = i.next();\n      if (terms.length > 1) {\n        buffer.append(\"(\");\n        for (int j = 0; j < terms.length; j++) {\n          buffer.append(terms[j].text());\n          if (j < terms.length-1)\n            buffer.append(\" \");\n        }\n        buffer.append(\")\");\n      } else {\n        buffer.append(terms[0].text());\n      }\n      if (i.hasNext())\n        buffer.append(\" \");\n    }\n    buffer.append(\"\\\"\");\n\n    if (slop != 0) {\n      buffer.append(\"~\");\n      buffer.append(slop);\n    }\n\n    buffer.append(ToStringUtils.boost(getBoost()));\n\n    return buffer.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2eaa5d4d2618a012373ae4574ebb6563933aa9f6","date":1331337973,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery#toString(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery#toString(String).mjava","sourceNew":"  /** Prints a user-readable version of this query. */\n  @Override\n  public final String toString(String f) {\n    StringBuilder buffer = new StringBuilder();\n    if (field == null || !field.equals(f)) {\n      buffer.append(field);\n      buffer.append(\":\");\n    }\n\n    buffer.append(\"\\\"\");\n    int k = 0;\n    Iterator<Term[]> i = termArrays.iterator();\n    int lastPos = -1;\n    boolean first = true;\n    while (i.hasNext()) {\n      Term[] terms = i.next();\n      int position = positions.get(k);\n      if (first) {\n        first = false;\n      } else {\n        buffer.append(\" \");\n        for (int j=1; j<(position-lastPos); j++) {\n          buffer.append(\"? \");\n        }\n      }\n      if (terms.length > 1) {\n        buffer.append(\"(\");\n        for (int j = 0; j < terms.length; j++) {\n          buffer.append(terms[j].text());\n          if (j < terms.length-1)\n            buffer.append(\" \");\n        }\n        buffer.append(\")\");\n      } else {\n        buffer.append(terms[0].text());\n      }\n      lastPos = position;\n      ++k;\n    }\n    buffer.append(\"\\\"\");\n\n    if (slop != 0) {\n      buffer.append(\"~\");\n      buffer.append(slop);\n    }\n\n    buffer.append(ToStringUtils.boost(getBoost()));\n\n    return buffer.toString();\n  }\n\n","sourceOld":"  /** Prints a user-readable version of this query. */\n  @Override\n  public final String toString(String f) {\n    StringBuilder buffer = new StringBuilder();\n    if (field == null || !field.equals(f)) {\n      buffer.append(field);\n      buffer.append(\":\");\n    }\n\n    buffer.append(\"\\\"\");\n    Iterator<Term[]> i = termArrays.iterator();\n    while (i.hasNext()) {\n      Term[] terms = i.next();\n      if (terms.length > 1) {\n        buffer.append(\"(\");\n        for (int j = 0; j < terms.length; j++) {\n          buffer.append(terms[j].text());\n          if (j < terms.length-1)\n            buffer.append(\" \");\n        }\n        buffer.append(\")\");\n      } else {\n        buffer.append(terms[0].text());\n      }\n      if (i.hasNext())\n        buffer.append(\" \");\n    }\n    buffer.append(\"\\\"\");\n\n    if (slop != 0) {\n      buffer.append(\"~\");\n      buffer.append(slop);\n    }\n\n    buffer.append(ToStringUtils.boost(getBoost()));\n\n    return buffer.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery#toString(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery#toString(String).mjava","sourceNew":"  /** Prints a user-readable version of this query. */\n  @Override\n  public final String toString(String f) {\n    StringBuilder buffer = new StringBuilder();\n    if (field == null || !field.equals(f)) {\n      buffer.append(field);\n      buffer.append(\":\");\n    }\n\n    buffer.append(\"\\\"\");\n    int k = 0;\n    Iterator<Term[]> i = termArrays.iterator();\n    int lastPos = -1;\n    boolean first = true;\n    while (i.hasNext()) {\n      Term[] terms = i.next();\n      int position = positions.get(k);\n      if (first) {\n        first = false;\n      } else {\n        buffer.append(\" \");\n        for (int j=1; j<(position-lastPos); j++) {\n          buffer.append(\"? \");\n        }\n      }\n      if (terms.length > 1) {\n        buffer.append(\"(\");\n        for (int j = 0; j < terms.length; j++) {\n          buffer.append(terms[j].text());\n          if (j < terms.length-1)\n            buffer.append(\" \");\n        }\n        buffer.append(\")\");\n      } else {\n        buffer.append(terms[0].text());\n      }\n      lastPos = position;\n      ++k;\n    }\n    buffer.append(\"\\\"\");\n\n    if (slop != 0) {\n      buffer.append(\"~\");\n      buffer.append(slop);\n    }\n\n    buffer.append(ToStringUtils.boost(getBoost()));\n\n    return buffer.toString();\n  }\n\n","sourceOld":"  /** Prints a user-readable version of this query. */\n  @Override\n  public final String toString(String f) {\n    StringBuilder buffer = new StringBuilder();\n    if (field == null || !field.equals(f)) {\n      buffer.append(field);\n      buffer.append(\":\");\n    }\n\n    buffer.append(\"\\\"\");\n    Iterator<Term[]> i = termArrays.iterator();\n    while (i.hasNext()) {\n      Term[] terms = i.next();\n      if (terms.length > 1) {\n        buffer.append(\"(\");\n        for (int j = 0; j < terms.length; j++) {\n          buffer.append(terms[j].text());\n          if (j < terms.length-1)\n            buffer.append(\" \");\n        }\n        buffer.append(\")\");\n      } else {\n        buffer.append(terms[0].text());\n      }\n      if (i.hasNext())\n        buffer.append(\" \");\n    }\n    buffer.append(\"\\\"\");\n\n    if (slop != 0) {\n      buffer.append(\"~\");\n      buffer.append(slop);\n    }\n\n    buffer.append(ToStringUtils.boost(getBoost()));\n\n    return buffer.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2dfdf766e55e943d942055d7de53c7ad6bc45283","date":1441632886,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery#toString(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery#toString(String).mjava","sourceNew":"  /** Prints a user-readable version of this query. */\n  @Override\n  public final String toString(String f) {\n    StringBuilder buffer = new StringBuilder();\n    if (field == null || !field.equals(f)) {\n      buffer.append(field);\n      buffer.append(\":\");\n    }\n\n    buffer.append(\"\\\"\");\n    int k = 0;\n    Iterator<Term[]> i = termArrays.iterator();\n    int lastPos = -1;\n    boolean first = true;\n    while (i.hasNext()) {\n      Term[] terms = i.next();\n      int position = positions.get(k);\n      if (first) {\n        first = false;\n      } else {\n        buffer.append(\" \");\n        for (int j=1; j<(position-lastPos); j++) {\n          buffer.append(\"? \");\n        }\n      }\n      if (terms.length > 1) {\n        buffer.append(\"(\");\n        for (int j = 0; j < terms.length; j++) {\n          buffer.append(terms[j].text());\n          if (j < terms.length-1)\n            buffer.append(\" \");\n        }\n        buffer.append(\")\");\n      } else {\n        buffer.append(terms[0].text());\n      }\n      lastPos = position;\n      ++k;\n    }\n    buffer.append(\"\\\"\");\n\n    if (slop != 0) {\n      buffer.append(\"~\");\n      buffer.append(slop);\n    }\n\n    return buffer.toString();\n  }\n\n","sourceOld":"  /** Prints a user-readable version of this query. */\n  @Override\n  public final String toString(String f) {\n    StringBuilder buffer = new StringBuilder();\n    if (field == null || !field.equals(f)) {\n      buffer.append(field);\n      buffer.append(\":\");\n    }\n\n    buffer.append(\"\\\"\");\n    int k = 0;\n    Iterator<Term[]> i = termArrays.iterator();\n    int lastPos = -1;\n    boolean first = true;\n    while (i.hasNext()) {\n      Term[] terms = i.next();\n      int position = positions.get(k);\n      if (first) {\n        first = false;\n      } else {\n        buffer.append(\" \");\n        for (int j=1; j<(position-lastPos); j++) {\n          buffer.append(\"? \");\n        }\n      }\n      if (terms.length > 1) {\n        buffer.append(\"(\");\n        for (int j = 0; j < terms.length; j++) {\n          buffer.append(terms[j].text());\n          if (j < terms.length-1)\n            buffer.append(\" \");\n        }\n        buffer.append(\")\");\n      } else {\n        buffer.append(terms[0].text());\n      }\n      lastPos = position;\n      ++k;\n    }\n    buffer.append(\"\\\"\");\n\n    if (slop != 0) {\n      buffer.append(\"~\");\n      buffer.append(slop);\n    }\n\n    buffer.append(ToStringUtils.boost(getBoost()));\n\n    return buffer.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"92b4a131f1796dd57cc6698aae3d589d32a29deb","date":1457087316,"type":3,"author":"Luc Vanlerberghe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery#toString(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery#toString(String).mjava","sourceNew":"  /** Prints a user-readable version of this query. */\n  @Override\n  public final String toString(String f) {\n    StringBuilder buffer = new StringBuilder();\n    if (field == null || !field.equals(f)) {\n      buffer.append(field);\n      buffer.append(\":\");\n    }\n\n    buffer.append(\"\\\"\");\n    int lastPos = -1;\n\n    for (int i = 0 ; i < termArrays.length ; ++i) {\n      Term[] terms = termArrays[i];\n      int position = positions[i];\n      if (i != 0) {\n        buffer.append(\" \");\n        for (int j=1; j<(position-lastPos); j++) {\n          buffer.append(\"? \");\n        }\n      }\n      if (terms.length > 1) {\n        buffer.append(\"(\");\n        for (int j = 0; j < terms.length; j++) {\n          buffer.append(terms[j].text());\n          if (j < terms.length-1)\n            buffer.append(\" \");\n        }\n        buffer.append(\")\");\n      } else {\n        buffer.append(terms[0].text());\n      }\n      lastPos = position;\n    }\n    buffer.append(\"\\\"\");\n\n    if (slop != 0) {\n      buffer.append(\"~\");\n      buffer.append(slop);\n    }\n\n    return buffer.toString();\n  }\n\n","sourceOld":"  /** Prints a user-readable version of this query. */\n  @Override\n  public final String toString(String f) {\n    StringBuilder buffer = new StringBuilder();\n    if (field == null || !field.equals(f)) {\n      buffer.append(field);\n      buffer.append(\":\");\n    }\n\n    buffer.append(\"\\\"\");\n    int k = 0;\n    Iterator<Term[]> i = termArrays.iterator();\n    int lastPos = -1;\n    boolean first = true;\n    while (i.hasNext()) {\n      Term[] terms = i.next();\n      int position = positions.get(k);\n      if (first) {\n        first = false;\n      } else {\n        buffer.append(\" \");\n        for (int j=1; j<(position-lastPos); j++) {\n          buffer.append(\"? \");\n        }\n      }\n      if (terms.length > 1) {\n        buffer.append(\"(\");\n        for (int j = 0; j < terms.length; j++) {\n          buffer.append(terms[j].text());\n          if (j < terms.length-1)\n            buffer.append(\" \");\n        }\n        buffer.append(\")\");\n      } else {\n        buffer.append(terms[0].text());\n      }\n      lastPos = position;\n      ++k;\n    }\n    buffer.append(\"\\\"\");\n\n    if (slop != 0) {\n      buffer.append(\"~\");\n      buffer.append(slop);\n    }\n\n    return buffer.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery#toString(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery#toString(String).mjava","sourceNew":"  /** Prints a user-readable version of this query. */\n  @Override\n  public final String toString(String f) {\n    StringBuilder buffer = new StringBuilder();\n    if (field == null || !field.equals(f)) {\n      buffer.append(field);\n      buffer.append(\":\");\n    }\n\n    buffer.append(\"\\\"\");\n    int lastPos = -1;\n\n    for (int i = 0 ; i < termArrays.length ; ++i) {\n      Term[] terms = termArrays[i];\n      int position = positions[i];\n      if (i != 0) {\n        buffer.append(\" \");\n        for (int j=1; j<(position-lastPos); j++) {\n          buffer.append(\"? \");\n        }\n      }\n      if (terms.length > 1) {\n        buffer.append(\"(\");\n        for (int j = 0; j < terms.length; j++) {\n          buffer.append(terms[j].text());\n          if (j < terms.length-1)\n            buffer.append(\" \");\n        }\n        buffer.append(\")\");\n      } else {\n        buffer.append(terms[0].text());\n      }\n      lastPos = position;\n    }\n    buffer.append(\"\\\"\");\n\n    if (slop != 0) {\n      buffer.append(\"~\");\n      buffer.append(slop);\n    }\n\n    return buffer.toString();\n  }\n\n","sourceOld":"  /** Prints a user-readable version of this query. */\n  @Override\n  public final String toString(String f) {\n    StringBuilder buffer = new StringBuilder();\n    if (field == null || !field.equals(f)) {\n      buffer.append(field);\n      buffer.append(\":\");\n    }\n\n    buffer.append(\"\\\"\");\n    int k = 0;\n    Iterator<Term[]> i = termArrays.iterator();\n    int lastPos = -1;\n    boolean first = true;\n    while (i.hasNext()) {\n      Term[] terms = i.next();\n      int position = positions.get(k);\n      if (first) {\n        first = false;\n      } else {\n        buffer.append(\" \");\n        for (int j=1; j<(position-lastPos); j++) {\n          buffer.append(\"? \");\n        }\n      }\n      if (terms.length > 1) {\n        buffer.append(\"(\");\n        for (int j = 0; j < terms.length; j++) {\n          buffer.append(terms[j].text());\n          if (j < terms.length-1)\n            buffer.append(\" \");\n        }\n        buffer.append(\")\");\n      } else {\n        buffer.append(terms[0].text());\n      }\n      lastPos = position;\n      ++k;\n    }\n    buffer.append(\"\\\"\");\n\n    if (slop != 0) {\n      buffer.append(\"~\");\n      buffer.append(slop);\n    }\n\n    return buffer.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"38e3b736c7ca086d61b7dbb841c905ee115490da":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","2eaa5d4d2618a012373ae4574ebb6563933aa9f6"],"2eaa5d4d2618a012373ae4574ebb6563933aa9f6":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"92b4a131f1796dd57cc6698aae3d589d32a29deb":["2dfdf766e55e943d942055d7de53c7ad6bc45283"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2dfdf766e55e943d942055d7de53c7ad6bc45283":["2eaa5d4d2618a012373ae4574ebb6563933aa9f6"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["2dfdf766e55e943d942055d7de53c7ad6bc45283","92b4a131f1796dd57cc6698aae3d589d32a29deb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"]},"commit2Childs":{"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"2eaa5d4d2618a012373ae4574ebb6563933aa9f6":["38e3b736c7ca086d61b7dbb841c905ee115490da","2dfdf766e55e943d942055d7de53c7ad6bc45283"],"92b4a131f1796dd57cc6698aae3d589d32a29deb":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["38e3b736c7ca086d61b7dbb841c905ee115490da","2eaa5d4d2618a012373ae4574ebb6563933aa9f6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"2dfdf766e55e943d942055d7de53c7ad6bc45283":["92b4a131f1796dd57cc6698aae3d589d32a29deb","cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["38e3b736c7ca086d61b7dbb841c905ee115490da","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}