{"path":"solr/core/src/test/org/apache/solr/CursorPagingTest#testCacheImpacts().mjava","commits":[{"id":"d5bc8e25f59990525f5beb14afe9c96240dcf4a2","date":1389042945,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/CursorPagingTest#testCacheImpacts().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * test that our assumptions about how caches are affected hold true\n   */\n  public void testCacheImpacts() throws Exception {\n    // cursor queryies can't live in the queryResultCache, but independent filters\n    // should still be cached & reused\n\n    // don't add in order of any field to ensure we aren't inadvertantly \n    // counting on internal docid ordering\n    assertU(adoc(\"id\", \"9\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"42\"));\n    assertU(adoc(\"id\", \"7\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"-1976\"));\n    assertU(adoc(\"id\", \"2\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"666\"));\n    assertU(adoc(\"id\", \"0\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"-42\"));\n    assertU(adoc(\"id\", \"5\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"2001\"));\n    assertU(adoc(\"id\", \"8\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"4055\"));\n    assertU(adoc(\"id\", \"6\", \"str\", \"a\", \"float\", \"64.5\", \"int\", \"7\"));\n    assertU(adoc(\"id\", \"1\", \"str\", \"a\", \"float\", \"64.5\", \"int\", \"7\"));\n    assertU(adoc(\"id\", \"4\", \"str\", \"a\", \"float\", \"11.1\", \"int\", \"6\"));\n    assertU(adoc(\"id\", \"3\", \"str\", \"a\", \"float\", \"11.1\", \"int\", \"3\"));\n    assertU(commit());\n\n    final Collection<String> allFieldNames = getAllFieldNames();\n\n    final SolrInfoMBean filterCacheStats \n      = h.getCore().getInfoRegistry().get(\"filterCache\");\n    assertNotNull(filterCacheStats);\n    final SolrInfoMBean queryCacheStats \n      = h.getCore().getInfoRegistry().get(\"queryResultCache\");\n    assertNotNull(queryCacheStats);\n\n    final long preQcIn = (Long) queryCacheStats.getStatistics().get(\"inserts\");\n    final long preFcIn = (Long) filterCacheStats.getStatistics().get(\"inserts\");\n    final long preFcHits = (Long) filterCacheStats.getStatistics().get(\"hits\");\n\n    SentinelIntSet ids = assertFullWalkNoDups\n      (10, params(\"q\", \"*:*\",\n                  \"rows\",\"\"+_TestUtil.nextInt(random(),1,11),\n                  \"fq\", \"-id:[1 TO 2]\",\n                  \"fq\", \"-id:[6 TO 7]\",\n                  \"fl\", \"id\",\n                  \"sort\", buildRandomSort(allFieldNames)));\n    \n    assertEquals(6, ids.size());\n\n    final long postQcIn = (Long) queryCacheStats.getStatistics().get(\"inserts\");\n    final long postFcIn = (Long) filterCacheStats.getStatistics().get(\"inserts\");\n    final long postFcHits = (Long) filterCacheStats.getStatistics().get(\"hits\");\n    \n    assertEquals(\"query cache inserts changed\", preQcIn, postQcIn);\n    // NOTE: use of pure negative filters causees \"*:* to be tracked in filterCache\n    assertEquals(\"filter cache did not grow correctly\", 3, postFcIn-preFcIn);\n    assertTrue(\"filter cache did not have any new cache hits\", 0 < postFcHits-preFcHits);\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6a0f9b793b360e5f5863eef2d4b02a2ddd8b47b4","date":1390935815,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/CursorPagingTest#testCacheImpacts().mjava","pathOld":"solr/core/src/test/org/apache/solr/CursorPagingTest#testCacheImpacts().mjava","sourceNew":"  /**\n   * test that our assumptions about how caches are affected hold true\n   */\n  public void testCacheImpacts() throws Exception {\n    // cursor queryies can't live in the queryResultCache, but independent filters\n    // should still be cached & reused\n\n    // don't add in order of any field to ensure we aren't inadvertantly \n    // counting on internal docid ordering\n    assertU(adoc(\"id\", \"9\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"42\"));\n    assertU(adoc(\"id\", \"7\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"-1976\"));\n    assertU(adoc(\"id\", \"2\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"666\"));\n    assertU(adoc(\"id\", \"0\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"-42\"));\n    assertU(adoc(\"id\", \"5\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"2001\"));\n    assertU(adoc(\"id\", \"8\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"4055\"));\n    assertU(adoc(\"id\", \"6\", \"str\", \"a\", \"float\", \"64.5\", \"int\", \"7\"));\n    assertU(adoc(\"id\", \"1\", \"str\", \"a\", \"float\", \"64.5\", \"int\", \"7\"));\n    assertU(adoc(\"id\", \"4\", \"str\", \"a\", \"float\", \"11.1\", \"int\", \"6\"));\n    assertU(adoc(\"id\", \"3\", \"str\", \"a\", \"float\", \"11.1\", \"int\", \"3\"));\n    assertU(commit());\n\n    final Collection<String> allFieldNames = getAllSortFieldNames();\n\n    final SolrInfoMBean filterCacheStats \n      = h.getCore().getInfoRegistry().get(\"filterCache\");\n    assertNotNull(filterCacheStats);\n    final SolrInfoMBean queryCacheStats \n      = h.getCore().getInfoRegistry().get(\"queryResultCache\");\n    assertNotNull(queryCacheStats);\n\n    final long preQcIn = (Long) queryCacheStats.getStatistics().get(\"inserts\");\n    final long preFcIn = (Long) filterCacheStats.getStatistics().get(\"inserts\");\n    final long preFcHits = (Long) filterCacheStats.getStatistics().get(\"hits\");\n\n    SentinelIntSet ids = assertFullWalkNoDups\n      (10, params(\"q\", \"*:*\",\n                  \"rows\",\"\"+_TestUtil.nextInt(random(),1,11),\n                  \"fq\", \"-id:[1 TO 2]\",\n                  \"fq\", \"-id:[6 TO 7]\",\n                  \"fl\", \"id\",\n                  \"sort\", buildRandomSort(allFieldNames)));\n    \n    assertEquals(6, ids.size());\n\n    final long postQcIn = (Long) queryCacheStats.getStatistics().get(\"inserts\");\n    final long postFcIn = (Long) filterCacheStats.getStatistics().get(\"inserts\");\n    final long postFcHits = (Long) filterCacheStats.getStatistics().get(\"hits\");\n    \n    assertEquals(\"query cache inserts changed\", preQcIn, postQcIn);\n    // NOTE: use of pure negative filters causees \"*:* to be tracked in filterCache\n    assertEquals(\"filter cache did not grow correctly\", 3, postFcIn-preFcIn);\n    assertTrue(\"filter cache did not have any new cache hits\", 0 < postFcHits-preFcHits);\n\n  }\n\n","sourceOld":"  /**\n   * test that our assumptions about how caches are affected hold true\n   */\n  public void testCacheImpacts() throws Exception {\n    // cursor queryies can't live in the queryResultCache, but independent filters\n    // should still be cached & reused\n\n    // don't add in order of any field to ensure we aren't inadvertantly \n    // counting on internal docid ordering\n    assertU(adoc(\"id\", \"9\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"42\"));\n    assertU(adoc(\"id\", \"7\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"-1976\"));\n    assertU(adoc(\"id\", \"2\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"666\"));\n    assertU(adoc(\"id\", \"0\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"-42\"));\n    assertU(adoc(\"id\", \"5\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"2001\"));\n    assertU(adoc(\"id\", \"8\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"4055\"));\n    assertU(adoc(\"id\", \"6\", \"str\", \"a\", \"float\", \"64.5\", \"int\", \"7\"));\n    assertU(adoc(\"id\", \"1\", \"str\", \"a\", \"float\", \"64.5\", \"int\", \"7\"));\n    assertU(adoc(\"id\", \"4\", \"str\", \"a\", \"float\", \"11.1\", \"int\", \"6\"));\n    assertU(adoc(\"id\", \"3\", \"str\", \"a\", \"float\", \"11.1\", \"int\", \"3\"));\n    assertU(commit());\n\n    final Collection<String> allFieldNames = getAllFieldNames();\n\n    final SolrInfoMBean filterCacheStats \n      = h.getCore().getInfoRegistry().get(\"filterCache\");\n    assertNotNull(filterCacheStats);\n    final SolrInfoMBean queryCacheStats \n      = h.getCore().getInfoRegistry().get(\"queryResultCache\");\n    assertNotNull(queryCacheStats);\n\n    final long preQcIn = (Long) queryCacheStats.getStatistics().get(\"inserts\");\n    final long preFcIn = (Long) filterCacheStats.getStatistics().get(\"inserts\");\n    final long preFcHits = (Long) filterCacheStats.getStatistics().get(\"hits\");\n\n    SentinelIntSet ids = assertFullWalkNoDups\n      (10, params(\"q\", \"*:*\",\n                  \"rows\",\"\"+_TestUtil.nextInt(random(),1,11),\n                  \"fq\", \"-id:[1 TO 2]\",\n                  \"fq\", \"-id:[6 TO 7]\",\n                  \"fl\", \"id\",\n                  \"sort\", buildRandomSort(allFieldNames)));\n    \n    assertEquals(6, ids.size());\n\n    final long postQcIn = (Long) queryCacheStats.getStatistics().get(\"inserts\");\n    final long postFcIn = (Long) filterCacheStats.getStatistics().get(\"inserts\");\n    final long postFcHits = (Long) filterCacheStats.getStatistics().get(\"hits\");\n    \n    assertEquals(\"query cache inserts changed\", preQcIn, postQcIn);\n    // NOTE: use of pure negative filters causees \"*:* to be tracked in filterCache\n    assertEquals(\"filter cache did not grow correctly\", 3, postFcIn-preFcIn);\n    assertTrue(\"filter cache did not have any new cache hits\", 0 < postFcHits-preFcHits);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/CursorPagingTest#testCacheImpacts().mjava","pathOld":"solr/core/src/test/org/apache/solr/CursorPagingTest#testCacheImpacts().mjava","sourceNew":"  /**\n   * test that our assumptions about how caches are affected hold true\n   */\n  public void testCacheImpacts() throws Exception {\n    // cursor queryies can't live in the queryResultCache, but independent filters\n    // should still be cached & reused\n\n    // don't add in order of any field to ensure we aren't inadvertantly \n    // counting on internal docid ordering\n    assertU(adoc(\"id\", \"9\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"42\"));\n    assertU(adoc(\"id\", \"7\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"-1976\"));\n    assertU(adoc(\"id\", \"2\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"666\"));\n    assertU(adoc(\"id\", \"0\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"-42\"));\n    assertU(adoc(\"id\", \"5\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"2001\"));\n    assertU(adoc(\"id\", \"8\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"4055\"));\n    assertU(adoc(\"id\", \"6\", \"str\", \"a\", \"float\", \"64.5\", \"int\", \"7\"));\n    assertU(adoc(\"id\", \"1\", \"str\", \"a\", \"float\", \"64.5\", \"int\", \"7\"));\n    assertU(adoc(\"id\", \"4\", \"str\", \"a\", \"float\", \"11.1\", \"int\", \"6\"));\n    assertU(adoc(\"id\", \"3\", \"str\", \"a\", \"float\", \"11.1\", \"int\", \"3\"));\n    assertU(commit());\n\n    final Collection<String> allFieldNames = getAllSortFieldNames();\n\n    final SolrInfoMBean filterCacheStats \n      = h.getCore().getInfoRegistry().get(\"filterCache\");\n    assertNotNull(filterCacheStats);\n    final SolrInfoMBean queryCacheStats \n      = h.getCore().getInfoRegistry().get(\"queryResultCache\");\n    assertNotNull(queryCacheStats);\n\n    final long preQcIn = (Long) queryCacheStats.getStatistics().get(\"inserts\");\n    final long preFcIn = (Long) filterCacheStats.getStatistics().get(\"inserts\");\n    final long preFcHits = (Long) filterCacheStats.getStatistics().get(\"hits\");\n\n    SentinelIntSet ids = assertFullWalkNoDups\n      (10, params(\"q\", \"*:*\",\n                  \"rows\",\"\"+ TestUtil.nextInt(random(), 1, 11),\n                  \"fq\", \"-id:[1 TO 2]\",\n                  \"fq\", \"-id:[6 TO 7]\",\n                  \"fl\", \"id\",\n                  \"sort\", buildRandomSort(allFieldNames)));\n    \n    assertEquals(6, ids.size());\n\n    final long postQcIn = (Long) queryCacheStats.getStatistics().get(\"inserts\");\n    final long postFcIn = (Long) filterCacheStats.getStatistics().get(\"inserts\");\n    final long postFcHits = (Long) filterCacheStats.getStatistics().get(\"hits\");\n    \n    assertEquals(\"query cache inserts changed\", preQcIn, postQcIn);\n    // NOTE: use of pure negative filters causees \"*:* to be tracked in filterCache\n    assertEquals(\"filter cache did not grow correctly\", 3, postFcIn-preFcIn);\n    assertTrue(\"filter cache did not have any new cache hits\", 0 < postFcHits-preFcHits);\n\n  }\n\n","sourceOld":"  /**\n   * test that our assumptions about how caches are affected hold true\n   */\n  public void testCacheImpacts() throws Exception {\n    // cursor queryies can't live in the queryResultCache, but independent filters\n    // should still be cached & reused\n\n    // don't add in order of any field to ensure we aren't inadvertantly \n    // counting on internal docid ordering\n    assertU(adoc(\"id\", \"9\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"42\"));\n    assertU(adoc(\"id\", \"7\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"-1976\"));\n    assertU(adoc(\"id\", \"2\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"666\"));\n    assertU(adoc(\"id\", \"0\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"-42\"));\n    assertU(adoc(\"id\", \"5\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"2001\"));\n    assertU(adoc(\"id\", \"8\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"4055\"));\n    assertU(adoc(\"id\", \"6\", \"str\", \"a\", \"float\", \"64.5\", \"int\", \"7\"));\n    assertU(adoc(\"id\", \"1\", \"str\", \"a\", \"float\", \"64.5\", \"int\", \"7\"));\n    assertU(adoc(\"id\", \"4\", \"str\", \"a\", \"float\", \"11.1\", \"int\", \"6\"));\n    assertU(adoc(\"id\", \"3\", \"str\", \"a\", \"float\", \"11.1\", \"int\", \"3\"));\n    assertU(commit());\n\n    final Collection<String> allFieldNames = getAllSortFieldNames();\n\n    final SolrInfoMBean filterCacheStats \n      = h.getCore().getInfoRegistry().get(\"filterCache\");\n    assertNotNull(filterCacheStats);\n    final SolrInfoMBean queryCacheStats \n      = h.getCore().getInfoRegistry().get(\"queryResultCache\");\n    assertNotNull(queryCacheStats);\n\n    final long preQcIn = (Long) queryCacheStats.getStatistics().get(\"inserts\");\n    final long preFcIn = (Long) filterCacheStats.getStatistics().get(\"inserts\");\n    final long preFcHits = (Long) filterCacheStats.getStatistics().get(\"hits\");\n\n    SentinelIntSet ids = assertFullWalkNoDups\n      (10, params(\"q\", \"*:*\",\n                  \"rows\",\"\"+_TestUtil.nextInt(random(),1,11),\n                  \"fq\", \"-id:[1 TO 2]\",\n                  \"fq\", \"-id:[6 TO 7]\",\n                  \"fl\", \"id\",\n                  \"sort\", buildRandomSort(allFieldNames)));\n    \n    assertEquals(6, ids.size());\n\n    final long postQcIn = (Long) queryCacheStats.getStatistics().get(\"inserts\");\n    final long postFcIn = (Long) filterCacheStats.getStatistics().get(\"inserts\");\n    final long postFcHits = (Long) filterCacheStats.getStatistics().get(\"hits\");\n    \n    assertEquals(\"query cache inserts changed\", preQcIn, postQcIn);\n    // NOTE: use of pure negative filters causees \"*:* to be tracked in filterCache\n    assertEquals(\"filter cache did not grow correctly\", 3, postFcIn-preFcIn);\n    assertTrue(\"filter cache did not have any new cache hits\", 0 < postFcHits-preFcHits);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"816521ebaad5add9cb96bb88c577394e2938c40b","date":1491931343,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/CursorPagingTest#testCacheImpacts().mjava","pathOld":"solr/core/src/test/org/apache/solr/CursorPagingTest#testCacheImpacts().mjava","sourceNew":"  /**\n   * test that our assumptions about how caches are affected hold true\n   */\n  public void testCacheImpacts() throws Exception {\n    // cursor queryies can't live in the queryResultCache, but independent filters\n    // should still be cached & reused\n\n    // don't add in order of any field to ensure we aren't inadvertantly \n    // counting on internal docid ordering\n    assertU(adoc(\"id\", \"9\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"42\"));\n    assertU(adoc(\"id\", \"7\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"-1976\"));\n    assertU(adoc(\"id\", \"2\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"666\"));\n    assertU(adoc(\"id\", \"0\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"-42\"));\n    assertU(adoc(\"id\", \"5\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"2001\"));\n    assertU(adoc(\"id\", \"8\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"4055\"));\n    assertU(adoc(\"id\", \"6\", \"str\", \"a\", \"float\", \"64.5\", \"int\", \"7\"));\n    assertU(adoc(\"id\", \"1\", \"str\", \"a\", \"float\", \"64.5\", \"int\", \"7\"));\n    assertU(adoc(\"id\", \"4\", \"str\", \"a\", \"float\", \"11.1\", \"int\", \"6\"));\n    assertU(adoc(\"id\", \"3\", \"str\", \"a\", \"float\", \"11.1\", \"int\", \"3\"));\n    assertU(commit());\n\n    final Collection<String> allFieldNames = getAllSortFieldNames();\n\n    final MetricsMap filterCacheStats =\n        (MetricsMap)h.getCore().getCoreMetricManager().getRegistry().getMetrics().get(\"CACHE.searcher.filterCache\");\n    assertNotNull(filterCacheStats);\n    final MetricsMap queryCacheStats =\n        (MetricsMap)h.getCore().getCoreMetricManager().getRegistry().getMetrics().get(\"CACHE.searcher.queryResultCache\");\n    assertNotNull(queryCacheStats);\n\n    final long preQcIn = (Long) queryCacheStats.getValue().get(\"inserts\");\n    final long preFcIn = (Long) filterCacheStats.getValue().get(\"inserts\");\n    final long preFcHits = (Long) filterCacheStats.getValue().get(\"hits\");\n\n    SentinelIntSet ids = assertFullWalkNoDups\n      (10, params(\"q\", \"*:*\",\n                  \"rows\",\"\"+ TestUtil.nextInt(random(), 1, 11),\n                  \"fq\", \"-id:[1 TO 2]\",\n                  \"fq\", \"-id:[6 TO 7]\",\n                  \"fl\", \"id\",\n                  \"sort\", buildRandomSort(allFieldNames)));\n    \n    assertEquals(6, ids.size());\n\n    final long postQcIn = (Long) queryCacheStats.getValue().get(\"inserts\");\n    final long postFcIn = (Long) filterCacheStats.getValue().get(\"inserts\");\n    final long postFcHits = (Long) filterCacheStats.getValue().get(\"hits\");\n    \n    assertEquals(\"query cache inserts changed\", preQcIn, postQcIn);\n    // NOTE: use of pure negative filters causees \"*:* to be tracked in filterCache\n    assertEquals(\"filter cache did not grow correctly\", 3, postFcIn-preFcIn);\n    assertTrue(\"filter cache did not have any new cache hits\", 0 < postFcHits-preFcHits);\n\n  }\n\n","sourceOld":"  /**\n   * test that our assumptions about how caches are affected hold true\n   */\n  public void testCacheImpacts() throws Exception {\n    // cursor queryies can't live in the queryResultCache, but independent filters\n    // should still be cached & reused\n\n    // don't add in order of any field to ensure we aren't inadvertantly \n    // counting on internal docid ordering\n    assertU(adoc(\"id\", \"9\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"42\"));\n    assertU(adoc(\"id\", \"7\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"-1976\"));\n    assertU(adoc(\"id\", \"2\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"666\"));\n    assertU(adoc(\"id\", \"0\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"-42\"));\n    assertU(adoc(\"id\", \"5\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"2001\"));\n    assertU(adoc(\"id\", \"8\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"4055\"));\n    assertU(adoc(\"id\", \"6\", \"str\", \"a\", \"float\", \"64.5\", \"int\", \"7\"));\n    assertU(adoc(\"id\", \"1\", \"str\", \"a\", \"float\", \"64.5\", \"int\", \"7\"));\n    assertU(adoc(\"id\", \"4\", \"str\", \"a\", \"float\", \"11.1\", \"int\", \"6\"));\n    assertU(adoc(\"id\", \"3\", \"str\", \"a\", \"float\", \"11.1\", \"int\", \"3\"));\n    assertU(commit());\n\n    final Collection<String> allFieldNames = getAllSortFieldNames();\n\n    final SolrInfoMBean filterCacheStats \n      = h.getCore().getInfoRegistry().get(\"filterCache\");\n    assertNotNull(filterCacheStats);\n    final SolrInfoMBean queryCacheStats \n      = h.getCore().getInfoRegistry().get(\"queryResultCache\");\n    assertNotNull(queryCacheStats);\n\n    final long preQcIn = (Long) queryCacheStats.getStatistics().get(\"inserts\");\n    final long preFcIn = (Long) filterCacheStats.getStatistics().get(\"inserts\");\n    final long preFcHits = (Long) filterCacheStats.getStatistics().get(\"hits\");\n\n    SentinelIntSet ids = assertFullWalkNoDups\n      (10, params(\"q\", \"*:*\",\n                  \"rows\",\"\"+ TestUtil.nextInt(random(), 1, 11),\n                  \"fq\", \"-id:[1 TO 2]\",\n                  \"fq\", \"-id:[6 TO 7]\",\n                  \"fl\", \"id\",\n                  \"sort\", buildRandomSort(allFieldNames)));\n    \n    assertEquals(6, ids.size());\n\n    final long postQcIn = (Long) queryCacheStats.getStatistics().get(\"inserts\");\n    final long postFcIn = (Long) filterCacheStats.getStatistics().get(\"inserts\");\n    final long postFcHits = (Long) filterCacheStats.getStatistics().get(\"hits\");\n    \n    assertEquals(\"query cache inserts changed\", preQcIn, postQcIn);\n    // NOTE: use of pure negative filters causees \"*:* to be tracked in filterCache\n    assertEquals(\"filter cache did not grow correctly\", 3, postFcIn-preFcIn);\n    assertTrue(\"filter cache did not have any new cache hits\", 0 < postFcHits-preFcHits);\n\n  }\n\n","bugFix":null,"bugIntro":["bfc52860e6d13d034226a760813c59d984c6817a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/CursorPagingTest#testCacheImpacts().mjava","pathOld":"solr/core/src/test/org/apache/solr/CursorPagingTest#testCacheImpacts().mjava","sourceNew":"  /**\n   * test that our assumptions about how caches are affected hold true\n   */\n  public void testCacheImpacts() throws Exception {\n    // cursor queryies can't live in the queryResultCache, but independent filters\n    // should still be cached & reused\n\n    // don't add in order of any field to ensure we aren't inadvertantly \n    // counting on internal docid ordering\n    assertU(adoc(\"id\", \"9\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"42\"));\n    assertU(adoc(\"id\", \"7\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"-1976\"));\n    assertU(adoc(\"id\", \"2\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"666\"));\n    assertU(adoc(\"id\", \"0\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"-42\"));\n    assertU(adoc(\"id\", \"5\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"2001\"));\n    assertU(adoc(\"id\", \"8\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"4055\"));\n    assertU(adoc(\"id\", \"6\", \"str\", \"a\", \"float\", \"64.5\", \"int\", \"7\"));\n    assertU(adoc(\"id\", \"1\", \"str\", \"a\", \"float\", \"64.5\", \"int\", \"7\"));\n    assertU(adoc(\"id\", \"4\", \"str\", \"a\", \"float\", \"11.1\", \"int\", \"6\"));\n    assertU(adoc(\"id\", \"3\", \"str\", \"a\", \"float\", \"11.1\", \"int\", \"3\"));\n    assertU(commit());\n\n    final Collection<String> allFieldNames = getAllSortFieldNames();\n\n    final MetricsMap filterCacheStats =\n        (MetricsMap)h.getCore().getCoreMetricManager().getRegistry().getMetrics().get(\"CACHE.searcher.filterCache\");\n    assertNotNull(filterCacheStats);\n    final MetricsMap queryCacheStats =\n        (MetricsMap)h.getCore().getCoreMetricManager().getRegistry().getMetrics().get(\"CACHE.searcher.queryResultCache\");\n    assertNotNull(queryCacheStats);\n\n    final long preQcIn = (Long) queryCacheStats.getValue().get(\"inserts\");\n    final long preFcIn = (Long) filterCacheStats.getValue().get(\"inserts\");\n    final long preFcHits = (Long) filterCacheStats.getValue().get(\"hits\");\n\n    SentinelIntSet ids = assertFullWalkNoDups\n      (10, params(\"q\", \"*:*\",\n                  \"rows\",\"\"+ TestUtil.nextInt(random(), 1, 11),\n                  \"fq\", \"-id:[1 TO 2]\",\n                  \"fq\", \"-id:[6 TO 7]\",\n                  \"fl\", \"id\",\n                  \"sort\", buildRandomSort(allFieldNames)));\n    \n    assertEquals(6, ids.size());\n\n    final long postQcIn = (Long) queryCacheStats.getValue().get(\"inserts\");\n    final long postFcIn = (Long) filterCacheStats.getValue().get(\"inserts\");\n    final long postFcHits = (Long) filterCacheStats.getValue().get(\"hits\");\n    \n    assertEquals(\"query cache inserts changed\", preQcIn, postQcIn);\n    // NOTE: use of pure negative filters causees \"*:* to be tracked in filterCache\n    assertEquals(\"filter cache did not grow correctly\", 3, postFcIn-preFcIn);\n    assertTrue(\"filter cache did not have any new cache hits\", 0 < postFcHits-preFcHits);\n\n  }\n\n","sourceOld":"  /**\n   * test that our assumptions about how caches are affected hold true\n   */\n  public void testCacheImpacts() throws Exception {\n    // cursor queryies can't live in the queryResultCache, but independent filters\n    // should still be cached & reused\n\n    // don't add in order of any field to ensure we aren't inadvertantly \n    // counting on internal docid ordering\n    assertU(adoc(\"id\", \"9\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"42\"));\n    assertU(adoc(\"id\", \"7\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"-1976\"));\n    assertU(adoc(\"id\", \"2\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"666\"));\n    assertU(adoc(\"id\", \"0\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"-42\"));\n    assertU(adoc(\"id\", \"5\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"2001\"));\n    assertU(adoc(\"id\", \"8\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"4055\"));\n    assertU(adoc(\"id\", \"6\", \"str\", \"a\", \"float\", \"64.5\", \"int\", \"7\"));\n    assertU(adoc(\"id\", \"1\", \"str\", \"a\", \"float\", \"64.5\", \"int\", \"7\"));\n    assertU(adoc(\"id\", \"4\", \"str\", \"a\", \"float\", \"11.1\", \"int\", \"6\"));\n    assertU(adoc(\"id\", \"3\", \"str\", \"a\", \"float\", \"11.1\", \"int\", \"3\"));\n    assertU(commit());\n\n    final Collection<String> allFieldNames = getAllSortFieldNames();\n\n    final SolrInfoMBean filterCacheStats \n      = h.getCore().getInfoRegistry().get(\"filterCache\");\n    assertNotNull(filterCacheStats);\n    final SolrInfoMBean queryCacheStats \n      = h.getCore().getInfoRegistry().get(\"queryResultCache\");\n    assertNotNull(queryCacheStats);\n\n    final long preQcIn = (Long) queryCacheStats.getStatistics().get(\"inserts\");\n    final long preFcIn = (Long) filterCacheStats.getStatistics().get(\"inserts\");\n    final long preFcHits = (Long) filterCacheStats.getStatistics().get(\"hits\");\n\n    SentinelIntSet ids = assertFullWalkNoDups\n      (10, params(\"q\", \"*:*\",\n                  \"rows\",\"\"+ TestUtil.nextInt(random(), 1, 11),\n                  \"fq\", \"-id:[1 TO 2]\",\n                  \"fq\", \"-id:[6 TO 7]\",\n                  \"fl\", \"id\",\n                  \"sort\", buildRandomSort(allFieldNames)));\n    \n    assertEquals(6, ids.size());\n\n    final long postQcIn = (Long) queryCacheStats.getStatistics().get(\"inserts\");\n    final long postFcIn = (Long) filterCacheStats.getStatistics().get(\"inserts\");\n    final long postFcHits = (Long) filterCacheStats.getStatistics().get(\"hits\");\n    \n    assertEquals(\"query cache inserts changed\", preQcIn, postQcIn);\n    // NOTE: use of pure negative filters causees \"*:* to be tracked in filterCache\n    assertEquals(\"filter cache did not grow correctly\", 3, postFcIn-preFcIn);\n    assertTrue(\"filter cache did not have any new cache hits\", 0 < postFcHits-preFcHits);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bfc52860e6d13d034226a760813c59d984c6817a","date":1522229027,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/CursorPagingTest#testCacheImpacts().mjava","pathOld":"solr/core/src/test/org/apache/solr/CursorPagingTest#testCacheImpacts().mjava","sourceNew":"  /**\n   * test that our assumptions about how caches are affected hold true\n   */\n  public void testCacheImpacts() throws Exception {\n    // cursor queryies can't live in the queryResultCache, but independent filters\n    // should still be cached & reused\n\n    // don't add in order of any field to ensure we aren't inadvertantly \n    // counting on internal docid ordering\n    assertU(adoc(\"id\", \"9\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"42\"));\n    assertU(adoc(\"id\", \"7\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"-1976\"));\n    assertU(adoc(\"id\", \"2\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"666\"));\n    assertU(adoc(\"id\", \"0\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"-42\"));\n    assertU(adoc(\"id\", \"5\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"2001\"));\n    assertU(adoc(\"id\", \"8\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"4055\"));\n    assertU(adoc(\"id\", \"6\", \"str\", \"a\", \"float\", \"64.5\", \"int\", \"7\"));\n    assertU(adoc(\"id\", \"1\", \"str\", \"a\", \"float\", \"64.5\", \"int\", \"7\"));\n    assertU(adoc(\"id\", \"4\", \"str\", \"a\", \"float\", \"11.1\", \"int\", \"6\"));\n    assertU(adoc(\"id\", \"3\", \"str\", \"a\", \"float\", \"11.1\", \"int\", \"3\"));\n    assertU(commit());\n\n    final Collection<String> allFieldNames = getAllSortFieldNames();\n\n    final MetricsMap filterCacheStats =\n        (MetricsMap)((SolrMetricManager.GaugeWrapper)h.getCore().getCoreMetricManager().getRegistry().getMetrics().get(\"CACHE.searcher.filterCache\")).getGauge();\n    assertNotNull(filterCacheStats);\n    final MetricsMap queryCacheStats =\n        (MetricsMap)((SolrMetricManager.GaugeWrapper)h.getCore().getCoreMetricManager().getRegistry().getMetrics().get(\"CACHE.searcher.queryResultCache\")).getGauge();\n    assertNotNull(queryCacheStats);\n\n    final long preQcIn = (Long) queryCacheStats.getValue().get(\"inserts\");\n    final long preFcIn = (Long) filterCacheStats.getValue().get(\"inserts\");\n    final long preFcHits = (Long) filterCacheStats.getValue().get(\"hits\");\n\n    SentinelIntSet ids = assertFullWalkNoDups\n      (10, params(\"q\", \"*:*\",\n                  \"rows\",\"\"+ TestUtil.nextInt(random(), 1, 11),\n                  \"fq\", \"-id:[1 TO 2]\",\n                  \"fq\", \"-id:[6 TO 7]\",\n                  \"fl\", \"id\",\n                  \"sort\", buildRandomSort(allFieldNames)));\n    \n    assertEquals(6, ids.size());\n\n    final long postQcIn = (Long) queryCacheStats.getValue().get(\"inserts\");\n    final long postFcIn = (Long) filterCacheStats.getValue().get(\"inserts\");\n    final long postFcHits = (Long) filterCacheStats.getValue().get(\"hits\");\n    \n    assertEquals(\"query cache inserts changed\", preQcIn, postQcIn);\n    // NOTE: use of pure negative filters causees \"*:* to be tracked in filterCache\n    assertEquals(\"filter cache did not grow correctly\", 3, postFcIn-preFcIn);\n    assertTrue(\"filter cache did not have any new cache hits\", 0 < postFcHits-preFcHits);\n\n  }\n\n","sourceOld":"  /**\n   * test that our assumptions about how caches are affected hold true\n   */\n  public void testCacheImpacts() throws Exception {\n    // cursor queryies can't live in the queryResultCache, but independent filters\n    // should still be cached & reused\n\n    // don't add in order of any field to ensure we aren't inadvertantly \n    // counting on internal docid ordering\n    assertU(adoc(\"id\", \"9\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"42\"));\n    assertU(adoc(\"id\", \"7\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"-1976\"));\n    assertU(adoc(\"id\", \"2\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"666\"));\n    assertU(adoc(\"id\", \"0\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"-42\"));\n    assertU(adoc(\"id\", \"5\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"2001\"));\n    assertU(adoc(\"id\", \"8\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"4055\"));\n    assertU(adoc(\"id\", \"6\", \"str\", \"a\", \"float\", \"64.5\", \"int\", \"7\"));\n    assertU(adoc(\"id\", \"1\", \"str\", \"a\", \"float\", \"64.5\", \"int\", \"7\"));\n    assertU(adoc(\"id\", \"4\", \"str\", \"a\", \"float\", \"11.1\", \"int\", \"6\"));\n    assertU(adoc(\"id\", \"3\", \"str\", \"a\", \"float\", \"11.1\", \"int\", \"3\"));\n    assertU(commit());\n\n    final Collection<String> allFieldNames = getAllSortFieldNames();\n\n    final MetricsMap filterCacheStats =\n        (MetricsMap)h.getCore().getCoreMetricManager().getRegistry().getMetrics().get(\"CACHE.searcher.filterCache\");\n    assertNotNull(filterCacheStats);\n    final MetricsMap queryCacheStats =\n        (MetricsMap)h.getCore().getCoreMetricManager().getRegistry().getMetrics().get(\"CACHE.searcher.queryResultCache\");\n    assertNotNull(queryCacheStats);\n\n    final long preQcIn = (Long) queryCacheStats.getValue().get(\"inserts\");\n    final long preFcIn = (Long) filterCacheStats.getValue().get(\"inserts\");\n    final long preFcHits = (Long) filterCacheStats.getValue().get(\"hits\");\n\n    SentinelIntSet ids = assertFullWalkNoDups\n      (10, params(\"q\", \"*:*\",\n                  \"rows\",\"\"+ TestUtil.nextInt(random(), 1, 11),\n                  \"fq\", \"-id:[1 TO 2]\",\n                  \"fq\", \"-id:[6 TO 7]\",\n                  \"fl\", \"id\",\n                  \"sort\", buildRandomSort(allFieldNames)));\n    \n    assertEquals(6, ids.size());\n\n    final long postQcIn = (Long) queryCacheStats.getValue().get(\"inserts\");\n    final long postFcIn = (Long) filterCacheStats.getValue().get(\"inserts\");\n    final long postFcHits = (Long) filterCacheStats.getValue().get(\"hits\");\n    \n    assertEquals(\"query cache inserts changed\", preQcIn, postQcIn);\n    // NOTE: use of pure negative filters causees \"*:* to be tracked in filterCache\n    assertEquals(\"filter cache did not grow correctly\", 3, postFcIn-preFcIn);\n    assertTrue(\"filter cache did not have any new cache hits\", 0 < postFcHits-preFcHits);\n\n  }\n\n","bugFix":["816521ebaad5add9cb96bb88c577394e2938c40b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43564cbb30b064675027cfb569564e8531096e97","date":1522334265,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/CursorPagingTest#testCacheImpacts().mjava","pathOld":"solr/core/src/test/org/apache/solr/CursorPagingTest#testCacheImpacts().mjava","sourceNew":"  /**\n   * test that our assumptions about how caches are affected hold true\n   */\n  public void testCacheImpacts() throws Exception {\n    // cursor queryies can't live in the queryResultCache, but independent filters\n    // should still be cached & reused\n\n    // don't add in order of any field to ensure we aren't inadvertantly \n    // counting on internal docid ordering\n    assertU(adoc(\"id\", \"9\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"42\"));\n    assertU(adoc(\"id\", \"7\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"-1976\"));\n    assertU(adoc(\"id\", \"2\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"666\"));\n    assertU(adoc(\"id\", \"0\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"-42\"));\n    assertU(adoc(\"id\", \"5\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"2001\"));\n    assertU(adoc(\"id\", \"8\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"4055\"));\n    assertU(adoc(\"id\", \"6\", \"str\", \"a\", \"float\", \"64.5\", \"int\", \"7\"));\n    assertU(adoc(\"id\", \"1\", \"str\", \"a\", \"float\", \"64.5\", \"int\", \"7\"));\n    assertU(adoc(\"id\", \"4\", \"str\", \"a\", \"float\", \"11.1\", \"int\", \"6\"));\n    assertU(adoc(\"id\", \"3\", \"str\", \"a\", \"float\", \"11.1\", \"int\", \"3\"));\n    assertU(commit());\n\n    final Collection<String> allFieldNames = getAllSortFieldNames();\n\n    final MetricsMap filterCacheStats =\n        (MetricsMap)((SolrMetricManager.GaugeWrapper)h.getCore().getCoreMetricManager().getRegistry().getMetrics().get(\"CACHE.searcher.filterCache\")).getGauge();\n    assertNotNull(filterCacheStats);\n    final MetricsMap queryCacheStats =\n        (MetricsMap)((SolrMetricManager.GaugeWrapper)h.getCore().getCoreMetricManager().getRegistry().getMetrics().get(\"CACHE.searcher.queryResultCache\")).getGauge();\n    assertNotNull(queryCacheStats);\n\n    final long preQcIn = (Long) queryCacheStats.getValue().get(\"inserts\");\n    final long preFcIn = (Long) filterCacheStats.getValue().get(\"inserts\");\n    final long preFcHits = (Long) filterCacheStats.getValue().get(\"hits\");\n\n    SentinelIntSet ids = assertFullWalkNoDups\n      (10, params(\"q\", \"*:*\",\n                  \"rows\",\"\"+ TestUtil.nextInt(random(), 1, 11),\n                  \"fq\", \"-id:[1 TO 2]\",\n                  \"fq\", \"-id:[6 TO 7]\",\n                  \"fl\", \"id\",\n                  \"sort\", buildRandomSort(allFieldNames)));\n    \n    assertEquals(6, ids.size());\n\n    final long postQcIn = (Long) queryCacheStats.getValue().get(\"inserts\");\n    final long postFcIn = (Long) filterCacheStats.getValue().get(\"inserts\");\n    final long postFcHits = (Long) filterCacheStats.getValue().get(\"hits\");\n    \n    assertEquals(\"query cache inserts changed\", preQcIn, postQcIn);\n    // NOTE: use of pure negative filters causees \"*:* to be tracked in filterCache\n    assertEquals(\"filter cache did not grow correctly\", 3, postFcIn-preFcIn);\n    assertTrue(\"filter cache did not have any new cache hits\", 0 < postFcHits-preFcHits);\n\n  }\n\n","sourceOld":"  /**\n   * test that our assumptions about how caches are affected hold true\n   */\n  public void testCacheImpacts() throws Exception {\n    // cursor queryies can't live in the queryResultCache, but independent filters\n    // should still be cached & reused\n\n    // don't add in order of any field to ensure we aren't inadvertantly \n    // counting on internal docid ordering\n    assertU(adoc(\"id\", \"9\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"42\"));\n    assertU(adoc(\"id\", \"7\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"-1976\"));\n    assertU(adoc(\"id\", \"2\", \"str\", \"c\", \"float\", \"-3.2\", \"int\", \"666\"));\n    assertU(adoc(\"id\", \"0\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"-42\"));\n    assertU(adoc(\"id\", \"5\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"2001\"));\n    assertU(adoc(\"id\", \"8\", \"str\", \"b\", \"float\", \"64.5\", \"int\", \"4055\"));\n    assertU(adoc(\"id\", \"6\", \"str\", \"a\", \"float\", \"64.5\", \"int\", \"7\"));\n    assertU(adoc(\"id\", \"1\", \"str\", \"a\", \"float\", \"64.5\", \"int\", \"7\"));\n    assertU(adoc(\"id\", \"4\", \"str\", \"a\", \"float\", \"11.1\", \"int\", \"6\"));\n    assertU(adoc(\"id\", \"3\", \"str\", \"a\", \"float\", \"11.1\", \"int\", \"3\"));\n    assertU(commit());\n\n    final Collection<String> allFieldNames = getAllSortFieldNames();\n\n    final MetricsMap filterCacheStats =\n        (MetricsMap)h.getCore().getCoreMetricManager().getRegistry().getMetrics().get(\"CACHE.searcher.filterCache\");\n    assertNotNull(filterCacheStats);\n    final MetricsMap queryCacheStats =\n        (MetricsMap)h.getCore().getCoreMetricManager().getRegistry().getMetrics().get(\"CACHE.searcher.queryResultCache\");\n    assertNotNull(queryCacheStats);\n\n    final long preQcIn = (Long) queryCacheStats.getValue().get(\"inserts\");\n    final long preFcIn = (Long) filterCacheStats.getValue().get(\"inserts\");\n    final long preFcHits = (Long) filterCacheStats.getValue().get(\"hits\");\n\n    SentinelIntSet ids = assertFullWalkNoDups\n      (10, params(\"q\", \"*:*\",\n                  \"rows\",\"\"+ TestUtil.nextInt(random(), 1, 11),\n                  \"fq\", \"-id:[1 TO 2]\",\n                  \"fq\", \"-id:[6 TO 7]\",\n                  \"fl\", \"id\",\n                  \"sort\", buildRandomSort(allFieldNames)));\n    \n    assertEquals(6, ids.size());\n\n    final long postQcIn = (Long) queryCacheStats.getValue().get(\"inserts\");\n    final long postFcIn = (Long) filterCacheStats.getValue().get(\"inserts\");\n    final long postFcHits = (Long) filterCacheStats.getValue().get(\"hits\");\n    \n    assertEquals(\"query cache inserts changed\", preQcIn, postQcIn);\n    // NOTE: use of pure negative filters causees \"*:* to be tracked in filterCache\n    assertEquals(\"filter cache did not grow correctly\", 3, postFcIn-preFcIn);\n    assertTrue(\"filter cache did not have any new cache hits\", 0 < postFcHits-preFcHits);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["6613659748fe4411a7dcf85266e55db1f95f7315"],"bfc52860e6d13d034226a760813c59d984c6817a":["816521ebaad5add9cb96bb88c577394e2938c40b"],"43564cbb30b064675027cfb569564e8531096e97":["816521ebaad5add9cb96bb88c577394e2938c40b","bfc52860e6d13d034226a760813c59d984c6817a"],"6613659748fe4411a7dcf85266e55db1f95f7315":["6a0f9b793b360e5f5863eef2d4b02a2ddd8b47b4"],"d5bc8e25f59990525f5beb14afe9c96240dcf4a2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6a0f9b793b360e5f5863eef2d4b02a2ddd8b47b4":["d5bc8e25f59990525f5beb14afe9c96240dcf4a2"],"816521ebaad5add9cb96bb88c577394e2938c40b":["6613659748fe4411a7dcf85266e55db1f95f7315"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["43564cbb30b064675027cfb569564e8531096e97"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":[],"bfc52860e6d13d034226a760813c59d984c6817a":["43564cbb30b064675027cfb569564e8531096e97"],"43564cbb30b064675027cfb569564e8531096e97":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6613659748fe4411a7dcf85266e55db1f95f7315":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","816521ebaad5add9cb96bb88c577394e2938c40b"],"d5bc8e25f59990525f5beb14afe9c96240dcf4a2":["6a0f9b793b360e5f5863eef2d4b02a2ddd8b47b4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d5bc8e25f59990525f5beb14afe9c96240dcf4a2"],"6a0f9b793b360e5f5863eef2d4b02a2ddd8b47b4":["6613659748fe4411a7dcf85266e55db1f95f7315"],"816521ebaad5add9cb96bb88c577394e2938c40b":["bfc52860e6d13d034226a760813c59d984c6817a","43564cbb30b064675027cfb569564e8531096e97"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}