{"path":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,long).mjava","commits":[{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":0,"author":"markrmiller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,long).mjava","pathOld":"/dev/null","sourceNew":"  public static void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, long timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    try {\n      zkStateReader.waitForState(collection, timeoutSeconds, TimeUnit.SECONDS, (liveNodes, docCollection) -> {\n        if (docCollection == null)\n          return false;\n        boolean sawLiveRecovering = false;\n\n        assertNotNull(\"Could not find collection:\" + collection, docCollection);\n        Map<String,Slice> slices = docCollection.getSlicesMap();\n        assertNotNull(\"Could not find collection:\" + collection, slices);\n        for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n          Slice slice = entry.getValue();\n          if (slice.getState() == Slice.State.CONSTRUCTION) { // similar to replica recovering; pretend its the same\n                                                              // thing\n            if (verbose) System.out.println(\"Found a slice in construction state; will wait.\");\n            sawLiveRecovering = true;\n          }\n          Map<String,Replica> shards = slice.getReplicasMap();\n          for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n            if (verbose) System.out.println(\"replica:\" + shard.getValue().getName() + \" rstate:\"\n                + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n                + \" live:\"\n                + liveNodes.contains(shard.getValue().getNodeName()));\n            final Replica.State state = shard.getValue().getState();\n            if ((state == Replica.State.RECOVERING || state == Replica.State.DOWN\n                || state == Replica.State.RECOVERY_FAILED)\n                && liveNodes.contains(shard.getValue().getStr(ZkStateReader.NODE_NAME_PROP))) {\n              return false;\n            }\n          }\n        }\n        if (!sawLiveRecovering) {\n          if (!sawLiveRecovering) {\n            if (verbose) System.out.println(\"no one is recoverying\");\n          } else {\n            if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n            return false;\n          }\n          return true;\n        } else {\n          return false;\n        }\n      });\n    } catch (TimeoutException | InterruptedException e) {\n      Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n      zkStateReader.getZkClient().printLayoutToStdOut();\n      fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15","date":1554259533,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,long).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,long).mjava","sourceNew":"  public static void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, long timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    try {\n      zkStateReader.waitForState(collection, timeoutSeconds, TimeUnit.SECONDS, (liveNodes, docCollection) -> {\n        if (docCollection == null)\n          return false;\n        boolean sawLiveRecovering = false;\n\n        assertNotNull(\"Could not find collection:\" + collection, docCollection);\n        Map<String,Slice> slices = docCollection.getSlicesMap();\n        assertNotNull(\"Could not find collection:\" + collection, slices);\n        for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n          Slice slice = entry.getValue();\n          if (slice.getState() == Slice.State.CONSTRUCTION) { // similar to replica recovering; pretend its the same\n                                                              // thing\n            if (verbose) System.out.println(\"Found a slice in construction state; will wait.\");\n            sawLiveRecovering = true;\n          }\n          Map<String,Replica> shards = slice.getReplicasMap();\n          for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n            if (verbose) System.out.println(\"replica:\" + shard.getValue().getName() + \" rstate:\"\n                + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n                + \" live:\"\n                + liveNodes.contains(shard.getValue().getNodeName()));\n            final Replica.State state = shard.getValue().getState();\n            if ((state == Replica.State.RECOVERING || state == Replica.State.DOWN\n                || state == Replica.State.RECOVERY_FAILED)\n                && liveNodes.contains(shard.getValue().getStr(ZkStateReader.NODE_NAME_PROP))) {\n              return false;\n            }\n          }\n        }\n        if (!sawLiveRecovering) {\n          if (!sawLiveRecovering) {\n            if (verbose) System.out.println(\"no one is recoverying\");\n          } else {\n            if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n            return false;\n          }\n          return true;\n        } else {\n          return false;\n        }\n      });\n    } catch (TimeoutException | InterruptedException e) {\n      Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n      zkStateReader.getZkClient().printLayoutToStream(System.out);\n      fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","sourceOld":"  public static void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, long timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    try {\n      zkStateReader.waitForState(collection, timeoutSeconds, TimeUnit.SECONDS, (liveNodes, docCollection) -> {\n        if (docCollection == null)\n          return false;\n        boolean sawLiveRecovering = false;\n\n        assertNotNull(\"Could not find collection:\" + collection, docCollection);\n        Map<String,Slice> slices = docCollection.getSlicesMap();\n        assertNotNull(\"Could not find collection:\" + collection, slices);\n        for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n          Slice slice = entry.getValue();\n          if (slice.getState() == Slice.State.CONSTRUCTION) { // similar to replica recovering; pretend its the same\n                                                              // thing\n            if (verbose) System.out.println(\"Found a slice in construction state; will wait.\");\n            sawLiveRecovering = true;\n          }\n          Map<String,Replica> shards = slice.getReplicasMap();\n          for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n            if (verbose) System.out.println(\"replica:\" + shard.getValue().getName() + \" rstate:\"\n                + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n                + \" live:\"\n                + liveNodes.contains(shard.getValue().getNodeName()));\n            final Replica.State state = shard.getValue().getState();\n            if ((state == Replica.State.RECOVERING || state == Replica.State.DOWN\n                || state == Replica.State.RECOVERY_FAILED)\n                && liveNodes.contains(shard.getValue().getStr(ZkStateReader.NODE_NAME_PROP))) {\n              return false;\n            }\n          }\n        }\n        if (!sawLiveRecovering) {\n          if (!sawLiveRecovering) {\n            if (verbose) System.out.println(\"no one is recoverying\");\n          } else {\n            if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n            return false;\n          }\n          return true;\n        } else {\n          return false;\n        }\n      });\n    } catch (TimeoutException | InterruptedException e) {\n      Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n      zkStateReader.getZkClient().printLayoutToStdOut();\n      fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"add1e7dd742ea533ff4318cea83ca0a1f669f662","date":1585262285,"type":3,"author":"Mike Drob","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,long).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,long).mjava","sourceNew":"  public static void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, long timeoutSeconds)\n      throws Exception {\n    waitForRecoveriesToFinish(collection, zkStateReader, verbose, failOnTimeout, timeoutSeconds, SECONDS);\n  }\n\n","sourceOld":"  public static void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, long timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    try {\n      zkStateReader.waitForState(collection, timeoutSeconds, TimeUnit.SECONDS, (liveNodes, docCollection) -> {\n        if (docCollection == null)\n          return false;\n        boolean sawLiveRecovering = false;\n\n        assertNotNull(\"Could not find collection:\" + collection, docCollection);\n        Map<String,Slice> slices = docCollection.getSlicesMap();\n        assertNotNull(\"Could not find collection:\" + collection, slices);\n        for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n          Slice slice = entry.getValue();\n          if (slice.getState() == Slice.State.CONSTRUCTION) { // similar to replica recovering; pretend its the same\n                                                              // thing\n            if (verbose) System.out.println(\"Found a slice in construction state; will wait.\");\n            sawLiveRecovering = true;\n          }\n          Map<String,Replica> shards = slice.getReplicasMap();\n          for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n            if (verbose) System.out.println(\"replica:\" + shard.getValue().getName() + \" rstate:\"\n                + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n                + \" live:\"\n                + liveNodes.contains(shard.getValue().getNodeName()));\n            final Replica.State state = shard.getValue().getState();\n            if ((state == Replica.State.RECOVERING || state == Replica.State.DOWN\n                || state == Replica.State.RECOVERY_FAILED)\n                && liveNodes.contains(shard.getValue().getStr(ZkStateReader.NODE_NAME_PROP))) {\n              return false;\n            }\n          }\n        }\n        if (!sawLiveRecovering) {\n          if (!sawLiveRecovering) {\n            if (verbose) System.out.println(\"no one is recoverying\");\n          } else {\n            if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n            return false;\n          }\n          return true;\n        } else {\n          return false;\n        }\n      });\n    } catch (TimeoutException | InterruptedException e) {\n      Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n      zkStateReader.getZkClient().printLayoutToStream(System.out);\n      fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"add1e7dd742ea533ff4318cea83ca0a1f669f662":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["add1e7dd742ea533ff4318cea83ca0a1f669f662"]},"commit2Childs":{"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"add1e7dd742ea533ff4318cea83ca0a1f669f662":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["add1e7dd742ea533ff4318cea83ca0a1f669f662"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}