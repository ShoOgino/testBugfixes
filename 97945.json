{"path":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#updateIOThrottle(OneMerge).mjava","commits":[{"id":"5faf65b6692f15cca0f87bf8666c87899afc619f","date":1420468108,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#updateIOThrottle(OneMerge).mjava","pathOld":"/dev/null","sourceNew":"  /** Tunes IO throttle when a new merge starts. */\n  private synchronized void updateIOThrottle(OneMerge merge) throws IOException {\n    if (doAutoIOThrottle == false) {\n      return;\n    }\n\n    double mergeMB = bytesToMB(merge.estimatedMergeBytes);\n    if (mergeMB < MIN_BIG_MERGE_MB) {\n      // Only watch non-trivial merges for throttling; this is safe because the MP must eventually\n      // have to do larger merges:\n      return;\n    }\n\n    long now = System.nanoTime();\n\n    // Simplistic closed-loop feedback control: if we find any other similarly\n    // sized merges running, then we are falling behind, so we bump up the\n    // IO throttle, else we lower it:\n    boolean newBacklog = isBacklog(now, merge);\n\n    boolean curBacklog = false;\n\n    if (newBacklog == false) {\n      if (mergeThreads.size() > maxThreadCount) {\n        // If there are already more than the maximum merge threads allowed, count that as backlog:\n        curBacklog = true;\n      } else {\n        // Now see if any still-running merges are backlog'd:\n        for (MergeThread mergeThread : mergeThreads) {\n          if (isBacklog(now, mergeThread.merge)) {\n            curBacklog = true;\n            break;\n          }\n        }\n      }\n    }\n\n    double curMBPerSec = targetMBPerSec;\n\n    if (newBacklog) {\n      // This new merge adds to the backlog: increase IO throttle by 20%\n      targetMBPerSec *= 1.20;\n      if (targetMBPerSec > 10000) {\n        targetMBPerSec = 10000;\n      }\n      if (verbose()) {\n        if (curMBPerSec == targetMBPerSec) {\n          message(String.format(Locale.ROOT, \"io throttle: new merge backlog; leave IO rate at ceiling %.1f MB/sec\", targetMBPerSec));\n        } else {\n          message(String.format(Locale.ROOT, \"io throttle: new merge backlog; increase IO rate to %.1f MB/sec\", targetMBPerSec));\n        }\n      }\n    } else if (curBacklog) {\n      // We still have an existing backlog; leave the rate as is:\n      if (verbose()) {\n        message(String.format(Locale.ROOT, \"io throttle: current merge backlog; leave IO rate at %.1f MB/sec\",\n                              targetMBPerSec));\n      }\n    } else {\n      // We are not falling behind: decrease IO throttle by 10%\n      targetMBPerSec /= 1.10;\n      if (targetMBPerSec < MIN_MERGE_MB_PER_SEC) {\n        targetMBPerSec = MIN_MERGE_MB_PER_SEC;\n      }\n      if (verbose()) {\n        if (curMBPerSec == targetMBPerSec) {\n          message(String.format(Locale.ROOT, \"io throttle: no merge backlog; leave IO rate at floor %.1f MB/sec\", targetMBPerSec));\n        } else {\n          message(String.format(Locale.ROOT, \"io throttle: no merge backlog; decrease IO rate to %.1f MB/sec\", targetMBPerSec));\n        }\n      }\n    }\n\n    targetMBPerSecChanged();\n    updateMergeThreads();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b9ce8a999aa42f91053eec065df8a25c9c311ea4","date":1420535836,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#updateIOThrottle(OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#updateIOThrottle(OneMerge).mjava","sourceNew":"  /** Tunes IO throttle when a new merge starts. */\n  private synchronized void updateIOThrottle(OneMerge merge) throws IOException {\n    if (doAutoIOThrottle == false) {\n      return;\n    }\n\n    double mergeMB = bytesToMB(merge.estimatedMergeBytes);\n    if (mergeMB < MIN_BIG_MERGE_MB) {\n      // Only watch non-trivial merges for throttling; this is safe because the MP must eventually\n      // have to do larger merges:\n      return;\n    }\n\n    long now = System.nanoTime();\n\n    // Simplistic closed-loop feedback control: if we find any other similarly\n    // sized merges running, then we are falling behind, so we bump up the\n    // IO throttle, else we lower it:\n    boolean newBacklog = isBacklog(now, merge);\n\n    boolean curBacklog = false;\n\n    if (newBacklog == false) {\n      if (mergeThreads.size() > maxThreadCount) {\n        // If there are already more than the maximum merge threads allowed, count that as backlog:\n        curBacklog = true;\n      } else {\n        // Now see if any still-running merges are backlog'd:\n        for (MergeThread mergeThread : mergeThreads) {\n          if (isBacklog(now, mergeThread.merge)) {\n            curBacklog = true;\n            break;\n          }\n        }\n      }\n    }\n\n    double curMBPerSec = targetMBPerSec;\n\n    if (newBacklog) {\n      // This new merge adds to the backlog: increase IO throttle by 20%\n      targetMBPerSec *= 1.20;\n      if (targetMBPerSec > MAX_MERGE_MB_PER_SEC) {\n        targetMBPerSec = MAX_MERGE_MB_PER_SEC;\n      }\n      if (verbose()) {\n        if (curMBPerSec == targetMBPerSec) {\n          message(String.format(Locale.ROOT, \"io throttle: new merge backlog; leave IO rate at ceiling %.1f MB/sec\", targetMBPerSec));\n        } else {\n          message(String.format(Locale.ROOT, \"io throttle: new merge backlog; increase IO rate to %.1f MB/sec\", targetMBPerSec));\n        }\n      }\n    } else if (curBacklog) {\n      // We still have an existing backlog; leave the rate as is:\n      if (verbose()) {\n        message(String.format(Locale.ROOT, \"io throttle: current merge backlog; leave IO rate at %.1f MB/sec\",\n                              targetMBPerSec));\n      }\n    } else {\n      // We are not falling behind: decrease IO throttle by 10%\n      targetMBPerSec /= 1.10;\n      if (targetMBPerSec < MIN_MERGE_MB_PER_SEC) {\n        targetMBPerSec = MIN_MERGE_MB_PER_SEC;\n      }\n      if (verbose()) {\n        if (curMBPerSec == targetMBPerSec) {\n          message(String.format(Locale.ROOT, \"io throttle: no merge backlog; leave IO rate at floor %.1f MB/sec\", targetMBPerSec));\n        } else {\n          message(String.format(Locale.ROOT, \"io throttle: no merge backlog; decrease IO rate to %.1f MB/sec\", targetMBPerSec));\n        }\n      }\n    }\n\n    targetMBPerSecChanged();\n    updateMergeThreads();\n  }\n\n","sourceOld":"  /** Tunes IO throttle when a new merge starts. */\n  private synchronized void updateIOThrottle(OneMerge merge) throws IOException {\n    if (doAutoIOThrottle == false) {\n      return;\n    }\n\n    double mergeMB = bytesToMB(merge.estimatedMergeBytes);\n    if (mergeMB < MIN_BIG_MERGE_MB) {\n      // Only watch non-trivial merges for throttling; this is safe because the MP must eventually\n      // have to do larger merges:\n      return;\n    }\n\n    long now = System.nanoTime();\n\n    // Simplistic closed-loop feedback control: if we find any other similarly\n    // sized merges running, then we are falling behind, so we bump up the\n    // IO throttle, else we lower it:\n    boolean newBacklog = isBacklog(now, merge);\n\n    boolean curBacklog = false;\n\n    if (newBacklog == false) {\n      if (mergeThreads.size() > maxThreadCount) {\n        // If there are already more than the maximum merge threads allowed, count that as backlog:\n        curBacklog = true;\n      } else {\n        // Now see if any still-running merges are backlog'd:\n        for (MergeThread mergeThread : mergeThreads) {\n          if (isBacklog(now, mergeThread.merge)) {\n            curBacklog = true;\n            break;\n          }\n        }\n      }\n    }\n\n    double curMBPerSec = targetMBPerSec;\n\n    if (newBacklog) {\n      // This new merge adds to the backlog: increase IO throttle by 20%\n      targetMBPerSec *= 1.20;\n      if (targetMBPerSec > 10000) {\n        targetMBPerSec = 10000;\n      }\n      if (verbose()) {\n        if (curMBPerSec == targetMBPerSec) {\n          message(String.format(Locale.ROOT, \"io throttle: new merge backlog; leave IO rate at ceiling %.1f MB/sec\", targetMBPerSec));\n        } else {\n          message(String.format(Locale.ROOT, \"io throttle: new merge backlog; increase IO rate to %.1f MB/sec\", targetMBPerSec));\n        }\n      }\n    } else if (curBacklog) {\n      // We still have an existing backlog; leave the rate as is:\n      if (verbose()) {\n        message(String.format(Locale.ROOT, \"io throttle: current merge backlog; leave IO rate at %.1f MB/sec\",\n                              targetMBPerSec));\n      }\n    } else {\n      // We are not falling behind: decrease IO throttle by 10%\n      targetMBPerSec /= 1.10;\n      if (targetMBPerSec < MIN_MERGE_MB_PER_SEC) {\n        targetMBPerSec = MIN_MERGE_MB_PER_SEC;\n      }\n      if (verbose()) {\n        if (curMBPerSec == targetMBPerSec) {\n          message(String.format(Locale.ROOT, \"io throttle: no merge backlog; leave IO rate at floor %.1f MB/sec\", targetMBPerSec));\n        } else {\n          message(String.format(Locale.ROOT, \"io throttle: no merge backlog; decrease IO rate to %.1f MB/sec\", targetMBPerSec));\n        }\n      }\n    }\n\n    targetMBPerSecChanged();\n    updateMergeThreads();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba45a22312e230cf8c9ada0f1199670ecf767d07","date":1420626256,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#updateIOThrottle(OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#updateIOThrottle(OneMerge).mjava","sourceNew":"  /** Tunes IO throttle when a new merge starts. */\n  private synchronized void updateIOThrottle(OneMerge newMerge) throws IOException {\n    if (doAutoIOThrottle == false) {\n      return;\n    }\n\n    double mergeMB = bytesToMB(newMerge.estimatedMergeBytes);\n    if (mergeMB < MIN_BIG_MERGE_MB) {\n      // Only watch non-trivial merges for throttling; this is safe because the MP must eventually\n      // have to do larger merges:\n      return;\n    }\n\n    long now = System.nanoTime();\n\n    // Simplistic closed-loop feedback control: if we find any other similarly\n    // sized merges running, then we are falling behind, so we bump up the\n    // IO throttle, else we lower it:\n    boolean newBacklog = isBacklog(now, newMerge);\n\n    boolean curBacklog = false;\n\n    if (newBacklog == false) {\n      if (mergeThreads.size() > maxThreadCount) {\n        // If there are already more than the maximum merge threads allowed, count that as backlog:\n        curBacklog = true;\n      } else {\n        // Now see if any still-running merges are backlog'd:\n        for (MergeThread mergeThread : mergeThreads) {\n          if (isBacklog(now, mergeThread.merge)) {\n            curBacklog = true;\n            break;\n          }\n        }\n      }\n    }\n\n    double curMBPerSec = targetMBPerSec;\n\n    if (newBacklog) {\n      // This new merge adds to the backlog: increase IO throttle by 20%\n      targetMBPerSec *= 1.20;\n      if (targetMBPerSec > MAX_MERGE_MB_PER_SEC) {\n        targetMBPerSec = MAX_MERGE_MB_PER_SEC;\n      }\n      if (verbose()) {\n        if (curMBPerSec == targetMBPerSec) {\n          message(String.format(Locale.ROOT, \"io throttle: new merge backlog; leave IO rate at ceiling %.1f MB/sec\", targetMBPerSec));\n        } else {\n          message(String.format(Locale.ROOT, \"io throttle: new merge backlog; increase IO rate to %.1f MB/sec\", targetMBPerSec));\n        }\n      }\n    } else if (curBacklog) {\n      // We still have an existing backlog; leave the rate as is:\n      if (verbose()) {\n        message(String.format(Locale.ROOT, \"io throttle: current merge backlog; leave IO rate at %.1f MB/sec\",\n                              targetMBPerSec));\n      }\n    } else {\n      // We are not falling behind: decrease IO throttle by 10%\n      targetMBPerSec /= 1.10;\n      if (targetMBPerSec < MIN_MERGE_MB_PER_SEC) {\n        targetMBPerSec = MIN_MERGE_MB_PER_SEC;\n      }\n      if (verbose()) {\n        if (curMBPerSec == targetMBPerSec) {\n          message(String.format(Locale.ROOT, \"io throttle: no merge backlog; leave IO rate at floor %.1f MB/sec\", targetMBPerSec));\n        } else {\n          message(String.format(Locale.ROOT, \"io throttle: no merge backlog; decrease IO rate to %.1f MB/sec\", targetMBPerSec));\n        }\n      }\n    }\n\n    newMerge.rateLimiter.setMBPerSec(targetMBPerSec);\n    targetMBPerSecChanged();\n  }\n\n","sourceOld":"  /** Tunes IO throttle when a new merge starts. */\n  private synchronized void updateIOThrottle(OneMerge merge) throws IOException {\n    if (doAutoIOThrottle == false) {\n      return;\n    }\n\n    double mergeMB = bytesToMB(merge.estimatedMergeBytes);\n    if (mergeMB < MIN_BIG_MERGE_MB) {\n      // Only watch non-trivial merges for throttling; this is safe because the MP must eventually\n      // have to do larger merges:\n      return;\n    }\n\n    long now = System.nanoTime();\n\n    // Simplistic closed-loop feedback control: if we find any other similarly\n    // sized merges running, then we are falling behind, so we bump up the\n    // IO throttle, else we lower it:\n    boolean newBacklog = isBacklog(now, merge);\n\n    boolean curBacklog = false;\n\n    if (newBacklog == false) {\n      if (mergeThreads.size() > maxThreadCount) {\n        // If there are already more than the maximum merge threads allowed, count that as backlog:\n        curBacklog = true;\n      } else {\n        // Now see if any still-running merges are backlog'd:\n        for (MergeThread mergeThread : mergeThreads) {\n          if (isBacklog(now, mergeThread.merge)) {\n            curBacklog = true;\n            break;\n          }\n        }\n      }\n    }\n\n    double curMBPerSec = targetMBPerSec;\n\n    if (newBacklog) {\n      // This new merge adds to the backlog: increase IO throttle by 20%\n      targetMBPerSec *= 1.20;\n      if (targetMBPerSec > MAX_MERGE_MB_PER_SEC) {\n        targetMBPerSec = MAX_MERGE_MB_PER_SEC;\n      }\n      if (verbose()) {\n        if (curMBPerSec == targetMBPerSec) {\n          message(String.format(Locale.ROOT, \"io throttle: new merge backlog; leave IO rate at ceiling %.1f MB/sec\", targetMBPerSec));\n        } else {\n          message(String.format(Locale.ROOT, \"io throttle: new merge backlog; increase IO rate to %.1f MB/sec\", targetMBPerSec));\n        }\n      }\n    } else if (curBacklog) {\n      // We still have an existing backlog; leave the rate as is:\n      if (verbose()) {\n        message(String.format(Locale.ROOT, \"io throttle: current merge backlog; leave IO rate at %.1f MB/sec\",\n                              targetMBPerSec));\n      }\n    } else {\n      // We are not falling behind: decrease IO throttle by 10%\n      targetMBPerSec /= 1.10;\n      if (targetMBPerSec < MIN_MERGE_MB_PER_SEC) {\n        targetMBPerSec = MIN_MERGE_MB_PER_SEC;\n      }\n      if (verbose()) {\n        if (curMBPerSec == targetMBPerSec) {\n          message(String.format(Locale.ROOT, \"io throttle: no merge backlog; leave IO rate at floor %.1f MB/sec\", targetMBPerSec));\n        } else {\n          message(String.format(Locale.ROOT, \"io throttle: no merge backlog; decrease IO rate to %.1f MB/sec\", targetMBPerSec));\n        }\n      }\n    }\n\n    targetMBPerSecChanged();\n    updateMergeThreads();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5afe95e76e6fc4db8ac64e3664e4b9bf50973cf5","date":1420795843,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#updateIOThrottle(OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#updateIOThrottle(OneMerge).mjava","sourceNew":"  /** Tunes IO throttle when a new merge starts. */\n  private synchronized void updateIOThrottle(OneMerge newMerge) throws IOException {\n    if (doAutoIOThrottle == false) {\n      return;\n    }\n\n    double mergeMB = bytesToMB(newMerge.estimatedMergeBytes);\n    if (mergeMB < MIN_BIG_MERGE_MB) {\n      // Only watch non-trivial merges for throttling; this is safe because the MP must eventually\n      // have to do larger merges:\n      return;\n    }\n\n    long now = System.nanoTime();\n\n    // Simplistic closed-loop feedback control: if we find any other similarly\n    // sized merges running, then we are falling behind, so we bump up the\n    // IO throttle, else we lower it:\n    boolean newBacklog = isBacklog(now, newMerge);\n\n    boolean curBacklog = false;\n\n    if (newBacklog == false) {\n      if (mergeThreads.size() > maxThreadCount) {\n        // If there are already more than the maximum merge threads allowed, count that as backlog:\n        curBacklog = true;\n      } else {\n        // Now see if any still-running merges are backlog'd:\n        for (MergeThread mergeThread : mergeThreads) {\n          if (isBacklog(now, mergeThread.merge)) {\n            curBacklog = true;\n            break;\n          }\n        }\n      }\n    }\n\n    double curMBPerSec = targetMBPerSec;\n\n    if (newBacklog) {\n      // This new merge adds to the backlog: increase IO throttle by 20%\n      targetMBPerSec *= 1.20;\n      if (targetMBPerSec > MAX_MERGE_MB_PER_SEC) {\n        targetMBPerSec = MAX_MERGE_MB_PER_SEC;\n      }\n      if (verbose()) {\n        if (curMBPerSec == targetMBPerSec) {\n          message(String.format(Locale.ROOT, \"io throttle: new merge backlog; leave IO rate at ceiling %.1f MB/sec\", targetMBPerSec));\n        } else {\n          message(String.format(Locale.ROOT, \"io throttle: new merge backlog; increase IO rate to %.1f MB/sec\", targetMBPerSec));\n        }\n      }\n    } else if (curBacklog) {\n      // We still have an existing backlog; leave the rate as is:\n      if (verbose()) {\n        message(String.format(Locale.ROOT, \"io throttle: current merge backlog; leave IO rate at %.1f MB/sec\",\n                              targetMBPerSec));\n      }\n    } else {\n      // We are not falling behind: decrease IO throttle by 10%\n      targetMBPerSec /= 1.10;\n      if (targetMBPerSec < MIN_MERGE_MB_PER_SEC) {\n        targetMBPerSec = MIN_MERGE_MB_PER_SEC;\n      }\n      if (verbose()) {\n        if (curMBPerSec == targetMBPerSec) {\n          message(String.format(Locale.ROOT, \"io throttle: no merge backlog; leave IO rate at floor %.1f MB/sec\", targetMBPerSec));\n        } else {\n          message(String.format(Locale.ROOT, \"io throttle: no merge backlog; decrease IO rate to %.1f MB/sec\", targetMBPerSec));\n        }\n      }\n    }\n\n    double rate;\n\n    if (newMerge.maxNumSegments != -1) {\n      rate = forceMergeMBPerSec;\n    } else {\n      rate = targetMBPerSec;\n    }\n    newMerge.rateLimiter.setMBPerSec(rate);\n    targetMBPerSecChanged();\n  }\n\n","sourceOld":"  /** Tunes IO throttle when a new merge starts. */\n  private synchronized void updateIOThrottle(OneMerge newMerge) throws IOException {\n    if (doAutoIOThrottle == false) {\n      return;\n    }\n\n    double mergeMB = bytesToMB(newMerge.estimatedMergeBytes);\n    if (mergeMB < MIN_BIG_MERGE_MB) {\n      // Only watch non-trivial merges for throttling; this is safe because the MP must eventually\n      // have to do larger merges:\n      return;\n    }\n\n    long now = System.nanoTime();\n\n    // Simplistic closed-loop feedback control: if we find any other similarly\n    // sized merges running, then we are falling behind, so we bump up the\n    // IO throttle, else we lower it:\n    boolean newBacklog = isBacklog(now, newMerge);\n\n    boolean curBacklog = false;\n\n    if (newBacklog == false) {\n      if (mergeThreads.size() > maxThreadCount) {\n        // If there are already more than the maximum merge threads allowed, count that as backlog:\n        curBacklog = true;\n      } else {\n        // Now see if any still-running merges are backlog'd:\n        for (MergeThread mergeThread : mergeThreads) {\n          if (isBacklog(now, mergeThread.merge)) {\n            curBacklog = true;\n            break;\n          }\n        }\n      }\n    }\n\n    double curMBPerSec = targetMBPerSec;\n\n    if (newBacklog) {\n      // This new merge adds to the backlog: increase IO throttle by 20%\n      targetMBPerSec *= 1.20;\n      if (targetMBPerSec > MAX_MERGE_MB_PER_SEC) {\n        targetMBPerSec = MAX_MERGE_MB_PER_SEC;\n      }\n      if (verbose()) {\n        if (curMBPerSec == targetMBPerSec) {\n          message(String.format(Locale.ROOT, \"io throttle: new merge backlog; leave IO rate at ceiling %.1f MB/sec\", targetMBPerSec));\n        } else {\n          message(String.format(Locale.ROOT, \"io throttle: new merge backlog; increase IO rate to %.1f MB/sec\", targetMBPerSec));\n        }\n      }\n    } else if (curBacklog) {\n      // We still have an existing backlog; leave the rate as is:\n      if (verbose()) {\n        message(String.format(Locale.ROOT, \"io throttle: current merge backlog; leave IO rate at %.1f MB/sec\",\n                              targetMBPerSec));\n      }\n    } else {\n      // We are not falling behind: decrease IO throttle by 10%\n      targetMBPerSec /= 1.10;\n      if (targetMBPerSec < MIN_MERGE_MB_PER_SEC) {\n        targetMBPerSec = MIN_MERGE_MB_PER_SEC;\n      }\n      if (verbose()) {\n        if (curMBPerSec == targetMBPerSec) {\n          message(String.format(Locale.ROOT, \"io throttle: no merge backlog; leave IO rate at floor %.1f MB/sec\", targetMBPerSec));\n        } else {\n          message(String.format(Locale.ROOT, \"io throttle: no merge backlog; decrease IO rate to %.1f MB/sec\", targetMBPerSec));\n        }\n      }\n    }\n\n    newMerge.rateLimiter.setMBPerSec(targetMBPerSec);\n    targetMBPerSecChanged();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1ee9437ba5a8297220428d48a6bb823d1fcd57b","date":1489137809,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#updateIOThrottle(OneMerge,MergeRateLimiter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#updateIOThrottle(OneMerge).mjava","sourceNew":"  /** Tunes IO throttle when a new merge starts. */\n  private synchronized void updateIOThrottle(OneMerge newMerge, MergeRateLimiter rateLimiter) throws IOException {\n    if (doAutoIOThrottle == false) {\n      return;\n    }\n\n    double mergeMB = bytesToMB(newMerge.estimatedMergeBytes);\n    if (mergeMB < MIN_BIG_MERGE_MB) {\n      // Only watch non-trivial merges for throttling; this is safe because the MP must eventually\n      // have to do larger merges:\n      return;\n    }\n\n    long now = System.nanoTime();\n\n    // Simplistic closed-loop feedback control: if we find any other similarly\n    // sized merges running, then we are falling behind, so we bump up the\n    // IO throttle, else we lower it:\n    boolean newBacklog = isBacklog(now, newMerge);\n\n    boolean curBacklog = false;\n\n    if (newBacklog == false) {\n      if (mergeThreads.size() > maxThreadCount) {\n        // If there are already more than the maximum merge threads allowed, count that as backlog:\n        curBacklog = true;\n      } else {\n        // Now see if any still-running merges are backlog'd:\n        for (MergeThread mergeThread : mergeThreads) {\n          if (isBacklog(now, mergeThread.merge)) {\n            curBacklog = true;\n            break;\n          }\n        }\n      }\n    }\n\n    double curMBPerSec = targetMBPerSec;\n\n    if (newBacklog) {\n      // This new merge adds to the backlog: increase IO throttle by 20%\n      targetMBPerSec *= 1.20;\n      if (targetMBPerSec > MAX_MERGE_MB_PER_SEC) {\n        targetMBPerSec = MAX_MERGE_MB_PER_SEC;\n      }\n      if (verbose()) {\n        if (curMBPerSec == targetMBPerSec) {\n          message(String.format(Locale.ROOT, \"io throttle: new merge backlog; leave IO rate at ceiling %.1f MB/sec\", targetMBPerSec));\n        } else {\n          message(String.format(Locale.ROOT, \"io throttle: new merge backlog; increase IO rate to %.1f MB/sec\", targetMBPerSec));\n        }\n      }\n    } else if (curBacklog) {\n      // We still have an existing backlog; leave the rate as is:\n      if (verbose()) {\n        message(String.format(Locale.ROOT, \"io throttle: current merge backlog; leave IO rate at %.1f MB/sec\",\n                              targetMBPerSec));\n      }\n    } else {\n      // We are not falling behind: decrease IO throttle by 10%\n      targetMBPerSec /= 1.10;\n      if (targetMBPerSec < MIN_MERGE_MB_PER_SEC) {\n        targetMBPerSec = MIN_MERGE_MB_PER_SEC;\n      }\n      if (verbose()) {\n        if (curMBPerSec == targetMBPerSec) {\n          message(String.format(Locale.ROOT, \"io throttle: no merge backlog; leave IO rate at floor %.1f MB/sec\", targetMBPerSec));\n        } else {\n          message(String.format(Locale.ROOT, \"io throttle: no merge backlog; decrease IO rate to %.1f MB/sec\", targetMBPerSec));\n        }\n      }\n    }\n\n    double rate;\n\n    if (newMerge.maxNumSegments != -1) {\n      rate = forceMergeMBPerSec;\n    } else {\n      rate = targetMBPerSec;\n    }\n    rateLimiter.setMBPerSec(rate);\n    targetMBPerSecChanged();\n  }\n\n","sourceOld":"  /** Tunes IO throttle when a new merge starts. */\n  private synchronized void updateIOThrottle(OneMerge newMerge) throws IOException {\n    if (doAutoIOThrottle == false) {\n      return;\n    }\n\n    double mergeMB = bytesToMB(newMerge.estimatedMergeBytes);\n    if (mergeMB < MIN_BIG_MERGE_MB) {\n      // Only watch non-trivial merges for throttling; this is safe because the MP must eventually\n      // have to do larger merges:\n      return;\n    }\n\n    long now = System.nanoTime();\n\n    // Simplistic closed-loop feedback control: if we find any other similarly\n    // sized merges running, then we are falling behind, so we bump up the\n    // IO throttle, else we lower it:\n    boolean newBacklog = isBacklog(now, newMerge);\n\n    boolean curBacklog = false;\n\n    if (newBacklog == false) {\n      if (mergeThreads.size() > maxThreadCount) {\n        // If there are already more than the maximum merge threads allowed, count that as backlog:\n        curBacklog = true;\n      } else {\n        // Now see if any still-running merges are backlog'd:\n        for (MergeThread mergeThread : mergeThreads) {\n          if (isBacklog(now, mergeThread.merge)) {\n            curBacklog = true;\n            break;\n          }\n        }\n      }\n    }\n\n    double curMBPerSec = targetMBPerSec;\n\n    if (newBacklog) {\n      // This new merge adds to the backlog: increase IO throttle by 20%\n      targetMBPerSec *= 1.20;\n      if (targetMBPerSec > MAX_MERGE_MB_PER_SEC) {\n        targetMBPerSec = MAX_MERGE_MB_PER_SEC;\n      }\n      if (verbose()) {\n        if (curMBPerSec == targetMBPerSec) {\n          message(String.format(Locale.ROOT, \"io throttle: new merge backlog; leave IO rate at ceiling %.1f MB/sec\", targetMBPerSec));\n        } else {\n          message(String.format(Locale.ROOT, \"io throttle: new merge backlog; increase IO rate to %.1f MB/sec\", targetMBPerSec));\n        }\n      }\n    } else if (curBacklog) {\n      // We still have an existing backlog; leave the rate as is:\n      if (verbose()) {\n        message(String.format(Locale.ROOT, \"io throttle: current merge backlog; leave IO rate at %.1f MB/sec\",\n                              targetMBPerSec));\n      }\n    } else {\n      // We are not falling behind: decrease IO throttle by 10%\n      targetMBPerSec /= 1.10;\n      if (targetMBPerSec < MIN_MERGE_MB_PER_SEC) {\n        targetMBPerSec = MIN_MERGE_MB_PER_SEC;\n      }\n      if (verbose()) {\n        if (curMBPerSec == targetMBPerSec) {\n          message(String.format(Locale.ROOT, \"io throttle: no merge backlog; leave IO rate at floor %.1f MB/sec\", targetMBPerSec));\n        } else {\n          message(String.format(Locale.ROOT, \"io throttle: no merge backlog; decrease IO rate to %.1f MB/sec\", targetMBPerSec));\n        }\n      }\n    }\n\n    double rate;\n\n    if (newMerge.maxNumSegments != -1) {\n      rate = forceMergeMBPerSec;\n    } else {\n      rate = targetMBPerSec;\n    }\n    newMerge.rateLimiter.setMBPerSec(rate);\n    targetMBPerSecChanged();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5afe95e76e6fc4db8ac64e3664e4b9bf50973cf5":["ba45a22312e230cf8c9ada0f1199670ecf767d07"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ba45a22312e230cf8c9ada0f1199670ecf767d07":["b9ce8a999aa42f91053eec065df8a25c9c311ea4"],"c1ee9437ba5a8297220428d48a6bb823d1fcd57b":["5afe95e76e6fc4db8ac64e3664e4b9bf50973cf5"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b9ce8a999aa42f91053eec065df8a25c9c311ea4":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c1ee9437ba5a8297220428d48a6bb823d1fcd57b"]},"commit2Childs":{"5afe95e76e6fc4db8ac64e3664e4b9bf50973cf5":["c1ee9437ba5a8297220428d48a6bb823d1fcd57b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"ba45a22312e230cf8c9ada0f1199670ecf767d07":["5afe95e76e6fc4db8ac64e3664e4b9bf50973cf5"],"c1ee9437ba5a8297220428d48a6bb823d1fcd57b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["b9ce8a999aa42f91053eec065df8a25c9c311ea4"],"b9ce8a999aa42f91053eec065df8a25c9c311ea4":["ba45a22312e230cf8c9ada0f1199670ecf767d07"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}