{"path":"lucene/core/src/java/org/apache/lucene/codecs/SimpleDVConsumer#mergeNumericField(MergeState).mjava","commits":[{"id":"3cdc80a62bb2b084e97738303ef870bcea0310ac","date":1352398860,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/SimpleDVConsumer#mergeNumericField(MergeState).mjava","pathOld":"/dev/null","sourceNew":"  // dead simple impl: codec can optimize\n  protected void mergeNumericField(MergeState mergeState) throws IOException {\n    // first compute min and max value of live ones to be merged.\n    long minValue = Long.MAX_VALUE;\n    long maxValue = Long.MIN_VALUE;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      final Source source = reader.docValues(mergeState.fieldInfo.name).getDirectSource();\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs == null || liveDocs.get(i)) {\n          long val = source.getInt(i);\n          minValue = Math.min(val, minValue);\n          maxValue = Math.min(val, maxValue);\n        }\n        mergeState.checkAbort.work(300);\n      }\n    }\n    // now we can merge\n    NumericDocValuesConsumer field = addNumericField(mergeState.fieldInfo, minValue, maxValue);\n    field.merge(mergeState);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"25e6d305c838339e588b0a8f3cf8f868d8597a0b","date":1352566882,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/SimpleDVConsumer#mergeNumericField(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/SimpleDVConsumer#mergeNumericField(MergeState).mjava","sourceNew":"  // dead simple impl: codec can optimize\n  protected void mergeNumericField(MergeState mergeState) throws IOException {\n    // first compute min and max value of live ones to be merged.\n    long minValue = Long.MAX_VALUE;\n    long maxValue = Long.MIN_VALUE;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      DocValues docvalues = reader.docValues(mergeState.fieldInfo.name);\n      final Source source;\n      if (docvalues == null) {\n        source = DocValues.getDefaultSource(mergeState.fieldInfo.getDocValuesType());\n      } else {\n        source = docvalues.getDirectSource();\n      }\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs == null || liveDocs.get(i)) {\n          long val = source.getInt(i);\n          minValue = Math.min(val, minValue);\n          maxValue = Math.min(val, maxValue);\n        }\n        mergeState.checkAbort.work(300);\n      }\n    }\n    // now we can merge\n    NumericDocValuesConsumer field = addNumericField(mergeState.fieldInfo, minValue, maxValue);\n    field.merge(mergeState);\n  }\n\n","sourceOld":"  // dead simple impl: codec can optimize\n  protected void mergeNumericField(MergeState mergeState) throws IOException {\n    // first compute min and max value of live ones to be merged.\n    long minValue = Long.MAX_VALUE;\n    long maxValue = Long.MIN_VALUE;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      final Source source = reader.docValues(mergeState.fieldInfo.name).getDirectSource();\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs == null || liveDocs.get(i)) {\n          long val = source.getInt(i);\n          minValue = Math.min(val, minValue);\n          maxValue = Math.min(val, maxValue);\n        }\n        mergeState.checkAbort.work(300);\n      }\n    }\n    // now we can merge\n    NumericDocValuesConsumer field = addNumericField(mergeState.fieldInfo, minValue, maxValue);\n    field.merge(mergeState);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f45b94f31bcc0de4497b99f7b51993765f64c601","date":1352745246,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/SimpleDVConsumer#mergeNumericField(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/SimpleDVConsumer#mergeNumericField(MergeState).mjava","sourceNew":"  // dead simple impl: codec can optimize\n  protected void mergeNumericField(MergeState mergeState) throws IOException {\n    // first compute min and max value of live ones to be merged.\n    long minValue = Long.MAX_VALUE;\n    long maxValue = Long.MIN_VALUE;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      DocValues docValues = reader.docValues(mergeState.fieldInfo.name);\n      final Source source;\n      if (docValues == null) {\n        source = DocValues.getDefaultSource(mergeState.fieldInfo.getDocValuesType());\n      } else {\n        source = docValues.getDirectSource();\n      }\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs == null || liveDocs.get(i)) {\n          long val = source.getInt(i);\n          minValue = Math.min(val, minValue);\n          maxValue = Math.min(val, maxValue);\n        }\n        mergeState.checkAbort.work(300);\n      }\n    }\n    // now we can merge\n    NumericDocValuesConsumer field = addNumericField(mergeState.fieldInfo, minValue, maxValue);\n    field.merge(mergeState);\n  }\n\n","sourceOld":"  // dead simple impl: codec can optimize\n  protected void mergeNumericField(MergeState mergeState) throws IOException {\n    // first compute min and max value of live ones to be merged.\n    long minValue = Long.MAX_VALUE;\n    long maxValue = Long.MIN_VALUE;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      DocValues docvalues = reader.docValues(mergeState.fieldInfo.name);\n      final Source source;\n      if (docvalues == null) {\n        source = DocValues.getDefaultSource(mergeState.fieldInfo.getDocValuesType());\n      } else {\n        source = docvalues.getDirectSource();\n      }\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs == null || liveDocs.get(i)) {\n          long val = source.getInt(i);\n          minValue = Math.min(val, minValue);\n          maxValue = Math.min(val, maxValue);\n        }\n        mergeState.checkAbort.work(300);\n      }\n    }\n    // now we can merge\n    NumericDocValuesConsumer field = addNumericField(mergeState.fieldInfo, minValue, maxValue);\n    field.merge(mergeState);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ce73f585d17f53055185a19beb46db23d76e0ad9","date":1353077110,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/SimpleDVConsumer#mergeNumericField(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/SimpleDVConsumer#mergeNumericField(MergeState).mjava","sourceNew":"  // dead simple impl: codec can optimize\n  protected void mergeNumericField(MergeState mergeState) throws IOException {\n    // first compute min and max value of live ones to be merged.\n    long minValue = Long.MAX_VALUE;\n    long maxValue = Long.MIN_VALUE;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      DocValues docValues = reader.docValues(mergeState.fieldInfo.name);\n      final Source source;\n      if (docValues == null) {\n        source = DocValues.getDefaultSource(mergeState.fieldInfo.getDocValuesType());\n      } else {\n        source = docValues.getDirectSource();\n      }\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs == null || liveDocs.get(i)) {\n          long val = source.getInt(i);\n          minValue = Math.min(val, minValue);\n          maxValue = Math.min(val, maxValue);\n        }\n        mergeState.checkAbort.work(300);\n      }\n    }\n    // now we can merge\n    NumericDocValuesConsumer field = addNumericField(mergeState.fieldInfo, minValue, maxValue, mergeState.segmentInfo.getDocCount());\n    field.merge(mergeState);\n  }\n\n","sourceOld":"  // dead simple impl: codec can optimize\n  protected void mergeNumericField(MergeState mergeState) throws IOException {\n    // first compute min and max value of live ones to be merged.\n    long minValue = Long.MAX_VALUE;\n    long maxValue = Long.MIN_VALUE;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      DocValues docValues = reader.docValues(mergeState.fieldInfo.name);\n      final Source source;\n      if (docValues == null) {\n        source = DocValues.getDefaultSource(mergeState.fieldInfo.getDocValuesType());\n      } else {\n        source = docValues.getDirectSource();\n      }\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs == null || liveDocs.get(i)) {\n          long val = source.getInt(i);\n          minValue = Math.min(val, minValue);\n          maxValue = Math.min(val, maxValue);\n        }\n        mergeState.checkAbort.work(300);\n      }\n    }\n    // now we can merge\n    NumericDocValuesConsumer field = addNumericField(mergeState.fieldInfo, minValue, maxValue);\n    field.merge(mergeState);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6295f14d43685811599f8a8f02a63d75ec6bd8fe","date":1353248103,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/SimpleDVConsumer#mergeNumericField(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/SimpleDVConsumer#mergeNumericField(MergeState).mjava","sourceNew":"  // dead simple impl: codec can optimize\n  protected void mergeNumericField(MergeState mergeState) throws IOException {\n    // first compute min and max value of live ones to be merged.\n    long minValue = Long.MAX_VALUE;\n    long maxValue = Long.MIN_VALUE;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      //System.out.println(\"merge field=\" + mergeState.fieldInfo.name);\n      NumericDocValues docValues = reader.getNumericDocValues(mergeState.fieldInfo.name);\n      if (docValues == null) {\n        docValues = NumericDocValues.DEFAULT;\n      }\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs == null || liveDocs.get(i)) {\n          long val = docValues.get(i);\n          minValue = Math.min(val, minValue);\n          maxValue = Math.min(val, maxValue);\n        }\n        mergeState.checkAbort.work(300);\n      }\n    }\n    // now we can merge\n    NumericDocValuesConsumer field = addNumericField(mergeState.fieldInfo, minValue, maxValue, mergeState.segmentInfo.getDocCount());\n    field.merge(mergeState);\n  }\n\n","sourceOld":"  // dead simple impl: codec can optimize\n  protected void mergeNumericField(MergeState mergeState) throws IOException {\n    // first compute min and max value of live ones to be merged.\n    long minValue = Long.MAX_VALUE;\n    long maxValue = Long.MIN_VALUE;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      DocValues docValues = reader.docValues(mergeState.fieldInfo.name);\n      final Source source;\n      if (docValues == null) {\n        source = DocValues.getDefaultSource(mergeState.fieldInfo.getDocValuesType());\n      } else {\n        source = docValues.getDirectSource();\n      }\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs == null || liveDocs.get(i)) {\n          long val = source.getInt(i);\n          minValue = Math.min(val, minValue);\n          maxValue = Math.min(val, maxValue);\n        }\n        mergeState.checkAbort.work(300);\n      }\n    }\n    // now we can merge\n    NumericDocValuesConsumer field = addNumericField(mergeState.fieldInfo, minValue, maxValue, mergeState.segmentInfo.getDocCount());\n    field.merge(mergeState);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f176b7bac2a187d69335c079b1f923449fb2881f","date":1353257308,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/SimpleDVConsumer#mergeNumericField(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/SimpleDVConsumer#mergeNumericField(MergeState).mjava","sourceNew":"  // dead simple impl: codec can optimize\n  protected void mergeNumericField(MergeState mergeState) throws IOException {\n    // first compute min and max value of live ones to be merged.\n    long minValue = Long.MAX_VALUE;\n    long maxValue = Long.MIN_VALUE;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      //System.out.println(\"merge field=\" + mergeState.fieldInfo.name);\n      NumericDocValues docValues = reader.getNumericDocValues(mergeState.fieldInfo.name);\n      if (docValues == null) {\n        docValues = NumericDocValues.DEFAULT;\n      }\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs == null || liveDocs.get(i)) {\n          long val = docValues.get(i);\n          minValue = Math.min(val, minValue);\n          maxValue = Math.min(val, maxValue);\n        }\n        mergeState.checkAbort.work(300);\n      }\n    }\n    // now we can merge\n    NumericDocValuesConsumer field = addNumericField(mergeState.fieldInfo, minValue, maxValue);\n    field.merge(mergeState);\n  }\n\n","sourceOld":"  // dead simple impl: codec can optimize\n  protected void mergeNumericField(MergeState mergeState) throws IOException {\n    // first compute min and max value of live ones to be merged.\n    long minValue = Long.MAX_VALUE;\n    long maxValue = Long.MIN_VALUE;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      //System.out.println(\"merge field=\" + mergeState.fieldInfo.name);\n      NumericDocValues docValues = reader.getNumericDocValues(mergeState.fieldInfo.name);\n      if (docValues == null) {\n        docValues = NumericDocValues.DEFAULT;\n      }\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs == null || liveDocs.get(i)) {\n          long val = docValues.get(i);\n          minValue = Math.min(val, minValue);\n          maxValue = Math.min(val, maxValue);\n        }\n        mergeState.checkAbort.work(300);\n      }\n    }\n    // now we can merge\n    NumericDocValuesConsumer field = addNumericField(mergeState.fieldInfo, minValue, maxValue, mergeState.segmentInfo.getDocCount());\n    field.merge(mergeState);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3ee07e8e258de164ee9346427b4307823c0b041d","date":1353263551,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/SimpleDVConsumer#mergeNumericField(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/SimpleDVConsumer#mergeNumericField(MergeState).mjava","sourceNew":"  // dead simple impl: codec can optimize\n  protected void mergeNumericField(MergeState mergeState) throws IOException {\n    // first compute min and max value of live ones to be merged.\n    long minValue = Long.MAX_VALUE;\n    long maxValue = Long.MIN_VALUE;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      //System.out.println(\"merge field=\" + mergeState.fieldInfo.name);\n      NumericDocValues docValues = reader.getNumericDocValues(mergeState.fieldInfo.name);\n      if (docValues == null) {\n        docValues = NumericDocValues.DEFAULT;\n      }\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs == null || liveDocs.get(i)) {\n          long val = docValues.get(i);\n          minValue = Math.min(val, minValue);\n          maxValue = Math.max(val, maxValue);\n        }\n        mergeState.checkAbort.work(300);\n      }\n    }\n    // now we can merge\n    NumericDocValuesConsumer field = addNumericField(mergeState.fieldInfo, minValue, maxValue);\n    field.merge(mergeState);\n  }\n\n","sourceOld":"  // dead simple impl: codec can optimize\n  protected void mergeNumericField(MergeState mergeState) throws IOException {\n    // first compute min and max value of live ones to be merged.\n    long minValue = Long.MAX_VALUE;\n    long maxValue = Long.MIN_VALUE;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      //System.out.println(\"merge field=\" + mergeState.fieldInfo.name);\n      NumericDocValues docValues = reader.getNumericDocValues(mergeState.fieldInfo.name);\n      if (docValues == null) {\n        docValues = NumericDocValues.DEFAULT;\n      }\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs == null || liveDocs.get(i)) {\n          long val = docValues.get(i);\n          minValue = Math.min(val, minValue);\n          maxValue = Math.min(val, maxValue);\n        }\n        mergeState.checkAbort.work(300);\n      }\n    }\n    // now we can merge\n    NumericDocValuesConsumer field = addNumericField(mergeState.fieldInfo, minValue, maxValue);\n    field.merge(mergeState);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6837aa82c41dc48163e43628d0c3d29d47915b0","date":1353334604,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/SimpleDVConsumer#mergeNumericField(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/SimpleDVConsumer#mergeNumericField(MergeState).mjava","sourceNew":"  // dead simple impl: codec can optimize\n  protected void mergeNumericField(MergeState mergeState) throws IOException {\n    // first compute min and max value of live ones to be merged.\n    long minValue = Long.MAX_VALUE;\n    long maxValue = Long.MIN_VALUE;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      //System.out.println(\"merge field=\" + mergeState.fieldInfo.name);\n      NumericDocValues docValues = reader.getNumericDocValues(mergeState.fieldInfo.name);\n      if (docValues == null) {\n        docValues = new NumericDocValues.EMPTY(1);\n      }\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs == null || liveDocs.get(i)) {\n          long val = docValues.get(i);\n          minValue = Math.min(val, minValue);\n          maxValue = Math.max(val, maxValue);\n        }\n        mergeState.checkAbort.work(300);\n      }\n    }\n    // now we can merge\n    NumericDocValuesConsumer field = addNumericField(mergeState.fieldInfo, minValue, maxValue);\n    field.merge(mergeState);\n  }\n\n","sourceOld":"  // dead simple impl: codec can optimize\n  protected void mergeNumericField(MergeState mergeState) throws IOException {\n    // first compute min and max value of live ones to be merged.\n    long minValue = Long.MAX_VALUE;\n    long maxValue = Long.MIN_VALUE;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      //System.out.println(\"merge field=\" + mergeState.fieldInfo.name);\n      NumericDocValues docValues = reader.getNumericDocValues(mergeState.fieldInfo.name);\n      if (docValues == null) {\n        docValues = NumericDocValues.DEFAULT;\n      }\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs == null || liveDocs.get(i)) {\n          long val = docValues.get(i);\n          minValue = Math.min(val, minValue);\n          maxValue = Math.max(val, maxValue);\n        }\n        mergeState.checkAbort.work(300);\n      }\n    }\n    // now we can merge\n    NumericDocValuesConsumer field = addNumericField(mergeState.fieldInfo, minValue, maxValue);\n    field.merge(mergeState);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f958f60b364c4f080208bc779369cf29ca8ab568","date":1353335393,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/SimpleDVConsumer#mergeNumericField(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/SimpleDVConsumer#mergeNumericField(MergeState).mjava","sourceNew":"  // dead simple impl: codec can optimize\n  protected void mergeNumericField(MergeState mergeState) throws IOException {\n    // first compute min and max value of live ones to be merged.\n    long minValue = Long.MAX_VALUE;\n    long maxValue = Long.MIN_VALUE;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      //System.out.println(\"merge field=\" + mergeState.fieldInfo.name);\n      NumericDocValues docValues = reader.getNumericDocValues(mergeState.fieldInfo.name);\n      if (docValues == null) {\n        docValues = new NumericDocValues.EMPTY(maxDoc);\n      }\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs == null || liveDocs.get(i)) {\n          long val = docValues.get(i);\n          minValue = Math.min(val, minValue);\n          maxValue = Math.max(val, maxValue);\n        }\n        mergeState.checkAbort.work(300);\n      }\n    }\n    // now we can merge\n    NumericDocValuesConsumer field = addNumericField(mergeState.fieldInfo, minValue, maxValue);\n    field.merge(mergeState);\n  }\n\n","sourceOld":"  // dead simple impl: codec can optimize\n  protected void mergeNumericField(MergeState mergeState) throws IOException {\n    // first compute min and max value of live ones to be merged.\n    long minValue = Long.MAX_VALUE;\n    long maxValue = Long.MIN_VALUE;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      //System.out.println(\"merge field=\" + mergeState.fieldInfo.name);\n      NumericDocValues docValues = reader.getNumericDocValues(mergeState.fieldInfo.name);\n      if (docValues == null) {\n        docValues = new NumericDocValues.EMPTY(1);\n      }\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs == null || liveDocs.get(i)) {\n          long val = docValues.get(i);\n          minValue = Math.min(val, minValue);\n          maxValue = Math.max(val, maxValue);\n        }\n        mergeState.checkAbort.work(300);\n      }\n    }\n    // now we can merge\n    NumericDocValuesConsumer field = addNumericField(mergeState.fieldInfo, minValue, maxValue);\n    field.merge(mergeState);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55eeb2534cd53d2a985669829df942468ebf5314","date":1354409119,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/SimpleDVConsumer#mergeNumericField(MergeState,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/SimpleDVConsumer#mergeNumericField(MergeState).mjava","sourceNew":"  // nocommit bogus forceNorms:\n  // dead simple impl: codec can optimize\n  protected void mergeNumericField(MergeState mergeState, boolean forceNorms) throws IOException {\n    // first compute min and max value of live ones to be merged.\n    long minValue = Long.MAX_VALUE;\n    long maxValue = Long.MIN_VALUE;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      //System.out.println(\"merge field=\" + mergeState.fieldInfo.name);\n      NumericDocValues docValues = forceNorms ? reader.simpleNormValues(mergeState.fieldInfo.name) : reader.getNumericDocValues(mergeState.fieldInfo.name);\n      if (docValues == null) {\n        // nocommit this isn't correct i think?  ie this one\n        // segment may have no docs containing this\n        // field... and that doesn't mean norms are omitted ...\n        //assert !forceNorms;\n        docValues = new NumericDocValues.EMPTY(maxDoc);\n      }\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs == null || liveDocs.get(i)) {\n          long val = docValues.get(i);\n          minValue = Math.min(val, minValue);\n          maxValue = Math.max(val, maxValue);\n        }\n        mergeState.checkAbort.work(300);\n      }\n    }\n    // now we can merge\n    NumericDocValuesConsumer field = addNumericField(mergeState.fieldInfo, minValue, maxValue);\n    field.merge(mergeState, forceNorms);\n  }\n\n","sourceOld":"  // dead simple impl: codec can optimize\n  protected void mergeNumericField(MergeState mergeState) throws IOException {\n    // first compute min and max value of live ones to be merged.\n    long minValue = Long.MAX_VALUE;\n    long maxValue = Long.MIN_VALUE;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      //System.out.println(\"merge field=\" + mergeState.fieldInfo.name);\n      NumericDocValues docValues = reader.getNumericDocValues(mergeState.fieldInfo.name);\n      if (docValues == null) {\n        docValues = new NumericDocValues.EMPTY(maxDoc);\n      }\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs == null || liveDocs.get(i)) {\n          long val = docValues.get(i);\n          minValue = Math.min(val, minValue);\n          maxValue = Math.max(val, maxValue);\n        }\n        mergeState.checkAbort.work(300);\n      }\n    }\n    // now we can merge\n    NumericDocValuesConsumer field = addNumericField(mergeState.fieldInfo, minValue, maxValue);\n    field.merge(mergeState);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ce73f585d17f53055185a19beb46db23d76e0ad9":["f45b94f31bcc0de4497b99f7b51993765f64c601"],"3cdc80a62bb2b084e97738303ef870bcea0310ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6295f14d43685811599f8a8f02a63d75ec6bd8fe":["ce73f585d17f53055185a19beb46db23d76e0ad9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"25e6d305c838339e588b0a8f3cf8f868d8597a0b":["3cdc80a62bb2b084e97738303ef870bcea0310ac"],"f176b7bac2a187d69335c079b1f923449fb2881f":["6295f14d43685811599f8a8f02a63d75ec6bd8fe"],"55eeb2534cd53d2a985669829df942468ebf5314":["f958f60b364c4f080208bc779369cf29ca8ab568"],"f45b94f31bcc0de4497b99f7b51993765f64c601":["25e6d305c838339e588b0a8f3cf8f868d8597a0b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f958f60b364c4f080208bc779369cf29ca8ab568":["b6837aa82c41dc48163e43628d0c3d29d47915b0"],"b6837aa82c41dc48163e43628d0c3d29d47915b0":["3ee07e8e258de164ee9346427b4307823c0b041d"],"3ee07e8e258de164ee9346427b4307823c0b041d":["f176b7bac2a187d69335c079b1f923449fb2881f"]},"commit2Childs":{"ce73f585d17f53055185a19beb46db23d76e0ad9":["6295f14d43685811599f8a8f02a63d75ec6bd8fe"],"3cdc80a62bb2b084e97738303ef870bcea0310ac":["25e6d305c838339e588b0a8f3cf8f868d8597a0b"],"6295f14d43685811599f8a8f02a63d75ec6bd8fe":["f176b7bac2a187d69335c079b1f923449fb2881f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3cdc80a62bb2b084e97738303ef870bcea0310ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"25e6d305c838339e588b0a8f3cf8f868d8597a0b":["f45b94f31bcc0de4497b99f7b51993765f64c601"],"f176b7bac2a187d69335c079b1f923449fb2881f":["3ee07e8e258de164ee9346427b4307823c0b041d"],"f45b94f31bcc0de4497b99f7b51993765f64c601":["ce73f585d17f53055185a19beb46db23d76e0ad9"],"55eeb2534cd53d2a985669829df942468ebf5314":[],"f958f60b364c4f080208bc779369cf29ca8ab568":["55eeb2534cd53d2a985669829df942468ebf5314"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b6837aa82c41dc48163e43628d0c3d29d47915b0":["f958f60b364c4f080208bc779369cf29ca8ab568"],"3ee07e8e258de164ee9346427b4307823c0b041d":["b6837aa82c41dc48163e43628d0c3d29d47915b0"]},"heads":["55eeb2534cd53d2a985669829df942468ebf5314","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}