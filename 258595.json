{"path":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweepByCacheSize().mjava","commits":[{"id":"7c5044c9bb1518e7a13c1c5385a21325ae343056","date":1479187798,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweepByCacheSize().mjava","pathOld":"/dev/null","sourceNew":"  /*\n    Must be called after acquiring markAndSweeoLock\n   */\n  private void markAndSweepByCacheSize() {\n    long oldestEntry = this.oldestEntry;\n    isCleaning = true;\n    this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n    long timeCurrent = stats.accessCounter.longValue();\n    int sz = stats.size.get();\n\n    int numRemoved = 0;\n    int numKept = 0;\n    long newestEntry = timeCurrent;\n    long newNewestEntry = -1;\n    long newOldestEntry = Long.MAX_VALUE;\n\n    int wantToKeep = lowerWaterMark;\n    int wantToRemove = sz - lowerWaterMark;\n\n    @SuppressWarnings(\"unchecked\") // generic array's are annoying\n    CacheEntry<K,V>[] eset = new CacheEntry[sz];\n    int eSize = 0;\n\n    // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n    // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n    for (CacheEntry<K,V> ce : map.values()) {\n      // set lastAccessedCopy to avoid more volatile reads\n      ce.lastAccessedCopy = ce.lastAccessed;\n      long thisEntry = ce.lastAccessedCopy;\n\n      // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n      if (thisEntry > newestEntry - wantToKeep) {\n        // this entry is guaranteed not to be in the bottom\n        // group, so do nothing.\n        numKept++;\n        newOldestEntry = Math.min(thisEntry, newOldestEntry);\n      } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n        // this entry is guaranteed to be in the bottom group\n        // so immediately remove it from the map.\n        evictEntry(ce.key);\n        numRemoved++;\n      } else {\n        // This entry *could* be in the bottom group.\n        // Collect these entries to avoid another full pass... this is wasted\n        // effort if enough entries are normally removed in this first pass.\n        // An alternate impl could make a full second pass.\n        if (eSize < eset.length-1) {\n          eset[eSize++] = ce;\n          newNewestEntry = Math.max(thisEntry, newNewestEntry);\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        }\n      }\n    }\n\n    // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n    // TODO: allow this to be customized in the constructor?\n    int numPasses=1; // maximum number of linear passes over the data\n\n    // if we didn't remove enough entries, then make more passes\n    // over the values we collected, with updated min and max values.\n    while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      newOldestEntry = Long.MAX_VALUE;\n      newestEntry = newNewestEntry;\n      newNewestEntry = -1;\n      wantToKeep = lowerWaterMark - numKept;\n      wantToRemove = sz - lowerWaterMark - numRemoved;\n\n      // iterate backward to make it easy to remove items.\n      for (int i=eSize-1; i>=0; i--) {\n        CacheEntry<K,V> ce = eset[i];\n        long thisEntry = ce.lastAccessedCopy;\n\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing but remove it from the eset.\n          numKept++;\n          // remove the entry by moving the last element to its position\n          eset[i] = eset[eSize-1];\n          eSize--;\n\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n\n          // remove the entry by moving the last element to its position\n          eset[i] = eset[eSize-1];\n          eSize--;\n        } else {\n          // This entry *could* be in the bottom group, so keep it in the eset,\n          // and update the stats.\n          newNewestEntry = Math.max(thisEntry, newNewestEntry);\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        }\n      }\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n    }\n\n\n    // if we still didn't remove enough entries, then make another pass while\n    // inserting into a priority queue\n    if (sz - numRemoved > acceptableWaterMark) {\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      newOldestEntry = Long.MAX_VALUE;\n      newestEntry = newNewestEntry;\n      newNewestEntry = -1;\n      wantToKeep = lowerWaterMark - numKept;\n      wantToRemove = sz - lowerWaterMark - numRemoved;\n\n      PQueue<K,V> queue = new PQueue<>(wantToRemove);\n\n      for (int i=eSize-1; i>=0; i--) {\n        CacheEntry<K,V> ce = eset[i];\n        long thisEntry = ce.lastAccessedCopy;\n\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing but remove it from the eset.\n          numKept++;\n          // removal not necessary on last pass.\n          // eset[i] = eset[eSize-1];\n          // eSize--;\n\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n\n        } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it.\n          evictEntry(ce.key);\n          numRemoved++;\n\n          // removal not necessary on last pass.\n          // eset[i] = eset[eSize-1];\n          // eSize--;\n        } else {\n          // This entry *could* be in the bottom group.\n          // add it to the priority queue\n\n          // everything in the priority queue will be removed, so keep track of\n          // the lowest value that ever comes back out of the queue.\n\n          // first reduce the size of the priority queue to account for\n          // the number of items we have already removed while executing\n          // this loop so far.\n          queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n          while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n            CacheEntry otherEntry = queue.pop();\n            newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n          }\n          if (queue.myMaxSize <= 0) break;\n\n          Object o = queue.myInsertWithOverflow(ce);\n          if (o != null) {\n            newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n          }\n        }\n      }\n\n      // Now delete everything in the priority queue.\n      // avoid using pop() since order doesn't matter anymore\n      for (CacheEntry<K,V> ce : queue.getValues()) {\n        if (ce==null) continue;\n        evictEntry(ce.key);\n        numRemoved++;\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n    }\n\n    oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n    this.oldestEntry = oldestEntry;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"21019aa828c8c9b0153877543a8b3f200bf2ca19","date":1479224450,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweepByCacheSize().mjava","pathOld":"/dev/null","sourceNew":"  /*\n    Must be called after acquiring markAndSweeoLock\n   */\n  private void markAndSweepByCacheSize() {\n    long oldestEntry = this.oldestEntry;\n    isCleaning = true;\n    this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n    long timeCurrent = stats.accessCounter.longValue();\n    int sz = stats.size.get();\n\n    int numRemoved = 0;\n    int numKept = 0;\n    long newestEntry = timeCurrent;\n    long newNewestEntry = -1;\n    long newOldestEntry = Long.MAX_VALUE;\n\n    int wantToKeep = lowerWaterMark;\n    int wantToRemove = sz - lowerWaterMark;\n\n    @SuppressWarnings(\"unchecked\") // generic array's are annoying\n    CacheEntry<K,V>[] eset = new CacheEntry[sz];\n    int eSize = 0;\n\n    // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n    // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n    for (CacheEntry<K,V> ce : map.values()) {\n      // set lastAccessedCopy to avoid more volatile reads\n      ce.lastAccessedCopy = ce.lastAccessed;\n      long thisEntry = ce.lastAccessedCopy;\n\n      // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n      if (thisEntry > newestEntry - wantToKeep) {\n        // this entry is guaranteed not to be in the bottom\n        // group, so do nothing.\n        numKept++;\n        newOldestEntry = Math.min(thisEntry, newOldestEntry);\n      } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n        // this entry is guaranteed to be in the bottom group\n        // so immediately remove it from the map.\n        evictEntry(ce.key);\n        numRemoved++;\n      } else {\n        // This entry *could* be in the bottom group.\n        // Collect these entries to avoid another full pass... this is wasted\n        // effort if enough entries are normally removed in this first pass.\n        // An alternate impl could make a full second pass.\n        if (eSize < eset.length-1) {\n          eset[eSize++] = ce;\n          newNewestEntry = Math.max(thisEntry, newNewestEntry);\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        }\n      }\n    }\n\n    // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n    // TODO: allow this to be customized in the constructor?\n    int numPasses=1; // maximum number of linear passes over the data\n\n    // if we didn't remove enough entries, then make more passes\n    // over the values we collected, with updated min and max values.\n    while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      newOldestEntry = Long.MAX_VALUE;\n      newestEntry = newNewestEntry;\n      newNewestEntry = -1;\n      wantToKeep = lowerWaterMark - numKept;\n      wantToRemove = sz - lowerWaterMark - numRemoved;\n\n      // iterate backward to make it easy to remove items.\n      for (int i=eSize-1; i>=0; i--) {\n        CacheEntry<K,V> ce = eset[i];\n        long thisEntry = ce.lastAccessedCopy;\n\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing but remove it from the eset.\n          numKept++;\n          // remove the entry by moving the last element to its position\n          eset[i] = eset[eSize-1];\n          eSize--;\n\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n\n          // remove the entry by moving the last element to its position\n          eset[i] = eset[eSize-1];\n          eSize--;\n        } else {\n          // This entry *could* be in the bottom group, so keep it in the eset,\n          // and update the stats.\n          newNewestEntry = Math.max(thisEntry, newNewestEntry);\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        }\n      }\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n    }\n\n\n    // if we still didn't remove enough entries, then make another pass while\n    // inserting into a priority queue\n    if (sz - numRemoved > acceptableWaterMark) {\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      newOldestEntry = Long.MAX_VALUE;\n      newestEntry = newNewestEntry;\n      newNewestEntry = -1;\n      wantToKeep = lowerWaterMark - numKept;\n      wantToRemove = sz - lowerWaterMark - numRemoved;\n\n      PQueue<K,V> queue = new PQueue<>(wantToRemove);\n\n      for (int i=eSize-1; i>=0; i--) {\n        CacheEntry<K,V> ce = eset[i];\n        long thisEntry = ce.lastAccessedCopy;\n\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing but remove it from the eset.\n          numKept++;\n          // removal not necessary on last pass.\n          // eset[i] = eset[eSize-1];\n          // eSize--;\n\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n\n        } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it.\n          evictEntry(ce.key);\n          numRemoved++;\n\n          // removal not necessary on last pass.\n          // eset[i] = eset[eSize-1];\n          // eSize--;\n        } else {\n          // This entry *could* be in the bottom group.\n          // add it to the priority queue\n\n          // everything in the priority queue will be removed, so keep track of\n          // the lowest value that ever comes back out of the queue.\n\n          // first reduce the size of the priority queue to account for\n          // the number of items we have already removed while executing\n          // this loop so far.\n          queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n          while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n            CacheEntry otherEntry = queue.pop();\n            newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n          }\n          if (queue.myMaxSize <= 0) break;\n\n          Object o = queue.myInsertWithOverflow(ce);\n          if (o != null) {\n            newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n          }\n        }\n      }\n\n      // Now delete everything in the priority queue.\n      // avoid using pop() since order doesn't matter anymore\n      for (CacheEntry<K,V> ce : queue.getValues()) {\n        if (ce==null) continue;\n        evictEntry(ce.key);\n        numRemoved++;\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n    }\n\n    oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n    this.oldestEntry = oldestEntry;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fbd58791ecf2b92d8917c2f4aab0e50965ec6a83","date":1568645407,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweepByCacheSize().mjava","pathOld":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweepByCacheSize().mjava","sourceNew":"  /*\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * </p>\n   * <p>The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.</p>\n   * Must be called after acquiring markAndSweepLock\n   */\n  private void markAndSweepByCacheSize() {\n    assert markAndSweepLock.isHeldByCurrentThread() : \"markAndSweepLock held by another thread\";\n    long oldestEntry = this.oldestEntry;\n    isCleaning = true;\n    this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n    long timeCurrent = stats.accessCounter.longValue();\n    int sz = stats.size.get();\n\n    int numRemoved = 0;\n    int numKept = 0;\n    long newestEntry = timeCurrent;\n    long newNewestEntry = -1;\n    long newOldestEntry = Long.MAX_VALUE;\n\n    int wantToKeep = lowerWaterMark;\n    int wantToRemove = sz - lowerWaterMark;\n\n    @SuppressWarnings(\"unchecked\") // generic array's are annoying\n    CacheEntry<K,V>[] eset = new CacheEntry[sz];\n    int eSize = 0;\n\n    // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n    // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n    for (CacheEntry<K,V> ce : map.values()) {\n      // set lastAccessedCopy to avoid more volatile reads\n      ce.lastAccessedCopy = ce.lastAccessed;\n      long thisEntry = ce.lastAccessedCopy;\n\n      // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n      if (thisEntry > newestEntry - wantToKeep) {\n        // this entry is guaranteed not to be in the bottom\n        // group, so do nothing.\n        numKept++;\n        newOldestEntry = Math.min(thisEntry, newOldestEntry);\n      } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n        // this entry is guaranteed to be in the bottom group\n        // so immediately remove it from the map.\n        evictEntry(ce.key);\n        numRemoved++;\n      } else {\n        // This entry *could* be in the bottom group.\n        // Collect these entries to avoid another full pass... this is wasted\n        // effort if enough entries are normally removed in this first pass.\n        // An alternate impl could make a full second pass.\n        if (eSize < eset.length-1) {\n          eset[eSize++] = ce;\n          newNewestEntry = Math.max(thisEntry, newNewestEntry);\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        }\n      }\n    }\n\n    // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n    // TODO: allow this to be customized in the constructor?\n    int numPasses=1; // maximum number of linear passes over the data\n\n    // if we didn't remove enough entries, then make more passes\n    // over the values we collected, with updated min and max values.\n    while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      newOldestEntry = Long.MAX_VALUE;\n      newestEntry = newNewestEntry;\n      newNewestEntry = -1;\n      wantToKeep = lowerWaterMark - numKept;\n      wantToRemove = sz - lowerWaterMark - numRemoved;\n\n      // iterate backward to make it easy to remove items.\n      for (int i=eSize-1; i>=0; i--) {\n        CacheEntry<K,V> ce = eset[i];\n        long thisEntry = ce.lastAccessedCopy;\n\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing but remove it from the eset.\n          numKept++;\n          // remove the entry by moving the last element to its position\n          eset[i] = eset[eSize-1];\n          eSize--;\n\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n\n          // remove the entry by moving the last element to its position\n          eset[i] = eset[eSize-1];\n          eSize--;\n        } else {\n          // This entry *could* be in the bottom group, so keep it in the eset,\n          // and update the stats.\n          newNewestEntry = Math.max(thisEntry, newNewestEntry);\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        }\n      }\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n    }\n\n\n    // if we still didn't remove enough entries, then make another pass while\n    // inserting into a priority queue\n    if (sz - numRemoved > acceptableWaterMark) {\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      newOldestEntry = Long.MAX_VALUE;\n      newestEntry = newNewestEntry;\n      newNewestEntry = -1;\n      wantToKeep = lowerWaterMark - numKept;\n      wantToRemove = sz - lowerWaterMark - numRemoved;\n\n      PQueue<K,V> queue = new PQueue<>(wantToRemove);\n\n      for (int i=eSize-1; i>=0; i--) {\n        CacheEntry<K,V> ce = eset[i];\n        long thisEntry = ce.lastAccessedCopy;\n\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing but remove it from the eset.\n          numKept++;\n          // removal not necessary on last pass.\n          // eset[i] = eset[eSize-1];\n          // eSize--;\n\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n\n        } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it.\n          evictEntry(ce.key);\n          numRemoved++;\n\n          // removal not necessary on last pass.\n          // eset[i] = eset[eSize-1];\n          // eSize--;\n        } else {\n          // This entry *could* be in the bottom group.\n          // add it to the priority queue\n\n          // everything in the priority queue will be removed, so keep track of\n          // the lowest value that ever comes back out of the queue.\n\n          // first reduce the size of the priority queue to account for\n          // the number of items we have already removed while executing\n          // this loop so far.\n          queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n          while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n            CacheEntry otherEntry = queue.pop();\n            newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n          }\n          if (queue.myMaxSize <= 0) break;\n\n          Object o = queue.myInsertWithOverflow(ce);\n          if (o != null) {\n            newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n          }\n        }\n      }\n\n      // Now delete everything in the priority queue.\n      // avoid using pop() since order doesn't matter anymore\n      for (CacheEntry<K,V> ce : queue.getValues()) {\n        if (ce==null) continue;\n        evictEntry(ce.key);\n        numRemoved++;\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n    }\n\n    oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n    this.oldestEntry = oldestEntry;\n  }\n\n","sourceOld":"  /*\n    Must be called after acquiring markAndSweeoLock\n   */\n  private void markAndSweepByCacheSize() {\n    long oldestEntry = this.oldestEntry;\n    isCleaning = true;\n    this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n    long timeCurrent = stats.accessCounter.longValue();\n    int sz = stats.size.get();\n\n    int numRemoved = 0;\n    int numKept = 0;\n    long newestEntry = timeCurrent;\n    long newNewestEntry = -1;\n    long newOldestEntry = Long.MAX_VALUE;\n\n    int wantToKeep = lowerWaterMark;\n    int wantToRemove = sz - lowerWaterMark;\n\n    @SuppressWarnings(\"unchecked\") // generic array's are annoying\n    CacheEntry<K,V>[] eset = new CacheEntry[sz];\n    int eSize = 0;\n\n    // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n    // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n    for (CacheEntry<K,V> ce : map.values()) {\n      // set lastAccessedCopy to avoid more volatile reads\n      ce.lastAccessedCopy = ce.lastAccessed;\n      long thisEntry = ce.lastAccessedCopy;\n\n      // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n      if (thisEntry > newestEntry - wantToKeep) {\n        // this entry is guaranteed not to be in the bottom\n        // group, so do nothing.\n        numKept++;\n        newOldestEntry = Math.min(thisEntry, newOldestEntry);\n      } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n        // this entry is guaranteed to be in the bottom group\n        // so immediately remove it from the map.\n        evictEntry(ce.key);\n        numRemoved++;\n      } else {\n        // This entry *could* be in the bottom group.\n        // Collect these entries to avoid another full pass... this is wasted\n        // effort if enough entries are normally removed in this first pass.\n        // An alternate impl could make a full second pass.\n        if (eSize < eset.length-1) {\n          eset[eSize++] = ce;\n          newNewestEntry = Math.max(thisEntry, newNewestEntry);\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        }\n      }\n    }\n\n    // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n    // TODO: allow this to be customized in the constructor?\n    int numPasses=1; // maximum number of linear passes over the data\n\n    // if we didn't remove enough entries, then make more passes\n    // over the values we collected, with updated min and max values.\n    while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      newOldestEntry = Long.MAX_VALUE;\n      newestEntry = newNewestEntry;\n      newNewestEntry = -1;\n      wantToKeep = lowerWaterMark - numKept;\n      wantToRemove = sz - lowerWaterMark - numRemoved;\n\n      // iterate backward to make it easy to remove items.\n      for (int i=eSize-1; i>=0; i--) {\n        CacheEntry<K,V> ce = eset[i];\n        long thisEntry = ce.lastAccessedCopy;\n\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing but remove it from the eset.\n          numKept++;\n          // remove the entry by moving the last element to its position\n          eset[i] = eset[eSize-1];\n          eSize--;\n\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n\n          // remove the entry by moving the last element to its position\n          eset[i] = eset[eSize-1];\n          eSize--;\n        } else {\n          // This entry *could* be in the bottom group, so keep it in the eset,\n          // and update the stats.\n          newNewestEntry = Math.max(thisEntry, newNewestEntry);\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        }\n      }\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n    }\n\n\n    // if we still didn't remove enough entries, then make another pass while\n    // inserting into a priority queue\n    if (sz - numRemoved > acceptableWaterMark) {\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      newOldestEntry = Long.MAX_VALUE;\n      newestEntry = newNewestEntry;\n      newNewestEntry = -1;\n      wantToKeep = lowerWaterMark - numKept;\n      wantToRemove = sz - lowerWaterMark - numRemoved;\n\n      PQueue<K,V> queue = new PQueue<>(wantToRemove);\n\n      for (int i=eSize-1; i>=0; i--) {\n        CacheEntry<K,V> ce = eset[i];\n        long thisEntry = ce.lastAccessedCopy;\n\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing but remove it from the eset.\n          numKept++;\n          // removal not necessary on last pass.\n          // eset[i] = eset[eSize-1];\n          // eSize--;\n\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n\n        } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it.\n          evictEntry(ce.key);\n          numRemoved++;\n\n          // removal not necessary on last pass.\n          // eset[i] = eset[eSize-1];\n          // eSize--;\n        } else {\n          // This entry *could* be in the bottom group.\n          // add it to the priority queue\n\n          // everything in the priority queue will be removed, so keep track of\n          // the lowest value that ever comes back out of the queue.\n\n          // first reduce the size of the priority queue to account for\n          // the number of items we have already removed while executing\n          // this loop so far.\n          queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n          while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n            CacheEntry otherEntry = queue.pop();\n            newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n          }\n          if (queue.myMaxSize <= 0) break;\n\n          Object o = queue.myInsertWithOverflow(ce);\n          if (o != null) {\n            newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n          }\n        }\n      }\n\n      // Now delete everything in the priority queue.\n      // avoid using pop() since order doesn't matter anymore\n      for (CacheEntry<K,V> ce : queue.getValues()) {\n        if (ce==null) continue;\n        evictEntry(ce.key);\n        numRemoved++;\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n    }\n\n    oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n    this.oldestEntry = oldestEntry;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"87f0484c38f986062889ed50f3bf3bd462848c26","date":1570108628,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweepByCacheSize().mjava","pathOld":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweepByCacheSize().mjava","sourceNew":"  /*\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * </p>\n   * <p>The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.</p>\n   * Must be called after acquiring markAndSweepLock\n   */\n  private void markAndSweepByCacheSize() {\n    assert markAndSweepLock.isHeldByCurrentThread() : \"markAndSweepLock held by another thread\";\n    long oldestEntry = this.oldestEntry;\n    isCleaning = true;\n    this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n    long timeCurrent = stats.accessCounter.longValue();\n    int sz = stats.size.intValue();\n\n    int numRemoved = 0;\n    int numKept = 0;\n    long newestEntry = timeCurrent;\n    long newNewestEntry = -1;\n    long newOldestEntry = Long.MAX_VALUE;\n\n    int wantToKeep = lowerWaterMark;\n    int wantToRemove = sz - lowerWaterMark;\n\n    @SuppressWarnings(\"unchecked\") // generic array's are annoying\n    CacheEntry<K,V>[] eset = new CacheEntry[sz];\n    int eSize = 0;\n\n    // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n    // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n    for (CacheEntry<K,V> ce : map.values()) {\n      // set lastAccessedCopy to avoid more volatile reads\n      ce.lastAccessedCopy = ce.lastAccessed;\n      long thisEntry = ce.lastAccessedCopy;\n\n      // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n      if (thisEntry > newestEntry - wantToKeep) {\n        // this entry is guaranteed not to be in the bottom\n        // group, so do nothing.\n        numKept++;\n        newOldestEntry = Math.min(thisEntry, newOldestEntry);\n      } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n        // this entry is guaranteed to be in the bottom group\n        // so immediately remove it from the map.\n        evictEntry(ce.key);\n        numRemoved++;\n      } else {\n        // This entry *could* be in the bottom group.\n        // Collect these entries to avoid another full pass... this is wasted\n        // effort if enough entries are normally removed in this first pass.\n        // An alternate impl could make a full second pass.\n        if (eSize < eset.length-1) {\n          eset[eSize++] = ce;\n          newNewestEntry = Math.max(thisEntry, newNewestEntry);\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        }\n      }\n    }\n\n    // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n    // TODO: allow this to be customized in the constructor?\n    int numPasses=1; // maximum number of linear passes over the data\n\n    // if we didn't remove enough entries, then make more passes\n    // over the values we collected, with updated min and max values.\n    while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      newOldestEntry = Long.MAX_VALUE;\n      newestEntry = newNewestEntry;\n      newNewestEntry = -1;\n      wantToKeep = lowerWaterMark - numKept;\n      wantToRemove = sz - lowerWaterMark - numRemoved;\n\n      // iterate backward to make it easy to remove items.\n      for (int i=eSize-1; i>=0; i--) {\n        CacheEntry<K,V> ce = eset[i];\n        long thisEntry = ce.lastAccessedCopy;\n\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing but remove it from the eset.\n          numKept++;\n          // remove the entry by moving the last element to its position\n          eset[i] = eset[eSize-1];\n          eSize--;\n\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n\n          // remove the entry by moving the last element to its position\n          eset[i] = eset[eSize-1];\n          eSize--;\n        } else {\n          // This entry *could* be in the bottom group, so keep it in the eset,\n          // and update the stats.\n          newNewestEntry = Math.max(thisEntry, newNewestEntry);\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        }\n      }\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n    }\n\n\n    // if we still didn't remove enough entries, then make another pass while\n    // inserting into a priority queue\n    if (sz - numRemoved > acceptableWaterMark) {\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      newOldestEntry = Long.MAX_VALUE;\n      newestEntry = newNewestEntry;\n      newNewestEntry = -1;\n      wantToKeep = lowerWaterMark - numKept;\n      wantToRemove = sz - lowerWaterMark - numRemoved;\n\n      PQueue<K,V> queue = new PQueue<>(wantToRemove);\n\n      for (int i=eSize-1; i>=0; i--) {\n        CacheEntry<K,V> ce = eset[i];\n        long thisEntry = ce.lastAccessedCopy;\n\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing but remove it from the eset.\n          numKept++;\n          // removal not necessary on last pass.\n          // eset[i] = eset[eSize-1];\n          // eSize--;\n\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n\n        } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it.\n          evictEntry(ce.key);\n          numRemoved++;\n\n          // removal not necessary on last pass.\n          // eset[i] = eset[eSize-1];\n          // eSize--;\n        } else {\n          // This entry *could* be in the bottom group.\n          // add it to the priority queue\n\n          // everything in the priority queue will be removed, so keep track of\n          // the lowest value that ever comes back out of the queue.\n\n          // first reduce the size of the priority queue to account for\n          // the number of items we have already removed while executing\n          // this loop so far.\n          queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n          while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n            CacheEntry otherEntry = queue.pop();\n            newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n          }\n          if (queue.myMaxSize <= 0) break;\n\n          Object o = queue.myInsertWithOverflow(ce);\n          if (o != null) {\n            newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n          }\n        }\n      }\n\n      // Now delete everything in the priority queue.\n      // avoid using pop() since order doesn't matter anymore\n      for (CacheEntry<K,V> ce : queue.getValues()) {\n        if (ce==null) continue;\n        evictEntry(ce.key);\n        numRemoved++;\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n    }\n\n    oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n    this.oldestEntry = oldestEntry;\n  }\n\n","sourceOld":"  /*\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * </p>\n   * <p>The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.</p>\n   * Must be called after acquiring markAndSweepLock\n   */\n  private void markAndSweepByCacheSize() {\n    assert markAndSweepLock.isHeldByCurrentThread() : \"markAndSweepLock held by another thread\";\n    long oldestEntry = this.oldestEntry;\n    isCleaning = true;\n    this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n    long timeCurrent = stats.accessCounter.longValue();\n    int sz = stats.size.get();\n\n    int numRemoved = 0;\n    int numKept = 0;\n    long newestEntry = timeCurrent;\n    long newNewestEntry = -1;\n    long newOldestEntry = Long.MAX_VALUE;\n\n    int wantToKeep = lowerWaterMark;\n    int wantToRemove = sz - lowerWaterMark;\n\n    @SuppressWarnings(\"unchecked\") // generic array's are annoying\n    CacheEntry<K,V>[] eset = new CacheEntry[sz];\n    int eSize = 0;\n\n    // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n    // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n    for (CacheEntry<K,V> ce : map.values()) {\n      // set lastAccessedCopy to avoid more volatile reads\n      ce.lastAccessedCopy = ce.lastAccessed;\n      long thisEntry = ce.lastAccessedCopy;\n\n      // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n      if (thisEntry > newestEntry - wantToKeep) {\n        // this entry is guaranteed not to be in the bottom\n        // group, so do nothing.\n        numKept++;\n        newOldestEntry = Math.min(thisEntry, newOldestEntry);\n      } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n        // this entry is guaranteed to be in the bottom group\n        // so immediately remove it from the map.\n        evictEntry(ce.key);\n        numRemoved++;\n      } else {\n        // This entry *could* be in the bottom group.\n        // Collect these entries to avoid another full pass... this is wasted\n        // effort if enough entries are normally removed in this first pass.\n        // An alternate impl could make a full second pass.\n        if (eSize < eset.length-1) {\n          eset[eSize++] = ce;\n          newNewestEntry = Math.max(thisEntry, newNewestEntry);\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        }\n      }\n    }\n\n    // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n    // TODO: allow this to be customized in the constructor?\n    int numPasses=1; // maximum number of linear passes over the data\n\n    // if we didn't remove enough entries, then make more passes\n    // over the values we collected, with updated min and max values.\n    while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      newOldestEntry = Long.MAX_VALUE;\n      newestEntry = newNewestEntry;\n      newNewestEntry = -1;\n      wantToKeep = lowerWaterMark - numKept;\n      wantToRemove = sz - lowerWaterMark - numRemoved;\n\n      // iterate backward to make it easy to remove items.\n      for (int i=eSize-1; i>=0; i--) {\n        CacheEntry<K,V> ce = eset[i];\n        long thisEntry = ce.lastAccessedCopy;\n\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing but remove it from the eset.\n          numKept++;\n          // remove the entry by moving the last element to its position\n          eset[i] = eset[eSize-1];\n          eSize--;\n\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n\n          // remove the entry by moving the last element to its position\n          eset[i] = eset[eSize-1];\n          eSize--;\n        } else {\n          // This entry *could* be in the bottom group, so keep it in the eset,\n          // and update the stats.\n          newNewestEntry = Math.max(thisEntry, newNewestEntry);\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        }\n      }\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n    }\n\n\n    // if we still didn't remove enough entries, then make another pass while\n    // inserting into a priority queue\n    if (sz - numRemoved > acceptableWaterMark) {\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      newOldestEntry = Long.MAX_VALUE;\n      newestEntry = newNewestEntry;\n      newNewestEntry = -1;\n      wantToKeep = lowerWaterMark - numKept;\n      wantToRemove = sz - lowerWaterMark - numRemoved;\n\n      PQueue<K,V> queue = new PQueue<>(wantToRemove);\n\n      for (int i=eSize-1; i>=0; i--) {\n        CacheEntry<K,V> ce = eset[i];\n        long thisEntry = ce.lastAccessedCopy;\n\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing but remove it from the eset.\n          numKept++;\n          // removal not necessary on last pass.\n          // eset[i] = eset[eSize-1];\n          // eSize--;\n\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n\n        } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it.\n          evictEntry(ce.key);\n          numRemoved++;\n\n          // removal not necessary on last pass.\n          // eset[i] = eset[eSize-1];\n          // eSize--;\n        } else {\n          // This entry *could* be in the bottom group.\n          // add it to the priority queue\n\n          // everything in the priority queue will be removed, so keep track of\n          // the lowest value that ever comes back out of the queue.\n\n          // first reduce the size of the priority queue to account for\n          // the number of items we have already removed while executing\n          // this loop so far.\n          queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n          while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n            CacheEntry otherEntry = queue.pop();\n            newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n          }\n          if (queue.myMaxSize <= 0) break;\n\n          Object o = queue.myInsertWithOverflow(ce);\n          if (o != null) {\n            newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n          }\n        }\n      }\n\n      // Now delete everything in the priority queue.\n      // avoid using pop() since order doesn't matter anymore\n      for (CacheEntry<K,V> ce : queue.getValues()) {\n        if (ce==null) continue;\n        evictEntry(ce.key);\n        numRemoved++;\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n    }\n\n    oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n    this.oldestEntry = oldestEntry;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweepByCacheSize().mjava","pathOld":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweepByCacheSize().mjava","sourceNew":"  /*\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * </p>\n   * <p>The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.</p>\n   * Must be called after acquiring markAndSweepLock\n   */\n  private void markAndSweepByCacheSize() {\n    assert markAndSweepLock.isHeldByCurrentThread() : \"markAndSweepLock held by another thread\";\n    long oldestEntry = this.oldestEntry;\n    isCleaning = true;\n    this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n    long timeCurrent = stats.accessCounter.longValue();\n    int sz = stats.size.intValue();\n\n    int numRemoved = 0;\n    int numKept = 0;\n    long newestEntry = timeCurrent;\n    long newNewestEntry = -1;\n    long newOldestEntry = Long.MAX_VALUE;\n\n    int wantToKeep = lowerWaterMark;\n    int wantToRemove = sz - lowerWaterMark;\n\n    @SuppressWarnings(\"unchecked\") // generic array's are annoying\n    CacheEntry<K,V>[] eset = new CacheEntry[sz];\n    int eSize = 0;\n\n    // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n    // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n    for (CacheEntry<K,V> ce : map.values()) {\n      // set lastAccessedCopy to avoid more volatile reads\n      ce.lastAccessedCopy = ce.lastAccessed;\n      long thisEntry = ce.lastAccessedCopy;\n\n      // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n      if (thisEntry > newestEntry - wantToKeep) {\n        // this entry is guaranteed not to be in the bottom\n        // group, so do nothing.\n        numKept++;\n        newOldestEntry = Math.min(thisEntry, newOldestEntry);\n      } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n        // this entry is guaranteed to be in the bottom group\n        // so immediately remove it from the map.\n        evictEntry(ce.key);\n        numRemoved++;\n      } else {\n        // This entry *could* be in the bottom group.\n        // Collect these entries to avoid another full pass... this is wasted\n        // effort if enough entries are normally removed in this first pass.\n        // An alternate impl could make a full second pass.\n        if (eSize < eset.length-1) {\n          eset[eSize++] = ce;\n          newNewestEntry = Math.max(thisEntry, newNewestEntry);\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        }\n      }\n    }\n\n    // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n    // TODO: allow this to be customized in the constructor?\n    int numPasses=1; // maximum number of linear passes over the data\n\n    // if we didn't remove enough entries, then make more passes\n    // over the values we collected, with updated min and max values.\n    while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      newOldestEntry = Long.MAX_VALUE;\n      newestEntry = newNewestEntry;\n      newNewestEntry = -1;\n      wantToKeep = lowerWaterMark - numKept;\n      wantToRemove = sz - lowerWaterMark - numRemoved;\n\n      // iterate backward to make it easy to remove items.\n      for (int i=eSize-1; i>=0; i--) {\n        CacheEntry<K,V> ce = eset[i];\n        long thisEntry = ce.lastAccessedCopy;\n\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing but remove it from the eset.\n          numKept++;\n          // remove the entry by moving the last element to its position\n          eset[i] = eset[eSize-1];\n          eSize--;\n\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n\n          // remove the entry by moving the last element to its position\n          eset[i] = eset[eSize-1];\n          eSize--;\n        } else {\n          // This entry *could* be in the bottom group, so keep it in the eset,\n          // and update the stats.\n          newNewestEntry = Math.max(thisEntry, newNewestEntry);\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        }\n      }\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n    }\n\n\n    // if we still didn't remove enough entries, then make another pass while\n    // inserting into a priority queue\n    if (sz - numRemoved > acceptableWaterMark) {\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      newOldestEntry = Long.MAX_VALUE;\n      newestEntry = newNewestEntry;\n      newNewestEntry = -1;\n      wantToKeep = lowerWaterMark - numKept;\n      wantToRemove = sz - lowerWaterMark - numRemoved;\n\n      PQueue<K,V> queue = new PQueue<>(wantToRemove);\n\n      for (int i=eSize-1; i>=0; i--) {\n        CacheEntry<K,V> ce = eset[i];\n        long thisEntry = ce.lastAccessedCopy;\n\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing but remove it from the eset.\n          numKept++;\n          // removal not necessary on last pass.\n          // eset[i] = eset[eSize-1];\n          // eSize--;\n\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n\n        } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it.\n          evictEntry(ce.key);\n          numRemoved++;\n\n          // removal not necessary on last pass.\n          // eset[i] = eset[eSize-1];\n          // eSize--;\n        } else {\n          // This entry *could* be in the bottom group.\n          // add it to the priority queue\n\n          // everything in the priority queue will be removed, so keep track of\n          // the lowest value that ever comes back out of the queue.\n\n          // first reduce the size of the priority queue to account for\n          // the number of items we have already removed while executing\n          // this loop so far.\n          queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n          while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n            CacheEntry otherEntry = queue.pop();\n            newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n          }\n          if (queue.myMaxSize <= 0) break;\n\n          Object o = queue.myInsertWithOverflow(ce);\n          if (o != null) {\n            newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n          }\n        }\n      }\n\n      // Now delete everything in the priority queue.\n      // avoid using pop() since order doesn't matter anymore\n      for (CacheEntry<K,V> ce : queue.getValues()) {\n        if (ce==null) continue;\n        evictEntry(ce.key);\n        numRemoved++;\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n    }\n\n    oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n    this.oldestEntry = oldestEntry;\n  }\n\n","sourceOld":"  /*\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * </p>\n   * <p>The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.</p>\n   * Must be called after acquiring markAndSweepLock\n   */\n  private void markAndSweepByCacheSize() {\n    assert markAndSweepLock.isHeldByCurrentThread() : \"markAndSweepLock held by another thread\";\n    long oldestEntry = this.oldestEntry;\n    isCleaning = true;\n    this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n    long timeCurrent = stats.accessCounter.longValue();\n    int sz = stats.size.get();\n\n    int numRemoved = 0;\n    int numKept = 0;\n    long newestEntry = timeCurrent;\n    long newNewestEntry = -1;\n    long newOldestEntry = Long.MAX_VALUE;\n\n    int wantToKeep = lowerWaterMark;\n    int wantToRemove = sz - lowerWaterMark;\n\n    @SuppressWarnings(\"unchecked\") // generic array's are annoying\n    CacheEntry<K,V>[] eset = new CacheEntry[sz];\n    int eSize = 0;\n\n    // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n    // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n    for (CacheEntry<K,V> ce : map.values()) {\n      // set lastAccessedCopy to avoid more volatile reads\n      ce.lastAccessedCopy = ce.lastAccessed;\n      long thisEntry = ce.lastAccessedCopy;\n\n      // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n      if (thisEntry > newestEntry - wantToKeep) {\n        // this entry is guaranteed not to be in the bottom\n        // group, so do nothing.\n        numKept++;\n        newOldestEntry = Math.min(thisEntry, newOldestEntry);\n      } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n        // this entry is guaranteed to be in the bottom group\n        // so immediately remove it from the map.\n        evictEntry(ce.key);\n        numRemoved++;\n      } else {\n        // This entry *could* be in the bottom group.\n        // Collect these entries to avoid another full pass... this is wasted\n        // effort if enough entries are normally removed in this first pass.\n        // An alternate impl could make a full second pass.\n        if (eSize < eset.length-1) {\n          eset[eSize++] = ce;\n          newNewestEntry = Math.max(thisEntry, newNewestEntry);\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        }\n      }\n    }\n\n    // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n    // TODO: allow this to be customized in the constructor?\n    int numPasses=1; // maximum number of linear passes over the data\n\n    // if we didn't remove enough entries, then make more passes\n    // over the values we collected, with updated min and max values.\n    while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      newOldestEntry = Long.MAX_VALUE;\n      newestEntry = newNewestEntry;\n      newNewestEntry = -1;\n      wantToKeep = lowerWaterMark - numKept;\n      wantToRemove = sz - lowerWaterMark - numRemoved;\n\n      // iterate backward to make it easy to remove items.\n      for (int i=eSize-1; i>=0; i--) {\n        CacheEntry<K,V> ce = eset[i];\n        long thisEntry = ce.lastAccessedCopy;\n\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing but remove it from the eset.\n          numKept++;\n          // remove the entry by moving the last element to its position\n          eset[i] = eset[eSize-1];\n          eSize--;\n\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n\n          // remove the entry by moving the last element to its position\n          eset[i] = eset[eSize-1];\n          eSize--;\n        } else {\n          // This entry *could* be in the bottom group, so keep it in the eset,\n          // and update the stats.\n          newNewestEntry = Math.max(thisEntry, newNewestEntry);\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        }\n      }\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n    }\n\n\n    // if we still didn't remove enough entries, then make another pass while\n    // inserting into a priority queue\n    if (sz - numRemoved > acceptableWaterMark) {\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      newOldestEntry = Long.MAX_VALUE;\n      newestEntry = newNewestEntry;\n      newNewestEntry = -1;\n      wantToKeep = lowerWaterMark - numKept;\n      wantToRemove = sz - lowerWaterMark - numRemoved;\n\n      PQueue<K,V> queue = new PQueue<>(wantToRemove);\n\n      for (int i=eSize-1; i>=0; i--) {\n        CacheEntry<K,V> ce = eset[i];\n        long thisEntry = ce.lastAccessedCopy;\n\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing but remove it from the eset.\n          numKept++;\n          // removal not necessary on last pass.\n          // eset[i] = eset[eSize-1];\n          // eSize--;\n\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n\n        } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it.\n          evictEntry(ce.key);\n          numRemoved++;\n\n          // removal not necessary on last pass.\n          // eset[i] = eset[eSize-1];\n          // eSize--;\n        } else {\n          // This entry *could* be in the bottom group.\n          // add it to the priority queue\n\n          // everything in the priority queue will be removed, so keep track of\n          // the lowest value that ever comes back out of the queue.\n\n          // first reduce the size of the priority queue to account for\n          // the number of items we have already removed while executing\n          // this loop so far.\n          queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n          while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n            CacheEntry otherEntry = queue.pop();\n            newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n          }\n          if (queue.myMaxSize <= 0) break;\n\n          Object o = queue.myInsertWithOverflow(ce);\n          if (o != null) {\n            newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n          }\n        }\n      }\n\n      // Now delete everything in the priority queue.\n      // avoid using pop() since order doesn't matter anymore\n      for (CacheEntry<K,V> ce : queue.getValues()) {\n        if (ce==null) continue;\n        evictEntry(ce.key);\n        numRemoved++;\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n    }\n\n    oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n    this.oldestEntry = oldestEntry;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06a8891f085f71282bb3ece1b1732b68f07813a3","date":1591912889,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweepByCacheSize().mjava","pathOld":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweepByCacheSize().mjava","sourceNew":"  /*\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * </p>\n   * <p>The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.</p>\n   * Must be called after acquiring markAndSweepLock\n   */\n  private void markAndSweepByCacheSize() {\n    assert markAndSweepLock.isHeldByCurrentThread() : \"markAndSweepLock held by another thread\";\n    long oldestEntry = this.oldestEntry;\n    isCleaning = true;\n    this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n    long timeCurrent = stats.accessCounter.longValue();\n    int sz = stats.size.intValue();\n\n    int numRemoved = 0;\n    int numKept = 0;\n    long newestEntry = timeCurrent;\n    long newNewestEntry = -1;\n    long newOldestEntry = Long.MAX_VALUE;\n\n    int wantToKeep = lowerWaterMark;\n    int wantToRemove = sz - lowerWaterMark;\n\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    CacheEntry<K,V>[] eset = new CacheEntry[sz];\n    int eSize = 0;\n\n    // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n    // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n    for (CacheEntry<K,V> ce : map.values()) {\n      // set lastAccessedCopy to avoid more volatile reads\n      ce.lastAccessedCopy = ce.lastAccessed;\n      long thisEntry = ce.lastAccessedCopy;\n\n      // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n      if (thisEntry > newestEntry - wantToKeep) {\n        // this entry is guaranteed not to be in the bottom\n        // group, so do nothing.\n        numKept++;\n        newOldestEntry = Math.min(thisEntry, newOldestEntry);\n      } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n        // this entry is guaranteed to be in the bottom group\n        // so immediately remove it from the map.\n        evictEntry(ce.key);\n        numRemoved++;\n      } else {\n        // This entry *could* be in the bottom group.\n        // Collect these entries to avoid another full pass... this is wasted\n        // effort if enough entries are normally removed in this first pass.\n        // An alternate impl could make a full second pass.\n        if (eSize < eset.length-1) {\n          eset[eSize++] = ce;\n          newNewestEntry = Math.max(thisEntry, newNewestEntry);\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        }\n      }\n    }\n\n    // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n    // TODO: allow this to be customized in the constructor?\n    int numPasses=1; // maximum number of linear passes over the data\n\n    // if we didn't remove enough entries, then make more passes\n    // over the values we collected, with updated min and max values.\n    while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      newOldestEntry = Long.MAX_VALUE;\n      newestEntry = newNewestEntry;\n      newNewestEntry = -1;\n      wantToKeep = lowerWaterMark - numKept;\n      wantToRemove = sz - lowerWaterMark - numRemoved;\n\n      // iterate backward to make it easy to remove items.\n      for (int i=eSize-1; i>=0; i--) {\n        CacheEntry<K,V> ce = eset[i];\n        long thisEntry = ce.lastAccessedCopy;\n\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing but remove it from the eset.\n          numKept++;\n          // remove the entry by moving the last element to its position\n          eset[i] = eset[eSize-1];\n          eSize--;\n\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n\n          // remove the entry by moving the last element to its position\n          eset[i] = eset[eSize-1];\n          eSize--;\n        } else {\n          // This entry *could* be in the bottom group, so keep it in the eset,\n          // and update the stats.\n          newNewestEntry = Math.max(thisEntry, newNewestEntry);\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        }\n      }\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n    }\n\n\n    // if we still didn't remove enough entries, then make another pass while\n    // inserting into a priority queue\n    if (sz - numRemoved > acceptableWaterMark) {\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      newOldestEntry = Long.MAX_VALUE;\n      newestEntry = newNewestEntry;\n      newNewestEntry = -1;\n      wantToKeep = lowerWaterMark - numKept;\n      wantToRemove = sz - lowerWaterMark - numRemoved;\n\n      PQueue<K,V> queue = new PQueue<>(wantToRemove);\n\n      for (int i=eSize-1; i>=0; i--) {\n        CacheEntry<K,V> ce = eset[i];\n        long thisEntry = ce.lastAccessedCopy;\n\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing but remove it from the eset.\n          numKept++;\n          // removal not necessary on last pass.\n          // eset[i] = eset[eSize-1];\n          // eSize--;\n\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n\n        } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it.\n          evictEntry(ce.key);\n          numRemoved++;\n\n          // removal not necessary on last pass.\n          // eset[i] = eset[eSize-1];\n          // eSize--;\n        } else {\n          // This entry *could* be in the bottom group.\n          // add it to the priority queue\n\n          // everything in the priority queue will be removed, so keep track of\n          // the lowest value that ever comes back out of the queue.\n\n          // first reduce the size of the priority queue to account for\n          // the number of items we have already removed while executing\n          // this loop so far.\n          queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n          while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n            @SuppressWarnings({\"rawtypes\"})\n            CacheEntry otherEntry = queue.pop();\n            newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n          }\n          if (queue.myMaxSize <= 0) break;\n\n          Object o = queue.myInsertWithOverflow(ce);\n          if (o != null) {\n            newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n          }\n        }\n      }\n\n      // Now delete everything in the priority queue.\n      // avoid using pop() since order doesn't matter anymore\n      for (CacheEntry<K,V> ce : queue.getValues()) {\n        if (ce==null) continue;\n        evictEntry(ce.key);\n        numRemoved++;\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n    }\n\n    oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n    this.oldestEntry = oldestEntry;\n  }\n\n","sourceOld":"  /*\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * </p>\n   * <p>The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.</p>\n   * Must be called after acquiring markAndSweepLock\n   */\n  private void markAndSweepByCacheSize() {\n    assert markAndSweepLock.isHeldByCurrentThread() : \"markAndSweepLock held by another thread\";\n    long oldestEntry = this.oldestEntry;\n    isCleaning = true;\n    this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n    long timeCurrent = stats.accessCounter.longValue();\n    int sz = stats.size.intValue();\n\n    int numRemoved = 0;\n    int numKept = 0;\n    long newestEntry = timeCurrent;\n    long newNewestEntry = -1;\n    long newOldestEntry = Long.MAX_VALUE;\n\n    int wantToKeep = lowerWaterMark;\n    int wantToRemove = sz - lowerWaterMark;\n\n    @SuppressWarnings(\"unchecked\") // generic array's are annoying\n    CacheEntry<K,V>[] eset = new CacheEntry[sz];\n    int eSize = 0;\n\n    // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n    // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n    for (CacheEntry<K,V> ce : map.values()) {\n      // set lastAccessedCopy to avoid more volatile reads\n      ce.lastAccessedCopy = ce.lastAccessed;\n      long thisEntry = ce.lastAccessedCopy;\n\n      // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n      if (thisEntry > newestEntry - wantToKeep) {\n        // this entry is guaranteed not to be in the bottom\n        // group, so do nothing.\n        numKept++;\n        newOldestEntry = Math.min(thisEntry, newOldestEntry);\n      } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n        // this entry is guaranteed to be in the bottom group\n        // so immediately remove it from the map.\n        evictEntry(ce.key);\n        numRemoved++;\n      } else {\n        // This entry *could* be in the bottom group.\n        // Collect these entries to avoid another full pass... this is wasted\n        // effort if enough entries are normally removed in this first pass.\n        // An alternate impl could make a full second pass.\n        if (eSize < eset.length-1) {\n          eset[eSize++] = ce;\n          newNewestEntry = Math.max(thisEntry, newNewestEntry);\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        }\n      }\n    }\n\n    // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n    // TODO: allow this to be customized in the constructor?\n    int numPasses=1; // maximum number of linear passes over the data\n\n    // if we didn't remove enough entries, then make more passes\n    // over the values we collected, with updated min and max values.\n    while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      newOldestEntry = Long.MAX_VALUE;\n      newestEntry = newNewestEntry;\n      newNewestEntry = -1;\n      wantToKeep = lowerWaterMark - numKept;\n      wantToRemove = sz - lowerWaterMark - numRemoved;\n\n      // iterate backward to make it easy to remove items.\n      for (int i=eSize-1; i>=0; i--) {\n        CacheEntry<K,V> ce = eset[i];\n        long thisEntry = ce.lastAccessedCopy;\n\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing but remove it from the eset.\n          numKept++;\n          // remove the entry by moving the last element to its position\n          eset[i] = eset[eSize-1];\n          eSize--;\n\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n\n          // remove the entry by moving the last element to its position\n          eset[i] = eset[eSize-1];\n          eSize--;\n        } else {\n          // This entry *could* be in the bottom group, so keep it in the eset,\n          // and update the stats.\n          newNewestEntry = Math.max(thisEntry, newNewestEntry);\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        }\n      }\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n    }\n\n\n    // if we still didn't remove enough entries, then make another pass while\n    // inserting into a priority queue\n    if (sz - numRemoved > acceptableWaterMark) {\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      newOldestEntry = Long.MAX_VALUE;\n      newestEntry = newNewestEntry;\n      newNewestEntry = -1;\n      wantToKeep = lowerWaterMark - numKept;\n      wantToRemove = sz - lowerWaterMark - numRemoved;\n\n      PQueue<K,V> queue = new PQueue<>(wantToRemove);\n\n      for (int i=eSize-1; i>=0; i--) {\n        CacheEntry<K,V> ce = eset[i];\n        long thisEntry = ce.lastAccessedCopy;\n\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing but remove it from the eset.\n          numKept++;\n          // removal not necessary on last pass.\n          // eset[i] = eset[eSize-1];\n          // eSize--;\n\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n\n        } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it.\n          evictEntry(ce.key);\n          numRemoved++;\n\n          // removal not necessary on last pass.\n          // eset[i] = eset[eSize-1];\n          // eSize--;\n        } else {\n          // This entry *could* be in the bottom group.\n          // add it to the priority queue\n\n          // everything in the priority queue will be removed, so keep track of\n          // the lowest value that ever comes back out of the queue.\n\n          // first reduce the size of the priority queue to account for\n          // the number of items we have already removed while executing\n          // this loop so far.\n          queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n          while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n            CacheEntry otherEntry = queue.pop();\n            newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n          }\n          if (queue.myMaxSize <= 0) break;\n\n          Object o = queue.myInsertWithOverflow(ce);\n          if (o != null) {\n            newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n          }\n        }\n      }\n\n      // Now delete everything in the priority queue.\n      // avoid using pop() since order doesn't matter anymore\n      for (CacheEntry<K,V> ce : queue.getValues()) {\n        if (ce==null) continue;\n        evictEntry(ce.key);\n        numRemoved++;\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n    }\n\n    oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n    this.oldestEntry = oldestEntry;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"21019aa828c8c9b0153877543a8b3f200bf2ca19":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7c5044c9bb1518e7a13c1c5385a21325ae343056"],"fbd58791ecf2b92d8917c2f4aab0e50965ec6a83":["7c5044c9bb1518e7a13c1c5385a21325ae343056"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"06a8891f085f71282bb3ece1b1732b68f07813a3":["87f0484c38f986062889ed50f3bf3bd462848c26"],"87f0484c38f986062889ed50f3bf3bd462848c26":["fbd58791ecf2b92d8917c2f4aab0e50965ec6a83"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["06a8891f085f71282bb3ece1b1732b68f07813a3"],"7c5044c9bb1518e7a13c1c5385a21325ae343056":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b0b597c65628ca9e73913a07e81691f8229bae35":["fbd58791ecf2b92d8917c2f4aab0e50965ec6a83","87f0484c38f986062889ed50f3bf3bd462848c26"]},"commit2Childs":{"21019aa828c8c9b0153877543a8b3f200bf2ca19":[],"fbd58791ecf2b92d8917c2f4aab0e50965ec6a83":["87f0484c38f986062889ed50f3bf3bd462848c26","b0b597c65628ca9e73913a07e81691f8229bae35"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["21019aa828c8c9b0153877543a8b3f200bf2ca19","7c5044c9bb1518e7a13c1c5385a21325ae343056"],"06a8891f085f71282bb3ece1b1732b68f07813a3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"87f0484c38f986062889ed50f3bf3bd462848c26":["06a8891f085f71282bb3ece1b1732b68f07813a3","b0b597c65628ca9e73913a07e81691f8229bae35"],"7c5044c9bb1518e7a13c1c5385a21325ae343056":["21019aa828c8c9b0153877543a8b3f200bf2ca19","fbd58791ecf2b92d8917c2f4aab0e50965ec6a83"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["21019aa828c8c9b0153877543a8b3f200bf2ca19","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}