{"path":"solr/core/src/java/org/apache/solr/cluster/placement/plugins/SamplePluginAffinityReplicaPlacement#makePlacementDecisions(SolrCollection,String,ImmutableSet[String],Replica.ReplicaType,int,AttributeValues,EnumMap[Replica.ReplicaType,Set[Node]],Map[Node,Integer],PlacementPlanFactory,Set[ReplicaPlacement]).mjava","commits":[{"id":"f5d9700b23e8e9b11b845fcecef89dbdf21373d9","date":1600294231,"type":0,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cluster/placement/plugins/SamplePluginAffinityReplicaPlacement#makePlacementDecisions(SolrCollection,String,ImmutableSet[String],Replica.ReplicaType,int,AttributeValues,EnumMap[Replica.ReplicaType,Set[Node]],Map[Node,Integer],PlacementPlanFactory,Set[ReplicaPlacement]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * <p>Picks nodes from {@code targetNodes} for placing {@code numReplicas} replicas.\n   *\n   * <p>The criteria used in this method are, in this order:\n   * <ol>\n   *     <li>No more than one replica of a given shard on a given node (strictly enforced)</li>\n   *     <li>Balance as much as possible the number of replicas of the given {@link org.apache.solr.cluster.Replica.ReplicaType} over available AZ's.\n   *     This balancing takes into account existing replicas <b>of the corresponding replica type</b>, if any.</li>\n   *     <li>Place replicas is possible on nodes having more than a certain amount of free disk space (note that nodes with a too small\n   *     amount of free disk space were eliminated as placement targets earlier, in {@link #getNodesPerReplicaType}). There's\n   *     a threshold here rather than sorting on the amount of free disk space, because sorting on that value would in\n   *     practice lead to never considering the number of cores on a node.</li>\n   *     <li>Place replicas on nodes having a smaller number of cores (the number of cores considered\n   *     for this decision includes decisions made during the processing of the placement request)</li>\n   * </ol>\n   */\n  @SuppressForbidden(reason = \"Ordering.arbitrary() has no equivalent in Comparator class. Rather reuse than copy.\")\n  private void makePlacementDecisions(SolrCollection solrCollection, String shardName, ImmutableSet<String> availabilityZones,\n                                      Replica.ReplicaType replicaType, int numReplicas, final AttributeValues attrValues,\n                                      EnumMap<Replica.ReplicaType, Set<Node>> replicaTypeToNodes, Map<Node, Integer> coresOnNodes,\n                                      PlacementPlanFactory placementPlanFactory, Set<ReplicaPlacement> replicaPlacements) throws PlacementException {\n    // Build the set of candidate nodes, i.e. nodes not having (yet) a replica of the given shard\n    Set<Node> candidateNodes = new HashSet<>(replicaTypeToNodes.get(replicaType));\n\n    // Count existing replicas per AZ. We count only instances the type of replica for which we need to do placement. This\n    // can be changed in the loop below if we want to count all replicas for the shard.\n    Map<String, Integer> azToNumReplicas = Maps.newHashMap();\n    // Add all \"interesting\" AZ's, i.e. AZ's for which there's a chance we can do placement.\n    for (String az : availabilityZones) {\n      azToNumReplicas.put(az, 0);\n    }\n\n    Shard shard = solrCollection.getShard(shardName);\n    if (shard != null) {\n      // shard is non null if we're adding replicas to an already existing collection.\n      // If we're creating the collection, the shards do not exist yet.\n      for (Replica replica : shard.replicas()) {\n        // Nodes already having any type of replica for the shard can't get another replica.\n        candidateNodes.remove(replica.getNode());\n        // The node's AZ has to be counted as having a replica if it has a replica of the same type as the one we need\n        // to place here (remove the \"if\" below to balance the number of replicas per AZ across all replica types rather\n        // than within each replica type, but then there's a risk that all NRT replicas for example end up on the same AZ).\n        // Note that if in the cluster nodes are configured to accept a single replica type and not multiple ones, the\n        // two options are equivalent (governed by system property AVAILABILITY_ZONE_SYSPROP on each node)\n        if (replica.getType() == replicaType) {\n          final String az = getNodeAZ(replica.getNode(), attrValues);\n          if (azToNumReplicas.containsKey(az)) {\n            // We do not count replicas on AZ's for which we don't have any node to place on because it would not help\n            // the placement decision. If we did want to do that, note the dereferencing below can't be assumed as the\n            // entry will not exist in the map.\n            azToNumReplicas.put(az, azToNumReplicas.get(az) + 1);\n          }\n        }\n      }\n    }\n\n    // We now have the set of real candidate nodes, we've enforced \"No more than one replica of a given shard on a given node\".\n    // We also counted for the shard and replica type under consideration how many replicas were per AZ, so we can place\n    // (or try to place) replicas on AZ's that have fewer replicas\n\n    // Get the candidate nodes per AZ in order to build (further down) a mapping of AZ to placement candidates.\n    Map<String, List<Node>> nodesPerAz = Maps.newHashMap();\n    for (Node node : candidateNodes) {\n      String nodeAz = getNodeAZ(node, attrValues);\n      List<Node> nodesForAz = nodesPerAz.computeIfAbsent(nodeAz, k -> new ArrayList<>());\n      nodesForAz.add(node);\n    }\n\n    // Build a treeMap sorted by the number of replicas per AZ and including candidates nodes suitable for placement on the\n    // AZ, so we can easily select the next AZ to get a replica assignment and quickly (constant time) decide if placement\n    // on this AZ is possible or not.\n    TreeMultimap<Integer, AzWithNodes> azByExistingReplicas = TreeMultimap.create(Comparator.naturalOrder(), Ordering.arbitrary());\n    for (Map.Entry<String, List<Node>> e : nodesPerAz.entrySet()) {\n      azByExistingReplicas.put(azToNumReplicas.get(e.getKey()), new AzWithNodes(e.getKey(), e.getValue()));\n    }\n\n    CoresAndDiskComparator coresAndDiskComparator = new CoresAndDiskComparator(attrValues, coresOnNodes, deprioritizedFreeDiskGB);\n\n    // Now we have for each AZ on which we might have a chance of placing a replica, the list of candidate nodes for replicas\n    // (candidate: does not already have a replica of this shard and is in the corresponding AZ).\n    // We must now select those of the nodes on which we actually place the replicas, and will do that based on the total\n    // number of cores already present on these nodes as well as the free disk space.\n    // We sort once by the order related to number of cores and disk space each list of nodes on an AZ. We do not sort all\n    // of them ahead of time because we might be placing a small number of replicas and it might be wasted work.\n    for (int i = 0; i < numReplicas; i++) {\n      // Pick the AZ having the lowest number of replicas for this shard, and if that AZ has available nodes, pick the\n      // most appropriate one (based on number of cores and disk space constraints). In the process, remove entries (AZ's)\n      // that do not have nodes to place replicas on because these are useless to us.\n      Map.Entry<Integer, AzWithNodes> azWithNodesEntry = null;\n      for (Iterator<Map.Entry<Integer, AzWithNodes>> it = azByExistingReplicas.entries().iterator(); it.hasNext(); ) {\n        Map.Entry<Integer, AzWithNodes> entry = it.next();\n        if (!entry.getValue().availableNodesForPlacement.isEmpty()) {\n          azWithNodesEntry = entry;\n          // Remove this entry. Will add it back after a node has been removed from the list of available nodes and the number\n          // of replicas on the AZ has been increased by one (search for \"azByExistingReplicas.put\" below).\n          it.remove();\n          break;\n        } else {\n          it.remove();\n        }\n      }\n\n      if (azWithNodesEntry == null) {\n        // This can happen because not enough nodes for the placement request or already too many nodes with replicas of\n        // the shard that can't accept new replicas or not enough nodes with enough free disk space.\n        throw new PlacementException(\"Not enough nodes to place \" + numReplicas + \" replica(s) of type \" + replicaType +\n                \" for shard \" + shardName + \" of collection \" + solrCollection.getName());\n      }\n\n      AzWithNodes azWithNodes = azWithNodesEntry.getValue();\n      List<Node> nodes = azWithNodes.availableNodesForPlacement;\n\n      if (!azWithNodes.hasBeenSorted) {\n        // Make sure we do not tend to use always the same nodes (within an AZ) if all conditions are identical (well, this\n        // likely is not the case since after having added a replica to a node its number of cores increases for the next\n        // placement decision, but let's be defensive here, given that multiple concurrent placement decisions might see\n        // the same initial cluster state, and we want placement to be reasonable even in that case without creating an\n        // unnecessary imbalance).\n        // For example, if all nodes have 0 cores and same amount of free disk space, ideally we want to pick a random node\n        // for placement, not always the same one due to some internal ordering.\n        Collections.shuffle(nodes, new Random());\n\n        // Sort by increasing number of cores but pushing nodes with low free disk space to the end of the list\n        nodes.sort(coresAndDiskComparator);\n\n        azWithNodes.hasBeenSorted = true;\n      }\n\n      Node assignTarget = nodes.remove(0);\n\n      // Insert back a corrected entry for the AZ: one more replica living there and one less node that can accept new replicas\n      // (the remaining candidate node list might be empty, in which case it will be cleaned up on the next iteration).\n      azByExistingReplicas.put(azWithNodesEntry.getKey() + 1, azWithNodes);\n\n      // Track that the node has one more core. These values are only used during the current run of the plugin.\n      coresOnNodes.merge(assignTarget, 1, Integer::sum);\n\n      // Register the replica assignment just decided\n      replicaPlacements.add(placementPlanFactory.createReplicaPlacement(solrCollection, shardName, assignTarget, replicaType));\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"65352f844eb9e9a677ec4eb2abced4404f08181d","date":1600297608,"type":0,"author":"noblepaul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cluster/placement/plugins/SamplePluginAffinityReplicaPlacement#makePlacementDecisions(SolrCollection,String,ImmutableSet[String],Replica.ReplicaType,int,AttributeValues,EnumMap[Replica.ReplicaType,Set[Node]],Map[Node,Integer],PlacementPlanFactory,Set[ReplicaPlacement]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * <p>Picks nodes from {@code targetNodes} for placing {@code numReplicas} replicas.\n   *\n   * <p>The criteria used in this method are, in this order:\n   * <ol>\n   *     <li>No more than one replica of a given shard on a given node (strictly enforced)</li>\n   *     <li>Balance as much as possible the number of replicas of the given {@link org.apache.solr.cluster.Replica.ReplicaType} over available AZ's.\n   *     This balancing takes into account existing replicas <b>of the corresponding replica type</b>, if any.</li>\n   *     <li>Place replicas is possible on nodes having more than a certain amount of free disk space (note that nodes with a too small\n   *     amount of free disk space were eliminated as placement targets earlier, in {@link #getNodesPerReplicaType}). There's\n   *     a threshold here rather than sorting on the amount of free disk space, because sorting on that value would in\n   *     practice lead to never considering the number of cores on a node.</li>\n   *     <li>Place replicas on nodes having a smaller number of cores (the number of cores considered\n   *     for this decision includes decisions made during the processing of the placement request)</li>\n   * </ol>\n   */\n  @SuppressForbidden(reason = \"Ordering.arbitrary() has no equivalent in Comparator class. Rather reuse than copy.\")\n  private void makePlacementDecisions(SolrCollection solrCollection, String shardName, ImmutableSet<String> availabilityZones,\n                                      Replica.ReplicaType replicaType, int numReplicas, final AttributeValues attrValues,\n                                      EnumMap<Replica.ReplicaType, Set<Node>> replicaTypeToNodes, Map<Node, Integer> coresOnNodes,\n                                      PlacementPlanFactory placementPlanFactory, Set<ReplicaPlacement> replicaPlacements) throws PlacementException {\n    // Build the set of candidate nodes, i.e. nodes not having (yet) a replica of the given shard\n    Set<Node> candidateNodes = new HashSet<>(replicaTypeToNodes.get(replicaType));\n\n    // Count existing replicas per AZ. We count only instances the type of replica for which we need to do placement. This\n    // can be changed in the loop below if we want to count all replicas for the shard.\n    Map<String, Integer> azToNumReplicas = Maps.newHashMap();\n    // Add all \"interesting\" AZ's, i.e. AZ's for which there's a chance we can do placement.\n    for (String az : availabilityZones) {\n      azToNumReplicas.put(az, 0);\n    }\n\n    Shard shard = solrCollection.getShard(shardName);\n    if (shard != null) {\n      // shard is non null if we're adding replicas to an already existing collection.\n      // If we're creating the collection, the shards do not exist yet.\n      for (Replica replica : shard.replicas()) {\n        // Nodes already having any type of replica for the shard can't get another replica.\n        candidateNodes.remove(replica.getNode());\n        // The node's AZ has to be counted as having a replica if it has a replica of the same type as the one we need\n        // to place here (remove the \"if\" below to balance the number of replicas per AZ across all replica types rather\n        // than within each replica type, but then there's a risk that all NRT replicas for example end up on the same AZ).\n        // Note that if in the cluster nodes are configured to accept a single replica type and not multiple ones, the\n        // two options are equivalent (governed by system property AVAILABILITY_ZONE_SYSPROP on each node)\n        if (replica.getType() == replicaType) {\n          final String az = getNodeAZ(replica.getNode(), attrValues);\n          if (azToNumReplicas.containsKey(az)) {\n            // We do not count replicas on AZ's for which we don't have any node to place on because it would not help\n            // the placement decision. If we did want to do that, note the dereferencing below can't be assumed as the\n            // entry will not exist in the map.\n            azToNumReplicas.put(az, azToNumReplicas.get(az) + 1);\n          }\n        }\n      }\n    }\n\n    // We now have the set of real candidate nodes, we've enforced \"No more than one replica of a given shard on a given node\".\n    // We also counted for the shard and replica type under consideration how many replicas were per AZ, so we can place\n    // (or try to place) replicas on AZ's that have fewer replicas\n\n    // Get the candidate nodes per AZ in order to build (further down) a mapping of AZ to placement candidates.\n    Map<String, List<Node>> nodesPerAz = Maps.newHashMap();\n    for (Node node : candidateNodes) {\n      String nodeAz = getNodeAZ(node, attrValues);\n      List<Node> nodesForAz = nodesPerAz.computeIfAbsent(nodeAz, k -> new ArrayList<>());\n      nodesForAz.add(node);\n    }\n\n    // Build a treeMap sorted by the number of replicas per AZ and including candidates nodes suitable for placement on the\n    // AZ, so we can easily select the next AZ to get a replica assignment and quickly (constant time) decide if placement\n    // on this AZ is possible or not.\n    TreeMultimap<Integer, AzWithNodes> azByExistingReplicas = TreeMultimap.create(Comparator.naturalOrder(), Ordering.arbitrary());\n    for (Map.Entry<String, List<Node>> e : nodesPerAz.entrySet()) {\n      azByExistingReplicas.put(azToNumReplicas.get(e.getKey()), new AzWithNodes(e.getKey(), e.getValue()));\n    }\n\n    CoresAndDiskComparator coresAndDiskComparator = new CoresAndDiskComparator(attrValues, coresOnNodes, deprioritizedFreeDiskGB);\n\n    // Now we have for each AZ on which we might have a chance of placing a replica, the list of candidate nodes for replicas\n    // (candidate: does not already have a replica of this shard and is in the corresponding AZ).\n    // We must now select those of the nodes on which we actually place the replicas, and will do that based on the total\n    // number of cores already present on these nodes as well as the free disk space.\n    // We sort once by the order related to number of cores and disk space each list of nodes on an AZ. We do not sort all\n    // of them ahead of time because we might be placing a small number of replicas and it might be wasted work.\n    for (int i = 0; i < numReplicas; i++) {\n      // Pick the AZ having the lowest number of replicas for this shard, and if that AZ has available nodes, pick the\n      // most appropriate one (based on number of cores and disk space constraints). In the process, remove entries (AZ's)\n      // that do not have nodes to place replicas on because these are useless to us.\n      Map.Entry<Integer, AzWithNodes> azWithNodesEntry = null;\n      for (Iterator<Map.Entry<Integer, AzWithNodes>> it = azByExistingReplicas.entries().iterator(); it.hasNext(); ) {\n        Map.Entry<Integer, AzWithNodes> entry = it.next();\n        if (!entry.getValue().availableNodesForPlacement.isEmpty()) {\n          azWithNodesEntry = entry;\n          // Remove this entry. Will add it back after a node has been removed from the list of available nodes and the number\n          // of replicas on the AZ has been increased by one (search for \"azByExistingReplicas.put\" below).\n          it.remove();\n          break;\n        } else {\n          it.remove();\n        }\n      }\n\n      if (azWithNodesEntry == null) {\n        // This can happen because not enough nodes for the placement request or already too many nodes with replicas of\n        // the shard that can't accept new replicas or not enough nodes with enough free disk space.\n        throw new PlacementException(\"Not enough nodes to place \" + numReplicas + \" replica(s) of type \" + replicaType +\n                \" for shard \" + shardName + \" of collection \" + solrCollection.getName());\n      }\n\n      AzWithNodes azWithNodes = azWithNodesEntry.getValue();\n      List<Node> nodes = azWithNodes.availableNodesForPlacement;\n\n      if (!azWithNodes.hasBeenSorted) {\n        // Make sure we do not tend to use always the same nodes (within an AZ) if all conditions are identical (well, this\n        // likely is not the case since after having added a replica to a node its number of cores increases for the next\n        // placement decision, but let's be defensive here, given that multiple concurrent placement decisions might see\n        // the same initial cluster state, and we want placement to be reasonable even in that case without creating an\n        // unnecessary imbalance).\n        // For example, if all nodes have 0 cores and same amount of free disk space, ideally we want to pick a random node\n        // for placement, not always the same one due to some internal ordering.\n        Collections.shuffle(nodes, new Random());\n\n        // Sort by increasing number of cores but pushing nodes with low free disk space to the end of the list\n        nodes.sort(coresAndDiskComparator);\n\n        azWithNodes.hasBeenSorted = true;\n      }\n\n      Node assignTarget = nodes.remove(0);\n\n      // Insert back a corrected entry for the AZ: one more replica living there and one less node that can accept new replicas\n      // (the remaining candidate node list might be empty, in which case it will be cleaned up on the next iteration).\n      azByExistingReplicas.put(azWithNodesEntry.getKey() + 1, azWithNodes);\n\n      // Track that the node has one more core. These values are only used during the current run of the plugin.\n      coresOnNodes.merge(assignTarget, 1, Integer::sum);\n\n      // Register the replica assignment just decided\n      replicaPlacements.add(placementPlanFactory.createReplicaPlacement(solrCollection, shardName, assignTarget, replicaType));\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f5d9700b23e8e9b11b845fcecef89dbdf21373d9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"65352f844eb9e9a677ec4eb2abced4404f08181d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f5d9700b23e8e9b11b845fcecef89dbdf21373d9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["65352f844eb9e9a677ec4eb2abced4404f08181d"]},"commit2Childs":{"f5d9700b23e8e9b11b845fcecef89dbdf21373d9":["65352f844eb9e9a677ec4eb2abced4404f08181d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f5d9700b23e8e9b11b845fcecef89dbdf21373d9","65352f844eb9e9a677ec4eb2abced4404f08181d"],"65352f844eb9e9a677ec4eb2abced4404f08181d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}