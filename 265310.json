{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(Vector).mjava","commits":[{"id":"116824c1b3f14f43f9a77914fbf6f0d70a5b7c89","date":1461609218,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(Vector).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public boolean isWithin(final Vector thePoint) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(thePoint)) {\n      return testPointInSet;\n    }\n    \n    // Choose our navigation route!\n    final double xDelta = Math.abs(thePoint.x - testPoint.x);\n    final double yDelta = Math.abs(thePoint.y - testPoint.y);\n    final double zDelta = Math.abs(thePoint.z - testPoint.z);\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointXZPlane.evaluateIsZero(thePoint)) {\n      // Use the XZ plane exclusively.\n      final SidedPlane testPointCutoff =  new SidedPlane(thePoint, testPointXZPlane, testPoint);\n      final SidedPlane checkPointCutoff = new SidedPlane(testPoint, testPointXZPlane, thePoint);\n      final CrossingEdgeIterator crossingEdgeIterator = new CrossingEdgeIterator(testPointXZPlane, testPointCutoff, checkPointCutoff, thePoint);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointYZPlane.evaluateIsZero(thePoint)) {\n      // Use the YZ plane exclusively.\n      final SidedPlane testPointCutoff =  new SidedPlane(thePoint, testPointYZPlane, testPoint);\n      final SidedPlane checkPointCutoff = new SidedPlane(testPoint, testPointYZPlane, thePoint);\n      final CrossingEdgeIterator crossingEdgeIterator = new CrossingEdgeIterator(testPointYZPlane, testPointCutoff, checkPointCutoff, thePoint);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointXYPlane.evaluateIsZero(thePoint)) {\n      // Use the XY plane exclusively.\n      final SidedPlane testPointCutoff =  new SidedPlane(thePoint, testPointXYPlane, testPoint);\n      final SidedPlane checkPointCutoff = new SidedPlane(testPoint, testPointXYPlane, thePoint);\n      final CrossingEdgeIterator crossingEdgeIterator = new CrossingEdgeIterator(testPointXYPlane, testPointCutoff, checkPointCutoff, thePoint);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // We need to use two planes to get there.  We can use any two planes, and order doesn't matter.\n      // The best to pick are the ones with the shortest overall distance.\n      if (xDelta + yDelta <= xDelta + zDelta && xDelta + yDelta <= yDelta + zDelta) {\n        // Travel in X and Y\n        // We'll do this using the testPointYZPlane, and create a travel plane for the right XZ plane.\n        final Plane travelPlane = new Plane(0.0, 1.0, 0.0, -thePoint.y);\n        // We need cutoff planes for both legs.\n        final SidedPlane testPointCutoffPlane = new SidedPlane(thePoint, testPointYZPlane, testPoint);\n        final SidedPlane checkPointCutoffPlane = new SidedPlane(testPoint, travelPlane, thePoint);\n        // Now, find the intersection of the check and test point planes.\n        final GeoPoint[] intersectionPoints = travelPlane.findIntersections(planetModel, testPointYZPlane, testPointCutoffPlane, checkPointCutoffPlane);\n        assert intersectionPoints != null : \"couldn't find any intersections\";\n        assert intersectionPoints.length != 1 : \"wrong number of intersection points\";\n        final SidedPlane testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointYZPlane, intersectionPoints[0]);\n        final SidedPlane checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoints[0]);\n        // Note: we need to handle the cases where end point of the leg sits on an edge!\n        // MHL\n        final CrossingEdgeIterator testPointEdgeIterator = new CrossingEdgeIterator(testPointYZPlane, testPointCutoffPlane, testPointOtherCutoffPlane, null);\n        xTree.traverse(testPointEdgeIterator, testPoint.x, testPoint.x);\n        final CrossingEdgeIterator checkPointEdgeIterator = new CrossingEdgeIterator(travelPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thePoint);\n        if (!yTree.traverse(checkPointEdgeIterator, thePoint.y, thePoint.y)) {\n          // Endpoint is on edge\n          return true;\n        }\n        return (((testPointEdgeIterator.crossingCount + checkPointEdgeIterator.crossingCount) & 1) == 0)?testPointInSet:!testPointInSet;\n      } else if (xDelta + zDelta <= xDelta + yDelta && xDelta + zDelta <= zDelta + yDelta) {\n        // Travel in X and Z\n        // We'll do this using the testPointXYPlane, and create a travel plane for the right YZ plane.\n        final Plane travelPlane = new Plane(1.0, 0.0, 0.0, -thePoint.x);\n        // We need cutoff planes for both legs.\n        final SidedPlane testPointCutoffPlane = new SidedPlane(thePoint, testPointXYPlane, testPoint);\n        final SidedPlane checkPointCutoffPlane = new SidedPlane(testPoint, travelPlane, thePoint);\n        // Now, find the intersection of the check and test point planes.\n        final GeoPoint[] intersectionPoints = travelPlane.findIntersections(planetModel, testPointXYPlane, testPointCutoffPlane, checkPointCutoffPlane);\n        assert intersectionPoints != null : \"couldn't find any intersections\";\n        assert intersectionPoints.length != 1 : \"wrong number of intersection points\";\n        final SidedPlane testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointXYPlane, intersectionPoints[0]);\n        final SidedPlane checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoints[0]);\n        // Note: we need to handle the cases where end point of the leg sits on an edge!\n        // MHL\n        final CrossingEdgeIterator testPointEdgeIterator = new CrossingEdgeIterator(testPointXYPlane, testPointCutoffPlane, testPointOtherCutoffPlane, null);\n        zTree.traverse(testPointEdgeIterator, testPoint.z, testPoint.z);\n        final CrossingEdgeIterator checkPointEdgeIterator = new CrossingEdgeIterator(travelPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thePoint);\n        if (!xTree.traverse(checkPointEdgeIterator, thePoint.x, thePoint.x)) {\n          // Endpoint is on edge\n          return true;\n        }\n        return (((testPointEdgeIterator.crossingCount + checkPointEdgeIterator.crossingCount) & 1) == 0)?testPointInSet:!testPointInSet;\n      } else if (yDelta + zDelta <= xDelta + yDelta && yDelta + zDelta <= xDelta + zDelta) {\n        // Travel in Y and Z\n        // We'll do this using the testPointXZPlane, and create a travel plane for the right XY plane.\n        final Plane travelPlane = new Plane(0.0, 0.0, 1.0, -thePoint.z);\n        // We need cutoff planes for both legs.\n        final SidedPlane testPointCutoffPlane = new SidedPlane(thePoint, testPointXZPlane, testPoint);\n        final SidedPlane checkPointCutoffPlane = new SidedPlane(testPoint, travelPlane, thePoint);\n        // Now, find the intersection of the check and test point planes.\n        final GeoPoint[] intersectionPoints = travelPlane.findIntersections(planetModel, testPointXZPlane, testPointCutoffPlane, checkPointCutoffPlane);\n        assert intersectionPoints != null : \"couldn't find any intersections\";\n        assert intersectionPoints.length != 1 : \"wrong number of intersection points\";\n        final SidedPlane testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointXZPlane, intersectionPoints[0]);\n        final SidedPlane checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoints[0]);\n        // Note: we need to handle the cases where end point of the first leg sits on an edge!\n        // MHL\n        final CrossingEdgeIterator testPointEdgeIterator = new CrossingEdgeIterator(testPointXZPlane, testPointCutoffPlane, testPointOtherCutoffPlane, null);\n        yTree.traverse(testPointEdgeIterator, testPoint.y, testPoint.y);\n        final CrossingEdgeIterator checkPointEdgeIterator = new CrossingEdgeIterator(travelPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thePoint);\n        if (!zTree.traverse(checkPointEdgeIterator, thePoint.z, thePoint.z)) {\n          // Endpoint is on edge\n          return true;\n        }\n        return (((testPointEdgeIterator.crossingCount + checkPointEdgeIterator.crossingCount) & 1) == 0)?testPointInSet:!testPointInSet;\n      }\n    }\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e6f1382358fb94a408ebd8bbb00135f2a83f4d66","date":1461613845,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(Vector).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(Vector).mjava","sourceNew":"  @Override\n  public boolean isWithin(final Vector thePoint) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(thePoint)) {\n      return testPointInSet;\n    }\n    \n    // Choose our navigation route!\n    final double xDelta = Math.abs(thePoint.x - testPoint.x);\n    final double yDelta = Math.abs(thePoint.y - testPoint.y);\n    final double zDelta = Math.abs(thePoint.z - testPoint.z);\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointXZPlane.evaluateIsZero(thePoint)) {\n      // Use the XZ plane exclusively.\n      final SidedPlane testPointCutoff =  new SidedPlane(thePoint, testPointXZPlane, testPoint);\n      final SidedPlane checkPointCutoff = new SidedPlane(testPoint, testPointXZPlane, thePoint);\n      final CrossingEdgeIterator crossingEdgeIterator = new CrossingEdgeIterator(testPointXZPlane, testPointXZAbovePlane, testPointXZBelowPlane, testPointCutoff, checkPointCutoff, thePoint);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointYZPlane.evaluateIsZero(thePoint)) {\n      // Use the YZ plane exclusively.\n      final SidedPlane testPointCutoff =  new SidedPlane(thePoint, testPointYZPlane, testPoint);\n      final SidedPlane checkPointCutoff = new SidedPlane(testPoint, testPointYZPlane, thePoint);\n      final CrossingEdgeIterator crossingEdgeIterator = new CrossingEdgeIterator(testPointYZPlane, testPointYZAbovePlane, testPointYZBelowPlane, testPointCutoff, checkPointCutoff, thePoint);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointXYPlane.evaluateIsZero(thePoint)) {\n      // Use the XY plane exclusively.\n      final SidedPlane testPointCutoff =  new SidedPlane(thePoint, testPointXYPlane, testPoint);\n      final SidedPlane checkPointCutoff = new SidedPlane(testPoint, testPointXYPlane, thePoint);\n      final CrossingEdgeIterator crossingEdgeIterator = new CrossingEdgeIterator(testPointXYPlane, testPointXYAbovePlane, testPointXYBelowPlane, testPointCutoff, checkPointCutoff, thePoint);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // We need to use two planes to get there.  We can use any two planes, and order doesn't matter.\n      // The best to pick are the ones with the shortest overall distance.\n      if (xDelta + yDelta <= xDelta + zDelta && xDelta + yDelta <= yDelta + zDelta) {\n        // Travel in X and Y\n        // We'll do this using the testPointYZPlane, and create a travel plane for the right XZ plane.\n        final Plane travelPlane = new Plane(0.0, 1.0, 0.0, -thePoint.y);\n        final Plane travelAbovePlane = new Plane(travelPlane, true);\n        final Plane travelBelowPlane = new Plane(travelPlane, false);\n        // We need cutoff planes for both legs.\n        final SidedPlane testPointCutoffPlane = new SidedPlane(thePoint, testPointYZPlane, testPoint);\n        final SidedPlane checkPointCutoffPlane = new SidedPlane(testPoint, travelPlane, thePoint);\n        // Now, find the intersection of the check and test point planes.\n        final GeoPoint[] intersectionPoints = travelPlane.findIntersections(planetModel, testPointYZPlane, testPointCutoffPlane, checkPointCutoffPlane);\n        assert intersectionPoints != null : \"couldn't find any intersections\";\n        assert intersectionPoints.length != 1 : \"wrong number of intersection points\";\n        final SidedPlane testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointYZPlane, intersectionPoints[0]);\n        final SidedPlane checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoints[0]);\n        // Note: we need to handle the cases where end point of the leg sits on an edge!\n        // MHL\n        final CrossingEdgeIterator testPointEdgeIterator = new CrossingEdgeIterator(testPointYZPlane, testPointYZAbovePlane, testPointYZBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, null);\n        xTree.traverse(testPointEdgeIterator, testPoint.x, testPoint.x);\n        final CrossingEdgeIterator checkPointEdgeIterator = new CrossingEdgeIterator(travelPlane, travelAbovePlane, travelBelowPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thePoint);\n        if (!yTree.traverse(checkPointEdgeIterator, thePoint.y, thePoint.y)) {\n          // Endpoint is on edge\n          return true;\n        }\n        return (((testPointEdgeIterator.crossingCount + checkPointEdgeIterator.crossingCount) & 1) == 0)?testPointInSet:!testPointInSet;\n      } else if (xDelta + zDelta <= xDelta + yDelta && xDelta + zDelta <= zDelta + yDelta) {\n        // Travel in X and Z\n        // We'll do this using the testPointXYPlane, and create a travel plane for the right YZ plane.\n        final Plane travelPlane = new Plane(1.0, 0.0, 0.0, -thePoint.x);\n        final Plane travelAbovePlane = new Plane(travelPlane, true);\n        final Plane travelBelowPlane = new Plane(travelPlane, false);\n        // We need cutoff planes for both legs.\n        final SidedPlane testPointCutoffPlane = new SidedPlane(thePoint, testPointXYPlane, testPoint);\n        final SidedPlane checkPointCutoffPlane = new SidedPlane(testPoint, travelPlane, thePoint);\n        // Now, find the intersection of the check and test point planes.\n        final GeoPoint[] intersectionPoints = travelPlane.findIntersections(planetModel, testPointXYPlane, testPointCutoffPlane, checkPointCutoffPlane);\n        assert intersectionPoints != null : \"couldn't find any intersections\";\n        assert intersectionPoints.length != 1 : \"wrong number of intersection points\";\n        final SidedPlane testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointXYPlane, intersectionPoints[0]);\n        final SidedPlane checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoints[0]);\n        // Note: we need to handle the cases where end point of the leg sits on an edge!\n        // MHL\n        final CrossingEdgeIterator testPointEdgeIterator = new CrossingEdgeIterator(testPointXYPlane, testPointXYAbovePlane, testPointXYBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, null);\n        zTree.traverse(testPointEdgeIterator, testPoint.z, testPoint.z);\n        final CrossingEdgeIterator checkPointEdgeIterator = new CrossingEdgeIterator(travelPlane, travelAbovePlane, travelBelowPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thePoint);\n        if (!xTree.traverse(checkPointEdgeIterator, thePoint.x, thePoint.x)) {\n          // Endpoint is on edge\n          return true;\n        }\n        return (((testPointEdgeIterator.crossingCount + checkPointEdgeIterator.crossingCount) & 1) == 0)?testPointInSet:!testPointInSet;\n      } else if (yDelta + zDelta <= xDelta + yDelta && yDelta + zDelta <= xDelta + zDelta) {\n        // Travel in Y and Z\n        // We'll do this using the testPointXZPlane, and create a travel plane for the right XY plane.\n        final Plane travelPlane = new Plane(0.0, 0.0, 1.0, -thePoint.z);\n        final Plane travelAbovePlane = new Plane(travelPlane, true);\n        final Plane travelBelowPlane = new Plane(travelPlane, false);\n        // We need cutoff planes for both legs.\n        final SidedPlane testPointCutoffPlane = new SidedPlane(thePoint, testPointXZPlane, testPoint);\n        final SidedPlane checkPointCutoffPlane = new SidedPlane(testPoint, travelPlane, thePoint);\n        // Now, find the intersection of the check and test point planes.\n        final GeoPoint[] intersectionPoints = travelPlane.findIntersections(planetModel, testPointXZPlane, testPointCutoffPlane, checkPointCutoffPlane);\n        assert intersectionPoints != null : \"couldn't find any intersections\";\n        assert intersectionPoints.length != 1 : \"wrong number of intersection points\";\n        final SidedPlane testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointXZPlane, intersectionPoints[0]);\n        final SidedPlane checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoints[0]);\n        // Note: we need to handle the cases where end point of the first leg sits on an edge!\n        // MHL\n        final CrossingEdgeIterator testPointEdgeIterator = new CrossingEdgeIterator(testPointXZPlane, testPointXZAbovePlane, testPointXZBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, null);\n        yTree.traverse(testPointEdgeIterator, testPoint.y, testPoint.y);\n        final CrossingEdgeIterator checkPointEdgeIterator = new CrossingEdgeIterator(travelPlane, travelAbovePlane, travelBelowPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thePoint);\n        if (!zTree.traverse(checkPointEdgeIterator, thePoint.z, thePoint.z)) {\n          // Endpoint is on edge\n          return true;\n        }\n        return (((testPointEdgeIterator.crossingCount + checkPointEdgeIterator.crossingCount) & 1) == 0)?testPointInSet:!testPointInSet;\n      }\n    }\n    return false;\n  }\n\n","sourceOld":"  @Override\n  public boolean isWithin(final Vector thePoint) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(thePoint)) {\n      return testPointInSet;\n    }\n    \n    // Choose our navigation route!\n    final double xDelta = Math.abs(thePoint.x - testPoint.x);\n    final double yDelta = Math.abs(thePoint.y - testPoint.y);\n    final double zDelta = Math.abs(thePoint.z - testPoint.z);\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointXZPlane.evaluateIsZero(thePoint)) {\n      // Use the XZ plane exclusively.\n      final SidedPlane testPointCutoff =  new SidedPlane(thePoint, testPointXZPlane, testPoint);\n      final SidedPlane checkPointCutoff = new SidedPlane(testPoint, testPointXZPlane, thePoint);\n      final CrossingEdgeIterator crossingEdgeIterator = new CrossingEdgeIterator(testPointXZPlane, testPointCutoff, checkPointCutoff, thePoint);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointYZPlane.evaluateIsZero(thePoint)) {\n      // Use the YZ plane exclusively.\n      final SidedPlane testPointCutoff =  new SidedPlane(thePoint, testPointYZPlane, testPoint);\n      final SidedPlane checkPointCutoff = new SidedPlane(testPoint, testPointYZPlane, thePoint);\n      final CrossingEdgeIterator crossingEdgeIterator = new CrossingEdgeIterator(testPointYZPlane, testPointCutoff, checkPointCutoff, thePoint);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointXYPlane.evaluateIsZero(thePoint)) {\n      // Use the XY plane exclusively.\n      final SidedPlane testPointCutoff =  new SidedPlane(thePoint, testPointXYPlane, testPoint);\n      final SidedPlane checkPointCutoff = new SidedPlane(testPoint, testPointXYPlane, thePoint);\n      final CrossingEdgeIterator crossingEdgeIterator = new CrossingEdgeIterator(testPointXYPlane, testPointCutoff, checkPointCutoff, thePoint);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // We need to use two planes to get there.  We can use any two planes, and order doesn't matter.\n      // The best to pick are the ones with the shortest overall distance.\n      if (xDelta + yDelta <= xDelta + zDelta && xDelta + yDelta <= yDelta + zDelta) {\n        // Travel in X and Y\n        // We'll do this using the testPointYZPlane, and create a travel plane for the right XZ plane.\n        final Plane travelPlane = new Plane(0.0, 1.0, 0.0, -thePoint.y);\n        // We need cutoff planes for both legs.\n        final SidedPlane testPointCutoffPlane = new SidedPlane(thePoint, testPointYZPlane, testPoint);\n        final SidedPlane checkPointCutoffPlane = new SidedPlane(testPoint, travelPlane, thePoint);\n        // Now, find the intersection of the check and test point planes.\n        final GeoPoint[] intersectionPoints = travelPlane.findIntersections(planetModel, testPointYZPlane, testPointCutoffPlane, checkPointCutoffPlane);\n        assert intersectionPoints != null : \"couldn't find any intersections\";\n        assert intersectionPoints.length != 1 : \"wrong number of intersection points\";\n        final SidedPlane testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointYZPlane, intersectionPoints[0]);\n        final SidedPlane checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoints[0]);\n        // Note: we need to handle the cases where end point of the leg sits on an edge!\n        // MHL\n        final CrossingEdgeIterator testPointEdgeIterator = new CrossingEdgeIterator(testPointYZPlane, testPointCutoffPlane, testPointOtherCutoffPlane, null);\n        xTree.traverse(testPointEdgeIterator, testPoint.x, testPoint.x);\n        final CrossingEdgeIterator checkPointEdgeIterator = new CrossingEdgeIterator(travelPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thePoint);\n        if (!yTree.traverse(checkPointEdgeIterator, thePoint.y, thePoint.y)) {\n          // Endpoint is on edge\n          return true;\n        }\n        return (((testPointEdgeIterator.crossingCount + checkPointEdgeIterator.crossingCount) & 1) == 0)?testPointInSet:!testPointInSet;\n      } else if (xDelta + zDelta <= xDelta + yDelta && xDelta + zDelta <= zDelta + yDelta) {\n        // Travel in X and Z\n        // We'll do this using the testPointXYPlane, and create a travel plane for the right YZ plane.\n        final Plane travelPlane = new Plane(1.0, 0.0, 0.0, -thePoint.x);\n        // We need cutoff planes for both legs.\n        final SidedPlane testPointCutoffPlane = new SidedPlane(thePoint, testPointXYPlane, testPoint);\n        final SidedPlane checkPointCutoffPlane = new SidedPlane(testPoint, travelPlane, thePoint);\n        // Now, find the intersection of the check and test point planes.\n        final GeoPoint[] intersectionPoints = travelPlane.findIntersections(planetModel, testPointXYPlane, testPointCutoffPlane, checkPointCutoffPlane);\n        assert intersectionPoints != null : \"couldn't find any intersections\";\n        assert intersectionPoints.length != 1 : \"wrong number of intersection points\";\n        final SidedPlane testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointXYPlane, intersectionPoints[0]);\n        final SidedPlane checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoints[0]);\n        // Note: we need to handle the cases where end point of the leg sits on an edge!\n        // MHL\n        final CrossingEdgeIterator testPointEdgeIterator = new CrossingEdgeIterator(testPointXYPlane, testPointCutoffPlane, testPointOtherCutoffPlane, null);\n        zTree.traverse(testPointEdgeIterator, testPoint.z, testPoint.z);\n        final CrossingEdgeIterator checkPointEdgeIterator = new CrossingEdgeIterator(travelPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thePoint);\n        if (!xTree.traverse(checkPointEdgeIterator, thePoint.x, thePoint.x)) {\n          // Endpoint is on edge\n          return true;\n        }\n        return (((testPointEdgeIterator.crossingCount + checkPointEdgeIterator.crossingCount) & 1) == 0)?testPointInSet:!testPointInSet;\n      } else if (yDelta + zDelta <= xDelta + yDelta && yDelta + zDelta <= xDelta + zDelta) {\n        // Travel in Y and Z\n        // We'll do this using the testPointXZPlane, and create a travel plane for the right XY plane.\n        final Plane travelPlane = new Plane(0.0, 0.0, 1.0, -thePoint.z);\n        // We need cutoff planes for both legs.\n        final SidedPlane testPointCutoffPlane = new SidedPlane(thePoint, testPointXZPlane, testPoint);\n        final SidedPlane checkPointCutoffPlane = new SidedPlane(testPoint, travelPlane, thePoint);\n        // Now, find the intersection of the check and test point planes.\n        final GeoPoint[] intersectionPoints = travelPlane.findIntersections(planetModel, testPointXZPlane, testPointCutoffPlane, checkPointCutoffPlane);\n        assert intersectionPoints != null : \"couldn't find any intersections\";\n        assert intersectionPoints.length != 1 : \"wrong number of intersection points\";\n        final SidedPlane testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointXZPlane, intersectionPoints[0]);\n        final SidedPlane checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoints[0]);\n        // Note: we need to handle the cases where end point of the first leg sits on an edge!\n        // MHL\n        final CrossingEdgeIterator testPointEdgeIterator = new CrossingEdgeIterator(testPointXZPlane, testPointCutoffPlane, testPointOtherCutoffPlane, null);\n        yTree.traverse(testPointEdgeIterator, testPoint.y, testPoint.y);\n        final CrossingEdgeIterator checkPointEdgeIterator = new CrossingEdgeIterator(travelPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thePoint);\n        if (!zTree.traverse(checkPointEdgeIterator, thePoint.z, thePoint.z)) {\n          // Endpoint is on edge\n          return true;\n        }\n        return (((testPointEdgeIterator.crossingCount + checkPointEdgeIterator.crossingCount) & 1) == 0)?testPointInSet:!testPointInSet;\n      }\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8ff44d836e8863507fa8711d2b1b2dd723516ca0","date":1461653163,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(Vector).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(Vector).mjava","sourceNew":"  @Override\n  public boolean isWithin(final Vector thePoint) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(thePoint)) {\n      return testPointInSet;\n    }\n    \n    // Choose our navigation route!\n    final double xDelta = Math.abs(thePoint.x - testPoint.x);\n    final double yDelta = Math.abs(thePoint.y - testPoint.y);\n    final double zDelta = Math.abs(thePoint.z - testPoint.z);\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointXZPlane.evaluateIsZero(thePoint)) {\n      // Use the XZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointXZPlane, testPointXZAbovePlane, testPointXZBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointYZPlane.evaluateIsZero(thePoint)) {\n      // Use the YZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointYZPlane, testPointYZAbovePlane, testPointYZBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointXYPlane.evaluateIsZero(thePoint)) {\n      // Use the XY plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointXYPlane, testPointXYAbovePlane, testPointXYBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // We need to use two planes to get there.  We can use any two planes, and order doesn't matter.\n      // The best to pick are the ones with the shortest overall distance.\n      if (xDelta + yDelta <= xDelta + zDelta && xDelta + yDelta <= yDelta + zDelta) {\n        // Travel in X and Y\n        // We'll do this using the testPointYZPlane, and create a travel plane for the right XZ plane.\n        final Plane travelPlane = new Plane(0.0, 1.0, 0.0, -thePoint.y);\n        final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(testPointYZPlane, testPointYZAbovePlane, testPointYZBelowPlane, travelPlane, testPoint, thePoint);\n        if (!xTree.traverse(edgeIterator, testPoint.x, testPoint.x)) {\n          return true;\n        }\n        edgeIterator.setSecondLeg();\n        if (!yTree.traverse(edgeIterator, thePoint.y, thePoint.y)) {\n          return true;\n        }\n        return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n      } else if (xDelta + zDelta <= xDelta + yDelta && xDelta + zDelta <= zDelta + yDelta) {\n        // Travel in X and Z\n        // We'll do this using the testPointXYPlane, and create a travel plane for the right YZ plane.\n        final Plane travelPlane = new Plane(1.0, 0.0, 0.0, -thePoint.x);\n        final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(testPointXYPlane, testPointXYAbovePlane, testPointXYBelowPlane, travelPlane, testPoint, thePoint);\n        if (!zTree.traverse(edgeIterator, testPoint.z, testPoint.z)) {\n          return true;\n        }\n        edgeIterator.setSecondLeg();\n        if (!xTree.traverse(edgeIterator, thePoint.x, thePoint.x)) {\n          return true;\n        }\n        return ((edgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n      } else if (yDelta + zDelta <= xDelta + yDelta && yDelta + zDelta <= xDelta + zDelta) {\n        // Travel in Y and Z\n        // We'll do this using the testPointXZPlane, and create a travel plane for the right XY plane.\n        final Plane travelPlane = new Plane(0.0, 0.0, 1.0, -thePoint.z);\n        final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(testPointXZPlane, testPointXZAbovePlane, testPointXZBelowPlane, travelPlane, testPoint, thePoint);\n        if (!yTree.traverse(edgeIterator, testPoint.y, testPoint.y)) {\n          return true;\n        }\n        edgeIterator.setSecondLeg();\n        if (!zTree.traverse(edgeIterator, thePoint.z, thePoint.z)) {\n          return true;\n        }\n        return ((edgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n      }\n    }\n    return false;\n  }\n\n","sourceOld":"  @Override\n  public boolean isWithin(final Vector thePoint) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(thePoint)) {\n      return testPointInSet;\n    }\n    \n    // Choose our navigation route!\n    final double xDelta = Math.abs(thePoint.x - testPoint.x);\n    final double yDelta = Math.abs(thePoint.y - testPoint.y);\n    final double zDelta = Math.abs(thePoint.z - testPoint.z);\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointXZPlane.evaluateIsZero(thePoint)) {\n      // Use the XZ plane exclusively.\n      final SidedPlane testPointCutoff =  new SidedPlane(thePoint, testPointXZPlane, testPoint);\n      final SidedPlane checkPointCutoff = new SidedPlane(testPoint, testPointXZPlane, thePoint);\n      final CrossingEdgeIterator crossingEdgeIterator = new CrossingEdgeIterator(testPointXZPlane, testPointXZAbovePlane, testPointXZBelowPlane, testPointCutoff, checkPointCutoff, thePoint);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointYZPlane.evaluateIsZero(thePoint)) {\n      // Use the YZ plane exclusively.\n      final SidedPlane testPointCutoff =  new SidedPlane(thePoint, testPointYZPlane, testPoint);\n      final SidedPlane checkPointCutoff = new SidedPlane(testPoint, testPointYZPlane, thePoint);\n      final CrossingEdgeIterator crossingEdgeIterator = new CrossingEdgeIterator(testPointYZPlane, testPointYZAbovePlane, testPointYZBelowPlane, testPointCutoff, checkPointCutoff, thePoint);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointXYPlane.evaluateIsZero(thePoint)) {\n      // Use the XY plane exclusively.\n      final SidedPlane testPointCutoff =  new SidedPlane(thePoint, testPointXYPlane, testPoint);\n      final SidedPlane checkPointCutoff = new SidedPlane(testPoint, testPointXYPlane, thePoint);\n      final CrossingEdgeIterator crossingEdgeIterator = new CrossingEdgeIterator(testPointXYPlane, testPointXYAbovePlane, testPointXYBelowPlane, testPointCutoff, checkPointCutoff, thePoint);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // We need to use two planes to get there.  We can use any two planes, and order doesn't matter.\n      // The best to pick are the ones with the shortest overall distance.\n      if (xDelta + yDelta <= xDelta + zDelta && xDelta + yDelta <= yDelta + zDelta) {\n        // Travel in X and Y\n        // We'll do this using the testPointYZPlane, and create a travel plane for the right XZ plane.\n        final Plane travelPlane = new Plane(0.0, 1.0, 0.0, -thePoint.y);\n        final Plane travelAbovePlane = new Plane(travelPlane, true);\n        final Plane travelBelowPlane = new Plane(travelPlane, false);\n        // We need cutoff planes for both legs.\n        final SidedPlane testPointCutoffPlane = new SidedPlane(thePoint, testPointYZPlane, testPoint);\n        final SidedPlane checkPointCutoffPlane = new SidedPlane(testPoint, travelPlane, thePoint);\n        // Now, find the intersection of the check and test point planes.\n        final GeoPoint[] intersectionPoints = travelPlane.findIntersections(planetModel, testPointYZPlane, testPointCutoffPlane, checkPointCutoffPlane);\n        assert intersectionPoints != null : \"couldn't find any intersections\";\n        assert intersectionPoints.length != 1 : \"wrong number of intersection points\";\n        final SidedPlane testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointYZPlane, intersectionPoints[0]);\n        final SidedPlane checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoints[0]);\n        // Note: we need to handle the cases where end point of the leg sits on an edge!\n        // MHL\n        final CrossingEdgeIterator testPointEdgeIterator = new CrossingEdgeIterator(testPointYZPlane, testPointYZAbovePlane, testPointYZBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, null);\n        xTree.traverse(testPointEdgeIterator, testPoint.x, testPoint.x);\n        final CrossingEdgeIterator checkPointEdgeIterator = new CrossingEdgeIterator(travelPlane, travelAbovePlane, travelBelowPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thePoint);\n        if (!yTree.traverse(checkPointEdgeIterator, thePoint.y, thePoint.y)) {\n          // Endpoint is on edge\n          return true;\n        }\n        return (((testPointEdgeIterator.crossingCount + checkPointEdgeIterator.crossingCount) & 1) == 0)?testPointInSet:!testPointInSet;\n      } else if (xDelta + zDelta <= xDelta + yDelta && xDelta + zDelta <= zDelta + yDelta) {\n        // Travel in X and Z\n        // We'll do this using the testPointXYPlane, and create a travel plane for the right YZ plane.\n        final Plane travelPlane = new Plane(1.0, 0.0, 0.0, -thePoint.x);\n        final Plane travelAbovePlane = new Plane(travelPlane, true);\n        final Plane travelBelowPlane = new Plane(travelPlane, false);\n        // We need cutoff planes for both legs.\n        final SidedPlane testPointCutoffPlane = new SidedPlane(thePoint, testPointXYPlane, testPoint);\n        final SidedPlane checkPointCutoffPlane = new SidedPlane(testPoint, travelPlane, thePoint);\n        // Now, find the intersection of the check and test point planes.\n        final GeoPoint[] intersectionPoints = travelPlane.findIntersections(planetModel, testPointXYPlane, testPointCutoffPlane, checkPointCutoffPlane);\n        assert intersectionPoints != null : \"couldn't find any intersections\";\n        assert intersectionPoints.length != 1 : \"wrong number of intersection points\";\n        final SidedPlane testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointXYPlane, intersectionPoints[0]);\n        final SidedPlane checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoints[0]);\n        // Note: we need to handle the cases where end point of the leg sits on an edge!\n        // MHL\n        final CrossingEdgeIterator testPointEdgeIterator = new CrossingEdgeIterator(testPointXYPlane, testPointXYAbovePlane, testPointXYBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, null);\n        zTree.traverse(testPointEdgeIterator, testPoint.z, testPoint.z);\n        final CrossingEdgeIterator checkPointEdgeIterator = new CrossingEdgeIterator(travelPlane, travelAbovePlane, travelBelowPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thePoint);\n        if (!xTree.traverse(checkPointEdgeIterator, thePoint.x, thePoint.x)) {\n          // Endpoint is on edge\n          return true;\n        }\n        return (((testPointEdgeIterator.crossingCount + checkPointEdgeIterator.crossingCount) & 1) == 0)?testPointInSet:!testPointInSet;\n      } else if (yDelta + zDelta <= xDelta + yDelta && yDelta + zDelta <= xDelta + zDelta) {\n        // Travel in Y and Z\n        // We'll do this using the testPointXZPlane, and create a travel plane for the right XY plane.\n        final Plane travelPlane = new Plane(0.0, 0.0, 1.0, -thePoint.z);\n        final Plane travelAbovePlane = new Plane(travelPlane, true);\n        final Plane travelBelowPlane = new Plane(travelPlane, false);\n        // We need cutoff planes for both legs.\n        final SidedPlane testPointCutoffPlane = new SidedPlane(thePoint, testPointXZPlane, testPoint);\n        final SidedPlane checkPointCutoffPlane = new SidedPlane(testPoint, travelPlane, thePoint);\n        // Now, find the intersection of the check and test point planes.\n        final GeoPoint[] intersectionPoints = travelPlane.findIntersections(planetModel, testPointXZPlane, testPointCutoffPlane, checkPointCutoffPlane);\n        assert intersectionPoints != null : \"couldn't find any intersections\";\n        assert intersectionPoints.length != 1 : \"wrong number of intersection points\";\n        final SidedPlane testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointXZPlane, intersectionPoints[0]);\n        final SidedPlane checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoints[0]);\n        // Note: we need to handle the cases where end point of the first leg sits on an edge!\n        // MHL\n        final CrossingEdgeIterator testPointEdgeIterator = new CrossingEdgeIterator(testPointXZPlane, testPointXZAbovePlane, testPointXZBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, null);\n        yTree.traverse(testPointEdgeIterator, testPoint.y, testPoint.y);\n        final CrossingEdgeIterator checkPointEdgeIterator = new CrossingEdgeIterator(travelPlane, travelAbovePlane, travelBelowPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thePoint);\n        if (!zTree.traverse(checkPointEdgeIterator, thePoint.z, thePoint.z)) {\n          // Endpoint is on edge\n          return true;\n        }\n        return (((testPointEdgeIterator.crossingCount + checkPointEdgeIterator.crossingCount) & 1) == 0)?testPointInSet:!testPointInSet;\n      }\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"265e2d0799e876e7c751a97229b0d8007cd79f0a","date":1461779668,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(Vector).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(Vector).mjava","sourceNew":"  @Override\n  public boolean isWithin(final Vector thePoint) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(thePoint)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointXZPlane.evaluateIsZero(thePoint)) {\n      // Use the XZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointXZPlane, testPointXZAbovePlane, testPointXZBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointYZPlane.evaluateIsZero(thePoint)) {\n      // Use the YZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointYZPlane, testPointYZAbovePlane, testPointYZBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointXYPlane.evaluateIsZero(thePoint)) {\n      // Use the XY plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointXYPlane, testPointXYAbovePlane, testPointXYBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -thePoint.x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -thePoint.y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -thePoint.z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XZIntersectionsYZ = travelPlaneFixedX.findIntersections(planetModel, testPointYZPlane);\n      final GeoPoint[] XZIntersectionsXY = travelPlaneFixedX.findIntersections(planetModel, testPointXYPlane);\n      final GeoPoint[] YZIntersectionsXZ = travelPlaneFixedY.findIntersections(planetModel, testPointXZPlane);\n      final GeoPoint[] YZIntersectionsXY = travelPlaneFixedY.findIntersections(planetModel, testPointXYPlane);\n      final GeoPoint[] XYIntersectionsYZ = travelPlaneFixedZ.findIntersections(planetModel, testPointYZPlane);\n      final GeoPoint[] XYIntersectionsXZ = travelPlaneFixedZ.findIntersections(planetModel, testPointXZPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.MAX_VALUE;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XZIntersectionsYZ) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        final double newDistance = Math.abs(thePoint.x - p.x) + Math.abs(testPoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointYZPlane;\n          firstLegAbovePlane = testPointYZAbovePlane;\n          firstLegBelowPlane = testPointYZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XZIntersectionsXY) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        final double newDistance = Math.abs(thePoint.z - p.z) + Math.abs(testPoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointXYPlane;\n          firstLegAbovePlane = testPointXYAbovePlane;\n          firstLegBelowPlane = testPointXYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YZIntersectionsXZ) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        final double newDistance = Math.abs(thePoint.y - p.y) + Math.abs(testPoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointXZPlane;\n          firstLegAbovePlane = testPointXZAbovePlane;\n          firstLegBelowPlane = testPointXZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YZIntersectionsXY) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        final double newDistance = Math.abs(thePoint.z - p.z) + Math.abs(testPoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointXYPlane;\n          firstLegAbovePlane = testPointXYAbovePlane;\n          firstLegBelowPlane = testPointXYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XYIntersectionsYZ) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        final double newDistance = Math.abs(thePoint.x - p.x) + Math.abs(testPoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointYZPlane;\n          firstLegAbovePlane = testPointYZAbovePlane;\n          firstLegBelowPlane = testPointYZBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XYIntersectionsXZ) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        final double newDistance = Math.abs(thePoint.y - p.y) + Math.abs(testPoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointXZPlane;\n          firstLegAbovePlane = testPointXZAbovePlane;\n          firstLegBelowPlane = testPointXZBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance < Double.MAX_VALUE : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, testPoint, thePoint, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue, firstLegValue)) {\n        return true;\n      }\n      edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue, secondLegValue)) {\n        return true;\n      }\n      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","sourceOld":"  @Override\n  public boolean isWithin(final Vector thePoint) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(thePoint)) {\n      return testPointInSet;\n    }\n    \n    // Choose our navigation route!\n    final double xDelta = Math.abs(thePoint.x - testPoint.x);\n    final double yDelta = Math.abs(thePoint.y - testPoint.y);\n    final double zDelta = Math.abs(thePoint.z - testPoint.z);\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointXZPlane.evaluateIsZero(thePoint)) {\n      // Use the XZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointXZPlane, testPointXZAbovePlane, testPointXZBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointYZPlane.evaluateIsZero(thePoint)) {\n      // Use the YZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointYZPlane, testPointYZAbovePlane, testPointYZBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointXYPlane.evaluateIsZero(thePoint)) {\n      // Use the XY plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointXYPlane, testPointXYAbovePlane, testPointXYBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // We need to use two planes to get there.  We can use any two planes, and order doesn't matter.\n      // The best to pick are the ones with the shortest overall distance.\n      if (xDelta + yDelta <= xDelta + zDelta && xDelta + yDelta <= yDelta + zDelta) {\n        // Travel in X and Y\n        // We'll do this using the testPointYZPlane, and create a travel plane for the right XZ plane.\n        final Plane travelPlane = new Plane(0.0, 1.0, 0.0, -thePoint.y);\n        final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(testPointYZPlane, testPointYZAbovePlane, testPointYZBelowPlane, travelPlane, testPoint, thePoint);\n        if (!xTree.traverse(edgeIterator, testPoint.x, testPoint.x)) {\n          return true;\n        }\n        edgeIterator.setSecondLeg();\n        if (!yTree.traverse(edgeIterator, thePoint.y, thePoint.y)) {\n          return true;\n        }\n        return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n      } else if (xDelta + zDelta <= xDelta + yDelta && xDelta + zDelta <= zDelta + yDelta) {\n        // Travel in X and Z\n        // We'll do this using the testPointXYPlane, and create a travel plane for the right YZ plane.\n        final Plane travelPlane = new Plane(1.0, 0.0, 0.0, -thePoint.x);\n        final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(testPointXYPlane, testPointXYAbovePlane, testPointXYBelowPlane, travelPlane, testPoint, thePoint);\n        if (!zTree.traverse(edgeIterator, testPoint.z, testPoint.z)) {\n          return true;\n        }\n        edgeIterator.setSecondLeg();\n        if (!xTree.traverse(edgeIterator, thePoint.x, thePoint.x)) {\n          return true;\n        }\n        return ((edgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n      } else if (yDelta + zDelta <= xDelta + yDelta && yDelta + zDelta <= xDelta + zDelta) {\n        // Travel in Y and Z\n        // We'll do this using the testPointXZPlane, and create a travel plane for the right XY plane.\n        final Plane travelPlane = new Plane(0.0, 0.0, 1.0, -thePoint.z);\n        final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(testPointXZPlane, testPointXZAbovePlane, testPointXZBelowPlane, travelPlane, testPoint, thePoint);\n        if (!yTree.traverse(edgeIterator, testPoint.y, testPoint.y)) {\n          return true;\n        }\n        edgeIterator.setSecondLeg();\n        if (!zTree.traverse(edgeIterator, thePoint.z, thePoint.z)) {\n          return true;\n        }\n        return ((edgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n      }\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b3ccbc7c0d21f9643de6c5c7894f67336dcb57a","date":1461845562,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(Vector).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(Vector).mjava","sourceNew":"  @Override\n  public boolean isWithin(final Vector thePoint) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(thePoint)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointXZPlane.evaluateIsZero(thePoint)) {\n      // Use the XZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointXZPlane, testPointXZAbovePlane, testPointXZBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointYZPlane.evaluateIsZero(thePoint)) {\n      // Use the YZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointYZPlane, testPointYZAbovePlane, testPointYZBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointXYPlane.evaluateIsZero(thePoint)) {\n      // Use the XY plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointXYPlane, testPointXYAbovePlane, testPointXYBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -thePoint.x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -thePoint.y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -thePoint.z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XZIntersectionsYZ = travelPlaneFixedX.findIntersections(planetModel, testPointYZPlane);\n      final GeoPoint[] XZIntersectionsXY = travelPlaneFixedX.findIntersections(planetModel, testPointXYPlane);\n      final GeoPoint[] YZIntersectionsXZ = travelPlaneFixedY.findIntersections(planetModel, testPointXZPlane);\n      final GeoPoint[] YZIntersectionsXY = travelPlaneFixedY.findIntersections(planetModel, testPointXYPlane);\n      final GeoPoint[] XYIntersectionsYZ = travelPlaneFixedZ.findIntersections(planetModel, testPointYZPlane);\n      final GeoPoint[] XYIntersectionsXZ = travelPlaneFixedZ.findIntersections(planetModel, testPointXZPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.MAX_VALUE;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XZIntersectionsYZ) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        final double newDistance = Math.abs(thePoint.x - p.x) + Math.abs(testPoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointYZPlane;\n          firstLegAbovePlane = testPointYZAbovePlane;\n          firstLegBelowPlane = testPointYZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XZIntersectionsXY) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        final double newDistance = Math.abs(thePoint.z - p.z) + Math.abs(testPoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointXYPlane;\n          firstLegAbovePlane = testPointXYAbovePlane;\n          firstLegBelowPlane = testPointXYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YZIntersectionsXZ) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        final double newDistance = Math.abs(thePoint.y - p.y) + Math.abs(testPoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointXZPlane;\n          firstLegAbovePlane = testPointXZAbovePlane;\n          firstLegBelowPlane = testPointXZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YZIntersectionsXY) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        final double newDistance = Math.abs(thePoint.z - p.z) + Math.abs(testPoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointXYPlane;\n          firstLegAbovePlane = testPointXYAbovePlane;\n          firstLegBelowPlane = testPointXYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XYIntersectionsYZ) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        final double newDistance = Math.abs(thePoint.x - p.x) + Math.abs(testPoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointYZPlane;\n          firstLegAbovePlane = testPointYZAbovePlane;\n          firstLegBelowPlane = testPointYZBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XYIntersectionsXZ) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        final double newDistance = Math.abs(thePoint.y - p.y) + Math.abs(testPoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointXZPlane;\n          firstLegAbovePlane = testPointXZAbovePlane;\n          firstLegBelowPlane = testPointXZBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance < Double.MAX_VALUE : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, testPoint, thePoint, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","sourceOld":"  @Override\n  public boolean isWithin(final Vector thePoint) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(thePoint)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointXZPlane.evaluateIsZero(thePoint)) {\n      // Use the XZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointXZPlane, testPointXZAbovePlane, testPointXZBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointYZPlane.evaluateIsZero(thePoint)) {\n      // Use the YZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointYZPlane, testPointYZAbovePlane, testPointYZBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointXYPlane.evaluateIsZero(thePoint)) {\n      // Use the XY plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointXYPlane, testPointXYAbovePlane, testPointXYBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -thePoint.x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -thePoint.y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -thePoint.z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XZIntersectionsYZ = travelPlaneFixedX.findIntersections(planetModel, testPointYZPlane);\n      final GeoPoint[] XZIntersectionsXY = travelPlaneFixedX.findIntersections(planetModel, testPointXYPlane);\n      final GeoPoint[] YZIntersectionsXZ = travelPlaneFixedY.findIntersections(planetModel, testPointXZPlane);\n      final GeoPoint[] YZIntersectionsXY = travelPlaneFixedY.findIntersections(planetModel, testPointXYPlane);\n      final GeoPoint[] XYIntersectionsYZ = travelPlaneFixedZ.findIntersections(planetModel, testPointYZPlane);\n      final GeoPoint[] XYIntersectionsXZ = travelPlaneFixedZ.findIntersections(planetModel, testPointXZPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.MAX_VALUE;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XZIntersectionsYZ) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        final double newDistance = Math.abs(thePoint.x - p.x) + Math.abs(testPoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointYZPlane;\n          firstLegAbovePlane = testPointYZAbovePlane;\n          firstLegBelowPlane = testPointYZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XZIntersectionsXY) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        final double newDistance = Math.abs(thePoint.z - p.z) + Math.abs(testPoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointXYPlane;\n          firstLegAbovePlane = testPointXYAbovePlane;\n          firstLegBelowPlane = testPointXYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YZIntersectionsXZ) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        final double newDistance = Math.abs(thePoint.y - p.y) + Math.abs(testPoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointXZPlane;\n          firstLegAbovePlane = testPointXZAbovePlane;\n          firstLegBelowPlane = testPointXZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YZIntersectionsXY) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        final double newDistance = Math.abs(thePoint.z - p.z) + Math.abs(testPoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointXYPlane;\n          firstLegAbovePlane = testPointXYAbovePlane;\n          firstLegBelowPlane = testPointXYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XYIntersectionsYZ) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        final double newDistance = Math.abs(thePoint.x - p.x) + Math.abs(testPoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointYZPlane;\n          firstLegAbovePlane = testPointYZAbovePlane;\n          firstLegBelowPlane = testPointYZBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XYIntersectionsXZ) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        final double newDistance = Math.abs(thePoint.y - p.y) + Math.abs(testPoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointXZPlane;\n          firstLegAbovePlane = testPointXZAbovePlane;\n          firstLegBelowPlane = testPointXZBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance < Double.MAX_VALUE : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, testPoint, thePoint, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue, firstLegValue)) {\n        return true;\n      }\n      edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue, secondLegValue)) {\n        return true;\n      }\n      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43631d6552f924eb58c0b507e3e10215c53754f8","date":1461863675,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(Vector).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(Vector).mjava","sourceNew":"  @Override\n  public boolean isWithin(final Vector thePoint) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(thePoint)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointXZPlane.evaluateIsZero(thePoint)) {\n      // Use the XZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointXZPlane, testPointXZAbovePlane, testPointXZBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointYZPlane.evaluateIsZero(thePoint)) {\n      // Use the YZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointYZPlane, testPointYZAbovePlane, testPointYZBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointXYPlane.evaluateIsZero(thePoint)) {\n      // Use the XY plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointXYPlane, testPointXYAbovePlane, testPointXYBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      System.err.println(\"isWithin() for check point \"+thePoint+\", test point \"+testPoint);\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -thePoint.x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -thePoint.y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -thePoint.z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XZIntersectionsYZ = travelPlaneFixedX.findIntersections(planetModel, testPointYZPlane);\n      final GeoPoint[] XZIntersectionsXY = travelPlaneFixedX.findIntersections(planetModel, testPointXYPlane);\n      final GeoPoint[] YZIntersectionsXZ = travelPlaneFixedY.findIntersections(planetModel, testPointXZPlane);\n      final GeoPoint[] YZIntersectionsXY = travelPlaneFixedY.findIntersections(planetModel, testPointXYPlane);\n      final GeoPoint[] XYIntersectionsYZ = travelPlaneFixedZ.findIntersections(planetModel, testPointYZPlane);\n      final GeoPoint[] XYIntersectionsXZ = travelPlaneFixedZ.findIntersections(planetModel, testPointXZPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.MAX_VALUE;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XZIntersectionsYZ) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        final double newDistance = Math.abs(thePoint.x - p.x) + Math.abs(testPoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointXZPlane;\n          firstLegAbovePlane = testPointXZAbovePlane;\n          firstLegBelowPlane = testPointXZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XZIntersectionsXY) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        final double newDistance = Math.abs(thePoint.z - p.z) + Math.abs(testPoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointXZPlane;\n          firstLegAbovePlane = testPointXZAbovePlane;\n          firstLegBelowPlane = testPointXZBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YZIntersectionsXZ) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        final double newDistance = Math.abs(thePoint.y - p.y) + Math.abs(testPoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointYZPlane;\n          firstLegAbovePlane = testPointYZAbovePlane;\n          firstLegBelowPlane = testPointYZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YZIntersectionsXY) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        final double newDistance = Math.abs(thePoint.z - p.z) + Math.abs(testPoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointYZPlane;\n          firstLegAbovePlane = testPointYZAbovePlane;\n          firstLegBelowPlane = testPointYZBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XYIntersectionsYZ) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        final double newDistance = Math.abs(thePoint.x - p.x) + Math.abs(testPoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointXYPlane;\n          firstLegAbovePlane = testPointXYAbovePlane;\n          firstLegBelowPlane = testPointXYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XYIntersectionsXZ) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        final double newDistance = Math.abs(thePoint.y - p.y) + Math.abs(testPoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointXYPlane;\n          firstLegAbovePlane = testPointXYAbovePlane;\n          firstLegBelowPlane = testPointXYBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance < Double.MAX_VALUE : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, testPoint, thePoint, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","sourceOld":"  @Override\n  public boolean isWithin(final Vector thePoint) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(thePoint)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointXZPlane.evaluateIsZero(thePoint)) {\n      // Use the XZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointXZPlane, testPointXZAbovePlane, testPointXZBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointYZPlane.evaluateIsZero(thePoint)) {\n      // Use the YZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointYZPlane, testPointYZAbovePlane, testPointYZBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointXYPlane.evaluateIsZero(thePoint)) {\n      // Use the XY plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointXYPlane, testPointXYAbovePlane, testPointXYBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -thePoint.x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -thePoint.y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -thePoint.z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XZIntersectionsYZ = travelPlaneFixedX.findIntersections(planetModel, testPointYZPlane);\n      final GeoPoint[] XZIntersectionsXY = travelPlaneFixedX.findIntersections(planetModel, testPointXYPlane);\n      final GeoPoint[] YZIntersectionsXZ = travelPlaneFixedY.findIntersections(planetModel, testPointXZPlane);\n      final GeoPoint[] YZIntersectionsXY = travelPlaneFixedY.findIntersections(planetModel, testPointXYPlane);\n      final GeoPoint[] XYIntersectionsYZ = travelPlaneFixedZ.findIntersections(planetModel, testPointYZPlane);\n      final GeoPoint[] XYIntersectionsXZ = travelPlaneFixedZ.findIntersections(planetModel, testPointXZPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.MAX_VALUE;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XZIntersectionsYZ) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        final double newDistance = Math.abs(thePoint.x - p.x) + Math.abs(testPoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointYZPlane;\n          firstLegAbovePlane = testPointYZAbovePlane;\n          firstLegBelowPlane = testPointYZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XZIntersectionsXY) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        final double newDistance = Math.abs(thePoint.z - p.z) + Math.abs(testPoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointXYPlane;\n          firstLegAbovePlane = testPointXYAbovePlane;\n          firstLegBelowPlane = testPointXYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YZIntersectionsXZ) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        final double newDistance = Math.abs(thePoint.y - p.y) + Math.abs(testPoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointXZPlane;\n          firstLegAbovePlane = testPointXZAbovePlane;\n          firstLegBelowPlane = testPointXZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YZIntersectionsXY) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        final double newDistance = Math.abs(thePoint.z - p.z) + Math.abs(testPoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointXYPlane;\n          firstLegAbovePlane = testPointXYAbovePlane;\n          firstLegBelowPlane = testPointXYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XYIntersectionsYZ) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        final double newDistance = Math.abs(thePoint.x - p.x) + Math.abs(testPoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointYZPlane;\n          firstLegAbovePlane = testPointYZAbovePlane;\n          firstLegBelowPlane = testPointYZBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XYIntersectionsXZ) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        final double newDistance = Math.abs(thePoint.y - p.y) + Math.abs(testPoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointXZPlane;\n          firstLegAbovePlane = testPointXZAbovePlane;\n          firstLegBelowPlane = testPointXZBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance < Double.MAX_VALUE : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, testPoint, thePoint, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4e36ad3a30dae8fc4711af30a236d83d6aa57c0f","date":1461870588,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(Vector).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(Vector).mjava","sourceNew":"  @Override\n  public boolean isWithin(final Vector thePoint) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(thePoint)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointXZPlane.evaluateIsZero(thePoint)) {\n      // Use the XZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointXZPlane, testPointXZAbovePlane, testPointXZBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointYZPlane.evaluateIsZero(thePoint)) {\n      // Use the YZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointYZPlane, testPointYZAbovePlane, testPointYZBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointXYPlane.evaluateIsZero(thePoint)) {\n      // Use the XY plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointXYPlane, testPointXYAbovePlane, testPointXYBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      System.err.println(\"isWithin() for check point \"+thePoint+\", test point \"+testPoint);\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -thePoint.x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -thePoint.y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -thePoint.z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XZIntersectionsYZ = travelPlaneFixedX.findIntersections(planetModel, testPointYZPlane);\n      final GeoPoint[] XZIntersectionsXY = travelPlaneFixedX.findIntersections(planetModel, testPointXYPlane);\n      final GeoPoint[] YZIntersectionsXZ = travelPlaneFixedY.findIntersections(planetModel, testPointXZPlane);\n      final GeoPoint[] YZIntersectionsXY = travelPlaneFixedY.findIntersections(planetModel, testPointXYPlane);\n      final GeoPoint[] XYIntersectionsYZ = travelPlaneFixedZ.findIntersections(planetModel, testPointYZPlane);\n      final GeoPoint[] XYIntersectionsXZ = travelPlaneFixedZ.findIntersections(planetModel, testPointXZPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.MAX_VALUE;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XZIntersectionsYZ) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointXZPlane;\n          firstLegAbovePlane = testPointXZAbovePlane;\n          firstLegBelowPlane = testPointXZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XZIntersectionsXY) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointXZPlane;\n          firstLegAbovePlane = testPointXZAbovePlane;\n          firstLegBelowPlane = testPointXZBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YZIntersectionsXZ) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointYZPlane;\n          firstLegAbovePlane = testPointYZAbovePlane;\n          firstLegBelowPlane = testPointYZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YZIntersectionsXY) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointYZPlane;\n          firstLegAbovePlane = testPointYZAbovePlane;\n          firstLegBelowPlane = testPointYZBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XYIntersectionsYZ) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointXYPlane;\n          firstLegAbovePlane = testPointXYAbovePlane;\n          firstLegBelowPlane = testPointXYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XYIntersectionsXZ) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointXYPlane;\n          firstLegAbovePlane = testPointXYAbovePlane;\n          firstLegBelowPlane = testPointXYBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance < Double.MAX_VALUE : \"Couldn't find an intersection point of any kind\";\n      \n      System.err.println(\"Best distance: \"+bestDistance);\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, testPoint, thePoint, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","sourceOld":"  @Override\n  public boolean isWithin(final Vector thePoint) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(thePoint)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointXZPlane.evaluateIsZero(thePoint)) {\n      // Use the XZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointXZPlane, testPointXZAbovePlane, testPointXZBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointYZPlane.evaluateIsZero(thePoint)) {\n      // Use the YZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointYZPlane, testPointYZAbovePlane, testPointYZBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointXYPlane.evaluateIsZero(thePoint)) {\n      // Use the XY plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointXYPlane, testPointXYAbovePlane, testPointXYBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      System.err.println(\"isWithin() for check point \"+thePoint+\", test point \"+testPoint);\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -thePoint.x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -thePoint.y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -thePoint.z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XZIntersectionsYZ = travelPlaneFixedX.findIntersections(planetModel, testPointYZPlane);\n      final GeoPoint[] XZIntersectionsXY = travelPlaneFixedX.findIntersections(planetModel, testPointXYPlane);\n      final GeoPoint[] YZIntersectionsXZ = travelPlaneFixedY.findIntersections(planetModel, testPointXZPlane);\n      final GeoPoint[] YZIntersectionsXY = travelPlaneFixedY.findIntersections(planetModel, testPointXYPlane);\n      final GeoPoint[] XYIntersectionsYZ = travelPlaneFixedZ.findIntersections(planetModel, testPointYZPlane);\n      final GeoPoint[] XYIntersectionsXZ = travelPlaneFixedZ.findIntersections(planetModel, testPointXZPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.MAX_VALUE;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XZIntersectionsYZ) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        final double newDistance = Math.abs(thePoint.x - p.x) + Math.abs(testPoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointXZPlane;\n          firstLegAbovePlane = testPointXZAbovePlane;\n          firstLegBelowPlane = testPointXZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XZIntersectionsXY) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        final double newDistance = Math.abs(thePoint.z - p.z) + Math.abs(testPoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointXZPlane;\n          firstLegAbovePlane = testPointXZAbovePlane;\n          firstLegBelowPlane = testPointXZBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YZIntersectionsXZ) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        final double newDistance = Math.abs(thePoint.y - p.y) + Math.abs(testPoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointYZPlane;\n          firstLegAbovePlane = testPointYZAbovePlane;\n          firstLegBelowPlane = testPointYZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YZIntersectionsXY) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        final double newDistance = Math.abs(thePoint.z - p.z) + Math.abs(testPoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointYZPlane;\n          firstLegAbovePlane = testPointYZAbovePlane;\n          firstLegBelowPlane = testPointYZBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XYIntersectionsYZ) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        final double newDistance = Math.abs(thePoint.x - p.x) + Math.abs(testPoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointXYPlane;\n          firstLegAbovePlane = testPointXYAbovePlane;\n          firstLegBelowPlane = testPointXYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XYIntersectionsXZ) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        final double newDistance = Math.abs(thePoint.y - p.y) + Math.abs(testPoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointXYPlane;\n          firstLegAbovePlane = testPointXYAbovePlane;\n          firstLegBelowPlane = testPointXYBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance < Double.MAX_VALUE : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, testPoint, thePoint, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"414d7bcd2f513d7e7162dae022e9a9f3cd930277","date":1461885603,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(Vector).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(Vector).mjava","sourceNew":"  @Override\n  public boolean isWithin(final Vector thePoint) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(thePoint)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYPlane.evaluateIsZero(thePoint)) {\n      // Use the XZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXPlane.evaluateIsZero(thePoint)) {\n      // Use the YZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZPlane.evaluateIsZero(thePoint)) {\n      // Use the XY plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -thePoint.x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -thePoint.y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -thePoint.z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n      final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.MAX_VALUE;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XIntersectionsY) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XIntersectionsZ) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsX) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsZ) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsX) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsY) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.MAX_VALUE : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, testPoint, thePoint, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","sourceOld":"  @Override\n  public boolean isWithin(final Vector thePoint) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(thePoint)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointXZPlane.evaluateIsZero(thePoint)) {\n      // Use the XZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointXZPlane, testPointXZAbovePlane, testPointXZBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointYZPlane.evaluateIsZero(thePoint)) {\n      // Use the YZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointYZPlane, testPointYZAbovePlane, testPointYZBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointXYPlane.evaluateIsZero(thePoint)) {\n      // Use the XY plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointXYPlane, testPointXYAbovePlane, testPointXYBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      System.err.println(\"isWithin() for check point \"+thePoint+\", test point \"+testPoint);\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -thePoint.x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -thePoint.y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -thePoint.z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XZIntersectionsYZ = travelPlaneFixedX.findIntersections(planetModel, testPointYZPlane);\n      final GeoPoint[] XZIntersectionsXY = travelPlaneFixedX.findIntersections(planetModel, testPointXYPlane);\n      final GeoPoint[] YZIntersectionsXZ = travelPlaneFixedY.findIntersections(planetModel, testPointXZPlane);\n      final GeoPoint[] YZIntersectionsXY = travelPlaneFixedY.findIntersections(planetModel, testPointXYPlane);\n      final GeoPoint[] XYIntersectionsYZ = travelPlaneFixedZ.findIntersections(planetModel, testPointYZPlane);\n      final GeoPoint[] XYIntersectionsXZ = travelPlaneFixedZ.findIntersections(planetModel, testPointXZPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.MAX_VALUE;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XZIntersectionsYZ) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointXZPlane;\n          firstLegAbovePlane = testPointXZAbovePlane;\n          firstLegBelowPlane = testPointXZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XZIntersectionsXY) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointXZPlane;\n          firstLegAbovePlane = testPointXZAbovePlane;\n          firstLegBelowPlane = testPointXZBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YZIntersectionsXZ) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointYZPlane;\n          firstLegAbovePlane = testPointYZAbovePlane;\n          firstLegBelowPlane = testPointYZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YZIntersectionsXY) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointYZPlane;\n          firstLegAbovePlane = testPointYZAbovePlane;\n          firstLegBelowPlane = testPointYZBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XYIntersectionsYZ) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointXYPlane;\n          firstLegAbovePlane = testPointXYAbovePlane;\n          firstLegBelowPlane = testPointXYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XYIntersectionsXZ) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointXYPlane;\n          firstLegAbovePlane = testPointXYAbovePlane;\n          firstLegBelowPlane = testPointXYBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance < Double.MAX_VALUE : \"Couldn't find an intersection point of any kind\";\n      \n      System.err.println(\"Best distance: \"+bestDistance);\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, testPoint, thePoint, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0","date":1461888019,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(Vector).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public boolean isWithin(final Vector thePoint) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(thePoint)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYPlane.evaluateIsZero(thePoint)) {\n      // Use the XZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXPlane.evaluateIsZero(thePoint)) {\n      // Use the YZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZPlane.evaluateIsZero(thePoint)) {\n      // Use the XY plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -thePoint.x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -thePoint.y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -thePoint.z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n      final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.MAX_VALUE;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XIntersectionsY) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XIntersectionsZ) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsX) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsZ) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsX) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsY) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.MAX_VALUE : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, testPoint, thePoint, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55b50463286869f584cf849d1587a0fcd54d1dfa","date":1462378517,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(Vector).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public boolean isWithin(final Vector thePoint) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(thePoint)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYPlane.evaluateIsZero(thePoint)) {\n      // Use the XZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXPlane.evaluateIsZero(thePoint)) {\n      // Use the YZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZPlane.evaluateIsZero(thePoint)) {\n      // Use the XY plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -thePoint.x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -thePoint.y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -thePoint.z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n      final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.MAX_VALUE;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XIntersectionsY) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XIntersectionsZ) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsX) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsZ) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsX) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsY) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.MAX_VALUE : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, testPoint, thePoint, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dc71a6ca063b508a28bf5b68fedf25a945572a0","date":1462433813,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(Vector).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(Vector).mjava","sourceNew":"  @Override\n  public boolean isWithin(final Vector thePoint) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(thePoint)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYPlane.evaluateIsZero(thePoint)) {\n      // Use the XZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXPlane.evaluateIsZero(thePoint)) {\n      // Use the YZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZPlane.evaluateIsZero(thePoint)) {\n      // Use the XY plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -thePoint.x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -thePoint.y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -thePoint.z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n      final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.MAX_VALUE;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XIntersectionsY) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XIntersectionsZ) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsX) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsZ) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsX) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsY) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.MAX_VALUE : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, thePoint, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","sourceOld":"  @Override\n  public boolean isWithin(final Vector thePoint) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(thePoint)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYPlane.evaluateIsZero(thePoint)) {\n      // Use the XZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXPlane.evaluateIsZero(thePoint)) {\n      // Use the YZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZPlane.evaluateIsZero(thePoint)) {\n      // Use the XY plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -thePoint.x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -thePoint.y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -thePoint.z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n      final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.MAX_VALUE;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XIntersectionsY) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XIntersectionsZ) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsX) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsZ) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsX) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsY) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.MAX_VALUE : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, testPoint, thePoint, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f9f156572c6e1245055b705603088061b42ab3a1","date":1462449249,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(Vector).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(Vector).mjava","sourceNew":"  @Override\n  public boolean isWithin(final Vector thePoint) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(thePoint)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYPlane.evaluateIsZero(thePoint)) {\n      // Use the XZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, thePoint);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXPlane.evaluateIsZero(thePoint)) {\n      // Use the YZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, thePoint);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZPlane.evaluateIsZero(thePoint)) {\n      // Use the XY plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, thePoint);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -thePoint.x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -thePoint.y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -thePoint.z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n      final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.MAX_VALUE;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XIntersectionsY) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = thePoint.y - p.y;\n        final double cpDelta2 = thePoint.z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XIntersectionsZ) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = thePoint.y - p.y;\n        final double cpDelta2 = thePoint.z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsX) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = thePoint.x - p.x;\n        final double cpDelta2 = thePoint.z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsZ) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = thePoint.x - p.x;\n        final double cpDelta2 = thePoint.z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsX) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = thePoint.y - p.y;\n        final double cpDelta2 = thePoint.x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsY) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = thePoint.y - p.y;\n        final double cpDelta2 = thePoint.x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.MAX_VALUE : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, thePoint, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","sourceOld":"  @Override\n  public boolean isWithin(final Vector thePoint) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(thePoint)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYPlane.evaluateIsZero(thePoint)) {\n      // Use the XZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXPlane.evaluateIsZero(thePoint)) {\n      // Use the YZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZPlane.evaluateIsZero(thePoint)) {\n      // Use the XY plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -thePoint.x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -thePoint.y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -thePoint.z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n      final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.MAX_VALUE;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XIntersectionsY) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XIntersectionsZ) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsX) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsZ) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsX) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsY) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.MAX_VALUE : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, thePoint, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7dc08f02757dd10637b16a5c65eaaef839a91a9a","date":1462455462,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(Vector).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(Vector).mjava","sourceNew":"  @Override\n  public boolean isWithin(final Vector thePoint) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(thePoint)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYPlane.evaluateIsZero(thePoint)) {\n      // Use the XZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, thePoint);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXPlane.evaluateIsZero(thePoint)) {\n      // Use the YZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, thePoint);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZPlane.evaluateIsZero(thePoint)) {\n      // Use the XY plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, thePoint);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -thePoint.x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -thePoint.y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -thePoint.z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n      final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.MAX_VALUE;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XIntersectionsY) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = thePoint.y - p.y;\n        final double cpDelta2 = thePoint.z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XIntersectionsZ) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = thePoint.y - p.y;\n        final double cpDelta2 = thePoint.z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsX) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = thePoint.x - p.x;\n        final double cpDelta2 = thePoint.z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsZ) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = thePoint.x - p.x;\n        final double cpDelta2 = thePoint.z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsX) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = thePoint.y - p.y;\n        final double cpDelta2 = thePoint.x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsY) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = thePoint.y - p.y;\n        final double cpDelta2 = thePoint.x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.MAX_VALUE : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, thePoint, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","sourceOld":"  @Override\n  public boolean isWithin(final Vector thePoint) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(thePoint)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYPlane.evaluateIsZero(thePoint)) {\n      // Use the XZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXPlane.evaluateIsZero(thePoint)) {\n      // Use the YZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZPlane.evaluateIsZero(thePoint)) {\n      // Use the XY plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -thePoint.x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -thePoint.y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -thePoint.z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n      final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.MAX_VALUE;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XIntersectionsY) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XIntersectionsZ) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsX) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsZ) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsX) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsY) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.MAX_VALUE : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, testPoint, thePoint, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7fe41964e49958f662028ea7ed8c224e0955edae","date":1462534610,"type":4,"author":"Karl Wright","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(Vector).mjava","sourceNew":null,"sourceOld":"  @Override\n  public boolean isWithin(final Vector thePoint) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(thePoint)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYPlane.evaluateIsZero(thePoint)) {\n      // Use the XZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, thePoint);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXPlane.evaluateIsZero(thePoint)) {\n      // Use the YZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, thePoint);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZPlane.evaluateIsZero(thePoint)) {\n      // Use the XY plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, thePoint);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -thePoint.x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -thePoint.y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -thePoint.z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n      final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.MAX_VALUE;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XIntersectionsY) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = thePoint.y - p.y;\n        final double cpDelta2 = thePoint.z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XIntersectionsZ) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = thePoint.y - p.y;\n        final double cpDelta2 = thePoint.z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsX) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = thePoint.x - p.x;\n        final double cpDelta2 = thePoint.z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsZ) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = thePoint.x - p.x;\n        final double cpDelta2 = thePoint.z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsX) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = thePoint.y - p.y;\n        final double cpDelta2 = thePoint.x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsY) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = thePoint.y - p.y;\n        final double cpDelta2 = thePoint.x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.MAX_VALUE : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, thePoint, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","date":1462576651,"type":4,"author":"Mike McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(Vector).mjava","sourceNew":null,"sourceOld":"  @Override\n  public boolean isWithin(final Vector thePoint) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(thePoint)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYPlane.evaluateIsZero(thePoint)) {\n      // Use the XZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXPlane.evaluateIsZero(thePoint)) {\n      // Use the YZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZPlane.evaluateIsZero(thePoint)) {\n      // Use the XY plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, testPoint, thePoint);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -thePoint.x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -thePoint.y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -thePoint.z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n      final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.MAX_VALUE;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XIntersectionsY) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XIntersectionsZ) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsX) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsZ) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsX) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsY) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.MAX_VALUE : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, testPoint, thePoint, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":4,"author":"Kevin Risden","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(Vector).mjava","sourceNew":null,"sourceOld":"  @Override\n  public boolean isWithin(final Vector thePoint) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(thePoint)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYPlane.evaluateIsZero(thePoint)) {\n      // Use the XZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, thePoint);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXPlane.evaluateIsZero(thePoint)) {\n      // Use the YZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, thePoint);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZPlane.evaluateIsZero(thePoint)) {\n      // Use the XY plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, thePoint);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -thePoint.x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -thePoint.y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -thePoint.z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n      final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.MAX_VALUE;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XIntersectionsY) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = thePoint.y - p.y;\n        final double cpDelta2 = thePoint.z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XIntersectionsZ) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = thePoint.y - p.y;\n        final double cpDelta2 = thePoint.z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.x;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsX) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = thePoint.x - p.x;\n        final double cpDelta2 = thePoint.z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsZ) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = thePoint.x - p.x;\n        final double cpDelta2 = thePoint.z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = thePoint.y;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsX) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = thePoint.y - p.y;\n        final double cpDelta2 = thePoint.x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsY) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = thePoint.y - p.y;\n        final double cpDelta2 = thePoint.x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = thePoint.z;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.MAX_VALUE : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, thePoint, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3dc71a6ca063b508a28bf5b68fedf25a945572a0":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"43631d6552f924eb58c0b507e3e10215c53754f8":["5b3ccbc7c0d21f9643de6c5c7894f67336dcb57a"],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":["55b50463286869f584cf849d1587a0fcd54d1dfa","f9f156572c6e1245055b705603088061b42ab3a1"],"f9f156572c6e1245055b705603088061b42ab3a1":["3dc71a6ca063b508a28bf5b68fedf25a945572a0"],"8ff44d836e8863507fa8711d2b1b2dd723516ca0":["e6f1382358fb94a408ebd8bbb00135f2a83f4d66"],"e6f1382358fb94a408ebd8bbb00135f2a83f4d66":["116824c1b3f14f43f9a77914fbf6f0d70a5b7c89"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7dc08f02757dd10637b16a5c65eaaef839a91a9a","7fe41964e49958f662028ea7ed8c224e0955edae"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0","7fe41964e49958f662028ea7ed8c224e0955edae"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"265e2d0799e876e7c751a97229b0d8007cd79f0a":["8ff44d836e8863507fa8711d2b1b2dd723516ca0"],"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","414d7bcd2f513d7e7162dae022e9a9f3cd930277"],"414d7bcd2f513d7e7162dae022e9a9f3cd930277":["4e36ad3a30dae8fc4711af30a236d83d6aa57c0f"],"7fe41964e49958f662028ea7ed8c224e0955edae":["f9f156572c6e1245055b705603088061b42ab3a1"],"5b3ccbc7c0d21f9643de6c5c7894f67336dcb57a":["265e2d0799e876e7c751a97229b0d8007cd79f0a"],"116824c1b3f14f43f9a77914fbf6f0d70a5b7c89":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7fe41964e49958f662028ea7ed8c224e0955edae"],"4e36ad3a30dae8fc4711af30a236d83d6aa57c0f":["43631d6552f924eb58c0b507e3e10215c53754f8"]},"commit2Childs":{"3dc71a6ca063b508a28bf5b68fedf25a945572a0":["f9f156572c6e1245055b705603088061b42ab3a1"],"43631d6552f924eb58c0b507e3e10215c53754f8":["4e36ad3a30dae8fc4711af30a236d83d6aa57c0f"],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"f9f156572c6e1245055b705603088061b42ab3a1":["7dc08f02757dd10637b16a5c65eaaef839a91a9a","7fe41964e49958f662028ea7ed8c224e0955edae"],"8ff44d836e8863507fa8711d2b1b2dd723516ca0":["265e2d0799e876e7c751a97229b0d8007cd79f0a"],"e6f1382358fb94a408ebd8bbb00135f2a83f4d66":["8ff44d836e8863507fa8711d2b1b2dd723516ca0"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"55b50463286869f584cf849d1587a0fcd54d1dfa":["7dc08f02757dd10637b16a5c65eaaef839a91a9a"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["55b50463286869f584cf849d1587a0fcd54d1dfa","c46db27f3364a67a1c77a0f4e462cc7c5b4147f0","116824c1b3f14f43f9a77914fbf6f0d70a5b7c89"],"265e2d0799e876e7c751a97229b0d8007cd79f0a":["5b3ccbc7c0d21f9643de6c5c7894f67336dcb57a"],"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0":["3dc71a6ca063b508a28bf5b68fedf25a945572a0","55b50463286869f584cf849d1587a0fcd54d1dfa","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904"],"414d7bcd2f513d7e7162dae022e9a9f3cd930277":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"5b3ccbc7c0d21f9643de6c5c7894f67336dcb57a":["43631d6552f924eb58c0b507e3e10215c53754f8"],"7fe41964e49958f662028ea7ed8c224e0955edae":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"116824c1b3f14f43f9a77914fbf6f0d70a5b7c89":["e6f1382358fb94a408ebd8bbb00135f2a83f4d66"],"4e36ad3a30dae8fc4711af30a236d83d6aa57c0f":["414d7bcd2f513d7e7162dae022e9a9f3cd930277"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}