{"path":"lucene/spatial-extras/src/test/org/apache/lucene/spatial/prefix/RandomSpatialOpFuzzyPrefixTreeTest#doTest(SpatialOperation).mjava","commits":[{"id":"112d77ac8d3e10a362516ad834c9a11d35c94234","date":1456784319,"type":1,"author":"nknize","isMerge":false,"pathNew":"lucene/spatial-extras/src/test/org/apache/lucene/spatial/prefix/RandomSpatialOpFuzzyPrefixTreeTest#doTest(SpatialOperation).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/RandomSpatialOpFuzzyPrefixTreeTest#doTest(SpatialOperation).mjava","sourceNew":"  @SuppressWarnings(\"fallthrough\")\n  private void doTest(final SpatialOperation operation) throws IOException {\n    //first show that when there's no data, a query will result in no results\n    {\n      Query query = strategy.makeQuery(new SpatialArgs(operation, randomRectangle()));\n      SearchResults searchResults = executeQuery(query, 1);\n      assertEquals(0, searchResults.numFound);\n    }\n\n    final boolean biasContains = (operation == SpatialOperation.Contains);\n\n    //Main index loop:\n    Map<String, Shape> indexedShapes = new LinkedHashMap<>();\n    Map<String, Shape> indexedShapesGS = new LinkedHashMap<>();//grid snapped\n    final int numIndexedShapes = randomIntBetween(1, 6);\n    boolean indexedAtLeastOneShapePair = false;\n    final boolean pointsOnly = ((PrefixTreeStrategy) strategy).isPointsOnly();\n    for (int i = 0; i < numIndexedShapes; i++) {\n      String id = \"\" + i;\n      Shape indexedShape;\n      int R = random().nextInt(12);\n      if (R == 0) {//1 in 12\n        indexedShape = null;\n      } else if (R == 1 || pointsOnly) {//1 in 12\n        indexedShape = randomPoint();//just one point\n      } else if (R <= 4) {//3 in 12\n        //comprised of more than one shape\n        indexedShape = randomShapePairRect(biasContains);\n        indexedAtLeastOneShapePair = true;\n      } else {\n        indexedShape = randomRectangle();//just one rect\n      }\n\n      indexedShapes.put(id, indexedShape);\n      indexedShapesGS.put(id, gridSnap(indexedShape));\n\n      adoc(id, indexedShape);\n\n      if (random().nextInt(10) == 0)\n        commit();//intermediate commit, produces extra segments\n\n    }\n    //delete some documents randomly\n    Iterator<String> idIter = indexedShapes.keySet().iterator();\n    while (idIter.hasNext()) {\n      String id = idIter.next();\n      if (random().nextInt(10) == 0) {\n        deleteDoc(id);\n        idIter.remove();\n        indexedShapesGS.remove(id);\n      }\n    }\n\n    commit();\n\n    //Main query loop:\n    final int numQueryShapes = atLeast(20);\n    for (int i = 0; i < numQueryShapes; i++) {\n      int scanLevel = randomInt(grid.getMaxLevels());\n      ((RecursivePrefixTreeStrategy) strategy).setPrefixGridScanLevel(scanLevel);\n\n      final Shape queryShape;\n      switch (randomInt(10)) {\n        case 0: queryShape = randomPoint(); break;\n// LUCENE-5549\n//TODO debug: -Dtests.method=testWithin -Dtests.multiplier=3 -Dtests.seed=5F5294CE2E075A3E:AAD2F0F79288CA64\n//        case 1:case 2:case 3:\n//          if (!indexedAtLeastOneShapePair) { // avoids ShapePair.relate(ShapePair), which isn't reliable\n//            queryShape = randomShapePairRect(!biasContains);//invert biasContains for query side\n//            break;\n//          }\n\n        case 4:\n          //choose an existing indexed shape\n          if (!indexedShapes.isEmpty()) {\n            Shape tmp = indexedShapes.values().iterator().next();\n            if (tmp instanceof Point || tmp instanceof Rectangle) {//avoids null and shapePair\n              queryShape = tmp;\n              break;\n            }\n          }//else fall-through\n\n        default: queryShape = randomRectangle();\n      }\n      final Shape queryShapeGS = gridSnap(queryShape);\n\n      final boolean opIsDisjoint = operation == SpatialOperation.IsDisjointTo;\n\n      //Generate truth via brute force:\n      // We ensure true-positive matches (if the predicate on the raw shapes match\n      //  then the search should find those same matches).\n      // approximations, false-positive matches\n      Set<String> expectedIds = new LinkedHashSet<>();//true-positives\n      Set<String> secondaryIds = new LinkedHashSet<>();//false-positives (unless disjoint)\n      for (Map.Entry<String, Shape> entry : indexedShapes.entrySet()) {\n        String id = entry.getKey();\n        Shape indexedShapeCompare = entry.getValue();\n        if (indexedShapeCompare == null)\n          continue;\n        Shape queryShapeCompare = queryShape;\n\n        if (operation.evaluate(indexedShapeCompare, queryShapeCompare)) {\n          expectedIds.add(id);\n          if (opIsDisjoint) {\n            //if no longer intersect after buffering them, for disjoint, remember this\n            indexedShapeCompare = indexedShapesGS.get(id);\n            queryShapeCompare = queryShapeGS;\n            if (!operation.evaluate(indexedShapeCompare, queryShapeCompare))\n              secondaryIds.add(id);\n          }\n        } else if (!opIsDisjoint) {\n          //buffer either the indexed or query shape (via gridSnap) and try again\n          if (operation == SpatialOperation.Intersects) {\n            indexedShapeCompare = indexedShapesGS.get(id);\n            queryShapeCompare = queryShapeGS;\n            //TODO Unfortunately, grid-snapping both can result in intersections that otherwise\n            // wouldn't happen when the grids are adjacent. Not a big deal but our test is just a\n            // bit more lenient.\n          } else if (operation == SpatialOperation.Contains) {\n            indexedShapeCompare = indexedShapesGS.get(id);\n          } else if (operation == SpatialOperation.IsWithin) {\n            queryShapeCompare = queryShapeGS;\n          }\n          if (operation.evaluate(indexedShapeCompare, queryShapeCompare))\n            secondaryIds.add(id);\n        }\n      }\n\n      //Search and verify results\n      SpatialArgs args = new SpatialArgs(operation, queryShape);\n      if (queryShape instanceof ShapePair)\n        args.setDistErrPct(0.0);//a hack; we want to be more detailed than gridSnap(queryShape)\n      Query query = strategy.makeQuery(args);\n      SearchResults got = executeQuery(query, 100);\n      Set<String> remainingExpectedIds = new LinkedHashSet<>(expectedIds);\n      for (SearchResult result : got.results) {\n        String id = result.getId();\n        boolean removed = remainingExpectedIds.remove(id);\n        if (!removed && (!opIsDisjoint && !secondaryIds.contains(id))) {\n          fail(\"Shouldn't match\", id, indexedShapes, indexedShapesGS, queryShape);\n        }\n      }\n      if (opIsDisjoint)\n        remainingExpectedIds.removeAll(secondaryIds);\n      if (!remainingExpectedIds.isEmpty()) {\n        String id = remainingExpectedIds.iterator().next();\n        fail(\"Should have matched\", id, indexedShapes, indexedShapesGS, queryShape);\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"fallthrough\")\n  private void doTest(final SpatialOperation operation) throws IOException {\n    //first show that when there's no data, a query will result in no results\n    {\n      Query query = strategy.makeQuery(new SpatialArgs(operation, randomRectangle()));\n      SearchResults searchResults = executeQuery(query, 1);\n      assertEquals(0, searchResults.numFound);\n    }\n\n    final boolean biasContains = (operation == SpatialOperation.Contains);\n\n    //Main index loop:\n    Map<String, Shape> indexedShapes = new LinkedHashMap<>();\n    Map<String, Shape> indexedShapesGS = new LinkedHashMap<>();//grid snapped\n    final int numIndexedShapes = randomIntBetween(1, 6);\n    boolean indexedAtLeastOneShapePair = false;\n    final boolean pointsOnly = ((PrefixTreeStrategy) strategy).isPointsOnly();\n    for (int i = 0; i < numIndexedShapes; i++) {\n      String id = \"\" + i;\n      Shape indexedShape;\n      int R = random().nextInt(12);\n      if (R == 0) {//1 in 12\n        indexedShape = null;\n      } else if (R == 1 || pointsOnly) {//1 in 12\n        indexedShape = randomPoint();//just one point\n      } else if (R <= 4) {//3 in 12\n        //comprised of more than one shape\n        indexedShape = randomShapePairRect(biasContains);\n        indexedAtLeastOneShapePair = true;\n      } else {\n        indexedShape = randomRectangle();//just one rect\n      }\n\n      indexedShapes.put(id, indexedShape);\n      indexedShapesGS.put(id, gridSnap(indexedShape));\n\n      adoc(id, indexedShape);\n\n      if (random().nextInt(10) == 0)\n        commit();//intermediate commit, produces extra segments\n\n    }\n    //delete some documents randomly\n    Iterator<String> idIter = indexedShapes.keySet().iterator();\n    while (idIter.hasNext()) {\n      String id = idIter.next();\n      if (random().nextInt(10) == 0) {\n        deleteDoc(id);\n        idIter.remove();\n        indexedShapesGS.remove(id);\n      }\n    }\n\n    commit();\n\n    //Main query loop:\n    final int numQueryShapes = atLeast(20);\n    for (int i = 0; i < numQueryShapes; i++) {\n      int scanLevel = randomInt(grid.getMaxLevels());\n      ((RecursivePrefixTreeStrategy) strategy).setPrefixGridScanLevel(scanLevel);\n\n      final Shape queryShape;\n      switch (randomInt(10)) {\n        case 0: queryShape = randomPoint(); break;\n// LUCENE-5549\n//TODO debug: -Dtests.method=testWithin -Dtests.multiplier=3 -Dtests.seed=5F5294CE2E075A3E:AAD2F0F79288CA64\n//        case 1:case 2:case 3:\n//          if (!indexedAtLeastOneShapePair) { // avoids ShapePair.relate(ShapePair), which isn't reliable\n//            queryShape = randomShapePairRect(!biasContains);//invert biasContains for query side\n//            break;\n//          }\n\n        case 4:\n          //choose an existing indexed shape\n          if (!indexedShapes.isEmpty()) {\n            Shape tmp = indexedShapes.values().iterator().next();\n            if (tmp instanceof Point || tmp instanceof Rectangle) {//avoids null and shapePair\n              queryShape = tmp;\n              break;\n            }\n          }//else fall-through\n\n        default: queryShape = randomRectangle();\n      }\n      final Shape queryShapeGS = gridSnap(queryShape);\n\n      final boolean opIsDisjoint = operation == SpatialOperation.IsDisjointTo;\n\n      //Generate truth via brute force:\n      // We ensure true-positive matches (if the predicate on the raw shapes match\n      //  then the search should find those same matches).\n      // approximations, false-positive matches\n      Set<String> expectedIds = new LinkedHashSet<>();//true-positives\n      Set<String> secondaryIds = new LinkedHashSet<>();//false-positives (unless disjoint)\n      for (Map.Entry<String, Shape> entry : indexedShapes.entrySet()) {\n        String id = entry.getKey();\n        Shape indexedShapeCompare = entry.getValue();\n        if (indexedShapeCompare == null)\n          continue;\n        Shape queryShapeCompare = queryShape;\n\n        if (operation.evaluate(indexedShapeCompare, queryShapeCompare)) {\n          expectedIds.add(id);\n          if (opIsDisjoint) {\n            //if no longer intersect after buffering them, for disjoint, remember this\n            indexedShapeCompare = indexedShapesGS.get(id);\n            queryShapeCompare = queryShapeGS;\n            if (!operation.evaluate(indexedShapeCompare, queryShapeCompare))\n              secondaryIds.add(id);\n          }\n        } else if (!opIsDisjoint) {\n          //buffer either the indexed or query shape (via gridSnap) and try again\n          if (operation == SpatialOperation.Intersects) {\n            indexedShapeCompare = indexedShapesGS.get(id);\n            queryShapeCompare = queryShapeGS;\n            //TODO Unfortunately, grid-snapping both can result in intersections that otherwise\n            // wouldn't happen when the grids are adjacent. Not a big deal but our test is just a\n            // bit more lenient.\n          } else if (operation == SpatialOperation.Contains) {\n            indexedShapeCompare = indexedShapesGS.get(id);\n          } else if (operation == SpatialOperation.IsWithin) {\n            queryShapeCompare = queryShapeGS;\n          }\n          if (operation.evaluate(indexedShapeCompare, queryShapeCompare))\n            secondaryIds.add(id);\n        }\n      }\n\n      //Search and verify results\n      SpatialArgs args = new SpatialArgs(operation, queryShape);\n      if (queryShape instanceof ShapePair)\n        args.setDistErrPct(0.0);//a hack; we want to be more detailed than gridSnap(queryShape)\n      Query query = strategy.makeQuery(args);\n      SearchResults got = executeQuery(query, 100);\n      Set<String> remainingExpectedIds = new LinkedHashSet<>(expectedIds);\n      for (SearchResult result : got.results) {\n        String id = result.getId();\n        boolean removed = remainingExpectedIds.remove(id);\n        if (!removed && (!opIsDisjoint && !secondaryIds.contains(id))) {\n          fail(\"Shouldn't match\", id, indexedShapes, indexedShapesGS, queryShape);\n        }\n      }\n      if (opIsDisjoint)\n        remainingExpectedIds.removeAll(secondaryIds);\n      if (!remainingExpectedIds.isEmpty()) {\n        String id = remainingExpectedIds.iterator().next();\n        fail(\"Should have matched\", id, indexedShapes, indexedShapesGS, queryShape);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":1,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial-extras/src/test/org/apache/lucene/spatial/prefix/RandomSpatialOpFuzzyPrefixTreeTest#doTest(SpatialOperation).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/RandomSpatialOpFuzzyPrefixTreeTest#doTest(SpatialOperation).mjava","sourceNew":"  @SuppressWarnings(\"fallthrough\")\n  private void doTest(final SpatialOperation operation) throws IOException {\n    //first show that when there's no data, a query will result in no results\n    {\n      Query query = strategy.makeQuery(new SpatialArgs(operation, randomRectangle()));\n      SearchResults searchResults = executeQuery(query, 1);\n      assertEquals(0, searchResults.numFound);\n    }\n\n    final boolean biasContains = (operation == SpatialOperation.Contains);\n\n    //Main index loop:\n    Map<String, Shape> indexedShapes = new LinkedHashMap<>();\n    Map<String, Shape> indexedShapesGS = new LinkedHashMap<>();//grid snapped\n    final int numIndexedShapes = randomIntBetween(1, 6);\n    boolean indexedAtLeastOneShapePair = false;\n    final boolean pointsOnly = ((PrefixTreeStrategy) strategy).isPointsOnly();\n    for (int i = 0; i < numIndexedShapes; i++) {\n      String id = \"\" + i;\n      Shape indexedShape;\n      int R = random().nextInt(12);\n      if (R == 0) {//1 in 12\n        indexedShape = null;\n      } else if (R == 1 || pointsOnly) {//1 in 12\n        indexedShape = randomPoint();//just one point\n      } else if (R <= 4) {//3 in 12\n        //comprised of more than one shape\n        indexedShape = randomShapePairRect(biasContains);\n        indexedAtLeastOneShapePair = true;\n      } else {\n        indexedShape = randomRectangle();//just one rect\n      }\n\n      indexedShapes.put(id, indexedShape);\n      indexedShapesGS.put(id, gridSnap(indexedShape));\n\n      adoc(id, indexedShape);\n\n      if (random().nextInt(10) == 0)\n        commit();//intermediate commit, produces extra segments\n\n    }\n    //delete some documents randomly\n    Iterator<String> idIter = indexedShapes.keySet().iterator();\n    while (idIter.hasNext()) {\n      String id = idIter.next();\n      if (random().nextInt(10) == 0) {\n        deleteDoc(id);\n        idIter.remove();\n        indexedShapesGS.remove(id);\n      }\n    }\n\n    commit();\n\n    //Main query loop:\n    final int numQueryShapes = atLeast(20);\n    for (int i = 0; i < numQueryShapes; i++) {\n      int scanLevel = randomInt(grid.getMaxLevels());\n      ((RecursivePrefixTreeStrategy) strategy).setPrefixGridScanLevel(scanLevel);\n\n      final Shape queryShape;\n      switch (randomInt(10)) {\n        case 0: queryShape = randomPoint(); break;\n// LUCENE-5549\n//TODO debug: -Dtests.method=testWithin -Dtests.multiplier=3 -Dtests.seed=5F5294CE2E075A3E:AAD2F0F79288CA64\n//        case 1:case 2:case 3:\n//          if (!indexedAtLeastOneShapePair) { // avoids ShapePair.relate(ShapePair), which isn't reliable\n//            queryShape = randomShapePairRect(!biasContains);//invert biasContains for query side\n//            break;\n//          }\n\n        case 4:\n          //choose an existing indexed shape\n          if (!indexedShapes.isEmpty()) {\n            Shape tmp = indexedShapes.values().iterator().next();\n            if (tmp instanceof Point || tmp instanceof Rectangle) {//avoids null and shapePair\n              queryShape = tmp;\n              break;\n            }\n          }//else fall-through\n\n        default: queryShape = randomRectangle();\n      }\n      final Shape queryShapeGS = gridSnap(queryShape);\n\n      final boolean opIsDisjoint = operation == SpatialOperation.IsDisjointTo;\n\n      //Generate truth via brute force:\n      // We ensure true-positive matches (if the predicate on the raw shapes match\n      //  then the search should find those same matches).\n      // approximations, false-positive matches\n      Set<String> expectedIds = new LinkedHashSet<>();//true-positives\n      Set<String> secondaryIds = new LinkedHashSet<>();//false-positives (unless disjoint)\n      for (Map.Entry<String, Shape> entry : indexedShapes.entrySet()) {\n        String id = entry.getKey();\n        Shape indexedShapeCompare = entry.getValue();\n        if (indexedShapeCompare == null)\n          continue;\n        Shape queryShapeCompare = queryShape;\n\n        if (operation.evaluate(indexedShapeCompare, queryShapeCompare)) {\n          expectedIds.add(id);\n          if (opIsDisjoint) {\n            //if no longer intersect after buffering them, for disjoint, remember this\n            indexedShapeCompare = indexedShapesGS.get(id);\n            queryShapeCompare = queryShapeGS;\n            if (!operation.evaluate(indexedShapeCompare, queryShapeCompare))\n              secondaryIds.add(id);\n          }\n        } else if (!opIsDisjoint) {\n          //buffer either the indexed or query shape (via gridSnap) and try again\n          if (operation == SpatialOperation.Intersects) {\n            indexedShapeCompare = indexedShapesGS.get(id);\n            queryShapeCompare = queryShapeGS;\n            //TODO Unfortunately, grid-snapping both can result in intersections that otherwise\n            // wouldn't happen when the grids are adjacent. Not a big deal but our test is just a\n            // bit more lenient.\n          } else if (operation == SpatialOperation.Contains) {\n            indexedShapeCompare = indexedShapesGS.get(id);\n          } else if (operation == SpatialOperation.IsWithin) {\n            queryShapeCompare = queryShapeGS;\n          }\n          if (operation.evaluate(indexedShapeCompare, queryShapeCompare))\n            secondaryIds.add(id);\n        }\n      }\n\n      //Search and verify results\n      SpatialArgs args = new SpatialArgs(operation, queryShape);\n      if (queryShape instanceof ShapePair)\n        args.setDistErrPct(0.0);//a hack; we want to be more detailed than gridSnap(queryShape)\n      Query query = strategy.makeQuery(args);\n      SearchResults got = executeQuery(query, 100);\n      Set<String> remainingExpectedIds = new LinkedHashSet<>(expectedIds);\n      for (SearchResult result : got.results) {\n        String id = result.getId();\n        boolean removed = remainingExpectedIds.remove(id);\n        if (!removed && (!opIsDisjoint && !secondaryIds.contains(id))) {\n          fail(\"Shouldn't match\", id, indexedShapes, indexedShapesGS, queryShape);\n        }\n      }\n      if (opIsDisjoint)\n        remainingExpectedIds.removeAll(secondaryIds);\n      if (!remainingExpectedIds.isEmpty()) {\n        String id = remainingExpectedIds.iterator().next();\n        fail(\"Should have matched\", id, indexedShapes, indexedShapesGS, queryShape);\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"fallthrough\")\n  private void doTest(final SpatialOperation operation) throws IOException {\n    //first show that when there's no data, a query will result in no results\n    {\n      Query query = strategy.makeQuery(new SpatialArgs(operation, randomRectangle()));\n      SearchResults searchResults = executeQuery(query, 1);\n      assertEquals(0, searchResults.numFound);\n    }\n\n    final boolean biasContains = (operation == SpatialOperation.Contains);\n\n    //Main index loop:\n    Map<String, Shape> indexedShapes = new LinkedHashMap<>();\n    Map<String, Shape> indexedShapesGS = new LinkedHashMap<>();//grid snapped\n    final int numIndexedShapes = randomIntBetween(1, 6);\n    boolean indexedAtLeastOneShapePair = false;\n    final boolean pointsOnly = ((PrefixTreeStrategy) strategy).isPointsOnly();\n    for (int i = 0; i < numIndexedShapes; i++) {\n      String id = \"\" + i;\n      Shape indexedShape;\n      int R = random().nextInt(12);\n      if (R == 0) {//1 in 12\n        indexedShape = null;\n      } else if (R == 1 || pointsOnly) {//1 in 12\n        indexedShape = randomPoint();//just one point\n      } else if (R <= 4) {//3 in 12\n        //comprised of more than one shape\n        indexedShape = randomShapePairRect(biasContains);\n        indexedAtLeastOneShapePair = true;\n      } else {\n        indexedShape = randomRectangle();//just one rect\n      }\n\n      indexedShapes.put(id, indexedShape);\n      indexedShapesGS.put(id, gridSnap(indexedShape));\n\n      adoc(id, indexedShape);\n\n      if (random().nextInt(10) == 0)\n        commit();//intermediate commit, produces extra segments\n\n    }\n    //delete some documents randomly\n    Iterator<String> idIter = indexedShapes.keySet().iterator();\n    while (idIter.hasNext()) {\n      String id = idIter.next();\n      if (random().nextInt(10) == 0) {\n        deleteDoc(id);\n        idIter.remove();\n        indexedShapesGS.remove(id);\n      }\n    }\n\n    commit();\n\n    //Main query loop:\n    final int numQueryShapes = atLeast(20);\n    for (int i = 0; i < numQueryShapes; i++) {\n      int scanLevel = randomInt(grid.getMaxLevels());\n      ((RecursivePrefixTreeStrategy) strategy).setPrefixGridScanLevel(scanLevel);\n\n      final Shape queryShape;\n      switch (randomInt(10)) {\n        case 0: queryShape = randomPoint(); break;\n// LUCENE-5549\n//TODO debug: -Dtests.method=testWithin -Dtests.multiplier=3 -Dtests.seed=5F5294CE2E075A3E:AAD2F0F79288CA64\n//        case 1:case 2:case 3:\n//          if (!indexedAtLeastOneShapePair) { // avoids ShapePair.relate(ShapePair), which isn't reliable\n//            queryShape = randomShapePairRect(!biasContains);//invert biasContains for query side\n//            break;\n//          }\n\n        case 4:\n          //choose an existing indexed shape\n          if (!indexedShapes.isEmpty()) {\n            Shape tmp = indexedShapes.values().iterator().next();\n            if (tmp instanceof Point || tmp instanceof Rectangle) {//avoids null and shapePair\n              queryShape = tmp;\n              break;\n            }\n          }//else fall-through\n\n        default: queryShape = randomRectangle();\n      }\n      final Shape queryShapeGS = gridSnap(queryShape);\n\n      final boolean opIsDisjoint = operation == SpatialOperation.IsDisjointTo;\n\n      //Generate truth via brute force:\n      // We ensure true-positive matches (if the predicate on the raw shapes match\n      //  then the search should find those same matches).\n      // approximations, false-positive matches\n      Set<String> expectedIds = new LinkedHashSet<>();//true-positives\n      Set<String> secondaryIds = new LinkedHashSet<>();//false-positives (unless disjoint)\n      for (Map.Entry<String, Shape> entry : indexedShapes.entrySet()) {\n        String id = entry.getKey();\n        Shape indexedShapeCompare = entry.getValue();\n        if (indexedShapeCompare == null)\n          continue;\n        Shape queryShapeCompare = queryShape;\n\n        if (operation.evaluate(indexedShapeCompare, queryShapeCompare)) {\n          expectedIds.add(id);\n          if (opIsDisjoint) {\n            //if no longer intersect after buffering them, for disjoint, remember this\n            indexedShapeCompare = indexedShapesGS.get(id);\n            queryShapeCompare = queryShapeGS;\n            if (!operation.evaluate(indexedShapeCompare, queryShapeCompare))\n              secondaryIds.add(id);\n          }\n        } else if (!opIsDisjoint) {\n          //buffer either the indexed or query shape (via gridSnap) and try again\n          if (operation == SpatialOperation.Intersects) {\n            indexedShapeCompare = indexedShapesGS.get(id);\n            queryShapeCompare = queryShapeGS;\n            //TODO Unfortunately, grid-snapping both can result in intersections that otherwise\n            // wouldn't happen when the grids are adjacent. Not a big deal but our test is just a\n            // bit more lenient.\n          } else if (operation == SpatialOperation.Contains) {\n            indexedShapeCompare = indexedShapesGS.get(id);\n          } else if (operation == SpatialOperation.IsWithin) {\n            queryShapeCompare = queryShapeGS;\n          }\n          if (operation.evaluate(indexedShapeCompare, queryShapeCompare))\n            secondaryIds.add(id);\n        }\n      }\n\n      //Search and verify results\n      SpatialArgs args = new SpatialArgs(operation, queryShape);\n      if (queryShape instanceof ShapePair)\n        args.setDistErrPct(0.0);//a hack; we want to be more detailed than gridSnap(queryShape)\n      Query query = strategy.makeQuery(args);\n      SearchResults got = executeQuery(query, 100);\n      Set<String> remainingExpectedIds = new LinkedHashSet<>(expectedIds);\n      for (SearchResult result : got.results) {\n        String id = result.getId();\n        boolean removed = remainingExpectedIds.remove(id);\n        if (!removed && (!opIsDisjoint && !secondaryIds.contains(id))) {\n          fail(\"Shouldn't match\", id, indexedShapes, indexedShapesGS, queryShape);\n        }\n      }\n      if (opIsDisjoint)\n        remainingExpectedIds.removeAll(secondaryIds);\n      if (!remainingExpectedIds.isEmpty()) {\n        String id = remainingExpectedIds.iterator().next();\n        fail(\"Should have matched\", id, indexedShapes, indexedShapesGS, queryShape);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"af2638813028b254a88b418ebeafb541afb49653":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","112d77ac8d3e10a362516ad834c9a11d35c94234"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"112d77ac8d3e10a362516ad834c9a11d35c94234":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["af2638813028b254a88b418ebeafb541afb49653"]},"commit2Childs":{"af2638813028b254a88b418ebeafb541afb49653":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["af2638813028b254a88b418ebeafb541afb49653","112d77ac8d3e10a362516ad834c9a11d35c94234"],"112d77ac8d3e10a362516ad834c9a11d35c94234":["af2638813028b254a88b418ebeafb541afb49653"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}