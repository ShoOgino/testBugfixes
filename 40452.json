{"path":"lucene/expressions/src/java/org/apache/lucene/expressions/SimpleBindings#validate().mjava","commits":[{"id":"c4a2e0e19d6ee2740632e97e6248b49b1f6df7fb","date":1379734663,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/SimpleBindings#validate().mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/Bindings#validate().mjava","sourceNew":"  /** \n   * Traverses the graph of bindings, checking there are no cycles or missing references \n   * @throws IllegalArgumentException if the bindings is inconsistent \n   */\n  public void validate() {\n    for (Object o : map.values()) {\n      if (o instanceof Expression) {\n        Expression expr = (Expression) o;\n        try {\n          expr.getValueSource(this);\n        } catch (StackOverflowError e) {\n          throw new IllegalArgumentException(\"Recursion Error: Cycle detected originating in (\" + expr.sourceText + \")\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Traverses the graph of bindings, checking there are no cycles or missing references \n   * @throws IllegalArgumentException if the bindings is inconsistent \n   */\n  public final void validate() {\n    Set<String> marked = new HashSet<String>();\n    Set<String> chain = new HashSet<String>();\n    \n    for (String name : this) {\n      if (!marked.contains(name)) {\n        chain.add(name);\n        validate(name, marked, chain);\n        chain.remove(name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7ae1ad302fc92a61505409a38838f2b1a4a2b092","date":1483787106,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/SimpleBindings#validate().mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/SimpleBindings#validate().mjava","sourceNew":"  /** \n   * Traverses the graph of bindings, checking there are no cycles or missing references \n   * @throws IllegalArgumentException if the bindings is inconsistent \n   */\n  public void validate() {\n    for (Object o : map.values()) {\n      if (o instanceof Expression) {\n        Expression expr = (Expression) o;\n        try {\n          expr.getDoubleValuesSource(this);\n        } catch (StackOverflowError e) {\n          throw new IllegalArgumentException(\"Recursion Error: Cycle detected originating in (\" + expr.sourceText + \")\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Traverses the graph of bindings, checking there are no cycles or missing references \n   * @throws IllegalArgumentException if the bindings is inconsistent \n   */\n  public void validate() {\n    for (Object o : map.values()) {\n      if (o instanceof Expression) {\n        Expression expr = (Expression) o;\n        try {\n          expr.getValueSource(this);\n        } catch (StackOverflowError e) {\n          throw new IllegalArgumentException(\"Recursion Error: Cycle detected originating in (\" + expr.sourceText + \")\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","date":1484239864,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/SimpleBindings#validate().mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/SimpleBindings#validate().mjava","sourceNew":"  /** \n   * Traverses the graph of bindings, checking there are no cycles or missing references \n   * @throws IllegalArgumentException if the bindings is inconsistent \n   */\n  public void validate() {\n    for (Object o : map.values()) {\n      if (o instanceof Expression) {\n        Expression expr = (Expression) o;\n        try {\n          expr.getDoubleValuesSource(this);\n        } catch (StackOverflowError e) {\n          throw new IllegalArgumentException(\"Recursion Error: Cycle detected originating in (\" + expr.sourceText + \")\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Traverses the graph of bindings, checking there are no cycles or missing references \n   * @throws IllegalArgumentException if the bindings is inconsistent \n   */\n  public void validate() {\n    for (Object o : map.values()) {\n      if (o instanceof Expression) {\n        Expression expr = (Expression) o;\n        try {\n          expr.getValueSource(this);\n        } catch (StackOverflowError e) {\n          throw new IllegalArgumentException(\"Recursion Error: Cycle detected originating in (\" + expr.sourceText + \")\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4e19926b5df3ff21524afd77f06c4cd823147b22","date":1587720230,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/SimpleBindings#validate().mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/SimpleBindings#validate().mjava","sourceNew":"  /**\n   * Traverses the graph of bindings, checking there are no cycles or missing references\n   * @throws IllegalArgumentException if the bindings is inconsistent\n   */\n  public void validate() {\n    for (Map.Entry<String, Function<Bindings, DoubleValuesSource>> origin : map.entrySet()) {\n      origin.getValue().apply(new CycleDetectionBindings(origin.getKey()));\n    }\n  }\n\n","sourceOld":"  /** \n   * Traverses the graph of bindings, checking there are no cycles or missing references \n   * @throws IllegalArgumentException if the bindings is inconsistent \n   */\n  public void validate() {\n    for (Object o : map.values()) {\n      if (o instanceof Expression) {\n        Expression expr = (Expression) o;\n        try {\n          expr.getDoubleValuesSource(this);\n        } catch (StackOverflowError e) {\n          throw new IllegalArgumentException(\"Recursion Error: Cycle detected originating in (\" + expr.sourceText + \")\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c4a2e0e19d6ee2740632e97e6248b49b1f6df7fb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7ae1ad302fc92a61505409a38838f2b1a4a2b092":["c4a2e0e19d6ee2740632e97e6248b49b1f6df7fb"],"4e19926b5df3ff21524afd77f06c4cd823147b22":["7ae1ad302fc92a61505409a38838f2b1a4a2b092"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":["c4a2e0e19d6ee2740632e97e6248b49b1f6df7fb","7ae1ad302fc92a61505409a38838f2b1a4a2b092"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4e19926b5df3ff21524afd77f06c4cd823147b22"]},"commit2Childs":{"c4a2e0e19d6ee2740632e97e6248b49b1f6df7fb":["7ae1ad302fc92a61505409a38838f2b1a4a2b092","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c4a2e0e19d6ee2740632e97e6248b49b1f6df7fb"],"7ae1ad302fc92a61505409a38838f2b1a4a2b092":["4e19926b5df3ff21524afd77f06c4cd823147b22","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7"],"4e19926b5df3ff21524afd77f06c4cd823147b22":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}