{"path":"src/java/org/apache/solr/core/SolrCore#getNewIndexDir().mjava","commits":[{"id":"29765e35c99654ed87e394d8bc13d8ab07b51092","date":1223889162,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#getNewIndexDir().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Returns the indexdir as given in index.properties. If index.properties exists in dataDir and\n   * there is a property <i>index</i> available and it points to a valid directory\n   * in dataDir that is returned Else dataDir/index is returned. Only called for creating new indexSearchers\n   * and indexwriters. Use the getIndexDir() method to know the active index directory\n   *\n   * @return the indexdir as given in index.properties\n   */\n  public String getNewIndexDir() {\n    String result = dataDir + \"index/\";\n    File propsFile = new File(dataDir + \"index.properties\");\n    if (propsFile.exists()) {\n      Properties p = new Properties();\n      InputStream is = null;\n      try {\n        is = new FileInputStream(propsFile);\n        p.load(is);\n      } catch (IOException e) {\n        /*no op*/\n      } finally {\n        IOUtils.closeQuietly(is);\n      }\n      String s = p.getProperty(\"index\");\n      if (s != null && s.trim().length() > 0) {\n        File tmp = new File(dataDir + s);\n        if (tmp.exists() && tmp.isDirectory())\n          result = dataDir + s;\n      }\n    }\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["96e0d4494fe54b31c7f0151f3a632124ab806351","96e0d4494fe54b31c7f0151f3a632124ab806351","96e0d4494fe54b31c7f0151f3a632124ab806351"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#getNewIndexDir().mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#getNewIndexDir().mjava","sourceNew":"  /**\n   * Returns the indexdir as given in index.properties. If index.properties exists in dataDir and\n   * there is a property <i>index</i> available and it points to a valid directory\n   * in dataDir that is returned Else dataDir/index is returned. Only called for creating new indexSearchers\n   * and indexwriters. Use the getIndexDir() method to know the active index directory\n   *\n   * @return the indexdir as given in index.properties\n   */\n  public String getNewIndexDir() {\n    String result = dataDir + \"index/\";\n    File propsFile = new File(dataDir + \"index.properties\");\n    if (propsFile.exists()) {\n      Properties p = new Properties();\n      InputStream is = null;\n      try {\n        is = new FileInputStream(propsFile);\n        p.load(is);\n      } catch (IOException e) {\n        /*no op*/\n      } finally {\n        IOUtils.closeQuietly(is);\n      }\n      String s = p.getProperty(\"index\");\n      if (s != null && s.trim().length() > 0) {\n        File tmp = new File(dataDir + s);\n        if (tmp.exists() && tmp.isDirectory())\n          result = dataDir + s;\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Returns the indexdir as given in index.properties. If index.properties exists in dataDir and\n   * there is a property <i>index</i> available and it points to a valid directory\n   * in dataDir that is returned Else dataDir/index is returned. Only called for creating new indexSearchers\n   * and indexwriters. Use the getIndexDir() method to know the active index directory\n   *\n   * @return the indexdir as given in index.properties\n   */\n  public String getNewIndexDir() {\n    String result = dataDir + \"index/\";\n    File propsFile = new File(dataDir + \"index.properties\");\n    if (propsFile.exists()) {\n      Properties p = new Properties();\n      InputStream is = null;\n      try {\n        is = new FileInputStream(propsFile);\n        p.load(is);\n      } catch (IOException e) {\n        /*no op*/\n      } finally {\n        IOUtils.closeQuietly(is);\n      }\n      String s = p.getProperty(\"index\");\n      if (s != null && s.trim().length() > 0) {\n        File tmp = new File(dataDir + s);\n        if (tmp.exists() && tmp.isDirectory())\n          result = dataDir + s;\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"ad94625fb8d088209f46650c8097196fec67f00c":["29765e35c99654ed87e394d8bc13d8ab07b51092"],"29765e35c99654ed87e394d8bc13d8ab07b51092":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["29765e35c99654ed87e394d8bc13d8ab07b51092"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"29765e35c99654ed87e394d8bc13d8ab07b51092":["ad94625fb8d088209f46650c8097196fec67f00c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}