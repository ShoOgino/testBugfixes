{"path":"solr/core/src/java/org/apache/solr/spelling/WordBreakSolrSpellChecker#getSuggestions(SpellingOptions).mjava","commits":[{"id":"0ad9ec888e587ca9a3279368245cdf00aabdc108","date":1338832525,"type":0,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/WordBreakSolrSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options)\n      throws IOException {\n    IndexReader ir = options.reader;\n    int numSuggestions = options.count;\n    \n    StringBuilder sb = new StringBuilder();\n    Token[] tokenArr = options.tokens.toArray(new Token[options.tokens.size()]);\n    List<Term> termArr = new ArrayList<Term>(options.tokens.size() + 2);\n    \n    List<ResultEntry> breakSuggestionList = new ArrayList<ResultEntry>();\n    boolean lastOneProhibited = false;\n    boolean lastOneRequired = false;\n    boolean lastOneprocedesNewBooleanOp = false;\n    for (int i = 0; i < tokenArr.length; i++) {      \n      boolean prohibited = \n        (tokenArr[i].getFlags() & QueryConverter.PROHIBITED_TERM_FLAG) == \n          QueryConverter.PROHIBITED_TERM_FLAG;\n      boolean required = \n        (tokenArr[i].getFlags() & QueryConverter.REQUIRED_TERM_FLAG) == \n          QueryConverter.REQUIRED_TERM_FLAG;\n      boolean procedesNewBooleanOp = \n        (tokenArr[i].getFlags() & QueryConverter.TERM_PRECEDES_NEW_BOOLEAN_OPERATOR_FLAG) == \n          QueryConverter.TERM_PRECEDES_NEW_BOOLEAN_OPERATOR_FLAG;\n      if (i > 0\n          && (prohibited != lastOneProhibited || required != lastOneRequired || lastOneprocedesNewBooleanOp)) {\n        termArr.add(WordBreakSpellChecker.SEPARATOR_TERM);\n      }\n      lastOneProhibited = prohibited;\n      lastOneRequired = required;\n      lastOneprocedesNewBooleanOp = procedesNewBooleanOp;\n      \n      Term thisTerm = new Term(field, tokenArr[i].toString());\n      termArr.add(thisTerm);\n      if (breakWords) {\n        SuggestWord[][] breakSuggestions = wbsp.suggestWordBreaks(thisTerm,\n            numSuggestions, ir, options.suggestMode, sortMethod);\n        for (SuggestWord[] breakSuggestion : breakSuggestions) {\n          sb.delete(0, sb.length());\n          boolean firstOne = true;\n          int freq = 0;\n          for (SuggestWord word : breakSuggestion) {\n            if (!firstOne) {\n              sb.append(\" \");\n            }\n            firstOne = false;\n            sb.append(word.string);\n            if (sortMethod == BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY) {\n              freq = Math.max(freq, word.freq);\n            } else {\n              freq += word.freq;\n            }\n          }\n          breakSuggestionList.add(new ResultEntry(tokenArr[i], sb.toString(),\n              freq));\n        }\n      }\n    }    \n    List<ResultEntry> combineSuggestionList = Collections.emptyList();\n    CombineSuggestion[] combineSuggestions = wbsp.suggestWordCombinations(\n        termArr.toArray(new Term[termArr.size()]), numSuggestions, ir, options.suggestMode);\n    if (combineWords) {\n      combineSuggestionList = new ArrayList<ResultEntry>(\n          combineSuggestions.length);\n      for (CombineSuggestion cs : combineSuggestions) {\n        int firstTermIndex = cs.originalTermIndexes[0];\n        int lastTermIndex = cs.originalTermIndexes[cs.originalTermIndexes.length - 1];\n        sb.delete(0, sb.length());\n        for (int i = firstTermIndex; i <= lastTermIndex; i++) {\n          if (i > firstTermIndex) {\n            sb.append(\" \");\n          }\n          sb.append(tokenArr[i].toString());\n        }\n        Token token = new Token(sb.toString(), tokenArr[firstTermIndex]\n            .startOffset(), tokenArr[lastTermIndex].endOffset());\n        combineSuggestionList.add(new ResultEntry(token, cs.suggestion.string,\n            cs.suggestion.freq));\n      }\n    }\n    \n    // Interleave the two lists of suggestions into one SpellingResult\n    SpellingResult result = new SpellingResult();\n    Iterator<ResultEntry> breakIter = breakSuggestionList.iterator();\n    Iterator<ResultEntry> combineIter = combineSuggestionList.iterator();\n    ResultEntry lastBreak = breakIter.hasNext() ? breakIter.next() : null;\n    ResultEntry lastCombine = combineIter.hasNext() ? combineIter.next() : null;\n    int breakCount = 0;\n    int combineCount = 0;\n    while (lastBreak != null || lastCombine != null) {\n      if (lastBreak == null) {\n        result.add(lastCombine.token, lastCombine.suggestion, lastCombine.freq);\n        lastCombine = null;\n      } else if (lastCombine == null) {\n        result.add(lastBreak.token, lastBreak.suggestion, lastBreak.freq);\n        lastBreak = null;\n      } else if (lastBreak.freq < lastCombine.freq) {\n        result.add(lastCombine.token, lastCombine.suggestion, lastCombine.freq);\n        lastCombine = null;\n      } else if (lastCombine.freq < lastBreak.freq) {\n        result.add(lastBreak.token, lastBreak.suggestion, lastBreak.freq);\n        lastBreak = null;\n      } else if (breakCount >= combineCount) {\n        result.add(lastCombine.token, lastCombine.suggestion, lastCombine.freq);\n        lastCombine = null;\n      } else {\n        result.add(lastBreak.token, lastBreak.suggestion, lastBreak.freq);\n        lastBreak = null;\n      }\n      if (result.getSuggestions().size() > numSuggestions) {\n        break;\n      }\n      if (lastBreak == null && breakIter.hasNext()) {\n        lastBreak = breakIter.next();\n        breakCount++;\n      }\n      if (lastCombine == null && combineIter.hasNext()) {\n        lastCombine = combineIter.next();\n        combineCount++;\n      }\n    }\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["8e65acce892eede973379cb2fb3b90ea49a4a5ed","f28ba44811b52d5f1b5df98515eadee9f835f116"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"56d78974d33c1244e0810e0dc8f1c6371faceac9","date":1338918242,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/WordBreakSolrSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/WordBreakSolrSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options)\n      throws IOException {\n    IndexReader ir = options.reader;\n    int numSuggestions = options.count;\n    \n    StringBuilder sb = new StringBuilder();\n    Token[] tokenArr = options.tokens.toArray(new Token[options.tokens.size()]);\n    List<Term> termArr = new ArrayList<Term>(options.tokens.size() + 2);\n    \n    List<ResultEntry> breakSuggestionList = new ArrayList<ResultEntry>();\n    boolean lastOneProhibited = false;\n    boolean lastOneRequired = false;\n    boolean lastOneprocedesNewBooleanOp = false;\n    for (int i = 0; i < tokenArr.length; i++) {      \n      boolean prohibited = \n        (tokenArr[i].getFlags() & QueryConverter.PROHIBITED_TERM_FLAG) == \n          QueryConverter.PROHIBITED_TERM_FLAG;\n      boolean required = \n        (tokenArr[i].getFlags() & QueryConverter.REQUIRED_TERM_FLAG) == \n          QueryConverter.REQUIRED_TERM_FLAG;\n      boolean procedesNewBooleanOp = \n        (tokenArr[i].getFlags() & QueryConverter.TERM_PRECEDES_NEW_BOOLEAN_OPERATOR_FLAG) == \n          QueryConverter.TERM_PRECEDES_NEW_BOOLEAN_OPERATOR_FLAG;\n      if (i > 0\n          && (prohibited != lastOneProhibited || required != lastOneRequired || lastOneprocedesNewBooleanOp)) {\n        termArr.add(WordBreakSpellChecker.SEPARATOR_TERM);\n      }\n      lastOneProhibited = prohibited;\n      lastOneRequired = required;\n      lastOneprocedesNewBooleanOp = procedesNewBooleanOp;\n      \n      Term thisTerm = new Term(field, tokenArr[i].toString());\n      termArr.add(thisTerm);\n      if (breakWords) {\n        SuggestWord[][] breakSuggestions = wbsp.suggestWordBreaks(thisTerm,\n            numSuggestions, ir, options.suggestMode, sortMethod);\n        for (SuggestWord[] breakSuggestion : breakSuggestions) {\n          sb.delete(0, sb.length());\n          boolean firstOne = true;\n          int freq = 0;\n          for (SuggestWord word : breakSuggestion) {\n            if (!firstOne) {\n              sb.append(\" \");\n            }\n            firstOne = false;\n            sb.append(word.string);\n            if (sortMethod == BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY) {\n              freq = Math.max(freq, word.freq);\n            } else {\n              freq += word.freq;\n            }\n          }\n          breakSuggestionList.add(new ResultEntry(tokenArr[i], sb.toString(),\n              freq));\n        }\n      }\n    }    \n    List<ResultEntry> combineSuggestionList = Collections.emptyList();\n    CombineSuggestion[] combineSuggestions = wbsp.suggestWordCombinations(\n        termArr.toArray(new Term[termArr.size()]), numSuggestions, ir, options.suggestMode);\n    if (combineWords) {\n      combineSuggestionList = new ArrayList<ResultEntry>(\n          combineSuggestions.length);\n      for (CombineSuggestion cs : combineSuggestions) {\n        int firstTermIndex = cs.originalTermIndexes[0];\n        int lastTermIndex = cs.originalTermIndexes[cs.originalTermIndexes.length - 1];\n        sb.delete(0, sb.length());\n        for (int i = firstTermIndex; i <= lastTermIndex; i++) {\n          if (i > firstTermIndex) {\n            sb.append(\" \");\n          }\n          sb.append(tokenArr[i].toString());\n        }\n        Token token = new Token(sb.toString(), tokenArr[firstTermIndex]\n            .startOffset(), tokenArr[lastTermIndex].endOffset());\n        combineSuggestionList.add(new ResultEntry(token, cs.suggestion.string,\n            cs.suggestion.freq));\n      }\n    }\n    \n    // Interleave the two lists of suggestions into one SpellingResult\n    SpellingResult result = new SpellingResult();\n    Iterator<ResultEntry> breakIter = breakSuggestionList.iterator();\n    Iterator<ResultEntry> combineIter = combineSuggestionList.iterator();\n    ResultEntry lastBreak = breakIter.hasNext() ? breakIter.next() : null;\n    ResultEntry lastCombine = combineIter.hasNext() ? combineIter.next() : null;\n    int breakCount = 0;\n    int combineCount = 0;\n    while (lastBreak != null || lastCombine != null) {\n      if (lastBreak == null) {\n        result.add(lastCombine.token, lastCombine.suggestion, lastCombine.freq);\n        result.addFrequency(lastCombine.token, getCombineFrequency(ir, lastCombine.token));\n        lastCombine = null;\n      } else if (lastCombine == null) {\n        result.add(lastBreak.token, lastBreak.suggestion, lastBreak.freq);\n        result.addFrequency(lastBreak.token, ir.docFreq(new Term(field, lastBreak.token.toString())));\n        lastBreak = null;\n      } else if (lastBreak.freq < lastCombine.freq) {\n        result.add(lastCombine.token, lastCombine.suggestion, lastCombine.freq);\n        result.addFrequency(lastCombine.token, getCombineFrequency(ir, lastCombine.token));\n        lastCombine = null;\n      } else if (lastCombine.freq < lastBreak.freq) {\n        result.add(lastBreak.token, lastBreak.suggestion, lastBreak.freq);\n        result.addFrequency(lastBreak.token, ir.docFreq(new Term(field, lastBreak.token.toString())));\n        lastBreak = null;\n      } else if (breakCount >= combineCount) {\n        result.add(lastCombine.token, lastCombine.suggestion, lastCombine.freq);\n        result.addFrequency(lastCombine.token, getCombineFrequency(ir, lastCombine.token));\n        lastCombine = null;\n      } else {\n        result.add(lastBreak.token, lastBreak.suggestion, lastBreak.freq);\n        result.addFrequency(lastBreak.token, ir.docFreq(new Term(field, lastBreak.token.toString())));\n        lastBreak = null;\n      }\n      if (result.getSuggestions().size() > numSuggestions) {\n        break;\n      }\n      if (lastBreak == null && breakIter.hasNext()) {\n        lastBreak = breakIter.next();\n        breakCount++;\n      }\n      if (lastCombine == null && combineIter.hasNext()) {\n        lastCombine = combineIter.next();\n        combineCount++;\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options)\n      throws IOException {\n    IndexReader ir = options.reader;\n    int numSuggestions = options.count;\n    \n    StringBuilder sb = new StringBuilder();\n    Token[] tokenArr = options.tokens.toArray(new Token[options.tokens.size()]);\n    List<Term> termArr = new ArrayList<Term>(options.tokens.size() + 2);\n    \n    List<ResultEntry> breakSuggestionList = new ArrayList<ResultEntry>();\n    boolean lastOneProhibited = false;\n    boolean lastOneRequired = false;\n    boolean lastOneprocedesNewBooleanOp = false;\n    for (int i = 0; i < tokenArr.length; i++) {      \n      boolean prohibited = \n        (tokenArr[i].getFlags() & QueryConverter.PROHIBITED_TERM_FLAG) == \n          QueryConverter.PROHIBITED_TERM_FLAG;\n      boolean required = \n        (tokenArr[i].getFlags() & QueryConverter.REQUIRED_TERM_FLAG) == \n          QueryConverter.REQUIRED_TERM_FLAG;\n      boolean procedesNewBooleanOp = \n        (tokenArr[i].getFlags() & QueryConverter.TERM_PRECEDES_NEW_BOOLEAN_OPERATOR_FLAG) == \n          QueryConverter.TERM_PRECEDES_NEW_BOOLEAN_OPERATOR_FLAG;\n      if (i > 0\n          && (prohibited != lastOneProhibited || required != lastOneRequired || lastOneprocedesNewBooleanOp)) {\n        termArr.add(WordBreakSpellChecker.SEPARATOR_TERM);\n      }\n      lastOneProhibited = prohibited;\n      lastOneRequired = required;\n      lastOneprocedesNewBooleanOp = procedesNewBooleanOp;\n      \n      Term thisTerm = new Term(field, tokenArr[i].toString());\n      termArr.add(thisTerm);\n      if (breakWords) {\n        SuggestWord[][] breakSuggestions = wbsp.suggestWordBreaks(thisTerm,\n            numSuggestions, ir, options.suggestMode, sortMethod);\n        for (SuggestWord[] breakSuggestion : breakSuggestions) {\n          sb.delete(0, sb.length());\n          boolean firstOne = true;\n          int freq = 0;\n          for (SuggestWord word : breakSuggestion) {\n            if (!firstOne) {\n              sb.append(\" \");\n            }\n            firstOne = false;\n            sb.append(word.string);\n            if (sortMethod == BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY) {\n              freq = Math.max(freq, word.freq);\n            } else {\n              freq += word.freq;\n            }\n          }\n          breakSuggestionList.add(new ResultEntry(tokenArr[i], sb.toString(),\n              freq));\n        }\n      }\n    }    \n    List<ResultEntry> combineSuggestionList = Collections.emptyList();\n    CombineSuggestion[] combineSuggestions = wbsp.suggestWordCombinations(\n        termArr.toArray(new Term[termArr.size()]), numSuggestions, ir, options.suggestMode);\n    if (combineWords) {\n      combineSuggestionList = new ArrayList<ResultEntry>(\n          combineSuggestions.length);\n      for (CombineSuggestion cs : combineSuggestions) {\n        int firstTermIndex = cs.originalTermIndexes[0];\n        int lastTermIndex = cs.originalTermIndexes[cs.originalTermIndexes.length - 1];\n        sb.delete(0, sb.length());\n        for (int i = firstTermIndex; i <= lastTermIndex; i++) {\n          if (i > firstTermIndex) {\n            sb.append(\" \");\n          }\n          sb.append(tokenArr[i].toString());\n        }\n        Token token = new Token(sb.toString(), tokenArr[firstTermIndex]\n            .startOffset(), tokenArr[lastTermIndex].endOffset());\n        combineSuggestionList.add(new ResultEntry(token, cs.suggestion.string,\n            cs.suggestion.freq));\n      }\n    }\n    \n    // Interleave the two lists of suggestions into one SpellingResult\n    SpellingResult result = new SpellingResult();\n    Iterator<ResultEntry> breakIter = breakSuggestionList.iterator();\n    Iterator<ResultEntry> combineIter = combineSuggestionList.iterator();\n    ResultEntry lastBreak = breakIter.hasNext() ? breakIter.next() : null;\n    ResultEntry lastCombine = combineIter.hasNext() ? combineIter.next() : null;\n    int breakCount = 0;\n    int combineCount = 0;\n    while (lastBreak != null || lastCombine != null) {\n      if (lastBreak == null) {\n        result.add(lastCombine.token, lastCombine.suggestion, lastCombine.freq);\n        lastCombine = null;\n      } else if (lastCombine == null) {\n        result.add(lastBreak.token, lastBreak.suggestion, lastBreak.freq);\n        lastBreak = null;\n      } else if (lastBreak.freq < lastCombine.freq) {\n        result.add(lastCombine.token, lastCombine.suggestion, lastCombine.freq);\n        lastCombine = null;\n      } else if (lastCombine.freq < lastBreak.freq) {\n        result.add(lastBreak.token, lastBreak.suggestion, lastBreak.freq);\n        lastBreak = null;\n      } else if (breakCount >= combineCount) {\n        result.add(lastCombine.token, lastCombine.suggestion, lastCombine.freq);\n        lastCombine = null;\n      } else {\n        result.add(lastBreak.token, lastBreak.suggestion, lastBreak.freq);\n        lastBreak = null;\n      }\n      if (result.getSuggestions().size() > numSuggestions) {\n        break;\n      }\n      if (lastBreak == null && breakIter.hasNext()) {\n        lastBreak = breakIter.next();\n        breakCount++;\n      }\n      if (lastCombine == null && combineIter.hasNext()) {\n        lastCombine = combineIter.next();\n        combineCount++;\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":["8e65acce892eede973379cb2fb3b90ea49a4a5ed"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/WordBreakSolrSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/WordBreakSolrSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options)\n      throws IOException {\n    IndexReader ir = options.reader;\n    int numSuggestions = options.count;\n    \n    StringBuilder sb = new StringBuilder();\n    Token[] tokenArr = options.tokens.toArray(new Token[options.tokens.size()]);\n    List<Term> termArr = new ArrayList<>(options.tokens.size() + 2);\n    \n    List<ResultEntry> breakSuggestionList = new ArrayList<>();\n    boolean lastOneProhibited = false;\n    boolean lastOneRequired = false;\n    boolean lastOneprocedesNewBooleanOp = false;\n    for (int i = 0; i < tokenArr.length; i++) {      \n      boolean prohibited = \n        (tokenArr[i].getFlags() & QueryConverter.PROHIBITED_TERM_FLAG) == \n          QueryConverter.PROHIBITED_TERM_FLAG;\n      boolean required = \n        (tokenArr[i].getFlags() & QueryConverter.REQUIRED_TERM_FLAG) == \n          QueryConverter.REQUIRED_TERM_FLAG;\n      boolean procedesNewBooleanOp = \n        (tokenArr[i].getFlags() & QueryConverter.TERM_PRECEDES_NEW_BOOLEAN_OPERATOR_FLAG) == \n          QueryConverter.TERM_PRECEDES_NEW_BOOLEAN_OPERATOR_FLAG;\n      if (i > 0\n          && (prohibited != lastOneProhibited || required != lastOneRequired || lastOneprocedesNewBooleanOp)) {\n        termArr.add(WordBreakSpellChecker.SEPARATOR_TERM);\n      }\n      lastOneProhibited = prohibited;\n      lastOneRequired = required;\n      lastOneprocedesNewBooleanOp = procedesNewBooleanOp;\n      \n      Term thisTerm = new Term(field, tokenArr[i].toString());\n      termArr.add(thisTerm);\n      if (breakWords) {\n        SuggestWord[][] breakSuggestions = wbsp.suggestWordBreaks(thisTerm,\n            numSuggestions, ir, options.suggestMode, sortMethod);\n        for (SuggestWord[] breakSuggestion : breakSuggestions) {\n          sb.delete(0, sb.length());\n          boolean firstOne = true;\n          int freq = 0;\n          for (SuggestWord word : breakSuggestion) {\n            if (!firstOne) {\n              sb.append(\" \");\n            }\n            firstOne = false;\n            sb.append(word.string);\n            if (sortMethod == BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY) {\n              freq = Math.max(freq, word.freq);\n            } else {\n              freq += word.freq;\n            }\n          }\n          breakSuggestionList.add(new ResultEntry(tokenArr[i], sb.toString(),\n              freq));\n        }\n      }\n    }    \n    List<ResultEntry> combineSuggestionList = Collections.emptyList();\n    CombineSuggestion[] combineSuggestions = wbsp.suggestWordCombinations(\n        termArr.toArray(new Term[termArr.size()]), numSuggestions, ir, options.suggestMode);\n    if (combineWords) {\n      combineSuggestionList = new ArrayList<>(\n          combineSuggestions.length);\n      for (CombineSuggestion cs : combineSuggestions) {\n        int firstTermIndex = cs.originalTermIndexes[0];\n        int lastTermIndex = cs.originalTermIndexes[cs.originalTermIndexes.length - 1];\n        sb.delete(0, sb.length());\n        for (int i = firstTermIndex; i <= lastTermIndex; i++) {\n          if (i > firstTermIndex) {\n            sb.append(\" \");\n          }\n          sb.append(tokenArr[i].toString());\n        }\n        Token token = new Token(sb.toString(), tokenArr[firstTermIndex]\n            .startOffset(), tokenArr[lastTermIndex].endOffset());\n        combineSuggestionList.add(new ResultEntry(token, cs.suggestion.string,\n            cs.suggestion.freq));\n      }\n    }\n    \n    // Interleave the two lists of suggestions into one SpellingResult\n    SpellingResult result = new SpellingResult();\n    Iterator<ResultEntry> breakIter = breakSuggestionList.iterator();\n    Iterator<ResultEntry> combineIter = combineSuggestionList.iterator();\n    ResultEntry lastBreak = breakIter.hasNext() ? breakIter.next() : null;\n    ResultEntry lastCombine = combineIter.hasNext() ? combineIter.next() : null;\n    int breakCount = 0;\n    int combineCount = 0;\n    while (lastBreak != null || lastCombine != null) {\n      if (lastBreak == null) {\n        result.add(lastCombine.token, lastCombine.suggestion, lastCombine.freq);\n        result.addFrequency(lastCombine.token, getCombineFrequency(ir, lastCombine.token));\n        lastCombine = null;\n      } else if (lastCombine == null) {\n        result.add(lastBreak.token, lastBreak.suggestion, lastBreak.freq);\n        result.addFrequency(lastBreak.token, ir.docFreq(new Term(field, lastBreak.token.toString())));\n        lastBreak = null;\n      } else if (lastBreak.freq < lastCombine.freq) {\n        result.add(lastCombine.token, lastCombine.suggestion, lastCombine.freq);\n        result.addFrequency(lastCombine.token, getCombineFrequency(ir, lastCombine.token));\n        lastCombine = null;\n      } else if (lastCombine.freq < lastBreak.freq) {\n        result.add(lastBreak.token, lastBreak.suggestion, lastBreak.freq);\n        result.addFrequency(lastBreak.token, ir.docFreq(new Term(field, lastBreak.token.toString())));\n        lastBreak = null;\n      } else if (breakCount >= combineCount) {\n        result.add(lastCombine.token, lastCombine.suggestion, lastCombine.freq);\n        result.addFrequency(lastCombine.token, getCombineFrequency(ir, lastCombine.token));\n        lastCombine = null;\n      } else {\n        result.add(lastBreak.token, lastBreak.suggestion, lastBreak.freq);\n        result.addFrequency(lastBreak.token, ir.docFreq(new Term(field, lastBreak.token.toString())));\n        lastBreak = null;\n      }\n      if (result.getSuggestions().size() > numSuggestions) {\n        break;\n      }\n      if (lastBreak == null && breakIter.hasNext()) {\n        lastBreak = breakIter.next();\n        breakCount++;\n      }\n      if (lastCombine == null && combineIter.hasNext()) {\n        lastCombine = combineIter.next();\n        combineCount++;\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options)\n      throws IOException {\n    IndexReader ir = options.reader;\n    int numSuggestions = options.count;\n    \n    StringBuilder sb = new StringBuilder();\n    Token[] tokenArr = options.tokens.toArray(new Token[options.tokens.size()]);\n    List<Term> termArr = new ArrayList<Term>(options.tokens.size() + 2);\n    \n    List<ResultEntry> breakSuggestionList = new ArrayList<ResultEntry>();\n    boolean lastOneProhibited = false;\n    boolean lastOneRequired = false;\n    boolean lastOneprocedesNewBooleanOp = false;\n    for (int i = 0; i < tokenArr.length; i++) {      \n      boolean prohibited = \n        (tokenArr[i].getFlags() & QueryConverter.PROHIBITED_TERM_FLAG) == \n          QueryConverter.PROHIBITED_TERM_FLAG;\n      boolean required = \n        (tokenArr[i].getFlags() & QueryConverter.REQUIRED_TERM_FLAG) == \n          QueryConverter.REQUIRED_TERM_FLAG;\n      boolean procedesNewBooleanOp = \n        (tokenArr[i].getFlags() & QueryConverter.TERM_PRECEDES_NEW_BOOLEAN_OPERATOR_FLAG) == \n          QueryConverter.TERM_PRECEDES_NEW_BOOLEAN_OPERATOR_FLAG;\n      if (i > 0\n          && (prohibited != lastOneProhibited || required != lastOneRequired || lastOneprocedesNewBooleanOp)) {\n        termArr.add(WordBreakSpellChecker.SEPARATOR_TERM);\n      }\n      lastOneProhibited = prohibited;\n      lastOneRequired = required;\n      lastOneprocedesNewBooleanOp = procedesNewBooleanOp;\n      \n      Term thisTerm = new Term(field, tokenArr[i].toString());\n      termArr.add(thisTerm);\n      if (breakWords) {\n        SuggestWord[][] breakSuggestions = wbsp.suggestWordBreaks(thisTerm,\n            numSuggestions, ir, options.suggestMode, sortMethod);\n        for (SuggestWord[] breakSuggestion : breakSuggestions) {\n          sb.delete(0, sb.length());\n          boolean firstOne = true;\n          int freq = 0;\n          for (SuggestWord word : breakSuggestion) {\n            if (!firstOne) {\n              sb.append(\" \");\n            }\n            firstOne = false;\n            sb.append(word.string);\n            if (sortMethod == BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY) {\n              freq = Math.max(freq, word.freq);\n            } else {\n              freq += word.freq;\n            }\n          }\n          breakSuggestionList.add(new ResultEntry(tokenArr[i], sb.toString(),\n              freq));\n        }\n      }\n    }    \n    List<ResultEntry> combineSuggestionList = Collections.emptyList();\n    CombineSuggestion[] combineSuggestions = wbsp.suggestWordCombinations(\n        termArr.toArray(new Term[termArr.size()]), numSuggestions, ir, options.suggestMode);\n    if (combineWords) {\n      combineSuggestionList = new ArrayList<ResultEntry>(\n          combineSuggestions.length);\n      for (CombineSuggestion cs : combineSuggestions) {\n        int firstTermIndex = cs.originalTermIndexes[0];\n        int lastTermIndex = cs.originalTermIndexes[cs.originalTermIndexes.length - 1];\n        sb.delete(0, sb.length());\n        for (int i = firstTermIndex; i <= lastTermIndex; i++) {\n          if (i > firstTermIndex) {\n            sb.append(\" \");\n          }\n          sb.append(tokenArr[i].toString());\n        }\n        Token token = new Token(sb.toString(), tokenArr[firstTermIndex]\n            .startOffset(), tokenArr[lastTermIndex].endOffset());\n        combineSuggestionList.add(new ResultEntry(token, cs.suggestion.string,\n            cs.suggestion.freq));\n      }\n    }\n    \n    // Interleave the two lists of suggestions into one SpellingResult\n    SpellingResult result = new SpellingResult();\n    Iterator<ResultEntry> breakIter = breakSuggestionList.iterator();\n    Iterator<ResultEntry> combineIter = combineSuggestionList.iterator();\n    ResultEntry lastBreak = breakIter.hasNext() ? breakIter.next() : null;\n    ResultEntry lastCombine = combineIter.hasNext() ? combineIter.next() : null;\n    int breakCount = 0;\n    int combineCount = 0;\n    while (lastBreak != null || lastCombine != null) {\n      if (lastBreak == null) {\n        result.add(lastCombine.token, lastCombine.suggestion, lastCombine.freq);\n        result.addFrequency(lastCombine.token, getCombineFrequency(ir, lastCombine.token));\n        lastCombine = null;\n      } else if (lastCombine == null) {\n        result.add(lastBreak.token, lastBreak.suggestion, lastBreak.freq);\n        result.addFrequency(lastBreak.token, ir.docFreq(new Term(field, lastBreak.token.toString())));\n        lastBreak = null;\n      } else if (lastBreak.freq < lastCombine.freq) {\n        result.add(lastCombine.token, lastCombine.suggestion, lastCombine.freq);\n        result.addFrequency(lastCombine.token, getCombineFrequency(ir, lastCombine.token));\n        lastCombine = null;\n      } else if (lastCombine.freq < lastBreak.freq) {\n        result.add(lastBreak.token, lastBreak.suggestion, lastBreak.freq);\n        result.addFrequency(lastBreak.token, ir.docFreq(new Term(field, lastBreak.token.toString())));\n        lastBreak = null;\n      } else if (breakCount >= combineCount) {\n        result.add(lastCombine.token, lastCombine.suggestion, lastCombine.freq);\n        result.addFrequency(lastCombine.token, getCombineFrequency(ir, lastCombine.token));\n        lastCombine = null;\n      } else {\n        result.add(lastBreak.token, lastBreak.suggestion, lastBreak.freq);\n        result.addFrequency(lastBreak.token, ir.docFreq(new Term(field, lastBreak.token.toString())));\n        lastBreak = null;\n      }\n      if (result.getSuggestions().size() > numSuggestions) {\n        break;\n      }\n      if (lastBreak == null && breakIter.hasNext()) {\n        lastBreak = breakIter.next();\n        breakCount++;\n      }\n      if (lastCombine == null && combineIter.hasNext()) {\n        lastCombine = combineIter.next();\n        combineCount++;\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8e65acce892eede973379cb2fb3b90ea49a4a5ed","date":1409839025,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/WordBreakSolrSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/WordBreakSolrSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options)\n      throws IOException {\n    IndexReader ir = options.reader;\n    int numSuggestions = options.count;\n    \n    StringBuilder sb = new StringBuilder();\n    Token[] tokenArr = options.tokens.toArray(new Token[options.tokens.size()]);\n    List<Term> termArr = new ArrayList<>(options.tokens.size() + 2);\n    \n    List<ResultEntry> breakSuggestionList = new ArrayList<>();\n    List<ResultEntry> noBreakSuggestionList = new ArrayList<>();\n    boolean lastOneProhibited = false;\n    boolean lastOneRequired = false;\n    boolean lastOneprocedesNewBooleanOp = false;\n    for (int i = 0; i < tokenArr.length; i++) {      \n      boolean prohibited = \n        (tokenArr[i].getFlags() & QueryConverter.PROHIBITED_TERM_FLAG) == \n          QueryConverter.PROHIBITED_TERM_FLAG;\n      boolean required = \n        (tokenArr[i].getFlags() & QueryConverter.REQUIRED_TERM_FLAG) == \n          QueryConverter.REQUIRED_TERM_FLAG;\n      boolean procedesNewBooleanOp = \n        (tokenArr[i].getFlags() & QueryConverter.TERM_PRECEDES_NEW_BOOLEAN_OPERATOR_FLAG) == \n          QueryConverter.TERM_PRECEDES_NEW_BOOLEAN_OPERATOR_FLAG;\n      if (i > 0\n          && (prohibited != lastOneProhibited || required != lastOneRequired || lastOneprocedesNewBooleanOp)) {\n        termArr.add(WordBreakSpellChecker.SEPARATOR_TERM);\n      }\n      lastOneProhibited = prohibited;\n      lastOneRequired = required;\n      lastOneprocedesNewBooleanOp = procedesNewBooleanOp;\n      \n      Term thisTerm = new Term(field, tokenArr[i].toString());\n      termArr.add(thisTerm);\n      if (breakWords) {\n        SuggestWord[][] breakSuggestions = wbsp.suggestWordBreaks(thisTerm,\n            numSuggestions, ir, options.suggestMode, sortMethod);\n        if(breakSuggestions.length==0) {\n          noBreakSuggestionList.add(new ResultEntry(tokenArr[i], null, 0));\n        }\n        for (SuggestWord[] breakSuggestion : breakSuggestions) {\n          sb.delete(0, sb.length());\n          boolean firstOne = true;\n          int freq = 0;\n          for (SuggestWord word : breakSuggestion) {\n            if (!firstOne) {\n              sb.append(\" \");\n            }\n            firstOne = false;\n            sb.append(word.string);\n            if (sortMethod == BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY) {\n              freq = Math.max(freq, word.freq);\n            } else {\n              freq += word.freq;\n            }\n          }\n          breakSuggestionList.add(new ResultEntry(tokenArr[i], sb.toString(),\n              freq));\n        }\n      }\n    }\n    breakSuggestionList.addAll(noBreakSuggestionList);\n    \n    List<ResultEntry> combineSuggestionList = Collections.emptyList();\n    CombineSuggestion[] combineSuggestions = wbsp.suggestWordCombinations(\n        termArr.toArray(new Term[termArr.size()]), numSuggestions, ir, options.suggestMode);\n    if (combineWords) {\n      combineSuggestionList = new ArrayList<>(\n          combineSuggestions.length);\n      for (CombineSuggestion cs : combineSuggestions) {\n        int firstTermIndex = cs.originalTermIndexes[0];\n        int lastTermIndex = cs.originalTermIndexes[cs.originalTermIndexes.length - 1];\n        sb.delete(0, sb.length());\n        for (int i = firstTermIndex; i <= lastTermIndex; i++) {\n          if (i > firstTermIndex) {\n            sb.append(\" \");\n          }\n          sb.append(tokenArr[i].toString());\n        }\n        Token token = new Token(sb.toString(), tokenArr[firstTermIndex]\n            .startOffset(), tokenArr[lastTermIndex].endOffset());\n        combineSuggestionList.add(new ResultEntry(token, cs.suggestion.string,\n            cs.suggestion.freq));\n      }\n    }\n    \n    // Interleave the two lists of suggestions into one SpellingResult\n    SpellingResult result = new SpellingResult();\n    Iterator<ResultEntry> breakIter = breakSuggestionList.iterator();\n    Iterator<ResultEntry> combineIter = combineSuggestionList.iterator();\n    ResultEntry lastBreak = breakIter.hasNext() ? breakIter.next() : null;\n    ResultEntry lastCombine = combineIter.hasNext() ? combineIter.next() : null;\n    int breakCount = 0;\n    int combineCount = 0;\n    while (lastBreak != null || lastCombine != null) {\n      if (lastBreak == null) {\n        addToResult(result, lastCombine.token, getCombineFrequency(ir, lastCombine.token), lastCombine.suggestion, lastCombine.freq);\n        lastCombine = null;\n      } else if (lastCombine == null) {\n        addToResult(result, lastBreak.token, ir.docFreq(new Term(field, lastBreak.token.toString())), lastBreak.suggestion, lastBreak.freq);\n        lastBreak = null;\n      } else if (lastBreak.freq < lastCombine.freq) {\n        addToResult(result, lastCombine.token, getCombineFrequency(ir, lastCombine.token), lastCombine.suggestion, lastCombine.freq);        \n        lastCombine = null;\n      } else if (lastCombine.freq < lastBreak.freq) {\n        addToResult(result, lastBreak.token, ir.docFreq(new Term(field, lastBreak.token.toString())), lastBreak.suggestion, lastBreak.freq);\n        lastBreak = null;\n      } else if (breakCount >= combineCount) { //TODO: Should reverse >= to < ??S\n        addToResult(result, lastCombine.token, getCombineFrequency(ir, lastCombine.token), lastCombine.suggestion, lastCombine.freq);        \n        lastCombine = null;\n      } else {\n        addToResult(result, lastBreak.token, ir.docFreq(new Term(field, lastBreak.token.toString())), lastBreak.suggestion, lastBreak.freq);        \n        lastBreak = null;\n      }\n      if (lastBreak == null && breakIter.hasNext()) {\n        lastBreak = breakIter.next();\n        breakCount++;\n      }\n      if (lastCombine == null && combineIter.hasNext()) {\n        lastCombine = combineIter.next();\n        combineCount++;\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options)\n      throws IOException {\n    IndexReader ir = options.reader;\n    int numSuggestions = options.count;\n    \n    StringBuilder sb = new StringBuilder();\n    Token[] tokenArr = options.tokens.toArray(new Token[options.tokens.size()]);\n    List<Term> termArr = new ArrayList<>(options.tokens.size() + 2);\n    \n    List<ResultEntry> breakSuggestionList = new ArrayList<>();\n    boolean lastOneProhibited = false;\n    boolean lastOneRequired = false;\n    boolean lastOneprocedesNewBooleanOp = false;\n    for (int i = 0; i < tokenArr.length; i++) {      \n      boolean prohibited = \n        (tokenArr[i].getFlags() & QueryConverter.PROHIBITED_TERM_FLAG) == \n          QueryConverter.PROHIBITED_TERM_FLAG;\n      boolean required = \n        (tokenArr[i].getFlags() & QueryConverter.REQUIRED_TERM_FLAG) == \n          QueryConverter.REQUIRED_TERM_FLAG;\n      boolean procedesNewBooleanOp = \n        (tokenArr[i].getFlags() & QueryConverter.TERM_PRECEDES_NEW_BOOLEAN_OPERATOR_FLAG) == \n          QueryConverter.TERM_PRECEDES_NEW_BOOLEAN_OPERATOR_FLAG;\n      if (i > 0\n          && (prohibited != lastOneProhibited || required != lastOneRequired || lastOneprocedesNewBooleanOp)) {\n        termArr.add(WordBreakSpellChecker.SEPARATOR_TERM);\n      }\n      lastOneProhibited = prohibited;\n      lastOneRequired = required;\n      lastOneprocedesNewBooleanOp = procedesNewBooleanOp;\n      \n      Term thisTerm = new Term(field, tokenArr[i].toString());\n      termArr.add(thisTerm);\n      if (breakWords) {\n        SuggestWord[][] breakSuggestions = wbsp.suggestWordBreaks(thisTerm,\n            numSuggestions, ir, options.suggestMode, sortMethod);\n        for (SuggestWord[] breakSuggestion : breakSuggestions) {\n          sb.delete(0, sb.length());\n          boolean firstOne = true;\n          int freq = 0;\n          for (SuggestWord word : breakSuggestion) {\n            if (!firstOne) {\n              sb.append(\" \");\n            }\n            firstOne = false;\n            sb.append(word.string);\n            if (sortMethod == BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY) {\n              freq = Math.max(freq, word.freq);\n            } else {\n              freq += word.freq;\n            }\n          }\n          breakSuggestionList.add(new ResultEntry(tokenArr[i], sb.toString(),\n              freq));\n        }\n      }\n    }    \n    List<ResultEntry> combineSuggestionList = Collections.emptyList();\n    CombineSuggestion[] combineSuggestions = wbsp.suggestWordCombinations(\n        termArr.toArray(new Term[termArr.size()]), numSuggestions, ir, options.suggestMode);\n    if (combineWords) {\n      combineSuggestionList = new ArrayList<>(\n          combineSuggestions.length);\n      for (CombineSuggestion cs : combineSuggestions) {\n        int firstTermIndex = cs.originalTermIndexes[0];\n        int lastTermIndex = cs.originalTermIndexes[cs.originalTermIndexes.length - 1];\n        sb.delete(0, sb.length());\n        for (int i = firstTermIndex; i <= lastTermIndex; i++) {\n          if (i > firstTermIndex) {\n            sb.append(\" \");\n          }\n          sb.append(tokenArr[i].toString());\n        }\n        Token token = new Token(sb.toString(), tokenArr[firstTermIndex]\n            .startOffset(), tokenArr[lastTermIndex].endOffset());\n        combineSuggestionList.add(new ResultEntry(token, cs.suggestion.string,\n            cs.suggestion.freq));\n      }\n    }\n    \n    // Interleave the two lists of suggestions into one SpellingResult\n    SpellingResult result = new SpellingResult();\n    Iterator<ResultEntry> breakIter = breakSuggestionList.iterator();\n    Iterator<ResultEntry> combineIter = combineSuggestionList.iterator();\n    ResultEntry lastBreak = breakIter.hasNext() ? breakIter.next() : null;\n    ResultEntry lastCombine = combineIter.hasNext() ? combineIter.next() : null;\n    int breakCount = 0;\n    int combineCount = 0;\n    while (lastBreak != null || lastCombine != null) {\n      if (lastBreak == null) {\n        result.add(lastCombine.token, lastCombine.suggestion, lastCombine.freq);\n        result.addFrequency(lastCombine.token, getCombineFrequency(ir, lastCombine.token));\n        lastCombine = null;\n      } else if (lastCombine == null) {\n        result.add(lastBreak.token, lastBreak.suggestion, lastBreak.freq);\n        result.addFrequency(lastBreak.token, ir.docFreq(new Term(field, lastBreak.token.toString())));\n        lastBreak = null;\n      } else if (lastBreak.freq < lastCombine.freq) {\n        result.add(lastCombine.token, lastCombine.suggestion, lastCombine.freq);\n        result.addFrequency(lastCombine.token, getCombineFrequency(ir, lastCombine.token));\n        lastCombine = null;\n      } else if (lastCombine.freq < lastBreak.freq) {\n        result.add(lastBreak.token, lastBreak.suggestion, lastBreak.freq);\n        result.addFrequency(lastBreak.token, ir.docFreq(new Term(field, lastBreak.token.toString())));\n        lastBreak = null;\n      } else if (breakCount >= combineCount) {\n        result.add(lastCombine.token, lastCombine.suggestion, lastCombine.freq);\n        result.addFrequency(lastCombine.token, getCombineFrequency(ir, lastCombine.token));\n        lastCombine = null;\n      } else {\n        result.add(lastBreak.token, lastBreak.suggestion, lastBreak.freq);\n        result.addFrequency(lastBreak.token, ir.docFreq(new Term(field, lastBreak.token.toString())));\n        lastBreak = null;\n      }\n      if (result.getSuggestions().size() > numSuggestions) {\n        break;\n      }\n      if (lastBreak == null && breakIter.hasNext()) {\n        lastBreak = breakIter.next();\n        breakCount++;\n      }\n      if (lastCombine == null && combineIter.hasNext()) {\n        lastCombine = combineIter.next();\n        combineCount++;\n      }\n    }\n    return result;\n  }\n\n","bugFix":["0ad9ec888e587ca9a3279368245cdf00aabdc108","56d78974d33c1244e0810e0dc8f1c6371faceac9"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f28ba44811b52d5f1b5df98515eadee9f835f116","date":1448994563,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/WordBreakSolrSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/WordBreakSolrSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options)\n      throws IOException {\n    IndexReader ir = options.reader;\n    int numSuggestions = options.count;\n    \n    StringBuilder sb = new StringBuilder();\n    Token[] tokenArr = options.tokens.toArray(new Token[options.tokens.size()]);\n    List<Token> tokenArrWithSeparators = new ArrayList<>(options.tokens.size() + 2);\n    List<Term> termArr = new ArrayList<>(options.tokens.size() + 2);\n    List<ResultEntry> breakSuggestionList = new ArrayList<>();\n    List<ResultEntry> noBreakSuggestionList = new ArrayList<>();\n    boolean lastOneProhibited = false;\n    boolean lastOneRequired = false;\n    boolean lastOneprocedesNewBooleanOp = false;\n    for (int i = 0; i < tokenArr.length; i++) {      \n      boolean prohibited = \n        (tokenArr[i].getFlags() & QueryConverter.PROHIBITED_TERM_FLAG) == \n          QueryConverter.PROHIBITED_TERM_FLAG;\n      boolean required = \n        (tokenArr[i].getFlags() & QueryConverter.REQUIRED_TERM_FLAG) == \n          QueryConverter.REQUIRED_TERM_FLAG;\n      boolean procedesNewBooleanOp = \n        (tokenArr[i].getFlags() & QueryConverter.TERM_PRECEDES_NEW_BOOLEAN_OPERATOR_FLAG) == \n          QueryConverter.TERM_PRECEDES_NEW_BOOLEAN_OPERATOR_FLAG;\n      if (i > 0\n          && (prohibited != lastOneProhibited || required != lastOneRequired || lastOneprocedesNewBooleanOp)) {\n        termArr.add(WordBreakSpellChecker.SEPARATOR_TERM);\n        tokenArrWithSeparators.add(null);\n      }\n      lastOneProhibited = prohibited;\n      lastOneRequired = required;\n      lastOneprocedesNewBooleanOp = procedesNewBooleanOp;\n      \n      Term thisTerm = new Term(field, tokenArr[i].toString());\n      termArr.add(thisTerm);\n      tokenArrWithSeparators.add(tokenArr[i]);\n      if (breakWords) {\n        SuggestWord[][] breakSuggestions = wbsp.suggestWordBreaks(thisTerm,\n            numSuggestions, ir, options.suggestMode, sortMethod);\n        if(breakSuggestions.length==0) {\n          noBreakSuggestionList.add(new ResultEntry(tokenArr[i], null, 0));\n        }\n        for (SuggestWord[] breakSuggestion : breakSuggestions) {\n          sb.delete(0, sb.length());\n          boolean firstOne = true;\n          int freq = 0;\n          for (SuggestWord word : breakSuggestion) {\n            if (!firstOne) {\n              sb.append(\" \");\n            }\n            firstOne = false;\n            sb.append(word.string);\n            if (sortMethod == BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY) {\n              freq = Math.max(freq, word.freq);\n            } else {\n              freq += word.freq;\n            }\n          }\n          breakSuggestionList.add(new ResultEntry(tokenArr[i], sb.toString(),\n              freq));\n        }\n      }\n    }\n    breakSuggestionList.addAll(noBreakSuggestionList);\n    \n    List<ResultEntry> combineSuggestionList = Collections.emptyList();\n    CombineSuggestion[] combineSuggestions = wbsp.suggestWordCombinations(\n        termArr.toArray(new Term[termArr.size()]), numSuggestions, ir, options.suggestMode);\n    if (combineWords) {\n      combineSuggestionList = new ArrayList<>(\n          combineSuggestions.length);\n      for (CombineSuggestion cs : combineSuggestions) {\n        int firstTermIndex = cs.originalTermIndexes[0];\n        int lastTermIndex = cs.originalTermIndexes[cs.originalTermIndexes.length - 1];\n        sb.delete(0, sb.length());\n        for (int i = firstTermIndex; i <= lastTermIndex; i++) {\n          if (i > firstTermIndex) {\n            sb.append(\" \");\n          }\n          sb.append(tokenArrWithSeparators.get(i).toString());\n        }\n        Token token = new Token(sb.toString(), tokenArrWithSeparators.get(firstTermIndex)\n            .startOffset(), tokenArrWithSeparators.get(lastTermIndex).endOffset());\n        combineSuggestionList.add(new ResultEntry(token, cs.suggestion.string,\n            cs.suggestion.freq));\n      }\n    }\n    \n    // Interleave the two lists of suggestions into one SpellingResult\n    SpellingResult result = new SpellingResult();\n    Iterator<ResultEntry> breakIter = breakSuggestionList.iterator();\n    Iterator<ResultEntry> combineIter = combineSuggestionList.iterator();\n    ResultEntry lastBreak = breakIter.hasNext() ? breakIter.next() : null;\n    ResultEntry lastCombine = combineIter.hasNext() ? combineIter.next() : null;\n    int breakCount = 0;\n    int combineCount = 0;\n    while (lastBreak != null || lastCombine != null) {\n      if (lastBreak == null) {\n        addToResult(result, lastCombine.token, getCombineFrequency(ir, lastCombine.token), lastCombine.suggestion, lastCombine.freq);\n        lastCombine = null;\n      } else if (lastCombine == null) {\n        addToResult(result, lastBreak.token, ir.docFreq(new Term(field, lastBreak.token.toString())), lastBreak.suggestion, lastBreak.freq);\n        lastBreak = null;\n      } else if (lastBreak.freq < lastCombine.freq) {\n        addToResult(result, lastCombine.token, getCombineFrequency(ir, lastCombine.token), lastCombine.suggestion, lastCombine.freq);        \n        lastCombine = null;\n      } else if (lastCombine.freq < lastBreak.freq) {\n        addToResult(result, lastBreak.token, ir.docFreq(new Term(field, lastBreak.token.toString())), lastBreak.suggestion, lastBreak.freq);\n        lastBreak = null;\n      } else if (breakCount >= combineCount) { //TODO: Should reverse >= to < ??S\n        addToResult(result, lastCombine.token, getCombineFrequency(ir, lastCombine.token), lastCombine.suggestion, lastCombine.freq);        \n        lastCombine = null;\n      } else {\n        addToResult(result, lastBreak.token, ir.docFreq(new Term(field, lastBreak.token.toString())), lastBreak.suggestion, lastBreak.freq);        \n        lastBreak = null;\n      }\n      if (lastBreak == null && breakIter.hasNext()) {\n        lastBreak = breakIter.next();\n        breakCount++;\n      }\n      if (lastCombine == null && combineIter.hasNext()) {\n        lastCombine = combineIter.next();\n        combineCount++;\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options)\n      throws IOException {\n    IndexReader ir = options.reader;\n    int numSuggestions = options.count;\n    \n    StringBuilder sb = new StringBuilder();\n    Token[] tokenArr = options.tokens.toArray(new Token[options.tokens.size()]);\n    List<Term> termArr = new ArrayList<>(options.tokens.size() + 2);\n    \n    List<ResultEntry> breakSuggestionList = new ArrayList<>();\n    List<ResultEntry> noBreakSuggestionList = new ArrayList<>();\n    boolean lastOneProhibited = false;\n    boolean lastOneRequired = false;\n    boolean lastOneprocedesNewBooleanOp = false;\n    for (int i = 0; i < tokenArr.length; i++) {      \n      boolean prohibited = \n        (tokenArr[i].getFlags() & QueryConverter.PROHIBITED_TERM_FLAG) == \n          QueryConverter.PROHIBITED_TERM_FLAG;\n      boolean required = \n        (tokenArr[i].getFlags() & QueryConverter.REQUIRED_TERM_FLAG) == \n          QueryConverter.REQUIRED_TERM_FLAG;\n      boolean procedesNewBooleanOp = \n        (tokenArr[i].getFlags() & QueryConverter.TERM_PRECEDES_NEW_BOOLEAN_OPERATOR_FLAG) == \n          QueryConverter.TERM_PRECEDES_NEW_BOOLEAN_OPERATOR_FLAG;\n      if (i > 0\n          && (prohibited != lastOneProhibited || required != lastOneRequired || lastOneprocedesNewBooleanOp)) {\n        termArr.add(WordBreakSpellChecker.SEPARATOR_TERM);\n      }\n      lastOneProhibited = prohibited;\n      lastOneRequired = required;\n      lastOneprocedesNewBooleanOp = procedesNewBooleanOp;\n      \n      Term thisTerm = new Term(field, tokenArr[i].toString());\n      termArr.add(thisTerm);\n      if (breakWords) {\n        SuggestWord[][] breakSuggestions = wbsp.suggestWordBreaks(thisTerm,\n            numSuggestions, ir, options.suggestMode, sortMethod);\n        if(breakSuggestions.length==0) {\n          noBreakSuggestionList.add(new ResultEntry(tokenArr[i], null, 0));\n        }\n        for (SuggestWord[] breakSuggestion : breakSuggestions) {\n          sb.delete(0, sb.length());\n          boolean firstOne = true;\n          int freq = 0;\n          for (SuggestWord word : breakSuggestion) {\n            if (!firstOne) {\n              sb.append(\" \");\n            }\n            firstOne = false;\n            sb.append(word.string);\n            if (sortMethod == BreakSuggestionSortMethod.NUM_CHANGES_THEN_MAX_FREQUENCY) {\n              freq = Math.max(freq, word.freq);\n            } else {\n              freq += word.freq;\n            }\n          }\n          breakSuggestionList.add(new ResultEntry(tokenArr[i], sb.toString(),\n              freq));\n        }\n      }\n    }\n    breakSuggestionList.addAll(noBreakSuggestionList);\n    \n    List<ResultEntry> combineSuggestionList = Collections.emptyList();\n    CombineSuggestion[] combineSuggestions = wbsp.suggestWordCombinations(\n        termArr.toArray(new Term[termArr.size()]), numSuggestions, ir, options.suggestMode);\n    if (combineWords) {\n      combineSuggestionList = new ArrayList<>(\n          combineSuggestions.length);\n      for (CombineSuggestion cs : combineSuggestions) {\n        int firstTermIndex = cs.originalTermIndexes[0];\n        int lastTermIndex = cs.originalTermIndexes[cs.originalTermIndexes.length - 1];\n        sb.delete(0, sb.length());\n        for (int i = firstTermIndex; i <= lastTermIndex; i++) {\n          if (i > firstTermIndex) {\n            sb.append(\" \");\n          }\n          sb.append(tokenArr[i].toString());\n        }\n        Token token = new Token(sb.toString(), tokenArr[firstTermIndex]\n            .startOffset(), tokenArr[lastTermIndex].endOffset());\n        combineSuggestionList.add(new ResultEntry(token, cs.suggestion.string,\n            cs.suggestion.freq));\n      }\n    }\n    \n    // Interleave the two lists of suggestions into one SpellingResult\n    SpellingResult result = new SpellingResult();\n    Iterator<ResultEntry> breakIter = breakSuggestionList.iterator();\n    Iterator<ResultEntry> combineIter = combineSuggestionList.iterator();\n    ResultEntry lastBreak = breakIter.hasNext() ? breakIter.next() : null;\n    ResultEntry lastCombine = combineIter.hasNext() ? combineIter.next() : null;\n    int breakCount = 0;\n    int combineCount = 0;\n    while (lastBreak != null || lastCombine != null) {\n      if (lastBreak == null) {\n        addToResult(result, lastCombine.token, getCombineFrequency(ir, lastCombine.token), lastCombine.suggestion, lastCombine.freq);\n        lastCombine = null;\n      } else if (lastCombine == null) {\n        addToResult(result, lastBreak.token, ir.docFreq(new Term(field, lastBreak.token.toString())), lastBreak.suggestion, lastBreak.freq);\n        lastBreak = null;\n      } else if (lastBreak.freq < lastCombine.freq) {\n        addToResult(result, lastCombine.token, getCombineFrequency(ir, lastCombine.token), lastCombine.suggestion, lastCombine.freq);        \n        lastCombine = null;\n      } else if (lastCombine.freq < lastBreak.freq) {\n        addToResult(result, lastBreak.token, ir.docFreq(new Term(field, lastBreak.token.toString())), lastBreak.suggestion, lastBreak.freq);\n        lastBreak = null;\n      } else if (breakCount >= combineCount) { //TODO: Should reverse >= to < ??S\n        addToResult(result, lastCombine.token, getCombineFrequency(ir, lastCombine.token), lastCombine.suggestion, lastCombine.freq);        \n        lastCombine = null;\n      } else {\n        addToResult(result, lastBreak.token, ir.docFreq(new Term(field, lastBreak.token.toString())), lastBreak.suggestion, lastBreak.freq);        \n        lastBreak = null;\n      }\n      if (lastBreak == null && breakIter.hasNext()) {\n        lastBreak = breakIter.next();\n        breakCount++;\n      }\n      if (lastCombine == null && combineIter.hasNext()) {\n        lastCombine = combineIter.next();\n        combineCount++;\n      }\n    }\n    return result;\n  }\n\n","bugFix":["0ad9ec888e587ca9a3279368245cdf00aabdc108"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["56d78974d33c1244e0810e0dc8f1c6371faceac9"],"56d78974d33c1244e0810e0dc8f1c6371faceac9":["0ad9ec888e587ca9a3279368245cdf00aabdc108"],"0ad9ec888e587ca9a3279368245cdf00aabdc108":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8e65acce892eede973379cb2fb3b90ea49a4a5ed":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"f28ba44811b52d5f1b5df98515eadee9f835f116":["8e65acce892eede973379cb2fb3b90ea49a4a5ed"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f28ba44811b52d5f1b5df98515eadee9f835f116"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["8e65acce892eede973379cb2fb3b90ea49a4a5ed"],"56d78974d33c1244e0810e0dc8f1c6371faceac9":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"0ad9ec888e587ca9a3279368245cdf00aabdc108":["56d78974d33c1244e0810e0dc8f1c6371faceac9"],"8e65acce892eede973379cb2fb3b90ea49a4a5ed":["f28ba44811b52d5f1b5df98515eadee9f835f116"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0ad9ec888e587ca9a3279368245cdf00aabdc108"],"f28ba44811b52d5f1b5df98515eadee9f835f116":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}