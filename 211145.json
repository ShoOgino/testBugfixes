{"path":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","commits":[{"id":"a0d196318cb8ce39ae32035f290cd1397833e472","date":1418140712,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req,\"json\");\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if(pieces.size()>=3) blobName = pieces.get(2);\n\n    if(\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\",\"Name not found\");\n        return;\n      }\n      if(req.getContentStreams() == null )  {\n        rsp.add(\"error\",\"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(),payload.position(),payload.limit());\n        String md5 = new BigInteger(1,m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"id\", md5)), 1);\n        if(duplicate.totalHits >0){\n          rsp.add(\"error\", \"duplicate entry\");\n          SolrParams solrParams = new MapSolrParams((Map) ZkNodeProps.makeMap(\n              \"q\", \"id:\" + md5,\n              \"fl\", \"id,size,version,timestamp,blobName\"));\n          try(LocalSolrQueryRequest r = new LocalSolrQueryRequest(req.getCore(), solrParams)) {\n            req.getCore().getRequestHandler(null).handleRequest(r, rsp);\n          }\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            null, 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if(docs.totalHits >0){\n          StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n\n        indexMap(req, makeMap(\n            \"id\", md5,\n            \"blobName\", blobName,\n            \"version\", ++version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload));\n        break;\n      }\n\n    } else {\n      int version =-1;\n      if(pieces.size()>3){\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if(ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))){\n        if(blobName == null ){\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if(version!=-1) q+= \" AND version:{1}\";\n          QParser qparser =  QParser.getParser(MessageFormat.format(q,blobName,version) , \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort( new SortField(\"version\", SortField.Type.LONG, true)));\n          if(docs.totalHits>0){\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter(){\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                StorableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if(buf == null){\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(),0,buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                MessageFormat.format(\"Invalid combination of blobName {0} and version {1}\", blobName,version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) q = \"blobName\" + \":\" + blobName;\n        if (version > -1) q += \" AND version:\" + version;\n\n        SolrParams args = new MapSolrParams((Map) ZkNodeProps.makeMap(\n            \"q\", q,\n            \"fl\", \"id,size,version,timestamp,blobName\",\n            \"sort\", \"version desc\"));\n        try (LocalSolrQueryRequest r  = new LocalSolrQueryRequest(req.getCore(), args)){\n          req.getCore().getRequestHandler(null).handleRequest(r, rsp);\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"34351b686392dd515bbca6de0feda9233eca0ec1","date":1418895646,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req,\"json\");\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if(pieces.size()>=3) blobName = pieces.get(2);\n\n    if(\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\",\"Name not found\");\n        return;\n      }\n      if(req.getContentStreams() == null )  {\n        rsp.add(\"error\",\"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(),payload.position(),payload.limit());\n        String md5 = new BigInteger(1,m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"id\", md5)), 1);\n        if(duplicate.totalHits >0){\n          rsp.add(\"error\", \"duplicate entry\");\n          req.forward(null,\n              new MapSolrParams((Map) makeMap(\n              \"q\", \"id:\" + md5,\n              \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            null, 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if(docs.totalHits >0){\n          StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n\n        indexMap(req, makeMap(\n            \"id\", md5,\n            \"blobName\", blobName,\n            \"version\", ++version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload));\n        break;\n      }\n\n    } else {\n      int version =-1;\n      if(pieces.size()>3){\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if(ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))){\n        if(blobName == null ){\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if(version!=-1) q+= \" AND version:{1}\";\n          QParser qparser =  QParser.getParser(MessageFormat.format(q,blobName,version) , \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort( new SortField(\"version\", SortField.Type.LONG, true)));\n          if(docs.totalHits>0){\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter(){\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                StorableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if(buf == null){\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(),0,buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                MessageFormat.format(\"Invalid combination of blobName {0} and version {1}\", blobName,version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) q = \"blobName\" + \":\" + blobName;\n        if (version > -1) q += \" AND version:\" + version;\n\n        req.forward(null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", q,\n                \"fl\", \"id,size,version,timestamp,blobName\",\n                \"sort\", \"version desc\"))\n            ,rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req,\"json\");\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if(pieces.size()>=3) blobName = pieces.get(2);\n\n    if(\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\",\"Name not found\");\n        return;\n      }\n      if(req.getContentStreams() == null )  {\n        rsp.add(\"error\",\"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(),payload.position(),payload.limit());\n        String md5 = new BigInteger(1,m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"id\", md5)), 1);\n        if(duplicate.totalHits >0){\n          rsp.add(\"error\", \"duplicate entry\");\n          SolrParams solrParams = new MapSolrParams((Map) ZkNodeProps.makeMap(\n              \"q\", \"id:\" + md5,\n              \"fl\", \"id,size,version,timestamp,blobName\"));\n          try(LocalSolrQueryRequest r = new LocalSolrQueryRequest(req.getCore(), solrParams)) {\n            req.getCore().getRequestHandler(null).handleRequest(r, rsp);\n          }\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            null, 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if(docs.totalHits >0){\n          StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n\n        indexMap(req, makeMap(\n            \"id\", md5,\n            \"blobName\", blobName,\n            \"version\", ++version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload));\n        break;\n      }\n\n    } else {\n      int version =-1;\n      if(pieces.size()>3){\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if(ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))){\n        if(blobName == null ){\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if(version!=-1) q+= \" AND version:{1}\";\n          QParser qparser =  QParser.getParser(MessageFormat.format(q,blobName,version) , \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort( new SortField(\"version\", SortField.Type.LONG, true)));\n          if(docs.totalHits>0){\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter(){\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                StorableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if(buf == null){\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(),0,buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                MessageFormat.format(\"Invalid combination of blobName {0} and version {1}\", blobName,version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) q = \"blobName\" + \":\" + blobName;\n        if (version > -1) q += \" AND version:\" + version;\n\n        SolrParams args = new MapSolrParams((Map) ZkNodeProps.makeMap(\n            \"q\", q,\n            \"fl\", \"id,size,version,timestamp,blobName\",\n            \"sort\", \"version desc\"));\n        try (LocalSolrQueryRequest r  = new LocalSolrQueryRequest(req.getCore(), args)){\n          req.getCore().getRequestHandler(null).handleRequest(r, rsp);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["bd915b3766935715579f128e83173b690e2504a8"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4ac60f04ae5100329a7aeb332ec715fd5775437","date":1420116442,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req,\"json\");\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if(pieces.size()>=3) blobName = pieces.get(2);\n\n    if(\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\",\"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if(err!=null){\n        rsp.add(\"error\", err);\n        return;\n      }\n      if(req.getContentStreams() == null )  {\n        rsp.add(\"error\",\"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(),payload.position(),payload.limit());\n        String md5 = new BigInteger(1,m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if(duplicate.totalHits >0){\n          rsp.add(\"error\", \"duplicate entry\");\n          req.forward(null,\n              new MapSolrParams((Map) makeMap(\n              \"q\", \"md5:\" + md5,\n              \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            null, 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if(docs.totalHits >0){\n          StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName+\"/\"+version;\n        indexMap(req, makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload));\n        break;\n      }\n\n    } else {\n      int version =-1;\n      if(pieces.size()>3){\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if(ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))){\n        if(blobName == null ){\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if(version != -1) q = \"id:{0}/{1}\";\n          QParser qparser =  QParser.getParser(MessageFormat.format(q,blobName,version) , \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort( new SortField(\"version\", SortField.Type.LONG, true)));\n          if(docs.totalHits>0){\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter(){\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                StorableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if(buf == null){\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(),0,buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                MessageFormat.format(\"Invalid combination of blobName {0} and version {1}\", blobName,version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if(blobName != null){\n          q = \"blobName:{0}\";\n          if(version != -1){\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        req.forward(null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", MessageFormat.format(q,blobName,version),\n                \"fl\", \"id,size,version,timestamp,blobName\",\n                \"sort\", \"version desc\"))\n            ,rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req,\"json\");\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if(pieces.size()>=3) blobName = pieces.get(2);\n\n    if(\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\",\"Name not found\");\n        return;\n      }\n      if(req.getContentStreams() == null )  {\n        rsp.add(\"error\",\"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(),payload.position(),payload.limit());\n        String md5 = new BigInteger(1,m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"id\", md5)), 1);\n        if(duplicate.totalHits >0){\n          rsp.add(\"error\", \"duplicate entry\");\n          req.forward(null,\n              new MapSolrParams((Map) makeMap(\n              \"q\", \"id:\" + md5,\n              \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            null, 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if(docs.totalHits >0){\n          StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n\n        indexMap(req, makeMap(\n            \"id\", md5,\n            \"blobName\", blobName,\n            \"version\", ++version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload));\n        break;\n      }\n\n    } else {\n      int version =-1;\n      if(pieces.size()>3){\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if(ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))){\n        if(blobName == null ){\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if(version!=-1) q+= \" AND version:{1}\";\n          QParser qparser =  QParser.getParser(MessageFormat.format(q,blobName,version) , \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort( new SortField(\"version\", SortField.Type.LONG, true)));\n          if(docs.totalHits>0){\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter(){\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                StorableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if(buf == null){\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(),0,buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                MessageFormat.format(\"Invalid combination of blobName {0} and version {1}\", blobName,version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) q = \"blobName\" + \":\" + blobName;\n        if (version > -1) q += \" AND version:\" + version;\n\n        req.forward(null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", q,\n                \"fl\", \"id,size,version,timestamp,blobName\",\n                \"sort\", \"version desc\"))\n            ,rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"432e578be72da02cfde62dcc7fb4fa8620bc85fd","date":1420557072,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req,\"json\");\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if(pieces.size()>=3) blobName = pieces.get(2);\n\n    if(\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\",\"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if(err!=null){\n        rsp.add(\"error\", err);\n        return;\n      }\n      if(req.getContentStreams() == null )  {\n        rsp.add(\"error\",\"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(),payload.position(),payload.limit());\n        String md5 = new BigInteger(1,m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if(duplicate.totalHits >0){\n          rsp.add(\"error\", \"duplicate entry\");\n          req.forward(null,\n              new MapSolrParams((Map) makeMap(\n              \"q\", \"md5:\" + md5,\n              \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            null, 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if(docs.totalHits >0){\n          StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName+\"/\"+version;\n        indexMap(req, makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload));\n        break;\n      }\n\n    } else {\n      int version =-1;\n      if(pieces.size()>3){\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if(ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))){\n        if(blobName == null ){\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if(version != -1) q = \"id:{0}/{1}\";\n          QParser qparser =  QParser.getParser(MessageFormat.format(q,blobName,version) , \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort( new SortField(\"version\", SortField.Type.LONG, true)));\n          if(docs.totalHits>0){\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter(){\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                StorableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if(buf == null){\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(),0,buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                MessageFormat.format(\"Invalid combination of blobName {0} and version {1}\", blobName,version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if(blobName != null){\n          q = \"blobName:{0}\";\n          if(version != -1){\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        req.forward(null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", MessageFormat.format(q,blobName,version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            ,rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req,\"json\");\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if(pieces.size()>=3) blobName = pieces.get(2);\n\n    if(\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\",\"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if(err!=null){\n        rsp.add(\"error\", err);\n        return;\n      }\n      if(req.getContentStreams() == null )  {\n        rsp.add(\"error\",\"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(),payload.position(),payload.limit());\n        String md5 = new BigInteger(1,m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if(duplicate.totalHits >0){\n          rsp.add(\"error\", \"duplicate entry\");\n          req.forward(null,\n              new MapSolrParams((Map) makeMap(\n              \"q\", \"md5:\" + md5,\n              \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            null, 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if(docs.totalHits >0){\n          StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName+\"/\"+version;\n        indexMap(req, makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload));\n        break;\n      }\n\n    } else {\n      int version =-1;\n      if(pieces.size()>3){\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if(ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))){\n        if(blobName == null ){\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if(version != -1) q = \"id:{0}/{1}\";\n          QParser qparser =  QParser.getParser(MessageFormat.format(q,blobName,version) , \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort( new SortField(\"version\", SortField.Type.LONG, true)));\n          if(docs.totalHits>0){\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter(){\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                StorableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if(buf == null){\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(),0,buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                MessageFormat.format(\"Invalid combination of blobName {0} and version {1}\", blobName,version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if(blobName != null){\n          q = \"blobName:{0}\";\n          if(version != -1){\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        req.forward(null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", MessageFormat.format(q,blobName,version),\n                \"fl\", \"id,size,version,timestamp,blobName\",\n                \"sort\", \"version desc\"))\n            ,rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4620bf9ef8a95eeaa92aa547a4d2aca2ca5d2fb6","date":1420715197,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req,\"json\");\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if(pieces.size()>=3) blobName = pieces.get(2);\n\n    if(\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\",\"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if(err!=null){\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if(req.getContentStreams() == null )  {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\",\"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(),payload.position(),payload.limit());\n        String md5 = new BigInteger(1,m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if(duplicate.totalHits >0){\n          rsp.add(\"error\", \"duplicate entry\");\n          req.forward(null,\n              new MapSolrParams((Map) makeMap(\n              \"q\", \"md5:\" + md5,\n              \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\"+blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            null, 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if(docs.totalHits >0){\n          StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName+\"/\"+version;\n        log.info(MessageFormat.format(\"New blob inserting {0} ,size {1}, md5 {2}\",id, payload.limit(),md5));\n        indexMap(req, rsp, makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload));\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \",id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version =-1;\n      if(pieces.size()>3){\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if(ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))){\n        if(blobName == null ){\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if(version != -1) q = \"id:{0}/{1}\";\n          QParser qparser =  QParser.getParser(MessageFormat.format(q,blobName,version) , \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort( new SortField(\"version\", SortField.Type.LONG, true)));\n          if(docs.totalHits>0){\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter(){\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                StorableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if(buf == null){\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(),0,buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                MessageFormat.format(\"Invalid combination of blobName {0} and version {1}\", blobName,version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if(blobName != null){\n          q = \"blobName:{0}\";\n          if(version != -1){\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        req.forward(null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", MessageFormat.format(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req,\"json\");\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if(pieces.size()>=3) blobName = pieces.get(2);\n\n    if(\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\",\"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if(err!=null){\n        rsp.add(\"error\", err);\n        return;\n      }\n      if(req.getContentStreams() == null )  {\n        rsp.add(\"error\",\"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(),payload.position(),payload.limit());\n        String md5 = new BigInteger(1,m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if(duplicate.totalHits >0){\n          rsp.add(\"error\", \"duplicate entry\");\n          req.forward(null,\n              new MapSolrParams((Map) makeMap(\n              \"q\", \"md5:\" + md5,\n              \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            null, 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if(docs.totalHits >0){\n          StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName+\"/\"+version;\n        indexMap(req, makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload));\n        break;\n      }\n\n    } else {\n      int version =-1;\n      if(pieces.size()>3){\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if(ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))){\n        if(blobName == null ){\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if(version != -1) q = \"id:{0}/{1}\";\n          QParser qparser =  QParser.getParser(MessageFormat.format(q,blobName,version) , \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort( new SortField(\"version\", SortField.Type.LONG, true)));\n          if(docs.totalHits>0){\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter(){\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                StorableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if(buf == null){\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(),0,buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                MessageFormat.format(\"Invalid combination of blobName {0} and version {1}\", blobName,version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if(blobName != null){\n          q = \"blobName:{0}\";\n          if(version != -1){\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        req.forward(null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", MessageFormat.format(q,blobName,version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            ,rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f46340080a63f8bb8358e83e88dba6ad13faf103","date":1421824628,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req,\"json\");\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if(pieces.size()>=3) blobName = pieces.get(2);\n\n    if(\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\",\"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if(err!=null){\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if(req.getContentStreams() == null )  {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\",\"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(),payload.position(),payload.limit());\n        String md5 = new BigInteger(1,m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if(duplicate.totalHits >0){\n          rsp.add(\"error\", \"duplicate entry\");\n          req.forward(null,\n              new MapSolrParams((Map) makeMap(\n              \"q\", \"md5:\" + md5,\n              \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\"+blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            null, 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if(docs.totalHits >0){\n          StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName+\"/\"+version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(MessageFormat.format(\"New blob inserting {0} ,size {1}, md5 {2}\",doc.get(\"id\"), payload.limit(),md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \",id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version =-1;\n      if(pieces.size()>3){\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if(ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))){\n        if(blobName == null ){\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if(version != -1) q = \"id:{0}/{1}\";\n          QParser qparser =  QParser.getParser(MessageFormat.format(q,blobName,version) , \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort( new SortField(\"version\", SortField.Type.LONG, true)));\n          if(docs.totalHits>0){\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter(){\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                StorableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if(buf == null){\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(),0,buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                MessageFormat.format(\"Invalid combination of blobName {0} and version {1}\", blobName,version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if(blobName != null){\n          q = \"blobName:{0}\";\n          if(version != -1){\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        req.forward(null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", MessageFormat.format(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req,\"json\");\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if(pieces.size()>=3) blobName = pieces.get(2);\n\n    if(\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\",\"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if(err!=null){\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if(req.getContentStreams() == null )  {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\",\"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(),payload.position(),payload.limit());\n        String md5 = new BigInteger(1,m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if(duplicate.totalHits >0){\n          rsp.add(\"error\", \"duplicate entry\");\n          req.forward(null,\n              new MapSolrParams((Map) makeMap(\n              \"q\", \"md5:\" + md5,\n              \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\"+blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            null, 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if(docs.totalHits >0){\n          StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName+\"/\"+version;\n        log.info(MessageFormat.format(\"New blob inserting {0} ,size {1}, md5 {2}\",id, payload.limit(),md5));\n        indexMap(req, rsp, makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload));\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \",id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version =-1;\n      if(pieces.size()>3){\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if(ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))){\n        if(blobName == null ){\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if(version != -1) q = \"id:{0}/{1}\";\n          QParser qparser =  QParser.getParser(MessageFormat.format(q,blobName,version) , \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort( new SortField(\"version\", SortField.Type.LONG, true)));\n          if(docs.totalHits>0){\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter(){\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                StorableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if(buf == null){\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(),0,buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                MessageFormat.format(\"Invalid combination of blobName {0} and version {1}\", blobName,version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if(blobName != null){\n          q = \"blobName:{0}\";\n          if(version != -1){\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        req.forward(null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", MessageFormat.format(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"28737337dc04b06b0c7366b4ac9db5082c6089bb","date":1423950368,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req,\"json\");\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if(pieces.size()>=3) blobName = pieces.get(2);\n\n    if(\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\",\"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if(err!=null){\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if(req.getContentStreams() == null )  {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\",\"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(),payload.position(),payload.limit());\n        String md5 = new BigInteger(1,m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if(duplicate.totalHits >0){\n          rsp.add(\"error\", \"duplicate entry\");\n          req.forward(null,\n              new MapSolrParams((Map) makeMap(\n              \"q\", \"md5:\" + md5,\n              \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\"+blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            null, 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if(docs.totalHits >0){\n          StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName+\"/\"+version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(MessageFormat.format(\"inserting new blob {0} ,size {1}, md5 {2}\",doc.get(\"id\"), String.valueOf(payload.limit()),md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \",id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version =-1;\n      if(pieces.size()>3){\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if(ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))){\n        if(blobName == null ){\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if(version != -1) q = \"id:{0}/{1}\";\n          QParser qparser =  QParser.getParser(MessageFormat.format(q,blobName,version) , \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort( new SortField(\"version\", SortField.Type.LONG, true)));\n          if(docs.totalHits>0){\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter(){\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                StorableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if(buf == null){\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(),0,buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                MessageFormat.format(\"Invalid combination of blobName {0} and version {1}\", blobName,String.valueOf(version)));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if(blobName != null){\n          q = \"blobName:{0}\";\n          if(version != -1){\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        req.forward(null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", MessageFormat.format(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req,\"json\");\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if(pieces.size()>=3) blobName = pieces.get(2);\n\n    if(\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\",\"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if(err!=null){\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if(req.getContentStreams() == null )  {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\",\"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(),payload.position(),payload.limit());\n        String md5 = new BigInteger(1,m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if(duplicate.totalHits >0){\n          rsp.add(\"error\", \"duplicate entry\");\n          req.forward(null,\n              new MapSolrParams((Map) makeMap(\n              \"q\", \"md5:\" + md5,\n              \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\"+blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            null, 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if(docs.totalHits >0){\n          StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName+\"/\"+version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(MessageFormat.format(\"New blob inserting {0} ,size {1}, md5 {2}\",doc.get(\"id\"), payload.limit(),md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \",id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version =-1;\n      if(pieces.size()>3){\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if(ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))){\n        if(blobName == null ){\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if(version != -1) q = \"id:{0}/{1}\";\n          QParser qparser =  QParser.getParser(MessageFormat.format(q,blobName,version) , \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort( new SortField(\"version\", SortField.Type.LONG, true)));\n          if(docs.totalHits>0){\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter(){\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                StorableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if(buf == null){\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(),0,buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                MessageFormat.format(\"Invalid combination of blobName {0} and version {1}\", blobName,version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if(blobName != null){\n          q = \"blobName:{0}\";\n          if(version != -1){\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        req.forward(null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", MessageFormat.format(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc","date":1424799790,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req,\"json\");\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if(pieces.size()>=3) blobName = pieces.get(2);\n\n    if(\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\",\"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if(err!=null){\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if(req.getContentStreams() == null )  {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\",\"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(),payload.position(),payload.limit());\n        String md5 = new BigInteger(1,m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if(duplicate.totalHits >0){\n          rsp.add(\"error\", \"duplicate entry\");\n          req.forward(null,\n              new MapSolrParams((Map) makeMap(\n              \"q\", \"md5:\" + md5,\n              \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\"+blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if(docs.totalHits >0){\n          StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName+\"/\"+version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(MessageFormat.format(\"inserting new blob {0} ,size {1}, md5 {2}\",doc.get(\"id\"), String.valueOf(payload.limit()),md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \",id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version =-1;\n      if(pieces.size()>3){\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if(ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))){\n        if(blobName == null ){\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if(version != -1) q = \"id:{0}/{1}\";\n          QParser qparser =  QParser.getParser(MessageFormat.format(q,blobName,version) , \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort( new SortField(\"version\", SortField.Type.LONG, true)));\n          if(docs.totalHits>0){\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter(){\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                StorableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if(buf == null){\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(),0,buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                MessageFormat.format(\"Invalid combination of blobName {0} and version {1}\", blobName,String.valueOf(version)));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if(blobName != null){\n          q = \"blobName:{0}\";\n          if(version != -1){\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        req.forward(null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", MessageFormat.format(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req,\"json\");\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if(pieces.size()>=3) blobName = pieces.get(2);\n\n    if(\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\",\"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if(err!=null){\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if(req.getContentStreams() == null )  {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\",\"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(),payload.position(),payload.limit());\n        String md5 = new BigInteger(1,m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if(duplicate.totalHits >0){\n          rsp.add(\"error\", \"duplicate entry\");\n          req.forward(null,\n              new MapSolrParams((Map) makeMap(\n              \"q\", \"md5:\" + md5,\n              \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\"+blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            null, 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if(docs.totalHits >0){\n          StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName+\"/\"+version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(MessageFormat.format(\"inserting new blob {0} ,size {1}, md5 {2}\",doc.get(\"id\"), String.valueOf(payload.limit()),md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \",id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version =-1;\n      if(pieces.size()>3){\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if(ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))){\n        if(blobName == null ){\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if(version != -1) q = \"id:{0}/{1}\";\n          QParser qparser =  QParser.getParser(MessageFormat.format(q,blobName,version) , \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort( new SortField(\"version\", SortField.Type.LONG, true)));\n          if(docs.totalHits>0){\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter(){\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                StorableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if(buf == null){\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(),0,buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                MessageFormat.format(\"Invalid combination of blobName {0} and version {1}\", blobName,String.valueOf(version)));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if(blobName != null){\n          q = \"blobName:{0}\";\n          if(version != -1){\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        req.forward(null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", MessageFormat.format(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c352c6a130ba2458c59ac61b1663c0d5bd145be8","date":1426607656,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, \"json\");\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          req.forward(null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(MessageFormat.format(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(\"id\"), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(MessageFormat.format(q, blobName, version), \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                StorableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                MessageFormat.format(\"Invalid combination of blobName {0} and version {1}\", blobName, String.valueOf(version)));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        req.forward(null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", MessageFormat.format(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req,\"json\");\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if(pieces.size()>=3) blobName = pieces.get(2);\n\n    if(\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\",\"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if(err!=null){\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if(req.getContentStreams() == null )  {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\",\"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(),payload.position(),payload.limit());\n        String md5 = new BigInteger(1,m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if(duplicate.totalHits >0){\n          rsp.add(\"error\", \"duplicate entry\");\n          req.forward(null,\n              new MapSolrParams((Map) makeMap(\n              \"q\", \"md5:\" + md5,\n              \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\"+blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if(docs.totalHits >0){\n          StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName+\"/\"+version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(MessageFormat.format(\"inserting new blob {0} ,size {1}, md5 {2}\",doc.get(\"id\"), String.valueOf(payload.limit()),md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \",id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version =-1;\n      if(pieces.size()>3){\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if(ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))){\n        if(blobName == null ){\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if(version != -1) q = \"id:{0}/{1}\";\n          QParser qparser =  QParser.getParser(MessageFormat.format(q,blobName,version) , \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort( new SortField(\"version\", SortField.Type.LONG, true)));\n          if(docs.totalHits>0){\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter(){\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                StorableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if(buf == null){\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(),0,buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                MessageFormat.format(\"Invalid combination of blobName {0} and version {1}\", blobName,String.valueOf(version)));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if(blobName != null){\n          q = \"blobName:{0}\";\n          if(version != -1){\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        req.forward(null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", MessageFormat.format(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["00bfa246dd03239965db3e388077a8929299bb42"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9bdb19206b4aeab66b9fb393c53969f44bdd48be","date":1426629125,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, \"json\");\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          req.forward(null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(\"id\"), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                StorableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        req.forward(null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, \"json\");\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          req.forward(null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(MessageFormat.format(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(\"id\"), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(MessageFormat.format(q, blobName, version), \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                StorableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                MessageFormat.format(\"Invalid combination of blobName {0} and version {1}\", blobName, String.valueOf(version)));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        req.forward(null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", MessageFormat.format(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, \"json\");\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          req.forward(null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(\"id\"), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                StorableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        req.forward(null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req,\"json\");\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if(pieces.size()>=3) blobName = pieces.get(2);\n\n    if(\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\",\"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if(err!=null){\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if(req.getContentStreams() == null )  {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\",\"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(),payload.position(),payload.limit());\n        String md5 = new BigInteger(1,m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if(duplicate.totalHits >0){\n          rsp.add(\"error\", \"duplicate entry\");\n          req.forward(null,\n              new MapSolrParams((Map) makeMap(\n              \"q\", \"md5:\" + md5,\n              \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\"+blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if(docs.totalHits >0){\n          StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName+\"/\"+version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(MessageFormat.format(\"inserting new blob {0} ,size {1}, md5 {2}\",doc.get(\"id\"), String.valueOf(payload.limit()),md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \",id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version =-1;\n      if(pieces.size()>3){\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if(ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))){\n        if(blobName == null ){\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if(version != -1) q = \"id:{0}/{1}\";\n          QParser qparser =  QParser.getParser(MessageFormat.format(q,blobName,version) , \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort( new SortField(\"version\", SortField.Type.LONG, true)));\n          if(docs.totalHits>0){\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter(){\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                StorableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if(buf == null){\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(),0,buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                MessageFormat.format(\"Invalid combination of blobName {0} and version {1}\", blobName,String.valueOf(version)));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if(blobName != null){\n          q = \"blobName:{0}\";\n          if(version != -1){\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        req.forward(null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", MessageFormat.format(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1390137e395d2f07f9ba5b8c43d293befe84d563","date":1427947685,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          req.forward(null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(\"id\"), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                StorableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        req.forward(null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, \"json\");\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          req.forward(null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(\"id\"), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                StorableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        req.forward(null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          req.forward(null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(\"id\"), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                StorableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        req.forward(null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, \"json\");\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          req.forward(null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(\"id\"), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                StorableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        req.forward(null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd915b3766935715579f128e83173b690e2504a8","date":1428590582,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(\"id\"), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                StorableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          req.forward(null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(\"id\"), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                StorableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        req.forward(null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":["34351b686392dd515bbca6de0feda9233eca0ec1"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c","date":1453060490,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(\"id\"), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(\"id\"), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                StoredDocument doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                StorableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cc5ee54a993d26579e3fe1f8f2a696b46b61c48f","date":1470751445,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(\"id\"), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(\"id\"), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8bca25eefa1f2205e2b0ef713701dc3a0fecd702","date":1470810578,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(\"id\"), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(\"id\"), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(\"id\"), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(\"id\"), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(\"id\"), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(\"id\"), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), \"lucene\", req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fcf710a8fcd590cf55c855d422c7a10fce3e6117","date":1485842253,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(\"id\"), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(\"id\"), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c3523a0ab04c3002eee3896c75ea5f10f388bcc","date":1485968422,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(\"id\"), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = (String) req.getContext().get(\"httpMethod\");\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(\"id\"), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6d2dadc1f5ca8703d8659f4964961f9967935d75","date":1490231750,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(\"id\"), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"01624b85de12fb02335810bdf325124e59040772","date":1490254940,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                SORT, \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e5fa6615014cd2288fe930f8c8bb726f9504961d","date":1490280013,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            \"id\", id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            \"version\", version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(\"id\"), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6f4c5d3859373c3a74734e85efa122b17514e3e8","date":1490280013,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                SORT, \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                \"sort\", \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a8c611a68829ce670498db444c39975f66888dfd","date":1494922075,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    RequestHandlerUtils.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                SORT, \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                SORT, \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a513b6a92751e54c76fb5447948c9e7d437163a7","date":1496136565,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    RequestHandlerUtils.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                SORT, \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                SORT, \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74aea047dff7f7c38a2d766827bd20d356f98c6a","date":1496721416,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    RequestHandlerUtils.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                SORT, \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                SORT, \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    RequestHandlerUtils.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                SORT, \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    SolrConfigHandler.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                SORT, \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55ed5a78f8a4b37108ac73a894a105db562d303e","date":1500477652,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    RequestHandlerUtils.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            CommonParams.TYPE, \"blob\",\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                SORT, \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    RequestHandlerUtils.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                SORT, \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c304e97e7c1d472bc70e801b35ee78583916c6cd","date":1507105431,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    RequestHandlerUtils.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            CommonParams.TYPE, \"blob\",\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                SORT, \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    RequestHandlerUtils.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                SORT, \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"560c18d71dad43d675158783c3840f8c80d6d39c","date":1507105532,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    RequestHandlerUtils.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            CommonParams.TYPE, \"blob\",\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                SORT, \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    RequestHandlerUtils.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                SORT, \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f15af35d55d70c34451f9df5edeaeff6b31f8cbe","date":1519625627,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    RequestHandlerUtils.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload;\n        try (InputStream is = stream.getStream()) {\n          payload = SimplePostTool.inputStreamToByteArray(is, maxSize);\n        }\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            CommonParams.TYPE, \"blob\",\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                SORT, \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    RequestHandlerUtils.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            CommonParams.TYPE, \"blob\",\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                SORT, \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ac35531329b1809368fb0780bcf1e72d0add3c21","date":1525474926,"type":3,"author":"Mark Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    RequestHandlerUtils.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload;\n        payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        \n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            CommonParams.TYPE, \"blob\",\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                SORT, \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    RequestHandlerUtils.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload;\n        try (InputStream is = stream.getStream()) {\n          payload = SimplePostTool.inputStreamToByteArray(is, maxSize);\n        }\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            CommonParams.TYPE, \"blob\",\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                SORT, \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cff47d27eb02068a9e554ff2d11e4bfd83875c20","date":1525634759,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    RequestHandlerUtils.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload;\n        try (InputStream is = stream.getStream()) {\n          payload = SimplePostTool.inputStreamToByteArray(is, maxSize);\n        }\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            CommonParams.TYPE, \"blob\",\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                SORT, \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    RequestHandlerUtils.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload;\n        payload = SimplePostTool.inputStreamToByteArray(stream.getStream(), maxSize);\n        \n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            CommonParams.TYPE, \"blob\",\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                SORT, \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    RequestHandlerUtils.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload;\n        try (InputStream is = stream.getStream()) {\n          payload = SimplePostTool.inputStreamToByteArray(is, maxSize);\n        }\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        int duplicateCount = req.getSearcher().count(new TermQuery(new Term(\"md5\", md5)));\n        if (duplicateCount > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits.value > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            CommonParams.TYPE, \"blob\",\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits.value > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                SORT, \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    RequestHandlerUtils.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload;\n        try (InputStream is = stream.getStream()) {\n          payload = SimplePostTool.inputStreamToByteArray(is, maxSize);\n        }\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        TopDocs duplicate = req.getSearcher().search(new TermQuery(new Term(\"md5\", md5)), 1);\n        if (duplicate.totalHits > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            CommonParams.TYPE, \"blob\",\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                SORT, \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"00bfa246dd03239965db3e388077a8929299bb42","date":1568492597,"type":3,"author":"Jan Hydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    RequestHandlerUtils.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload;\n        try (InputStream is = stream.getStream()) {\n          payload = SimplePostTool.inputStreamToByteArray(is, maxSize);\n        }\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new String(Hex.encodeHex(m.digest()));\n\n        int duplicateCount = req.getSearcher().count(new TermQuery(new Term(\"md5\", md5)));\n        if (duplicateCount > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits.value > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            CommonParams.TYPE, \"blob\",\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits.value > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                SORT, \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    RequestHandlerUtils.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload;\n        try (InputStream is = stream.getStream()) {\n          payload = SimplePostTool.inputStreamToByteArray(is, maxSize);\n        }\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new BigInteger(1, m.digest()).toString(16);\n\n        int duplicateCount = req.getSearcher().count(new TermQuery(new Term(\"md5\", md5)));\n        if (duplicateCount > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits.value > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            CommonParams.TYPE, \"blob\",\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits.value > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                SORT, \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":["c352c6a130ba2458c59ac61b1663c0d5bd145be8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4","date":1588172214,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    RequestHandlerUtils.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload;\n        try (InputStream is = stream.getStream()) {\n          payload = SimplePostTool.inputStreamToByteArray(is, maxSize);\n        }\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new String(Hex.encodeHex(m.digest()));\n\n        int duplicateCount = req.getSearcher().count(new TermQuery(new Term(\"md5\", md5)));\n        if (duplicateCount > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob : {}\", blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits.value > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            CommonParams.TYPE, \"blob\",\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        if (log.isInfoEnabled()) {\n          log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        }\n        indexMap(req, rsp, doc);\n        if (log.isInfoEnabled()) {\n          log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n        }\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits.value > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                SORT, \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    RequestHandlerUtils.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload;\n        try (InputStream is = stream.getStream()) {\n          payload = SimplePostTool.inputStreamToByteArray(is, maxSize);\n        }\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new String(Hex.encodeHex(m.digest()));\n\n        int duplicateCount = req.getSearcher().count(new TermQuery(new Term(\"md5\", md5)));\n        if (duplicateCount > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob :\" + blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits.value > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            CommonParams.TYPE, \"blob\",\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        indexMap(req, rsp, doc);\n        log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits.value > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                SORT, \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2caf6d6e842e1a4e4ae68ec6dfa5139c31a84ec5","date":1591384964,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/BlobHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    RequestHandlerUtils.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload;\n        try (InputStream is = stream.getStream()) {\n          payload = SimplePostTool.inputStreamToByteArray(is, maxSize);\n        }\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new String(Hex.encodeHex(m.digest()));\n\n        int duplicateCount = req.getSearcher().count(new TermQuery(new Term(\"md5\", md5)));\n        if (duplicateCount > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob : {}\", blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits.value > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            CommonParams.TYPE, \"blob\",\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        if (log.isInfoEnabled()) {\n          log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        }\n        indexMap(req, rsp, doc);\n        if (log.isInfoEnabled()) {\n          log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n        }\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits.value > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                SORT, \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(final SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    String httpMethod = req.getHttpMethod();\n    String path = (String) req.getContext().get(\"path\");\n    RequestHandlerUtils.setWt(req, JSON);\n\n    List<String> pieces = StrUtils.splitSmart(path, '/');\n    String blobName = null;\n    if (pieces.size() >= 3) blobName = pieces.get(2);\n\n    if (\"POST\".equals(httpMethod)) {\n      if (blobName == null || blobName.isEmpty()) {\n        rsp.add(\"error\", \"Name not found\");\n        return;\n      }\n      String err = SolrConfigHandler.validateName(blobName);\n      if (err != null) {\n        log.warn(\"no blob name\");\n        rsp.add(\"error\", err);\n        return;\n      }\n      if (req.getContentStreams() == null) {\n        log.warn(\"no content stream\");\n        rsp.add(\"error\", \"No stream\");\n        return;\n      }\n\n\n      for (ContentStream stream : req.getContentStreams()) {\n        ByteBuffer payload;\n        try (InputStream is = stream.getStream()) {\n          payload = SimplePostTool.inputStreamToByteArray(is, maxSize);\n        }\n        MessageDigest m = MessageDigest.getInstance(\"MD5\");\n        m.update(payload.array(), payload.position(), payload.limit());\n        String md5 = new String(Hex.encodeHex(m.digest()));\n\n        int duplicateCount = req.getSearcher().count(new TermQuery(new Term(\"md5\", md5)));\n        if (duplicateCount > 0) {\n          rsp.add(\"error\", \"duplicate entry\");\n          forward(req, null,\n              new MapSolrParams((Map) makeMap(\n                  \"q\", \"md5:\" + md5,\n                  \"fl\", \"id,size,version,timestamp,blobName\")),\n              rsp);\n          log.warn(\"duplicate entry for blob : {}\", blobName);\n          return;\n        }\n\n        TopFieldDocs docs = req.getSearcher().search(new TermQuery(new Term(\"blobName\", blobName)),\n            1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n\n        long version = 0;\n        if (docs.totalHits.value > 0) {\n          Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n          Number n = doc.getField(\"version\").numericValue();\n          version = n.longValue();\n        }\n        version++;\n        String id = blobName + \"/\" + version;\n        Map<String, Object> doc = makeMap(\n            ID, id,\n            CommonParams.TYPE, \"blob\",\n            \"md5\", md5,\n            \"blobName\", blobName,\n            VERSION, version,\n            \"timestamp\", new Date(),\n            \"size\", payload.limit(),\n            \"blob\", payload);\n        verifyWithRealtimeGet(blobName, version, req, doc);\n        if (log.isInfoEnabled()) {\n          log.info(StrUtils.formatString(\"inserting new blob {0} ,size {1}, md5 {2}\", doc.get(ID), String.valueOf(payload.limit()), md5));\n        }\n        indexMap(req, rsp, doc);\n        if (log.isInfoEnabled()) {\n          log.info(\" Successfully Added and committed a blob with id {} and size {} \", id, payload.limit());\n        }\n\n        break;\n      }\n\n    } else {\n      int version = -1;\n      if (pieces.size() > 3) {\n        try {\n          version = Integer.parseInt(pieces.get(3));\n        } catch (NumberFormatException e) {\n          rsp.add(\"error\", \"Invalid version\" + pieces.get(3));\n          return;\n        }\n\n      }\n      if (ReplicationHandler.FILE_STREAM.equals(req.getParams().get(CommonParams.WT))) {\n        if (blobName == null) {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Please send the request in the format /blob/<blobName>/<version>\");\n        } else {\n          String q = \"blobName:{0}\";\n          if (version != -1) q = \"id:{0}/{1}\";\n          QParser qparser = QParser.getParser(StrUtils.formatString(q, blobName, version), req);\n          final TopDocs docs = req.getSearcher().search(qparser.parse(), 1, new Sort(new SortField(\"version\", SortField.Type.LONG, true)));\n          if (docs.totalHits.value > 0) {\n            rsp.add(ReplicationHandler.FILE_STREAM, new SolrCore.RawWriter() {\n\n              @Override\n              public void write(OutputStream os) throws IOException {\n                Document doc = req.getSearcher().doc(docs.scoreDocs[0].doc);\n                IndexableField sf = doc.getField(\"blob\");\n                FieldType fieldType = req.getSchema().getField(\"blob\").getType();\n                ByteBuffer buf = (ByteBuffer) fieldType.toObject(sf);\n                if (buf == null) {\n                  //should never happen unless a user wrote this document directly\n                  throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"Invalid document . No field called blob\");\n                } else {\n                  os.write(buf.array(), 0, buf.limit());\n                }\n              }\n            });\n\n          } else {\n            throw new SolrException(SolrException.ErrorCode.NOT_FOUND,\n                StrUtils.formatString(\"Invalid combination of blobName {0} and version {1}\", blobName, version));\n          }\n\n        }\n      } else {\n        String q = \"*:*\";\n        if (blobName != null) {\n          q = \"blobName:{0}\";\n          if (version != -1) {\n            q = \"id:{0}/{1}\";\n          }\n        }\n\n        forward(req, null,\n            new MapSolrParams((Map) makeMap(\n                \"q\", StrUtils.formatString(q, blobName, version),\n                \"fl\", \"id,size,version,timestamp,blobName,md5\",\n                SORT, \"version desc\"))\n            , rsp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c304e97e7c1d472bc70e801b35ee78583916c6cd":["28288370235ed02234a64753cdbf0c6ec096304a","55ed5a78f8a4b37108ac73a894a105db562d303e"],"c352c6a130ba2458c59ac61b1663c0d5bd145be8":["f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","fcf710a8fcd590cf55c855d422c7a10fce3e6117"],"28737337dc04b06b0c7366b4ac9db5082c6089bb":["f46340080a63f8bb8358e83e88dba6ad13faf103"],"00bfa246dd03239965db3e388077a8929299bb42":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"01624b85de12fb02335810bdf325124e59040772":["6d2dadc1f5ca8703d8659f4964961f9967935d75"],"34351b686392dd515bbca6de0feda9233eca0ec1":["a0d196318cb8ce39ae32035f290cd1397833e472"],"8bca25eefa1f2205e2b0ef713701dc3a0fecd702":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c","cc5ee54a993d26579e3fe1f8f2a696b46b61c48f"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc","9bdb19206b4aeab66b9fb393c53969f44bdd48be"],"74aea047dff7f7c38a2d766827bd20d356f98c6a":["01624b85de12fb02335810bdf325124e59040772","a513b6a92751e54c76fb5447948c9e7d437163a7"],"1390137e395d2f07f9ba5b8c43d293befe84d563":["9bdb19206b4aeab66b9fb393c53969f44bdd48be"],"432e578be72da02cfde62dcc7fb4fa8620bc85fd":["d4ac60f04ae5100329a7aeb332ec715fd5775437"],"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4":["00bfa246dd03239965db3e388077a8929299bb42"],"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc":["28737337dc04b06b0c7366b4ac9db5082c6089bb"],"a0d196318cb8ce39ae32035f290cd1397833e472":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","1390137e395d2f07f9ba5b8c43d293befe84d563"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["cff47d27eb02068a9e554ff2d11e4bfd83875c20"],"f15af35d55d70c34451f9df5edeaeff6b31f8cbe":["560c18d71dad43d675158783c3840f8c80d6d39c"],"9bdb19206b4aeab66b9fb393c53969f44bdd48be":["c352c6a130ba2458c59ac61b1663c0d5bd145be8"],"560c18d71dad43d675158783c3840f8c80d6d39c":["28288370235ed02234a64753cdbf0c6ec096304a","c304e97e7c1d472bc70e801b35ee78583916c6cd"],"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c":["bd915b3766935715579f128e83173b690e2504a8"],"bd915b3766935715579f128e83173b690e2504a8":["1390137e395d2f07f9ba5b8c43d293befe84d563"],"d4ac60f04ae5100329a7aeb332ec715fd5775437":["34351b686392dd515bbca6de0feda9233eca0ec1"],"cff47d27eb02068a9e554ff2d11e4bfd83875c20":["ac35531329b1809368fb0780bcf1e72d0add3c21"],"f46340080a63f8bb8358e83e88dba6ad13faf103":["4620bf9ef8a95eeaa92aa547a4d2aca2ca5d2fb6"],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["fcf710a8fcd590cf55c855d422c7a10fce3e6117"],"fcf710a8fcd590cf55c855d422c7a10fce3e6117":["8bca25eefa1f2205e2b0ef713701dc3a0fecd702"],"cc5ee54a993d26579e3fe1f8f2a696b46b61c48f":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c"],"6f4c5d3859373c3a74734e85efa122b17514e3e8":["e5fa6615014cd2288fe930f8c8bb726f9504961d"],"ac35531329b1809368fb0780bcf1e72d0add3c21":["f15af35d55d70c34451f9df5edeaeff6b31f8cbe"],"28288370235ed02234a64753cdbf0c6ec096304a":["01624b85de12fb02335810bdf325124e59040772","74aea047dff7f7c38a2d766827bd20d356f98c6a"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c","8bca25eefa1f2205e2b0ef713701dc3a0fecd702"],"e5fa6615014cd2288fe930f8c8bb726f9504961d":["fcf710a8fcd590cf55c855d422c7a10fce3e6117"],"55ed5a78f8a4b37108ac73a894a105db562d303e":["a8c611a68829ce670498db444c39975f66888dfd"],"4620bf9ef8a95eeaa92aa547a4d2aca2ca5d2fb6":["432e578be72da02cfde62dcc7fb4fa8620bc85fd"],"a8c611a68829ce670498db444c39975f66888dfd":["6f4c5d3859373c3a74734e85efa122b17514e3e8"],"2caf6d6e842e1a4e4ae68ec6dfa5139c31a84ec5":["fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4"],"a513b6a92751e54c76fb5447948c9e7d437163a7":["01624b85de12fb02335810bdf325124e59040772"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c","8bca25eefa1f2205e2b0ef713701dc3a0fecd702"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2caf6d6e842e1a4e4ae68ec6dfa5139c31a84ec5"]},"commit2Childs":{"c304e97e7c1d472bc70e801b35ee78583916c6cd":["560c18d71dad43d675158783c3840f8c80d6d39c"],"c352c6a130ba2458c59ac61b1663c0d5bd145be8":["9bdb19206b4aeab66b9fb393c53969f44bdd48be"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":[],"28737337dc04b06b0c7366b4ac9db5082c6089bb":["f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc"],"00bfa246dd03239965db3e388077a8929299bb42":["fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4"],"01624b85de12fb02335810bdf325124e59040772":["74aea047dff7f7c38a2d766827bd20d356f98c6a","28288370235ed02234a64753cdbf0c6ec096304a","a513b6a92751e54c76fb5447948c9e7d437163a7"],"34351b686392dd515bbca6de0feda9233eca0ec1":["d4ac60f04ae5100329a7aeb332ec715fd5775437"],"8bca25eefa1f2205e2b0ef713701dc3a0fecd702":["fcf710a8fcd590cf55c855d422c7a10fce3e6117","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["d2638f781be724518ff6c2263d14a48cf6e68017"],"74aea047dff7f7c38a2d766827bd20d356f98c6a":["28288370235ed02234a64753cdbf0c6ec096304a"],"1390137e395d2f07f9ba5b8c43d293befe84d563":["d2638f781be724518ff6c2263d14a48cf6e68017","bd915b3766935715579f128e83173b690e2504a8"],"432e578be72da02cfde62dcc7fb4fa8620bc85fd":["4620bf9ef8a95eeaa92aa547a4d2aca2ca5d2fb6"],"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc":["c352c6a130ba2458c59ac61b1663c0d5bd145be8","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"a0d196318cb8ce39ae32035f290cd1397833e472":["34351b686392dd515bbca6de0feda9233eca0ec1"],"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4":["2caf6d6e842e1a4e4ae68ec6dfa5139c31a84ec5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a0d196318cb8ce39ae32035f290cd1397833e472"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"83788ad129a5154d5c6562c4e8ce3db48793aada":["00bfa246dd03239965db3e388077a8929299bb42"],"f15af35d55d70c34451f9df5edeaeff6b31f8cbe":["ac35531329b1809368fb0780bcf1e72d0add3c21"],"9bdb19206b4aeab66b9fb393c53969f44bdd48be":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","1390137e395d2f07f9ba5b8c43d293befe84d563"],"560c18d71dad43d675158783c3840f8c80d6d39c":["f15af35d55d70c34451f9df5edeaeff6b31f8cbe"],"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c":["8bca25eefa1f2205e2b0ef713701dc3a0fecd702","cc5ee54a993d26579e3fe1f8f2a696b46b61c48f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"bd915b3766935715579f128e83173b690e2504a8":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c"],"d4ac60f04ae5100329a7aeb332ec715fd5775437":["432e578be72da02cfde62dcc7fb4fa8620bc85fd"],"cff47d27eb02068a9e554ff2d11e4bfd83875c20":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"f46340080a63f8bb8358e83e88dba6ad13faf103":["28737337dc04b06b0c7366b4ac9db5082c6089bb"],"fcf710a8fcd590cf55c855d422c7a10fce3e6117":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc","6d2dadc1f5ca8703d8659f4964961f9967935d75","e5fa6615014cd2288fe930f8c8bb726f9504961d"],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["01624b85de12fb02335810bdf325124e59040772"],"cc5ee54a993d26579e3fe1f8f2a696b46b61c48f":["8bca25eefa1f2205e2b0ef713701dc3a0fecd702"],"6f4c5d3859373c3a74734e85efa122b17514e3e8":["a8c611a68829ce670498db444c39975f66888dfd"],"ac35531329b1809368fb0780bcf1e72d0add3c21":["cff47d27eb02068a9e554ff2d11e4bfd83875c20"],"28288370235ed02234a64753cdbf0c6ec096304a":["c304e97e7c1d472bc70e801b35ee78583916c6cd","560c18d71dad43d675158783c3840f8c80d6d39c"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc"],"e5fa6615014cd2288fe930f8c8bb726f9504961d":["6f4c5d3859373c3a74734e85efa122b17514e3e8"],"55ed5a78f8a4b37108ac73a894a105db562d303e":["c304e97e7c1d472bc70e801b35ee78583916c6cd"],"4620bf9ef8a95eeaa92aa547a4d2aca2ca5d2fb6":["f46340080a63f8bb8358e83e88dba6ad13faf103"],"a8c611a68829ce670498db444c39975f66888dfd":["55ed5a78f8a4b37108ac73a894a105db562d303e"],"a513b6a92751e54c76fb5447948c9e7d437163a7":["74aea047dff7f7c38a2d766827bd20d356f98c6a"],"2caf6d6e842e1a4e4ae68ec6dfa5139c31a84ec5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc","d2638f781be724518ff6c2263d14a48cf6e68017","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}