{"path":"lucene/src/java/org/apache/lucene/index/IndexWriter#addFlushedSegment(FlushedSegment).mjava","commits":[{"id":"bfaa69f5e3b29a90ec41762bfbfa166a9e52eccf","date":1298618128,"type":1,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#addFlushedSegment(FlushedSegment).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#addFlushedSegment(SegmentInfo,BitVector).mjava","sourceNew":"  void addFlushedSegment(FlushedSegment flushedSegment) throws IOException {\n    assert flushedSegment != null;\n\n    SegmentInfo newSegment = flushedSegment.segmentInfo;\n\n    setDiagnostics(newSegment, \"flush\");\n\n    boolean success = false;\n    try {\n      if (useCompoundFile(newSegment)) {\n        String compoundFileName = IndexFileNames.segmentFileName(newSegment.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION);\n        message(\"creating compound file \" + compoundFileName);\n      // Now build compound file\n        CompoundFileWriter cfsWriter = new CompoundFileWriter(directory, compoundFileName);\n        for(String fileName : newSegment.files()) {\n          cfsWriter.addFile(fileName);\n        }\n\n        // Perform the merge\n        cfsWriter.close();\n        synchronized(this) {\n          deleter.deleteNewFiles(newSegment.files());\n        }\n\n        newSegment.setUseCompoundFile(true);\n      }\n\n      // Must write deleted docs after the CFS so we don't\n      // slurp the del file into CFS:\n      if (flushedSegment.deletedDocuments != null) {\n        final int delCount = flushedSegment.deletedDocuments.count();\n        assert delCount > 0;\n        newSegment.setDelCount(delCount);\n        newSegment.advanceDelGen();\n        final String delFileName = newSegment.getDelFileName();\n        if (infoStream != null) {\n          message(\"flush: write \" + delCount + \" deletes to \" + delFileName);\n        }\n        boolean success2 = false;\n        try {\n          // TODO: in the NRT case it'd be better to hand\n          // this del vector over to the\n          // shortly-to-be-opened SegmentReader and let it\n          // carry the changes; there's no reason to use\n          // filesystem as intermediary here.\n          flushedSegment.deletedDocuments.write(directory, delFileName);\n          success2 = true;\n        } finally {\n          if (!success2) {\n            try {\n              directory.deleteFile(delFileName);\n            } catch (Throwable t) {\n              // suppress this so we keep throwing the\n              // original exception\n            }\n          }\n        }\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"hit exception \" +\n              \"reating compound file for newly flushed segment \" + newSegment.name);\n        }\n\n        synchronized(this) {\n          deleter.refresh(newSegment.name);\n        }\n      }\n    }\n\n\n    synchronized(this) {\n      segmentInfos.add(newSegment);\n      checkpoint();\n    }\n  }\n\n","sourceOld":"  void addFlushedSegment(SegmentInfo newSegment, BitVector deletedDocs) throws IOException {\n    assert newSegment != null;\n\n    setDiagnostics(newSegment, \"flush\");\n\n    boolean success = false;\n    try {\n      if (useCompoundFile(newSegment)) {\n        String compoundFileName = IndexFileNames.segmentFileName(newSegment.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION);\n        message(\"creating compound file \" + compoundFileName);\n      // Now build compound file\n        CompoundFileWriter cfsWriter = new CompoundFileWriter(directory, compoundFileName);\n        for(String fileName : newSegment.files()) {\n          cfsWriter.addFile(fileName);\n        }\n\n        // Perform the merge\n        cfsWriter.close();\n        synchronized(this) {\n          deleter.deleteNewFiles(newSegment.files());\n        }\n\n        newSegment.setUseCompoundFile(true);\n      }\n\n      // Must write deleted docs after the CFS so we don't\n      // slurp the del file into CFS:\n      if (deletedDocs != null) {\n        final int delCount = deletedDocs.count();\n        assert delCount > 0;\n        newSegment.setDelCount(delCount);\n        newSegment.advanceDelGen();\n        final String delFileName = newSegment.getDelFileName();\n        if (infoStream != null) {\n          message(\"flush: write \" + delCount + \" deletes to \" + delFileName);\n        }\n        boolean success2 = false;\n        try {\n          // TODO: in the NRT case it'd be better to hand\n          // this del vector over to the\n          // shortly-to-be-opened SegmentReader and let it\n          // carry the changes; there's no reason to use\n          // filesystem as intermediary here.\n          deletedDocs.write(directory, delFileName);\n          success2 = true;\n        } finally {\n          if (!success2) {\n            try {\n              directory.deleteFile(delFileName);\n            } catch (Throwable t) {\n              // suppress this so we keep throwing the\n              // original exception\n            }\n          }\n        }\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"hit exception \" +\n              \"reating compound file for newly flushed segment \" + newSegment.name);\n        }\n\n        synchronized(this) {\n          deleter.refresh(newSegment.name);\n        }\n      }\n    }\n\n\n    synchronized(this) {\n      segmentInfos.add(newSegment);\n      checkpoint();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"327863a2fd61e831028b6c56c8fef6b00a44eb0b","date":1302686439,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#prepareFlushedSegment(FlushedSegment).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#addFlushedSegment(FlushedSegment).mjava","sourceNew":"  /**\n   * Prepares the {@link SegmentInfo} for the new flushed segment and persists\n   * the deleted documents {@link BitVector}. Use\n   * {@link #publishFlushedSegment(SegmentInfo, FrozenBufferedDeletes)} to\n   * publish the returned {@link SegmentInfo} together with its segment private\n   * delete packet.\n   * \n   * @see #publishFlushedSegment(SegmentInfo, FrozenBufferedDeletes)\n   */\n  SegmentInfo prepareFlushedSegment(FlushedSegment flushedSegment) throws IOException {\n    assert flushedSegment != null;\n\n    SegmentInfo newSegment = flushedSegment.segmentInfo;\n\n    setDiagnostics(newSegment, \"flush\");\n\n    boolean success = false;\n    try {\n      if (useCompoundFile(newSegment)) {\n        String compoundFileName = IndexFileNames.segmentFileName(newSegment.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION);\n        message(\"creating compound file \" + compoundFileName);\n      // Now build compound file\n        CompoundFileWriter cfsWriter = new CompoundFileWriter(directory, compoundFileName);\n        for(String fileName : newSegment.files()) {\n          cfsWriter.addFile(fileName);\n        }\n\n        // Perform the merge\n        cfsWriter.close();\n        synchronized(this) {\n          deleter.deleteNewFiles(newSegment.files());\n        }\n\n        newSegment.setUseCompoundFile(true);\n      }\n\n      // Must write deleted docs after the CFS so we don't\n      // slurp the del file into CFS:\n      if (flushedSegment.deletedDocuments != null) {\n        final int delCount = flushedSegment.deletedDocuments.count();\n        assert delCount > 0;\n        newSegment.setDelCount(delCount);\n        newSegment.advanceDelGen();\n        final String delFileName = newSegment.getDelFileName();\n        if (infoStream != null) {\n          message(\"flush: write \" + delCount + \" deletes to \" + delFileName);\n        }\n        boolean success2 = false;\n        try {\n          // TODO: in the NRT case it'd be better to hand\n          // this del vector over to the\n          // shortly-to-be-opened SegmentReader and let it\n          // carry the changes; there's no reason to use\n          // filesystem as intermediary here.\n          flushedSegment.deletedDocuments.write(directory, delFileName);\n          success2 = true;\n        } finally {\n          if (!success2) {\n            try {\n              directory.deleteFile(delFileName);\n            } catch (Throwable t) {\n              // suppress this so we keep throwing the\n              // original exception\n            }\n          }\n        }\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"hit exception \" +\n              \"reating compound file for newly flushed segment \" + newSegment.name);\n        }\n\n        synchronized(this) {\n          deleter.refresh(newSegment.name);\n        }\n      }\n    }\n    return newSegment;\n  }\n\n","sourceOld":"  void addFlushedSegment(FlushedSegment flushedSegment) throws IOException {\n    assert flushedSegment != null;\n\n    SegmentInfo newSegment = flushedSegment.segmentInfo;\n\n    setDiagnostics(newSegment, \"flush\");\n\n    boolean success = false;\n    try {\n      if (useCompoundFile(newSegment)) {\n        String compoundFileName = IndexFileNames.segmentFileName(newSegment.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION);\n        message(\"creating compound file \" + compoundFileName);\n      // Now build compound file\n        CompoundFileWriter cfsWriter = new CompoundFileWriter(directory, compoundFileName);\n        for(String fileName : newSegment.files()) {\n          cfsWriter.addFile(fileName);\n        }\n\n        // Perform the merge\n        cfsWriter.close();\n        synchronized(this) {\n          deleter.deleteNewFiles(newSegment.files());\n        }\n\n        newSegment.setUseCompoundFile(true);\n      }\n\n      // Must write deleted docs after the CFS so we don't\n      // slurp the del file into CFS:\n      if (flushedSegment.deletedDocuments != null) {\n        final int delCount = flushedSegment.deletedDocuments.count();\n        assert delCount > 0;\n        newSegment.setDelCount(delCount);\n        newSegment.advanceDelGen();\n        final String delFileName = newSegment.getDelFileName();\n        if (infoStream != null) {\n          message(\"flush: write \" + delCount + \" deletes to \" + delFileName);\n        }\n        boolean success2 = false;\n        try {\n          // TODO: in the NRT case it'd be better to hand\n          // this del vector over to the\n          // shortly-to-be-opened SegmentReader and let it\n          // carry the changes; there's no reason to use\n          // filesystem as intermediary here.\n          flushedSegment.deletedDocuments.write(directory, delFileName);\n          success2 = true;\n        } finally {\n          if (!success2) {\n            try {\n              directory.deleteFile(delFileName);\n            } catch (Throwable t) {\n              // suppress this so we keep throwing the\n              // original exception\n            }\n          }\n        }\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"hit exception \" +\n              \"reating compound file for newly flushed segment \" + newSegment.name);\n        }\n\n        synchronized(this) {\n          deleter.refresh(newSegment.name);\n        }\n      }\n    }\n\n\n    synchronized(this) {\n      segmentInfos.add(newSegment);\n      checkpoint();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bfaa69f5e3b29a90ec41762bfbfa166a9e52eccf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"327863a2fd61e831028b6c56c8fef6b00a44eb0b":["bfaa69f5e3b29a90ec41762bfbfa166a9e52eccf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bfaa69f5e3b29a90ec41762bfbfa166a9e52eccf","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bfaa69f5e3b29a90ec41762bfbfa166a9e52eccf":["327863a2fd61e831028b6c56c8fef6b00a44eb0b"],"327863a2fd61e831028b6c56c8fef6b00a44eb0b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["327863a2fd61e831028b6c56c8fef6b00a44eb0b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}