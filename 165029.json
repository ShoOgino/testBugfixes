{"path":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#testRandomPointInSetQuery().mjava","commits":[{"id":"e460f059c59ca6be827d6de9a0e26f526b9414c0","date":1456270863,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#testRandomPointInSetQuery().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandomPointInSetQuery() throws Exception {\n    final Set<Integer> valuesSet = new HashSet<>();\n    int numValues = TestUtil.nextInt(random(), 1, 100);\n    while (valuesSet.size() < numValues) {\n      valuesSet.add(random().nextInt());\n    }\n    int[] values = toArray(valuesSet);\n    int numDocs = TestUtil.nextInt(random(), 1, 10000);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDocs=\" + numDocs);\n    }\n\n    Directory dir;\n    if (numDocs > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setCodec(getCodec());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    // nocommit multi-valued too\n\n    int[] docValues = new int[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      int x = values[random().nextInt(values.length)];\n      Document doc = new Document();\n      doc.add(new IntPoint(\"int\", x));\n      docValues[i] = x;\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              int numValidValuesToQuery = random().nextInt(values.length);\n\n              Set<Integer> valuesToQuery = new HashSet<>();\n              while (valuesToQuery.size() < numValidValuesToQuery) {\n                valuesToQuery.add(values[random().nextInt(values.length)]);\n              }\n\n              int numExtraValuesToQuery = random().nextInt(20);\n              while (valuesToQuery.size() < numValidValuesToQuery + numExtraValuesToQuery) {\n                // nocommit fix test to sometimes use \"narrow\" range of values\n                valuesToQuery.add(random().nextInt());\n              }\n\n              int expectedCount = 0;\n              for(int value : docValues) {\n                if (valuesToQuery.contains(value)) {\n                  expectedCount++;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"TEST: thread=\" + Thread.currentThread() + \" values=\" + valuesToQuery + \" expectedCount=\" + expectedCount);\n              }\n\n              assertEquals(expectedCount, s.count(IntPoint.newSetQuery(\"int\", toArray(valuesToQuery))));\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"96ae115468a08fb03270562a0121761d73c2c8c1","date":1456307437,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#testRandomPointInSetQuery().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#testRandomPointInSetQuery().mjava","sourceNew":"  public void testRandomPointInSetQuery() throws Exception {\n\n    boolean useNarrowRange = random().nextBoolean();\n    final Integer valueMin;\n    final Integer valueMax;\n    if (useNarrowRange) {\n      int gap = random().nextInt(100);\n      valueMin = random().nextInt(Integer.MAX_VALUE-gap);\n      valueMax = valueMin + gap;\n    } else {\n      valueMin = null;\n      valueMax = null;\n    }\n    final Set<Integer> valuesSet = new HashSet<>();\n    int numValues = TestUtil.nextInt(random(), 1, 100);\n    while (valuesSet.size() < numValues) {\n      valuesSet.add(randomIntValue(valueMin, valueMax));\n    }\n    int[] values = toArray(valuesSet);\n    int numDocs = TestUtil.nextInt(random(), 1, 10000);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDocs=\" + numDocs);\n    }\n\n    Directory dir;\n    if (numDocs > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setCodec(getCodec());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    // nocommit multi-valued too\n\n    int[] docValues = new int[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      int x = values[random().nextInt(values.length)];\n      Document doc = new Document();\n      doc.add(new IntPoint(\"int\", x));\n      docValues[i] = x;\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              int numValidValuesToQuery = random().nextInt(values.length);\n\n              Set<Integer> valuesToQuery = new HashSet<>();\n              while (valuesToQuery.size() < numValidValuesToQuery) {\n                valuesToQuery.add(values[random().nextInt(values.length)]);\n              }\n\n              int numExtraValuesToQuery = random().nextInt(20);\n              while (valuesToQuery.size() < numValidValuesToQuery + numExtraValuesToQuery) {\n                valuesToQuery.add(randomIntValue(valueMin, valueMax));\n              }\n\n              int expectedCount = 0;\n              for(int value : docValues) {\n                if (valuesToQuery.contains(value)) {\n                  expectedCount++;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"TEST: thread=\" + Thread.currentThread() + \" values=\" + valuesToQuery + \" expectedCount=\" + expectedCount);\n              }\n\n              assertEquals(expectedCount, s.count(IntPoint.newSetQuery(\"int\", toArray(valuesToQuery))));\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  public void testRandomPointInSetQuery() throws Exception {\n    final Set<Integer> valuesSet = new HashSet<>();\n    int numValues = TestUtil.nextInt(random(), 1, 100);\n    while (valuesSet.size() < numValues) {\n      valuesSet.add(random().nextInt());\n    }\n    int[] values = toArray(valuesSet);\n    int numDocs = TestUtil.nextInt(random(), 1, 10000);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDocs=\" + numDocs);\n    }\n\n    Directory dir;\n    if (numDocs > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setCodec(getCodec());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    // nocommit multi-valued too\n\n    int[] docValues = new int[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      int x = values[random().nextInt(values.length)];\n      Document doc = new Document();\n      doc.add(new IntPoint(\"int\", x));\n      docValues[i] = x;\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              int numValidValuesToQuery = random().nextInt(values.length);\n\n              Set<Integer> valuesToQuery = new HashSet<>();\n              while (valuesToQuery.size() < numValidValuesToQuery) {\n                valuesToQuery.add(values[random().nextInt(values.length)]);\n              }\n\n              int numExtraValuesToQuery = random().nextInt(20);\n              while (valuesToQuery.size() < numValidValuesToQuery + numExtraValuesToQuery) {\n                // nocommit fix test to sometimes use \"narrow\" range of values\n                valuesToQuery.add(random().nextInt());\n              }\n\n              int expectedCount = 0;\n              for(int value : docValues) {\n                if (valuesToQuery.contains(value)) {\n                  expectedCount++;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"TEST: thread=\" + Thread.currentThread() + \" values=\" + valuesToQuery + \" expectedCount=\" + expectedCount);\n              }\n\n              assertEquals(expectedCount, s.count(IntPoint.newSetQuery(\"int\", toArray(valuesToQuery))));\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"375ee6573ef9849fb746b27e12fea91e8f7d77b9","date":1456351141,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#testRandomPointInSetQuery().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#testRandomPointInSetQuery().mjava","sourceNew":"  public void testRandomPointInSetQuery() throws Exception {\n\n    boolean useNarrowRange = random().nextBoolean();\n    final Integer valueMin;\n    final Integer valueMax;\n    int numValues;\n    if (useNarrowRange) {\n      int gap = random().nextInt(100);\n      valueMin = random().nextInt(Integer.MAX_VALUE-gap);\n      valueMax = valueMin + gap;\n      numValues = TestUtil.nextInt(random(), 1, gap+1);\n    } else {\n      valueMin = null;\n      valueMax = null;\n      numValues = TestUtil.nextInt(random(), 1, 100);\n    }\n    final Set<Integer> valuesSet = new HashSet<>();\n    while (valuesSet.size() < numValues) {\n      valuesSet.add(randomIntValue(valueMin, valueMax));\n    }\n    int[] values = toArray(valuesSet);\n    int numDocs = TestUtil.nextInt(random(), 1, 10000);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDocs=\" + numDocs);\n    }\n\n    Directory dir;\n    if (numDocs > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setCodec(getCodec());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    // nocommit multi-valued too\n\n    int[] docValues = new int[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      int x = values[random().nextInt(values.length)];\n      Document doc = new Document();\n      doc.add(new IntPoint(\"int\", x));\n      docValues[i] = x;\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              int numValidValuesToQuery = random().nextInt(values.length);\n\n              Set<Integer> valuesToQuery = new HashSet<>();\n              while (valuesToQuery.size() < numValidValuesToQuery) {\n                valuesToQuery.add(values[random().nextInt(values.length)]);\n              }\n\n              int numExtraValuesToQuery = random().nextInt(20);\n              while (valuesToQuery.size() < numValidValuesToQuery + numExtraValuesToQuery) {\n                valuesToQuery.add(random().nextInt());\n              }\n\n              int expectedCount = 0;\n              for(int value : docValues) {\n                if (valuesToQuery.contains(value)) {\n                  expectedCount++;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"TEST: thread=\" + Thread.currentThread() + \" values=\" + valuesToQuery + \" expectedCount=\" + expectedCount);\n              }\n\n              assertEquals(expectedCount, s.count(IntPoint.newSetQuery(\"int\", toArray(valuesToQuery))));\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  public void testRandomPointInSetQuery() throws Exception {\n\n    boolean useNarrowRange = random().nextBoolean();\n    final Integer valueMin;\n    final Integer valueMax;\n    if (useNarrowRange) {\n      int gap = random().nextInt(100);\n      valueMin = random().nextInt(Integer.MAX_VALUE-gap);\n      valueMax = valueMin + gap;\n    } else {\n      valueMin = null;\n      valueMax = null;\n    }\n    final Set<Integer> valuesSet = new HashSet<>();\n    int numValues = TestUtil.nextInt(random(), 1, 100);\n    while (valuesSet.size() < numValues) {\n      valuesSet.add(randomIntValue(valueMin, valueMax));\n    }\n    int[] values = toArray(valuesSet);\n    int numDocs = TestUtil.nextInt(random(), 1, 10000);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDocs=\" + numDocs);\n    }\n\n    Directory dir;\n    if (numDocs > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setCodec(getCodec());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    // nocommit multi-valued too\n\n    int[] docValues = new int[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      int x = values[random().nextInt(values.length)];\n      Document doc = new Document();\n      doc.add(new IntPoint(\"int\", x));\n      docValues[i] = x;\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              int numValidValuesToQuery = random().nextInt(values.length);\n\n              Set<Integer> valuesToQuery = new HashSet<>();\n              while (valuesToQuery.size() < numValidValuesToQuery) {\n                valuesToQuery.add(values[random().nextInt(values.length)]);\n              }\n\n              int numExtraValuesToQuery = random().nextInt(20);\n              while (valuesToQuery.size() < numValidValuesToQuery + numExtraValuesToQuery) {\n                valuesToQuery.add(randomIntValue(valueMin, valueMax));\n              }\n\n              int expectedCount = 0;\n              for(int value : docValues) {\n                if (valuesToQuery.contains(value)) {\n                  expectedCount++;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"TEST: thread=\" + Thread.currentThread() + \" values=\" + valuesToQuery + \" expectedCount=\" + expectedCount);\n              }\n\n              assertEquals(expectedCount, s.count(IntPoint.newSetQuery(\"int\", toArray(valuesToQuery))));\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b9ccce763ea3c7e51eff749e584c061d8744b72d","date":1456395668,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#testRandomPointInSetQuery().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#testRandomPointInSetQuery().mjava","sourceNew":"  public void testRandomPointInSetQuery() throws Exception {\n\n    boolean useNarrowRange = random().nextBoolean();\n    final Integer valueMin;\n    final Integer valueMax;\n    int numValues;\n    if (useNarrowRange) {\n      int gap = random().nextInt(100);\n      valueMin = random().nextInt(Integer.MAX_VALUE-gap);\n      valueMax = valueMin + gap;\n      numValues = TestUtil.nextInt(random(), 1, gap+1);\n    } else {\n      valueMin = null;\n      valueMax = null;\n      numValues = TestUtil.nextInt(random(), 1, 100);\n    }\n    final Set<Integer> valuesSet = new HashSet<>();\n    while (valuesSet.size() < numValues) {\n      valuesSet.add(randomIntValue(valueMin, valueMax));\n    }\n    int[] values = toArray(valuesSet);\n    int numDocs = TestUtil.nextInt(random(), 1, 10000);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDocs=\" + numDocs);\n    }\n\n    Directory dir;\n    if (numDocs > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setCodec(getCodec());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int[] docValues = new int[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      int x = values[random().nextInt(values.length)];\n      Document doc = new Document();\n      doc.add(new IntPoint(\"int\", x));\n      docValues[i] = x;\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              int numValidValuesToQuery = random().nextInt(values.length);\n\n              Set<Integer> valuesToQuery = new HashSet<>();\n              while (valuesToQuery.size() < numValidValuesToQuery) {\n                valuesToQuery.add(values[random().nextInt(values.length)]);\n              }\n\n              int numExtraValuesToQuery = random().nextInt(20);\n              while (valuesToQuery.size() < numValidValuesToQuery + numExtraValuesToQuery) {\n                valuesToQuery.add(random().nextInt());\n              }\n\n              int expectedCount = 0;\n              for(int value : docValues) {\n                if (valuesToQuery.contains(value)) {\n                  expectedCount++;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"TEST: thread=\" + Thread.currentThread() + \" values=\" + valuesToQuery + \" expectedCount=\" + expectedCount);\n              }\n\n              assertEquals(expectedCount, s.count(IntPoint.newSetQuery(\"int\", toArray(valuesToQuery))));\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  public void testRandomPointInSetQuery() throws Exception {\n\n    boolean useNarrowRange = random().nextBoolean();\n    final Integer valueMin;\n    final Integer valueMax;\n    int numValues;\n    if (useNarrowRange) {\n      int gap = random().nextInt(100);\n      valueMin = random().nextInt(Integer.MAX_VALUE-gap);\n      valueMax = valueMin + gap;\n      numValues = TestUtil.nextInt(random(), 1, gap+1);\n    } else {\n      valueMin = null;\n      valueMax = null;\n      numValues = TestUtil.nextInt(random(), 1, 100);\n    }\n    final Set<Integer> valuesSet = new HashSet<>();\n    while (valuesSet.size() < numValues) {\n      valuesSet.add(randomIntValue(valueMin, valueMax));\n    }\n    int[] values = toArray(valuesSet);\n    int numDocs = TestUtil.nextInt(random(), 1, 10000);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDocs=\" + numDocs);\n    }\n\n    Directory dir;\n    if (numDocs > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setCodec(getCodec());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    // nocommit multi-valued too\n\n    int[] docValues = new int[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      int x = values[random().nextInt(values.length)];\n      Document doc = new Document();\n      doc.add(new IntPoint(\"int\", x));\n      docValues[i] = x;\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              int numValidValuesToQuery = random().nextInt(values.length);\n\n              Set<Integer> valuesToQuery = new HashSet<>();\n              while (valuesToQuery.size() < numValidValuesToQuery) {\n                valuesToQuery.add(values[random().nextInt(values.length)]);\n              }\n\n              int numExtraValuesToQuery = random().nextInt(20);\n              while (valuesToQuery.size() < numValidValuesToQuery + numExtraValuesToQuery) {\n                valuesToQuery.add(random().nextInt());\n              }\n\n              int expectedCount = 0;\n              for(int value : docValues) {\n                if (valuesToQuery.contains(value)) {\n                  expectedCount++;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"TEST: thread=\" + Thread.currentThread() + \" values=\" + valuesToQuery + \" expectedCount=\" + expectedCount);\n              }\n\n              assertEquals(expectedCount, s.count(IntPoint.newSetQuery(\"int\", toArray(valuesToQuery))));\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"868f63baffb79407d4b49f3c0be8dc4725ffc6e1","date":1456423715,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#testRandomPointInSetQuery().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandomPointInSetQuery() throws Exception {\n\n    boolean useNarrowRange = random().nextBoolean();\n    final Integer valueMin;\n    final Integer valueMax;\n    int numValues;\n    if (useNarrowRange) {\n      int gap = random().nextInt(100);\n      valueMin = random().nextInt(Integer.MAX_VALUE-gap);\n      valueMax = valueMin + gap;\n      numValues = TestUtil.nextInt(random(), 1, gap+1);\n    } else {\n      valueMin = null;\n      valueMax = null;\n      numValues = TestUtil.nextInt(random(), 1, 100);\n    }\n    final Set<Integer> valuesSet = new HashSet<>();\n    while (valuesSet.size() < numValues) {\n      valuesSet.add(randomIntValue(valueMin, valueMax));\n    }\n    int[] values = toArray(valuesSet);\n    int numDocs = TestUtil.nextInt(random(), 1, 10000);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDocs=\" + numDocs);\n    }\n\n    Directory dir;\n    if (numDocs > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setCodec(getCodec());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int[] docValues = new int[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      int x = values[random().nextInt(values.length)];\n      Document doc = new Document();\n      doc.add(new IntPoint(\"int\", x));\n      docValues[i] = x;\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              int numValidValuesToQuery = random().nextInt(values.length);\n\n              Set<Integer> valuesToQuery = new HashSet<>();\n              while (valuesToQuery.size() < numValidValuesToQuery) {\n                valuesToQuery.add(values[random().nextInt(values.length)]);\n              }\n\n              int numExtraValuesToQuery = random().nextInt(20);\n              while (valuesToQuery.size() < numValidValuesToQuery + numExtraValuesToQuery) {\n                valuesToQuery.add(random().nextInt());\n              }\n\n              int expectedCount = 0;\n              for(int value : docValues) {\n                if (valuesToQuery.contains(value)) {\n                  expectedCount++;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"TEST: thread=\" + Thread.currentThread() + \" values=\" + valuesToQuery + \" expectedCount=\" + expectedCount);\n              }\n\n              assertEquals(expectedCount, s.count(IntPoint.newSetQuery(\"int\", toArray(valuesToQuery))));\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"adc9dc8ef0ce617b940a039fd12f79e8b098cc7f","date":1456936072,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#testRandomPointInSetQuery().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#testRandomPointInSetQuery().mjava","sourceNew":"  public void testRandomPointInSetQuery() throws Exception {\n\n    boolean useNarrowRange = random().nextBoolean();\n    final Integer valueMin;\n    final Integer valueMax;\n    int numValues;\n    if (useNarrowRange) {\n      int gap = random().nextInt(100);\n      valueMin = random().nextInt(Integer.MAX_VALUE-gap);\n      valueMax = valueMin + gap;\n      numValues = TestUtil.nextInt(random(), 1, gap+1);\n    } else {\n      valueMin = null;\n      valueMax = null;\n      numValues = TestUtil.nextInt(random(), 1, 100);\n    }\n    final Set<Integer> valuesSet = new HashSet<>();\n    while (valuesSet.size() < numValues) {\n      valuesSet.add(randomIntValue(valueMin, valueMax));\n    }\n    int[] values = toArray(valuesSet);\n    int numDocs = TestUtil.nextInt(random(), 1, 10000);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDocs=\" + numDocs);\n    }\n\n    Directory dir;\n    if (numDocs > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setCodec(getCodec());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int[] docValues = new int[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      int x = values[random().nextInt(values.length)];\n      Document doc = new Document();\n      doc.add(new IntPoint(\"int\", x));\n      docValues[i] = x;\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              int numValidValuesToQuery = random().nextInt(values.length);\n\n              Set<Integer> valuesToQuery = new HashSet<>();\n              while (valuesToQuery.size() < numValidValuesToQuery) {\n                valuesToQuery.add(values[random().nextInt(values.length)]);\n              }\n\n              int numExtraValuesToQuery = random().nextInt(20);\n              while (valuesToQuery.size() < numValidValuesToQuery + numExtraValuesToQuery) {\n                valuesToQuery.add(random().nextInt());\n              }\n\n              int expectedCount = 0;\n              for(int value : docValues) {\n                if (valuesToQuery.contains(value)) {\n                  expectedCount++;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"TEST: thread=\" + Thread.currentThread() + \" values=\" + valuesToQuery + \" expectedCount=\" + expectedCount);\n              }\n\n              assertEquals(expectedCount, s.count(IntPoint.newSetQuery(\"int\", toArray(valuesToQuery))));\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  public void testRandomPointInSetQuery() throws Exception {\n\n    boolean useNarrowRange = random().nextBoolean();\n    final Integer valueMin;\n    final Integer valueMax;\n    int numValues;\n    if (useNarrowRange) {\n      int gap = random().nextInt(100);\n      valueMin = random().nextInt(Integer.MAX_VALUE-gap);\n      valueMax = valueMin + gap;\n      numValues = TestUtil.nextInt(random(), 1, gap+1);\n    } else {\n      valueMin = null;\n      valueMax = null;\n      numValues = TestUtil.nextInt(random(), 1, 100);\n    }\n    final Set<Integer> valuesSet = new HashSet<>();\n    while (valuesSet.size() < numValues) {\n      valuesSet.add(randomIntValue(valueMin, valueMax));\n    }\n    int[] values = toArray(valuesSet);\n    int numDocs = TestUtil.nextInt(random(), 1, 10000);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDocs=\" + numDocs);\n    }\n\n    Directory dir;\n    if (numDocs > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setCodec(getCodec());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int[] docValues = new int[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      int x = values[random().nextInt(values.length)];\n      Document doc = new Document();\n      doc.add(new IntPoint(\"int\", x));\n      docValues[i] = x;\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              int numValidValuesToQuery = random().nextInt(values.length);\n\n              Set<Integer> valuesToQuery = new HashSet<>();\n              while (valuesToQuery.size() < numValidValuesToQuery) {\n                valuesToQuery.add(values[random().nextInt(values.length)]);\n              }\n\n              int numExtraValuesToQuery = random().nextInt(20);\n              while (valuesToQuery.size() < numValidValuesToQuery + numExtraValuesToQuery) {\n                valuesToQuery.add(random().nextInt());\n              }\n\n              int expectedCount = 0;\n              for(int value : docValues) {\n                if (valuesToQuery.contains(value)) {\n                  expectedCount++;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"TEST: thread=\" + Thread.currentThread() + \" values=\" + valuesToQuery + \" expectedCount=\" + expectedCount);\n              }\n\n              assertEquals(expectedCount, s.count(IntPoint.newSetQuery(\"int\", toArray(valuesToQuery))));\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#testRandomPointInSetQuery().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#testRandomPointInSetQuery().mjava","sourceNew":"  public void testRandomPointInSetQuery() throws Exception {\n\n    boolean useNarrowRange = random().nextBoolean();\n    final Integer valueMin;\n    final Integer valueMax;\n    int numValues;\n    if (useNarrowRange) {\n      int gap = random().nextInt(100);\n      valueMin = random().nextInt(Integer.MAX_VALUE-gap);\n      valueMax = valueMin + gap;\n      numValues = TestUtil.nextInt(random(), 1, gap+1);\n    } else {\n      valueMin = null;\n      valueMax = null;\n      numValues = TestUtil.nextInt(random(), 1, 100);\n    }\n    final Set<Integer> valuesSet = new HashSet<>();\n    while (valuesSet.size() < numValues) {\n      valuesSet.add(randomIntValue(valueMin, valueMax));\n    }\n    int[] values = toArray(valuesSet);\n    int numDocs = TestUtil.nextInt(random(), 1, 10000);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDocs=\" + numDocs);\n    }\n\n    Directory dir;\n    if (numDocs > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setCodec(getCodec());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int[] docValues = new int[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      int x = values[random().nextInt(values.length)];\n      Document doc = new Document();\n      doc.add(new IntPoint(\"int\", x));\n      docValues[i] = x;\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              int numValidValuesToQuery = random().nextInt(values.length);\n\n              Set<Integer> valuesToQuery = new HashSet<>();\n              while (valuesToQuery.size() < numValidValuesToQuery) {\n                valuesToQuery.add(values[random().nextInt(values.length)]);\n              }\n\n              int numExtraValuesToQuery = random().nextInt(20);\n              while (valuesToQuery.size() < numValidValuesToQuery + numExtraValuesToQuery) {\n                valuesToQuery.add(random().nextInt());\n              }\n\n              int expectedCount = 0;\n              for(int value : docValues) {\n                if (valuesToQuery.contains(value)) {\n                  expectedCount++;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"TEST: thread=\" + Thread.currentThread() + \" values=\" + valuesToQuery + \" expectedCount=\" + expectedCount);\n              }\n\n              assertEquals(expectedCount, s.count(IntPoint.newSetQuery(\"int\", toArray(valuesToQuery))));\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  public void testRandomPointInSetQuery() throws Exception {\n\n    boolean useNarrowRange = random().nextBoolean();\n    final Integer valueMin;\n    final Integer valueMax;\n    int numValues;\n    if (useNarrowRange) {\n      int gap = random().nextInt(100);\n      valueMin = random().nextInt(Integer.MAX_VALUE-gap);\n      valueMax = valueMin + gap;\n      numValues = TestUtil.nextInt(random(), 1, gap+1);\n    } else {\n      valueMin = null;\n      valueMax = null;\n      numValues = TestUtil.nextInt(random(), 1, 100);\n    }\n    final Set<Integer> valuesSet = new HashSet<>();\n    while (valuesSet.size() < numValues) {\n      valuesSet.add(randomIntValue(valueMin, valueMax));\n    }\n    int[] values = toArray(valuesSet);\n    int numDocs = TestUtil.nextInt(random(), 1, 10000);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDocs=\" + numDocs);\n    }\n\n    Directory dir;\n    if (numDocs > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setCodec(getCodec());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int[] docValues = new int[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      int x = values[random().nextInt(values.length)];\n      Document doc = new Document();\n      doc.add(new IntPoint(\"int\", x));\n      docValues[i] = x;\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              int numValidValuesToQuery = random().nextInt(values.length);\n\n              Set<Integer> valuesToQuery = new HashSet<>();\n              while (valuesToQuery.size() < numValidValuesToQuery) {\n                valuesToQuery.add(values[random().nextInt(values.length)]);\n              }\n\n              int numExtraValuesToQuery = random().nextInt(20);\n              while (valuesToQuery.size() < numValidValuesToQuery + numExtraValuesToQuery) {\n                valuesToQuery.add(random().nextInt());\n              }\n\n              int expectedCount = 0;\n              for(int value : docValues) {\n                if (valuesToQuery.contains(value)) {\n                  expectedCount++;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"TEST: thread=\" + Thread.currentThread() + \" values=\" + valuesToQuery + \" expectedCount=\" + expectedCount);\n              }\n\n              assertEquals(expectedCount, s.count(IntPoint.newSetQuery(\"int\", toArray(valuesToQuery))));\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"375ee6573ef9849fb746b27e12fea91e8f7d77b9":["96ae115468a08fb03270562a0121761d73c2c8c1"],"e460f059c59ca6be827d6de9a0e26f526b9414c0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"868f63baffb79407d4b49f3c0be8dc4725ffc6e1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b9ccce763ea3c7e51eff749e584c061d8744b72d"],"b9ccce763ea3c7e51eff749e584c061d8744b72d":["375ee6573ef9849fb746b27e12fea91e8f7d77b9"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["868f63baffb79407d4b49f3c0be8dc4725ffc6e1","adc9dc8ef0ce617b940a039fd12f79e8b098cc7f"],"96ae115468a08fb03270562a0121761d73c2c8c1":["e460f059c59ca6be827d6de9a0e26f526b9414c0"],"adc9dc8ef0ce617b940a039fd12f79e8b098cc7f":["868f63baffb79407d4b49f3c0be8dc4725ffc6e1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"]},"commit2Childs":{"375ee6573ef9849fb746b27e12fea91e8f7d77b9":["b9ccce763ea3c7e51eff749e584c061d8744b72d"],"e460f059c59ca6be827d6de9a0e26f526b9414c0":["96ae115468a08fb03270562a0121761d73c2c8c1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e460f059c59ca6be827d6de9a0e26f526b9414c0","868f63baffb79407d4b49f3c0be8dc4725ffc6e1"],"868f63baffb79407d4b49f3c0be8dc4725ffc6e1":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273","adc9dc8ef0ce617b940a039fd12f79e8b098cc7f"],"b9ccce763ea3c7e51eff749e584c061d8744b72d":["868f63baffb79407d4b49f3c0be8dc4725ffc6e1"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"96ae115468a08fb03270562a0121761d73c2c8c1":["375ee6573ef9849fb746b27e12fea91e8f7d77b9"],"adc9dc8ef0ce617b940a039fd12f79e8b098cc7f":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}