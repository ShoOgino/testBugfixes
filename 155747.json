{"path":"lucene/core/src/java/org/apache/lucene/util/packed/DirectPackedReader#get(int).mjava","commits":[{"id":"4a470c93b2b0f8f51241f52705fc110a01f27ad2","date":1337969379,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/DirectPackedReader#get(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/DirectReader#get(int).mjava","sourceNew":"  @Override\n  public long get(int index) {\n    final long majorBitPos = (long)index * bitsPerValue;\n    final int elementPos = (int)(majorBitPos >>> BLOCK_BITS); // / BLOCK_SIZE\n    final int bitPos =     (int)(majorBitPos & MOD_MASK); // % BLOCK_SIZE);\n\n    final long result;\n    try {\n      in.seek(startPointer + (elementPos << 3));\n      final long l1 = in.readLong();\n      final int bits1 = 64 - bitPos;\n      if (bits1 >= bitsPerValue) { // not split\n        result = l1 >> (bits1-bitsPerValue) & masks[bitsPerValue-1];\n      } else {\n        final int bits2 = bitsPerValue - bits1;\n        final long result1 = (l1 & masks[bits1-1]) << bits2;\n        final long l2 = in.readLong();\n        final long result2 = l2 >> (64 - bits2) & masks[bits2-1];\n        result = result1 | result2;\n      }\n\n      return result;\n    } catch (IOException ioe) {\n      throw new IllegalStateException(\"failed\", ioe);\n    }\n  }\n\n","sourceOld":"  @Override\n  public long get(int index) {\n    final long majorBitPos = (long)index * bitsPerValue;\n    final int elementPos = (int)(majorBitPos >>> BLOCK_BITS); // / BLOCK_SIZE\n    final int bitPos =     (int)(majorBitPos & MOD_MASK); // % BLOCK_SIZE);\n\n    final long result;\n    try {\n      in.seek(startPointer + (elementPos << 3));\n      final long l1 = in.readLong();\n      final int bits1 = 64 - bitPos;\n      if (bits1 >= bitsPerValue) { // not split\n        result = l1 >> (bits1-bitsPerValue) & masks[bitsPerValue-1];\n      } else {\n        final int bits2 = bitsPerValue - bits1;\n        final long result1 = (l1 & masks[bits1-1]) << bits2;\n        final long l2 = in.readLong();\n        final long result2 = l2 >> (64 - bits2) & masks[bits2-1];\n        result = result1 | result2;\n      }\n\n      return result;\n    } catch (IOException ioe) {\n      throw new IllegalStateException(\"failed\", ioe);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c661dcad9680b8a6ce5bf2cc583a69ec965328bc","date":1352297862,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/DirectPackedReader#get(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/DirectPackedReader#get(int).mjava","sourceNew":"  @Override\n  public long get(int index) {\n    final long majorBitPos = (long)index * bitsPerValue;\n    final long elementPos = majorBitPos >>> 3;\n    try {\n      in.seek(startPointer + elementPos);\n\n      final byte b0 = in.readByte();\n      final int bitPos = (int) (majorBitPos & 7);\n      if (bitPos + bitsPerValue <= 8) {\n        // special case: all bits are in the first byte\n        return (b0 & ((1L << (8 - bitPos)) - 1)) >>> (8 - bitPos - bitsPerValue);\n      }\n\n      // take bits from the first byte\n      int remainingBits = bitsPerValue - 8 + bitPos;\n      long result = (b0 & ((1L << (8 - bitPos)) - 1)) << remainingBits;\n\n      // add bits from inner bytes\n      while (remainingBits >= 8) {\n        remainingBits -= 8;\n        result |= (in.readByte() & 0xFFL) << remainingBits;\n      }\n\n      // take bits from the last byte\n      if (remainingBits > 0) {\n        result |= (in.readByte() & 0xFFL) >>> (8 - remainingBits);\n      }\n\n      return result;\n    } catch (IOException ioe) {\n      throw new IllegalStateException(\"failed\", ioe);\n    }\n  }\n\n","sourceOld":"  @Override\n  public long get(int index) {\n    final long majorBitPos = (long)index * bitsPerValue;\n    final int elementPos = (int)(majorBitPos >>> BLOCK_BITS); // / BLOCK_SIZE\n    final int bitPos =     (int)(majorBitPos & MOD_MASK); // % BLOCK_SIZE);\n\n    final long result;\n    try {\n      in.seek(startPointer + (elementPos << 3));\n      final long l1 = in.readLong();\n      final int bits1 = 64 - bitPos;\n      if (bits1 >= bitsPerValue) { // not split\n        result = l1 >> (bits1-bitsPerValue) & masks[bitsPerValue-1];\n      } else {\n        final int bits2 = bitsPerValue - bits1;\n        final long result1 = (l1 & masks[bits1-1]) << bits2;\n        final long l2 = in.readLong();\n        final long result2 = l2 >> (64 - bits2) & masks[bits2-1];\n        result = result1 | result2;\n      }\n\n      return result;\n    } catch (IOException ioe) {\n      throw new IllegalStateException(\"failed\", ioe);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29518c5f1eb317a58cfb96446be6720fc6387dd4","date":1381888454,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/DirectPackedReader#get(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/DirectPackedReader#get(int).mjava","sourceNew":"  @Override\n  public long get(int index) {\n    final long majorBitPos = (long)index * bitsPerValue;\n    final long elementPos = majorBitPos >>> 3;\n    try {\n      in.seek(startPointer + elementPos);\n\n      final int bitPos = (int) (majorBitPos & 7);\n      // round up bits to a multiple of 8 to find total bytes needed to read\n      final int roundedBits = ((bitPos + bitsPerValue + 7) & ~7);\n      // the number of extra bits read at the end to shift out\n      int shiftRightBits = roundedBits - bitPos - bitsPerValue;\n\n      long rawValue;\n      switch (roundedBits >>> 3) {\n        case 1:\n          rawValue = in.readByte();\n          break;\n        case 2:\n          rawValue = in.readShort();\n          break;\n        case 3:\n          rawValue = ((long)in.readShort() << 8) | (in.readByte() & 0xFFL);\n          break;\n        case 4:\n          rawValue = in.readInt();\n          break;\n        case 5:\n          rawValue = ((long)in.readInt() << 8) | (in.readByte() & 0xFFL);\n          break;\n        case 6:\n          rawValue = ((long)in.readInt() << 16) | (in.readShort() & 0xFFFFL);\n          break;\n        case 7:\n          rawValue = ((long)in.readInt() << 24) | ((in.readShort() & 0xFFFFL) << 8) | (in.readByte() & 0xFFL);\n          break;\n        case 8:\n          rawValue = in.readLong();\n          break;\n        case 9:\n          // We must be very careful not to shift out relevant bits. So we account for right shift\n          // we would normally do on return here, and reset it.\n          rawValue = (in.readLong() << (8 - shiftRightBits)) | ((in.readByte() & 0xFFL) >>> shiftRightBits);\n          shiftRightBits = 0;\n          break;\n        default:\n          throw new AssertionError(\"bitsPerValue too large: \" + bitsPerValue);\n      }\n      return (rawValue >>> shiftRightBits) & valueMask;\n\n    } catch (IOException ioe) {\n      throw new IllegalStateException(\"failed\", ioe);\n    }\n  }\n\n","sourceOld":"  @Override\n  public long get(int index) {\n    final long majorBitPos = (long)index * bitsPerValue;\n    final long elementPos = majorBitPos >>> 3;\n    try {\n      in.seek(startPointer + elementPos);\n\n      final byte b0 = in.readByte();\n      final int bitPos = (int) (majorBitPos & 7);\n      if (bitPos + bitsPerValue <= 8) {\n        // special case: all bits are in the first byte\n        return (b0 & ((1L << (8 - bitPos)) - 1)) >>> (8 - bitPos - bitsPerValue);\n      }\n\n      // take bits from the first byte\n      int remainingBits = bitsPerValue - 8 + bitPos;\n      long result = (b0 & ((1L << (8 - bitPos)) - 1)) << remainingBits;\n\n      // add bits from inner bytes\n      while (remainingBits >= 8) {\n        remainingBits -= 8;\n        result |= (in.readByte() & 0xFFL) << remainingBits;\n      }\n\n      // take bits from the last byte\n      if (remainingBits > 0) {\n        result |= (in.readByte() & 0xFFL) >>> (8 - remainingBits);\n      }\n\n      return result;\n    } catch (IOException ioe) {\n      throw new IllegalStateException(\"failed\", ioe);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d36ccb9a1c11aeb91962e89bda4a2e643c8629b3","date":1401710950,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/DirectPackedReader#get(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/DirectPackedReader#get(int).mjava","sourceNew":"  @Override\n  public long get(int index) {\n    final long majorBitPos = (long)index * bitsPerValue;\n    final long elementPos = majorBitPos >>> 3;\n    try {\n      in.seek(startPointer + elementPos);\n\n      final int bitPos = (int) (majorBitPos & 7);\n      // round up bits to a multiple of 8 to find total bytes needed to read\n      final int roundedBits = ((bitPos + bitsPerValue + 7) & ~7);\n      // the number of extra bits read at the end to shift out\n      int shiftRightBits = roundedBits - bitPos - bitsPerValue;\n\n      long rawValue;\n      switch (roundedBits >>> 3) {\n        case 1:\n          rawValue = in.readByte();\n          break;\n        case 2:\n          rawValue = in.readShort();\n          break;\n        case 3:\n          rawValue = ((long)in.readShort() << 8) | (in.readByte() & 0xFFL);\n          break;\n        case 4:\n          rawValue = in.readInt();\n          break;\n        case 5:\n          rawValue = ((long)in.readInt() << 8) | (in.readByte() & 0xFFL);\n          break;\n        case 6:\n          rawValue = ((long)in.readInt() << 16) | (in.readShort() & 0xFFFFL);\n          break;\n        case 7:\n          rawValue = ((long)in.readInt() << 24) | ((in.readShort() & 0xFFFFL) << 8) | (in.readByte() & 0xFFL);\n          break;\n        case 8:\n          rawValue = in.readLong();\n          break;\n        case 9:\n          // We must be very careful not to shift out relevant bits. So we account for right shift\n          // we would normally do on return here, and reset it.\n          rawValue = (in.readLong() << (8 - shiftRightBits)) | ((in.readByte() & 0xFFL) >>> shiftRightBits);\n          shiftRightBits = 0;\n          break;\n        default:\n          throw new AssertionError(\"bitsPerValue too large: \" + bitsPerValue);\n      }\n      return (rawValue >>> shiftRightBits) & valueMask;\n\n    } catch (IOException ioe) {\n      throw new RuntimeException(ioe);\n    }\n  }\n\n","sourceOld":"  @Override\n  public long get(int index) {\n    final long majorBitPos = (long)index * bitsPerValue;\n    final long elementPos = majorBitPos >>> 3;\n    try {\n      in.seek(startPointer + elementPos);\n\n      final int bitPos = (int) (majorBitPos & 7);\n      // round up bits to a multiple of 8 to find total bytes needed to read\n      final int roundedBits = ((bitPos + bitsPerValue + 7) & ~7);\n      // the number of extra bits read at the end to shift out\n      int shiftRightBits = roundedBits - bitPos - bitsPerValue;\n\n      long rawValue;\n      switch (roundedBits >>> 3) {\n        case 1:\n          rawValue = in.readByte();\n          break;\n        case 2:\n          rawValue = in.readShort();\n          break;\n        case 3:\n          rawValue = ((long)in.readShort() << 8) | (in.readByte() & 0xFFL);\n          break;\n        case 4:\n          rawValue = in.readInt();\n          break;\n        case 5:\n          rawValue = ((long)in.readInt() << 8) | (in.readByte() & 0xFFL);\n          break;\n        case 6:\n          rawValue = ((long)in.readInt() << 16) | (in.readShort() & 0xFFFFL);\n          break;\n        case 7:\n          rawValue = ((long)in.readInt() << 24) | ((in.readShort() & 0xFFFFL) << 8) | (in.readByte() & 0xFFL);\n          break;\n        case 8:\n          rawValue = in.readLong();\n          break;\n        case 9:\n          // We must be very careful not to shift out relevant bits. So we account for right shift\n          // we would normally do on return here, and reset it.\n          rawValue = (in.readLong() << (8 - shiftRightBits)) | ((in.readByte() & 0xFFL) >>> shiftRightBits);\n          shiftRightBits = 0;\n          break;\n        default:\n          throw new AssertionError(\"bitsPerValue too large: \" + bitsPerValue);\n      }\n      return (rawValue >>> shiftRightBits) & valueMask;\n\n    } catch (IOException ioe) {\n      throw new IllegalStateException(\"failed\", ioe);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d36ccb9a1c11aeb91962e89bda4a2e643c8629b3":["29518c5f1eb317a58cfb96446be6720fc6387dd4"],"29518c5f1eb317a58cfb96446be6720fc6387dd4":["c661dcad9680b8a6ce5bf2cc583a69ec965328bc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c661dcad9680b8a6ce5bf2cc583a69ec965328bc":["4a470c93b2b0f8f51241f52705fc110a01f27ad2"],"4a470c93b2b0f8f51241f52705fc110a01f27ad2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d36ccb9a1c11aeb91962e89bda4a2e643c8629b3"]},"commit2Childs":{"d36ccb9a1c11aeb91962e89bda4a2e643c8629b3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"29518c5f1eb317a58cfb96446be6720fc6387dd4":["d36ccb9a1c11aeb91962e89bda4a2e643c8629b3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4a470c93b2b0f8f51241f52705fc110a01f27ad2"],"c661dcad9680b8a6ce5bf2cc583a69ec965328bc":["29518c5f1eb317a58cfb96446be6720fc6387dd4"],"4a470c93b2b0f8f51241f52705fc110a01f27ad2":["c661dcad9680b8a6ce5bf2cc583a69ec965328bc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}