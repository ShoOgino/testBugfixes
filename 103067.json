{"path":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testDateMathInStart().mjava","commits":[{"id":"56aa6ff4cdf3147154a86d7c22a8a2615869e772","date":1570745842,"type":0,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testDateMathInStart().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testDateMathInStart() throws Exception {\n    ClusterStateProvider clusterStateProvider = solrClient.getClusterStateProvider();\n    Class<? extends ClusterStateProvider> aClass = clusterStateProvider.getClass();\n    System.out.println(\"CSPROVIDER:\" + aClass);\n\n    // This test prevents recurrence of SOLR-13760\n\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n    CountDownLatch aliasUpdate = new CountDownLatch(1);\n    monitorAlias(aliasUpdate);\n\n    // each collection has 4 shards with 3 replicas for 12 possible destinations\n    // 4 of which are leaders, and 8 of which should fail this test.\n    final int numShards = 1 + random().nextInt(4);\n    final int numReplicas = 1 + random().nextInt(3);\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2019-09-14T03:00:00Z/DAY\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas))\n        .process(solrClient);\n\n    aliasUpdate.await();\n    if (BaseHttpClusterStateProvider.class.isAssignableFrom(aClass)) {\n      ((BaseHttpClusterStateProvider)clusterStateProvider).resolveAlias(getAlias(), true);\n    }\n    aliasUpdate = new CountDownLatch(1);\n    monitorAlias(aliasUpdate);\n\n    ModifiableSolrParams params = params();\n    String nowDay = DateTimeFormatter.ISO_INSTANT.format(DateMathParser.parseMath(new Date(), \"2019-09-14T01:00:00Z\").toInstant());\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"1\", \"timestamp_dt\", nowDay)), // should not cause preemptive creation of 10-28 now\n        params));\n\n    // this process should have lead to the modification of the start time for the alias, converting it into\n    // a parsable date, removing the DateMath\n\n    // what we test next happens in a separate thread, so we have to give it some time to happen\n    aliasUpdate.await();\n    if (BaseHttpClusterStateProvider.class.isAssignableFrom(aClass)) {\n      ((BaseHttpClusterStateProvider)clusterStateProvider).resolveAlias(getAlias(), true);\n    }\n\n    String hopeFullyModified = clusterStateProvider.getAliasProperties(getAlias()).get(ROUTER_START);\n    try {\n      Instant.parse(hopeFullyModified);\n    } catch (DateTimeParseException e) {\n      fail(ROUTER_START + \" should not have any date math by this point and parse as an instant. Using \"+ aClass +\" Found:\" + hopeFullyModified);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":0,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testDateMathInStart().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testDateMathInStart() throws Exception {\n    ClusterStateProvider clusterStateProvider = solrClient.getClusterStateProvider();\n    Class<? extends ClusterStateProvider> aClass = clusterStateProvider.getClass();\n    System.out.println(\"CSPROVIDER:\" + aClass);\n\n    // This test prevents recurrence of SOLR-13760\n\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n    CountDownLatch aliasUpdate = new CountDownLatch(1);\n    monitorAlias(aliasUpdate);\n\n    // each collection has 4 shards with 3 replicas for 12 possible destinations\n    // 4 of which are leaders, and 8 of which should fail this test.\n    final int numShards = 1 + random().nextInt(4);\n    final int numReplicas = 1 + random().nextInt(3);\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2019-09-14T03:00:00Z/DAY\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas))\n        .process(solrClient);\n\n    aliasUpdate.await();\n    if (BaseHttpClusterStateProvider.class.isAssignableFrom(aClass)) {\n      ((BaseHttpClusterStateProvider)clusterStateProvider).resolveAlias(getAlias(), true);\n    }\n    aliasUpdate = new CountDownLatch(1);\n    monitorAlias(aliasUpdate);\n\n    ModifiableSolrParams params = params();\n    String nowDay = DateTimeFormatter.ISO_INSTANT.format(DateMathParser.parseMath(new Date(), \"2019-09-14T01:00:00Z\").toInstant());\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"1\", \"timestamp_dt\", nowDay)), // should not cause preemptive creation of 10-28 now\n        params));\n\n    // this process should have lead to the modification of the start time for the alias, converting it into\n    // a parsable date, removing the DateMath\n\n    // what we test next happens in a separate thread, so we have to give it some time to happen\n    aliasUpdate.await();\n    if (BaseHttpClusterStateProvider.class.isAssignableFrom(aClass)) {\n      ((BaseHttpClusterStateProvider)clusterStateProvider).resolveAlias(getAlias(), true);\n    }\n\n    String hopeFullyModified = clusterStateProvider.getAliasProperties(getAlias()).get(ROUTER_START);\n    try {\n      Instant.parse(hopeFullyModified);\n    } catch (DateTimeParseException e) {\n      fail(ROUTER_START + \" should not have any date math by this point and parse as an instant. Using \"+ aClass +\" Found:\" + hopeFullyModified);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"794a58eca3854680b1f0c2e3aeb839d6365cd5cb","date":1574119941,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testDateMathInStart().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testDateMathInStart().mjava","sourceNew":"  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-13943\")\n  @Test\n  public void testDateMathInStart() throws Exception {\n    ClusterStateProvider clusterStateProvider = solrClient.getClusterStateProvider();\n    Class<? extends ClusterStateProvider> aClass = clusterStateProvider.getClass();\n    System.out.println(\"CSPROVIDER:\" + aClass);\n\n    // This test prevents recurrence of SOLR-13760\n\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n    CountDownLatch aliasUpdate = new CountDownLatch(1);\n    monitorAlias(aliasUpdate);\n\n    // each collection has 4 shards with 3 replicas for 12 possible destinations\n    // 4 of which are leaders, and 8 of which should fail this test.\n    final int numShards = 1 + random().nextInt(4);\n    final int numReplicas = 1 + random().nextInt(3);\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2019-09-14T03:00:00Z/DAY\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas))\n        .process(solrClient);\n\n    aliasUpdate.await();\n    if (BaseHttpClusterStateProvider.class.isAssignableFrom(aClass)) {\n      ((BaseHttpClusterStateProvider)clusterStateProvider).resolveAlias(getAlias(), true);\n    }\n    aliasUpdate = new CountDownLatch(1);\n    monitorAlias(aliasUpdate);\n\n    ModifiableSolrParams params = params();\n    String nowDay = DateTimeFormatter.ISO_INSTANT.format(DateMathParser.parseMath(new Date(), \"2019-09-14T01:00:00Z\").toInstant());\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"1\", \"timestamp_dt\", nowDay)), // should not cause preemptive creation of 10-28 now\n        params));\n\n    // this process should have lead to the modification of the start time for the alias, converting it into\n    // a parsable date, removing the DateMath\n\n    // what we test next happens in a separate thread, so we have to give it some time to happen\n    aliasUpdate.await();\n    if (BaseHttpClusterStateProvider.class.isAssignableFrom(aClass)) {\n      ((BaseHttpClusterStateProvider)clusterStateProvider).resolveAlias(getAlias(), true);\n    }\n\n    String hopeFullyModified = clusterStateProvider.getAliasProperties(getAlias()).get(ROUTER_START);\n    try {\n      Instant.parse(hopeFullyModified);\n    } catch (DateTimeParseException e) {\n      fail(ROUTER_START + \" should not have any date math by this point and parse as an instant. Using \"+ aClass +\" Found:\" + hopeFullyModified);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testDateMathInStart() throws Exception {\n    ClusterStateProvider clusterStateProvider = solrClient.getClusterStateProvider();\n    Class<? extends ClusterStateProvider> aClass = clusterStateProvider.getClass();\n    System.out.println(\"CSPROVIDER:\" + aClass);\n\n    // This test prevents recurrence of SOLR-13760\n\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n    CountDownLatch aliasUpdate = new CountDownLatch(1);\n    monitorAlias(aliasUpdate);\n\n    // each collection has 4 shards with 3 replicas for 12 possible destinations\n    // 4 of which are leaders, and 8 of which should fail this test.\n    final int numShards = 1 + random().nextInt(4);\n    final int numReplicas = 1 + random().nextInt(3);\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2019-09-14T03:00:00Z/DAY\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas))\n        .process(solrClient);\n\n    aliasUpdate.await();\n    if (BaseHttpClusterStateProvider.class.isAssignableFrom(aClass)) {\n      ((BaseHttpClusterStateProvider)clusterStateProvider).resolveAlias(getAlias(), true);\n    }\n    aliasUpdate = new CountDownLatch(1);\n    monitorAlias(aliasUpdate);\n\n    ModifiableSolrParams params = params();\n    String nowDay = DateTimeFormatter.ISO_INSTANT.format(DateMathParser.parseMath(new Date(), \"2019-09-14T01:00:00Z\").toInstant());\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"1\", \"timestamp_dt\", nowDay)), // should not cause preemptive creation of 10-28 now\n        params));\n\n    // this process should have lead to the modification of the start time for the alias, converting it into\n    // a parsable date, removing the DateMath\n\n    // what we test next happens in a separate thread, so we have to give it some time to happen\n    aliasUpdate.await();\n    if (BaseHttpClusterStateProvider.class.isAssignableFrom(aClass)) {\n      ((BaseHttpClusterStateProvider)clusterStateProvider).resolveAlias(getAlias(), true);\n    }\n\n    String hopeFullyModified = clusterStateProvider.getAliasProperties(getAlias()).get(ROUTER_START);\n    try {\n      Instant.parse(hopeFullyModified);\n    } catch (DateTimeParseException e) {\n      fail(ROUTER_START + \" should not have any date math by this point and parse as an instant. Using \"+ aClass +\" Found:\" + hopeFullyModified);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testDateMathInStart().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testDateMathInStart().mjava","sourceNew":"  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-13943\")\n  @Test\n  public void testDateMathInStart() throws Exception {\n    ClusterStateProvider clusterStateProvider = solrClient.getClusterStateProvider();\n    Class<? extends ClusterStateProvider> aClass = clusterStateProvider.getClass();\n    System.out.println(\"CSPROVIDER:\" + aClass);\n\n    // This test prevents recurrence of SOLR-13760\n\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n    CountDownLatch aliasUpdate = new CountDownLatch(1);\n    monitorAlias(aliasUpdate);\n\n    // each collection has 4 shards with 3 replicas for 12 possible destinations\n    // 4 of which are leaders, and 8 of which should fail this test.\n    final int numShards = 1 + random().nextInt(4);\n    final int numReplicas = 1 + random().nextInt(3);\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2019-09-14T03:00:00Z/DAY\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas))\n        .process(solrClient);\n\n    aliasUpdate.await();\n    if (BaseHttpClusterStateProvider.class.isAssignableFrom(aClass)) {\n      ((BaseHttpClusterStateProvider)clusterStateProvider).resolveAlias(getAlias(), true);\n    }\n    aliasUpdate = new CountDownLatch(1);\n    monitorAlias(aliasUpdate);\n\n    ModifiableSolrParams params = params();\n    String nowDay = DateTimeFormatter.ISO_INSTANT.format(DateMathParser.parseMath(new Date(), \"2019-09-14T01:00:00Z\").toInstant());\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"1\", \"timestamp_dt\", nowDay)), // should not cause preemptive creation of 10-28 now\n        params));\n\n    // this process should have lead to the modification of the start time for the alias, converting it into\n    // a parsable date, removing the DateMath\n\n    // what we test next happens in a separate thread, so we have to give it some time to happen\n    aliasUpdate.await();\n    if (BaseHttpClusterStateProvider.class.isAssignableFrom(aClass)) {\n      ((BaseHttpClusterStateProvider)clusterStateProvider).resolveAlias(getAlias(), true);\n    }\n\n    String hopeFullyModified = clusterStateProvider.getAliasProperties(getAlias()).get(ROUTER_START);\n    try {\n      Instant.parse(hopeFullyModified);\n    } catch (DateTimeParseException e) {\n      fail(ROUTER_START + \" should not have any date math by this point and parse as an instant. Using \"+ aClass +\" Found:\" + hopeFullyModified);\n    }\n  }\n\n","sourceOld":"  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-13943\")\n  @Test\n  public void testDateMathInStart() throws Exception {\n    ClusterStateProvider clusterStateProvider = solrClient.getClusterStateProvider();\n    Class<? extends ClusterStateProvider> aClass = clusterStateProvider.getClass();\n    System.out.println(\"CSPROVIDER:\" + aClass);\n\n    // This test prevents recurrence of SOLR-13760\n\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n    CountDownLatch aliasUpdate = new CountDownLatch(1);\n    monitorAlias(aliasUpdate);\n\n    // each collection has 4 shards with 3 replicas for 12 possible destinations\n    // 4 of which are leaders, and 8 of which should fail this test.\n    final int numShards = 1 + random().nextInt(4);\n    final int numReplicas = 1 + random().nextInt(3);\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2019-09-14T03:00:00Z/DAY\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas))\n        .process(solrClient);\n\n    aliasUpdate.await();\n    if (BaseHttpClusterStateProvider.class.isAssignableFrom(aClass)) {\n      ((BaseHttpClusterStateProvider)clusterStateProvider).resolveAlias(getAlias(), true);\n    }\n    aliasUpdate = new CountDownLatch(1);\n    monitorAlias(aliasUpdate);\n\n    ModifiableSolrParams params = params();\n    String nowDay = DateTimeFormatter.ISO_INSTANT.format(DateMathParser.parseMath(new Date(), \"2019-09-14T01:00:00Z\").toInstant());\n    assertUpdateResponse(add(alias, Arrays.asList(\n        sdoc(\"id\", \"1\", \"timestamp_dt\", nowDay)), // should not cause preemptive creation of 10-28 now\n        params));\n\n    // this process should have lead to the modification of the start time for the alias, converting it into\n    // a parsable date, removing the DateMath\n\n    // what we test next happens in a separate thread, so we have to give it some time to happen\n    aliasUpdate.await();\n    if (BaseHttpClusterStateProvider.class.isAssignableFrom(aClass)) {\n      ((BaseHttpClusterStateProvider)clusterStateProvider).resolveAlias(getAlias(), true);\n    }\n\n    String hopeFullyModified = clusterStateProvider.getAliasProperties(getAlias()).get(ROUTER_START);\n    try {\n      Instant.parse(hopeFullyModified);\n    } catch (DateTimeParseException e) {\n      fail(ROUTER_START + \" should not have any date math by this point and parse as an instant. Using \"+ aClass +\" Found:\" + hopeFullyModified);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"794a58eca3854680b1f0c2e3aeb839d6365cd5cb":["56aa6ff4cdf3147154a86d7c22a8a2615869e772"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["794a58eca3854680b1f0c2e3aeb839d6365cd5cb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"56aa6ff4cdf3147154a86d7c22a8a2615869e772":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b0b597c65628ca9e73913a07e81691f8229bae35":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","56aa6ff4cdf3147154a86d7c22a8a2615869e772"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["56aa6ff4cdf3147154a86d7c22a8a2615869e772","b0b597c65628ca9e73913a07e81691f8229bae35"],"794a58eca3854680b1f0c2e3aeb839d6365cd5cb":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"56aa6ff4cdf3147154a86d7c22a8a2615869e772":["794a58eca3854680b1f0c2e3aeb839d6365cd5cb","b0b597c65628ca9e73913a07e81691f8229bae35"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}