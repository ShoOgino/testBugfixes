{"path":"lucene/src/test/org/apache/lucene/util/TestStringIntern#testStringIntern().mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/TestStringIntern#testStringIntern().mjava","pathOld":"src/test/org/apache/lucene/util/TestStringIntern#testStringIntern().mjava","sourceNew":"  public void testStringIntern() throws InterruptedException {\n    makeStrings(1024*10);  // something greater than the capacity of the default cache size\n    // makeStrings(100);  // realistic for perf testing\n    int nThreads = 20;\n    // final int iter=100000;\n    final int iter=1000000;\n    \n    // try native intern\n    // StringHelper.interner = new StringInterner();\n\n    Thread[] threads = new Thread[nThreads];\n    for (int i=0; i<nThreads; i++) {\n      final int seed = i;\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          Random rand = new Random(seed);\n          String[] myInterned = new String[testStrings.length];\n          for (int j=0; j<iter; j++) {\n            int idx = rand.nextInt(testStrings.length);\n            String s = testStrings[idx];\n            if (rand.nextBoolean()) s = new String(s); // make a copy half of the time\n            String interned = StringHelper.intern(s);\n            String prevInterned = myInterned[idx];\n            String otherInterned = internedStrings[idx];\n\n            // test against other threads\n            if (otherInterned != null && otherInterned != interned) {\n              fail();\n            }\n            internedStrings[idx] = interned;\n\n            // test against local copy\n            if (prevInterned != null && prevInterned != interned) {\n              fail();\n            }\n            myInterned[idx] = interned;\n          }\n        }\n      };\n\n      threads[i].start();\n    }\n\n    for (int i=0; i<nThreads; i++) {\n      threads[i].join();\n    }\n  }\n\n","sourceOld":"  public void testStringIntern() throws InterruptedException {\n    makeStrings(1024*10);  // something greater than the capacity of the default cache size\n    // makeStrings(100);  // realistic for perf testing\n    int nThreads = 20;\n    // final int iter=100000;\n    final int iter=1000000;\n    \n    // try native intern\n    // StringHelper.interner = new StringInterner();\n\n    Thread[] threads = new Thread[nThreads];\n    for (int i=0; i<nThreads; i++) {\n      final int seed = i;\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          Random rand = new Random(seed);\n          String[] myInterned = new String[testStrings.length];\n          for (int j=0; j<iter; j++) {\n            int idx = rand.nextInt(testStrings.length);\n            String s = testStrings[idx];\n            if (rand.nextBoolean()) s = new String(s); // make a copy half of the time\n            String interned = StringHelper.intern(s);\n            String prevInterned = myInterned[idx];\n            String otherInterned = internedStrings[idx];\n\n            // test against other threads\n            if (otherInterned != null && otherInterned != interned) {\n              fail();\n            }\n            internedStrings[idx] = interned;\n\n            // test against local copy\n            if (prevInterned != null && prevInterned != interned) {\n              fail();\n            }\n            myInterned[idx] = interned;\n          }\n        }\n      };\n\n      threads[i].start();\n    }\n\n    for (int i=0; i<nThreads; i++) {\n      threads[i].join();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2aafd88401639311b0404e67c94e829e123a0e45","date":1273477632,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/TestStringIntern#testStringIntern().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/TestStringIntern#testStringIntern().mjava","sourceNew":"  public void testStringIntern() throws InterruptedException {\n    makeStrings(1024*10);  // something greater than the capacity of the default cache size\n    // makeStrings(100);  // realistic for perf testing\n    int nThreads = 20;\n    // final int iter=100000;\n    final int iter=1000000*_TestUtil.getRandomMultiplier();\n    \n    // try native intern\n    // StringHelper.interner = new StringInterner();\n\n    Thread[] threads = new Thread[nThreads];\n    for (int i=0; i<nThreads; i++) {\n      final int seed = i;\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          Random rand = new Random(seed);\n          String[] myInterned = new String[testStrings.length];\n          for (int j=0; j<iter; j++) {\n            int idx = rand.nextInt(testStrings.length);\n            String s = testStrings[idx];\n            if (rand.nextBoolean()) s = new String(s); // make a copy half of the time\n            String interned = StringHelper.intern(s);\n            String prevInterned = myInterned[idx];\n            String otherInterned = internedStrings[idx];\n\n            // test against other threads\n            if (otherInterned != null && otherInterned != interned) {\n              fail();\n            }\n            internedStrings[idx] = interned;\n\n            // test against local copy\n            if (prevInterned != null && prevInterned != interned) {\n              fail();\n            }\n            myInterned[idx] = interned;\n          }\n        }\n      };\n\n      threads[i].start();\n    }\n\n    for (int i=0; i<nThreads; i++) {\n      threads[i].join();\n    }\n  }\n\n","sourceOld":"  public void testStringIntern() throws InterruptedException {\n    makeStrings(1024*10);  // something greater than the capacity of the default cache size\n    // makeStrings(100);  // realistic for perf testing\n    int nThreads = 20;\n    // final int iter=100000;\n    final int iter=1000000;\n    \n    // try native intern\n    // StringHelper.interner = new StringInterner();\n\n    Thread[] threads = new Thread[nThreads];\n    for (int i=0; i<nThreads; i++) {\n      final int seed = i;\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          Random rand = new Random(seed);\n          String[] myInterned = new String[testStrings.length];\n          for (int j=0; j<iter; j++) {\n            int idx = rand.nextInt(testStrings.length);\n            String s = testStrings[idx];\n            if (rand.nextBoolean()) s = new String(s); // make a copy half of the time\n            String interned = StringHelper.intern(s);\n            String prevInterned = myInterned[idx];\n            String otherInterned = internedStrings[idx];\n\n            // test against other threads\n            if (otherInterned != null && otherInterned != interned) {\n              fail();\n            }\n            internedStrings[idx] = interned;\n\n            // test against local copy\n            if (prevInterned != null && prevInterned != interned) {\n              fail();\n            }\n            myInterned[idx] = interned;\n          }\n        }\n      };\n\n      threads[i].start();\n    }\n\n    for (int i=0; i<nThreads; i++) {\n      threads[i].join();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0e45742e10e8e3b98e854babe6dbb07a4197b71","date":1280230285,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/TestStringIntern#testStringIntern().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/TestStringIntern#testStringIntern().mjava","sourceNew":"  public void testStringIntern() throws InterruptedException {\n    makeStrings(1024*10);  // something greater than the capacity of the default cache size\n    // makeStrings(100);  // realistic for perf testing\n    int nThreads = 20;\n    // final int iter=100000;\n    final int iter = 1000000 * RANDOM_MULTIPLIER;\n    \n    // try native intern\n    // StringHelper.interner = new StringInterner();\n\n    Thread[] threads = new Thread[nThreads];\n    for (int i=0; i<nThreads; i++) {\n      final int seed = i;\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          Random rand = new Random(seed);\n          String[] myInterned = new String[testStrings.length];\n          for (int j=0; j<iter; j++) {\n            int idx = rand.nextInt(testStrings.length);\n            String s = testStrings[idx];\n            if (rand.nextBoolean()) s = new String(s); // make a copy half of the time\n            String interned = StringHelper.intern(s);\n            String prevInterned = myInterned[idx];\n            String otherInterned = internedStrings[idx];\n\n            // test against other threads\n            if (otherInterned != null && otherInterned != interned) {\n              fail();\n            }\n            internedStrings[idx] = interned;\n\n            // test against local copy\n            if (prevInterned != null && prevInterned != interned) {\n              fail();\n            }\n            myInterned[idx] = interned;\n          }\n        }\n      };\n\n      threads[i].start();\n    }\n\n    for (int i=0; i<nThreads; i++) {\n      threads[i].join();\n    }\n  }\n\n","sourceOld":"  public void testStringIntern() throws InterruptedException {\n    makeStrings(1024*10);  // something greater than the capacity of the default cache size\n    // makeStrings(100);  // realistic for perf testing\n    int nThreads = 20;\n    // final int iter=100000;\n    final int iter=1000000*_TestUtil.getRandomMultiplier();\n    \n    // try native intern\n    // StringHelper.interner = new StringInterner();\n\n    Thread[] threads = new Thread[nThreads];\n    for (int i=0; i<nThreads; i++) {\n      final int seed = i;\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          Random rand = new Random(seed);\n          String[] myInterned = new String[testStrings.length];\n          for (int j=0; j<iter; j++) {\n            int idx = rand.nextInt(testStrings.length);\n            String s = testStrings[idx];\n            if (rand.nextBoolean()) s = new String(s); // make a copy half of the time\n            String interned = StringHelper.intern(s);\n            String prevInterned = myInterned[idx];\n            String otherInterned = internedStrings[idx];\n\n            // test against other threads\n            if (otherInterned != null && otherInterned != interned) {\n              fail();\n            }\n            internedStrings[idx] = interned;\n\n            // test against local copy\n            if (prevInterned != null && prevInterned != interned) {\n              fail();\n            }\n            myInterned[idx] = interned;\n          }\n        }\n      };\n\n      threads[i].start();\n    }\n\n    for (int i=0; i<nThreads; i++) {\n      threads[i].join();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3242a09f703274d3b9283f2064a1a33064b53a1b","date":1280263474,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/TestStringIntern#testStringIntern().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/TestStringIntern#testStringIntern().mjava","sourceNew":"  public void testStringIntern() throws InterruptedException {\n    makeStrings(1024*10);  // something greater than the capacity of the default cache size\n    // makeStrings(100);  // realistic for perf testing\n    int nThreads = 20;\n    // final int iter=100000;\n    final int iter = 1000000 * RANDOM_MULTIPLIER;\n    \n    // try native intern\n    // StringHelper.interner = new StringInterner();\n\n    Thread[] threads = new Thread[nThreads];\n    for (int i=0; i<nThreads; i++) {\n      final int seed = i;\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          Random rand = new Random(seed);\n          String[] myInterned = new String[testStrings.length];\n          for (int j=0; j<iter; j++) {\n            int idx = rand.nextInt(testStrings.length);\n            String s = testStrings[idx];\n            if (rand.nextBoolean()) s = new String(s); // make a copy half of the time\n            String interned = StringHelper.intern(s);\n            String prevInterned = myInterned[idx];\n            String otherInterned = internedStrings[idx];\n\n            // test against other threads\n            if (otherInterned != null && otherInterned != interned) {\n              fail();\n            }\n            internedStrings[idx] = interned;\n\n            // test against local copy\n            if (prevInterned != null && prevInterned != interned) {\n              fail();\n            }\n            myInterned[idx] = interned;\n          }\n        }\n      };\n\n      threads[i].start();\n    }\n\n    for (int i=0; i<nThreads; i++) {\n      threads[i].join();\n    }\n  }\n\n","sourceOld":"  public void testStringIntern() throws InterruptedException {\n    makeStrings(1024*10);  // something greater than the capacity of the default cache size\n    // makeStrings(100);  // realistic for perf testing\n    int nThreads = 20;\n    // final int iter=100000;\n    final int iter=1000000*_TestUtil.getRandomMultiplier();\n    \n    // try native intern\n    // StringHelper.interner = new StringInterner();\n\n    Thread[] threads = new Thread[nThreads];\n    for (int i=0; i<nThreads; i++) {\n      final int seed = i;\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          Random rand = new Random(seed);\n          String[] myInterned = new String[testStrings.length];\n          for (int j=0; j<iter; j++) {\n            int idx = rand.nextInt(testStrings.length);\n            String s = testStrings[idx];\n            if (rand.nextBoolean()) s = new String(s); // make a copy half of the time\n            String interned = StringHelper.intern(s);\n            String prevInterned = myInterned[idx];\n            String otherInterned = internedStrings[idx];\n\n            // test against other threads\n            if (otherInterned != null && otherInterned != interned) {\n              fail();\n            }\n            internedStrings[idx] = interned;\n\n            // test against local copy\n            if (prevInterned != null && prevInterned != interned) {\n              fail();\n            }\n            myInterned[idx] = interned;\n          }\n        }\n      };\n\n      threads[i].start();\n    }\n\n    for (int i=0; i<nThreads; i++) {\n      threads[i].join();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0762b640e0d0d12b6edb96db68986e13145c3484","date":1307575932,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/TestStringIntern#testStringIntern().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/TestStringIntern#testStringIntern().mjava","sourceNew":"  public void testStringIntern() throws InterruptedException {\n    makeStrings(1024*10);  // something greater than the capacity of the default cache size\n    // makeStrings(100);  // realistic for perf testing\n    int nThreads = 20;\n    // final int iter=100000;\n    final int iter = atLeast(100000);\n    \n    // try native intern\n    // StringHelper.interner = new StringInterner();\n\n    Thread[] threads = new Thread[nThreads];\n    for (int i=0; i<nThreads; i++) {\n      final int seed = i;\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          Random rand = new Random(seed);\n          String[] myInterned = new String[testStrings.length];\n          for (int j=0; j<iter; j++) {\n            int idx = rand.nextInt(testStrings.length);\n            String s = testStrings[idx];\n            if (rand.nextBoolean()) s = new String(s); // make a copy half of the time\n            String interned = StringHelper.intern(s);\n            String prevInterned = myInterned[idx];\n            String otherInterned = internedStrings[idx];\n\n            // test against other threads\n            if (otherInterned != null && otherInterned != interned) {\n              fail();\n            }\n            internedStrings[idx] = interned;\n\n            // test against local copy\n            if (prevInterned != null && prevInterned != interned) {\n              fail();\n            }\n            myInterned[idx] = interned;\n          }\n        }\n      };\n\n      threads[i].start();\n    }\n\n    for (int i=0; i<nThreads; i++) {\n      threads[i].join();\n    }\n  }\n\n","sourceOld":"  public void testStringIntern() throws InterruptedException {\n    makeStrings(1024*10);  // something greater than the capacity of the default cache size\n    // makeStrings(100);  // realistic for perf testing\n    int nThreads = 20;\n    // final int iter=100000;\n    final int iter = 1000000 * RANDOM_MULTIPLIER;\n    \n    // try native intern\n    // StringHelper.interner = new StringInterner();\n\n    Thread[] threads = new Thread[nThreads];\n    for (int i=0; i<nThreads; i++) {\n      final int seed = i;\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          Random rand = new Random(seed);\n          String[] myInterned = new String[testStrings.length];\n          for (int j=0; j<iter; j++) {\n            int idx = rand.nextInt(testStrings.length);\n            String s = testStrings[idx];\n            if (rand.nextBoolean()) s = new String(s); // make a copy half of the time\n            String interned = StringHelper.intern(s);\n            String prevInterned = myInterned[idx];\n            String otherInterned = internedStrings[idx];\n\n            // test against other threads\n            if (otherInterned != null && otherInterned != interned) {\n              fail();\n            }\n            internedStrings[idx] = interned;\n\n            // test against local copy\n            if (prevInterned != null && prevInterned != interned) {\n              fail();\n            }\n            myInterned[idx] = interned;\n          }\n        }\n      };\n\n      threads[i].start();\n    }\n\n    for (int i=0; i<nThreads; i++) {\n      threads[i].join();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"77cf4379b2824f6ea34b091c495d6e95c38ff9e2","date":1307610475,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/TestStringIntern#testStringIntern().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/TestStringIntern#testStringIntern().mjava","sourceNew":"  public void testStringIntern() throws InterruptedException {\n    makeStrings(1024*10);  // something greater than the capacity of the default cache size\n    // makeStrings(100);  // realistic for perf testing\n    int nThreads = 20;\n    // final int iter=100000;\n    final int iter = atLeast(100000);\n    \n    // try native intern\n    // StringHelper.interner = new StringInterner();\n\n    Thread[] threads = new Thread[nThreads];\n    for (int i=0; i<nThreads; i++) {\n      final int seed = i;\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          Random rand = new Random(seed);\n          String[] myInterned = new String[testStrings.length];\n          for (int j=0; j<iter; j++) {\n            int idx = rand.nextInt(testStrings.length);\n            String s = testStrings[idx];\n            if (rand.nextBoolean()) s = new String(s); // make a copy half of the time\n            String interned = StringHelper.intern(s);\n            String prevInterned = myInterned[idx];\n            String otherInterned = internedStrings[idx];\n\n            // test against other threads\n            if (otherInterned != null && otherInterned != interned) {\n              fail();\n            }\n            internedStrings[idx] = interned;\n\n            // test against local copy\n            if (prevInterned != null && prevInterned != interned) {\n              fail();\n            }\n            myInterned[idx] = interned;\n          }\n        }\n      };\n\n      threads[i].start();\n    }\n\n    for (int i=0; i<nThreads; i++) {\n      threads[i].join();\n    }\n  }\n\n","sourceOld":"  public void testStringIntern() throws InterruptedException {\n    makeStrings(1024*10);  // something greater than the capacity of the default cache size\n    // makeStrings(100);  // realistic for perf testing\n    int nThreads = 20;\n    // final int iter=100000;\n    final int iter = 1000000 * RANDOM_MULTIPLIER;\n    \n    // try native intern\n    // StringHelper.interner = new StringInterner();\n\n    Thread[] threads = new Thread[nThreads];\n    for (int i=0; i<nThreads; i++) {\n      final int seed = i;\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          Random rand = new Random(seed);\n          String[] myInterned = new String[testStrings.length];\n          for (int j=0; j<iter; j++) {\n            int idx = rand.nextInt(testStrings.length);\n            String s = testStrings[idx];\n            if (rand.nextBoolean()) s = new String(s); // make a copy half of the time\n            String interned = StringHelper.intern(s);\n            String prevInterned = myInterned[idx];\n            String otherInterned = internedStrings[idx];\n\n            // test against other threads\n            if (otherInterned != null && otherInterned != interned) {\n              fail();\n            }\n            internedStrings[idx] = interned;\n\n            // test against local copy\n            if (prevInterned != null && prevInterned != interned) {\n              fail();\n            }\n            myInterned[idx] = interned;\n          }\n        }\n      };\n\n      threads[i].start();\n    }\n\n    for (int i=0; i<nThreads; i++) {\n      threads[i].join();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","date":1307729864,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/TestStringIntern#testStringIntern().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/TestStringIntern#testStringIntern().mjava","sourceNew":"  public void testStringIntern() throws InterruptedException {\n    makeStrings(1024*10);  // something greater than the capacity of the default cache size\n    // makeStrings(100);  // realistic for perf testing\n    int nThreads = 20;\n    // final int iter=100000;\n    final int iter = atLeast(100000);\n    \n    // try native intern\n    // StringHelper.interner = new StringInterner();\n\n    Thread[] threads = new Thread[nThreads];\n    for (int i=0; i<nThreads; i++) {\n      final int seed = i;\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          Random rand = new Random(seed);\n          String[] myInterned = new String[testStrings.length];\n          for (int j=0; j<iter; j++) {\n            int idx = rand.nextInt(testStrings.length);\n            String s = testStrings[idx];\n            if (rand.nextBoolean()) s = new String(s); // make a copy half of the time\n            String interned = StringHelper.intern(s);\n            String prevInterned = myInterned[idx];\n            String otherInterned = internedStrings[idx];\n\n            // test against other threads\n            if (otherInterned != null && otherInterned != interned) {\n              fail();\n            }\n            internedStrings[idx] = interned;\n\n            // test against local copy\n            if (prevInterned != null && prevInterned != interned) {\n              fail();\n            }\n            myInterned[idx] = interned;\n          }\n        }\n      };\n\n      threads[i].start();\n    }\n\n    for (int i=0; i<nThreads; i++) {\n      threads[i].join();\n    }\n  }\n\n","sourceOld":"  public void testStringIntern() throws InterruptedException {\n    makeStrings(1024*10);  // something greater than the capacity of the default cache size\n    // makeStrings(100);  // realistic for perf testing\n    int nThreads = 20;\n    // final int iter=100000;\n    final int iter = 1000000 * RANDOM_MULTIPLIER;\n    \n    // try native intern\n    // StringHelper.interner = new StringInterner();\n\n    Thread[] threads = new Thread[nThreads];\n    for (int i=0; i<nThreads; i++) {\n      final int seed = i;\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          Random rand = new Random(seed);\n          String[] myInterned = new String[testStrings.length];\n          for (int j=0; j<iter; j++) {\n            int idx = rand.nextInt(testStrings.length);\n            String s = testStrings[idx];\n            if (rand.nextBoolean()) s = new String(s); // make a copy half of the time\n            String interned = StringHelper.intern(s);\n            String prevInterned = myInterned[idx];\n            String otherInterned = internedStrings[idx];\n\n            // test against other threads\n            if (otherInterned != null && otherInterned != interned) {\n              fail();\n            }\n            internedStrings[idx] = interned;\n\n            // test against local copy\n            if (prevInterned != null && prevInterned != interned) {\n              fail();\n            }\n            myInterned[idx] = interned;\n          }\n        }\n      };\n\n      threads[i].start();\n    }\n\n    for (int i=0; i<nThreads; i++) {\n      threads[i].join();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fafef7c83fe8e0b3ca9298d5d75d6b943dc28153","date":1308670974,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/test/org/apache/lucene/util/TestStringIntern#testStringIntern().mjava","sourceNew":null,"sourceOld":"  public void testStringIntern() throws InterruptedException {\n    makeStrings(1024*10);  // something greater than the capacity of the default cache size\n    // makeStrings(100);  // realistic for perf testing\n    int nThreads = 20;\n    // final int iter=100000;\n    final int iter = atLeast(100000);\n    \n    // try native intern\n    // StringHelper.interner = new StringInterner();\n\n    Thread[] threads = new Thread[nThreads];\n    for (int i=0; i<nThreads; i++) {\n      final int seed = i;\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          Random rand = new Random(seed);\n          String[] myInterned = new String[testStrings.length];\n          for (int j=0; j<iter; j++) {\n            int idx = rand.nextInt(testStrings.length);\n            String s = testStrings[idx];\n            if (rand.nextBoolean()) s = new String(s); // make a copy half of the time\n            String interned = StringHelper.intern(s);\n            String prevInterned = myInterned[idx];\n            String otherInterned = internedStrings[idx];\n\n            // test against other threads\n            if (otherInterned != null && otherInterned != interned) {\n              fail();\n            }\n            internedStrings[idx] = interned;\n\n            // test against local copy\n            if (prevInterned != null && prevInterned != interned) {\n              fail();\n            }\n            myInterned[idx] = interned;\n          }\n        }\n      };\n\n      threads[i].start();\n    }\n\n    for (int i=0; i<nThreads; i++) {\n      threads[i].join();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":4,"author":"Steven Rowe","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/test/org/apache/lucene/util/TestStringIntern#testStringIntern().mjava","sourceNew":null,"sourceOld":"  public void testStringIntern() throws InterruptedException {\n    makeStrings(1024*10);  // something greater than the capacity of the default cache size\n    // makeStrings(100);  // realistic for perf testing\n    int nThreads = 20;\n    // final int iter=100000;\n    final int iter = atLeast(100000);\n    \n    // try native intern\n    // StringHelper.interner = new StringInterner();\n\n    Thread[] threads = new Thread[nThreads];\n    for (int i=0; i<nThreads; i++) {\n      final int seed = i;\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          Random rand = new Random(seed);\n          String[] myInterned = new String[testStrings.length];\n          for (int j=0; j<iter; j++) {\n            int idx = rand.nextInt(testStrings.length);\n            String s = testStrings[idx];\n            if (rand.nextBoolean()) s = new String(s); // make a copy half of the time\n            String interned = StringHelper.intern(s);\n            String prevInterned = myInterned[idx];\n            String otherInterned = internedStrings[idx];\n\n            // test against other threads\n            if (otherInterned != null && otherInterned != interned) {\n              fail();\n            }\n            internedStrings[idx] = interned;\n\n            // test against local copy\n            if (prevInterned != null && prevInterned != interned) {\n              fail();\n            }\n            myInterned[idx] = interned;\n          }\n        }\n      };\n\n      threads[i].start();\n    }\n\n    for (int i=0; i<nThreads; i++) {\n      threads[i].join();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":4,"author":"Simon Willnauer","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/test/org/apache/lucene/util/TestStringIntern#testStringIntern().mjava","sourceNew":null,"sourceOld":"  public void testStringIntern() throws InterruptedException {\n    makeStrings(1024*10);  // something greater than the capacity of the default cache size\n    // makeStrings(100);  // realistic for perf testing\n    int nThreads = 20;\n    // final int iter=100000;\n    final int iter = atLeast(100000);\n    \n    // try native intern\n    // StringHelper.interner = new StringInterner();\n\n    Thread[] threads = new Thread[nThreads];\n    for (int i=0; i<nThreads; i++) {\n      final int seed = i;\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          Random rand = new Random(seed);\n          String[] myInterned = new String[testStrings.length];\n          for (int j=0; j<iter; j++) {\n            int idx = rand.nextInt(testStrings.length);\n            String s = testStrings[idx];\n            if (rand.nextBoolean()) s = new String(s); // make a copy half of the time\n            String interned = StringHelper.intern(s);\n            String prevInterned = myInterned[idx];\n            String otherInterned = internedStrings[idx];\n\n            // test against other threads\n            if (otherInterned != null && otherInterned != interned) {\n              fail();\n            }\n            internedStrings[idx] = interned;\n\n            // test against local copy\n            if (prevInterned != null && prevInterned != interned) {\n              fail();\n            }\n            myInterned[idx] = interned;\n          }\n        }\n      };\n\n      threads[i].start();\n    }\n\n    for (int i=0; i<nThreads; i++) {\n      threads[i].join();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e45742e10e8e3b98e854babe6dbb07a4197b71":["2aafd88401639311b0404e67c94e829e123a0e45"],"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["a0e45742e10e8e3b98e854babe6dbb07a4197b71","0762b640e0d0d12b6edb96db68986e13145c3484"],"3242a09f703274d3b9283f2064a1a33064b53a1b":["2aafd88401639311b0404e67c94e829e123a0e45","a0e45742e10e8e3b98e854babe6dbb07a4197b71"],"0762b640e0d0d12b6edb96db68986e13145c3484":["a0e45742e10e8e3b98e854babe6dbb07a4197b71"],"fafef7c83fe8e0b3ca9298d5d75d6b943dc28153":["0762b640e0d0d12b6edb96db68986e13145c3484"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"77cf4379b2824f6ea34b091c495d6e95c38ff9e2":["a0e45742e10e8e3b98e854babe6dbb07a4197b71","0762b640e0d0d12b6edb96db68986e13145c3484"],"2aafd88401639311b0404e67c94e829e123a0e45":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"2553b00f699380c64959ccb27991289aae87be2e":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","fafef7c83fe8e0b3ca9298d5d75d6b943dc28153"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["0762b640e0d0d12b6edb96db68986e13145c3484","fafef7c83fe8e0b3ca9298d5d75d6b943dc28153"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fafef7c83fe8e0b3ca9298d5d75d6b943dc28153"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e45742e10e8e3b98e854babe6dbb07a4197b71":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","3242a09f703274d3b9283f2064a1a33064b53a1b","0762b640e0d0d12b6edb96db68986e13145c3484","77cf4379b2824f6ea34b091c495d6e95c38ff9e2"],"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["2553b00f699380c64959ccb27991289aae87be2e"],"3242a09f703274d3b9283f2064a1a33064b53a1b":[],"0762b640e0d0d12b6edb96db68986e13145c3484":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","fafef7c83fe8e0b3ca9298d5d75d6b943dc28153","77cf4379b2824f6ea34b091c495d6e95c38ff9e2","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"fafef7c83fe8e0b3ca9298d5d75d6b943dc28153":["2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"77cf4379b2824f6ea34b091c495d6e95c38ff9e2":[],"2aafd88401639311b0404e67c94e829e123a0e45":["a0e45742e10e8e3b98e854babe6dbb07a4197b71","3242a09f703274d3b9283f2064a1a33064b53a1b"],"2553b00f699380c64959ccb27991289aae87be2e":[],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["2aafd88401639311b0404e67c94e829e123a0e45"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3242a09f703274d3b9283f2064a1a33064b53a1b","77cf4379b2824f6ea34b091c495d6e95c38ff9e2","2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}