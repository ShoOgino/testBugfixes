{"path":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#launchIndexingThreads(LineFileDocs,int,long,Set[String],Set[String],List[SubDocs]).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#launchIndexingThreads(LineFileDocs,int,long,Set[String],Set[String],List[SubDocs]).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#launchIndexingThreads(LineFileDocs,int,long,Set[String],Set[String],List[SubDocs]).mjava","sourceNew":"  private Thread[] launchIndexingThreads(final LineFileDocs docs,\n                                         int numThreads,\n                                         final long stopTime,\n                                         final Set<String> delIDs,\n                                         final Set<String> delPackIDs,\n                                         final List<SubDocs> allSubDocs)\n    throws Exception {\n    final Thread[] threads = new Thread[numThreads];\n    for(int thread=0;thread<numThreads;thread++) {\n      threads[thread] = new Thread() {\n          @Override\n          public void run() {\n            // TODO: would be better if this were cross thread, so that we make sure one thread deleting anothers added docs works:\n            final List<String> toDeleteIDs = new ArrayList<String>();\n            final List<SubDocs> toDeleteSubDocs = new ArrayList<SubDocs>();\n            while(System.currentTimeMillis() < stopTime && !failed.get()) {\n              try {\n\n                // Occasional longish pause if running\n                // nightly\n                if (LuceneTestCase.TEST_NIGHTLY && random.nextInt(6) == 3) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": now long sleep\");\n                  }\n                  Thread.sleep(_TestUtil.nextInt(random, 50, 500));\n                }\n\n                // Rate limit ingest rate:\n                if (random.nextInt(7) == 5) {\n                  Thread.sleep(_TestUtil.nextInt(random, 1, 10));\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": done sleep\");\n                  }\n                }\n\n                Document doc = docs.nextDoc();\n                if (doc == null) {\n                  break;\n                }\n\n                // Maybe add randomly named field\n                final String addedField;\n                if (random.nextBoolean()) {\n                  addedField = \"extra\" + random.nextInt(40);\n                  doc.add(newField(addedField, \"a random field\", TextField.TYPE_STORED));\n                } else {\n                  addedField = null;\n                }\n\n                if (random.nextBoolean()) {\n\n                  if (random.nextBoolean()) {\n                    // Add/update doc block:\n                    final String packID;\n                    final SubDocs delSubDocs;\n                    if (toDeleteSubDocs.size() > 0 && random.nextBoolean()) {\n                      delSubDocs = toDeleteSubDocs.get(random.nextInt(toDeleteSubDocs.size()));\n                      assert !delSubDocs.deleted;\n                      toDeleteSubDocs.remove(delSubDocs);\n                      // Update doc block, replacing prior packID\n                      packID = delSubDocs.packID;\n                    } else {\n                      delSubDocs = null;\n                      // Add doc block, using new packID\n                      packID = packCount.getAndIncrement() + \"\";\n                    }\n\n                    final Field packIDField = newField(\"packID\", packID, StringField.TYPE_STORED);\n                    final List<String> docIDs = new ArrayList<String>();\n                    final SubDocs subDocs = new SubDocs(packID, docIDs);\n                    final List<Document> docsList = new ArrayList<Document>();\n\n                    allSubDocs.add(subDocs);\n                    doc.add(packIDField);\n                    docsList.add(_TestUtil.cloneDocument(doc));\n                    docIDs.add(doc.get(\"docid\"));\n\n                    final int maxDocCount = _TestUtil.nextInt(random, 1, 10);\n                    while(docsList.size() < maxDocCount) {\n                      doc = docs.nextDoc();\n                      if (doc == null) {\n                        break;\n                      }\n                      docsList.add(_TestUtil.cloneDocument(doc));\n                      docIDs.add(doc.get(\"docid\"));\n                    }\n                    addCount.addAndGet(docsList.size());\n\n                    final Term packIDTerm = new Term(\"packID\", packID);\n\n                    if (delSubDocs != null) {\n                      delSubDocs.deleted = true;\n                      delIDs.addAll(delSubDocs.subIDs);\n                      delCount.addAndGet(delSubDocs.subIDs.size());\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": update pack packID=\" + delSubDocs.packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      updateDocuments(packIDTerm, docsList);\n                    } else {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": add pack packID=\" + packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      addDocuments(packIDTerm, docsList);\n                    }\n                    doc.removeField(\"packID\");\n\n                    if (random.nextInt(5) == 2) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + packID);\n                      }\n                      toDeleteSubDocs.add(subDocs);\n                    }\n\n                  } else {\n                    // Add single doc\n                    final String docid = doc.get(\"docid\");\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": add doc docid:\" + docid);\n                    }\n                    addDocument(new Term(\"docid\", docid), doc);\n                    addCount.getAndIncrement();\n\n                    if (random.nextInt(5) == 3) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                      }\n                      toDeleteIDs.add(docid);\n                    }\n                  }\n                } else {\n\n                  // Update single doc, but we never re-use\n                  // and ID so the delete will never\n                  // actually happen:\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": update doc id:\" + doc.get(\"docid\"));\n                  }\n                  final String docid = doc.get(\"docid\");\n                  updateDocument(new Term(\"docid\", docid), doc);\n                  addCount.getAndIncrement();\n\n                  if (random.nextInt(5) == 3) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                    }\n                    toDeleteIDs.add(docid);\n                  }\n                }\n\n                if (random.nextInt(30) == 17) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": apply \" + toDeleteIDs.size() + \" deletes\");\n                  }\n                  for(String id : toDeleteIDs) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del term=id:\" + id);\n                    }\n                    deleteDocuments(new Term(\"docid\", id));\n                  }\n                  final int count = delCount.addAndGet(toDeleteIDs.size());\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": tot \" + count + \" deletes\");\n                  }\n                  delIDs.addAll(toDeleteIDs);\n                  toDeleteIDs.clear();\n\n                  for(SubDocs subDocs : toDeleteSubDocs) {\n                    assert !subDocs.deleted;\n                    delPackIDs.add(subDocs.packID);\n                    deleteDocuments(new Term(\"packID\", subDocs.packID));\n                    subDocs.deleted = true;\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del subs: \" + subDocs.subIDs + \" packID=\" + subDocs.packID);\n                    }\n                    delIDs.addAll(subDocs.subIDs);\n                    delCount.addAndGet(subDocs.subIDs.size());\n                  }\n                  toDeleteSubDocs.clear();\n                }\n                if (addedField != null) {\n                  doc.removeField(addedField);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                t.printStackTrace();\n                failed.set(true);\n                throw new RuntimeException(t);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": indexing done\");\n            }\n\n            doAfterIndexingThreadDone();\n          }\n        };\n      threads[thread].setDaemon(true);\n      threads[thread].start();\n    }\n\n    return threads;\n  }\n\n","sourceOld":"  private Thread[] launchIndexingThreads(final LineFileDocs docs,\n                                         int numThreads,\n                                         final long stopTime,\n                                         final Set<String> delIDs,\n                                         final Set<String> delPackIDs,\n                                         final List<SubDocs> allSubDocs)\n    throws Exception {\n    final Thread[] threads = new Thread[numThreads];\n    for(int thread=0;thread<numThreads;thread++) {\n      threads[thread] = new Thread() {\n          @Override\n          public void run() {\n            // TODO: would be better if this were cross thread, so that we make sure one thread deleting anothers added docs works:\n            final List<String> toDeleteIDs = new ArrayList<String>();\n            final List<SubDocs> toDeleteSubDocs = new ArrayList<SubDocs>();\n            while(System.currentTimeMillis() < stopTime && !failed.get()) {\n              try {\n\n                // Occasional longish pause if running\n                // nightly\n                if (LuceneTestCase.TEST_NIGHTLY && random.nextInt(6) == 3) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": now long sleep\");\n                  }\n                  Thread.sleep(_TestUtil.nextInt(random, 50, 500));\n                }\n\n                // Rate limit ingest rate:\n                if (random.nextInt(7) == 5) {\n                  Thread.sleep(_TestUtil.nextInt(random, 1, 10));\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": done sleep\");\n                  }\n                }\n\n                Document doc = docs.nextDoc();\n                if (doc == null) {\n                  break;\n                }\n\n                // Maybe add randomly named field\n                final String addedField;\n                if (random.nextBoolean()) {\n                  addedField = \"extra\" + random.nextInt(40);\n                  doc.add(newField(addedField, \"a random field\", TextField.TYPE_STORED));\n                } else {\n                  addedField = null;\n                }\n\n                if (random.nextBoolean()) {\n\n                  if (random.nextBoolean()) {\n                    // Add/update doc block:\n                    final String packID;\n                    final SubDocs delSubDocs;\n                    if (toDeleteSubDocs.size() > 0 && random.nextBoolean()) {\n                      delSubDocs = toDeleteSubDocs.get(random.nextInt(toDeleteSubDocs.size()));\n                      assert !delSubDocs.deleted;\n                      toDeleteSubDocs.remove(delSubDocs);\n                      // Update doc block, replacing prior packID\n                      packID = delSubDocs.packID;\n                    } else {\n                      delSubDocs = null;\n                      // Add doc block, using new packID\n                      packID = packCount.getAndIncrement() + \"\";\n                    }\n\n                    final Field packIDField = newField(\"packID\", packID, StringField.TYPE_STORED);\n                    final List<String> docIDs = new ArrayList<String>();\n                    final SubDocs subDocs = new SubDocs(packID, docIDs);\n                    final List<Document> docsList = new ArrayList<Document>();\n\n                    allSubDocs.add(subDocs);\n                    doc.add(packIDField);\n                    docsList.add(_TestUtil.cloneDocument(doc));\n                    docIDs.add(doc.get(\"docid\"));\n\n                    final int maxDocCount = _TestUtil.nextInt(random, 1, 10);\n                    while(docsList.size() < maxDocCount) {\n                      doc = docs.nextDoc();\n                      if (doc == null) {\n                        break;\n                      }\n                      docsList.add(_TestUtil.cloneDocument(doc));\n                      docIDs.add(doc.get(\"docid\"));\n                    }\n                    addCount.addAndGet(docsList.size());\n\n                    final Term packIDTerm = new Term(\"packID\", packID);\n\n                    if (delSubDocs != null) {\n                      delSubDocs.deleted = true;\n                      delIDs.addAll(delSubDocs.subIDs);\n                      delCount.addAndGet(delSubDocs.subIDs.size());\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": update pack packID=\" + delSubDocs.packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      updateDocuments(packIDTerm, docsList);\n                    } else {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": add pack packID=\" + packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      addDocuments(packIDTerm, docsList);\n                    }\n                    doc.removeField(\"packID\");\n\n                    if (random.nextInt(5) == 2) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + packID);\n                      }\n                      toDeleteSubDocs.add(subDocs);\n                    }\n\n                  } else {\n                    // Add single doc\n                    final String docid = doc.get(\"docid\");\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": add doc docid:\" + docid);\n                    }\n                    addDocument(new Term(\"docid\", docid), doc);\n                    addCount.getAndIncrement();\n\n                    if (random.nextInt(5) == 3) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                      }\n                      toDeleteIDs.add(docid);\n                    }\n                  }\n                } else {\n\n                  // Update single doc, but we never re-use\n                  // and ID so the delete will never\n                  // actually happen:\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": update doc id:\" + doc.get(\"docid\"));\n                  }\n                  final String docid = doc.get(\"docid\");\n                  updateDocument(new Term(\"docid\", docid), doc);\n                  addCount.getAndIncrement();\n\n                  if (random.nextInt(5) == 3) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                    }\n                    toDeleteIDs.add(docid);\n                  }\n                }\n\n                if (random.nextInt(30) == 17) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": apply \" + toDeleteIDs.size() + \" deletes\");\n                  }\n                  for(String id : toDeleteIDs) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del term=id:\" + id);\n                    }\n                    deleteDocuments(new Term(\"docid\", id));\n                  }\n                  final int count = delCount.addAndGet(toDeleteIDs.size());\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": tot \" + count + \" deletes\");\n                  }\n                  delIDs.addAll(toDeleteIDs);\n                  toDeleteIDs.clear();\n\n                  for(SubDocs subDocs : toDeleteSubDocs) {\n                    assert !subDocs.deleted;\n                    delPackIDs.add(subDocs.packID);\n                    deleteDocuments(new Term(\"packID\", subDocs.packID));\n                    subDocs.deleted = true;\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del subs: \" + subDocs.subIDs + \" packID=\" + subDocs.packID);\n                    }\n                    delIDs.addAll(subDocs.subIDs);\n                    delCount.addAndGet(subDocs.subIDs.size());\n                  }\n                  toDeleteSubDocs.clear();\n                }\n                if (addedField != null) {\n                  doc.removeField(addedField);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                t.printStackTrace();\n                failed.set(true);\n                throw new RuntimeException(t);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": indexing done\");\n            }\n\n            doAfterIndexingThreadDone();\n          }\n        };\n      threads[thread].setDaemon(true);\n      threads[thread].start();\n    }\n\n    return threads;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#launchIndexingThreads(LineFileDocs,int,long,Set[String],Set[String],List[SubDocs]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#launchIndexingThreads(LineFileDocs,int,long,Set[String],Set[String],List[SubDocs]).mjava","sourceNew":"  private Thread[] launchIndexingThreads(final LineFileDocs docs,\n                                         int numThreads,\n                                         final long stopTime,\n                                         final Set<String> delIDs,\n                                         final Set<String> delPackIDs,\n                                         final List<SubDocs> allSubDocs)\n    throws Exception {\n    final Thread[] threads = new Thread[numThreads];\n    for(int thread=0;thread<numThreads;thread++) {\n      threads[thread] = new Thread() {\n          @Override\n          public void run() {\n            // TODO: would be better if this were cross thread, so that we make sure one thread deleting anothers added docs works:\n            final List<String> toDeleteIDs = new ArrayList<String>();\n            final List<SubDocs> toDeleteSubDocs = new ArrayList<SubDocs>();\n            while(System.currentTimeMillis() < stopTime && !failed.get()) {\n              try {\n\n                // Occasional longish pause if running\n                // nightly\n                if (LuceneTestCase.TEST_NIGHTLY && random().nextInt(6) == 3) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": now long sleep\");\n                  }\n                  Thread.sleep(_TestUtil.nextInt(random(), 50, 500));\n                }\n\n                // Rate limit ingest rate:\n                if (random().nextInt(7) == 5) {\n                  Thread.sleep(_TestUtil.nextInt(random(), 1, 10));\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": done sleep\");\n                  }\n                }\n\n                Document doc = docs.nextDoc();\n                if (doc == null) {\n                  break;\n                }\n\n                // Maybe add randomly named field\n                final String addedField;\n                if (random().nextBoolean()) {\n                  addedField = \"extra\" + random().nextInt(40);\n                  doc.add(newField(addedField, \"a random field\", TextField.TYPE_STORED));\n                } else {\n                  addedField = null;\n                }\n\n                if (random().nextBoolean()) {\n\n                  if (random().nextBoolean()) {\n                    // Add/update doc block:\n                    final String packID;\n                    final SubDocs delSubDocs;\n                    if (toDeleteSubDocs.size() > 0 && random().nextBoolean()) {\n                      delSubDocs = toDeleteSubDocs.get(random().nextInt(toDeleteSubDocs.size()));\n                      assert !delSubDocs.deleted;\n                      toDeleteSubDocs.remove(delSubDocs);\n                      // Update doc block, replacing prior packID\n                      packID = delSubDocs.packID;\n                    } else {\n                      delSubDocs = null;\n                      // Add doc block, using new packID\n                      packID = packCount.getAndIncrement() + \"\";\n                    }\n\n                    final Field packIDField = newField(\"packID\", packID, StringField.TYPE_STORED);\n                    final List<String> docIDs = new ArrayList<String>();\n                    final SubDocs subDocs = new SubDocs(packID, docIDs);\n                    final List<Document> docsList = new ArrayList<Document>();\n\n                    allSubDocs.add(subDocs);\n                    doc.add(packIDField);\n                    docsList.add(_TestUtil.cloneDocument(doc));\n                    docIDs.add(doc.get(\"docid\"));\n\n                    final int maxDocCount = _TestUtil.nextInt(random(), 1, 10);\n                    while(docsList.size() < maxDocCount) {\n                      doc = docs.nextDoc();\n                      if (doc == null) {\n                        break;\n                      }\n                      docsList.add(_TestUtil.cloneDocument(doc));\n                      docIDs.add(doc.get(\"docid\"));\n                    }\n                    addCount.addAndGet(docsList.size());\n\n                    final Term packIDTerm = new Term(\"packID\", packID);\n\n                    if (delSubDocs != null) {\n                      delSubDocs.deleted = true;\n                      delIDs.addAll(delSubDocs.subIDs);\n                      delCount.addAndGet(delSubDocs.subIDs.size());\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": update pack packID=\" + delSubDocs.packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      updateDocuments(packIDTerm, docsList);\n                    } else {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": add pack packID=\" + packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      addDocuments(packIDTerm, docsList);\n                    }\n                    doc.removeField(\"packID\");\n\n                    if (random().nextInt(5) == 2) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + packID);\n                      }\n                      toDeleteSubDocs.add(subDocs);\n                    }\n\n                  } else {\n                    // Add single doc\n                    final String docid = doc.get(\"docid\");\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": add doc docid:\" + docid);\n                    }\n                    addDocument(new Term(\"docid\", docid), doc);\n                    addCount.getAndIncrement();\n\n                    if (random().nextInt(5) == 3) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                      }\n                      toDeleteIDs.add(docid);\n                    }\n                  }\n                } else {\n\n                  // Update single doc, but we never re-use\n                  // and ID so the delete will never\n                  // actually happen:\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": update doc id:\" + doc.get(\"docid\"));\n                  }\n                  final String docid = doc.get(\"docid\");\n                  updateDocument(new Term(\"docid\", docid), doc);\n                  addCount.getAndIncrement();\n\n                  if (random().nextInt(5) == 3) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                    }\n                    toDeleteIDs.add(docid);\n                  }\n                }\n\n                if (random().nextInt(30) == 17) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": apply \" + toDeleteIDs.size() + \" deletes\");\n                  }\n                  for(String id : toDeleteIDs) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del term=id:\" + id);\n                    }\n                    deleteDocuments(new Term(\"docid\", id));\n                  }\n                  final int count = delCount.addAndGet(toDeleteIDs.size());\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": tot \" + count + \" deletes\");\n                  }\n                  delIDs.addAll(toDeleteIDs);\n                  toDeleteIDs.clear();\n\n                  for(SubDocs subDocs : toDeleteSubDocs) {\n                    assert !subDocs.deleted;\n                    delPackIDs.add(subDocs.packID);\n                    deleteDocuments(new Term(\"packID\", subDocs.packID));\n                    subDocs.deleted = true;\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del subs: \" + subDocs.subIDs + \" packID=\" + subDocs.packID);\n                    }\n                    delIDs.addAll(subDocs.subIDs);\n                    delCount.addAndGet(subDocs.subIDs.size());\n                  }\n                  toDeleteSubDocs.clear();\n                }\n                if (addedField != null) {\n                  doc.removeField(addedField);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                t.printStackTrace();\n                failed.set(true);\n                throw new RuntimeException(t);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": indexing done\");\n            }\n\n            doAfterIndexingThreadDone();\n          }\n        };\n      threads[thread].setDaemon(true);\n      threads[thread].start();\n    }\n\n    return threads;\n  }\n\n","sourceOld":"  private Thread[] launchIndexingThreads(final LineFileDocs docs,\n                                         int numThreads,\n                                         final long stopTime,\n                                         final Set<String> delIDs,\n                                         final Set<String> delPackIDs,\n                                         final List<SubDocs> allSubDocs)\n    throws Exception {\n    final Thread[] threads = new Thread[numThreads];\n    for(int thread=0;thread<numThreads;thread++) {\n      threads[thread] = new Thread() {\n          @Override\n          public void run() {\n            // TODO: would be better if this were cross thread, so that we make sure one thread deleting anothers added docs works:\n            final List<String> toDeleteIDs = new ArrayList<String>();\n            final List<SubDocs> toDeleteSubDocs = new ArrayList<SubDocs>();\n            while(System.currentTimeMillis() < stopTime && !failed.get()) {\n              try {\n\n                // Occasional longish pause if running\n                // nightly\n                if (LuceneTestCase.TEST_NIGHTLY && random.nextInt(6) == 3) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": now long sleep\");\n                  }\n                  Thread.sleep(_TestUtil.nextInt(random, 50, 500));\n                }\n\n                // Rate limit ingest rate:\n                if (random.nextInt(7) == 5) {\n                  Thread.sleep(_TestUtil.nextInt(random, 1, 10));\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": done sleep\");\n                  }\n                }\n\n                Document doc = docs.nextDoc();\n                if (doc == null) {\n                  break;\n                }\n\n                // Maybe add randomly named field\n                final String addedField;\n                if (random.nextBoolean()) {\n                  addedField = \"extra\" + random.nextInt(40);\n                  doc.add(newField(addedField, \"a random field\", TextField.TYPE_STORED));\n                } else {\n                  addedField = null;\n                }\n\n                if (random.nextBoolean()) {\n\n                  if (random.nextBoolean()) {\n                    // Add/update doc block:\n                    final String packID;\n                    final SubDocs delSubDocs;\n                    if (toDeleteSubDocs.size() > 0 && random.nextBoolean()) {\n                      delSubDocs = toDeleteSubDocs.get(random.nextInt(toDeleteSubDocs.size()));\n                      assert !delSubDocs.deleted;\n                      toDeleteSubDocs.remove(delSubDocs);\n                      // Update doc block, replacing prior packID\n                      packID = delSubDocs.packID;\n                    } else {\n                      delSubDocs = null;\n                      // Add doc block, using new packID\n                      packID = packCount.getAndIncrement() + \"\";\n                    }\n\n                    final Field packIDField = newField(\"packID\", packID, StringField.TYPE_STORED);\n                    final List<String> docIDs = new ArrayList<String>();\n                    final SubDocs subDocs = new SubDocs(packID, docIDs);\n                    final List<Document> docsList = new ArrayList<Document>();\n\n                    allSubDocs.add(subDocs);\n                    doc.add(packIDField);\n                    docsList.add(_TestUtil.cloneDocument(doc));\n                    docIDs.add(doc.get(\"docid\"));\n\n                    final int maxDocCount = _TestUtil.nextInt(random, 1, 10);\n                    while(docsList.size() < maxDocCount) {\n                      doc = docs.nextDoc();\n                      if (doc == null) {\n                        break;\n                      }\n                      docsList.add(_TestUtil.cloneDocument(doc));\n                      docIDs.add(doc.get(\"docid\"));\n                    }\n                    addCount.addAndGet(docsList.size());\n\n                    final Term packIDTerm = new Term(\"packID\", packID);\n\n                    if (delSubDocs != null) {\n                      delSubDocs.deleted = true;\n                      delIDs.addAll(delSubDocs.subIDs);\n                      delCount.addAndGet(delSubDocs.subIDs.size());\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": update pack packID=\" + delSubDocs.packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      updateDocuments(packIDTerm, docsList);\n                    } else {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": add pack packID=\" + packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      addDocuments(packIDTerm, docsList);\n                    }\n                    doc.removeField(\"packID\");\n\n                    if (random.nextInt(5) == 2) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + packID);\n                      }\n                      toDeleteSubDocs.add(subDocs);\n                    }\n\n                  } else {\n                    // Add single doc\n                    final String docid = doc.get(\"docid\");\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": add doc docid:\" + docid);\n                    }\n                    addDocument(new Term(\"docid\", docid), doc);\n                    addCount.getAndIncrement();\n\n                    if (random.nextInt(5) == 3) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                      }\n                      toDeleteIDs.add(docid);\n                    }\n                  }\n                } else {\n\n                  // Update single doc, but we never re-use\n                  // and ID so the delete will never\n                  // actually happen:\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": update doc id:\" + doc.get(\"docid\"));\n                  }\n                  final String docid = doc.get(\"docid\");\n                  updateDocument(new Term(\"docid\", docid), doc);\n                  addCount.getAndIncrement();\n\n                  if (random.nextInt(5) == 3) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                    }\n                    toDeleteIDs.add(docid);\n                  }\n                }\n\n                if (random.nextInt(30) == 17) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": apply \" + toDeleteIDs.size() + \" deletes\");\n                  }\n                  for(String id : toDeleteIDs) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del term=id:\" + id);\n                    }\n                    deleteDocuments(new Term(\"docid\", id));\n                  }\n                  final int count = delCount.addAndGet(toDeleteIDs.size());\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": tot \" + count + \" deletes\");\n                  }\n                  delIDs.addAll(toDeleteIDs);\n                  toDeleteIDs.clear();\n\n                  for(SubDocs subDocs : toDeleteSubDocs) {\n                    assert !subDocs.deleted;\n                    delPackIDs.add(subDocs.packID);\n                    deleteDocuments(new Term(\"packID\", subDocs.packID));\n                    subDocs.deleted = true;\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del subs: \" + subDocs.subIDs + \" packID=\" + subDocs.packID);\n                    }\n                    delIDs.addAll(subDocs.subIDs);\n                    delCount.addAndGet(subDocs.subIDs.size());\n                  }\n                  toDeleteSubDocs.clear();\n                }\n                if (addedField != null) {\n                  doc.removeField(addedField);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                t.printStackTrace();\n                failed.set(true);\n                throw new RuntimeException(t);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": indexing done\");\n            }\n\n            doAfterIndexingThreadDone();\n          }\n        };\n      threads[thread].setDaemon(true);\n      threads[thread].start();\n    }\n\n    return threads;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"04f07771a2a7dd3a395700665ed839c3dae2def2","date":1339350139,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#launchIndexingThreads(LineFileDocs,int,long,Set[String],Set[String],List[SubDocs]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#launchIndexingThreads(LineFileDocs,int,long,Set[String],Set[String],List[SubDocs]).mjava","sourceNew":"  private Thread[] launchIndexingThreads(final LineFileDocs docs,\n                                         int numThreads,\n                                         final long stopTime,\n                                         final Set<String> delIDs,\n                                         final Set<String> delPackIDs,\n                                         final List<SubDocs> allSubDocs)\n    throws Exception {\n    final Thread[] threads = new Thread[numThreads];\n    for(int thread=0;thread<numThreads;thread++) {\n      threads[thread] = new Thread() {\n          @Override\n          public void run() {\n            // TODO: would be better if this were cross thread, so that we make sure one thread deleting anothers added docs works:\n            final List<String> toDeleteIDs = new ArrayList<String>();\n            final List<SubDocs> toDeleteSubDocs = new ArrayList<SubDocs>();\n            while(System.currentTimeMillis() < stopTime && !failed.get()) {\n              try {\n\n                // Occasional longish pause if running\n                // nightly\n                if (LuceneTestCase.TEST_NIGHTLY && random().nextInt(6) == 3) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": now long sleep\");\n                  }\n                  Thread.sleep(_TestUtil.nextInt(random(), 50, 500));\n                }\n\n                // Rate limit ingest rate:\n                if (random().nextInt(7) == 5) {\n                  Thread.sleep(_TestUtil.nextInt(random(), 1, 10));\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": done sleep\");\n                  }\n                }\n\n                Document doc = docs.nextDoc();\n                if (doc == null) {\n                  break;\n                }\n\n                // Maybe add randomly named field\n                final String addedField;\n                if (random().nextBoolean()) {\n                  addedField = \"extra\" + random().nextInt(40);\n                  doc.add(newTextField(addedField, \"a random field\", Field.Store.YES));\n                } else {\n                  addedField = null;\n                }\n\n                if (random().nextBoolean()) {\n\n                  if (random().nextBoolean()) {\n                    // Add/update doc block:\n                    final String packID;\n                    final SubDocs delSubDocs;\n                    if (toDeleteSubDocs.size() > 0 && random().nextBoolean()) {\n                      delSubDocs = toDeleteSubDocs.get(random().nextInt(toDeleteSubDocs.size()));\n                      assert !delSubDocs.deleted;\n                      toDeleteSubDocs.remove(delSubDocs);\n                      // Update doc block, replacing prior packID\n                      packID = delSubDocs.packID;\n                    } else {\n                      delSubDocs = null;\n                      // Add doc block, using new packID\n                      packID = packCount.getAndIncrement() + \"\";\n                    }\n\n                    final Field packIDField = newStringField(\"packID\", packID, Field.Store.YES);\n                    final List<String> docIDs = new ArrayList<String>();\n                    final SubDocs subDocs = new SubDocs(packID, docIDs);\n                    final List<Document> docsList = new ArrayList<Document>();\n\n                    allSubDocs.add(subDocs);\n                    doc.add(packIDField);\n                    docsList.add(_TestUtil.cloneDocument(doc));\n                    docIDs.add(doc.get(\"docid\"));\n\n                    final int maxDocCount = _TestUtil.nextInt(random(), 1, 10);\n                    while(docsList.size() < maxDocCount) {\n                      doc = docs.nextDoc();\n                      if (doc == null) {\n                        break;\n                      }\n                      docsList.add(_TestUtil.cloneDocument(doc));\n                      docIDs.add(doc.get(\"docid\"));\n                    }\n                    addCount.addAndGet(docsList.size());\n\n                    final Term packIDTerm = new Term(\"packID\", packID);\n\n                    if (delSubDocs != null) {\n                      delSubDocs.deleted = true;\n                      delIDs.addAll(delSubDocs.subIDs);\n                      delCount.addAndGet(delSubDocs.subIDs.size());\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": update pack packID=\" + delSubDocs.packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      updateDocuments(packIDTerm, docsList);\n                    } else {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": add pack packID=\" + packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      addDocuments(packIDTerm, docsList);\n                    }\n                    doc.removeField(\"packID\");\n\n                    if (random().nextInt(5) == 2) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + packID);\n                      }\n                      toDeleteSubDocs.add(subDocs);\n                    }\n\n                  } else {\n                    // Add single doc\n                    final String docid = doc.get(\"docid\");\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": add doc docid:\" + docid);\n                    }\n                    addDocument(new Term(\"docid\", docid), doc);\n                    addCount.getAndIncrement();\n\n                    if (random().nextInt(5) == 3) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                      }\n                      toDeleteIDs.add(docid);\n                    }\n                  }\n                } else {\n\n                  // Update single doc, but we never re-use\n                  // and ID so the delete will never\n                  // actually happen:\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": update doc id:\" + doc.get(\"docid\"));\n                  }\n                  final String docid = doc.get(\"docid\");\n                  updateDocument(new Term(\"docid\", docid), doc);\n                  addCount.getAndIncrement();\n\n                  if (random().nextInt(5) == 3) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                    }\n                    toDeleteIDs.add(docid);\n                  }\n                }\n\n                if (random().nextInt(30) == 17) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": apply \" + toDeleteIDs.size() + \" deletes\");\n                  }\n                  for(String id : toDeleteIDs) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del term=id:\" + id);\n                    }\n                    deleteDocuments(new Term(\"docid\", id));\n                  }\n                  final int count = delCount.addAndGet(toDeleteIDs.size());\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": tot \" + count + \" deletes\");\n                  }\n                  delIDs.addAll(toDeleteIDs);\n                  toDeleteIDs.clear();\n\n                  for(SubDocs subDocs : toDeleteSubDocs) {\n                    assert !subDocs.deleted;\n                    delPackIDs.add(subDocs.packID);\n                    deleteDocuments(new Term(\"packID\", subDocs.packID));\n                    subDocs.deleted = true;\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del subs: \" + subDocs.subIDs + \" packID=\" + subDocs.packID);\n                    }\n                    delIDs.addAll(subDocs.subIDs);\n                    delCount.addAndGet(subDocs.subIDs.size());\n                  }\n                  toDeleteSubDocs.clear();\n                }\n                if (addedField != null) {\n                  doc.removeField(addedField);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                t.printStackTrace();\n                failed.set(true);\n                throw new RuntimeException(t);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": indexing done\");\n            }\n\n            doAfterIndexingThreadDone();\n          }\n        };\n      threads[thread].setDaemon(true);\n      threads[thread].start();\n    }\n\n    return threads;\n  }\n\n","sourceOld":"  private Thread[] launchIndexingThreads(final LineFileDocs docs,\n                                         int numThreads,\n                                         final long stopTime,\n                                         final Set<String> delIDs,\n                                         final Set<String> delPackIDs,\n                                         final List<SubDocs> allSubDocs)\n    throws Exception {\n    final Thread[] threads = new Thread[numThreads];\n    for(int thread=0;thread<numThreads;thread++) {\n      threads[thread] = new Thread() {\n          @Override\n          public void run() {\n            // TODO: would be better if this were cross thread, so that we make sure one thread deleting anothers added docs works:\n            final List<String> toDeleteIDs = new ArrayList<String>();\n            final List<SubDocs> toDeleteSubDocs = new ArrayList<SubDocs>();\n            while(System.currentTimeMillis() < stopTime && !failed.get()) {\n              try {\n\n                // Occasional longish pause if running\n                // nightly\n                if (LuceneTestCase.TEST_NIGHTLY && random().nextInt(6) == 3) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": now long sleep\");\n                  }\n                  Thread.sleep(_TestUtil.nextInt(random(), 50, 500));\n                }\n\n                // Rate limit ingest rate:\n                if (random().nextInt(7) == 5) {\n                  Thread.sleep(_TestUtil.nextInt(random(), 1, 10));\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": done sleep\");\n                  }\n                }\n\n                Document doc = docs.nextDoc();\n                if (doc == null) {\n                  break;\n                }\n\n                // Maybe add randomly named field\n                final String addedField;\n                if (random().nextBoolean()) {\n                  addedField = \"extra\" + random().nextInt(40);\n                  doc.add(newField(addedField, \"a random field\", TextField.TYPE_STORED));\n                } else {\n                  addedField = null;\n                }\n\n                if (random().nextBoolean()) {\n\n                  if (random().nextBoolean()) {\n                    // Add/update doc block:\n                    final String packID;\n                    final SubDocs delSubDocs;\n                    if (toDeleteSubDocs.size() > 0 && random().nextBoolean()) {\n                      delSubDocs = toDeleteSubDocs.get(random().nextInt(toDeleteSubDocs.size()));\n                      assert !delSubDocs.deleted;\n                      toDeleteSubDocs.remove(delSubDocs);\n                      // Update doc block, replacing prior packID\n                      packID = delSubDocs.packID;\n                    } else {\n                      delSubDocs = null;\n                      // Add doc block, using new packID\n                      packID = packCount.getAndIncrement() + \"\";\n                    }\n\n                    final Field packIDField = newField(\"packID\", packID, StringField.TYPE_STORED);\n                    final List<String> docIDs = new ArrayList<String>();\n                    final SubDocs subDocs = new SubDocs(packID, docIDs);\n                    final List<Document> docsList = new ArrayList<Document>();\n\n                    allSubDocs.add(subDocs);\n                    doc.add(packIDField);\n                    docsList.add(_TestUtil.cloneDocument(doc));\n                    docIDs.add(doc.get(\"docid\"));\n\n                    final int maxDocCount = _TestUtil.nextInt(random(), 1, 10);\n                    while(docsList.size() < maxDocCount) {\n                      doc = docs.nextDoc();\n                      if (doc == null) {\n                        break;\n                      }\n                      docsList.add(_TestUtil.cloneDocument(doc));\n                      docIDs.add(doc.get(\"docid\"));\n                    }\n                    addCount.addAndGet(docsList.size());\n\n                    final Term packIDTerm = new Term(\"packID\", packID);\n\n                    if (delSubDocs != null) {\n                      delSubDocs.deleted = true;\n                      delIDs.addAll(delSubDocs.subIDs);\n                      delCount.addAndGet(delSubDocs.subIDs.size());\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": update pack packID=\" + delSubDocs.packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      updateDocuments(packIDTerm, docsList);\n                    } else {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": add pack packID=\" + packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      addDocuments(packIDTerm, docsList);\n                    }\n                    doc.removeField(\"packID\");\n\n                    if (random().nextInt(5) == 2) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + packID);\n                      }\n                      toDeleteSubDocs.add(subDocs);\n                    }\n\n                  } else {\n                    // Add single doc\n                    final String docid = doc.get(\"docid\");\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": add doc docid:\" + docid);\n                    }\n                    addDocument(new Term(\"docid\", docid), doc);\n                    addCount.getAndIncrement();\n\n                    if (random().nextInt(5) == 3) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                      }\n                      toDeleteIDs.add(docid);\n                    }\n                  }\n                } else {\n\n                  // Update single doc, but we never re-use\n                  // and ID so the delete will never\n                  // actually happen:\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": update doc id:\" + doc.get(\"docid\"));\n                  }\n                  final String docid = doc.get(\"docid\");\n                  updateDocument(new Term(\"docid\", docid), doc);\n                  addCount.getAndIncrement();\n\n                  if (random().nextInt(5) == 3) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                    }\n                    toDeleteIDs.add(docid);\n                  }\n                }\n\n                if (random().nextInt(30) == 17) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": apply \" + toDeleteIDs.size() + \" deletes\");\n                  }\n                  for(String id : toDeleteIDs) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del term=id:\" + id);\n                    }\n                    deleteDocuments(new Term(\"docid\", id));\n                  }\n                  final int count = delCount.addAndGet(toDeleteIDs.size());\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": tot \" + count + \" deletes\");\n                  }\n                  delIDs.addAll(toDeleteIDs);\n                  toDeleteIDs.clear();\n\n                  for(SubDocs subDocs : toDeleteSubDocs) {\n                    assert !subDocs.deleted;\n                    delPackIDs.add(subDocs.packID);\n                    deleteDocuments(new Term(\"packID\", subDocs.packID));\n                    subDocs.deleted = true;\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del subs: \" + subDocs.subIDs + \" packID=\" + subDocs.packID);\n                    }\n                    delIDs.addAll(subDocs.subIDs);\n                    delCount.addAndGet(subDocs.subIDs.size());\n                  }\n                  toDeleteSubDocs.clear();\n                }\n                if (addedField != null) {\n                  doc.removeField(addedField);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                t.printStackTrace();\n                failed.set(true);\n                throw new RuntimeException(t);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": indexing done\");\n            }\n\n            doAfterIndexingThreadDone();\n          }\n        };\n      threads[thread].setDaemon(true);\n      threads[thread].start();\n    }\n\n    return threads;\n  }\n\n","bugFix":["edcc2c2cbab6bf89ea584169ffb3ca83a31827f9"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#launchIndexingThreads(LineFileDocs,int,long,Set[String],Set[String],List[SubDocs]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#launchIndexingThreads(LineFileDocs,int,long,Set[String],Set[String],List[SubDocs]).mjava","sourceNew":"  private Thread[] launchIndexingThreads(final LineFileDocs docs,\n                                         int numThreads,\n                                         final long stopTime,\n                                         final Set<String> delIDs,\n                                         final Set<String> delPackIDs,\n                                         final List<SubDocs> allSubDocs) {\n    final Thread[] threads = new Thread[numThreads];\n    for(int thread=0;thread<numThreads;thread++) {\n      threads[thread] = new Thread() {\n          @Override\n          public void run() {\n            // TODO: would be better if this were cross thread, so that we make sure one thread deleting anothers added docs works:\n            final List<String> toDeleteIDs = new ArrayList<String>();\n            final List<SubDocs> toDeleteSubDocs = new ArrayList<SubDocs>();\n            while(System.currentTimeMillis() < stopTime && !failed.get()) {\n              try {\n\n                // Occasional longish pause if running\n                // nightly\n                if (LuceneTestCase.TEST_NIGHTLY && random().nextInt(6) == 3) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": now long sleep\");\n                  }\n                  Thread.sleep(_TestUtil.nextInt(random(), 50, 500));\n                }\n\n                // Rate limit ingest rate:\n                if (random().nextInt(7) == 5) {\n                  Thread.sleep(_TestUtil.nextInt(random(), 1, 10));\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": done sleep\");\n                  }\n                }\n\n                Document doc = docs.nextDoc();\n                if (doc == null) {\n                  break;\n                }\n\n                // Maybe add randomly named field\n                final String addedField;\n                if (random().nextBoolean()) {\n                  addedField = \"extra\" + random().nextInt(40);\n                  doc.add(newTextField(addedField, \"a random field\", Field.Store.YES));\n                } else {\n                  addedField = null;\n                }\n\n                if (random().nextBoolean()) {\n\n                  if (random().nextBoolean()) {\n                    // Add/update doc block:\n                    final String packID;\n                    final SubDocs delSubDocs;\n                    if (toDeleteSubDocs.size() > 0 && random().nextBoolean()) {\n                      delSubDocs = toDeleteSubDocs.get(random().nextInt(toDeleteSubDocs.size()));\n                      assert !delSubDocs.deleted;\n                      toDeleteSubDocs.remove(delSubDocs);\n                      // Update doc block, replacing prior packID\n                      packID = delSubDocs.packID;\n                    } else {\n                      delSubDocs = null;\n                      // Add doc block, using new packID\n                      packID = packCount.getAndIncrement() + \"\";\n                    }\n\n                    final Field packIDField = newStringField(\"packID\", packID, Field.Store.YES);\n                    final List<String> docIDs = new ArrayList<String>();\n                    final SubDocs subDocs = new SubDocs(packID, docIDs);\n                    final List<Document> docsList = new ArrayList<Document>();\n\n                    allSubDocs.add(subDocs);\n                    doc.add(packIDField);\n                    docsList.add(_TestUtil.cloneDocument(doc));\n                    docIDs.add(doc.get(\"docid\"));\n\n                    final int maxDocCount = _TestUtil.nextInt(random(), 1, 10);\n                    while(docsList.size() < maxDocCount) {\n                      doc = docs.nextDoc();\n                      if (doc == null) {\n                        break;\n                      }\n                      docsList.add(_TestUtil.cloneDocument(doc));\n                      docIDs.add(doc.get(\"docid\"));\n                    }\n                    addCount.addAndGet(docsList.size());\n\n                    final Term packIDTerm = new Term(\"packID\", packID);\n\n                    if (delSubDocs != null) {\n                      delSubDocs.deleted = true;\n                      delIDs.addAll(delSubDocs.subIDs);\n                      delCount.addAndGet(delSubDocs.subIDs.size());\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": update pack packID=\" + delSubDocs.packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      updateDocuments(packIDTerm, docsList);\n                    } else {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": add pack packID=\" + packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      addDocuments(packIDTerm, docsList);\n                    }\n                    doc.removeField(\"packID\");\n\n                    if (random().nextInt(5) == 2) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + packID);\n                      }\n                      toDeleteSubDocs.add(subDocs);\n                    }\n\n                  } else {\n                    // Add single doc\n                    final String docid = doc.get(\"docid\");\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": add doc docid:\" + docid);\n                    }\n                    addDocument(new Term(\"docid\", docid), doc);\n                    addCount.getAndIncrement();\n\n                    if (random().nextInt(5) == 3) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                      }\n                      toDeleteIDs.add(docid);\n                    }\n                  }\n                } else {\n\n                  // Update single doc, but we never re-use\n                  // and ID so the delete will never\n                  // actually happen:\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": update doc id:\" + doc.get(\"docid\"));\n                  }\n                  final String docid = doc.get(\"docid\");\n                  updateDocument(new Term(\"docid\", docid), doc);\n                  addCount.getAndIncrement();\n\n                  if (random().nextInt(5) == 3) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                    }\n                    toDeleteIDs.add(docid);\n                  }\n                }\n\n                if (random().nextInt(30) == 17) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": apply \" + toDeleteIDs.size() + \" deletes\");\n                  }\n                  for(String id : toDeleteIDs) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del term=id:\" + id);\n                    }\n                    deleteDocuments(new Term(\"docid\", id));\n                  }\n                  final int count = delCount.addAndGet(toDeleteIDs.size());\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": tot \" + count + \" deletes\");\n                  }\n                  delIDs.addAll(toDeleteIDs);\n                  toDeleteIDs.clear();\n\n                  for(SubDocs subDocs : toDeleteSubDocs) {\n                    assert !subDocs.deleted;\n                    delPackIDs.add(subDocs.packID);\n                    deleteDocuments(new Term(\"packID\", subDocs.packID));\n                    subDocs.deleted = true;\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del subs: \" + subDocs.subIDs + \" packID=\" + subDocs.packID);\n                    }\n                    delIDs.addAll(subDocs.subIDs);\n                    delCount.addAndGet(subDocs.subIDs.size());\n                  }\n                  toDeleteSubDocs.clear();\n                }\n                if (addedField != null) {\n                  doc.removeField(addedField);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                t.printStackTrace();\n                failed.set(true);\n                throw new RuntimeException(t);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": indexing done\");\n            }\n\n            doAfterIndexingThreadDone();\n          }\n        };\n      threads[thread].setDaemon(true);\n      threads[thread].start();\n    }\n\n    return threads;\n  }\n\n","sourceOld":"  private Thread[] launchIndexingThreads(final LineFileDocs docs,\n                                         int numThreads,\n                                         final long stopTime,\n                                         final Set<String> delIDs,\n                                         final Set<String> delPackIDs,\n                                         final List<SubDocs> allSubDocs)\n    throws Exception {\n    final Thread[] threads = new Thread[numThreads];\n    for(int thread=0;thread<numThreads;thread++) {\n      threads[thread] = new Thread() {\n          @Override\n          public void run() {\n            // TODO: would be better if this were cross thread, so that we make sure one thread deleting anothers added docs works:\n            final List<String> toDeleteIDs = new ArrayList<String>();\n            final List<SubDocs> toDeleteSubDocs = new ArrayList<SubDocs>();\n            while(System.currentTimeMillis() < stopTime && !failed.get()) {\n              try {\n\n                // Occasional longish pause if running\n                // nightly\n                if (LuceneTestCase.TEST_NIGHTLY && random().nextInt(6) == 3) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": now long sleep\");\n                  }\n                  Thread.sleep(_TestUtil.nextInt(random(), 50, 500));\n                }\n\n                // Rate limit ingest rate:\n                if (random().nextInt(7) == 5) {\n                  Thread.sleep(_TestUtil.nextInt(random(), 1, 10));\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": done sleep\");\n                  }\n                }\n\n                Document doc = docs.nextDoc();\n                if (doc == null) {\n                  break;\n                }\n\n                // Maybe add randomly named field\n                final String addedField;\n                if (random().nextBoolean()) {\n                  addedField = \"extra\" + random().nextInt(40);\n                  doc.add(newTextField(addedField, \"a random field\", Field.Store.YES));\n                } else {\n                  addedField = null;\n                }\n\n                if (random().nextBoolean()) {\n\n                  if (random().nextBoolean()) {\n                    // Add/update doc block:\n                    final String packID;\n                    final SubDocs delSubDocs;\n                    if (toDeleteSubDocs.size() > 0 && random().nextBoolean()) {\n                      delSubDocs = toDeleteSubDocs.get(random().nextInt(toDeleteSubDocs.size()));\n                      assert !delSubDocs.deleted;\n                      toDeleteSubDocs.remove(delSubDocs);\n                      // Update doc block, replacing prior packID\n                      packID = delSubDocs.packID;\n                    } else {\n                      delSubDocs = null;\n                      // Add doc block, using new packID\n                      packID = packCount.getAndIncrement() + \"\";\n                    }\n\n                    final Field packIDField = newStringField(\"packID\", packID, Field.Store.YES);\n                    final List<String> docIDs = new ArrayList<String>();\n                    final SubDocs subDocs = new SubDocs(packID, docIDs);\n                    final List<Document> docsList = new ArrayList<Document>();\n\n                    allSubDocs.add(subDocs);\n                    doc.add(packIDField);\n                    docsList.add(_TestUtil.cloneDocument(doc));\n                    docIDs.add(doc.get(\"docid\"));\n\n                    final int maxDocCount = _TestUtil.nextInt(random(), 1, 10);\n                    while(docsList.size() < maxDocCount) {\n                      doc = docs.nextDoc();\n                      if (doc == null) {\n                        break;\n                      }\n                      docsList.add(_TestUtil.cloneDocument(doc));\n                      docIDs.add(doc.get(\"docid\"));\n                    }\n                    addCount.addAndGet(docsList.size());\n\n                    final Term packIDTerm = new Term(\"packID\", packID);\n\n                    if (delSubDocs != null) {\n                      delSubDocs.deleted = true;\n                      delIDs.addAll(delSubDocs.subIDs);\n                      delCount.addAndGet(delSubDocs.subIDs.size());\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": update pack packID=\" + delSubDocs.packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      updateDocuments(packIDTerm, docsList);\n                    } else {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": add pack packID=\" + packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      addDocuments(packIDTerm, docsList);\n                    }\n                    doc.removeField(\"packID\");\n\n                    if (random().nextInt(5) == 2) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + packID);\n                      }\n                      toDeleteSubDocs.add(subDocs);\n                    }\n\n                  } else {\n                    // Add single doc\n                    final String docid = doc.get(\"docid\");\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": add doc docid:\" + docid);\n                    }\n                    addDocument(new Term(\"docid\", docid), doc);\n                    addCount.getAndIncrement();\n\n                    if (random().nextInt(5) == 3) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                      }\n                      toDeleteIDs.add(docid);\n                    }\n                  }\n                } else {\n\n                  // Update single doc, but we never re-use\n                  // and ID so the delete will never\n                  // actually happen:\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": update doc id:\" + doc.get(\"docid\"));\n                  }\n                  final String docid = doc.get(\"docid\");\n                  updateDocument(new Term(\"docid\", docid), doc);\n                  addCount.getAndIncrement();\n\n                  if (random().nextInt(5) == 3) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                    }\n                    toDeleteIDs.add(docid);\n                  }\n                }\n\n                if (random().nextInt(30) == 17) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": apply \" + toDeleteIDs.size() + \" deletes\");\n                  }\n                  for(String id : toDeleteIDs) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del term=id:\" + id);\n                    }\n                    deleteDocuments(new Term(\"docid\", id));\n                  }\n                  final int count = delCount.addAndGet(toDeleteIDs.size());\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": tot \" + count + \" deletes\");\n                  }\n                  delIDs.addAll(toDeleteIDs);\n                  toDeleteIDs.clear();\n\n                  for(SubDocs subDocs : toDeleteSubDocs) {\n                    assert !subDocs.deleted;\n                    delPackIDs.add(subDocs.packID);\n                    deleteDocuments(new Term(\"packID\", subDocs.packID));\n                    subDocs.deleted = true;\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del subs: \" + subDocs.subIDs + \" packID=\" + subDocs.packID);\n                    }\n                    delIDs.addAll(subDocs.subIDs);\n                    delCount.addAndGet(subDocs.subIDs.size());\n                  }\n                  toDeleteSubDocs.clear();\n                }\n                if (addedField != null) {\n                  doc.removeField(addedField);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                t.printStackTrace();\n                failed.set(true);\n                throw new RuntimeException(t);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": indexing done\");\n            }\n\n            doAfterIndexingThreadDone();\n          }\n        };\n      threads[thread].setDaemon(true);\n      threads[thread].start();\n    }\n\n    return threads;\n  }\n\n","bugFix":["edcc2c2cbab6bf89ea584169ffb3ca83a31827f9"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#launchIndexingThreads(LineFileDocs,int,long,Set[String],Set[String],List[SubDocs]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#launchIndexingThreads(LineFileDocs,int,long,Set[String],Set[String],List[SubDocs]).mjava","sourceNew":"  private Thread[] launchIndexingThreads(final LineFileDocs docs,\n                                         int numThreads,\n                                         final long stopTime,\n                                         final Set<String> delIDs,\n                                         final Set<String> delPackIDs,\n                                         final List<SubDocs> allSubDocs) {\n    final Thread[] threads = new Thread[numThreads];\n    for(int thread=0;thread<numThreads;thread++) {\n      threads[thread] = new Thread() {\n          @Override\n          public void run() {\n            // TODO: would be better if this were cross thread, so that we make sure one thread deleting anothers added docs works:\n            final List<String> toDeleteIDs = new ArrayList<String>();\n            final List<SubDocs> toDeleteSubDocs = new ArrayList<SubDocs>();\n            while(System.currentTimeMillis() < stopTime && !failed.get()) {\n              try {\n\n                // Occasional longish pause if running\n                // nightly\n                if (LuceneTestCase.TEST_NIGHTLY && random().nextInt(6) == 3) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": now long sleep\");\n                  }\n                  Thread.sleep(_TestUtil.nextInt(random(), 50, 500));\n                }\n\n                // Rate limit ingest rate:\n                if (random().nextInt(7) == 5) {\n                  Thread.sleep(_TestUtil.nextInt(random(), 1, 10));\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": done sleep\");\n                  }\n                }\n\n                Document doc = docs.nextDoc();\n                if (doc == null) {\n                  break;\n                }\n\n                // Maybe add randomly named field\n                final String addedField;\n                if (random().nextBoolean()) {\n                  addedField = \"extra\" + random().nextInt(40);\n                  doc.add(newTextField(addedField, \"a random field\", Field.Store.YES));\n                } else {\n                  addedField = null;\n                }\n\n                if (random().nextBoolean()) {\n\n                  if (random().nextBoolean()) {\n                    // Add/update doc block:\n                    final String packID;\n                    final SubDocs delSubDocs;\n                    if (toDeleteSubDocs.size() > 0 && random().nextBoolean()) {\n                      delSubDocs = toDeleteSubDocs.get(random().nextInt(toDeleteSubDocs.size()));\n                      assert !delSubDocs.deleted;\n                      toDeleteSubDocs.remove(delSubDocs);\n                      // Update doc block, replacing prior packID\n                      packID = delSubDocs.packID;\n                    } else {\n                      delSubDocs = null;\n                      // Add doc block, using new packID\n                      packID = packCount.getAndIncrement() + \"\";\n                    }\n\n                    final Field packIDField = newStringField(\"packID\", packID, Field.Store.YES);\n                    final List<String> docIDs = new ArrayList<String>();\n                    final SubDocs subDocs = new SubDocs(packID, docIDs);\n                    final List<Document> docsList = new ArrayList<Document>();\n\n                    allSubDocs.add(subDocs);\n                    doc.add(packIDField);\n                    docsList.add(_TestUtil.cloneDocument(doc));\n                    docIDs.add(doc.get(\"docid\"));\n\n                    final int maxDocCount = _TestUtil.nextInt(random(), 1, 10);\n                    while(docsList.size() < maxDocCount) {\n                      doc = docs.nextDoc();\n                      if (doc == null) {\n                        break;\n                      }\n                      docsList.add(_TestUtil.cloneDocument(doc));\n                      docIDs.add(doc.get(\"docid\"));\n                    }\n                    addCount.addAndGet(docsList.size());\n\n                    final Term packIDTerm = new Term(\"packID\", packID);\n\n                    if (delSubDocs != null) {\n                      delSubDocs.deleted = true;\n                      delIDs.addAll(delSubDocs.subIDs);\n                      delCount.addAndGet(delSubDocs.subIDs.size());\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": update pack packID=\" + delSubDocs.packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      updateDocuments(packIDTerm, docsList);\n                    } else {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": add pack packID=\" + packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      addDocuments(packIDTerm, docsList);\n                    }\n                    doc.removeField(\"packID\");\n\n                    if (random().nextInt(5) == 2) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + packID);\n                      }\n                      toDeleteSubDocs.add(subDocs);\n                    }\n\n                  } else {\n                    // Add single doc\n                    final String docid = doc.get(\"docid\");\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": add doc docid:\" + docid);\n                    }\n                    addDocument(new Term(\"docid\", docid), doc);\n                    addCount.getAndIncrement();\n\n                    if (random().nextInt(5) == 3) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                      }\n                      toDeleteIDs.add(docid);\n                    }\n                  }\n                } else {\n\n                  // Update single doc, but we never re-use\n                  // and ID so the delete will never\n                  // actually happen:\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": update doc id:\" + doc.get(\"docid\"));\n                  }\n                  final String docid = doc.get(\"docid\");\n                  updateDocument(new Term(\"docid\", docid), doc);\n                  addCount.getAndIncrement();\n\n                  if (random().nextInt(5) == 3) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                    }\n                    toDeleteIDs.add(docid);\n                  }\n                }\n\n                if (random().nextInt(30) == 17) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": apply \" + toDeleteIDs.size() + \" deletes\");\n                  }\n                  for(String id : toDeleteIDs) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del term=id:\" + id);\n                    }\n                    deleteDocuments(new Term(\"docid\", id));\n                  }\n                  final int count = delCount.addAndGet(toDeleteIDs.size());\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": tot \" + count + \" deletes\");\n                  }\n                  delIDs.addAll(toDeleteIDs);\n                  toDeleteIDs.clear();\n\n                  for(SubDocs subDocs : toDeleteSubDocs) {\n                    assert !subDocs.deleted;\n                    delPackIDs.add(subDocs.packID);\n                    deleteDocuments(new Term(\"packID\", subDocs.packID));\n                    subDocs.deleted = true;\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del subs: \" + subDocs.subIDs + \" packID=\" + subDocs.packID);\n                    }\n                    delIDs.addAll(subDocs.subIDs);\n                    delCount.addAndGet(subDocs.subIDs.size());\n                  }\n                  toDeleteSubDocs.clear();\n                }\n                if (addedField != null) {\n                  doc.removeField(addedField);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                t.printStackTrace();\n                failed.set(true);\n                throw new RuntimeException(t);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": indexing done\");\n            }\n\n            doAfterIndexingThreadDone();\n          }\n        };\n      threads[thread].setDaemon(true);\n      threads[thread].start();\n    }\n\n    return threads;\n  }\n\n","sourceOld":"  private Thread[] launchIndexingThreads(final LineFileDocs docs,\n                                         int numThreads,\n                                         final long stopTime,\n                                         final Set<String> delIDs,\n                                         final Set<String> delPackIDs,\n                                         final List<SubDocs> allSubDocs)\n    throws Exception {\n    final Thread[] threads = new Thread[numThreads];\n    for(int thread=0;thread<numThreads;thread++) {\n      threads[thread] = new Thread() {\n          @Override\n          public void run() {\n            // TODO: would be better if this were cross thread, so that we make sure one thread deleting anothers added docs works:\n            final List<String> toDeleteIDs = new ArrayList<String>();\n            final List<SubDocs> toDeleteSubDocs = new ArrayList<SubDocs>();\n            while(System.currentTimeMillis() < stopTime && !failed.get()) {\n              try {\n\n                // Occasional longish pause if running\n                // nightly\n                if (LuceneTestCase.TEST_NIGHTLY && random().nextInt(6) == 3) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": now long sleep\");\n                  }\n                  Thread.sleep(_TestUtil.nextInt(random(), 50, 500));\n                }\n\n                // Rate limit ingest rate:\n                if (random().nextInt(7) == 5) {\n                  Thread.sleep(_TestUtil.nextInt(random(), 1, 10));\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": done sleep\");\n                  }\n                }\n\n                Document doc = docs.nextDoc();\n                if (doc == null) {\n                  break;\n                }\n\n                // Maybe add randomly named field\n                final String addedField;\n                if (random().nextBoolean()) {\n                  addedField = \"extra\" + random().nextInt(40);\n                  doc.add(newTextField(addedField, \"a random field\", Field.Store.YES));\n                } else {\n                  addedField = null;\n                }\n\n                if (random().nextBoolean()) {\n\n                  if (random().nextBoolean()) {\n                    // Add/update doc block:\n                    final String packID;\n                    final SubDocs delSubDocs;\n                    if (toDeleteSubDocs.size() > 0 && random().nextBoolean()) {\n                      delSubDocs = toDeleteSubDocs.get(random().nextInt(toDeleteSubDocs.size()));\n                      assert !delSubDocs.deleted;\n                      toDeleteSubDocs.remove(delSubDocs);\n                      // Update doc block, replacing prior packID\n                      packID = delSubDocs.packID;\n                    } else {\n                      delSubDocs = null;\n                      // Add doc block, using new packID\n                      packID = packCount.getAndIncrement() + \"\";\n                    }\n\n                    final Field packIDField = newStringField(\"packID\", packID, Field.Store.YES);\n                    final List<String> docIDs = new ArrayList<String>();\n                    final SubDocs subDocs = new SubDocs(packID, docIDs);\n                    final List<Document> docsList = new ArrayList<Document>();\n\n                    allSubDocs.add(subDocs);\n                    doc.add(packIDField);\n                    docsList.add(_TestUtil.cloneDocument(doc));\n                    docIDs.add(doc.get(\"docid\"));\n\n                    final int maxDocCount = _TestUtil.nextInt(random(), 1, 10);\n                    while(docsList.size() < maxDocCount) {\n                      doc = docs.nextDoc();\n                      if (doc == null) {\n                        break;\n                      }\n                      docsList.add(_TestUtil.cloneDocument(doc));\n                      docIDs.add(doc.get(\"docid\"));\n                    }\n                    addCount.addAndGet(docsList.size());\n\n                    final Term packIDTerm = new Term(\"packID\", packID);\n\n                    if (delSubDocs != null) {\n                      delSubDocs.deleted = true;\n                      delIDs.addAll(delSubDocs.subIDs);\n                      delCount.addAndGet(delSubDocs.subIDs.size());\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": update pack packID=\" + delSubDocs.packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      updateDocuments(packIDTerm, docsList);\n                    } else {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": add pack packID=\" + packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      addDocuments(packIDTerm, docsList);\n                    }\n                    doc.removeField(\"packID\");\n\n                    if (random().nextInt(5) == 2) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + packID);\n                      }\n                      toDeleteSubDocs.add(subDocs);\n                    }\n\n                  } else {\n                    // Add single doc\n                    final String docid = doc.get(\"docid\");\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": add doc docid:\" + docid);\n                    }\n                    addDocument(new Term(\"docid\", docid), doc);\n                    addCount.getAndIncrement();\n\n                    if (random().nextInt(5) == 3) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                      }\n                      toDeleteIDs.add(docid);\n                    }\n                  }\n                } else {\n\n                  // Update single doc, but we never re-use\n                  // and ID so the delete will never\n                  // actually happen:\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": update doc id:\" + doc.get(\"docid\"));\n                  }\n                  final String docid = doc.get(\"docid\");\n                  updateDocument(new Term(\"docid\", docid), doc);\n                  addCount.getAndIncrement();\n\n                  if (random().nextInt(5) == 3) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                    }\n                    toDeleteIDs.add(docid);\n                  }\n                }\n\n                if (random().nextInt(30) == 17) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": apply \" + toDeleteIDs.size() + \" deletes\");\n                  }\n                  for(String id : toDeleteIDs) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del term=id:\" + id);\n                    }\n                    deleteDocuments(new Term(\"docid\", id));\n                  }\n                  final int count = delCount.addAndGet(toDeleteIDs.size());\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": tot \" + count + \" deletes\");\n                  }\n                  delIDs.addAll(toDeleteIDs);\n                  toDeleteIDs.clear();\n\n                  for(SubDocs subDocs : toDeleteSubDocs) {\n                    assert !subDocs.deleted;\n                    delPackIDs.add(subDocs.packID);\n                    deleteDocuments(new Term(\"packID\", subDocs.packID));\n                    subDocs.deleted = true;\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del subs: \" + subDocs.subIDs + \" packID=\" + subDocs.packID);\n                    }\n                    delIDs.addAll(subDocs.subIDs);\n                    delCount.addAndGet(subDocs.subIDs.size());\n                  }\n                  toDeleteSubDocs.clear();\n                }\n                if (addedField != null) {\n                  doc.removeField(addedField);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                t.printStackTrace();\n                failed.set(true);\n                throw new RuntimeException(t);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": indexing done\");\n            }\n\n            doAfterIndexingThreadDone();\n          }\n        };\n      threads[thread].setDaemon(true);\n      threads[thread].start();\n    }\n\n    return threads;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#launchIndexingThreads(LineFileDocs,int,long,Set[String],Set[String],List[SubDocs]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#launchIndexingThreads(LineFileDocs,int,long,Set[String],Set[String],List[SubDocs]).mjava","sourceNew":"  private Thread[] launchIndexingThreads(final LineFileDocs docs,\n                                         int numThreads,\n                                         final long stopTime,\n                                         final Set<String> delIDs,\n                                         final Set<String> delPackIDs,\n                                         final List<SubDocs> allSubDocs) {\n    final Thread[] threads = new Thread[numThreads];\n    for(int thread=0;thread<numThreads;thread++) {\n      threads[thread] = new Thread() {\n          @Override\n          public void run() {\n            // TODO: would be better if this were cross thread, so that we make sure one thread deleting anothers added docs works:\n            final List<String> toDeleteIDs = new ArrayList<String>();\n            final List<SubDocs> toDeleteSubDocs = new ArrayList<SubDocs>();\n            while(System.currentTimeMillis() < stopTime && !failed.get()) {\n              try {\n\n                // Occasional longish pause if running\n                // nightly\n                if (LuceneTestCase.TEST_NIGHTLY && random().nextInt(6) == 3) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": now long sleep\");\n                  }\n                  Thread.sleep(TestUtil.nextInt(random(), 50, 500));\n                }\n\n                // Rate limit ingest rate:\n                if (random().nextInt(7) == 5) {\n                  Thread.sleep(TestUtil.nextInt(random(), 1, 10));\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": done sleep\");\n                  }\n                }\n\n                Document doc = docs.nextDoc();\n                if (doc == null) {\n                  break;\n                }\n\n                // Maybe add randomly named field\n                final String addedField;\n                if (random().nextBoolean()) {\n                  addedField = \"extra\" + random().nextInt(40);\n                  doc.add(newTextField(addedField, \"a random field\", Field.Store.YES));\n                } else {\n                  addedField = null;\n                }\n\n                if (random().nextBoolean()) {\n\n                  if (random().nextBoolean()) {\n                    // Add/update doc block:\n                    final String packID;\n                    final SubDocs delSubDocs;\n                    if (toDeleteSubDocs.size() > 0 && random().nextBoolean()) {\n                      delSubDocs = toDeleteSubDocs.get(random().nextInt(toDeleteSubDocs.size()));\n                      assert !delSubDocs.deleted;\n                      toDeleteSubDocs.remove(delSubDocs);\n                      // Update doc block, replacing prior packID\n                      packID = delSubDocs.packID;\n                    } else {\n                      delSubDocs = null;\n                      // Add doc block, using new packID\n                      packID = packCount.getAndIncrement() + \"\";\n                    }\n\n                    final Field packIDField = newStringField(\"packID\", packID, Field.Store.YES);\n                    final List<String> docIDs = new ArrayList<String>();\n                    final SubDocs subDocs = new SubDocs(packID, docIDs);\n                    final List<Document> docsList = new ArrayList<Document>();\n\n                    allSubDocs.add(subDocs);\n                    doc.add(packIDField);\n                    docsList.add(TestUtil.cloneDocument(doc));\n                    docIDs.add(doc.get(\"docid\"));\n\n                    final int maxDocCount = TestUtil.nextInt(random(), 1, 10);\n                    while(docsList.size() < maxDocCount) {\n                      doc = docs.nextDoc();\n                      if (doc == null) {\n                        break;\n                      }\n                      docsList.add(TestUtil.cloneDocument(doc));\n                      docIDs.add(doc.get(\"docid\"));\n                    }\n                    addCount.addAndGet(docsList.size());\n\n                    final Term packIDTerm = new Term(\"packID\", packID);\n\n                    if (delSubDocs != null) {\n                      delSubDocs.deleted = true;\n                      delIDs.addAll(delSubDocs.subIDs);\n                      delCount.addAndGet(delSubDocs.subIDs.size());\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": update pack packID=\" + delSubDocs.packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      updateDocuments(packIDTerm, docsList);\n                    } else {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": add pack packID=\" + packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      addDocuments(packIDTerm, docsList);\n                    }\n                    doc.removeField(\"packID\");\n\n                    if (random().nextInt(5) == 2) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + packID);\n                      }\n                      toDeleteSubDocs.add(subDocs);\n                    }\n\n                  } else {\n                    // Add single doc\n                    final String docid = doc.get(\"docid\");\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": add doc docid:\" + docid);\n                    }\n                    addDocument(new Term(\"docid\", docid), doc);\n                    addCount.getAndIncrement();\n\n                    if (random().nextInt(5) == 3) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                      }\n                      toDeleteIDs.add(docid);\n                    }\n                  }\n                } else {\n\n                  // Update single doc, but we never re-use\n                  // and ID so the delete will never\n                  // actually happen:\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": update doc id:\" + doc.get(\"docid\"));\n                  }\n                  final String docid = doc.get(\"docid\");\n                  updateDocument(new Term(\"docid\", docid), doc);\n                  addCount.getAndIncrement();\n\n                  if (random().nextInt(5) == 3) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                    }\n                    toDeleteIDs.add(docid);\n                  }\n                }\n\n                if (random().nextInt(30) == 17) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": apply \" + toDeleteIDs.size() + \" deletes\");\n                  }\n                  for(String id : toDeleteIDs) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del term=id:\" + id);\n                    }\n                    deleteDocuments(new Term(\"docid\", id));\n                  }\n                  final int count = delCount.addAndGet(toDeleteIDs.size());\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": tot \" + count + \" deletes\");\n                  }\n                  delIDs.addAll(toDeleteIDs);\n                  toDeleteIDs.clear();\n\n                  for(SubDocs subDocs : toDeleteSubDocs) {\n                    assert !subDocs.deleted;\n                    delPackIDs.add(subDocs.packID);\n                    deleteDocuments(new Term(\"packID\", subDocs.packID));\n                    subDocs.deleted = true;\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del subs: \" + subDocs.subIDs + \" packID=\" + subDocs.packID);\n                    }\n                    delIDs.addAll(subDocs.subIDs);\n                    delCount.addAndGet(subDocs.subIDs.size());\n                  }\n                  toDeleteSubDocs.clear();\n                }\n                if (addedField != null) {\n                  doc.removeField(addedField);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                t.printStackTrace();\n                failed.set(true);\n                throw new RuntimeException(t);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": indexing done\");\n            }\n\n            doAfterIndexingThreadDone();\n          }\n        };\n      threads[thread].setDaemon(true);\n      threads[thread].start();\n    }\n\n    return threads;\n  }\n\n","sourceOld":"  private Thread[] launchIndexingThreads(final LineFileDocs docs,\n                                         int numThreads,\n                                         final long stopTime,\n                                         final Set<String> delIDs,\n                                         final Set<String> delPackIDs,\n                                         final List<SubDocs> allSubDocs) {\n    final Thread[] threads = new Thread[numThreads];\n    for(int thread=0;thread<numThreads;thread++) {\n      threads[thread] = new Thread() {\n          @Override\n          public void run() {\n            // TODO: would be better if this were cross thread, so that we make sure one thread deleting anothers added docs works:\n            final List<String> toDeleteIDs = new ArrayList<String>();\n            final List<SubDocs> toDeleteSubDocs = new ArrayList<SubDocs>();\n            while(System.currentTimeMillis() < stopTime && !failed.get()) {\n              try {\n\n                // Occasional longish pause if running\n                // nightly\n                if (LuceneTestCase.TEST_NIGHTLY && random().nextInt(6) == 3) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": now long sleep\");\n                  }\n                  Thread.sleep(_TestUtil.nextInt(random(), 50, 500));\n                }\n\n                // Rate limit ingest rate:\n                if (random().nextInt(7) == 5) {\n                  Thread.sleep(_TestUtil.nextInt(random(), 1, 10));\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": done sleep\");\n                  }\n                }\n\n                Document doc = docs.nextDoc();\n                if (doc == null) {\n                  break;\n                }\n\n                // Maybe add randomly named field\n                final String addedField;\n                if (random().nextBoolean()) {\n                  addedField = \"extra\" + random().nextInt(40);\n                  doc.add(newTextField(addedField, \"a random field\", Field.Store.YES));\n                } else {\n                  addedField = null;\n                }\n\n                if (random().nextBoolean()) {\n\n                  if (random().nextBoolean()) {\n                    // Add/update doc block:\n                    final String packID;\n                    final SubDocs delSubDocs;\n                    if (toDeleteSubDocs.size() > 0 && random().nextBoolean()) {\n                      delSubDocs = toDeleteSubDocs.get(random().nextInt(toDeleteSubDocs.size()));\n                      assert !delSubDocs.deleted;\n                      toDeleteSubDocs.remove(delSubDocs);\n                      // Update doc block, replacing prior packID\n                      packID = delSubDocs.packID;\n                    } else {\n                      delSubDocs = null;\n                      // Add doc block, using new packID\n                      packID = packCount.getAndIncrement() + \"\";\n                    }\n\n                    final Field packIDField = newStringField(\"packID\", packID, Field.Store.YES);\n                    final List<String> docIDs = new ArrayList<String>();\n                    final SubDocs subDocs = new SubDocs(packID, docIDs);\n                    final List<Document> docsList = new ArrayList<Document>();\n\n                    allSubDocs.add(subDocs);\n                    doc.add(packIDField);\n                    docsList.add(_TestUtil.cloneDocument(doc));\n                    docIDs.add(doc.get(\"docid\"));\n\n                    final int maxDocCount = _TestUtil.nextInt(random(), 1, 10);\n                    while(docsList.size() < maxDocCount) {\n                      doc = docs.nextDoc();\n                      if (doc == null) {\n                        break;\n                      }\n                      docsList.add(_TestUtil.cloneDocument(doc));\n                      docIDs.add(doc.get(\"docid\"));\n                    }\n                    addCount.addAndGet(docsList.size());\n\n                    final Term packIDTerm = new Term(\"packID\", packID);\n\n                    if (delSubDocs != null) {\n                      delSubDocs.deleted = true;\n                      delIDs.addAll(delSubDocs.subIDs);\n                      delCount.addAndGet(delSubDocs.subIDs.size());\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": update pack packID=\" + delSubDocs.packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      updateDocuments(packIDTerm, docsList);\n                    } else {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": add pack packID=\" + packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      addDocuments(packIDTerm, docsList);\n                    }\n                    doc.removeField(\"packID\");\n\n                    if (random().nextInt(5) == 2) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + packID);\n                      }\n                      toDeleteSubDocs.add(subDocs);\n                    }\n\n                  } else {\n                    // Add single doc\n                    final String docid = doc.get(\"docid\");\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": add doc docid:\" + docid);\n                    }\n                    addDocument(new Term(\"docid\", docid), doc);\n                    addCount.getAndIncrement();\n\n                    if (random().nextInt(5) == 3) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                      }\n                      toDeleteIDs.add(docid);\n                    }\n                  }\n                } else {\n\n                  // Update single doc, but we never re-use\n                  // and ID so the delete will never\n                  // actually happen:\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": update doc id:\" + doc.get(\"docid\"));\n                  }\n                  final String docid = doc.get(\"docid\");\n                  updateDocument(new Term(\"docid\", docid), doc);\n                  addCount.getAndIncrement();\n\n                  if (random().nextInt(5) == 3) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                    }\n                    toDeleteIDs.add(docid);\n                  }\n                }\n\n                if (random().nextInt(30) == 17) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": apply \" + toDeleteIDs.size() + \" deletes\");\n                  }\n                  for(String id : toDeleteIDs) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del term=id:\" + id);\n                    }\n                    deleteDocuments(new Term(\"docid\", id));\n                  }\n                  final int count = delCount.addAndGet(toDeleteIDs.size());\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": tot \" + count + \" deletes\");\n                  }\n                  delIDs.addAll(toDeleteIDs);\n                  toDeleteIDs.clear();\n\n                  for(SubDocs subDocs : toDeleteSubDocs) {\n                    assert !subDocs.deleted;\n                    delPackIDs.add(subDocs.packID);\n                    deleteDocuments(new Term(\"packID\", subDocs.packID));\n                    subDocs.deleted = true;\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del subs: \" + subDocs.subIDs + \" packID=\" + subDocs.packID);\n                    }\n                    delIDs.addAll(subDocs.subIDs);\n                    delCount.addAndGet(subDocs.subIDs.size());\n                  }\n                  toDeleteSubDocs.clear();\n                }\n                if (addedField != null) {\n                  doc.removeField(addedField);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                t.printStackTrace();\n                failed.set(true);\n                throw new RuntimeException(t);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": indexing done\");\n            }\n\n            doAfterIndexingThreadDone();\n          }\n        };\n      threads[thread].setDaemon(true);\n      threads[thread].start();\n    }\n\n    return threads;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#launchIndexingThreads(LineFileDocs,int,long,Set[String],Set[String],List[SubDocs]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#launchIndexingThreads(LineFileDocs,int,long,Set[String],Set[String],List[SubDocs]).mjava","sourceNew":"  private Thread[] launchIndexingThreads(final LineFileDocs docs,\n                                         int numThreads,\n                                         final long stopTime,\n                                         final Set<String> delIDs,\n                                         final Set<String> delPackIDs,\n                                         final List<SubDocs> allSubDocs) {\n    final Thread[] threads = new Thread[numThreads];\n    for(int thread=0;thread<numThreads;thread++) {\n      threads[thread] = new Thread() {\n          @Override\n          public void run() {\n            // TODO: would be better if this were cross thread, so that we make sure one thread deleting anothers added docs works:\n            final List<String> toDeleteIDs = new ArrayList<>();\n            final List<SubDocs> toDeleteSubDocs = new ArrayList<>();\n            while(System.currentTimeMillis() < stopTime && !failed.get()) {\n              try {\n\n                // Occasional longish pause if running\n                // nightly\n                if (LuceneTestCase.TEST_NIGHTLY && random().nextInt(6) == 3) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": now long sleep\");\n                  }\n                  Thread.sleep(TestUtil.nextInt(random(), 50, 500));\n                }\n\n                // Rate limit ingest rate:\n                if (random().nextInt(7) == 5) {\n                  Thread.sleep(TestUtil.nextInt(random(), 1, 10));\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": done sleep\");\n                  }\n                }\n\n                Document doc = docs.nextDoc();\n                if (doc == null) {\n                  break;\n                }\n\n                // Maybe add randomly named field\n                final String addedField;\n                if (random().nextBoolean()) {\n                  addedField = \"extra\" + random().nextInt(40);\n                  doc.add(newTextField(addedField, \"a random field\", Field.Store.YES));\n                } else {\n                  addedField = null;\n                }\n\n                if (random().nextBoolean()) {\n\n                  if (random().nextBoolean()) {\n                    // Add/update doc block:\n                    final String packID;\n                    final SubDocs delSubDocs;\n                    if (toDeleteSubDocs.size() > 0 && random().nextBoolean()) {\n                      delSubDocs = toDeleteSubDocs.get(random().nextInt(toDeleteSubDocs.size()));\n                      assert !delSubDocs.deleted;\n                      toDeleteSubDocs.remove(delSubDocs);\n                      // Update doc block, replacing prior packID\n                      packID = delSubDocs.packID;\n                    } else {\n                      delSubDocs = null;\n                      // Add doc block, using new packID\n                      packID = packCount.getAndIncrement() + \"\";\n                    }\n\n                    final Field packIDField = newStringField(\"packID\", packID, Field.Store.YES);\n                    final List<String> docIDs = new ArrayList<>();\n                    final SubDocs subDocs = new SubDocs(packID, docIDs);\n                    final List<Document> docsList = new ArrayList<>();\n\n                    allSubDocs.add(subDocs);\n                    doc.add(packIDField);\n                    docsList.add(TestUtil.cloneDocument(doc));\n                    docIDs.add(doc.get(\"docid\"));\n\n                    final int maxDocCount = TestUtil.nextInt(random(), 1, 10);\n                    while(docsList.size() < maxDocCount) {\n                      doc = docs.nextDoc();\n                      if (doc == null) {\n                        break;\n                      }\n                      docsList.add(TestUtil.cloneDocument(doc));\n                      docIDs.add(doc.get(\"docid\"));\n                    }\n                    addCount.addAndGet(docsList.size());\n\n                    final Term packIDTerm = new Term(\"packID\", packID);\n\n                    if (delSubDocs != null) {\n                      delSubDocs.deleted = true;\n                      delIDs.addAll(delSubDocs.subIDs);\n                      delCount.addAndGet(delSubDocs.subIDs.size());\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": update pack packID=\" + delSubDocs.packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      updateDocuments(packIDTerm, docsList);\n                    } else {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": add pack packID=\" + packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      addDocuments(packIDTerm, docsList);\n                    }\n                    doc.removeField(\"packID\");\n\n                    if (random().nextInt(5) == 2) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + packID);\n                      }\n                      toDeleteSubDocs.add(subDocs);\n                    }\n\n                  } else {\n                    // Add single doc\n                    final String docid = doc.get(\"docid\");\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": add doc docid:\" + docid);\n                    }\n                    addDocument(new Term(\"docid\", docid), doc);\n                    addCount.getAndIncrement();\n\n                    if (random().nextInt(5) == 3) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                      }\n                      toDeleteIDs.add(docid);\n                    }\n                  }\n                } else {\n\n                  // Update single doc, but we never re-use\n                  // and ID so the delete will never\n                  // actually happen:\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": update doc id:\" + doc.get(\"docid\"));\n                  }\n                  final String docid = doc.get(\"docid\");\n                  updateDocument(new Term(\"docid\", docid), doc);\n                  addCount.getAndIncrement();\n\n                  if (random().nextInt(5) == 3) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                    }\n                    toDeleteIDs.add(docid);\n                  }\n                }\n\n                if (random().nextInt(30) == 17) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": apply \" + toDeleteIDs.size() + \" deletes\");\n                  }\n                  for(String id : toDeleteIDs) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del term=id:\" + id);\n                    }\n                    deleteDocuments(new Term(\"docid\", id));\n                  }\n                  final int count = delCount.addAndGet(toDeleteIDs.size());\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": tot \" + count + \" deletes\");\n                  }\n                  delIDs.addAll(toDeleteIDs);\n                  toDeleteIDs.clear();\n\n                  for(SubDocs subDocs : toDeleteSubDocs) {\n                    assert !subDocs.deleted;\n                    delPackIDs.add(subDocs.packID);\n                    deleteDocuments(new Term(\"packID\", subDocs.packID));\n                    subDocs.deleted = true;\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del subs: \" + subDocs.subIDs + \" packID=\" + subDocs.packID);\n                    }\n                    delIDs.addAll(subDocs.subIDs);\n                    delCount.addAndGet(subDocs.subIDs.size());\n                  }\n                  toDeleteSubDocs.clear();\n                }\n                if (addedField != null) {\n                  doc.removeField(addedField);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                t.printStackTrace();\n                failed.set(true);\n                throw new RuntimeException(t);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": indexing done\");\n            }\n\n            doAfterIndexingThreadDone();\n          }\n        };\n      threads[thread].setDaemon(true);\n      threads[thread].start();\n    }\n\n    return threads;\n  }\n\n","sourceOld":"  private Thread[] launchIndexingThreads(final LineFileDocs docs,\n                                         int numThreads,\n                                         final long stopTime,\n                                         final Set<String> delIDs,\n                                         final Set<String> delPackIDs,\n                                         final List<SubDocs> allSubDocs) {\n    final Thread[] threads = new Thread[numThreads];\n    for(int thread=0;thread<numThreads;thread++) {\n      threads[thread] = new Thread() {\n          @Override\n          public void run() {\n            // TODO: would be better if this were cross thread, so that we make sure one thread deleting anothers added docs works:\n            final List<String> toDeleteIDs = new ArrayList<String>();\n            final List<SubDocs> toDeleteSubDocs = new ArrayList<SubDocs>();\n            while(System.currentTimeMillis() < stopTime && !failed.get()) {\n              try {\n\n                // Occasional longish pause if running\n                // nightly\n                if (LuceneTestCase.TEST_NIGHTLY && random().nextInt(6) == 3) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": now long sleep\");\n                  }\n                  Thread.sleep(TestUtil.nextInt(random(), 50, 500));\n                }\n\n                // Rate limit ingest rate:\n                if (random().nextInt(7) == 5) {\n                  Thread.sleep(TestUtil.nextInt(random(), 1, 10));\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": done sleep\");\n                  }\n                }\n\n                Document doc = docs.nextDoc();\n                if (doc == null) {\n                  break;\n                }\n\n                // Maybe add randomly named field\n                final String addedField;\n                if (random().nextBoolean()) {\n                  addedField = \"extra\" + random().nextInt(40);\n                  doc.add(newTextField(addedField, \"a random field\", Field.Store.YES));\n                } else {\n                  addedField = null;\n                }\n\n                if (random().nextBoolean()) {\n\n                  if (random().nextBoolean()) {\n                    // Add/update doc block:\n                    final String packID;\n                    final SubDocs delSubDocs;\n                    if (toDeleteSubDocs.size() > 0 && random().nextBoolean()) {\n                      delSubDocs = toDeleteSubDocs.get(random().nextInt(toDeleteSubDocs.size()));\n                      assert !delSubDocs.deleted;\n                      toDeleteSubDocs.remove(delSubDocs);\n                      // Update doc block, replacing prior packID\n                      packID = delSubDocs.packID;\n                    } else {\n                      delSubDocs = null;\n                      // Add doc block, using new packID\n                      packID = packCount.getAndIncrement() + \"\";\n                    }\n\n                    final Field packIDField = newStringField(\"packID\", packID, Field.Store.YES);\n                    final List<String> docIDs = new ArrayList<String>();\n                    final SubDocs subDocs = new SubDocs(packID, docIDs);\n                    final List<Document> docsList = new ArrayList<Document>();\n\n                    allSubDocs.add(subDocs);\n                    doc.add(packIDField);\n                    docsList.add(TestUtil.cloneDocument(doc));\n                    docIDs.add(doc.get(\"docid\"));\n\n                    final int maxDocCount = TestUtil.nextInt(random(), 1, 10);\n                    while(docsList.size() < maxDocCount) {\n                      doc = docs.nextDoc();\n                      if (doc == null) {\n                        break;\n                      }\n                      docsList.add(TestUtil.cloneDocument(doc));\n                      docIDs.add(doc.get(\"docid\"));\n                    }\n                    addCount.addAndGet(docsList.size());\n\n                    final Term packIDTerm = new Term(\"packID\", packID);\n\n                    if (delSubDocs != null) {\n                      delSubDocs.deleted = true;\n                      delIDs.addAll(delSubDocs.subIDs);\n                      delCount.addAndGet(delSubDocs.subIDs.size());\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": update pack packID=\" + delSubDocs.packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      updateDocuments(packIDTerm, docsList);\n                    } else {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": add pack packID=\" + packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      addDocuments(packIDTerm, docsList);\n                    }\n                    doc.removeField(\"packID\");\n\n                    if (random().nextInt(5) == 2) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + packID);\n                      }\n                      toDeleteSubDocs.add(subDocs);\n                    }\n\n                  } else {\n                    // Add single doc\n                    final String docid = doc.get(\"docid\");\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": add doc docid:\" + docid);\n                    }\n                    addDocument(new Term(\"docid\", docid), doc);\n                    addCount.getAndIncrement();\n\n                    if (random().nextInt(5) == 3) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                      }\n                      toDeleteIDs.add(docid);\n                    }\n                  }\n                } else {\n\n                  // Update single doc, but we never re-use\n                  // and ID so the delete will never\n                  // actually happen:\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": update doc id:\" + doc.get(\"docid\"));\n                  }\n                  final String docid = doc.get(\"docid\");\n                  updateDocument(new Term(\"docid\", docid), doc);\n                  addCount.getAndIncrement();\n\n                  if (random().nextInt(5) == 3) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                    }\n                    toDeleteIDs.add(docid);\n                  }\n                }\n\n                if (random().nextInt(30) == 17) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": apply \" + toDeleteIDs.size() + \" deletes\");\n                  }\n                  for(String id : toDeleteIDs) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del term=id:\" + id);\n                    }\n                    deleteDocuments(new Term(\"docid\", id));\n                  }\n                  final int count = delCount.addAndGet(toDeleteIDs.size());\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": tot \" + count + \" deletes\");\n                  }\n                  delIDs.addAll(toDeleteIDs);\n                  toDeleteIDs.clear();\n\n                  for(SubDocs subDocs : toDeleteSubDocs) {\n                    assert !subDocs.deleted;\n                    delPackIDs.add(subDocs.packID);\n                    deleteDocuments(new Term(\"packID\", subDocs.packID));\n                    subDocs.deleted = true;\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del subs: \" + subDocs.subIDs + \" packID=\" + subDocs.packID);\n                    }\n                    delIDs.addAll(subDocs.subIDs);\n                    delCount.addAndGet(subDocs.subIDs.size());\n                  }\n                  toDeleteSubDocs.clear();\n                }\n                if (addedField != null) {\n                  doc.removeField(addedField);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                t.printStackTrace();\n                failed.set(true);\n                throw new RuntimeException(t);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": indexing done\");\n            }\n\n            doAfterIndexingThreadDone();\n          }\n        };\n      threads[thread].setDaemon(true);\n      threads[thread].start();\n    }\n\n    return threads;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"edf3884ae1f2a71b2e1c12fb514407dfc9bf81b2","date":1427842554,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#launchIndexingThreads(LineFileDocs,int,long,Set[String],Set[String],List[SubDocs]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#launchIndexingThreads(LineFileDocs,int,long,Set[String],Set[String],List[SubDocs]).mjava","sourceNew":"  private Thread[] launchIndexingThreads(final LineFileDocs docs,\n                                         int numThreads,\n                                         final long stopTime,\n                                         final Set<String> delIDs,\n                                         final Set<String> delPackIDs,\n                                         final List<SubDocs> allSubDocs) {\n    final Thread[] threads = new Thread[numThreads];\n    for(int thread=0;thread<numThreads;thread++) {\n      threads[thread] = new Thread() {\n          @Override\n          public void run() {\n            // TODO: would be better if this were cross thread, so that we make sure one thread deleting anothers added docs works:\n            final List<String> toDeleteIDs = new ArrayList<>();\n            final List<SubDocs> toDeleteSubDocs = new ArrayList<>();\n            while(System.currentTimeMillis() < stopTime && !failed.get()) {\n              try {\n\n                // Occasional longish pause if running\n                // nightly\n                if (LuceneTestCase.TEST_NIGHTLY && random().nextInt(6) == 3) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": now long sleep\");\n                  }\n                  Thread.sleep(TestUtil.nextInt(random(), 50, 500));\n                }\n\n                // Rate limit ingest rate:\n                if (random().nextInt(7) == 5) {\n                  Thread.sleep(TestUtil.nextInt(random(), 1, 10));\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": done sleep\");\n                  }\n                }\n\n                Document doc = docs.nextDoc();\n                if (doc == null) {\n                  break;\n                }\n\n                // Maybe add randomly named field\n                final String addedField;\n                if (random().nextBoolean()) {\n                  addedField = \"extra\" + random().nextInt(40);\n                  doc.add(newTextField(addedField, \"a random field\", Field.Store.YES));\n                } else {\n                  addedField = null;\n                }\n\n                if (random().nextBoolean()) {\n\n                  if (random().nextBoolean()) {\n                    // Add/update doc block:\n                    final String packID;\n                    final SubDocs delSubDocs;\n                    if (toDeleteSubDocs.size() > 0 && random().nextBoolean()) {\n                      delSubDocs = toDeleteSubDocs.get(random().nextInt(toDeleteSubDocs.size()));\n                      assert !delSubDocs.deleted;\n                      toDeleteSubDocs.remove(delSubDocs);\n                      // Update doc block, replacing prior packID\n                      packID = delSubDocs.packID;\n                    } else {\n                      delSubDocs = null;\n                      // Add doc block, using new packID\n                      packID = packCount.getAndIncrement() + \"\";\n                    }\n\n                    final Field packIDField = newStringField(\"packID\", packID, Field.Store.YES);\n                    final List<String> docIDs = new ArrayList<>();\n                    final SubDocs subDocs = new SubDocs(packID, docIDs);\n                    final List<Document> docsList = new ArrayList<>();\n\n                    allSubDocs.add(subDocs);\n                    doc.add(packIDField);\n                    docsList.add(TestUtil.cloneDocument(doc));\n                    docIDs.add(doc.get(\"docid\"));\n\n                    final int maxDocCount = TestUtil.nextInt(random(), 1, 10);\n                    while(docsList.size() < maxDocCount) {\n                      doc = docs.nextDoc();\n                      if (doc == null) {\n                        break;\n                      }\n                      docsList.add(TestUtil.cloneDocument(doc));\n                      docIDs.add(doc.get(\"docid\"));\n                    }\n                    addCount.addAndGet(docsList.size());\n\n                    final Term packIDTerm = new Term(\"packID\", packID);\n\n                    if (delSubDocs != null) {\n                      delSubDocs.deleted = true;\n                      delIDs.addAll(delSubDocs.subIDs);\n                      delCount.addAndGet(delSubDocs.subIDs.size());\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": update pack packID=\" + delSubDocs.packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      updateDocuments(packIDTerm, docsList);\n                    } else {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": add pack packID=\" + packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      addDocuments(packIDTerm, docsList);\n                    }\n                    doc.removeField(\"packID\");\n\n                    if (random().nextInt(5) == 2) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + packID);\n                      }\n                      toDeleteSubDocs.add(subDocs);\n                    }\n\n                  } else {\n                    // Add single doc\n                    final String docid = doc.get(\"docid\");\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": add doc docid:\" + docid);\n                    }\n                    addDocument(new Term(\"docid\", docid), doc);\n                    addCount.getAndIncrement();\n\n                    if (random().nextInt(5) == 3) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                      }\n                      toDeleteIDs.add(docid);\n                    }\n                  }\n                } else {\n\n                  // Update single doc, but we never re-use\n                  // and ID so the delete will never\n                  // actually happen:\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": update doc id:\" + doc.get(\"docid\"));\n                  }\n                  final String docid = doc.get(\"docid\");\n                  updateDocument(new Term(\"docid\", docid), doc);\n                  addCount.getAndIncrement();\n\n                  if (random().nextInt(5) == 3) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                    }\n                    toDeleteIDs.add(docid);\n                  }\n                }\n\n                if (random().nextInt(30) == 17) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": apply \" + toDeleteIDs.size() + \" deletes\");\n                  }\n                  for(String id : toDeleteIDs) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del term=id:\" + id);\n                    }\n                    deleteDocuments(new Term(\"docid\", id));\n                  }\n                  final int count = delCount.addAndGet(toDeleteIDs.size());\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": tot \" + count + \" deletes\");\n                  }\n                  delIDs.addAll(toDeleteIDs);\n                  toDeleteIDs.clear();\n\n                  for(SubDocs subDocs : toDeleteSubDocs) {\n                    assert !subDocs.deleted;\n                    delPackIDs.add(subDocs.packID);\n                    deleteDocuments(new Term(\"packID\", subDocs.packID));\n                    subDocs.deleted = true;\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del subs: \" + subDocs.subIDs + \" packID=\" + subDocs.packID);\n                    }\n                    delIDs.addAll(subDocs.subIDs);\n                    delCount.addAndGet(subDocs.subIDs.size());\n                  }\n                  toDeleteSubDocs.clear();\n                }\n                if (addedField != null) {\n                  doc.removeField(addedField);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                t.printStackTrace();\n                failed.set(true);\n                throw new RuntimeException(t);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": indexing done\");\n            }\n\n            doAfterIndexingThreadDone();\n          }\n        };\n      threads[thread].start();\n    }\n\n    return threads;\n  }\n\n","sourceOld":"  private Thread[] launchIndexingThreads(final LineFileDocs docs,\n                                         int numThreads,\n                                         final long stopTime,\n                                         final Set<String> delIDs,\n                                         final Set<String> delPackIDs,\n                                         final List<SubDocs> allSubDocs) {\n    final Thread[] threads = new Thread[numThreads];\n    for(int thread=0;thread<numThreads;thread++) {\n      threads[thread] = new Thread() {\n          @Override\n          public void run() {\n            // TODO: would be better if this were cross thread, so that we make sure one thread deleting anothers added docs works:\n            final List<String> toDeleteIDs = new ArrayList<>();\n            final List<SubDocs> toDeleteSubDocs = new ArrayList<>();\n            while(System.currentTimeMillis() < stopTime && !failed.get()) {\n              try {\n\n                // Occasional longish pause if running\n                // nightly\n                if (LuceneTestCase.TEST_NIGHTLY && random().nextInt(6) == 3) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": now long sleep\");\n                  }\n                  Thread.sleep(TestUtil.nextInt(random(), 50, 500));\n                }\n\n                // Rate limit ingest rate:\n                if (random().nextInt(7) == 5) {\n                  Thread.sleep(TestUtil.nextInt(random(), 1, 10));\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": done sleep\");\n                  }\n                }\n\n                Document doc = docs.nextDoc();\n                if (doc == null) {\n                  break;\n                }\n\n                // Maybe add randomly named field\n                final String addedField;\n                if (random().nextBoolean()) {\n                  addedField = \"extra\" + random().nextInt(40);\n                  doc.add(newTextField(addedField, \"a random field\", Field.Store.YES));\n                } else {\n                  addedField = null;\n                }\n\n                if (random().nextBoolean()) {\n\n                  if (random().nextBoolean()) {\n                    // Add/update doc block:\n                    final String packID;\n                    final SubDocs delSubDocs;\n                    if (toDeleteSubDocs.size() > 0 && random().nextBoolean()) {\n                      delSubDocs = toDeleteSubDocs.get(random().nextInt(toDeleteSubDocs.size()));\n                      assert !delSubDocs.deleted;\n                      toDeleteSubDocs.remove(delSubDocs);\n                      // Update doc block, replacing prior packID\n                      packID = delSubDocs.packID;\n                    } else {\n                      delSubDocs = null;\n                      // Add doc block, using new packID\n                      packID = packCount.getAndIncrement() + \"\";\n                    }\n\n                    final Field packIDField = newStringField(\"packID\", packID, Field.Store.YES);\n                    final List<String> docIDs = new ArrayList<>();\n                    final SubDocs subDocs = new SubDocs(packID, docIDs);\n                    final List<Document> docsList = new ArrayList<>();\n\n                    allSubDocs.add(subDocs);\n                    doc.add(packIDField);\n                    docsList.add(TestUtil.cloneDocument(doc));\n                    docIDs.add(doc.get(\"docid\"));\n\n                    final int maxDocCount = TestUtil.nextInt(random(), 1, 10);\n                    while(docsList.size() < maxDocCount) {\n                      doc = docs.nextDoc();\n                      if (doc == null) {\n                        break;\n                      }\n                      docsList.add(TestUtil.cloneDocument(doc));\n                      docIDs.add(doc.get(\"docid\"));\n                    }\n                    addCount.addAndGet(docsList.size());\n\n                    final Term packIDTerm = new Term(\"packID\", packID);\n\n                    if (delSubDocs != null) {\n                      delSubDocs.deleted = true;\n                      delIDs.addAll(delSubDocs.subIDs);\n                      delCount.addAndGet(delSubDocs.subIDs.size());\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": update pack packID=\" + delSubDocs.packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      updateDocuments(packIDTerm, docsList);\n                    } else {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": add pack packID=\" + packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      addDocuments(packIDTerm, docsList);\n                    }\n                    doc.removeField(\"packID\");\n\n                    if (random().nextInt(5) == 2) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + packID);\n                      }\n                      toDeleteSubDocs.add(subDocs);\n                    }\n\n                  } else {\n                    // Add single doc\n                    final String docid = doc.get(\"docid\");\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": add doc docid:\" + docid);\n                    }\n                    addDocument(new Term(\"docid\", docid), doc);\n                    addCount.getAndIncrement();\n\n                    if (random().nextInt(5) == 3) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                      }\n                      toDeleteIDs.add(docid);\n                    }\n                  }\n                } else {\n\n                  // Update single doc, but we never re-use\n                  // and ID so the delete will never\n                  // actually happen:\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": update doc id:\" + doc.get(\"docid\"));\n                  }\n                  final String docid = doc.get(\"docid\");\n                  updateDocument(new Term(\"docid\", docid), doc);\n                  addCount.getAndIncrement();\n\n                  if (random().nextInt(5) == 3) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                    }\n                    toDeleteIDs.add(docid);\n                  }\n                }\n\n                if (random().nextInt(30) == 17) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": apply \" + toDeleteIDs.size() + \" deletes\");\n                  }\n                  for(String id : toDeleteIDs) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del term=id:\" + id);\n                    }\n                    deleteDocuments(new Term(\"docid\", id));\n                  }\n                  final int count = delCount.addAndGet(toDeleteIDs.size());\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": tot \" + count + \" deletes\");\n                  }\n                  delIDs.addAll(toDeleteIDs);\n                  toDeleteIDs.clear();\n\n                  for(SubDocs subDocs : toDeleteSubDocs) {\n                    assert !subDocs.deleted;\n                    delPackIDs.add(subDocs.packID);\n                    deleteDocuments(new Term(\"packID\", subDocs.packID));\n                    subDocs.deleted = true;\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del subs: \" + subDocs.subIDs + \" packID=\" + subDocs.packID);\n                    }\n                    delIDs.addAll(subDocs.subIDs);\n                    delCount.addAndGet(subDocs.subIDs.size());\n                  }\n                  toDeleteSubDocs.clear();\n                }\n                if (addedField != null) {\n                  doc.removeField(addedField);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                t.printStackTrace();\n                failed.set(true);\n                throw new RuntimeException(t);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": indexing done\");\n            }\n\n            doAfterIndexingThreadDone();\n          }\n        };\n      threads[thread].setDaemon(true);\n      threads[thread].start();\n    }\n\n    return threads;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c576bf71df117a2003cac1787df5a9a5de44eb6","date":1427849700,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#launchIndexingThreads(LineFileDocs,int,long,Set[String],Set[String],List[SubDocs]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#launchIndexingThreads(LineFileDocs,int,long,Set[String],Set[String],List[SubDocs]).mjava","sourceNew":"  private Thread[] launchIndexingThreads(final LineFileDocs docs,\n                                         int numThreads,\n                                         final long stopTime,\n                                         final Set<String> delIDs,\n                                         final Set<String> delPackIDs,\n                                         final List<SubDocs> allSubDocs) {\n    final Thread[] threads = new Thread[numThreads];\n    for(int thread=0;thread<numThreads;thread++) {\n      threads[thread] = new Thread() {\n          @Override\n          public void run() {\n            // TODO: would be better if this were cross thread, so that we make sure one thread deleting anothers added docs works:\n            final List<String> toDeleteIDs = new ArrayList<>();\n            final List<SubDocs> toDeleteSubDocs = new ArrayList<>();\n            while(System.currentTimeMillis() < stopTime && !failed.get()) {\n              try {\n\n                // Occasional longish pause if running\n                // nightly\n                if (LuceneTestCase.TEST_NIGHTLY && random().nextInt(6) == 3) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": now long sleep\");\n                  }\n                  Thread.sleep(TestUtil.nextInt(random(), 50, 500));\n                }\n\n                // Rate limit ingest rate:\n                if (random().nextInt(7) == 5) {\n                  Thread.sleep(TestUtil.nextInt(random(), 1, 10));\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": done sleep\");\n                  }\n                }\n\n                Document doc = docs.nextDoc();\n                if (doc == null) {\n                  break;\n                }\n\n                // Maybe add randomly named field\n                final String addedField;\n                if (random().nextBoolean()) {\n                  addedField = \"extra\" + random().nextInt(40);\n                  doc.add(newTextField(addedField, \"a random field\", Field.Store.YES));\n                } else {\n                  addedField = null;\n                }\n\n                if (random().nextBoolean()) {\n\n                  if (random().nextBoolean()) {\n                    // Add/update doc block:\n                    final String packID;\n                    final SubDocs delSubDocs;\n                    if (toDeleteSubDocs.size() > 0 && random().nextBoolean()) {\n                      delSubDocs = toDeleteSubDocs.get(random().nextInt(toDeleteSubDocs.size()));\n                      assert !delSubDocs.deleted;\n                      toDeleteSubDocs.remove(delSubDocs);\n                      // Update doc block, replacing prior packID\n                      packID = delSubDocs.packID;\n                    } else {\n                      delSubDocs = null;\n                      // Add doc block, using new packID\n                      packID = packCount.getAndIncrement() + \"\";\n                    }\n\n                    final Field packIDField = newStringField(\"packID\", packID, Field.Store.YES);\n                    final List<String> docIDs = new ArrayList<>();\n                    final SubDocs subDocs = new SubDocs(packID, docIDs);\n                    final List<Document> docsList = new ArrayList<>();\n\n                    allSubDocs.add(subDocs);\n                    doc.add(packIDField);\n                    docsList.add(TestUtil.cloneDocument(doc));\n                    docIDs.add(doc.get(\"docid\"));\n\n                    final int maxDocCount = TestUtil.nextInt(random(), 1, 10);\n                    while(docsList.size() < maxDocCount) {\n                      doc = docs.nextDoc();\n                      if (doc == null) {\n                        break;\n                      }\n                      docsList.add(TestUtil.cloneDocument(doc));\n                      docIDs.add(doc.get(\"docid\"));\n                    }\n                    addCount.addAndGet(docsList.size());\n\n                    final Term packIDTerm = new Term(\"packID\", packID);\n\n                    if (delSubDocs != null) {\n                      delSubDocs.deleted = true;\n                      delIDs.addAll(delSubDocs.subIDs);\n                      delCount.addAndGet(delSubDocs.subIDs.size());\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": update pack packID=\" + delSubDocs.packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      updateDocuments(packIDTerm, docsList);\n                    } else {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": add pack packID=\" + packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      addDocuments(packIDTerm, docsList);\n                    }\n                    doc.removeField(\"packID\");\n\n                    if (random().nextInt(5) == 2) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + packID);\n                      }\n                      toDeleteSubDocs.add(subDocs);\n                    }\n\n                  } else {\n                    // Add single doc\n                    final String docid = doc.get(\"docid\");\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": add doc docid:\" + docid);\n                    }\n                    addDocument(new Term(\"docid\", docid), doc);\n                    addCount.getAndIncrement();\n\n                    if (random().nextInt(5) == 3) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                      }\n                      toDeleteIDs.add(docid);\n                    }\n                  }\n                } else {\n\n                  // Update single doc, but we never re-use\n                  // and ID so the delete will never\n                  // actually happen:\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": update doc id:\" + doc.get(\"docid\"));\n                  }\n                  final String docid = doc.get(\"docid\");\n                  updateDocument(new Term(\"docid\", docid), doc);\n                  addCount.getAndIncrement();\n\n                  if (random().nextInt(5) == 3) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                    }\n                    toDeleteIDs.add(docid);\n                  }\n                }\n\n                if (random().nextInt(30) == 17) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": apply \" + toDeleteIDs.size() + \" deletes\");\n                  }\n                  for(String id : toDeleteIDs) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del term=id:\" + id);\n                    }\n                    deleteDocuments(new Term(\"docid\", id));\n                  }\n                  final int count = delCount.addAndGet(toDeleteIDs.size());\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": tot \" + count + \" deletes\");\n                  }\n                  delIDs.addAll(toDeleteIDs);\n                  toDeleteIDs.clear();\n\n                  for(SubDocs subDocs : toDeleteSubDocs) {\n                    assert !subDocs.deleted;\n                    delPackIDs.add(subDocs.packID);\n                    deleteDocuments(new Term(\"packID\", subDocs.packID));\n                    subDocs.deleted = true;\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del subs: \" + subDocs.subIDs + \" packID=\" + subDocs.packID);\n                    }\n                    delIDs.addAll(subDocs.subIDs);\n                    delCount.addAndGet(subDocs.subIDs.size());\n                  }\n                  toDeleteSubDocs.clear();\n                }\n                if (addedField != null) {\n                  doc.removeField(addedField);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                t.printStackTrace();\n                failed.set(true);\n                throw new RuntimeException(t);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": indexing done\");\n            }\n\n            doAfterIndexingThreadDone();\n          }\n        };\n      threads[thread].start();\n    }\n\n    return threads;\n  }\n\n","sourceOld":"  private Thread[] launchIndexingThreads(final LineFileDocs docs,\n                                         int numThreads,\n                                         final long stopTime,\n                                         final Set<String> delIDs,\n                                         final Set<String> delPackIDs,\n                                         final List<SubDocs> allSubDocs) {\n    final Thread[] threads = new Thread[numThreads];\n    for(int thread=0;thread<numThreads;thread++) {\n      threads[thread] = new Thread() {\n          @Override\n          public void run() {\n            // TODO: would be better if this were cross thread, so that we make sure one thread deleting anothers added docs works:\n            final List<String> toDeleteIDs = new ArrayList<>();\n            final List<SubDocs> toDeleteSubDocs = new ArrayList<>();\n            while(System.currentTimeMillis() < stopTime && !failed.get()) {\n              try {\n\n                // Occasional longish pause if running\n                // nightly\n                if (LuceneTestCase.TEST_NIGHTLY && random().nextInt(6) == 3) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": now long sleep\");\n                  }\n                  Thread.sleep(TestUtil.nextInt(random(), 50, 500));\n                }\n\n                // Rate limit ingest rate:\n                if (random().nextInt(7) == 5) {\n                  Thread.sleep(TestUtil.nextInt(random(), 1, 10));\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": done sleep\");\n                  }\n                }\n\n                Document doc = docs.nextDoc();\n                if (doc == null) {\n                  break;\n                }\n\n                // Maybe add randomly named field\n                final String addedField;\n                if (random().nextBoolean()) {\n                  addedField = \"extra\" + random().nextInt(40);\n                  doc.add(newTextField(addedField, \"a random field\", Field.Store.YES));\n                } else {\n                  addedField = null;\n                }\n\n                if (random().nextBoolean()) {\n\n                  if (random().nextBoolean()) {\n                    // Add/update doc block:\n                    final String packID;\n                    final SubDocs delSubDocs;\n                    if (toDeleteSubDocs.size() > 0 && random().nextBoolean()) {\n                      delSubDocs = toDeleteSubDocs.get(random().nextInt(toDeleteSubDocs.size()));\n                      assert !delSubDocs.deleted;\n                      toDeleteSubDocs.remove(delSubDocs);\n                      // Update doc block, replacing prior packID\n                      packID = delSubDocs.packID;\n                    } else {\n                      delSubDocs = null;\n                      // Add doc block, using new packID\n                      packID = packCount.getAndIncrement() + \"\";\n                    }\n\n                    final Field packIDField = newStringField(\"packID\", packID, Field.Store.YES);\n                    final List<String> docIDs = new ArrayList<>();\n                    final SubDocs subDocs = new SubDocs(packID, docIDs);\n                    final List<Document> docsList = new ArrayList<>();\n\n                    allSubDocs.add(subDocs);\n                    doc.add(packIDField);\n                    docsList.add(TestUtil.cloneDocument(doc));\n                    docIDs.add(doc.get(\"docid\"));\n\n                    final int maxDocCount = TestUtil.nextInt(random(), 1, 10);\n                    while(docsList.size() < maxDocCount) {\n                      doc = docs.nextDoc();\n                      if (doc == null) {\n                        break;\n                      }\n                      docsList.add(TestUtil.cloneDocument(doc));\n                      docIDs.add(doc.get(\"docid\"));\n                    }\n                    addCount.addAndGet(docsList.size());\n\n                    final Term packIDTerm = new Term(\"packID\", packID);\n\n                    if (delSubDocs != null) {\n                      delSubDocs.deleted = true;\n                      delIDs.addAll(delSubDocs.subIDs);\n                      delCount.addAndGet(delSubDocs.subIDs.size());\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": update pack packID=\" + delSubDocs.packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      updateDocuments(packIDTerm, docsList);\n                    } else {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": add pack packID=\" + packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      addDocuments(packIDTerm, docsList);\n                    }\n                    doc.removeField(\"packID\");\n\n                    if (random().nextInt(5) == 2) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + packID);\n                      }\n                      toDeleteSubDocs.add(subDocs);\n                    }\n\n                  } else {\n                    // Add single doc\n                    final String docid = doc.get(\"docid\");\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": add doc docid:\" + docid);\n                    }\n                    addDocument(new Term(\"docid\", docid), doc);\n                    addCount.getAndIncrement();\n\n                    if (random().nextInt(5) == 3) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                      }\n                      toDeleteIDs.add(docid);\n                    }\n                  }\n                } else {\n\n                  // Update single doc, but we never re-use\n                  // and ID so the delete will never\n                  // actually happen:\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": update doc id:\" + doc.get(\"docid\"));\n                  }\n                  final String docid = doc.get(\"docid\");\n                  updateDocument(new Term(\"docid\", docid), doc);\n                  addCount.getAndIncrement();\n\n                  if (random().nextInt(5) == 3) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                    }\n                    toDeleteIDs.add(docid);\n                  }\n                }\n\n                if (random().nextInt(30) == 17) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": apply \" + toDeleteIDs.size() + \" deletes\");\n                  }\n                  for(String id : toDeleteIDs) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del term=id:\" + id);\n                    }\n                    deleteDocuments(new Term(\"docid\", id));\n                  }\n                  final int count = delCount.addAndGet(toDeleteIDs.size());\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": tot \" + count + \" deletes\");\n                  }\n                  delIDs.addAll(toDeleteIDs);\n                  toDeleteIDs.clear();\n\n                  for(SubDocs subDocs : toDeleteSubDocs) {\n                    assert !subDocs.deleted;\n                    delPackIDs.add(subDocs.packID);\n                    deleteDocuments(new Term(\"packID\", subDocs.packID));\n                    subDocs.deleted = true;\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del subs: \" + subDocs.subIDs + \" packID=\" + subDocs.packID);\n                    }\n                    delIDs.addAll(subDocs.subIDs);\n                    delCount.addAndGet(subDocs.subIDs.size());\n                  }\n                  toDeleteSubDocs.clear();\n                }\n                if (addedField != null) {\n                  doc.removeField(addedField);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                t.printStackTrace();\n                failed.set(true);\n                throw new RuntimeException(t);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": indexing done\");\n            }\n\n            doAfterIndexingThreadDone();\n          }\n        };\n      threads[thread].setDaemon(true);\n      threads[thread].start();\n    }\n\n    return threads;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"04f07771a2a7dd3a395700665ed839c3dae2def2":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6613659748fe4411a7dcf85266e55db1f95f7315"],"edf3884ae1f2a71b2e1c12fb514407dfc9bf81b2":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"6613659748fe4411a7dcf85266e55db1f95f7315":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["04f07771a2a7dd3a395700665ed839c3dae2def2","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6c576bf71df117a2003cac1787df5a9a5de44eb6":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6c576bf71df117a2003cac1787df5a9a5de44eb6"]},"commit2Childs":{"04f07771a2a7dd3a395700665ed839c3dae2def2":["fe33227f6805edab2036cbb80645cc4e2d1fa424","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["edf3884ae1f2a71b2e1c12fb514407dfc9bf81b2","6c576bf71df117a2003cac1787df5a9a5de44eb6"],"edf3884ae1f2a71b2e1c12fb514407dfc9bf81b2":[],"6613659748fe4411a7dcf85266e55db1f95f7315":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"6c576bf71df117a2003cac1787df5a9a5de44eb6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["6613659748fe4411a7dcf85266e55db1f95f7315","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["edf3884ae1f2a71b2e1c12fb514407dfc9bf81b2","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}