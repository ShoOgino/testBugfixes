{"path":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#inflateGens(SegmentInfos,Collection[String],InfoStream).mjava","commits":[{"id":"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13","date":1409346855,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#inflateGens(SegmentInfos,Collection[String],InfoStream).mjava","pathOld":"/dev/null","sourceNew":"  /** Set all gens beyond what we currently see in the directory, to avoid double-write in cases where the previous IndexWriter did not\n   *  gracefully close/rollback (e.g. os/machine crashed or lost power). */\n  static void inflateGens(SegmentInfos infos, Collection<String> files, InfoStream infoStream) {\n\n    long maxSegmentGen = Long.MIN_VALUE;\n    int maxSegmentName = Integer.MIN_VALUE;\n\n    // Confusingly, this is the union of liveDocs, field infos, doc values\n    // (and maybe others, in the future) gens.  This is somewhat messy,\n    // since it means DV updates will suddenly write to the next gen after\n    // live docs' gen, for example, but we don't have the APIs to ask the\n    // codec which file is which:\n    Map<String,Long> maxPerSegmentGen = new HashMap<>();\n\n    for(String fileName : files) {\n      if (fileName.equals(IndexFileNames.SEGMENTS_GEN) || fileName.equals(IndexWriter.WRITE_LOCK_NAME)) {\n        // do nothing\n      } else if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n        try {\n          maxSegmentGen = Math.max(SegmentInfos.generationFromSegmentsFileName(fileName), maxSegmentGen);\n        } catch (NumberFormatException ignore) {\n          // trash file: we have to handle this since we allow anything starting with 'segments' here\n        }\n      } else {\n        String segmentName = IndexFileNames.parseSegmentName(fileName);\n        assert segmentName.startsWith(\"_\"): \"wtf? file=\" + fileName;\n\n        maxSegmentName = Math.max(maxSegmentName, Integer.parseInt(segmentName.substring(1), Character.MAX_RADIX));\n\n        Long curGen = maxPerSegmentGen.get(segmentName);\n        if (curGen == null) {\n          curGen = 0L;\n        }\n\n        try {\n          curGen = Math.max(curGen, IndexFileNames.parseGeneration(fileName));\n        } catch (NumberFormatException ignore) {\n          // trash file: we have to handle this since codec regex is only so good\n        }\n        maxPerSegmentGen.put(segmentName, curGen);\n      }\n    }\n\n    // Generation is advanced before write:\n    infos.setGeneration(Math.max(infos.getGeneration(), maxSegmentGen));\n    if (infos.counter < 1+maxSegmentName) {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"init: inflate infos.counter to \" + (1+maxSegmentName) + \" vs current=\" + infos.counter);\n      }\n      infos.counter = 1+maxSegmentName;\n    }\n\n    for(SegmentCommitInfo info : infos) {\n      Long gen = maxPerSegmentGen.get(info.info.name);\n      assert gen != null;\n      long genLong = gen;\n      if (info.getNextWriteDelGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteDelGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteDelGen());\n        }\n        info.setNextWriteDelGen(genLong+1);\n      }\n      if (info.getNextWriteFieldInfosGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteFieldInfosGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteFieldInfosGen());\n        }\n        info.setNextWriteFieldInfosGen(genLong+1);\n      }\n      if (info.getNextWriteDocValuesGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteDocValuesGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteDocValuesGen());\n        }\n        info.setNextWriteDocValuesGen(genLong+1);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["0617d2d25b13b9a49450ea49ceb06123ebd6542a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"46e4a8bdfbafda795ef9c39a2bc2d47095770299","date":1410411846,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#inflateGens(SegmentInfos,Collection[String],InfoStream).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#inflateGens(SegmentInfos,Collection[String],InfoStream).mjava","sourceNew":"  /** Set all gens beyond what we currently see in the directory, to avoid double-write in cases where the previous IndexWriter did not\n   *  gracefully close/rollback (e.g. os/machine crashed or lost power). */\n  static void inflateGens(SegmentInfos infos, Collection<String> files, InfoStream infoStream) {\n\n    long maxSegmentGen = Long.MIN_VALUE;\n    int maxSegmentName = Integer.MIN_VALUE;\n\n    // Confusingly, this is the union of liveDocs, field infos, doc values\n    // (and maybe others, in the future) gens.  This is somewhat messy,\n    // since it means DV updates will suddenly write to the next gen after\n    // live docs' gen, for example, but we don't have the APIs to ask the\n    // codec which file is which:\n    Map<String,Long> maxPerSegmentGen = new HashMap<>();\n\n    for(String fileName : files) {\n      if (fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN) || fileName.equals(IndexWriter.WRITE_LOCK_NAME)) {\n        // do nothing\n      } else if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n        try {\n          maxSegmentGen = Math.max(SegmentInfos.generationFromSegmentsFileName(fileName), maxSegmentGen);\n        } catch (NumberFormatException ignore) {\n          // trash file: we have to handle this since we allow anything starting with 'segments' here\n        }\n      } else if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n        try {\n          maxSegmentGen = Math.max(SegmentInfos.generationFromSegmentsFileName(fileName.substring(8)), maxSegmentGen);\n        } catch (NumberFormatException ignore) {\n          // trash file: we have to handle this since we allow anything starting with 'pending_segments' here\n        }\n      } else {\n        String segmentName = IndexFileNames.parseSegmentName(fileName);\n        assert segmentName.startsWith(\"_\"): \"wtf? file=\" + fileName;\n\n        maxSegmentName = Math.max(maxSegmentName, Integer.parseInt(segmentName.substring(1), Character.MAX_RADIX));\n\n        Long curGen = maxPerSegmentGen.get(segmentName);\n        if (curGen == null) {\n          curGen = 0L;\n        }\n\n        try {\n          curGen = Math.max(curGen, IndexFileNames.parseGeneration(fileName));\n        } catch (NumberFormatException ignore) {\n          // trash file: we have to handle this since codec regex is only so good\n        }\n        maxPerSegmentGen.put(segmentName, curGen);\n      }\n    }\n\n    // Generation is advanced before write:\n    infos.setGeneration(Math.max(infos.getGeneration(), maxSegmentGen));\n    if (infos.counter < 1+maxSegmentName) {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"init: inflate infos.counter to \" + (1+maxSegmentName) + \" vs current=\" + infos.counter);\n      }\n      infos.counter = 1+maxSegmentName;\n    }\n\n    for(SegmentCommitInfo info : infos) {\n      Long gen = maxPerSegmentGen.get(info.info.name);\n      assert gen != null;\n      long genLong = gen;\n      if (info.getNextWriteDelGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteDelGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteDelGen());\n        }\n        info.setNextWriteDelGen(genLong+1);\n      }\n      if (info.getNextWriteFieldInfosGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteFieldInfosGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteFieldInfosGen());\n        }\n        info.setNextWriteFieldInfosGen(genLong+1);\n      }\n      if (info.getNextWriteDocValuesGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteDocValuesGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteDocValuesGen());\n        }\n        info.setNextWriteDocValuesGen(genLong+1);\n      }\n    }\n  }\n\n","sourceOld":"  /** Set all gens beyond what we currently see in the directory, to avoid double-write in cases where the previous IndexWriter did not\n   *  gracefully close/rollback (e.g. os/machine crashed or lost power). */\n  static void inflateGens(SegmentInfos infos, Collection<String> files, InfoStream infoStream) {\n\n    long maxSegmentGen = Long.MIN_VALUE;\n    int maxSegmentName = Integer.MIN_VALUE;\n\n    // Confusingly, this is the union of liveDocs, field infos, doc values\n    // (and maybe others, in the future) gens.  This is somewhat messy,\n    // since it means DV updates will suddenly write to the next gen after\n    // live docs' gen, for example, but we don't have the APIs to ask the\n    // codec which file is which:\n    Map<String,Long> maxPerSegmentGen = new HashMap<>();\n\n    for(String fileName : files) {\n      if (fileName.equals(IndexFileNames.SEGMENTS_GEN) || fileName.equals(IndexWriter.WRITE_LOCK_NAME)) {\n        // do nothing\n      } else if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n        try {\n          maxSegmentGen = Math.max(SegmentInfos.generationFromSegmentsFileName(fileName), maxSegmentGen);\n        } catch (NumberFormatException ignore) {\n          // trash file: we have to handle this since we allow anything starting with 'segments' here\n        }\n      } else {\n        String segmentName = IndexFileNames.parseSegmentName(fileName);\n        assert segmentName.startsWith(\"_\"): \"wtf? file=\" + fileName;\n\n        maxSegmentName = Math.max(maxSegmentName, Integer.parseInt(segmentName.substring(1), Character.MAX_RADIX));\n\n        Long curGen = maxPerSegmentGen.get(segmentName);\n        if (curGen == null) {\n          curGen = 0L;\n        }\n\n        try {\n          curGen = Math.max(curGen, IndexFileNames.parseGeneration(fileName));\n        } catch (NumberFormatException ignore) {\n          // trash file: we have to handle this since codec regex is only so good\n        }\n        maxPerSegmentGen.put(segmentName, curGen);\n      }\n    }\n\n    // Generation is advanced before write:\n    infos.setGeneration(Math.max(infos.getGeneration(), maxSegmentGen));\n    if (infos.counter < 1+maxSegmentName) {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"init: inflate infos.counter to \" + (1+maxSegmentName) + \" vs current=\" + infos.counter);\n      }\n      infos.counter = 1+maxSegmentName;\n    }\n\n    for(SegmentCommitInfo info : infos) {\n      Long gen = maxPerSegmentGen.get(info.info.name);\n      assert gen != null;\n      long genLong = gen;\n      if (info.getNextWriteDelGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteDelGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteDelGen());\n        }\n        info.setNextWriteDelGen(genLong+1);\n      }\n      if (info.getNextWriteFieldInfosGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteFieldInfosGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteFieldInfosGen());\n        }\n        info.setNextWriteFieldInfosGen(genLong+1);\n      }\n      if (info.getNextWriteDocValuesGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteDocValuesGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteDocValuesGen());\n        }\n        info.setNextWriteDocValuesGen(genLong+1);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a6b82a3644db30161c3cbd3e23aeefe19cb88113","date":1435478870,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#inflateGens(SegmentInfos,Collection[String],InfoStream).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#inflateGens(SegmentInfos,Collection[String],InfoStream).mjava","sourceNew":"  /** Set all gens beyond what we currently see in the directory, to avoid double-write in cases where the previous IndexWriter did not\n   *  gracefully close/rollback (e.g. os/machine crashed or lost power). */\n  static void inflateGens(SegmentInfos infos, Collection<String> files, InfoStream infoStream) {\n\n    long maxSegmentGen = Long.MIN_VALUE;\n    int maxSegmentName = Integer.MIN_VALUE;\n\n    // Confusingly, this is the union of liveDocs, field infos, doc values\n    // (and maybe others, in the future) gens.  This is somewhat messy,\n    // since it means DV updates will suddenly write to the next gen after\n    // live docs' gen, for example, but we don't have the APIs to ask the\n    // codec which file is which:\n    Map<String,Long> maxPerSegmentGen = new HashMap<>();\n\n    for(String fileName : files) {\n      if (fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN) || fileName.equals(IndexWriter.WRITE_LOCK_NAME)) {\n        // do nothing\n      } else if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n        try {\n          maxSegmentGen = Math.max(SegmentInfos.generationFromSegmentsFileName(fileName), maxSegmentGen);\n        } catch (NumberFormatException ignore) {\n          // trash file: we have to handle this since we allow anything starting with 'segments' here\n        }\n      } else if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n        try {\n          maxSegmentGen = Math.max(SegmentInfos.generationFromSegmentsFileName(fileName.substring(8)), maxSegmentGen);\n        } catch (NumberFormatException ignore) {\n          // trash file: we have to handle this since we allow anything starting with 'pending_segments' here\n        }\n      } else {\n        String segmentName = IndexFileNames.parseSegmentName(fileName);\n        assert segmentName.startsWith(\"_\"): \"wtf? file=\" + fileName;\n\n        maxSegmentName = Math.max(maxSegmentName, Integer.parseInt(segmentName.substring(1), Character.MAX_RADIX));\n\n        Long curGen = maxPerSegmentGen.get(segmentName);\n        if (curGen == null) {\n          curGen = 0L;\n        }\n\n        try {\n          curGen = Math.max(curGen, IndexFileNames.parseGeneration(fileName));\n        } catch (NumberFormatException ignore) {\n          // trash file: we have to handle this since codec regex is only so good\n        }\n        maxPerSegmentGen.put(segmentName, curGen);\n      }\n    }\n\n    // Generation is advanced before write:\n    infos.setNextWriteGeneration(Math.max(infos.getGeneration(), maxSegmentGen));\n    if (infos.counter < 1+maxSegmentName) {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"init: inflate infos.counter to \" + (1+maxSegmentName) + \" vs current=\" + infos.counter);\n      }\n      infos.counter = 1+maxSegmentName;\n    }\n\n    for(SegmentCommitInfo info : infos) {\n      Long gen = maxPerSegmentGen.get(info.info.name);\n      assert gen != null;\n      long genLong = gen;\n      if (info.getNextWriteDelGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteDelGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteDelGen());\n        }\n        info.setNextWriteDelGen(genLong+1);\n      }\n      if (info.getNextWriteFieldInfosGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteFieldInfosGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteFieldInfosGen());\n        }\n        info.setNextWriteFieldInfosGen(genLong+1);\n      }\n      if (info.getNextWriteDocValuesGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteDocValuesGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteDocValuesGen());\n        }\n        info.setNextWriteDocValuesGen(genLong+1);\n      }\n    }\n  }\n\n","sourceOld":"  /** Set all gens beyond what we currently see in the directory, to avoid double-write in cases where the previous IndexWriter did not\n   *  gracefully close/rollback (e.g. os/machine crashed or lost power). */\n  static void inflateGens(SegmentInfos infos, Collection<String> files, InfoStream infoStream) {\n\n    long maxSegmentGen = Long.MIN_VALUE;\n    int maxSegmentName = Integer.MIN_VALUE;\n\n    // Confusingly, this is the union of liveDocs, field infos, doc values\n    // (and maybe others, in the future) gens.  This is somewhat messy,\n    // since it means DV updates will suddenly write to the next gen after\n    // live docs' gen, for example, but we don't have the APIs to ask the\n    // codec which file is which:\n    Map<String,Long> maxPerSegmentGen = new HashMap<>();\n\n    for(String fileName : files) {\n      if (fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN) || fileName.equals(IndexWriter.WRITE_LOCK_NAME)) {\n        // do nothing\n      } else if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n        try {\n          maxSegmentGen = Math.max(SegmentInfos.generationFromSegmentsFileName(fileName), maxSegmentGen);\n        } catch (NumberFormatException ignore) {\n          // trash file: we have to handle this since we allow anything starting with 'segments' here\n        }\n      } else if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n        try {\n          maxSegmentGen = Math.max(SegmentInfos.generationFromSegmentsFileName(fileName.substring(8)), maxSegmentGen);\n        } catch (NumberFormatException ignore) {\n          // trash file: we have to handle this since we allow anything starting with 'pending_segments' here\n        }\n      } else {\n        String segmentName = IndexFileNames.parseSegmentName(fileName);\n        assert segmentName.startsWith(\"_\"): \"wtf? file=\" + fileName;\n\n        maxSegmentName = Math.max(maxSegmentName, Integer.parseInt(segmentName.substring(1), Character.MAX_RADIX));\n\n        Long curGen = maxPerSegmentGen.get(segmentName);\n        if (curGen == null) {\n          curGen = 0L;\n        }\n\n        try {\n          curGen = Math.max(curGen, IndexFileNames.parseGeneration(fileName));\n        } catch (NumberFormatException ignore) {\n          // trash file: we have to handle this since codec regex is only so good\n        }\n        maxPerSegmentGen.put(segmentName, curGen);\n      }\n    }\n\n    // Generation is advanced before write:\n    infos.setGeneration(Math.max(infos.getGeneration(), maxSegmentGen));\n    if (infos.counter < 1+maxSegmentName) {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"init: inflate infos.counter to \" + (1+maxSegmentName) + \" vs current=\" + infos.counter);\n      }\n      infos.counter = 1+maxSegmentName;\n    }\n\n    for(SegmentCommitInfo info : infos) {\n      Long gen = maxPerSegmentGen.get(info.info.name);\n      assert gen != null;\n      long genLong = gen;\n      if (info.getNextWriteDelGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteDelGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteDelGen());\n        }\n        info.setNextWriteDelGen(genLong+1);\n      }\n      if (info.getNextWriteFieldInfosGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteFieldInfosGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteFieldInfosGen());\n        }\n        info.setNextWriteFieldInfosGen(genLong+1);\n      }\n      if (info.getNextWriteDocValuesGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteDocValuesGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteDocValuesGen());\n        }\n        info.setNextWriteDocValuesGen(genLong+1);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"57deae53907a4ece55c7e78d3aab19592ad083a5","date":1446894468,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#inflateGens(SegmentInfos,Collection[String],InfoStream).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#inflateGens(SegmentInfos,Collection[String],InfoStream).mjava","sourceNew":"  /** Set all gens beyond what we currently see in the directory, to avoid double-write in cases where the previous IndexWriter did not\n   *  gracefully close/rollback (e.g. os/machine crashed or lost power). */\n  static void inflateGens(SegmentInfos infos, Collection<String> files, InfoStream infoStream) {\n\n    long maxSegmentGen = Long.MIN_VALUE;\n    int maxSegmentName = Integer.MIN_VALUE;\n\n    // Confusingly, this is the union of liveDocs, field infos, doc values\n    // (and maybe others, in the future) gens.  This is somewhat messy,\n    // since it means DV updates will suddenly write to the next gen after\n    // live docs' gen, for example, but we don't have the APIs to ask the\n    // codec which file is which:\n    Map<String,Long> maxPerSegmentGen = new HashMap<>();\n\n    for(String fileName : files) {\n      if (fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN) || fileName.equals(IndexWriter.WRITE_LOCK_NAME)) {\n        // do nothing\n      } else if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n        try {\n          maxSegmentGen = Math.max(SegmentInfos.generationFromSegmentsFileName(fileName), maxSegmentGen);\n        } catch (NumberFormatException ignore) {\n          // trash file: we have to handle this since we allow anything starting with 'segments' here\n        }\n      } else if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n        try {\n          maxSegmentGen = Math.max(SegmentInfos.generationFromSegmentsFileName(fileName.substring(8)), maxSegmentGen);\n        } catch (NumberFormatException ignore) {\n          // trash file: we have to handle this since we allow anything starting with 'pending_segments' here\n        }\n      } else {\n        String segmentName = IndexFileNames.parseSegmentName(fileName);\n        assert segmentName.startsWith(\"_\"): \"wtf? file=\" + fileName;\n\n        if (fileName.toLowerCase(Locale.ROOT).endsWith(\".tmp\")) {\n          // A temp file: don't try to look at its gen\n          continue;\n        }\n\n        maxSegmentName = Math.max(maxSegmentName, Integer.parseInt(segmentName.substring(1), Character.MAX_RADIX));\n\n        Long curGen = maxPerSegmentGen.get(segmentName);\n        if (curGen == null) {\n          curGen = 0L;\n        }\n\n        try {\n          curGen = Math.max(curGen, IndexFileNames.parseGeneration(fileName));\n        } catch (NumberFormatException ignore) {\n          // trash file: we have to handle this since codec regex is only so good\n        }\n        maxPerSegmentGen.put(segmentName, curGen);\n      }\n    }\n\n    // Generation is advanced before write:\n    infos.setNextWriteGeneration(Math.max(infos.getGeneration(), maxSegmentGen));\n    if (infos.counter < 1+maxSegmentName) {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"init: inflate infos.counter to \" + (1+maxSegmentName) + \" vs current=\" + infos.counter);\n      }\n      infos.counter = 1+maxSegmentName;\n    }\n\n    for(SegmentCommitInfo info : infos) {\n      Long gen = maxPerSegmentGen.get(info.info.name);\n      assert gen != null;\n      long genLong = gen;\n      if (info.getNextWriteDelGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteDelGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteDelGen());\n        }\n        info.setNextWriteDelGen(genLong+1);\n      }\n      if (info.getNextWriteFieldInfosGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteFieldInfosGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteFieldInfosGen());\n        }\n        info.setNextWriteFieldInfosGen(genLong+1);\n      }\n      if (info.getNextWriteDocValuesGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteDocValuesGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteDocValuesGen());\n        }\n        info.setNextWriteDocValuesGen(genLong+1);\n      }\n    }\n  }\n\n","sourceOld":"  /** Set all gens beyond what we currently see in the directory, to avoid double-write in cases where the previous IndexWriter did not\n   *  gracefully close/rollback (e.g. os/machine crashed or lost power). */\n  static void inflateGens(SegmentInfos infos, Collection<String> files, InfoStream infoStream) {\n\n    long maxSegmentGen = Long.MIN_VALUE;\n    int maxSegmentName = Integer.MIN_VALUE;\n\n    // Confusingly, this is the union of liveDocs, field infos, doc values\n    // (and maybe others, in the future) gens.  This is somewhat messy,\n    // since it means DV updates will suddenly write to the next gen after\n    // live docs' gen, for example, but we don't have the APIs to ask the\n    // codec which file is which:\n    Map<String,Long> maxPerSegmentGen = new HashMap<>();\n\n    for(String fileName : files) {\n      if (fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN) || fileName.equals(IndexWriter.WRITE_LOCK_NAME)) {\n        // do nothing\n      } else if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n        try {\n          maxSegmentGen = Math.max(SegmentInfos.generationFromSegmentsFileName(fileName), maxSegmentGen);\n        } catch (NumberFormatException ignore) {\n          // trash file: we have to handle this since we allow anything starting with 'segments' here\n        }\n      } else if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n        try {\n          maxSegmentGen = Math.max(SegmentInfos.generationFromSegmentsFileName(fileName.substring(8)), maxSegmentGen);\n        } catch (NumberFormatException ignore) {\n          // trash file: we have to handle this since we allow anything starting with 'pending_segments' here\n        }\n      } else {\n        String segmentName = IndexFileNames.parseSegmentName(fileName);\n        assert segmentName.startsWith(\"_\"): \"wtf? file=\" + fileName;\n\n        maxSegmentName = Math.max(maxSegmentName, Integer.parseInt(segmentName.substring(1), Character.MAX_RADIX));\n\n        Long curGen = maxPerSegmentGen.get(segmentName);\n        if (curGen == null) {\n          curGen = 0L;\n        }\n\n        try {\n          curGen = Math.max(curGen, IndexFileNames.parseGeneration(fileName));\n        } catch (NumberFormatException ignore) {\n          // trash file: we have to handle this since codec regex is only so good\n        }\n        maxPerSegmentGen.put(segmentName, curGen);\n      }\n    }\n\n    // Generation is advanced before write:\n    infos.setNextWriteGeneration(Math.max(infos.getGeneration(), maxSegmentGen));\n    if (infos.counter < 1+maxSegmentName) {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"init: inflate infos.counter to \" + (1+maxSegmentName) + \" vs current=\" + infos.counter);\n      }\n      infos.counter = 1+maxSegmentName;\n    }\n\n    for(SegmentCommitInfo info : infos) {\n      Long gen = maxPerSegmentGen.get(info.info.name);\n      assert gen != null;\n      long genLong = gen;\n      if (info.getNextWriteDelGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteDelGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteDelGen());\n        }\n        info.setNextWriteDelGen(genLong+1);\n      }\n      if (info.getNextWriteFieldInfosGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteFieldInfosGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteFieldInfosGen());\n        }\n        info.setNextWriteFieldInfosGen(genLong+1);\n      }\n      if (info.getNextWriteDocValuesGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteDocValuesGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteDocValuesGen());\n        }\n        info.setNextWriteDocValuesGen(genLong+1);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0617d2d25b13b9a49450ea49ceb06123ebd6542a","date":1508865221,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#inflateGens(SegmentInfos,Collection[String],InfoStream).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#inflateGens(SegmentInfos,Collection[String],InfoStream).mjava","sourceNew":"  /** Set all gens beyond what we currently see in the directory, to avoid double-write in cases where the previous IndexWriter did not\n   *  gracefully close/rollback (e.g. os/machine crashed or lost power). */\n  static void inflateGens(SegmentInfos infos, Collection<String> files, InfoStream infoStream) {\n\n    long maxSegmentGen = Long.MIN_VALUE;\n    long maxSegmentName = Long.MIN_VALUE;\n\n    // Confusingly, this is the union of liveDocs, field infos, doc values\n    // (and maybe others, in the future) gens.  This is somewhat messy,\n    // since it means DV updates will suddenly write to the next gen after\n    // live docs' gen, for example, but we don't have the APIs to ask the\n    // codec which file is which:\n    Map<String,Long> maxPerSegmentGen = new HashMap<>();\n\n    for(String fileName : files) {\n      if (fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN) || fileName.equals(IndexWriter.WRITE_LOCK_NAME)) {\n        // do nothing\n      } else if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n        try {\n          maxSegmentGen = Math.max(SegmentInfos.generationFromSegmentsFileName(fileName), maxSegmentGen);\n        } catch (NumberFormatException ignore) {\n          // trash file: we have to handle this since we allow anything starting with 'segments' here\n        }\n      } else if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n        try {\n          maxSegmentGen = Math.max(SegmentInfos.generationFromSegmentsFileName(fileName.substring(8)), maxSegmentGen);\n        } catch (NumberFormatException ignore) {\n          // trash file: we have to handle this since we allow anything starting with 'pending_segments' here\n        }\n      } else {\n        String segmentName = IndexFileNames.parseSegmentName(fileName);\n        assert segmentName.startsWith(\"_\"): \"wtf? file=\" + fileName;\n\n        if (fileName.toLowerCase(Locale.ROOT).endsWith(\".tmp\")) {\n          // A temp file: don't try to look at its gen\n          continue;\n        }\n\n        maxSegmentName = Math.max(maxSegmentName, Long.parseLong(segmentName.substring(1), Character.MAX_RADIX));\n\n        Long curGen = maxPerSegmentGen.get(segmentName);\n        if (curGen == null) {\n          curGen = 0L;\n        }\n\n        try {\n          curGen = Math.max(curGen, IndexFileNames.parseGeneration(fileName));\n        } catch (NumberFormatException ignore) {\n          // trash file: we have to handle this since codec regex is only so good\n        }\n        maxPerSegmentGen.put(segmentName, curGen);\n      }\n    }\n\n    // Generation is advanced before write:\n    infos.setNextWriteGeneration(Math.max(infos.getGeneration(), maxSegmentGen));\n    if (infos.counter < 1+maxSegmentName) {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"init: inflate infos.counter to \" + (1+maxSegmentName) + \" vs current=\" + infos.counter);\n      }\n      infos.counter = 1+maxSegmentName;\n    }\n\n    for(SegmentCommitInfo info : infos) {\n      Long gen = maxPerSegmentGen.get(info.info.name);\n      assert gen != null;\n      long genLong = gen;\n      if (info.getNextWriteDelGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteDelGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteDelGen());\n        }\n        info.setNextWriteDelGen(genLong+1);\n      }\n      if (info.getNextWriteFieldInfosGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteFieldInfosGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteFieldInfosGen());\n        }\n        info.setNextWriteFieldInfosGen(genLong+1);\n      }\n      if (info.getNextWriteDocValuesGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteDocValuesGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteDocValuesGen());\n        }\n        info.setNextWriteDocValuesGen(genLong+1);\n      }\n    }\n  }\n\n","sourceOld":"  /** Set all gens beyond what we currently see in the directory, to avoid double-write in cases where the previous IndexWriter did not\n   *  gracefully close/rollback (e.g. os/machine crashed or lost power). */\n  static void inflateGens(SegmentInfos infos, Collection<String> files, InfoStream infoStream) {\n\n    long maxSegmentGen = Long.MIN_VALUE;\n    int maxSegmentName = Integer.MIN_VALUE;\n\n    // Confusingly, this is the union of liveDocs, field infos, doc values\n    // (and maybe others, in the future) gens.  This is somewhat messy,\n    // since it means DV updates will suddenly write to the next gen after\n    // live docs' gen, for example, but we don't have the APIs to ask the\n    // codec which file is which:\n    Map<String,Long> maxPerSegmentGen = new HashMap<>();\n\n    for(String fileName : files) {\n      if (fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN) || fileName.equals(IndexWriter.WRITE_LOCK_NAME)) {\n        // do nothing\n      } else if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n        try {\n          maxSegmentGen = Math.max(SegmentInfos.generationFromSegmentsFileName(fileName), maxSegmentGen);\n        } catch (NumberFormatException ignore) {\n          // trash file: we have to handle this since we allow anything starting with 'segments' here\n        }\n      } else if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n        try {\n          maxSegmentGen = Math.max(SegmentInfos.generationFromSegmentsFileName(fileName.substring(8)), maxSegmentGen);\n        } catch (NumberFormatException ignore) {\n          // trash file: we have to handle this since we allow anything starting with 'pending_segments' here\n        }\n      } else {\n        String segmentName = IndexFileNames.parseSegmentName(fileName);\n        assert segmentName.startsWith(\"_\"): \"wtf? file=\" + fileName;\n\n        if (fileName.toLowerCase(Locale.ROOT).endsWith(\".tmp\")) {\n          // A temp file: don't try to look at its gen\n          continue;\n        }\n\n        maxSegmentName = Math.max(maxSegmentName, Integer.parseInt(segmentName.substring(1), Character.MAX_RADIX));\n\n        Long curGen = maxPerSegmentGen.get(segmentName);\n        if (curGen == null) {\n          curGen = 0L;\n        }\n\n        try {\n          curGen = Math.max(curGen, IndexFileNames.parseGeneration(fileName));\n        } catch (NumberFormatException ignore) {\n          // trash file: we have to handle this since codec regex is only so good\n        }\n        maxPerSegmentGen.put(segmentName, curGen);\n      }\n    }\n\n    // Generation is advanced before write:\n    infos.setNextWriteGeneration(Math.max(infos.getGeneration(), maxSegmentGen));\n    if (infos.counter < 1+maxSegmentName) {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"init: inflate infos.counter to \" + (1+maxSegmentName) + \" vs current=\" + infos.counter);\n      }\n      infos.counter = 1+maxSegmentName;\n    }\n\n    for(SegmentCommitInfo info : infos) {\n      Long gen = maxPerSegmentGen.get(info.info.name);\n      assert gen != null;\n      long genLong = gen;\n      if (info.getNextWriteDelGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteDelGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteDelGen());\n        }\n        info.setNextWriteDelGen(genLong+1);\n      }\n      if (info.getNextWriteFieldInfosGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteFieldInfosGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteFieldInfosGen());\n        }\n        info.setNextWriteFieldInfosGen(genLong+1);\n      }\n      if (info.getNextWriteDocValuesGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteDocValuesGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteDocValuesGen());\n        }\n        info.setNextWriteDocValuesGen(genLong+1);\n      }\n    }\n  }\n\n","bugFix":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7166881391ea0f64d02756406371ce34719e4e8","date":1567583487,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#inflateGens(SegmentInfos,Collection[String],InfoStream).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#inflateGens(SegmentInfos,Collection[String],InfoStream).mjava","sourceNew":"  /** Set all gens beyond what we currently see in the directory, to avoid double-write in cases where the previous IndexWriter did not\n   *  gracefully close/rollback (e.g. os/machine crashed or lost power). */\n  static void inflateGens(SegmentInfos infos, Collection<String> files, InfoStream infoStream) {\n\n    long maxSegmentGen = Long.MIN_VALUE;\n    long maxSegmentName = Long.MIN_VALUE;\n\n    // Confusingly, this is the union of liveDocs, field infos, doc values\n    // (and maybe others, in the future) gens.  This is somewhat messy,\n    // since it means DV updates will suddenly write to the next gen after\n    // live docs' gen, for example, but we don't have the APIs to ask the\n    // codec which file is which:\n    Map<String,Long> maxPerSegmentGen = new HashMap<>();\n\n    for(String fileName : files) {\n      if (fileName.equals(IndexWriter.WRITE_LOCK_NAME)) {\n        // do nothing\n      } else if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n        try {\n          maxSegmentGen = Math.max(SegmentInfos.generationFromSegmentsFileName(fileName), maxSegmentGen);\n        } catch (NumberFormatException ignore) {\n          // trash file: we have to handle this since we allow anything starting with 'segments' here\n        }\n      } else if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n        try {\n          maxSegmentGen = Math.max(SegmentInfos.generationFromSegmentsFileName(fileName.substring(8)), maxSegmentGen);\n        } catch (NumberFormatException ignore) {\n          // trash file: we have to handle this since we allow anything starting with 'pending_segments' here\n        }\n      } else {\n        String segmentName = IndexFileNames.parseSegmentName(fileName);\n        assert segmentName.startsWith(\"_\"): \"wtf? file=\" + fileName;\n\n        if (fileName.toLowerCase(Locale.ROOT).endsWith(\".tmp\")) {\n          // A temp file: don't try to look at its gen\n          continue;\n        }\n\n        maxSegmentName = Math.max(maxSegmentName, Long.parseLong(segmentName.substring(1), Character.MAX_RADIX));\n\n        Long curGen = maxPerSegmentGen.get(segmentName);\n        if (curGen == null) {\n          curGen = 0L;\n        }\n\n        try {\n          curGen = Math.max(curGen, IndexFileNames.parseGeneration(fileName));\n        } catch (NumberFormatException ignore) {\n          // trash file: we have to handle this since codec regex is only so good\n        }\n        maxPerSegmentGen.put(segmentName, curGen);\n      }\n    }\n\n    // Generation is advanced before write:\n    infos.setNextWriteGeneration(Math.max(infos.getGeneration(), maxSegmentGen));\n    if (infos.counter < 1+maxSegmentName) {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"init: inflate infos.counter to \" + (1+maxSegmentName) + \" vs current=\" + infos.counter);\n      }\n      infos.counter = 1+maxSegmentName;\n    }\n\n    for(SegmentCommitInfo info : infos) {\n      Long gen = maxPerSegmentGen.get(info.info.name);\n      assert gen != null;\n      long genLong = gen;\n      if (info.getNextWriteDelGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteDelGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteDelGen());\n        }\n        info.setNextWriteDelGen(genLong+1);\n      }\n      if (info.getNextWriteFieldInfosGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteFieldInfosGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteFieldInfosGen());\n        }\n        info.setNextWriteFieldInfosGen(genLong+1);\n      }\n      if (info.getNextWriteDocValuesGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteDocValuesGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteDocValuesGen());\n        }\n        info.setNextWriteDocValuesGen(genLong+1);\n      }\n    }\n  }\n\n","sourceOld":"  /** Set all gens beyond what we currently see in the directory, to avoid double-write in cases where the previous IndexWriter did not\n   *  gracefully close/rollback (e.g. os/machine crashed or lost power). */\n  static void inflateGens(SegmentInfos infos, Collection<String> files, InfoStream infoStream) {\n\n    long maxSegmentGen = Long.MIN_VALUE;\n    long maxSegmentName = Long.MIN_VALUE;\n\n    // Confusingly, this is the union of liveDocs, field infos, doc values\n    // (and maybe others, in the future) gens.  This is somewhat messy,\n    // since it means DV updates will suddenly write to the next gen after\n    // live docs' gen, for example, but we don't have the APIs to ask the\n    // codec which file is which:\n    Map<String,Long> maxPerSegmentGen = new HashMap<>();\n\n    for(String fileName : files) {\n      if (fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN) || fileName.equals(IndexWriter.WRITE_LOCK_NAME)) {\n        // do nothing\n      } else if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n        try {\n          maxSegmentGen = Math.max(SegmentInfos.generationFromSegmentsFileName(fileName), maxSegmentGen);\n        } catch (NumberFormatException ignore) {\n          // trash file: we have to handle this since we allow anything starting with 'segments' here\n        }\n      } else if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n        try {\n          maxSegmentGen = Math.max(SegmentInfos.generationFromSegmentsFileName(fileName.substring(8)), maxSegmentGen);\n        } catch (NumberFormatException ignore) {\n          // trash file: we have to handle this since we allow anything starting with 'pending_segments' here\n        }\n      } else {\n        String segmentName = IndexFileNames.parseSegmentName(fileName);\n        assert segmentName.startsWith(\"_\"): \"wtf? file=\" + fileName;\n\n        if (fileName.toLowerCase(Locale.ROOT).endsWith(\".tmp\")) {\n          // A temp file: don't try to look at its gen\n          continue;\n        }\n\n        maxSegmentName = Math.max(maxSegmentName, Long.parseLong(segmentName.substring(1), Character.MAX_RADIX));\n\n        Long curGen = maxPerSegmentGen.get(segmentName);\n        if (curGen == null) {\n          curGen = 0L;\n        }\n\n        try {\n          curGen = Math.max(curGen, IndexFileNames.parseGeneration(fileName));\n        } catch (NumberFormatException ignore) {\n          // trash file: we have to handle this since codec regex is only so good\n        }\n        maxPerSegmentGen.put(segmentName, curGen);\n      }\n    }\n\n    // Generation is advanced before write:\n    infos.setNextWriteGeneration(Math.max(infos.getGeneration(), maxSegmentGen));\n    if (infos.counter < 1+maxSegmentName) {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"init: inflate infos.counter to \" + (1+maxSegmentName) + \" vs current=\" + infos.counter);\n      }\n      infos.counter = 1+maxSegmentName;\n    }\n\n    for(SegmentCommitInfo info : infos) {\n      Long gen = maxPerSegmentGen.get(info.info.name);\n      assert gen != null;\n      long genLong = gen;\n      if (info.getNextWriteDelGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteDelGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteDelGen());\n        }\n        info.setNextWriteDelGen(genLong+1);\n      }\n      if (info.getNextWriteFieldInfosGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteFieldInfosGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteFieldInfosGen());\n        }\n        info.setNextWriteFieldInfosGen(genLong+1);\n      }\n      if (info.getNextWriteDocValuesGen() < genLong+1) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: seg=\" + info.info.name + \" set nextWriteDocValuesGen=\" + (genLong+1) + \" vs current=\" + info.getNextWriteDocValuesGen());\n        }\n        info.setNextWriteDocValuesGen(genLong+1);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"46e4a8bdfbafda795ef9c39a2bc2d47095770299":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"],"57deae53907a4ece55c7e78d3aab19592ad083a5":["a6b82a3644db30161c3cbd3e23aeefe19cb88113"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f7166881391ea0f64d02756406371ce34719e4e8":["0617d2d25b13b9a49450ea49ceb06123ebd6542a"],"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a6b82a3644db30161c3cbd3e23aeefe19cb88113":["46e4a8bdfbafda795ef9c39a2bc2d47095770299"],"0617d2d25b13b9a49450ea49ceb06123ebd6542a":["57deae53907a4ece55c7e78d3aab19592ad083a5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f7166881391ea0f64d02756406371ce34719e4e8"]},"commit2Childs":{"46e4a8bdfbafda795ef9c39a2bc2d47095770299":["a6b82a3644db30161c3cbd3e23aeefe19cb88113"],"57deae53907a4ece55c7e78d3aab19592ad083a5":["0617d2d25b13b9a49450ea49ceb06123ebd6542a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"],"f7166881391ea0f64d02756406371ce34719e4e8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13":["46e4a8bdfbafda795ef9c39a2bc2d47095770299"],"a6b82a3644db30161c3cbd3e23aeefe19cb88113":["57deae53907a4ece55c7e78d3aab19592ad083a5"],"0617d2d25b13b9a49450ea49ceb06123ebd6542a":["f7166881391ea0f64d02756406371ce34719e4e8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}