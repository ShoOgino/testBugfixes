{"path":"lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose#testCloseUnderException().mjava","commits":[{"id":"6f8a4ddee78d8bc3c8c736c1cdb130b94cde0b89","date":1395763949,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose#testCloseUnderException().mjava","pathOld":"/dev/null","sourceNew":"  public void testCloseUnderException() throws IOException {\n    final int iters = 1000 +  1 + random().nextInt(20);\n    for (int j = 0; j < iters; j++) {\n      Directory dir = newDirectory();\n      IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(random(), TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n      writer.commit();\n      writer.close();\n      DirectoryReader open = DirectoryReader.open(dir);\n      final boolean throwOnClose = !rarely();\n      AtomicReader wrap = SlowCompositeReaderWrapper.wrap(open);\n      FilterAtomicReader reader = new FilterAtomicReader(wrap) {\n        @Override\n        protected void doClose() throws IOException {\n          super.doClose();\n          if (throwOnClose) {\n           throw new IllegalStateException(\"BOOM!\");\n          }\n        }\n      };\n      List<IndexReader.ReaderClosedListener> listeners = new ArrayList<>();\n      int listenerCount = random().nextInt(20);\n      AtomicInteger count = new AtomicInteger();\n      boolean faultySet = false;\n      for (int i = 0; i < listenerCount; i++) {\n          if (rarely()) {\n            faultySet = true;\n            reader.addReaderClosedListener(new FaultyListener());\n          } else {\n            count.incrementAndGet();\n            reader.addReaderClosedListener(new CountListener(count));\n          }\n      }\n      if (!faultySet && !throwOnClose) {\n        reader.addReaderClosedListener(new FaultyListener());\n      }\n      try {\n        reader.close();\n        fail(\"expected Exception\");\n      } catch (IllegalStateException ex) {\n        if (throwOnClose) {\n          assertEquals(\"BOOM!\", ex.getMessage());\n        } else {\n          assertEquals(\"GRRRRRRRRRRRR!\", ex.getMessage());\n        }\n      }\n\n      try {\n        reader.fields();\n        fail(\"we are closed\");\n      } catch (AlreadyClosedException ex) {\n      }\n\n      if (random().nextBoolean()) {\n        reader.close(); // call it again\n      }\n      assertEquals(0, count.get());\n      wrap.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1","05fe562aa248790944d43cdd478f512572835ba0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose#testCloseUnderException().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose#testCloseUnderException().mjava","sourceNew":"  public void testCloseUnderException() throws IOException {\n    final int iters = 1000 +  1 + random().nextInt(20);\n    for (int j = 0; j < iters; j++) {\n      Directory dir = newDirectory();\n      IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(random(), TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n      writer.commit();\n      writer.shutdown();\n      DirectoryReader open = DirectoryReader.open(dir);\n      final boolean throwOnClose = !rarely();\n      AtomicReader wrap = SlowCompositeReaderWrapper.wrap(open);\n      FilterAtomicReader reader = new FilterAtomicReader(wrap) {\n        @Override\n        protected void doClose() throws IOException {\n          super.doClose();\n          if (throwOnClose) {\n           throw new IllegalStateException(\"BOOM!\");\n          }\n        }\n      };\n      List<IndexReader.ReaderClosedListener> listeners = new ArrayList<>();\n      int listenerCount = random().nextInt(20);\n      AtomicInteger count = new AtomicInteger();\n      boolean faultySet = false;\n      for (int i = 0; i < listenerCount; i++) {\n          if (rarely()) {\n            faultySet = true;\n            reader.addReaderClosedListener(new FaultyListener());\n          } else {\n            count.incrementAndGet();\n            reader.addReaderClosedListener(new CountListener(count));\n          }\n      }\n      if (!faultySet && !throwOnClose) {\n        reader.addReaderClosedListener(new FaultyListener());\n      }\n      try {\n        reader.close();\n        fail(\"expected Exception\");\n      } catch (IllegalStateException ex) {\n        if (throwOnClose) {\n          assertEquals(\"BOOM!\", ex.getMessage());\n        } else {\n          assertEquals(\"GRRRRRRRRRRRR!\", ex.getMessage());\n        }\n      }\n\n      try {\n        reader.fields();\n        fail(\"we are closed\");\n      } catch (AlreadyClosedException ex) {\n      }\n\n      if (random().nextBoolean()) {\n        reader.close(); // call it again\n      }\n      assertEquals(0, count.get());\n      wrap.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testCloseUnderException() throws IOException {\n    final int iters = 1000 +  1 + random().nextInt(20);\n    for (int j = 0; j < iters; j++) {\n      Directory dir = newDirectory();\n      IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(random(), TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n      writer.commit();\n      writer.close();\n      DirectoryReader open = DirectoryReader.open(dir);\n      final boolean throwOnClose = !rarely();\n      AtomicReader wrap = SlowCompositeReaderWrapper.wrap(open);\n      FilterAtomicReader reader = new FilterAtomicReader(wrap) {\n        @Override\n        protected void doClose() throws IOException {\n          super.doClose();\n          if (throwOnClose) {\n           throw new IllegalStateException(\"BOOM!\");\n          }\n        }\n      };\n      List<IndexReader.ReaderClosedListener> listeners = new ArrayList<>();\n      int listenerCount = random().nextInt(20);\n      AtomicInteger count = new AtomicInteger();\n      boolean faultySet = false;\n      for (int i = 0; i < listenerCount; i++) {\n          if (rarely()) {\n            faultySet = true;\n            reader.addReaderClosedListener(new FaultyListener());\n          } else {\n            count.incrementAndGet();\n            reader.addReaderClosedListener(new CountListener(count));\n          }\n      }\n      if (!faultySet && !throwOnClose) {\n        reader.addReaderClosedListener(new FaultyListener());\n      }\n      try {\n        reader.close();\n        fail(\"expected Exception\");\n      } catch (IllegalStateException ex) {\n        if (throwOnClose) {\n          assertEquals(\"BOOM!\", ex.getMessage());\n        } else {\n          assertEquals(\"GRRRRRRRRRRRR!\", ex.getMessage());\n        }\n      }\n\n      try {\n        reader.fields();\n        fail(\"we are closed\");\n      } catch (AlreadyClosedException ex) {\n      }\n\n      if (random().nextBoolean()) {\n        reader.close(); // call it again\n      }\n      assertEquals(0, count.get());\n      wrap.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7704e64a78bc9f245268f5c002d1e66b6c9f309f","date":1400878491,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose#testCloseUnderException().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose#testCloseUnderException().mjava","sourceNew":"  public void testCloseUnderException() throws IOException {\n    final int iters = 1000 +  1 + random().nextInt(20);\n    for (int j = 0; j < iters; j++) {\n      Directory dir = newDirectory();\n      IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(random(), TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n      writer.commit();\n      writer.shutdown();\n      DirectoryReader open = DirectoryReader.open(dir);\n      final boolean throwOnClose = !rarely();\n      AtomicReader wrap = SlowCompositeReaderWrapper.wrap(open);\n      FilterAtomicReader reader = new FilterAtomicReader(wrap) {\n        @Override\n        protected void doClose() throws IOException {\n          super.doClose();\n          if (throwOnClose) {\n           throw new IllegalStateException(\"BOOM!\");\n          }\n        }\n      };\n      int listenerCount = random().nextInt(20);\n      AtomicInteger count = new AtomicInteger();\n      boolean faultySet = false;\n      for (int i = 0; i < listenerCount; i++) {\n          if (rarely()) {\n            faultySet = true;\n            reader.addReaderClosedListener(new FaultyListener());\n          } else {\n            count.incrementAndGet();\n            reader.addReaderClosedListener(new CountListener(count));\n          }\n      }\n      if (!faultySet && !throwOnClose) {\n        reader.addReaderClosedListener(new FaultyListener());\n      }\n      try {\n        reader.close();\n        fail(\"expected Exception\");\n      } catch (IllegalStateException ex) {\n        if (throwOnClose) {\n          assertEquals(\"BOOM!\", ex.getMessage());\n        } else {\n          assertEquals(\"GRRRRRRRRRRRR!\", ex.getMessage());\n        }\n      }\n\n      try {\n        reader.fields();\n        fail(\"we are closed\");\n      } catch (AlreadyClosedException ex) {\n      }\n\n      if (random().nextBoolean()) {\n        reader.close(); // call it again\n      }\n      assertEquals(0, count.get());\n      wrap.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testCloseUnderException() throws IOException {\n    final int iters = 1000 +  1 + random().nextInt(20);\n    for (int j = 0; j < iters; j++) {\n      Directory dir = newDirectory();\n      IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(random(), TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n      writer.commit();\n      writer.shutdown();\n      DirectoryReader open = DirectoryReader.open(dir);\n      final boolean throwOnClose = !rarely();\n      AtomicReader wrap = SlowCompositeReaderWrapper.wrap(open);\n      FilterAtomicReader reader = new FilterAtomicReader(wrap) {\n        @Override\n        protected void doClose() throws IOException {\n          super.doClose();\n          if (throwOnClose) {\n           throw new IllegalStateException(\"BOOM!\");\n          }\n        }\n      };\n      List<IndexReader.ReaderClosedListener> listeners = new ArrayList<>();\n      int listenerCount = random().nextInt(20);\n      AtomicInteger count = new AtomicInteger();\n      boolean faultySet = false;\n      for (int i = 0; i < listenerCount; i++) {\n          if (rarely()) {\n            faultySet = true;\n            reader.addReaderClosedListener(new FaultyListener());\n          } else {\n            count.incrementAndGet();\n            reader.addReaderClosedListener(new CountListener(count));\n          }\n      }\n      if (!faultySet && !throwOnClose) {\n        reader.addReaderClosedListener(new FaultyListener());\n      }\n      try {\n        reader.close();\n        fail(\"expected Exception\");\n      } catch (IllegalStateException ex) {\n        if (throwOnClose) {\n          assertEquals(\"BOOM!\", ex.getMessage());\n        } else {\n          assertEquals(\"GRRRRRRRRRRRR!\", ex.getMessage());\n        }\n      }\n\n      try {\n        reader.fields();\n        fail(\"we are closed\");\n      } catch (AlreadyClosedException ex) {\n      }\n\n      if (random().nextBoolean()) {\n        reader.close(); // call it again\n      }\n      assertEquals(0, count.get());\n      wrap.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose#testCloseUnderException().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose#testCloseUnderException().mjava","sourceNew":"  public void testCloseUnderException() throws IOException {\n    final int iters = 1000 +  1 + random().nextInt(20);\n    for (int j = 0; j < iters; j++) {\n      Directory dir = newDirectory();\n      IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(random(), new MockAnalyzer(random())));\n      writer.commit();\n      writer.close();\n      DirectoryReader open = DirectoryReader.open(dir);\n      final boolean throwOnClose = !rarely();\n      AtomicReader wrap = SlowCompositeReaderWrapper.wrap(open);\n      FilterAtomicReader reader = new FilterAtomicReader(wrap) {\n        @Override\n        protected void doClose() throws IOException {\n          super.doClose();\n          if (throwOnClose) {\n           throw new IllegalStateException(\"BOOM!\");\n          }\n        }\n      };\n      int listenerCount = random().nextInt(20);\n      AtomicInteger count = new AtomicInteger();\n      boolean faultySet = false;\n      for (int i = 0; i < listenerCount; i++) {\n          if (rarely()) {\n            faultySet = true;\n            reader.addReaderClosedListener(new FaultyListener());\n          } else {\n            count.incrementAndGet();\n            reader.addReaderClosedListener(new CountListener(count));\n          }\n      }\n      if (!faultySet && !throwOnClose) {\n        reader.addReaderClosedListener(new FaultyListener());\n      }\n      try {\n        reader.close();\n        fail(\"expected Exception\");\n      } catch (IllegalStateException ex) {\n        if (throwOnClose) {\n          assertEquals(\"BOOM!\", ex.getMessage());\n        } else {\n          assertEquals(\"GRRRRRRRRRRRR!\", ex.getMessage());\n        }\n      }\n\n      try {\n        reader.fields();\n        fail(\"we are closed\");\n      } catch (AlreadyClosedException ex) {\n      }\n\n      if (random().nextBoolean()) {\n        reader.close(); // call it again\n      }\n      assertEquals(0, count.get());\n      wrap.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testCloseUnderException() throws IOException {\n    final int iters = 1000 +  1 + random().nextInt(20);\n    for (int j = 0; j < iters; j++) {\n      Directory dir = newDirectory();\n      IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(random(), TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n      writer.commit();\n      writer.shutdown();\n      DirectoryReader open = DirectoryReader.open(dir);\n      final boolean throwOnClose = !rarely();\n      AtomicReader wrap = SlowCompositeReaderWrapper.wrap(open);\n      FilterAtomicReader reader = new FilterAtomicReader(wrap) {\n        @Override\n        protected void doClose() throws IOException {\n          super.doClose();\n          if (throwOnClose) {\n           throw new IllegalStateException(\"BOOM!\");\n          }\n        }\n      };\n      int listenerCount = random().nextInt(20);\n      AtomicInteger count = new AtomicInteger();\n      boolean faultySet = false;\n      for (int i = 0; i < listenerCount; i++) {\n          if (rarely()) {\n            faultySet = true;\n            reader.addReaderClosedListener(new FaultyListener());\n          } else {\n            count.incrementAndGet();\n            reader.addReaderClosedListener(new CountListener(count));\n          }\n      }\n      if (!faultySet && !throwOnClose) {\n        reader.addReaderClosedListener(new FaultyListener());\n      }\n      try {\n        reader.close();\n        fail(\"expected Exception\");\n      } catch (IllegalStateException ex) {\n        if (throwOnClose) {\n          assertEquals(\"BOOM!\", ex.getMessage());\n        } else {\n          assertEquals(\"GRRRRRRRRRRRR!\", ex.getMessage());\n        }\n      }\n\n      try {\n        reader.fields();\n        fail(\"we are closed\");\n      } catch (AlreadyClosedException ex) {\n      }\n\n      if (random().nextBoolean()) {\n        reader.close(); // call it again\n      }\n      assertEquals(0, count.get());\n      wrap.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose#testCloseUnderException().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose#testCloseUnderException().mjava","sourceNew":"  public void testCloseUnderException() throws IOException {\n    final int iters = 1000 +  1 + random().nextInt(20);\n    for (int j = 0; j < iters; j++) {\n      Directory dir = newDirectory();\n      IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(random(), new MockAnalyzer(random())));\n      writer.commit();\n      writer.close();\n      DirectoryReader open = DirectoryReader.open(dir);\n      final boolean throwOnClose = !rarely();\n      LeafReader wrap = SlowCompositeReaderWrapper.wrap(open);\n      FilterLeafReader reader = new FilterLeafReader(wrap) {\n        @Override\n        protected void doClose() throws IOException {\n          super.doClose();\n          if (throwOnClose) {\n           throw new IllegalStateException(\"BOOM!\");\n          }\n        }\n      };\n      int listenerCount = random().nextInt(20);\n      AtomicInteger count = new AtomicInteger();\n      boolean faultySet = false;\n      for (int i = 0; i < listenerCount; i++) {\n          if (rarely()) {\n            faultySet = true;\n            reader.addReaderClosedListener(new FaultyListener());\n          } else {\n            count.incrementAndGet();\n            reader.addReaderClosedListener(new CountListener(count));\n          }\n      }\n      if (!faultySet && !throwOnClose) {\n        reader.addReaderClosedListener(new FaultyListener());\n      }\n      try {\n        reader.close();\n        fail(\"expected Exception\");\n      } catch (IllegalStateException ex) {\n        if (throwOnClose) {\n          assertEquals(\"BOOM!\", ex.getMessage());\n        } else {\n          assertEquals(\"GRRRRRRRRRRRR!\", ex.getMessage());\n        }\n      }\n\n      try {\n        reader.fields();\n        fail(\"we are closed\");\n      } catch (AlreadyClosedException ex) {\n      }\n\n      if (random().nextBoolean()) {\n        reader.close(); // call it again\n      }\n      assertEquals(0, count.get());\n      wrap.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testCloseUnderException() throws IOException {\n    final int iters = 1000 +  1 + random().nextInt(20);\n    for (int j = 0; j < iters; j++) {\n      Directory dir = newDirectory();\n      IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(random(), new MockAnalyzer(random())));\n      writer.commit();\n      writer.close();\n      DirectoryReader open = DirectoryReader.open(dir);\n      final boolean throwOnClose = !rarely();\n      AtomicReader wrap = SlowCompositeReaderWrapper.wrap(open);\n      FilterAtomicReader reader = new FilterAtomicReader(wrap) {\n        @Override\n        protected void doClose() throws IOException {\n          super.doClose();\n          if (throwOnClose) {\n           throw new IllegalStateException(\"BOOM!\");\n          }\n        }\n      };\n      int listenerCount = random().nextInt(20);\n      AtomicInteger count = new AtomicInteger();\n      boolean faultySet = false;\n      for (int i = 0; i < listenerCount; i++) {\n          if (rarely()) {\n            faultySet = true;\n            reader.addReaderClosedListener(new FaultyListener());\n          } else {\n            count.incrementAndGet();\n            reader.addReaderClosedListener(new CountListener(count));\n          }\n      }\n      if (!faultySet && !throwOnClose) {\n        reader.addReaderClosedListener(new FaultyListener());\n      }\n      try {\n        reader.close();\n        fail(\"expected Exception\");\n      } catch (IllegalStateException ex) {\n        if (throwOnClose) {\n          assertEquals(\"BOOM!\", ex.getMessage());\n        } else {\n          assertEquals(\"GRRRRRRRRRRRR!\", ex.getMessage());\n        }\n      }\n\n      try {\n        reader.fields();\n        fail(\"we are closed\");\n      } catch (AlreadyClosedException ex) {\n      }\n\n      if (random().nextBoolean()) {\n        reader.close(); // call it again\n      }\n      assertEquals(0, count.get());\n      wrap.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a87ce200bba7d88024e2f1c4012212072ce8a5ae","date":1417031281,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose#testCloseUnderException().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose#testCloseUnderException().mjava","sourceNew":"  public void testCloseUnderException() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(random(), new MockAnalyzer(random())));\n    writer.commit();\n    writer.close();\n    final int iters = 1000 +  1 + random().nextInt(20);\n    for (int j = 0; j < iters; j++) {\n      DirectoryReader open = DirectoryReader.open(dir);\n      final boolean throwOnClose = !rarely();\n      LeafReader wrap = SlowCompositeReaderWrapper.wrap(open);\n      FilterLeafReader reader = new FilterLeafReader(wrap) {\n        @Override\n        protected void doClose() throws IOException {\n          super.doClose();\n          if (throwOnClose) {\n           throw new IllegalStateException(\"BOOM!\");\n          }\n        }\n      };\n      int listenerCount = random().nextInt(20);\n      AtomicInteger count = new AtomicInteger();\n      boolean faultySet = false;\n      for (int i = 0; i < listenerCount; i++) {\n          if (rarely()) {\n            faultySet = true;\n            reader.addReaderClosedListener(new FaultyListener());\n          } else {\n            count.incrementAndGet();\n            reader.addReaderClosedListener(new CountListener(count));\n          }\n      }\n      if (!faultySet && !throwOnClose) {\n        reader.addReaderClosedListener(new FaultyListener());\n      }\n      try {\n        reader.close();\n        fail(\"expected Exception\");\n      } catch (IllegalStateException ex) {\n        if (throwOnClose) {\n          assertEquals(\"BOOM!\", ex.getMessage());\n        } else {\n          assertEquals(\"GRRRRRRRRRRRR!\", ex.getMessage());\n        }\n      }\n\n      try {\n        reader.fields();\n        fail(\"we are closed\");\n      } catch (AlreadyClosedException ex) {\n      }\n\n      if (random().nextBoolean()) {\n        reader.close(); // call it again\n      }\n      assertEquals(0, count.get());\n      wrap.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testCloseUnderException() throws IOException {\n    final int iters = 1000 +  1 + random().nextInt(20);\n    for (int j = 0; j < iters; j++) {\n      Directory dir = newDirectory();\n      IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(random(), new MockAnalyzer(random())));\n      writer.commit();\n      writer.close();\n      DirectoryReader open = DirectoryReader.open(dir);\n      final boolean throwOnClose = !rarely();\n      LeafReader wrap = SlowCompositeReaderWrapper.wrap(open);\n      FilterLeafReader reader = new FilterLeafReader(wrap) {\n        @Override\n        protected void doClose() throws IOException {\n          super.doClose();\n          if (throwOnClose) {\n           throw new IllegalStateException(\"BOOM!\");\n          }\n        }\n      };\n      int listenerCount = random().nextInt(20);\n      AtomicInteger count = new AtomicInteger();\n      boolean faultySet = false;\n      for (int i = 0; i < listenerCount; i++) {\n          if (rarely()) {\n            faultySet = true;\n            reader.addReaderClosedListener(new FaultyListener());\n          } else {\n            count.incrementAndGet();\n            reader.addReaderClosedListener(new CountListener(count));\n          }\n      }\n      if (!faultySet && !throwOnClose) {\n        reader.addReaderClosedListener(new FaultyListener());\n      }\n      try {\n        reader.close();\n        fail(\"expected Exception\");\n      } catch (IllegalStateException ex) {\n        if (throwOnClose) {\n          assertEquals(\"BOOM!\", ex.getMessage());\n        } else {\n          assertEquals(\"GRRRRRRRRRRRR!\", ex.getMessage());\n        }\n      }\n\n      try {\n        reader.fields();\n        fail(\"we are closed\");\n      } catch (AlreadyClosedException ex) {\n      }\n\n      if (random().nextBoolean()) {\n        reader.close(); // call it again\n      }\n      assertEquals(0, count.get());\n      wrap.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"05fe562aa248790944d43cdd478f512572835ba0","date":1455901667,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose#testCloseUnderException().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose#testCloseUnderException().mjava","sourceNew":"  public void testCloseUnderException() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(random(), new MockAnalyzer(random())));\n    writer.commit();\n    writer.close();\n    final int iters = 1000 +  1 + random().nextInt(20);\n    for (int j = 0; j < iters; j++) {\n      DirectoryReader open = DirectoryReader.open(dir);\n      final boolean throwOnClose = !rarely();\n      LeafReader wrap = SlowCompositeReaderWrapper.wrap(open);\n      FilterLeafReader reader = new FilterLeafReader(wrap) {\n        @Override\n        protected void doClose() throws IOException {\n          super.doClose();\n          if (throwOnClose) {\n           throw new IllegalStateException(\"BOOM!\");\n          }\n        }\n      };\n      int listenerCount = random().nextInt(20);\n      AtomicInteger count = new AtomicInteger();\n      boolean faultySet = false;\n      for (int i = 0; i < listenerCount; i++) {\n          if (rarely()) {\n            faultySet = true;\n            reader.addReaderClosedListener(new FaultyListener());\n          } else {\n            count.incrementAndGet();\n            reader.addReaderClosedListener(new CountListener(count));\n          }\n      }\n      if (!faultySet && !throwOnClose) {\n        reader.addReaderClosedListener(new FaultyListener());\n      }\n\n      IllegalStateException expected = expectThrows(IllegalStateException.class, () -> {\n        reader.close();\n      });\n\n      if (throwOnClose) {\n        assertEquals(\"BOOM!\", expected.getMessage());\n      } else {\n        assertEquals(\"GRRRRRRRRRRRR!\", expected.getMessage());\n      }\n\n      expectThrows(AlreadyClosedException.class, () -> {\n        reader.fields();\n      });\n\n      if (random().nextBoolean()) {\n        reader.close(); // call it again\n      }\n      assertEquals(0, count.get());\n      wrap.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testCloseUnderException() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(random(), new MockAnalyzer(random())));\n    writer.commit();\n    writer.close();\n    final int iters = 1000 +  1 + random().nextInt(20);\n    for (int j = 0; j < iters; j++) {\n      DirectoryReader open = DirectoryReader.open(dir);\n      final boolean throwOnClose = !rarely();\n      LeafReader wrap = SlowCompositeReaderWrapper.wrap(open);\n      FilterLeafReader reader = new FilterLeafReader(wrap) {\n        @Override\n        protected void doClose() throws IOException {\n          super.doClose();\n          if (throwOnClose) {\n           throw new IllegalStateException(\"BOOM!\");\n          }\n        }\n      };\n      int listenerCount = random().nextInt(20);\n      AtomicInteger count = new AtomicInteger();\n      boolean faultySet = false;\n      for (int i = 0; i < listenerCount; i++) {\n          if (rarely()) {\n            faultySet = true;\n            reader.addReaderClosedListener(new FaultyListener());\n          } else {\n            count.incrementAndGet();\n            reader.addReaderClosedListener(new CountListener(count));\n          }\n      }\n      if (!faultySet && !throwOnClose) {\n        reader.addReaderClosedListener(new FaultyListener());\n      }\n      try {\n        reader.close();\n        fail(\"expected Exception\");\n      } catch (IllegalStateException ex) {\n        if (throwOnClose) {\n          assertEquals(\"BOOM!\", ex.getMessage());\n        } else {\n          assertEquals(\"GRRRRRRRRRRRR!\", ex.getMessage());\n        }\n      }\n\n      try {\n        reader.fields();\n        fail(\"we are closed\");\n      } catch (AlreadyClosedException ex) {\n      }\n\n      if (random().nextBoolean()) {\n        reader.close(); // call it again\n      }\n      assertEquals(0, count.get());\n      wrap.close();\n    }\n    dir.close();\n  }\n\n","bugFix":["6f8a4ddee78d8bc3c8c736c1cdb130b94cde0b89"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1","date":1457644139,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose#testCloseUnderException().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose#testCloseUnderException().mjava","sourceNew":"  public void testCloseUnderException() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(random(), new MockAnalyzer(random())));\n    writer.addDocument(new Document());\n    writer.commit();\n    writer.close();\n    final int iters = 1000 +  1 + random().nextInt(20);\n    for (int j = 0; j < iters; j++) {\n      DirectoryReader open = DirectoryReader.open(dir);\n      final boolean throwOnClose = !rarely();\n      LeafReader leaf = getOnlyLeafReader(open);\n      FilterLeafReader reader = new FilterLeafReader(leaf) {\n        @Override\n        protected void doClose() throws IOException {\n          super.doClose();\n          if (throwOnClose) {\n           throw new IllegalStateException(\"BOOM!\");\n          }\n        }\n      };\n      int listenerCount = random().nextInt(20);\n      AtomicInteger count = new AtomicInteger();\n      boolean faultySet = false;\n      for (int i = 0; i < listenerCount; i++) {\n          if (rarely()) {\n            faultySet = true;\n            reader.addReaderClosedListener(new FaultyListener());\n          } else {\n            count.incrementAndGet();\n            reader.addReaderClosedListener(new CountListener(count));\n          }\n      }\n      if (!faultySet && !throwOnClose) {\n        reader.addReaderClosedListener(new FaultyListener());\n      }\n\n      IllegalStateException expected = expectThrows(IllegalStateException.class, () -> {\n        reader.close();\n      });\n\n      if (throwOnClose) {\n        assertEquals(\"BOOM!\", expected.getMessage());\n      } else {\n        assertEquals(\"GRRRRRRRRRRRR!\", expected.getMessage());\n      }\n\n      expectThrows(AlreadyClosedException.class, () -> {\n        reader.fields();\n      });\n\n      if (random().nextBoolean()) {\n        reader.close(); // call it again\n      }\n      assertEquals(0, count.get());\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testCloseUnderException() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(random(), new MockAnalyzer(random())));\n    writer.commit();\n    writer.close();\n    final int iters = 1000 +  1 + random().nextInt(20);\n    for (int j = 0; j < iters; j++) {\n      DirectoryReader open = DirectoryReader.open(dir);\n      final boolean throwOnClose = !rarely();\n      LeafReader wrap = SlowCompositeReaderWrapper.wrap(open);\n      FilterLeafReader reader = new FilterLeafReader(wrap) {\n        @Override\n        protected void doClose() throws IOException {\n          super.doClose();\n          if (throwOnClose) {\n           throw new IllegalStateException(\"BOOM!\");\n          }\n        }\n      };\n      int listenerCount = random().nextInt(20);\n      AtomicInteger count = new AtomicInteger();\n      boolean faultySet = false;\n      for (int i = 0; i < listenerCount; i++) {\n          if (rarely()) {\n            faultySet = true;\n            reader.addReaderClosedListener(new FaultyListener());\n          } else {\n            count.incrementAndGet();\n            reader.addReaderClosedListener(new CountListener(count));\n          }\n      }\n      if (!faultySet && !throwOnClose) {\n        reader.addReaderClosedListener(new FaultyListener());\n      }\n\n      IllegalStateException expected = expectThrows(IllegalStateException.class, () -> {\n        reader.close();\n      });\n\n      if (throwOnClose) {\n        assertEquals(\"BOOM!\", expected.getMessage());\n      } else {\n        assertEquals(\"GRRRRRRRRRRRR!\", expected.getMessage());\n      }\n\n      expectThrows(AlreadyClosedException.class, () -> {\n        reader.fields();\n      });\n\n      if (random().nextBoolean()) {\n        reader.close(); // call it again\n      }\n      assertEquals(0, count.get());\n      wrap.close();\n    }\n    dir.close();\n  }\n\n","bugFix":["c9fb5f46e264daf5ba3860defe623a89d202dd87","6f8a4ddee78d8bc3c8c736c1cdb130b94cde0b89"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d211216c83f01894810543d1c107160a9ae3650b","date":1488289605,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose#testCloseUnderException().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose#testCloseUnderException().mjava","sourceNew":"  public void testCloseUnderException() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(random(), new MockAnalyzer(random())));\n    writer.addDocument(new Document());\n    writer.commit();\n    writer.close();\n    final int iters = 1000 +  1 + random().nextInt(20);\n    for (int j = 0; j < iters; j++) {\n      DirectoryReader open = DirectoryReader.open(dir);\n      final boolean throwOnClose = !rarely();\n      LeafReader leaf = getOnlyLeafReader(open);\n      FilterLeafReader reader = new FilterLeafReader(leaf) {\n        @Override\n        public CacheHelper getCoreCacheHelper() {\n          return in.getCoreCacheHelper();\n        }\n        @Override\n        public CacheHelper getReaderCacheHelper() {\n          return in.getReaderCacheHelper();\n        }\n        @Override\n        protected void doClose() throws IOException {\n          try {\n            super.doClose();\n          } finally {\n            if (throwOnClose) {\n              throw new IllegalStateException(\"BOOM!\");\n             }\n          }\n        }\n      };\n      int listenerCount = random().nextInt(20);\n      AtomicInteger count = new AtomicInteger();\n      boolean faultySet = false;\n      for (int i = 0; i < listenerCount; i++) {\n          if (rarely()) {\n            faultySet = true;\n            reader.getReaderCacheHelper().addClosedListener(new FaultyListener());\n          } else {\n            count.incrementAndGet();\n            reader.getReaderCacheHelper().addClosedListener(new CountListener(count));\n          }\n      }\n      if (!faultySet && !throwOnClose) {\n        reader.getReaderCacheHelper().addClosedListener(new FaultyListener());\n      }\n\n      IllegalStateException expected = expectThrows(IllegalStateException.class, () -> {\n        reader.close();\n      });\n\n      if (throwOnClose) {\n        assertEquals(\"BOOM!\", expected.getMessage());\n      } else {\n        assertEquals(\"GRRRRRRRRRRRR!\", expected.getMessage());\n      }\n\n      expectThrows(AlreadyClosedException.class, () -> {\n        reader.fields();\n      });\n\n      if (random().nextBoolean()) {\n        reader.close(); // call it again\n      }\n      assertEquals(0, count.get());\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testCloseUnderException() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(random(), new MockAnalyzer(random())));\n    writer.addDocument(new Document());\n    writer.commit();\n    writer.close();\n    final int iters = 1000 +  1 + random().nextInt(20);\n    for (int j = 0; j < iters; j++) {\n      DirectoryReader open = DirectoryReader.open(dir);\n      final boolean throwOnClose = !rarely();\n      LeafReader leaf = getOnlyLeafReader(open);\n      FilterLeafReader reader = new FilterLeafReader(leaf) {\n        @Override\n        protected void doClose() throws IOException {\n          super.doClose();\n          if (throwOnClose) {\n           throw new IllegalStateException(\"BOOM!\");\n          }\n        }\n      };\n      int listenerCount = random().nextInt(20);\n      AtomicInteger count = new AtomicInteger();\n      boolean faultySet = false;\n      for (int i = 0; i < listenerCount; i++) {\n          if (rarely()) {\n            faultySet = true;\n            reader.addReaderClosedListener(new FaultyListener());\n          } else {\n            count.incrementAndGet();\n            reader.addReaderClosedListener(new CountListener(count));\n          }\n      }\n      if (!faultySet && !throwOnClose) {\n        reader.addReaderClosedListener(new FaultyListener());\n      }\n\n      IllegalStateException expected = expectThrows(IllegalStateException.class, () -> {\n        reader.close();\n      });\n\n      if (throwOnClose) {\n        assertEquals(\"BOOM!\", expected.getMessage());\n      } else {\n        assertEquals(\"GRRRRRRRRRRRR!\", expected.getMessage());\n      }\n\n      expectThrows(AlreadyClosedException.class, () -> {\n        reader.fields();\n      });\n\n      if (random().nextBoolean()) {\n        reader.close(); // call it again\n      }\n      assertEquals(0, count.get());\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"71da9a885c49918fb26c68bb7dba0154f87130da","date":1492065707,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose#testCloseUnderException().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose#testCloseUnderException().mjava","sourceNew":"  public void testCloseUnderException() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(random(), new MockAnalyzer(random())));\n    writer.addDocument(new Document());\n    writer.commit();\n    writer.close();\n    final int iters = 1000 +  1 + random().nextInt(20);\n    for (int j = 0; j < iters; j++) {\n      DirectoryReader open = DirectoryReader.open(dir);\n      final boolean throwOnClose = !rarely();\n      LeafReader leaf = getOnlyLeafReader(open);\n      FilterLeafReader reader = new FilterLeafReader(leaf) {\n        @Override\n        public CacheHelper getCoreCacheHelper() {\n          return in.getCoreCacheHelper();\n        }\n        @Override\n        public CacheHelper getReaderCacheHelper() {\n          return in.getReaderCacheHelper();\n        }\n        @Override\n        protected void doClose() throws IOException {\n          try {\n            super.doClose();\n          } finally {\n            if (throwOnClose) {\n              throw new IllegalStateException(\"BOOM!\");\n             }\n          }\n        }\n      };\n      int listenerCount = random().nextInt(20);\n      AtomicInteger count = new AtomicInteger();\n      boolean faultySet = false;\n      for (int i = 0; i < listenerCount; i++) {\n          if (rarely()) {\n            faultySet = true;\n            reader.getReaderCacheHelper().addClosedListener(new FaultyListener());\n          } else {\n            count.incrementAndGet();\n            reader.getReaderCacheHelper().addClosedListener(new CountListener(count, reader.getReaderCacheHelper().getKey()));\n          }\n      }\n      if (!faultySet && !throwOnClose) {\n        reader.getReaderCacheHelper().addClosedListener(new FaultyListener());\n      }\n\n      IllegalStateException expected = expectThrows(IllegalStateException.class, () -> {\n        reader.close();\n      });\n\n      if (throwOnClose) {\n        assertEquals(\"BOOM!\", expected.getMessage());\n      } else {\n        assertEquals(\"GRRRRRRRRRRRR!\", expected.getMessage());\n      }\n\n      expectThrows(AlreadyClosedException.class, () -> {\n        reader.fields();\n      });\n\n      if (random().nextBoolean()) {\n        reader.close(); // call it again\n      }\n      assertEquals(0, count.get());\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testCloseUnderException() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(random(), new MockAnalyzer(random())));\n    writer.addDocument(new Document());\n    writer.commit();\n    writer.close();\n    final int iters = 1000 +  1 + random().nextInt(20);\n    for (int j = 0; j < iters; j++) {\n      DirectoryReader open = DirectoryReader.open(dir);\n      final boolean throwOnClose = !rarely();\n      LeafReader leaf = getOnlyLeafReader(open);\n      FilterLeafReader reader = new FilterLeafReader(leaf) {\n        @Override\n        public CacheHelper getCoreCacheHelper() {\n          return in.getCoreCacheHelper();\n        }\n        @Override\n        public CacheHelper getReaderCacheHelper() {\n          return in.getReaderCacheHelper();\n        }\n        @Override\n        protected void doClose() throws IOException {\n          try {\n            super.doClose();\n          } finally {\n            if (throwOnClose) {\n              throw new IllegalStateException(\"BOOM!\");\n             }\n          }\n        }\n      };\n      int listenerCount = random().nextInt(20);\n      AtomicInteger count = new AtomicInteger();\n      boolean faultySet = false;\n      for (int i = 0; i < listenerCount; i++) {\n          if (rarely()) {\n            faultySet = true;\n            reader.getReaderCacheHelper().addClosedListener(new FaultyListener());\n          } else {\n            count.incrementAndGet();\n            reader.getReaderCacheHelper().addClosedListener(new CountListener(count));\n          }\n      }\n      if (!faultySet && !throwOnClose) {\n        reader.getReaderCacheHelper().addClosedListener(new FaultyListener());\n      }\n\n      IllegalStateException expected = expectThrows(IllegalStateException.class, () -> {\n        reader.close();\n      });\n\n      if (throwOnClose) {\n        assertEquals(\"BOOM!\", expected.getMessage());\n      } else {\n        assertEquals(\"GRRRRRRRRRRRR!\", expected.getMessage());\n      }\n\n      expectThrows(AlreadyClosedException.class, () -> {\n        reader.fields();\n      });\n\n      if (random().nextBoolean()) {\n        reader.close(); // call it again\n      }\n      assertEquals(0, count.get());\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose#testCloseUnderException().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose#testCloseUnderException().mjava","sourceNew":"  public void testCloseUnderException() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(random(), new MockAnalyzer(random())));\n    writer.addDocument(new Document());\n    writer.commit();\n    writer.close();\n    final int iters = 1000 +  1 + random().nextInt(20);\n    for (int j = 0; j < iters; j++) {\n      DirectoryReader open = DirectoryReader.open(dir);\n      final boolean throwOnClose = !rarely();\n      LeafReader leaf = getOnlyLeafReader(open);\n      FilterLeafReader reader = new FilterLeafReader(leaf) {\n        @Override\n        public CacheHelper getCoreCacheHelper() {\n          return in.getCoreCacheHelper();\n        }\n        @Override\n        public CacheHelper getReaderCacheHelper() {\n          return in.getReaderCacheHelper();\n        }\n        @Override\n        protected void doClose() throws IOException {\n          try {\n            super.doClose();\n          } finally {\n            if (throwOnClose) {\n              throw new IllegalStateException(\"BOOM!\");\n             }\n          }\n        }\n      };\n      int listenerCount = random().nextInt(20);\n      AtomicInteger count = new AtomicInteger();\n      boolean faultySet = false;\n      for (int i = 0; i < listenerCount; i++) {\n          if (rarely()) {\n            faultySet = true;\n            reader.getReaderCacheHelper().addClosedListener(new FaultyListener());\n          } else {\n            count.incrementAndGet();\n            reader.getReaderCacheHelper().addClosedListener(new CountListener(count, reader.getReaderCacheHelper().getKey()));\n          }\n      }\n      if (!faultySet && !throwOnClose) {\n        reader.getReaderCacheHelper().addClosedListener(new FaultyListener());\n      }\n\n      IllegalStateException expected = expectThrows(IllegalStateException.class, () -> {\n        reader.close();\n      });\n\n      if (throwOnClose) {\n        assertEquals(\"BOOM!\", expected.getMessage());\n      } else {\n        assertEquals(\"GRRRRRRRRRRRR!\", expected.getMessage());\n      }\n\n      expectThrows(AlreadyClosedException.class, () -> {\n        reader.fields();\n      });\n\n      if (random().nextBoolean()) {\n        reader.close(); // call it again\n      }\n      assertEquals(0, count.get());\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testCloseUnderException() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(random(), new MockAnalyzer(random())));\n    writer.addDocument(new Document());\n    writer.commit();\n    writer.close();\n    final int iters = 1000 +  1 + random().nextInt(20);\n    for (int j = 0; j < iters; j++) {\n      DirectoryReader open = DirectoryReader.open(dir);\n      final boolean throwOnClose = !rarely();\n      LeafReader leaf = getOnlyLeafReader(open);\n      FilterLeafReader reader = new FilterLeafReader(leaf) {\n        @Override\n        public CacheHelper getCoreCacheHelper() {\n          return in.getCoreCacheHelper();\n        }\n        @Override\n        public CacheHelper getReaderCacheHelper() {\n          return in.getReaderCacheHelper();\n        }\n        @Override\n        protected void doClose() throws IOException {\n          try {\n            super.doClose();\n          } finally {\n            if (throwOnClose) {\n              throw new IllegalStateException(\"BOOM!\");\n             }\n          }\n        }\n      };\n      int listenerCount = random().nextInt(20);\n      AtomicInteger count = new AtomicInteger();\n      boolean faultySet = false;\n      for (int i = 0; i < listenerCount; i++) {\n          if (rarely()) {\n            faultySet = true;\n            reader.getReaderCacheHelper().addClosedListener(new FaultyListener());\n          } else {\n            count.incrementAndGet();\n            reader.getReaderCacheHelper().addClosedListener(new CountListener(count));\n          }\n      }\n      if (!faultySet && !throwOnClose) {\n        reader.getReaderCacheHelper().addClosedListener(new FaultyListener());\n      }\n\n      IllegalStateException expected = expectThrows(IllegalStateException.class, () -> {\n        reader.close();\n      });\n\n      if (throwOnClose) {\n        assertEquals(\"BOOM!\", expected.getMessage());\n      } else {\n        assertEquals(\"GRRRRRRRRRRRR!\", expected.getMessage());\n      }\n\n      expectThrows(AlreadyClosedException.class, () -> {\n        reader.fields();\n      });\n\n      if (random().nextBoolean()) {\n        reader.close(); // call it again\n      }\n      assertEquals(0, count.get());\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b","date":1497408244,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose#testCloseUnderException().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose#testCloseUnderException().mjava","sourceNew":"  public void testCloseUnderException() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(random(), new MockAnalyzer(random())));\n    writer.addDocument(new Document());\n    writer.commit();\n    writer.close();\n    final int iters = 1000 +  1 + random().nextInt(20);\n    for (int j = 0; j < iters; j++) {\n      DirectoryReader open = DirectoryReader.open(dir);\n      final boolean throwOnClose = !rarely();\n      LeafReader leaf = getOnlyLeafReader(open);\n      FilterLeafReader reader = new FilterLeafReader(leaf) {\n        @Override\n        public CacheHelper getCoreCacheHelper() {\n          return in.getCoreCacheHelper();\n        }\n        @Override\n        public CacheHelper getReaderCacheHelper() {\n          return in.getReaderCacheHelper();\n        }\n        @Override\n        protected void doClose() throws IOException {\n          try {\n            super.doClose();\n          } finally {\n            if (throwOnClose) {\n              throw new IllegalStateException(\"BOOM!\");\n             }\n          }\n        }\n      };\n      int listenerCount = random().nextInt(20);\n      AtomicInteger count = new AtomicInteger();\n      boolean faultySet = false;\n      for (int i = 0; i < listenerCount; i++) {\n          if (rarely()) {\n            faultySet = true;\n            reader.getReaderCacheHelper().addClosedListener(new FaultyListener());\n          } else {\n            count.incrementAndGet();\n            reader.getReaderCacheHelper().addClosedListener(new CountListener(count, reader.getReaderCacheHelper().getKey()));\n          }\n      }\n      if (!faultySet && !throwOnClose) {\n        reader.getReaderCacheHelper().addClosedListener(new FaultyListener());\n      }\n\n      IllegalStateException expected = expectThrows(IllegalStateException.class, () -> reader.close());\n\n      if (throwOnClose) {\n        assertEquals(\"BOOM!\", expected.getMessage());\n      } else {\n        assertEquals(\"GRRRRRRRRRRRR!\", expected.getMessage());\n      }\n\n      expectThrows(AlreadyClosedException.class, () -> reader.terms(\"someField\"));\n\n      if (random().nextBoolean()) {\n        reader.close(); // call it again\n      }\n      assertEquals(0, count.get());\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testCloseUnderException() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(random(), new MockAnalyzer(random())));\n    writer.addDocument(new Document());\n    writer.commit();\n    writer.close();\n    final int iters = 1000 +  1 + random().nextInt(20);\n    for (int j = 0; j < iters; j++) {\n      DirectoryReader open = DirectoryReader.open(dir);\n      final boolean throwOnClose = !rarely();\n      LeafReader leaf = getOnlyLeafReader(open);\n      FilterLeafReader reader = new FilterLeafReader(leaf) {\n        @Override\n        public CacheHelper getCoreCacheHelper() {\n          return in.getCoreCacheHelper();\n        }\n        @Override\n        public CacheHelper getReaderCacheHelper() {\n          return in.getReaderCacheHelper();\n        }\n        @Override\n        protected void doClose() throws IOException {\n          try {\n            super.doClose();\n          } finally {\n            if (throwOnClose) {\n              throw new IllegalStateException(\"BOOM!\");\n             }\n          }\n        }\n      };\n      int listenerCount = random().nextInt(20);\n      AtomicInteger count = new AtomicInteger();\n      boolean faultySet = false;\n      for (int i = 0; i < listenerCount; i++) {\n          if (rarely()) {\n            faultySet = true;\n            reader.getReaderCacheHelper().addClosedListener(new FaultyListener());\n          } else {\n            count.incrementAndGet();\n            reader.getReaderCacheHelper().addClosedListener(new CountListener(count, reader.getReaderCacheHelper().getKey()));\n          }\n      }\n      if (!faultySet && !throwOnClose) {\n        reader.getReaderCacheHelper().addClosedListener(new FaultyListener());\n      }\n\n      IllegalStateException expected = expectThrows(IllegalStateException.class, () -> {\n        reader.close();\n      });\n\n      if (throwOnClose) {\n        assertEquals(\"BOOM!\", expected.getMessage());\n      } else {\n        assertEquals(\"GRRRRRRRRRRRR!\", expected.getMessage());\n      }\n\n      expectThrows(AlreadyClosedException.class, () -> {\n        reader.fields();\n      });\n\n      if (random().nextBoolean()) {\n        reader.close(); // call it again\n      }\n      assertEquals(0, count.get());\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose#testCloseUnderException().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose#testCloseUnderException().mjava","sourceNew":"  public void testCloseUnderException() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(random(), new MockAnalyzer(random())));\n    writer.addDocument(new Document());\n    writer.commit();\n    writer.close();\n    final int iters = 1000 +  1 + random().nextInt(20);\n    for (int j = 0; j < iters; j++) {\n      DirectoryReader open = DirectoryReader.open(dir);\n      final boolean throwOnClose = !rarely();\n      LeafReader leaf = getOnlyLeafReader(open);\n      FilterLeafReader reader = new FilterLeafReader(leaf) {\n        @Override\n        public CacheHelper getCoreCacheHelper() {\n          return in.getCoreCacheHelper();\n        }\n        @Override\n        public CacheHelper getReaderCacheHelper() {\n          return in.getReaderCacheHelper();\n        }\n        @Override\n        protected void doClose() throws IOException {\n          try {\n            super.doClose();\n          } finally {\n            if (throwOnClose) {\n              throw new IllegalStateException(\"BOOM!\");\n             }\n          }\n        }\n      };\n      int listenerCount = random().nextInt(20);\n      AtomicInteger count = new AtomicInteger();\n      boolean faultySet = false;\n      for (int i = 0; i < listenerCount; i++) {\n          if (rarely()) {\n            faultySet = true;\n            reader.getReaderCacheHelper().addClosedListener(new FaultyListener());\n          } else {\n            count.incrementAndGet();\n            reader.getReaderCacheHelper().addClosedListener(new CountListener(count, reader.getReaderCacheHelper().getKey()));\n          }\n      }\n      if (!faultySet && !throwOnClose) {\n        reader.getReaderCacheHelper().addClosedListener(new FaultyListener());\n      }\n\n      IllegalStateException expected = expectThrows(IllegalStateException.class, () -> reader.close());\n\n      if (throwOnClose) {\n        assertEquals(\"BOOM!\", expected.getMessage());\n      } else {\n        assertEquals(\"GRRRRRRRRRRRR!\", expected.getMessage());\n      }\n\n      expectThrows(AlreadyClosedException.class, () -> reader.terms(\"someField\"));\n\n      if (random().nextBoolean()) {\n        reader.close(); // call it again\n      }\n      assertEquals(0, count.get());\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testCloseUnderException() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(random(), new MockAnalyzer(random())));\n    writer.addDocument(new Document());\n    writer.commit();\n    writer.close();\n    final int iters = 1000 +  1 + random().nextInt(20);\n    for (int j = 0; j < iters; j++) {\n      DirectoryReader open = DirectoryReader.open(dir);\n      final boolean throwOnClose = !rarely();\n      LeafReader leaf = getOnlyLeafReader(open);\n      FilterLeafReader reader = new FilterLeafReader(leaf) {\n        @Override\n        public CacheHelper getCoreCacheHelper() {\n          return in.getCoreCacheHelper();\n        }\n        @Override\n        public CacheHelper getReaderCacheHelper() {\n          return in.getReaderCacheHelper();\n        }\n        @Override\n        protected void doClose() throws IOException {\n          try {\n            super.doClose();\n          } finally {\n            if (throwOnClose) {\n              throw new IllegalStateException(\"BOOM!\");\n             }\n          }\n        }\n      };\n      int listenerCount = random().nextInt(20);\n      AtomicInteger count = new AtomicInteger();\n      boolean faultySet = false;\n      for (int i = 0; i < listenerCount; i++) {\n          if (rarely()) {\n            faultySet = true;\n            reader.getReaderCacheHelper().addClosedListener(new FaultyListener());\n          } else {\n            count.incrementAndGet();\n            reader.getReaderCacheHelper().addClosedListener(new CountListener(count, reader.getReaderCacheHelper().getKey()));\n          }\n      }\n      if (!faultySet && !throwOnClose) {\n        reader.getReaderCacheHelper().addClosedListener(new FaultyListener());\n      }\n\n      IllegalStateException expected = expectThrows(IllegalStateException.class, () -> {\n        reader.close();\n      });\n\n      if (throwOnClose) {\n        assertEquals(\"BOOM!\", expected.getMessage());\n      } else {\n        assertEquals(\"GRRRRRRRRRRRR!\", expected.getMessage());\n      }\n\n      expectThrows(AlreadyClosedException.class, () -> {\n        reader.fields();\n      });\n\n      if (random().nextBoolean()) {\n        reader.close(); // call it again\n      }\n      assertEquals(0, count.get());\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose#testCloseUnderException().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose#testCloseUnderException().mjava","sourceNew":"  public void testCloseUnderException() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(random(), new MockAnalyzer(random())));\n    writer.addDocument(new Document());\n    writer.commit();\n    writer.close();\n    final int iters = 1000 +  1 + random().nextInt(20);\n    for (int j = 0; j < iters; j++) {\n      DirectoryReader open = DirectoryReader.open(dir);\n      final boolean throwOnClose = !rarely();\n      LeafReader leaf = getOnlyLeafReader(open);\n      FilterLeafReader reader = new FilterLeafReader(leaf) {\n        @Override\n        public CacheHelper getCoreCacheHelper() {\n          return in.getCoreCacheHelper();\n        }\n        @Override\n        public CacheHelper getReaderCacheHelper() {\n          return in.getReaderCacheHelper();\n        }\n        @Override\n        protected void doClose() throws IOException {\n          try {\n            super.doClose();\n          } finally {\n            if (throwOnClose) {\n              throw new IllegalStateException(\"BOOM!\");\n             }\n          }\n        }\n      };\n      int listenerCount = random().nextInt(20);\n      AtomicInteger count = new AtomicInteger();\n      boolean faultySet = false;\n      for (int i = 0; i < listenerCount; i++) {\n          if (rarely()) {\n            faultySet = true;\n            reader.getReaderCacheHelper().addClosedListener(new FaultyListener());\n          } else {\n            count.incrementAndGet();\n            reader.getReaderCacheHelper().addClosedListener(new CountListener(count, reader.getReaderCacheHelper().getKey()));\n          }\n      }\n      if (!faultySet && !throwOnClose) {\n        reader.getReaderCacheHelper().addClosedListener(new FaultyListener());\n      }\n\n      IllegalStateException expected = expectThrows(IllegalStateException.class, () -> reader.close());\n\n      if (throwOnClose) {\n        assertEquals(\"BOOM!\", expected.getMessage());\n      } else {\n        assertEquals(\"GRRRRRRRRRRRR!\", expected.getMessage());\n      }\n\n      expectThrows(AlreadyClosedException.class, () -> reader.terms(\"someField\"));\n\n      if (random().nextBoolean()) {\n        reader.close(); // call it again\n      }\n      assertEquals(0, count.get());\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testCloseUnderException() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(random(), new MockAnalyzer(random())));\n    writer.addDocument(new Document());\n    writer.commit();\n    writer.close();\n    final int iters = 1000 +  1 + random().nextInt(20);\n    for (int j = 0; j < iters; j++) {\n      DirectoryReader open = DirectoryReader.open(dir);\n      final boolean throwOnClose = !rarely();\n      LeafReader leaf = getOnlyLeafReader(open);\n      FilterLeafReader reader = new FilterLeafReader(leaf) {\n        @Override\n        public CacheHelper getCoreCacheHelper() {\n          return in.getCoreCacheHelper();\n        }\n        @Override\n        public CacheHelper getReaderCacheHelper() {\n          return in.getReaderCacheHelper();\n        }\n        @Override\n        protected void doClose() throws IOException {\n          try {\n            super.doClose();\n          } finally {\n            if (throwOnClose) {\n              throw new IllegalStateException(\"BOOM!\");\n             }\n          }\n        }\n      };\n      int listenerCount = random().nextInt(20);\n      AtomicInteger count = new AtomicInteger();\n      boolean faultySet = false;\n      for (int i = 0; i < listenerCount; i++) {\n          if (rarely()) {\n            faultySet = true;\n            reader.getReaderCacheHelper().addClosedListener(new FaultyListener());\n          } else {\n            count.incrementAndGet();\n            reader.getReaderCacheHelper().addClosedListener(new CountListener(count, reader.getReaderCacheHelper().getKey()));\n          }\n      }\n      if (!faultySet && !throwOnClose) {\n        reader.getReaderCacheHelper().addClosedListener(new FaultyListener());\n      }\n\n      IllegalStateException expected = expectThrows(IllegalStateException.class, () -> {\n        reader.close();\n      });\n\n      if (throwOnClose) {\n        assertEquals(\"BOOM!\", expected.getMessage());\n      } else {\n        assertEquals(\"GRRRRRRRRRRRR!\", expected.getMessage());\n      }\n\n      expectThrows(AlreadyClosedException.class, () -> {\n        reader.fields();\n      });\n\n      if (random().nextBoolean()) {\n        reader.close(); // call it again\n      }\n      assertEquals(0, count.get());\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["d211216c83f01894810543d1c107160a9ae3650b"],"e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b":["71da9a885c49918fb26c68bb7dba0154f87130da"],"7704e64a78bc9f245268f5c002d1e66b6c9f309f":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"6f8a4ddee78d8bc3c8c736c1cdb130b94cde0b89":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"05fe562aa248790944d43cdd478f512572835ba0":["a87ce200bba7d88024e2f1c4012212072ce8a5ae"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"28288370235ed02234a64753cdbf0c6ec096304a":["71da9a885c49918fb26c68bb7dba0154f87130da","e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b"],"71da9a885c49918fb26c68bb7dba0154f87130da":["d211216c83f01894810543d1c107160a9ae3650b"],"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1":["05fe562aa248790944d43cdd478f512572835ba0"],"a87ce200bba7d88024e2f1c4012212072ce8a5ae":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"d211216c83f01894810543d1c107160a9ae3650b":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["7704e64a78bc9f245268f5c002d1e66b6c9f309f"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["6f8a4ddee78d8bc3c8c736c1cdb130b94cde0b89"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["28288370235ed02234a64753cdbf0c6ec096304a"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"7704e64a78bc9f245268f5c002d1e66b6c9f309f":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"6f8a4ddee78d8bc3c8c736c1cdb130b94cde0b89":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"05fe562aa248790944d43cdd478f512572835ba0":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["a87ce200bba7d88024e2f1c4012212072ce8a5ae"],"28288370235ed02234a64753cdbf0c6ec096304a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"71da9a885c49918fb26c68bb7dba0154f87130da":["e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b","28288370235ed02234a64753cdbf0c6ec096304a"],"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1":["d211216c83f01894810543d1c107160a9ae3650b"],"a87ce200bba7d88024e2f1c4012212072ce8a5ae":["05fe562aa248790944d43cdd478f512572835ba0"],"d211216c83f01894810543d1c107160a9ae3650b":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","71da9a885c49918fb26c68bb7dba0154f87130da"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6f8a4ddee78d8bc3c8c736c1cdb130b94cde0b89"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["7704e64a78bc9f245268f5c002d1e66b6c9f309f"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}