{"path":"lucene/core/src/java/org/apache/lucene/search/FilteringNumericLeafComparator#updateCompetitiveIterator().mjava","commits":[{"id":"e18fac0122568cb02eb2c92608ca703a723bbbd6","date":1592942698,"type":0,"author":"Mayya Sharipova","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FilteringNumericLeafComparator#updateCompetitiveIterator().mjava","pathOld":"/dev/null","sourceNew":"  // update its iterator to include possibly only docs that are \"stronger\" than the current bottom entry\n  private void updateCompetitiveIterator() throws IOException {\n    if (canUpdateIterator == false) return;\n    if (pointValues == null) return;\n    // if some documents have missing points, check that missing values prohibits optimization\n    if ((pointValues.getDocCount() < maxDoc) && isMissingValueCompetitive()) {\n      return; // we can't filter out documents, as documents with missing values are competitive\n    }\n\n    updateCounter++;\n    if (updateCounter > 256 && (updateCounter & 0x1f) != 0x1f) { // Start sampling if we get called too much\n      return;\n    }\n    if (reverse == false) {\n      encodeBottom(maxValueAsBytes);\n      if (hasTopValue) {\n        encodeTop(minValueAsBytes);\n      }\n    } else {\n      encodeBottom(minValueAsBytes);\n      if (hasTopValue) {\n        encodeTop(maxValueAsBytes);\n      }\n    }\n\n    DocIdSetBuilder result = new DocIdSetBuilder(maxDoc);\n    PointValues.IntersectVisitor visitor = new PointValues.IntersectVisitor() {\n      DocIdSetBuilder.BulkAdder adder;\n\n      @Override\n      public void grow(int count) {\n        adder = result.grow(count);\n      }\n\n      @Override\n      public void visit(int docID) {\n        if (docID <= maxDocVisited) {\n          return; // Already visited or skipped\n        }\n        adder.add(docID);\n      }\n\n      @Override\n      public void visit(int docID, byte[] packedValue) {\n        if (docID <= maxDocVisited) {\n          return;  // already visited or skipped\n        }\n        if (maxValueAsBytes != null) {\n          int cmp = Arrays.compareUnsigned(packedValue, 0, bytesCount, maxValueAsBytes, 0, bytesCount);\n          // if doc's value is too high or for single sort even equal, it is not competitive and the doc can be skipped\n          if (cmp > 0 || (singleSort && cmp == 0)) return;\n        }\n        if (minValueAsBytes != null) {\n          int cmp = Arrays.compareUnsigned(packedValue, 0, bytesCount, minValueAsBytes, 0, bytesCount);\n          // if doc's value is too low or for single sort even equal, it is not competitive and the doc can be skipped\n          if (cmp < 0 || (singleSort && cmp == 0)) return;\n        }\n        adder.add(docID); // doc is competitive\n      }\n\n      @Override\n      public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        if (maxValueAsBytes != null) {\n          int cmp = Arrays.compareUnsigned(minPackedValue, 0, bytesCount, maxValueAsBytes, 0, bytesCount);\n          if (cmp > 0 || (singleSort && cmp == 0)) return PointValues.Relation.CELL_OUTSIDE_QUERY;\n        }\n        if (minValueAsBytes != null) {\n          int cmp =  Arrays.compareUnsigned(maxPackedValue, 0, bytesCount, minValueAsBytes, 0, bytesCount);\n          if (cmp < 0 || (singleSort && cmp == 0)) return PointValues.Relation.CELL_OUTSIDE_QUERY;\n        }\n        if ((maxValueAsBytes != null && Arrays.compareUnsigned(maxPackedValue, 0, bytesCount, maxValueAsBytes, 0, bytesCount) > 0) ||\n            (minValueAsBytes != null && Arrays.compareUnsigned(minPackedValue, 0, bytesCount, minValueAsBytes, 0, bytesCount) < 0)) {\n          return PointValues.Relation.CELL_CROSSES_QUERY;\n        }\n        return PointValues.Relation.CELL_INSIDE_QUERY;\n      }\n    };\n    final long threshold = iteratorCost >>> 3;\n    long estimatedNumberOfMatches = pointValues.estimatePointCount(visitor); // runs in O(log(numPoints))\n    if (estimatedNumberOfMatches >= threshold) {\n      // the new range is not selective enough to be worth materializing, it doesn't reduce number of docs at least 8x\n      return;\n    }\n    pointValues.intersect(visitor);\n    competitiveIterator = result.build().iterator();\n    iteratorCost = competitiveIterator.cost();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e3d1c24d2bbe79dcf77ffcb104706e42ae3c9241","date":1599588987,"type":4,"author":"Mayya Sharipova","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/search/FilteringNumericLeafComparator#updateCompetitiveIterator().mjava","sourceNew":null,"sourceOld":"  // update its iterator to include possibly only docs that are \"stronger\" than the current bottom entry\n  private void updateCompetitiveIterator() throws IOException {\n    if (canUpdateIterator == false) return;\n    if (pointValues == null) return;\n    // if some documents have missing points, check that missing values prohibits optimization\n    if ((pointValues.getDocCount() < maxDoc) && isMissingValueCompetitive()) {\n      return; // we can't filter out documents, as documents with missing values are competitive\n    }\n\n    updateCounter++;\n    if (updateCounter > 256 && (updateCounter & 0x1f) != 0x1f) { // Start sampling if we get called too much\n      return;\n    }\n    if (reverse == false) {\n      encodeBottom(maxValueAsBytes);\n      if (hasTopValue) {\n        encodeTop(minValueAsBytes);\n      }\n    } else {\n      encodeBottom(minValueAsBytes);\n      if (hasTopValue) {\n        encodeTop(maxValueAsBytes);\n      }\n    }\n\n    DocIdSetBuilder result = new DocIdSetBuilder(maxDoc);\n    PointValues.IntersectVisitor visitor = new PointValues.IntersectVisitor() {\n      DocIdSetBuilder.BulkAdder adder;\n\n      @Override\n      public void grow(int count) {\n        adder = result.grow(count);\n      }\n\n      @Override\n      public void visit(int docID) {\n        if (docID <= maxDocVisited) {\n          return; // Already visited or skipped\n        }\n        adder.add(docID);\n      }\n\n      @Override\n      public void visit(int docID, byte[] packedValue) {\n        if (docID <= maxDocVisited) {\n          return;  // already visited or skipped\n        }\n        if (maxValueAsBytes != null) {\n          int cmp = Arrays.compareUnsigned(packedValue, 0, bytesCount, maxValueAsBytes, 0, bytesCount);\n          // if doc's value is too high or for single sort even equal, it is not competitive and the doc can be skipped\n          if (cmp > 0 || (singleSort && cmp == 0)) return;\n        }\n        if (minValueAsBytes != null) {\n          int cmp = Arrays.compareUnsigned(packedValue, 0, bytesCount, minValueAsBytes, 0, bytesCount);\n          // if doc's value is too low or for single sort even equal, it is not competitive and the doc can be skipped\n          if (cmp < 0 || (singleSort && cmp == 0)) return;\n        }\n        adder.add(docID); // doc is competitive\n      }\n\n      @Override\n      public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n        if (maxValueAsBytes != null) {\n          int cmp = Arrays.compareUnsigned(minPackedValue, 0, bytesCount, maxValueAsBytes, 0, bytesCount);\n          if (cmp > 0 || (singleSort && cmp == 0)) return PointValues.Relation.CELL_OUTSIDE_QUERY;\n        }\n        if (minValueAsBytes != null) {\n          int cmp =  Arrays.compareUnsigned(maxPackedValue, 0, bytesCount, minValueAsBytes, 0, bytesCount);\n          if (cmp < 0 || (singleSort && cmp == 0)) return PointValues.Relation.CELL_OUTSIDE_QUERY;\n        }\n        if ((maxValueAsBytes != null && Arrays.compareUnsigned(maxPackedValue, 0, bytesCount, maxValueAsBytes, 0, bytesCount) > 0) ||\n            (minValueAsBytes != null && Arrays.compareUnsigned(minPackedValue, 0, bytesCount, minValueAsBytes, 0, bytesCount) < 0)) {\n          return PointValues.Relation.CELL_CROSSES_QUERY;\n        }\n        return PointValues.Relation.CELL_INSIDE_QUERY;\n      }\n    };\n    final long threshold = iteratorCost >>> 3;\n    long estimatedNumberOfMatches = pointValues.estimatePointCount(visitor); // runs in O(log(numPoints))\n    if (estimatedNumberOfMatches >= threshold) {\n      // the new range is not selective enough to be worth materializing, it doesn't reduce number of docs at least 8x\n      return;\n    }\n    pointValues.intersect(visitor);\n    competitiveIterator = result.build().iterator();\n    iteratorCost = competitiveIterator.cost();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e18fac0122568cb02eb2c92608ca703a723bbbd6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e3d1c24d2bbe79dcf77ffcb104706e42ae3c9241"],"e3d1c24d2bbe79dcf77ffcb104706e42ae3c9241":["e18fac0122568cb02eb2c92608ca703a723bbbd6"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e18fac0122568cb02eb2c92608ca703a723bbbd6"],"e18fac0122568cb02eb2c92608ca703a723bbbd6":["e3d1c24d2bbe79dcf77ffcb104706e42ae3c9241"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"e3d1c24d2bbe79dcf77ffcb104706e42ae3c9241":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}