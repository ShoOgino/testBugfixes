{"path":"solr/core/src/java/org/apache/solr/util/hll/HLL#clone().mjava","commits":[{"id":"6d8714f9ceaaff94f0968d1c2d037978c3fde569","date":1437042727,"type":0,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/hll/HLL#clone().mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Create a deep copy of this HLL.\n     *\n     * @see java.lang.Object#clone()\n     */\n    @Override\n    public HLL clone() throws CloneNotSupportedException {\n        // NOTE: Since the package-only constructor assumes both explicit and\n        //       sparse are enabled, the easiest thing to do here is to re-derive\n        //       the expthresh parameter and create a new HLL with the public\n        //       constructor.\n        // TODO: add a more sensible constructor to make this less obfuscated\n        final int copyExpthresh;\n        if(explicitAuto) {\n            copyExpthresh = -1;\n        } else if(explicitOff) {\n            copyExpthresh = 0;\n        } else {\n            // explicitThreshold is defined as:\n            //\n            //      this.explicitThreshold = (1 << (expthresh - 1));\n            //\n            // Since explicitThreshold is a power of two and only has a single\n            // bit set, finding the LSB is the same as finding the inverse\n            copyExpthresh = BitUtil.leastSignificantBit(explicitThreshold) + 1;\n        }\n        final HLL copy = new HLL(log2m, regwidth, copyExpthresh, !sparseOff/*sparseOn*/, type);\n        switch(type) {\n            case EMPTY:\n                // nothing to be done\n                break;\n            case EXPLICIT:\n                copy.explicitStorage = this.explicitStorage.clone();\n                break;\n            case SPARSE:\n                copy.sparseProbabilisticStorage = this.sparseProbabilisticStorage.clone();\n                break;\n            case FULL:\n                copy.probabilisticStorage = this.probabilisticStorage.clone();\n                break;\n            default:\n                throw new RuntimeException(\"Unsupported HLL type \" + type);\n        }\n        return copy;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b5ee4c66244bdfcc4796a114519d47701b2c026","date":1437132013,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/hll/HLL#clone().mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Create a deep copy of this HLL.\n     *\n     * @see java.lang.Object#clone()\n     */\n    @Override\n    public HLL clone() throws CloneNotSupportedException {\n        // NOTE: Since the package-only constructor assumes both explicit and\n        //       sparse are enabled, the easiest thing to do here is to re-derive\n        //       the expthresh parameter and create a new HLL with the public\n        //       constructor.\n        // TODO: add a more sensible constructor to make this less obfuscated\n        final int copyExpthresh;\n        if(explicitAuto) {\n            copyExpthresh = -1;\n        } else if(explicitOff) {\n            copyExpthresh = 0;\n        } else {\n            // explicitThreshold is defined as:\n            //\n            //      this.explicitThreshold = (1 << (expthresh - 1));\n            //\n            // Since explicitThreshold is a power of two and only has a single\n            // bit set, finding the LSB is the same as finding the inverse\n            copyExpthresh = BitUtil.leastSignificantBit(explicitThreshold) + 1;\n        }\n        final HLL copy = new HLL(log2m, regwidth, copyExpthresh, !sparseOff/*sparseOn*/, type);\n        switch(type) {\n            case EMPTY:\n                // nothing to be done\n                break;\n            case EXPLICIT:\n                copy.explicitStorage = this.explicitStorage.clone();\n                break;\n            case SPARSE:\n                copy.sparseProbabilisticStorage = this.sparseProbabilisticStorage.clone();\n                break;\n            case FULL:\n                copy.probabilisticStorage = this.probabilisticStorage.clone();\n                break;\n            default:\n                throw new RuntimeException(\"Unsupported HLL type \" + type);\n        }\n        return copy;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3b5ee4c66244bdfcc4796a114519d47701b2c026":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6d8714f9ceaaff94f0968d1c2d037978c3fde569"],"6d8714f9ceaaff94f0968d1c2d037978c3fde569":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3b5ee4c66244bdfcc4796a114519d47701b2c026"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3b5ee4c66244bdfcc4796a114519d47701b2c026","6d8714f9ceaaff94f0968d1c2d037978c3fde569"],"3b5ee4c66244bdfcc4796a114519d47701b2c026":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6d8714f9ceaaff94f0968d1c2d037978c3fde569":["3b5ee4c66244bdfcc4796a114519d47701b2c026"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}