{"path":"lucene/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int).mjava","commits":[{"id":"d14e8d18c0e3970c20354dbeeb49da11bd587fbd","date":1321041051,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#optimize().mjava","sourceNew":"  /**\n   * Forces merge policy to merge segments until there's <=\n   * maxNumSegments.  The actual merges to be\n   * executed are determined by the {@link MergePolicy}.\n   *\n   * <p>This is a horribly costly operation, especially when\n   * you pass a small {@code maxNumSegments}; usually you\n   * should only call this if the index is static (will no\n   * longer be changed).</p>\n   *\n   * <p>Note that this requires up to 2X the index size free\n   * space in your Directory (3X if you're using compound\n   * file format).  For example, if your index size is 10 MB\n   * then you need up to 20 MB free for this to complete (30\n   * MB if you're using compound file format).  Also,\n   * it's best to call {@link #commit()} afterwards,\n   * to allow IndexWriter to free up disk space.</p>\n   *\n   * <p>If some but not all readers re-open while merging\n   * is underway, this will cause > 2X temporary\n   * space to be consumed as those new readers will then\n   * hold open the temporary segments at that time.  It is\n   * best not to re-open readers while merging is running.</p>\n   *\n   * <p>The actual temporary usage could be much less than\n   * these figures (it depends on many factors).</p>\n   *\n   * <p>In general, once the this completes, the total size of the\n   * index will be less than the size of the starting index.\n   * It could be quite a bit smaller (if there were many\n   * pending deletes) or just slightly smaller.</p>\n   *\n   * <p>If an Exception is hit, for example\n   * due to disk full, the index will not be corrupt and no\n   * documents will have been lost.  However, it may have\n   * been partially merged (some segments were merged but\n   * not all), and it's possible that one of the segments in\n   * the index will be in non-compound format even when\n   * using compound file format.  This will occur when the\n   * Exception is hit during conversion of the segment into\n   * compound format.</p>\n   *\n   * <p>This call will merge those segments present in\n   * the index when the call started.  If other threads are\n   * still adding documents and flushing segments, those\n   * newly created segments will not be merged unless you\n   * call forceMerge again.</p>\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #close(boolean)}\n   * with <tt>false</tt>, which aborts all running merges,\n   * then any thread still running this method might hit a\n   * {@link MergePolicy.MergeAbortedException}.\n   *\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @see MergePolicy#findMerges\n   *\n   * @param maxNumSegments maximum number of segments left\n   * in the index after merging finishes\n  */\n  public void forceMerge(int maxNumSegments) throws CorruptIndexException, IOException {\n    forceMerge(maxNumSegments, true);\n  }\n\n","sourceOld":"  /**\n   * Requests an \"optimize\" operation on an index, priming the index\n   * for the fastest available search. Traditionally this has meant\n   * merging all segments into a single segment as is done in the\n   * default merge policy, but individual merge policies may implement\n   * optimize in different ways.\n   *\n   * <p> Optimize is a very costly operation, so you\n   * should only do it if your search performance really\n   * requires it.  Many search applications do fine never\n   * calling optimize. </p>\n   *\n   * <p>Note that optimize requires 2X the index size free\n   * space in your Directory (3X if you're using compound\n   * file format).  For example, if your index size is 10 MB\n   * then you need 20 MB free for optimize to complete (30\n   * MB if you're using compound file format).  Also,\n   * it's best to call {@link #commit()} after the optimize\n   * completes to allow IndexWriter to free up disk space.</p>\n   *\n   * <p>If some but not all readers re-open while an\n   * optimize is underway, this will cause > 2X temporary\n   * space to be consumed as those new readers will then\n   * hold open the partially optimized segments at that\n   * time.  It is best not to re-open readers while optimize\n   * is running.</p>\n   *\n   * <p>The actual temporary usage could be much less than\n   * these figures (it depends on many factors).</p>\n   *\n   * <p>In general, once the optimize completes, the total size of the\n   * index will be less than the size of the starting index.\n   * It could be quite a bit smaller (if there were many\n   * pending deletes) or just slightly smaller.</p>\n   *\n   * <p>If an Exception is hit during optimize(), for example\n   * due to disk full, the index will not be corrupt and no\n   * documents will have been lost.  However, it may have\n   * been partially optimized (some segments were merged but\n   * not all), and it's possible that one of the segments in\n   * the index will be in non-compound format even when\n   * using compound file format.  This will occur when the\n   * Exception is hit during conversion of the segment into\n   * compound format.</p>\n   *\n   * <p>This call will optimize those segments present in\n   * the index when the call started.  If other threads are\n   * still adding documents and flushing segments, those\n   * newly created segments will not be optimized unless you\n   * call optimize again.</p>\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #close(boolean)}\n   * with <tt>false</tt>, which aborts all running merges,\n   * then any thread still running this method might hit a\n   * {@link MergePolicy.MergeAbortedException}.\n   *\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @see MergePolicy#findMergesForOptimize\n  */\n  public void optimize() throws CorruptIndexException, IOException {\n    optimize(true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int).mjava","sourceNew":"  /**\n   * Forces merge policy to merge segments until there's <=\n   * maxNumSegments.  The actual merges to be\n   * executed are determined by the {@link MergePolicy}.\n   *\n   * <p>This is a horribly costly operation, especially when\n   * you pass a small {@code maxNumSegments}; usually you\n   * should only call this if the index is static (will no\n   * longer be changed).</p>\n   *\n   * <p>Note that this requires up to 2X the index size free\n   * space in your Directory (3X if you're using compound\n   * file format).  For example, if your index size is 10 MB\n   * then you need up to 20 MB free for this to complete (30\n   * MB if you're using compound file format).  Also,\n   * it's best to call {@link #commit()} afterwards,\n   * to allow IndexWriter to free up disk space.</p>\n   *\n   * <p>If some but not all readers re-open while merging\n   * is underway, this will cause > 2X temporary\n   * space to be consumed as those new readers will then\n   * hold open the temporary segments at that time.  It is\n   * best not to re-open readers while merging is running.</p>\n   *\n   * <p>The actual temporary usage could be much less than\n   * these figures (it depends on many factors).</p>\n   *\n   * <p>In general, once the this completes, the total size of the\n   * index will be less than the size of the starting index.\n   * It could be quite a bit smaller (if there were many\n   * pending deletes) or just slightly smaller.</p>\n   *\n   * <p>If an Exception is hit, for example\n   * due to disk full, the index will not be corrupt and no\n   * documents will have been lost.  However, it may have\n   * been partially merged (some segments were merged but\n   * not all), and it's possible that one of the segments in\n   * the index will be in non-compound format even when\n   * using compound file format.  This will occur when the\n   * Exception is hit during conversion of the segment into\n   * compound format.</p>\n   *\n   * <p>This call will merge those segments present in\n   * the index when the call started.  If other threads are\n   * still adding documents and flushing segments, those\n   * newly created segments will not be merged unless you\n   * call forceMerge again.</p>\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #close(boolean)}\n   * with <tt>false</tt>, which aborts all running merges,\n   * then any thread still running this method might hit a\n   * {@link MergePolicy.MergeAbortedException}.\n   *\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @see MergePolicy#findMerges\n   *\n   * @param maxNumSegments maximum number of segments left\n   * in the index after merging finishes\n  */\n  public void forceMerge(int maxNumSegments) throws CorruptIndexException, IOException {\n    forceMerge(maxNumSegments, true);\n  }\n\n","sourceOld":"  /**\n   * Forces merge policy to merge segments until there's <=\n   * maxNumSegments.  The actual merges to be\n   * executed are determined by the {@link MergePolicy}.\n   *\n   * <p>This is a horribly costly operation, especially when\n   * you pass a small {@code maxNumSegments}; usually you\n   * should only call this if the index is static (will no\n   * longer be changed).</p>\n   *\n   * <p>Note that this requires up to 2X the index size free\n   * space in your Directory (3X if you're using compound\n   * file format).  For example, if your index size is 10 MB\n   * then you need up to 20 MB free for this to complete (30\n   * MB if you're using compound file format).  Also,\n   * it's best to call {@link #commit()} afterwards,\n   * to allow IndexWriter to free up disk space.</p>\n   *\n   * <p>If some but not all readers re-open while merging\n   * is underway, this will cause > 2X temporary\n   * space to be consumed as those new readers will then\n   * hold open the temporary segments at that time.  It is\n   * best not to re-open readers while merging is running.</p>\n   *\n   * <p>The actual temporary usage could be much less than\n   * these figures (it depends on many factors).</p>\n   *\n   * <p>In general, once the this completes, the total size of the\n   * index will be less than the size of the starting index.\n   * It could be quite a bit smaller (if there were many\n   * pending deletes) or just slightly smaller.</p>\n   *\n   * <p>If an Exception is hit, for example\n   * due to disk full, the index will not be corrupt and no\n   * documents will have been lost.  However, it may have\n   * been partially merged (some segments were merged but\n   * not all), and it's possible that one of the segments in\n   * the index will be in non-compound format even when\n   * using compound file format.  This will occur when the\n   * Exception is hit during conversion of the segment into\n   * compound format.</p>\n   *\n   * <p>This call will merge those segments present in\n   * the index when the call started.  If other threads are\n   * still adding documents and flushing segments, those\n   * newly created segments will not be merged unless you\n   * call forceMerge again.</p>\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #close(boolean)}\n   * with <tt>false</tt>, which aborts all running merges,\n   * then any thread still running this method might hit a\n   * {@link MergePolicy.MergeAbortedException}.\n   *\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   * @see MergePolicy#findMerges\n   *\n   * @param maxNumSegments maximum number of segments left\n   * in the index after merging finishes\n  */\n  public void forceMerge(int maxNumSegments) throws CorruptIndexException, IOException {\n    forceMerge(maxNumSegments, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["d14e8d18c0e3970c20354dbeeb49da11bd587fbd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d14e8d18c0e3970c20354dbeeb49da11bd587fbd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d14e8d18c0e3970c20354dbeeb49da11bd587fbd"],"d14e8d18c0e3970c20354dbeeb49da11bd587fbd":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}