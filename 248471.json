{"path":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(BufferedDeletes,SegmentReader).mjava","commits":[{"id":"c19f985e36a65cc969e8e564fe337a0d41512075","date":1296330536,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(BufferedDeletes,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletes#applyDeletes(SegmentDeletes,SegmentReader).mjava","sourceNew":"  private synchronized long applyDeletes(BufferedDeletes deletes, SegmentReader reader) throws IOException {\n\n    long delCount = 0;\n\n    assert checkDeleteTerm(null);\n    \n    if (deletes.terms.size() > 0) {\n      Fields fields = reader.fields();\n      if (fields == null) {\n        // This reader has no postings\n        return 0;\n      }\n\n      TermsEnum termsEnum = null;\n        \n      String currentField = null;\n      DocsEnum docs = null;\n        \n      for (Entry<Term,Integer> entry: deletes.terms.entrySet()) {\n        Term term = entry.getKey();\n        // Since we visit terms sorted, we gain performance\n        // by re-using the same TermsEnum and seeking only\n        // forwards\n        if (term.field() != currentField) {\n          assert currentField == null || currentField.compareTo(term.field()) < 0;\n          currentField = term.field();\n          Terms terms = fields.terms(currentField);\n          if (terms != null) {\n            termsEnum = terms.iterator();\n          } else {\n            termsEnum = null;\n          }\n        }\n          \n        if (termsEnum == null) {\n          continue;\n        }\n        assert checkDeleteTerm(term);\n          \n        if (termsEnum.seek(term.bytes(), false) == TermsEnum.SeekStatus.FOUND) {\n          DocsEnum docsEnum = termsEnum.docs(reader.getDeletedDocs(), docs);\n            \n          if (docsEnum != null) {\n            docs = docsEnum;\n            final int limit = entry.getValue();\n            while (true) {\n              final int docID = docs.nextDoc();\n              if (docID == DocsEnum.NO_MORE_DOCS || docID >= limit) {\n                break;\n              }\n              reader.deleteDocument(docID);\n              // TODO: we could/should change\n              // reader.deleteDocument to return boolean\n              // true if it did in fact delete, because here\n              // we could be deleting an already-deleted doc\n              // which makes this an upper bound:\n              delCount++;\n            }\n          }\n        }\n      }\n    }\n\n    // Delete by docID\n    for (Integer docIdInt : deletes.docIDs) {\n      int docID = docIdInt.intValue();\n      reader.deleteDocument(docID);\n      delCount++;\n    }\n\n    // Delete by query\n    if (deletes.queries.size() > 0) {\n      IndexSearcher searcher = new IndexSearcher(reader);\n      assert searcher.getTopReaderContext().isAtomic;\n      final AtomicReaderContext readerContext = (AtomicReaderContext) searcher.getTopReaderContext();\n      try {\n        for (Entry<Query, Integer> entry : deletes.queries.entrySet()) {\n          Query query = entry.getKey();\n          int limit = entry.getValue().intValue();\n          Weight weight = query.weight(searcher);\n          Scorer scorer = weight.scorer(readerContext, Weight.ScorerContext.def());\n          if (scorer != null) {\n            while(true)  {\n              int doc = scorer.nextDoc();\n              if (doc >= limit)\n                break;\n\n              reader.deleteDocument(doc);\n              // TODO: we could/should change\n              // reader.deleteDocument to return boolean\n              // true if it did in fact delete, because here\n              // we could be deleting an already-deleted doc\n              // which makes this an upper bound:\n              delCount++;\n            }\n          }\n        }\n      } finally {\n        searcher.close();\n      }\n    }\n\n    return delCount;\n  }\n\n","sourceOld":"  private synchronized long applyDeletes(SegmentDeletes deletes, SegmentReader reader) throws IOException {\n\n    long delCount = 0;\n\n    assert checkDeleteTerm(null);\n    \n    if (deletes.terms.size() > 0) {\n      Fields fields = reader.fields();\n      if (fields == null) {\n        // This reader has no postings\n        return 0;\n      }\n\n      TermsEnum termsEnum = null;\n        \n      String currentField = null;\n      DocsEnum docs = null;\n        \n      for (Entry<Term,Integer> entry: deletes.terms.entrySet()) {\n        Term term = entry.getKey();\n        // Since we visit terms sorted, we gain performance\n        // by re-using the same TermsEnum and seeking only\n        // forwards\n        if (term.field() != currentField) {\n          assert currentField == null || currentField.compareTo(term.field()) < 0;\n          currentField = term.field();\n          Terms terms = fields.terms(currentField);\n          if (terms != null) {\n            termsEnum = terms.iterator();\n          } else {\n            termsEnum = null;\n          }\n        }\n          \n        if (termsEnum == null) {\n          continue;\n        }\n        assert checkDeleteTerm(term);\n          \n        if (termsEnum.seek(term.bytes(), false) == TermsEnum.SeekStatus.FOUND) {\n          DocsEnum docsEnum = termsEnum.docs(reader.getDeletedDocs(), docs);\n            \n          if (docsEnum != null) {\n            docs = docsEnum;\n            final int limit = entry.getValue();\n            while (true) {\n              final int docID = docs.nextDoc();\n              if (docID == DocsEnum.NO_MORE_DOCS || docID >= limit) {\n                break;\n              }\n              reader.deleteDocument(docID);\n              // TODO: we could/should change\n              // reader.deleteDocument to return boolean\n              // true if it did in fact delete, because here\n              // we could be deleting an already-deleted doc\n              // which makes this an upper bound:\n              delCount++;\n            }\n          }\n        }\n      }\n    }\n\n    // Delete by docID\n    for (Integer docIdInt : deletes.docIDs) {\n      int docID = docIdInt.intValue();\n      reader.deleteDocument(docID);\n      delCount++;\n    }\n\n    // Delete by query\n    if (deletes.queries.size() > 0) {\n      IndexSearcher searcher = new IndexSearcher(reader);\n      assert searcher.getTopReaderContext().isAtomic;\n      final AtomicReaderContext readerContext = (AtomicReaderContext) searcher.getTopReaderContext();\n      try {\n        for (Entry<Query, Integer> entry : deletes.queries.entrySet()) {\n          Query query = entry.getKey();\n          int limit = entry.getValue().intValue();\n          Weight weight = query.weight(searcher);\n          Scorer scorer = weight.scorer(readerContext, Weight.ScorerContext.def());\n          if (scorer != null) {\n            while(true)  {\n              int doc = scorer.nextDoc();\n              if (doc >= limit)\n                break;\n\n              reader.deleteDocument(doc);\n              // TODO: we could/should change\n              // reader.deleteDocument to return boolean\n              // true if it did in fact delete, because here\n              // we could be deleting an already-deleted doc\n              // which makes this an upper bound:\n              delCount++;\n            }\n          }\n        }\n      } finally {\n        searcher.close();\n      }\n    }\n\n    return delCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"69a6d2d525aeab53c867ed26934185e5bb627d0e","date":1296516902,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(BufferedDeletes,SegmentReader).mjava","sourceNew":null,"sourceOld":"  private synchronized long applyDeletes(BufferedDeletes deletes, SegmentReader reader) throws IOException {\n\n    long delCount = 0;\n\n    assert checkDeleteTerm(null);\n    \n    if (deletes.terms.size() > 0) {\n      Fields fields = reader.fields();\n      if (fields == null) {\n        // This reader has no postings\n        return 0;\n      }\n\n      TermsEnum termsEnum = null;\n        \n      String currentField = null;\n      DocsEnum docs = null;\n        \n      for (Entry<Term,Integer> entry: deletes.terms.entrySet()) {\n        Term term = entry.getKey();\n        // Since we visit terms sorted, we gain performance\n        // by re-using the same TermsEnum and seeking only\n        // forwards\n        if (term.field() != currentField) {\n          assert currentField == null || currentField.compareTo(term.field()) < 0;\n          currentField = term.field();\n          Terms terms = fields.terms(currentField);\n          if (terms != null) {\n            termsEnum = terms.iterator();\n          } else {\n            termsEnum = null;\n          }\n        }\n          \n        if (termsEnum == null) {\n          continue;\n        }\n        assert checkDeleteTerm(term);\n          \n        if (termsEnum.seek(term.bytes(), false) == TermsEnum.SeekStatus.FOUND) {\n          DocsEnum docsEnum = termsEnum.docs(reader.getDeletedDocs(), docs);\n            \n          if (docsEnum != null) {\n            docs = docsEnum;\n            final int limit = entry.getValue();\n            while (true) {\n              final int docID = docs.nextDoc();\n              if (docID == DocsEnum.NO_MORE_DOCS || docID >= limit) {\n                break;\n              }\n              reader.deleteDocument(docID);\n              // TODO: we could/should change\n              // reader.deleteDocument to return boolean\n              // true if it did in fact delete, because here\n              // we could be deleting an already-deleted doc\n              // which makes this an upper bound:\n              delCount++;\n            }\n          }\n        }\n      }\n    }\n\n    // Delete by docID\n    for (Integer docIdInt : deletes.docIDs) {\n      int docID = docIdInt.intValue();\n      reader.deleteDocument(docID);\n      delCount++;\n    }\n\n    // Delete by query\n    if (deletes.queries.size() > 0) {\n      IndexSearcher searcher = new IndexSearcher(reader);\n      assert searcher.getTopReaderContext().isAtomic;\n      final AtomicReaderContext readerContext = (AtomicReaderContext) searcher.getTopReaderContext();\n      try {\n        for (Entry<Query, Integer> entry : deletes.queries.entrySet()) {\n          Query query = entry.getKey();\n          int limit = entry.getValue().intValue();\n          Weight weight = query.weight(searcher);\n          Scorer scorer = weight.scorer(readerContext, Weight.ScorerContext.def());\n          if (scorer != null) {\n            while(true)  {\n              int doc = scorer.nextDoc();\n              if (doc >= limit)\n                break;\n\n              reader.deleteDocument(doc);\n              // TODO: we could/should change\n              // reader.deleteDocument to return boolean\n              // true if it did in fact delete, because here\n              // we could be deleting an already-deleted doc\n              // which makes this an upper bound:\n              delCount++;\n            }\n          }\n        }\n      } finally {\n        searcher.close();\n      }\n    }\n\n    return delCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"69a6d2d525aeab53c867ed26934185e5bb627d0e":["c19f985e36a65cc969e8e564fe337a0d41512075"],"c19f985e36a65cc969e8e564fe337a0d41512075":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["69a6d2d525aeab53c867ed26934185e5bb627d0e"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c19f985e36a65cc969e8e564fe337a0d41512075"],"69a6d2d525aeab53c867ed26934185e5bb627d0e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c19f985e36a65cc969e8e564fe337a0d41512075":["69a6d2d525aeab53c867ed26934185e5bb627d0e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}