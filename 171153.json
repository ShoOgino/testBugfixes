{"path":"src/java/org/apache/lucene/analysis/ru/RussianStemmer#setEndings().mjava","commits":[{"id":"70aa49bffe8257a0135ed4eea2633937e92e99a6","date":1032144718,"type":0,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/ru/RussianStemmer#setEndings().mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Set ending definition as in Russian stemming algorithm.\n     * Creation date: (16/03/2002 11:16:36 PM)\n     */\n    private void setEndings()\n    {\n        vowels = new char[] { A, E, I, O, U, Y, AE, IU, IA };\n\n        perfectiveGerundEndings1 = new char[][] {\n            { V }, { V, SH, I }, { V, SH, I, S, SOFT }\n        };\n\n        perfectiveGerund1Predessors = new char[][] { { A }, { IA }\n        };\n\n        perfectiveGerundEndings2 = new char[][] {\n            { I, V },\n            { Y, V },\n            { I, V, SH, I },\n            { Y, V, SH, I },\n            { I, V, SH, I, S, SOFT },\n            { Y, V, SH, I, S, SOFT }\n        };\n\n        adjectiveEndings = new char[][] {\n            { E, E },\n            { I, E },\n            { Y, E },\n            { O, E },\n            { E, I_ },\n            { I, I_ },\n            { Y, I_ },\n            { O, I_ },\n            { E, M },\n            { I, M },\n            { Y, M },\n            { O, M },\n            { I, X },\n            { Y, X },\n            { U, IU },\n            { IU, IU },\n            { A, IA },\n            { IA, IA },\n            { O, IU },\n            { E, IU },\n            { I, M, I },\n            { Y, M, I },\n            { E, G, O },\n            { O, G, O },\n            { E, M, U },\n            { O, M, U }\n        };\n\n        participleEndings1 = new char[][] {\n            { SHCH },\n            { E, M },\n            { N, N },\n            { V, SH },\n            { IU, SHCH }\n        };\n\n        participleEndings2 = new char[][] {\n            { I, V, SH },\n            { Y, V, SH },\n            { U, IU, SHCH }\n        };\n\n        participle1Predessors = new char[][] {\n            { A },\n            { IA }\n        };\n\n        reflexiveEndings = new char[][] {\n            { S, IA },\n            { S, SOFT }\n        };\n\n        verbEndings1 = new char[][] {\n            { I_ },\n            { L },\n            { N },\n            { L, O },\n            { N, O },\n            { E, T },\n            { IU, T },\n            { L, A },\n            { N, A },\n            { L, I },\n            { E, M },\n            { N, Y },\n            { E, T, E },\n            { I_, T, E },\n            { T, SOFT },\n            { E, SH, SOFT },\n            { N, N, O }\n        };\n\n        verbEndings2 = new char[][] {\n            { IU },\n            { U, IU },\n            { E, N },\n            { E, I_ },\n            { IA, T },\n            { U, I_ },\n            { I, L },\n            { Y, L },\n            { I, M },\n            { Y, M },\n            { I, T },\n            { Y, T },\n            { I, L, A },\n            { Y, L, A },\n            { E, N, A },\n            { I, T, E },\n            { I, L, I },\n            { Y, L, I },\n            { I, L, O },\n            { Y, L, O },\n            { E, N, O },\n            { U, E, T },\n            { U, IU, T },\n            { E, N, Y },\n            { I, T, SOFT },\n            { Y, T, SOFT },\n            { I, SH, SOFT },\n            { E, I_, T, E },\n            { U, I_, T, E }\n        };\n\n        verb1Predessors = new char[][] {\n            { A },\n            { IA }\n        };\n\n        nounEndings = new char[][] {\n            { A },\n            { IU },\n            { I_ },\n            { O },\n            { U },\n            { E },\n            { Y },\n            { I },\n            { SOFT },\n            { IA },\n            { E, V },\n            { O, V },\n            { I, E },\n            { SOFT, E },\n            { IA, X },\n            { I, IU },\n            { E, I },\n            { I, I },\n            { E, I_ },\n            { O, I_ },\n            { E, M },\n            { A, M },\n            { O, M },\n            { A, X },\n            { SOFT, IU },\n            { I, IA },\n            { SOFT, IA },\n            { I, I_ },\n            { IA, M },\n            { IA, M, I },\n            { A, M, I },\n            { I, E, I_ },\n            { I, IA, M },\n            { I, E, M },\n            { I, IA, X },\n            { I, IA, M, I }\n        };\n\n        superlativeEndings = new char[][] {\n            { E, I_, SH },\n            { E, I_, SH, E }\n        };\n\n        derivationalEndings = new char[][] {\n            { O, S, T },\n            { O, S, T, SOFT }\n        };\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd07a421953319d10081b50e7083bd19680615be","date":1092482077,"type":4,"author":"Daniel Naber","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/analysis/ru/RussianStemmer#setEndings().mjava","sourceNew":null,"sourceOld":"    /**\n     * Set ending definition as in Russian stemming algorithm.\n     * Creation date: (16/03/2002 11:16:36 PM)\n     */\n    private void setEndings()\n    {\n        vowels = new char[] { A, E, I, O, U, Y, AE, IU, IA };\n\n        perfectiveGerundEndings1 = new char[][] {\n            { V }, { V, SH, I }, { V, SH, I, S, SOFT }\n        };\n\n        perfectiveGerund1Predessors = new char[][] { { A }, { IA }\n        };\n\n        perfectiveGerundEndings2 = new char[][] {\n            { I, V },\n            { Y, V },\n            { I, V, SH, I },\n            { Y, V, SH, I },\n            { I, V, SH, I, S, SOFT },\n            { Y, V, SH, I, S, SOFT }\n        };\n\n        adjectiveEndings = new char[][] {\n            { E, E },\n            { I, E },\n            { Y, E },\n            { O, E },\n            { E, I_ },\n            { I, I_ },\n            { Y, I_ },\n            { O, I_ },\n            { E, M },\n            { I, M },\n            { Y, M },\n            { O, M },\n            { I, X },\n            { Y, X },\n            { U, IU },\n            { IU, IU },\n            { A, IA },\n            { IA, IA },\n            { O, IU },\n            { E, IU },\n            { I, M, I },\n            { Y, M, I },\n            { E, G, O },\n            { O, G, O },\n            { E, M, U },\n            { O, M, U }\n        };\n\n        participleEndings1 = new char[][] {\n            { SHCH },\n            { E, M },\n            { N, N },\n            { V, SH },\n            { IU, SHCH }\n        };\n\n        participleEndings2 = new char[][] {\n            { I, V, SH },\n            { Y, V, SH },\n            { U, IU, SHCH }\n        };\n\n        participle1Predessors = new char[][] {\n            { A },\n            { IA }\n        };\n\n        reflexiveEndings = new char[][] {\n            { S, IA },\n            { S, SOFT }\n        };\n\n        verbEndings1 = new char[][] {\n            { I_ },\n            { L },\n            { N },\n            { L, O },\n            { N, O },\n            { E, T },\n            { IU, T },\n            { L, A },\n            { N, A },\n            { L, I },\n            { E, M },\n            { N, Y },\n            { E, T, E },\n            { I_, T, E },\n            { T, SOFT },\n            { E, SH, SOFT },\n            { N, N, O }\n        };\n\n        verbEndings2 = new char[][] {\n            { IU },\n            { U, IU },\n            { E, N },\n            { E, I_ },\n            { IA, T },\n            { U, I_ },\n            { I, L },\n            { Y, L },\n            { I, M },\n            { Y, M },\n            { I, T },\n            { Y, T },\n            { I, L, A },\n            { Y, L, A },\n            { E, N, A },\n            { I, T, E },\n            { I, L, I },\n            { Y, L, I },\n            { I, L, O },\n            { Y, L, O },\n            { E, N, O },\n            { U, E, T },\n            { U, IU, T },\n            { E, N, Y },\n            { I, T, SOFT },\n            { Y, T, SOFT },\n            { I, SH, SOFT },\n            { E, I_, T, E },\n            { U, I_, T, E }\n        };\n\n        verb1Predessors = new char[][] {\n            { A },\n            { IA }\n        };\n\n        nounEndings = new char[][] {\n            { A },\n            { IU },\n            { I_ },\n            { O },\n            { U },\n            { E },\n            { Y },\n            { I },\n            { SOFT },\n            { IA },\n            { E, V },\n            { O, V },\n            { I, E },\n            { SOFT, E },\n            { IA, X },\n            { I, IU },\n            { E, I },\n            { I, I },\n            { E, I_ },\n            { O, I_ },\n            { E, M },\n            { A, M },\n            { O, M },\n            { A, X },\n            { SOFT, IU },\n            { I, IA },\n            { SOFT, IA },\n            { I, I_ },\n            { IA, M },\n            { IA, M, I },\n            { A, M, I },\n            { I, E, I_ },\n            { I, IA, M },\n            { I, E, M },\n            { I, IA, X },\n            { I, IA, M, I }\n        };\n\n        superlativeEndings = new char[][] {\n            { E, I_, SH },\n            { E, I_, SH, E }\n        };\n\n        derivationalEndings = new char[][] {\n            { O, S, T },\n            { O, S, T, SOFT }\n        };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"dd07a421953319d10081b50e7083bd19680615be":["70aa49bffe8257a0135ed4eea2633937e92e99a6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["dd07a421953319d10081b50e7083bd19680615be"],"70aa49bffe8257a0135ed4eea2633937e92e99a6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["70aa49bffe8257a0135ed4eea2633937e92e99a6"],"dd07a421953319d10081b50e7083bd19680615be":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"70aa49bffe8257a0135ed4eea2633937e92e99a6":["dd07a421953319d10081b50e7083bd19680615be"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}