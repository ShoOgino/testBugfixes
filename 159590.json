{"path":"src/java/org/apache/solr/search/DisMaxQParser#parse().mjava","commits":[{"id":"bf4d5ca2c75db0d2c7a9bd0ce5a8f92475ebae58","date":1243018718,"type":1,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/search/DisMaxQParser#parse().mjava","pathOld":"src/java/org/apache/solr/search/DismaxQParser[DisMaxQParserPlugin]#parse().mjava","sourceNew":"  public Query parse() throws ParseException {\n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    IndexSchema schema = req.getSchema();\n\n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    Map<String, Float> phraseFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.PF));\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    /* a generic parser for parsing regular lucene queries */\n    QueryParser p = schema.getSolrQueryParser(null);\n\n    /* a parser for dealing with user input, which will convert\n     * things to DisjunctionMaxQueries\n     */\n    SolrPluginUtils.DisjunctionMaxQueryParser up =\n            new SolrPluginUtils.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    up.addAlias(IMPOSSIBLE_FIELD_NAME,\n            tiebreaker, queryFields);\n    up.setPhraseSlop(qslop);\n\n    /* for parsing sloppy phrases using DisjunctionMaxQueries */\n    SolrPluginUtils.DisjunctionMaxQueryParser pp =\n            new SolrPluginUtils.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n            tiebreaker, phraseFields);\n    pp.setPhraseSlop(pslop);\n\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if (userQuery == null || userQuery.trim().length() < 1) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get(DisMaxParams.ALTQ);\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.parse();\n        query.add(altUserQuery, BooleanClause.Occur.MUST);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"missing query string\");\n      }\n    } else {\n      // There is a valid query string\n      userQuery = SolrPluginUtils.partialEscape(SolrPluginUtils.stripUnbalancedQuotes(userQuery)).toString();\n      userQuery = SolrPluginUtils.stripIllegalOperators(userQuery).toString();\n\n      String minShouldMatch = solrParams.get(DisMaxParams.MM, \"100%\");\n      Query dis = up.parse(userQuery);\n      parsedUserQuery = dis;\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery) dis);\n        SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n        parsedUserQuery = t;\n      }\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n\n      /* * * Add on Phrases for the Query * * */\n\n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, strip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\", \"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    //List<Query> boostQueries = SolrPluginUtils.parseQueryStrings(req, boostParams);\n    boostQueries = null;\n    if (boostParams != null && boostParams.length > 0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length() == 0) continue;\n        Query q = subQuery(qs, null).parse();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      if (1 == boostQueries.size() && 1 == boostParams.length) {\n        /* legacy logic */\n        Query f = boostQueries.get(0);\n        if (1.0f == f.getBoost() && f instanceof BooleanQuery) {\n          /* if the default boost was used, and we've got a BooleanQuery\n           * extract the subqueries out and use them directly\n           */\n          for (Object c : ((BooleanQuery) f).clauses()) {\n            query.add((BooleanClause) c);\n          }\n        } else {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      } else {\n        for (Query f : boostQueries) {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if (null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String, Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).parse();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    return query;\n  }\n\n","sourceOld":"  public Query parse() throws ParseException {\n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    IndexSchema schema = req.getSchema();\n\n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    Map<String,Float> phraseFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.PF));\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    /* a parser for dealing with user input, which will convert\n     * things to DisjunctionMaxQueries\n     */\n    SolrPluginUtils.DisjunctionMaxQueryParser up =\n      new SolrPluginUtils.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n    up.setPhraseSlop(qslop);\n\n    /* for parsing sloppy phrases using DisjunctionMaxQueries */\n    SolrPluginUtils.DisjunctionMaxQueryParser pp =\n      new SolrPluginUtils.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, phraseFields);\n    pp.setPhraseSlop(pslop);\n\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.parse();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {\n      // There is a valid query string\n      userQuery = SolrPluginUtils.partialEscape(SolrPluginUtils.stripUnbalancedQuotes(userQuery)).toString();\n      userQuery = SolrPluginUtils.stripIllegalOperators(userQuery).toString();\n\n      String minShouldMatch = solrParams.get(DisMaxParams.MM, \"100%\");\n      Query dis = up.parse(userQuery);\n      parsedUserQuery = dis;\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)dis);\n        SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n        parsedUserQuery = t;\n      }\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n\n      /* * * Add on Phrases for the Query * * */\n\n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, strip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    //List<Query> boostQueries = SolrPluginUtils.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).parse();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      if(1 == boostQueries.size() && 1 == boostParams.length) {\n        /* legacy logic */\n        Query f = boostQueries.get(0);\n        if (1.0f == f.getBoost() && f instanceof BooleanQuery) {\n          /* if the default boost was used, and we've got a BooleanQuery\n           * extract the subqueries out and use them directly\n           */\n          for (Object c : ((BooleanQuery)f).clauses()) {\n            query.add((BooleanClause)c);\n          }\n        } else {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      } else {\n        for(Query f : boostQueries) {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).parse();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"50de217601652b8d4bff9f8ac567455920c85891","date":1243497655,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/search/DisMaxQParser#parse().mjava","pathOld":"src/java/org/apache/solr/search/DisMaxQParser#parse().mjava","sourceNew":"  public Query parse() throws ParseException {\n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    addMainQuery(query, solrParams);\n    addBoostQuery(query, solrParams);\n    addBoostFunctions(query, solrParams);\n\n    return query;\n  }\n\n","sourceOld":"  public Query parse() throws ParseException {\n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    IndexSchema schema = req.getSchema();\n\n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    Map<String, Float> phraseFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.PF));\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    /* a generic parser for parsing regular lucene queries */\n    QueryParser p = schema.getSolrQueryParser(null);\n\n    /* a parser for dealing with user input, which will convert\n     * things to DisjunctionMaxQueries\n     */\n    SolrPluginUtils.DisjunctionMaxQueryParser up =\n            new SolrPluginUtils.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    up.addAlias(IMPOSSIBLE_FIELD_NAME,\n            tiebreaker, queryFields);\n    up.setPhraseSlop(qslop);\n\n    /* for parsing sloppy phrases using DisjunctionMaxQueries */\n    SolrPluginUtils.DisjunctionMaxQueryParser pp =\n            new SolrPluginUtils.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n            tiebreaker, phraseFields);\n    pp.setPhraseSlop(pslop);\n\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if (userQuery == null || userQuery.trim().length() < 1) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get(DisMaxParams.ALTQ);\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.parse();\n        query.add(altUserQuery, BooleanClause.Occur.MUST);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"missing query string\");\n      }\n    } else {\n      // There is a valid query string\n      userQuery = SolrPluginUtils.partialEscape(SolrPluginUtils.stripUnbalancedQuotes(userQuery)).toString();\n      userQuery = SolrPluginUtils.stripIllegalOperators(userQuery).toString();\n\n      String minShouldMatch = solrParams.get(DisMaxParams.MM, \"100%\");\n      Query dis = up.parse(userQuery);\n      parsedUserQuery = dis;\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery) dis);\n        SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n        parsedUserQuery = t;\n      }\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n\n      /* * * Add on Phrases for the Query * * */\n\n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, strip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\", \"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    //List<Query> boostQueries = SolrPluginUtils.parseQueryStrings(req, boostParams);\n    boostQueries = null;\n    if (boostParams != null && boostParams.length > 0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length() == 0) continue;\n        Query q = subQuery(qs, null).parse();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      if (1 == boostQueries.size() && 1 == boostParams.length) {\n        /* legacy logic */\n        Query f = boostQueries.get(0);\n        if (1.0f == f.getBoost() && f instanceof BooleanQuery) {\n          /* if the default boost was used, and we've got a BooleanQuery\n           * extract the subqueries out and use them directly\n           */\n          for (Object c : ((BooleanQuery) f).clauses()) {\n            query.add((BooleanClause) c);\n          }\n        } else {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      } else {\n        for (Query f : boostQueries) {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if (null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String, Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).parse();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b63aae1b4446787889e3e4acf66a8a1190caf9fc","date":1266980445,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/search/DisMaxQParser#parse().mjava","pathOld":"src/java/org/apache/solr/search/DisMaxQParser#parse().mjava","sourceNew":"  public Query parse() throws ParseException {\n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    addMainQuery(query, solrParams);\n    addBoostQuery(query, solrParams);\n    addBoostFunctions(query, solrParams);\n\n    return query;\n  }\n\n","sourceOld":"  public Query parse() throws ParseException {\n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    addMainQuery(query, solrParams);\n    addBoostQuery(query, solrParams);\n    addBoostFunctions(query, solrParams);\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/DisMaxQParser#parse().mjava","pathOld":"src/java/org/apache/solr/search/DisMaxQParser#parse().mjava","sourceNew":"  public Query parse() throws ParseException {\n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    addMainQuery(query, solrParams);\n    addBoostQuery(query, solrParams);\n    addBoostFunctions(query, solrParams);\n\n    return query;\n  }\n\n","sourceOld":"  public Query parse() throws ParseException {\n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    addMainQuery(query, solrParams);\n    addBoostQuery(query, solrParams);\n    addBoostFunctions(query, solrParams);\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b63aae1b4446787889e3e4acf66a8a1190caf9fc":["50de217601652b8d4bff9f8ac567455920c85891"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"ad94625fb8d088209f46650c8097196fec67f00c":["b63aae1b4446787889e3e4acf66a8a1190caf9fc"],"50de217601652b8d4bff9f8ac567455920c85891":["bf4d5ca2c75db0d2c7a9bd0ce5a8f92475ebae58"],"bf4d5ca2c75db0d2c7a9bd0ce5a8f92475ebae58":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"b63aae1b4446787889e3e4acf66a8a1190caf9fc":["ad94625fb8d088209f46650c8097196fec67f00c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["bf4d5ca2c75db0d2c7a9bd0ce5a8f92475ebae58"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"50de217601652b8d4bff9f8ac567455920c85891":["b63aae1b4446787889e3e4acf66a8a1190caf9fc"],"bf4d5ca2c75db0d2c7a9bd0ce5a8f92475ebae58":["50de217601652b8d4bff9f8ac567455920c85891"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}