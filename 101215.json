{"path":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","commits":[{"id":"fde68de507dbf344495d7b5e8052866fe5f254ab","date":1189434831,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document).mjava","sourceNew":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized ThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    ThreadState state = (ThreadState) threadBindings.get(Thread.currentThread());\n    if (state == null) {\n      // First time this thread has called us since last flush\n      ThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        ThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length == MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        ThreadState[] newArray = new ThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new ThreadState();\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    while(!state.isIdle || pauseThreads != 0 || flushPending)\n      try {\n        wait();\n      } catch (InterruptedException e) {}\n\n    if (segment == null)\n      segment = writer.newSegmentName();\n\n    numDocsInRAM++;\n\n    // We must at this point commit to flushing to ensure we\n    // always get N docs when we flush by doc count, even if\n    // > 1 thread is adding documents:\n    /* new merge policy\n    if (!flushPending && maxBufferedDocs > 0 && numDocsInRAM >= maxBufferedDocs) {\n    */\n    if (!flushPending && ramBufferSize == 0 && numDocsInRAM >= maxBufferedDocs) {\n      flushPending = true;\n      state.doFlushAfter = true;\n    } else\n      state.doFlushAfter = false;\n\n    state.isIdle = false;\n\n    boolean success = false;\n    try {\n      state.init(doc, nextDocID++);\n      success = true;\n    } finally {\n      if (!success) {\n        state.isIdle = true;\n        if (state.doFlushAfter) {\n          state.doFlushAfter = false;\n          flushPending = false;\n        }\n        abort();\n      }\n    }\n\n    if (delTerm != null)\n      addDeleteTerm(delTerm, state.docID);\n\n    return state;\n  }\n\n","sourceOld":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending. */\n  synchronized ThreadState getThreadState(Document doc) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    ThreadState state = (ThreadState) threadBindings.get(Thread.currentThread());\n    if (state == null) {\n      // First time this thread has called us since last flush\n      ThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        ThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length == MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        ThreadState[] newArray = new ThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new ThreadState();\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    while(!state.isIdle || pauseThreads != 0 || flushPending)\n      try {\n        wait();\n      } catch (InterruptedException e) {}\n\n    if (segment == null)\n      segment = writer.newSegmentName();\n\n    numDocsInRAM++;\n\n    // We must at this point commit to flushing to ensure we\n    // always get N docs when we flush by doc count, even if\n    // > 1 thread is adding documents:\n    /* new merge policy\n    if (!flushPending && maxBufferedDocs > 0 && numDocsInRAM >= maxBufferedDocs) {\n    */\n    if (!flushPending && ramBufferSize == 0 && numDocsInRAM >= maxBufferedDocs) {\n      flushPending = true;\n      state.doFlushAfter = true;\n    } else\n      state.doFlushAfter = false;\n\n    state.isIdle = false;\n\n    boolean success = false;\n    try {\n      state.init(doc, nextDocID++);\n      success = true;\n    } finally {\n      if (!success) {\n        state.isIdle = true;\n        if (state.doFlushAfter) {\n          state.doFlushAfter = false;\n          flushPending = false;\n        }\n        abort();\n      }\n    }\n\n    return state;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b1405362241b561f5590ff4a87d5d6e173bcd9cf","date":1190107634,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","sourceNew":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized ThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    ThreadState state = (ThreadState) threadBindings.get(Thread.currentThread());\n    if (state == null) {\n      // First time this thread has called us since last flush\n      ThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        ThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length == MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        ThreadState[] newArray = new ThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new ThreadState();\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    while(!state.isIdle || pauseThreads != 0 || flushPending)\n      try {\n        wait();\n      } catch (InterruptedException e) {}\n\n    if (segment == null)\n      segment = writer.newSegmentName();\n\n    numDocsInRAM++;\n    numDocsInStore++;\n\n    // We must at this point commit to flushing to ensure we\n    // always get N docs when we flush by doc count, even if\n    // > 1 thread is adding documents:\n    /* new merge policy\n    if (!flushPending && maxBufferedDocs > 0 && numDocsInRAM >= maxBufferedDocs) {\n    */\n    if (!flushPending && ramBufferSize == 0 && numDocsInRAM >= maxBufferedDocs) {\n      flushPending = true;\n      state.doFlushAfter = true;\n    } else\n      state.doFlushAfter = false;\n\n    state.isIdle = false;\n\n    boolean success = false;\n    try {\n      state.init(doc, nextDocID++);\n      success = true;\n    } finally {\n      if (!success) {\n        state.isIdle = true;\n        if (state.doFlushAfter) {\n          state.doFlushAfter = false;\n          flushPending = false;\n        }\n        abort();\n      }\n    }\n\n    if (delTerm != null)\n      addDeleteTerm(delTerm, state.docID);\n\n    return state;\n  }\n\n","sourceOld":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized ThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    ThreadState state = (ThreadState) threadBindings.get(Thread.currentThread());\n    if (state == null) {\n      // First time this thread has called us since last flush\n      ThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        ThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length == MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        ThreadState[] newArray = new ThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new ThreadState();\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    while(!state.isIdle || pauseThreads != 0 || flushPending)\n      try {\n        wait();\n      } catch (InterruptedException e) {}\n\n    if (segment == null)\n      segment = writer.newSegmentName();\n\n    numDocsInRAM++;\n\n    // We must at this point commit to flushing to ensure we\n    // always get N docs when we flush by doc count, even if\n    // > 1 thread is adding documents:\n    /* new merge policy\n    if (!flushPending && maxBufferedDocs > 0 && numDocsInRAM >= maxBufferedDocs) {\n    */\n    if (!flushPending && ramBufferSize == 0 && numDocsInRAM >= maxBufferedDocs) {\n      flushPending = true;\n      state.doFlushAfter = true;\n    } else\n      state.doFlushAfter = false;\n\n    state.isIdle = false;\n\n    boolean success = false;\n    try {\n      state.init(doc, nextDocID++);\n      success = true;\n    } finally {\n      if (!success) {\n        state.isIdle = true;\n        if (state.doFlushAfter) {\n          state.doFlushAfter = false;\n          flushPending = false;\n        }\n        abort();\n      }\n    }\n\n    if (delTerm != null)\n      addDeleteTerm(delTerm, state.docID);\n\n    return state;\n  }\n\n","bugFix":null,"bugIntro":["49adbad5232116eb2448ea8166464e6a68bca007"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2558ddf9e14a97bc597f5b72bb3ecb5b7f6bba8e","date":1191352543,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","sourceNew":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized ThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    ThreadState state = (ThreadState) threadBindings.get(Thread.currentThread());\n    if (state == null) {\n      // First time this thread has called us since last flush\n      ThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        ThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length == MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        ThreadState[] newArray = new ThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new ThreadState();\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    while(!state.isIdle || pauseThreads != 0 || flushPending)\n      try {\n        wait();\n      } catch (InterruptedException e) {}\n\n    if (segment == null)\n      segment = writer.newSegmentName();\n\n    numDocsInRAM++;\n    numDocsInStore++;\n\n    // We must at this point commit to flushing to ensure we\n    // always get N docs when we flush by doc count, even if\n    // > 1 thread is adding documents:\n    if (!flushPending && maxBufferedDocs != IndexWriter.DISABLE_AUTO_FLUSH\n        && numDocsInRAM >= maxBufferedDocs) {\n      flushPending = true;\n      state.doFlushAfter = true;\n    } else\n      state.doFlushAfter = false;\n\n    state.isIdle = false;\n\n    boolean success = false;\n    try {\n      state.init(doc, nextDocID++);\n      success = true;\n    } finally {\n      if (!success) {\n        state.isIdle = true;\n        if (state.doFlushAfter) {\n          state.doFlushAfter = false;\n          flushPending = false;\n        }\n        abort();\n      }\n    }\n\n    if (delTerm != null) {\n      addDeleteTerm(delTerm, state.docID);\n      if (!state.doFlushAfter) {\n        state.doFlushAfter = timeToFlushDeletes();\n      }\n    }\n\n    return state;\n  }\n\n","sourceOld":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized ThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    ThreadState state = (ThreadState) threadBindings.get(Thread.currentThread());\n    if (state == null) {\n      // First time this thread has called us since last flush\n      ThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        ThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length == MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        ThreadState[] newArray = new ThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new ThreadState();\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    while(!state.isIdle || pauseThreads != 0 || flushPending)\n      try {\n        wait();\n      } catch (InterruptedException e) {}\n\n    if (segment == null)\n      segment = writer.newSegmentName();\n\n    numDocsInRAM++;\n    numDocsInStore++;\n\n    // We must at this point commit to flushing to ensure we\n    // always get N docs when we flush by doc count, even if\n    // > 1 thread is adding documents:\n    /* new merge policy\n    if (!flushPending && maxBufferedDocs > 0 && numDocsInRAM >= maxBufferedDocs) {\n    */\n    if (!flushPending && ramBufferSize == 0 && numDocsInRAM >= maxBufferedDocs) {\n      flushPending = true;\n      state.doFlushAfter = true;\n    } else\n      state.doFlushAfter = false;\n\n    state.isIdle = false;\n\n    boolean success = false;\n    try {\n      state.init(doc, nextDocID++);\n      success = true;\n    } finally {\n      if (!success) {\n        state.isIdle = true;\n        if (state.doFlushAfter) {\n          state.doFlushAfter = false;\n          flushPending = false;\n        }\n        abort();\n      }\n    }\n\n    if (delTerm != null)\n      addDeleteTerm(delTerm, state.docID);\n\n    return state;\n  }\n\n","bugFix":null,"bugIntro":["8560794cda5bcd510c60e38ed553e9c5a6204983","ac1242ce6d99813874fddfe4ca5f57779beddb22"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8560794cda5bcd510c60e38ed553e9c5a6204983","date":1196807382,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","sourceNew":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized ThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    ThreadState state = (ThreadState) threadBindings.get(Thread.currentThread());\n    if (state == null) {\n      // First time this thread has called us since last flush\n      ThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        ThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length == MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        ThreadState[] newArray = new ThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new ThreadState();\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    while(!state.isIdle || pauseThreads != 0 || flushPending)\n      try {\n        wait();\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n\n    if (segment == null)\n      segment = writer.newSegmentName();\n\n    numDocsInRAM++;\n    numDocsInStore++;\n\n    // We must at this point commit to flushing to ensure we\n    // always get N docs when we flush by doc count, even if\n    // > 1 thread is adding documents:\n    if (!flushPending && maxBufferedDocs != IndexWriter.DISABLE_AUTO_FLUSH\n        && numDocsInRAM >= maxBufferedDocs) {\n      flushPending = true;\n      state.doFlushAfter = true;\n    } else\n      state.doFlushAfter = false;\n\n    state.isIdle = false;\n\n    boolean success = false;\n    try {\n      state.init(doc, nextDocID++);\n\n      if (delTerm != null) {\n        addDeleteTerm(delTerm, state.docID);\n        if (!state.doFlushAfter)\n          state.doFlushAfter = timeToFlushDeletes();\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        synchronized(this) {\n          state.isIdle = true;\n          if (state.doFlushAfter) {\n            state.doFlushAfter = false;\n            flushPending = false;\n          }\n          notifyAll();\n        }\n      }\n    }\n\n    return state;\n  }\n\n","sourceOld":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized ThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    ThreadState state = (ThreadState) threadBindings.get(Thread.currentThread());\n    if (state == null) {\n      // First time this thread has called us since last flush\n      ThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        ThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length == MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        ThreadState[] newArray = new ThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new ThreadState();\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    while(!state.isIdle || pauseThreads != 0 || flushPending)\n      try {\n        wait();\n      } catch (InterruptedException e) {}\n\n    if (segment == null)\n      segment = writer.newSegmentName();\n\n    numDocsInRAM++;\n    numDocsInStore++;\n\n    // We must at this point commit to flushing to ensure we\n    // always get N docs when we flush by doc count, even if\n    // > 1 thread is adding documents:\n    if (!flushPending && maxBufferedDocs != IndexWriter.DISABLE_AUTO_FLUSH\n        && numDocsInRAM >= maxBufferedDocs) {\n      flushPending = true;\n      state.doFlushAfter = true;\n    } else\n      state.doFlushAfter = false;\n\n    state.isIdle = false;\n\n    boolean success = false;\n    try {\n      state.init(doc, nextDocID++);\n      success = true;\n    } finally {\n      if (!success) {\n        state.isIdle = true;\n        if (state.doFlushAfter) {\n          state.doFlushAfter = false;\n          flushPending = false;\n        }\n        abort();\n      }\n    }\n\n    if (delTerm != null) {\n      addDeleteTerm(delTerm, state.docID);\n      if (!state.doFlushAfter) {\n        state.doFlushAfter = timeToFlushDeletes();\n      }\n    }\n\n    return state;\n  }\n\n","bugFix":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c","2558ddf9e14a97bc597f5b72bb3ecb5b7f6bba8e","fde68de507dbf344495d7b5e8052866fe5f254ab"],"bugIntro":["83bbb041887bbef07b8a98d08a0e1713ce137039"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"346d5897e4c4e77ed5dbd31f7730ff30973d5971","date":1198317988,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","sourceNew":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized ThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    ThreadState state = (ThreadState) threadBindings.get(Thread.currentThread());\n    if (state == null) {\n      // First time this thread has called us since last flush\n      ThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        ThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length == MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        ThreadState[] newArray = new ThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new ThreadState();\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    while(!state.isIdle || pauseThreads != 0 || flushPending)\n      try {\n        wait();\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n\n    if (closed)\n      throw new AlreadyClosedException(\"this IndexWriter is closed\");\n\n    if (segment == null)\n      segment = writer.newSegmentName();\n\n    numDocsInRAM++;\n    numDocsInStore++;\n\n    // We must at this point commit to flushing to ensure we\n    // always get N docs when we flush by doc count, even if\n    // > 1 thread is adding documents:\n    if (!flushPending && maxBufferedDocs != IndexWriter.DISABLE_AUTO_FLUSH\n        && numDocsInRAM >= maxBufferedDocs) {\n      flushPending = true;\n      state.doFlushAfter = true;\n    } else\n      state.doFlushAfter = false;\n\n    state.isIdle = false;\n\n    boolean success = false;\n    try {\n      state.init(doc, nextDocID++);\n\n      if (delTerm != null) {\n        addDeleteTerm(delTerm, state.docID);\n        if (!state.doFlushAfter)\n          state.doFlushAfter = timeToFlushDeletes();\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        synchronized(this) {\n          state.isIdle = true;\n          if (state.doFlushAfter) {\n            state.doFlushAfter = false;\n            flushPending = false;\n          }\n          notifyAll();\n        }\n      }\n    }\n\n    return state;\n  }\n\n","sourceOld":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized ThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    ThreadState state = (ThreadState) threadBindings.get(Thread.currentThread());\n    if (state == null) {\n      // First time this thread has called us since last flush\n      ThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        ThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length == MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        ThreadState[] newArray = new ThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new ThreadState();\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    while(!state.isIdle || pauseThreads != 0 || flushPending)\n      try {\n        wait();\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n\n    if (segment == null)\n      segment = writer.newSegmentName();\n\n    numDocsInRAM++;\n    numDocsInStore++;\n\n    // We must at this point commit to flushing to ensure we\n    // always get N docs when we flush by doc count, even if\n    // > 1 thread is adding documents:\n    if (!flushPending && maxBufferedDocs != IndexWriter.DISABLE_AUTO_FLUSH\n        && numDocsInRAM >= maxBufferedDocs) {\n      flushPending = true;\n      state.doFlushAfter = true;\n    } else\n      state.doFlushAfter = false;\n\n    state.isIdle = false;\n\n    boolean success = false;\n    try {\n      state.init(doc, nextDocID++);\n\n      if (delTerm != null) {\n        addDeleteTerm(delTerm, state.docID);\n        if (!state.doFlushAfter)\n          state.doFlushAfter = timeToFlushDeletes();\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        synchronized(this) {\n          state.isIdle = true;\n          if (state.doFlushAfter) {\n            state.doFlushAfter = false;\n            flushPending = false;\n          }\n          notifyAll();\n        }\n      }\n    }\n\n    return state;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"83bbb041887bbef07b8a98d08a0e1713ce137039","date":1200330381,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","sourceNew":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized ThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    ThreadState state = (ThreadState) threadBindings.get(Thread.currentThread());\n    if (state == null) {\n      // First time this thread has called us since last flush\n      ThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        ThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length == MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        ThreadState[] newArray = new ThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new ThreadState();\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    while(!closed && (!state.isIdle || pauseThreads != 0 || flushPending || aborting))\n      try {\n        wait();\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n\n    if (closed)\n      throw new AlreadyClosedException(\"this IndexWriter is closed\");\n\n    if (segment == null)\n      segment = writer.newSegmentName();\n\n    numDocsInRAM++;\n    numDocsInStore++;\n\n    // We must at this point commit to flushing to ensure we\n    // always get N docs when we flush by doc count, even if\n    // > 1 thread is adding documents:\n    if (!flushPending && maxBufferedDocs != IndexWriter.DISABLE_AUTO_FLUSH\n        && numDocsInRAM >= maxBufferedDocs) {\n      flushPending = true;\n      state.doFlushAfter = true;\n    } else\n      state.doFlushAfter = false;\n\n    state.isIdle = false;\n\n    try {\n      boolean success = false;\n      try {\n        state.init(doc, nextDocID);\n        if (delTerm != null) {\n          addDeleteTerm(delTerm, state.docID);\n          if (!state.doFlushAfter)\n            state.doFlushAfter = timeToFlushDeletes();\n        }\n        // Only increment nextDocID on successful init\n        nextDocID++;\n        success = true;\n      } finally {\n        if (!success) {\n          // Forcefully idle this ThreadState:\n          state.isIdle = true;\n          notifyAll();\n          if (state.doFlushAfter) {\n            state.doFlushAfter = false;\n            flushPending = false;\n          }\n        }\n      }\n    } catch (AbortException ae) {\n      abort(ae);\n    }\n\n    return state;\n  }\n\n","sourceOld":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized ThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    ThreadState state = (ThreadState) threadBindings.get(Thread.currentThread());\n    if (state == null) {\n      // First time this thread has called us since last flush\n      ThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        ThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length == MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        ThreadState[] newArray = new ThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new ThreadState();\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    while(!state.isIdle || pauseThreads != 0 || flushPending)\n      try {\n        wait();\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n\n    if (closed)\n      throw new AlreadyClosedException(\"this IndexWriter is closed\");\n\n    if (segment == null)\n      segment = writer.newSegmentName();\n\n    numDocsInRAM++;\n    numDocsInStore++;\n\n    // We must at this point commit to flushing to ensure we\n    // always get N docs when we flush by doc count, even if\n    // > 1 thread is adding documents:\n    if (!flushPending && maxBufferedDocs != IndexWriter.DISABLE_AUTO_FLUSH\n        && numDocsInRAM >= maxBufferedDocs) {\n      flushPending = true;\n      state.doFlushAfter = true;\n    } else\n      state.doFlushAfter = false;\n\n    state.isIdle = false;\n\n    boolean success = false;\n    try {\n      state.init(doc, nextDocID++);\n\n      if (delTerm != null) {\n        addDeleteTerm(delTerm, state.docID);\n        if (!state.doFlushAfter)\n          state.doFlushAfter = timeToFlushDeletes();\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        synchronized(this) {\n          state.isIdle = true;\n          if (state.doFlushAfter) {\n            state.doFlushAfter = false;\n            flushPending = false;\n          }\n          notifyAll();\n        }\n      }\n    }\n\n    return state;\n  }\n\n","bugFix":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c","8560794cda5bcd510c60e38ed553e9c5a6204983"],"bugIntro":["176324efd1eab6bd44a6d81c27c9b3a1a175ba3d","ac1242ce6d99813874fddfe4ca5f57779beddb22"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"176324efd1eab6bd44a6d81c27c9b3a1a175ba3d","date":1202734547,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","sourceNew":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized ThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    ThreadState state = (ThreadState) threadBindings.get(Thread.currentThread());\n    if (state == null) {\n      // First time this thread has called us since last flush\n      ThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        ThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length == MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        ThreadState[] newArray = new ThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new ThreadState();\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    while(!closed && (!state.isIdle || pauseThreads != 0 || flushPending || abortCount > 0))\n      try {\n        wait();\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n\n    if (closed)\n      throw new AlreadyClosedException(\"this IndexWriter is closed\");\n\n    if (segment == null)\n      segment = writer.newSegmentName();\n\n    numDocsInRAM++;\n    numDocsInStore++;\n\n    // We must at this point commit to flushing to ensure we\n    // always get N docs when we flush by doc count, even if\n    // > 1 thread is adding documents:\n    if (!flushPending && maxBufferedDocs != IndexWriter.DISABLE_AUTO_FLUSH\n        && numDocsInRAM >= maxBufferedDocs) {\n      flushPending = true;\n      state.doFlushAfter = true;\n    } else\n      state.doFlushAfter = false;\n\n    state.isIdle = false;\n\n    try {\n      boolean success = false;\n      try {\n        state.init(doc, nextDocID);\n        if (delTerm != null) {\n          addDeleteTerm(delTerm, state.docID);\n          if (!state.doFlushAfter)\n            state.doFlushAfter = timeToFlushDeletes();\n        }\n        // Only increment nextDocID on successful init\n        nextDocID++;\n        success = true;\n      } finally {\n        if (!success) {\n          // Forcefully idle this ThreadState:\n          state.isIdle = true;\n          notifyAll();\n          if (state.doFlushAfter) {\n            state.doFlushAfter = false;\n            flushPending = false;\n          }\n        }\n      }\n    } catch (AbortException ae) {\n      abort(ae);\n    }\n\n    return state;\n  }\n\n","sourceOld":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized ThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    ThreadState state = (ThreadState) threadBindings.get(Thread.currentThread());\n    if (state == null) {\n      // First time this thread has called us since last flush\n      ThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        ThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length == MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        ThreadState[] newArray = new ThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new ThreadState();\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    while(!closed && (!state.isIdle || pauseThreads != 0 || flushPending || aborting))\n      try {\n        wait();\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n\n    if (closed)\n      throw new AlreadyClosedException(\"this IndexWriter is closed\");\n\n    if (segment == null)\n      segment = writer.newSegmentName();\n\n    numDocsInRAM++;\n    numDocsInStore++;\n\n    // We must at this point commit to flushing to ensure we\n    // always get N docs when we flush by doc count, even if\n    // > 1 thread is adding documents:\n    if (!flushPending && maxBufferedDocs != IndexWriter.DISABLE_AUTO_FLUSH\n        && numDocsInRAM >= maxBufferedDocs) {\n      flushPending = true;\n      state.doFlushAfter = true;\n    } else\n      state.doFlushAfter = false;\n\n    state.isIdle = false;\n\n    try {\n      boolean success = false;\n      try {\n        state.init(doc, nextDocID);\n        if (delTerm != null) {\n          addDeleteTerm(delTerm, state.docID);\n          if (!state.doFlushAfter)\n            state.doFlushAfter = timeToFlushDeletes();\n        }\n        // Only increment nextDocID on successful init\n        nextDocID++;\n        success = true;\n      } finally {\n        if (!success) {\n          // Forcefully idle this ThreadState:\n          state.isIdle = true;\n          notifyAll();\n          if (state.doFlushAfter) {\n            state.doFlushAfter = false;\n            flushPending = false;\n          }\n        }\n      }\n    } catch (AbortException ae) {\n      abort(ae);\n    }\n\n    return state;\n  }\n\n","bugFix":["83bbb041887bbef07b8a98d08a0e1713ce137039"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"49adbad5232116eb2448ea8166464e6a68bca007","date":1202851885,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","sourceNew":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized ThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    ThreadState state = (ThreadState) threadBindings.get(Thread.currentThread());\n    if (state == null) {\n      // First time this thread has called us since last flush\n      ThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        ThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length == MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        ThreadState[] newArray = new ThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new ThreadState();\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    while(!closed && (!state.isIdle || pauseThreads != 0 || flushPending || abortCount > 0))\n      try {\n        wait();\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n\n    if (closed)\n      throw new AlreadyClosedException(\"this IndexWriter is closed\");\n\n    if (segment == null)\n      segment = writer.newSegmentName();\n\n    numDocsInRAM++;\n\n    // We must at this point commit to flushing to ensure we\n    // always get N docs when we flush by doc count, even if\n    // > 1 thread is adding documents:\n    if (!flushPending && maxBufferedDocs != IndexWriter.DISABLE_AUTO_FLUSH\n        && numDocsInRAM >= maxBufferedDocs) {\n      flushPending = true;\n      state.doFlushAfter = true;\n    } else\n      state.doFlushAfter = false;\n\n    state.isIdle = false;\n\n    try {\n      boolean success = false;\n      try {\n        state.init(doc, nextDocID);\n        if (delTerm != null) {\n          addDeleteTerm(delTerm, state.docID);\n          if (!state.doFlushAfter)\n            state.doFlushAfter = timeToFlushDeletes();\n        }\n        // Only increment nextDocID on successful init\n        nextDocID++;\n        success = true;\n      } finally {\n        if (!success) {\n          // Forcefully idle this ThreadState:\n          state.isIdle = true;\n          notifyAll();\n          if (state.doFlushAfter) {\n            state.doFlushAfter = false;\n            flushPending = false;\n          }\n        }\n      }\n    } catch (AbortException ae) {\n      abort(ae);\n    }\n\n    return state;\n  }\n\n","sourceOld":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized ThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    ThreadState state = (ThreadState) threadBindings.get(Thread.currentThread());\n    if (state == null) {\n      // First time this thread has called us since last flush\n      ThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        ThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length == MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        ThreadState[] newArray = new ThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new ThreadState();\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    while(!closed && (!state.isIdle || pauseThreads != 0 || flushPending || abortCount > 0))\n      try {\n        wait();\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n\n    if (closed)\n      throw new AlreadyClosedException(\"this IndexWriter is closed\");\n\n    if (segment == null)\n      segment = writer.newSegmentName();\n\n    numDocsInRAM++;\n    numDocsInStore++;\n\n    // We must at this point commit to flushing to ensure we\n    // always get N docs when we flush by doc count, even if\n    // > 1 thread is adding documents:\n    if (!flushPending && maxBufferedDocs != IndexWriter.DISABLE_AUTO_FLUSH\n        && numDocsInRAM >= maxBufferedDocs) {\n      flushPending = true;\n      state.doFlushAfter = true;\n    } else\n      state.doFlushAfter = false;\n\n    state.isIdle = false;\n\n    try {\n      boolean success = false;\n      try {\n        state.init(doc, nextDocID);\n        if (delTerm != null) {\n          addDeleteTerm(delTerm, state.docID);\n          if (!state.doFlushAfter)\n            state.doFlushAfter = timeToFlushDeletes();\n        }\n        // Only increment nextDocID on successful init\n        nextDocID++;\n        success = true;\n      } finally {\n        if (!success) {\n          // Forcefully idle this ThreadState:\n          state.isIdle = true;\n          notifyAll();\n          if (state.doFlushAfter) {\n            state.doFlushAfter = false;\n            flushPending = false;\n          }\n        }\n      }\n    } catch (AbortException ae) {\n      abort(ae);\n    }\n\n    return state;\n  }\n\n","bugFix":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ac1242ce6d99813874fddfe4ca5f57779beddb22","date":1204500247,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","sourceNew":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized ThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    ThreadState state = (ThreadState) threadBindings.get(Thread.currentThread());\n    if (state == null) {\n      // First time this thread has called us since last flush\n      ThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        ThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length == MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        ThreadState[] newArray = new ThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new ThreadState();\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    while(!closed && (!state.isIdle || pauseThreads != 0 || flushPending || abortCount > 0))\n      try {\n        wait();\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n\n    if (closed)\n      throw new AlreadyClosedException(\"this IndexWriter is closed\");\n\n    if (segment == null)\n      segment = writer.newSegmentName();\n\n    state.isIdle = false;\n\n    try {\n      boolean success = false;\n      try {\n        state.init(doc, nextDocID);\n        if (delTerm != null) {\n          addDeleteTerm(delTerm, state.docID);\n          state.doFlushAfter = timeToFlushDeletes();\n        }\n        // Only increment nextDocID & numDocsInRAM on successful init\n        nextDocID++;\n        numDocsInRAM++;\n\n        // We must at this point commit to flushing to ensure we\n        // always get N docs when we flush by doc count, even if\n        // > 1 thread is adding documents:\n        if (!flushPending && maxBufferedDocs != IndexWriter.DISABLE_AUTO_FLUSH\n            && numDocsInRAM >= maxBufferedDocs) {\n          flushPending = true;\n          state.doFlushAfter = true;\n        }\n\n        success = true;\n      } finally {\n        if (!success) {\n          // Forcefully idle this ThreadState:\n          state.isIdle = true;\n          notifyAll();\n          if (state.doFlushAfter) {\n            state.doFlushAfter = false;\n            flushPending = false;\n          }\n        }\n      }\n    } catch (AbortException ae) {\n      abort(ae);\n    }\n\n    return state;\n  }\n\n","sourceOld":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized ThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    ThreadState state = (ThreadState) threadBindings.get(Thread.currentThread());\n    if (state == null) {\n      // First time this thread has called us since last flush\n      ThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        ThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length == MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        ThreadState[] newArray = new ThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new ThreadState();\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    while(!closed && (!state.isIdle || pauseThreads != 0 || flushPending || abortCount > 0))\n      try {\n        wait();\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n\n    if (closed)\n      throw new AlreadyClosedException(\"this IndexWriter is closed\");\n\n    if (segment == null)\n      segment = writer.newSegmentName();\n\n    numDocsInRAM++;\n\n    // We must at this point commit to flushing to ensure we\n    // always get N docs when we flush by doc count, even if\n    // > 1 thread is adding documents:\n    if (!flushPending && maxBufferedDocs != IndexWriter.DISABLE_AUTO_FLUSH\n        && numDocsInRAM >= maxBufferedDocs) {\n      flushPending = true;\n      state.doFlushAfter = true;\n    } else\n      state.doFlushAfter = false;\n\n    state.isIdle = false;\n\n    try {\n      boolean success = false;\n      try {\n        state.init(doc, nextDocID);\n        if (delTerm != null) {\n          addDeleteTerm(delTerm, state.docID);\n          if (!state.doFlushAfter)\n            state.doFlushAfter = timeToFlushDeletes();\n        }\n        // Only increment nextDocID on successful init\n        nextDocID++;\n        success = true;\n      } finally {\n        if (!success) {\n          // Forcefully idle this ThreadState:\n          state.isIdle = true;\n          notifyAll();\n          if (state.doFlushAfter) {\n            state.doFlushAfter = false;\n            flushPending = false;\n          }\n        }\n      }\n    } catch (AbortException ae) {\n      abort(ae);\n    }\n\n    return state;\n  }\n\n","bugFix":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c","2558ddf9e14a97bc597f5b72bb3ecb5b7f6bba8e","83bbb041887bbef07b8a98d08a0e1713ce137039"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be","date":1204801324,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","sourceNew":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized ThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    ThreadState state = (ThreadState) threadBindings.get(Thread.currentThread());\n    if (state == null) {\n      // First time this thread has called us since last flush\n      ThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        ThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length == MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        ThreadState[] newArray = new ThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new ThreadState();\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    waitReady(state);\n\n    if (segment == null)\n      segment = writer.newSegmentName();\n\n    state.isIdle = false;\n\n    try {\n      boolean success = false;\n      try {\n        state.init(doc, nextDocID);\n        if (delTerm != null) {\n          addDeleteTerm(delTerm, state.docID);\n          state.doFlushAfter = timeToFlushDeletes();\n        }\n        // Only increment nextDocID & numDocsInRAM on successful init\n        nextDocID++;\n        numDocsInRAM++;\n\n        // We must at this point commit to flushing to ensure we\n        // always get N docs when we flush by doc count, even if\n        // > 1 thread is adding documents:\n        if (!flushPending && maxBufferedDocs != IndexWriter.DISABLE_AUTO_FLUSH\n            && numDocsInRAM >= maxBufferedDocs) {\n          flushPending = true;\n          state.doFlushAfter = true;\n        }\n\n        success = true;\n      } finally {\n        if (!success) {\n          // Forcefully idle this ThreadState:\n          state.isIdle = true;\n          notifyAll();\n          if (state.doFlushAfter) {\n            state.doFlushAfter = false;\n            flushPending = false;\n          }\n        }\n      }\n    } catch (AbortException ae) {\n      abort(ae);\n    }\n\n    return state;\n  }\n\n","sourceOld":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized ThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    ThreadState state = (ThreadState) threadBindings.get(Thread.currentThread());\n    if (state == null) {\n      // First time this thread has called us since last flush\n      ThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        ThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length == MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        ThreadState[] newArray = new ThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new ThreadState();\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    while(!closed && (!state.isIdle || pauseThreads != 0 || flushPending || abortCount > 0))\n      try {\n        wait();\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n\n    if (closed)\n      throw new AlreadyClosedException(\"this IndexWriter is closed\");\n\n    if (segment == null)\n      segment = writer.newSegmentName();\n\n    state.isIdle = false;\n\n    try {\n      boolean success = false;\n      try {\n        state.init(doc, nextDocID);\n        if (delTerm != null) {\n          addDeleteTerm(delTerm, state.docID);\n          state.doFlushAfter = timeToFlushDeletes();\n        }\n        // Only increment nextDocID & numDocsInRAM on successful init\n        nextDocID++;\n        numDocsInRAM++;\n\n        // We must at this point commit to flushing to ensure we\n        // always get N docs when we flush by doc count, even if\n        // > 1 thread is adding documents:\n        if (!flushPending && maxBufferedDocs != IndexWriter.DISABLE_AUTO_FLUSH\n            && numDocsInRAM >= maxBufferedDocs) {\n          flushPending = true;\n          state.doFlushAfter = true;\n        }\n\n        success = true;\n      } finally {\n        if (!success) {\n          // Forcefully idle this ThreadState:\n          state.isIdle = true;\n          notifyAll();\n          if (state.doFlushAfter) {\n            state.doFlushAfter = false;\n            flushPending = false;\n          }\n        }\n      }\n    } catch (AbortException ae) {\n      abort(ae);\n    }\n\n    return state;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a0af3a442be522899177e5e11384a45a6784a3f","date":1205348952,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","sourceNew":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized DocumentsWriterThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    DocumentsWriterThreadState state = (DocumentsWriterThreadState) threadBindings.get(Thread.currentThread());\n    if (state == null) {\n      // First time this thread has called us since last flush\n      DocumentsWriterThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        DocumentsWriterThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length == MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        DocumentsWriterThreadState[] newArray = new DocumentsWriterThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new DocumentsWriterThreadState(this);\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    waitReady(state);\n\n    if (segment == null)\n      segment = writer.newSegmentName();\n\n    state.isIdle = false;\n\n    try {\n      boolean success = false;\n      try {\n        state.init(doc, nextDocID);\n        if (delTerm != null) {\n          addDeleteTerm(delTerm, state.docID);\n          state.doFlushAfter = timeToFlushDeletes();\n        }\n        // Only increment nextDocID & numDocsInRAM on successful init\n        nextDocID++;\n        numDocsInRAM++;\n\n        // We must at this point commit to flushing to ensure we\n        // always get N docs when we flush by doc count, even if\n        // > 1 thread is adding documents:\n        if (!flushPending && maxBufferedDocs != IndexWriter.DISABLE_AUTO_FLUSH\n            && numDocsInRAM >= maxBufferedDocs) {\n          flushPending = true;\n          state.doFlushAfter = true;\n        }\n\n        success = true;\n      } finally {\n        if (!success) {\n          // Forcefully idle this ThreadState:\n          state.isIdle = true;\n          notifyAll();\n          if (state.doFlushAfter) {\n            state.doFlushAfter = false;\n            flushPending = false;\n          }\n        }\n      }\n    } catch (AbortException ae) {\n      abort(ae);\n    }\n\n    return state;\n  }\n\n","sourceOld":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized ThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    ThreadState state = (ThreadState) threadBindings.get(Thread.currentThread());\n    if (state == null) {\n      // First time this thread has called us since last flush\n      ThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        ThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length == MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        ThreadState[] newArray = new ThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new ThreadState();\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    waitReady(state);\n\n    if (segment == null)\n      segment = writer.newSegmentName();\n\n    state.isIdle = false;\n\n    try {\n      boolean success = false;\n      try {\n        state.init(doc, nextDocID);\n        if (delTerm != null) {\n          addDeleteTerm(delTerm, state.docID);\n          state.doFlushAfter = timeToFlushDeletes();\n        }\n        // Only increment nextDocID & numDocsInRAM on successful init\n        nextDocID++;\n        numDocsInRAM++;\n\n        // We must at this point commit to flushing to ensure we\n        // always get N docs when we flush by doc count, even if\n        // > 1 thread is adding documents:\n        if (!flushPending && maxBufferedDocs != IndexWriter.DISABLE_AUTO_FLUSH\n            && numDocsInRAM >= maxBufferedDocs) {\n          flushPending = true;\n          state.doFlushAfter = true;\n        }\n\n        success = true;\n      } finally {\n        if (!success) {\n          // Forcefully idle this ThreadState:\n          state.isIdle = true;\n          notifyAll();\n          if (state.doFlushAfter) {\n            state.doFlushAfter = false;\n            flushPending = false;\n          }\n        }\n      }\n    } catch (AbortException ae) {\n      abort(ae);\n    }\n\n    return state;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5350389bf83287111f7760b9e3db3af8e3648474","date":1216372812,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","sourceNew":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized DocumentsWriterThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    DocumentsWriterThreadState state = (DocumentsWriterThreadState) threadBindings.get(Thread.currentThread());\n    if (state == null) {\n\n      // First time this thread has called us since last\n      // flush.  Find the least loaded thread state:\n      DocumentsWriterThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        DocumentsWriterThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length >= MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        DocumentsWriterThreadState[] newArray = new DocumentsWriterThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new DocumentsWriterThreadState(this);\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    waitReady(state);\n\n    // Allocate segment name if this is the first doc since\n    // last flush:\n    initSegmentName(false);\n\n    state.isIdle = false;\n\n    boolean success = false;\n    try {\n      state.docState.docID = nextDocID;\n\n      assert writer.testPoint(\"DocumentsWriter.ThreadState.init start\");\n\n      if (delTerm != null) {\n        addDeleteTerm(delTerm, state.docState.docID);\n        state.doFlushAfter = timeToFlushDeletes();\n      }\n\n      assert writer.testPoint(\"DocumentsWriter.ThreadState.init after delTerm\");\n\n      nextDocID++;\n      numDocsInRAM++;\n\n      // We must at this point commit to flushing to ensure we\n      // always get N docs when we flush by doc count, even if\n      // > 1 thread is adding documents:\n      if (!flushPending &&\n          maxBufferedDocs != IndexWriter.DISABLE_AUTO_FLUSH\n          && numDocsInRAM >= maxBufferedDocs) {\n        flushPending = true;\n        state.doFlushAfter = true;\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        // Forcefully idle this ThreadState:\n        state.isIdle = true;\n        notifyAll();\n        if (state.doFlushAfter) {\n          state.doFlushAfter = false;\n          flushPending = false;\n        }\n      }\n    }\n\n    return state;\n  }\n\n","sourceOld":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized DocumentsWriterThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    DocumentsWriterThreadState state = (DocumentsWriterThreadState) threadBindings.get(Thread.currentThread());\n    if (state == null) {\n      // First time this thread has called us since last flush\n      DocumentsWriterThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        DocumentsWriterThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length == MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        DocumentsWriterThreadState[] newArray = new DocumentsWriterThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new DocumentsWriterThreadState(this);\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    waitReady(state);\n\n    if (segment == null)\n      segment = writer.newSegmentName();\n\n    state.isIdle = false;\n\n    try {\n      boolean success = false;\n      try {\n        state.init(doc, nextDocID);\n        if (delTerm != null) {\n          addDeleteTerm(delTerm, state.docID);\n          state.doFlushAfter = timeToFlushDeletes();\n        }\n        // Only increment nextDocID & numDocsInRAM on successful init\n        nextDocID++;\n        numDocsInRAM++;\n\n        // We must at this point commit to flushing to ensure we\n        // always get N docs when we flush by doc count, even if\n        // > 1 thread is adding documents:\n        if (!flushPending && maxBufferedDocs != IndexWriter.DISABLE_AUTO_FLUSH\n            && numDocsInRAM >= maxBufferedDocs) {\n          flushPending = true;\n          state.doFlushAfter = true;\n        }\n\n        success = true;\n      } finally {\n        if (!success) {\n          // Forcefully idle this ThreadState:\n          state.isIdle = true;\n          notifyAll();\n          if (state.doFlushAfter) {\n            state.doFlushAfter = false;\n            flushPending = false;\n          }\n        }\n      }\n    } catch (AbortException ae) {\n      abort(ae);\n    }\n\n    return state;\n  }\n\n","bugFix":null,"bugIntro":["a9802bb5985cb6cc3e0a3a0ecb2158acf4d5cfcf"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4e1ce9be74263e9659aad8a6ee1f213193710b71","date":1256298843,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","sourceNew":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized DocumentsWriterThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    DocumentsWriterThreadState state = threadBindings.get(Thread.currentThread());\n    if (state == null) {\n\n      // First time this thread has called us since last\n      // flush.  Find the least loaded thread state:\n      DocumentsWriterThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        DocumentsWriterThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length >= MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        DocumentsWriterThreadState[] newArray = new DocumentsWriterThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new DocumentsWriterThreadState(this);\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    waitReady(state);\n\n    // Allocate segment name if this is the first doc since\n    // last flush:\n    initSegmentName(false);\n\n    state.isIdle = false;\n\n    boolean success = false;\n    try {\n      state.docState.docID = nextDocID;\n\n      assert writer.testPoint(\"DocumentsWriter.ThreadState.init start\");\n\n      if (delTerm != null) {\n        addDeleteTerm(delTerm, state.docState.docID);\n        state.doFlushAfter = timeToFlushDeletes();\n      }\n\n      assert writer.testPoint(\"DocumentsWriter.ThreadState.init after delTerm\");\n\n      nextDocID++;\n      numDocsInRAM++;\n\n      // We must at this point commit to flushing to ensure we\n      // always get N docs when we flush by doc count, even if\n      // > 1 thread is adding documents:\n      if (!flushPending &&\n          maxBufferedDocs != IndexWriter.DISABLE_AUTO_FLUSH\n          && numDocsInRAM >= maxBufferedDocs) {\n        flushPending = true;\n        state.doFlushAfter = true;\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        // Forcefully idle this ThreadState:\n        state.isIdle = true;\n        notifyAll();\n        if (state.doFlushAfter) {\n          state.doFlushAfter = false;\n          flushPending = false;\n        }\n      }\n    }\n\n    return state;\n  }\n\n","sourceOld":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized DocumentsWriterThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    DocumentsWriterThreadState state = (DocumentsWriterThreadState) threadBindings.get(Thread.currentThread());\n    if (state == null) {\n\n      // First time this thread has called us since last\n      // flush.  Find the least loaded thread state:\n      DocumentsWriterThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        DocumentsWriterThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length >= MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        DocumentsWriterThreadState[] newArray = new DocumentsWriterThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new DocumentsWriterThreadState(this);\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    waitReady(state);\n\n    // Allocate segment name if this is the first doc since\n    // last flush:\n    initSegmentName(false);\n\n    state.isIdle = false;\n\n    boolean success = false;\n    try {\n      state.docState.docID = nextDocID;\n\n      assert writer.testPoint(\"DocumentsWriter.ThreadState.init start\");\n\n      if (delTerm != null) {\n        addDeleteTerm(delTerm, state.docState.docID);\n        state.doFlushAfter = timeToFlushDeletes();\n      }\n\n      assert writer.testPoint(\"DocumentsWriter.ThreadState.init after delTerm\");\n\n      nextDocID++;\n      numDocsInRAM++;\n\n      // We must at this point commit to flushing to ensure we\n      // always get N docs when we flush by doc count, even if\n      // > 1 thread is adding documents:\n      if (!flushPending &&\n          maxBufferedDocs != IndexWriter.DISABLE_AUTO_FLUSH\n          && numDocsInRAM >= maxBufferedDocs) {\n        flushPending = true;\n        state.doFlushAfter = true;\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        // Forcefully idle this ThreadState:\n        state.isIdle = true;\n        notifyAll();\n        if (state.doFlushAfter) {\n          state.doFlushAfter = false;\n          flushPending = false;\n        }\n      }\n    }\n\n    return state;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1cedb00d2dd44640194401179358a2e3ba6051bf","date":1268243626,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","sourceNew":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized DocumentsWriterThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    DocumentsWriterThreadState state = threadBindings.get(Thread.currentThread());\n    if (state == null) {\n\n      // First time this thread has called us since last\n      // flush.  Find the least loaded thread state:\n      DocumentsWriterThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        DocumentsWriterThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length >= MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        DocumentsWriterThreadState[] newArray = new DocumentsWriterThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new DocumentsWriterThreadState(this);\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    waitReady(state);\n\n    // Allocate segment name if this is the first doc since\n    // last flush:\n    initSegmentName(false);\n\n    state.isIdle = false;\n\n    boolean success = false;\n    try {\n      state.docState.docID = nextDocID;\n\n      assert writer.testPoint(\"DocumentsWriter.ThreadState.init start\");\n\n      if (delTerm != null) {\n        addDeleteTerm(delTerm, state.docState.docID);\n        state.doFlushAfter = timeToFlushDeletes();\n      }\n\n      assert writer.testPoint(\"DocumentsWriter.ThreadState.init after delTerm\");\n\n      nextDocID++;\n      numDocsInRAM++;\n\n      // We must at this point commit to flushing to ensure we\n      // always get N docs when we flush by doc count, even if\n      // > 1 thread is adding documents:\n      if (!flushPending &&\n          maxBufferedDocs != IndexWriterConfig.DISABLE_AUTO_FLUSH\n          && numDocsInRAM >= maxBufferedDocs) {\n        flushPending = true;\n        state.doFlushAfter = true;\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        // Forcefully idle this ThreadState:\n        state.isIdle = true;\n        notifyAll();\n        if (state.doFlushAfter) {\n          state.doFlushAfter = false;\n          flushPending = false;\n        }\n      }\n    }\n\n    return state;\n  }\n\n","sourceOld":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized DocumentsWriterThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    DocumentsWriterThreadState state = threadBindings.get(Thread.currentThread());\n    if (state == null) {\n\n      // First time this thread has called us since last\n      // flush.  Find the least loaded thread state:\n      DocumentsWriterThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        DocumentsWriterThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length >= MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        DocumentsWriterThreadState[] newArray = new DocumentsWriterThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new DocumentsWriterThreadState(this);\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    waitReady(state);\n\n    // Allocate segment name if this is the first doc since\n    // last flush:\n    initSegmentName(false);\n\n    state.isIdle = false;\n\n    boolean success = false;\n    try {\n      state.docState.docID = nextDocID;\n\n      assert writer.testPoint(\"DocumentsWriter.ThreadState.init start\");\n\n      if (delTerm != null) {\n        addDeleteTerm(delTerm, state.docState.docID);\n        state.doFlushAfter = timeToFlushDeletes();\n      }\n\n      assert writer.testPoint(\"DocumentsWriter.ThreadState.init after delTerm\");\n\n      nextDocID++;\n      numDocsInRAM++;\n\n      // We must at this point commit to flushing to ensure we\n      // always get N docs when we flush by doc count, even if\n      // > 1 thread is adding documents:\n      if (!flushPending &&\n          maxBufferedDocs != IndexWriter.DISABLE_AUTO_FLUSH\n          && numDocsInRAM >= maxBufferedDocs) {\n        flushPending = true;\n        state.doFlushAfter = true;\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        // Forcefully idle this ThreadState:\n        state.isIdle = true;\n        notifyAll();\n        if (state.doFlushAfter) {\n          state.doFlushAfter = false;\n          flushPending = false;\n        }\n      }\n    }\n\n    return state;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e52fea2c4081a1e552b98506691990be59503168","date":1268250331,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","sourceNew":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized DocumentsWriterThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    DocumentsWriterThreadState state = threadBindings.get(Thread.currentThread());\n    if (state == null) {\n\n      // First time this thread has called us since last\n      // flush.  Find the least loaded thread state:\n      DocumentsWriterThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        DocumentsWriterThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length >= MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        DocumentsWriterThreadState[] newArray = new DocumentsWriterThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new DocumentsWriterThreadState(this);\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    waitReady(state);\n\n    // Allocate segment name if this is the first doc since\n    // last flush:\n    initSegmentName(false);\n\n    state.isIdle = false;\n\n    boolean success = false;\n    try {\n      state.docState.docID = nextDocID;\n\n      assert writer.testPoint(\"DocumentsWriter.ThreadState.init start\");\n\n      if (delTerm != null) {\n        addDeleteTerm(delTerm, state.docState.docID);\n        state.doFlushAfter = timeToFlushDeletes();\n      }\n\n      assert writer.testPoint(\"DocumentsWriter.ThreadState.init after delTerm\");\n\n      nextDocID++;\n      numDocsInRAM++;\n\n      // We must at this point commit to flushing to ensure we\n      // always get N docs when we flush by doc count, even if\n      // > 1 thread is adding documents:\n      if (!flushPending &&\n          maxBufferedDocs != IndexWriter.DISABLE_AUTO_FLUSH\n          && numDocsInRAM >= maxBufferedDocs) {\n        flushPending = true;\n        state.doFlushAfter = true;\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        // Forcefully idle this ThreadState:\n        state.isIdle = true;\n        notifyAll();\n        if (state.doFlushAfter) {\n          state.doFlushAfter = false;\n          flushPending = false;\n        }\n      }\n    }\n\n    return state;\n  }\n\n","sourceOld":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized DocumentsWriterThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    DocumentsWriterThreadState state = threadBindings.get(Thread.currentThread());\n    if (state == null) {\n\n      // First time this thread has called us since last\n      // flush.  Find the least loaded thread state:\n      DocumentsWriterThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        DocumentsWriterThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length >= MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        DocumentsWriterThreadState[] newArray = new DocumentsWriterThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new DocumentsWriterThreadState(this);\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    waitReady(state);\n\n    // Allocate segment name if this is the first doc since\n    // last flush:\n    initSegmentName(false);\n\n    state.isIdle = false;\n\n    boolean success = false;\n    try {\n      state.docState.docID = nextDocID;\n\n      assert writer.testPoint(\"DocumentsWriter.ThreadState.init start\");\n\n      if (delTerm != null) {\n        addDeleteTerm(delTerm, state.docState.docID);\n        state.doFlushAfter = timeToFlushDeletes();\n      }\n\n      assert writer.testPoint(\"DocumentsWriter.ThreadState.init after delTerm\");\n\n      nextDocID++;\n      numDocsInRAM++;\n\n      // We must at this point commit to flushing to ensure we\n      // always get N docs when we flush by doc count, even if\n      // > 1 thread is adding documents:\n      if (!flushPending &&\n          maxBufferedDocs != IndexWriterConfig.DISABLE_AUTO_FLUSH\n          && numDocsInRAM >= maxBufferedDocs) {\n        flushPending = true;\n        state.doFlushAfter = true;\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        // Forcefully idle this ThreadState:\n        state.isIdle = true;\n        notifyAll();\n        if (state.doFlushAfter) {\n          state.doFlushAfter = false;\n          flushPending = false;\n        }\n      }\n    }\n\n    return state;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8","date":1268494368,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","sourceNew":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized DocumentsWriterThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    DocumentsWriterThreadState state = threadBindings.get(Thread.currentThread());\n    if (state == null) {\n\n      // First time this thread has called us since last\n      // flush.  Find the least loaded thread state:\n      DocumentsWriterThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        DocumentsWriterThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length >= MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        DocumentsWriterThreadState[] newArray = new DocumentsWriterThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new DocumentsWriterThreadState(this);\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    waitReady(state);\n\n    // Allocate segment name if this is the first doc since\n    // last flush:\n    initSegmentName(false);\n\n    state.isIdle = false;\n\n    boolean success = false;\n    try {\n      state.docState.docID = nextDocID;\n\n      assert writer.testPoint(\"DocumentsWriter.ThreadState.init start\");\n\n      if (delTerm != null) {\n        addDeleteTerm(delTerm, state.docState.docID);\n        state.doFlushAfter = timeToFlushDeletes();\n      }\n\n      assert writer.testPoint(\"DocumentsWriter.ThreadState.init after delTerm\");\n\n      nextDocID++;\n      numDocsInRAM++;\n\n      // We must at this point commit to flushing to ensure we\n      // always get N docs when we flush by doc count, even if\n      // > 1 thread is adding documents:\n      if (!flushPending &&\n          maxBufferedDocs != IndexWriterConfig.DISABLE_AUTO_FLUSH\n          && numDocsInRAM >= maxBufferedDocs) {\n        flushPending = true;\n        state.doFlushAfter = true;\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        // Forcefully idle this ThreadState:\n        state.isIdle = true;\n        notifyAll();\n        if (state.doFlushAfter) {\n          state.doFlushAfter = false;\n          flushPending = false;\n        }\n      }\n    }\n\n    return state;\n  }\n\n","sourceOld":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized DocumentsWriterThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    DocumentsWriterThreadState state = threadBindings.get(Thread.currentThread());\n    if (state == null) {\n\n      // First time this thread has called us since last\n      // flush.  Find the least loaded thread state:\n      DocumentsWriterThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        DocumentsWriterThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length >= MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        DocumentsWriterThreadState[] newArray = new DocumentsWriterThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new DocumentsWriterThreadState(this);\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    waitReady(state);\n\n    // Allocate segment name if this is the first doc since\n    // last flush:\n    initSegmentName(false);\n\n    state.isIdle = false;\n\n    boolean success = false;\n    try {\n      state.docState.docID = nextDocID;\n\n      assert writer.testPoint(\"DocumentsWriter.ThreadState.init start\");\n\n      if (delTerm != null) {\n        addDeleteTerm(delTerm, state.docState.docID);\n        state.doFlushAfter = timeToFlushDeletes();\n      }\n\n      assert writer.testPoint(\"DocumentsWriter.ThreadState.init after delTerm\");\n\n      nextDocID++;\n      numDocsInRAM++;\n\n      // We must at this point commit to flushing to ensure we\n      // always get N docs when we flush by doc count, even if\n      // > 1 thread is adding documents:\n      if (!flushPending &&\n          maxBufferedDocs != IndexWriter.DISABLE_AUTO_FLUSH\n          && numDocsInRAM >= maxBufferedDocs) {\n        flushPending = true;\n        state.doFlushAfter = true;\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        // Forcefully idle this ThreadState:\n        state.isIdle = true;\n        notifyAll();\n        if (state.doFlushAfter) {\n          state.doFlushAfter = false;\n          flushPending = false;\n        }\n      }\n    }\n\n    return state;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a9802bb5985cb6cc3e0a3a0ecb2158acf4d5cfcf","date":1268662366,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","sourceNew":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized DocumentsWriterThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    DocumentsWriterThreadState state = threadBindings.get(Thread.currentThread());\n    if (state == null) {\n\n      // First time this thread has called us since last\n      // flush.  Find the least loaded thread state:\n      DocumentsWriterThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        DocumentsWriterThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length >= maxThreadStates)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        DocumentsWriterThreadState[] newArray = new DocumentsWriterThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new DocumentsWriterThreadState(this);\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    waitReady(state);\n\n    // Allocate segment name if this is the first doc since\n    // last flush:\n    initSegmentName(false);\n\n    state.isIdle = false;\n\n    boolean success = false;\n    try {\n      state.docState.docID = nextDocID;\n\n      assert writer.testPoint(\"DocumentsWriter.ThreadState.init start\");\n\n      if (delTerm != null) {\n        addDeleteTerm(delTerm, state.docState.docID);\n        state.doFlushAfter = timeToFlushDeletes();\n      }\n\n      assert writer.testPoint(\"DocumentsWriter.ThreadState.init after delTerm\");\n\n      nextDocID++;\n      numDocsInRAM++;\n\n      // We must at this point commit to flushing to ensure we\n      // always get N docs when we flush by doc count, even if\n      // > 1 thread is adding documents:\n      if (!flushPending &&\n          maxBufferedDocs != IndexWriterConfig.DISABLE_AUTO_FLUSH\n          && numDocsInRAM >= maxBufferedDocs) {\n        flushPending = true;\n        state.doFlushAfter = true;\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        // Forcefully idle this ThreadState:\n        state.isIdle = true;\n        notifyAll();\n        if (state.doFlushAfter) {\n          state.doFlushAfter = false;\n          flushPending = false;\n        }\n      }\n    }\n\n    return state;\n  }\n\n","sourceOld":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized DocumentsWriterThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    DocumentsWriterThreadState state = threadBindings.get(Thread.currentThread());\n    if (state == null) {\n\n      // First time this thread has called us since last\n      // flush.  Find the least loaded thread state:\n      DocumentsWriterThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        DocumentsWriterThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length >= MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        DocumentsWriterThreadState[] newArray = new DocumentsWriterThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new DocumentsWriterThreadState(this);\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    waitReady(state);\n\n    // Allocate segment name if this is the first doc since\n    // last flush:\n    initSegmentName(false);\n\n    state.isIdle = false;\n\n    boolean success = false;\n    try {\n      state.docState.docID = nextDocID;\n\n      assert writer.testPoint(\"DocumentsWriter.ThreadState.init start\");\n\n      if (delTerm != null) {\n        addDeleteTerm(delTerm, state.docState.docID);\n        state.doFlushAfter = timeToFlushDeletes();\n      }\n\n      assert writer.testPoint(\"DocumentsWriter.ThreadState.init after delTerm\");\n\n      nextDocID++;\n      numDocsInRAM++;\n\n      // We must at this point commit to flushing to ensure we\n      // always get N docs when we flush by doc count, even if\n      // > 1 thread is adding documents:\n      if (!flushPending &&\n          maxBufferedDocs != IndexWriterConfig.DISABLE_AUTO_FLUSH\n          && numDocsInRAM >= maxBufferedDocs) {\n        flushPending = true;\n        state.doFlushAfter = true;\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        // Forcefully idle this ThreadState:\n        state.isIdle = true;\n        notifyAll();\n        if (state.doFlushAfter) {\n          state.doFlushAfter = false;\n          flushPending = false;\n        }\n      }\n    }\n\n    return state;\n  }\n\n","bugFix":["5350389bf83287111f7760b9e3db3af8e3648474"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","sourceNew":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized DocumentsWriterThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    DocumentsWriterThreadState state = threadBindings.get(Thread.currentThread());\n    if (state == null) {\n\n      // First time this thread has called us since last\n      // flush.  Find the least loaded thread state:\n      DocumentsWriterThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        DocumentsWriterThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length >= maxThreadStates)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        DocumentsWriterThreadState[] newArray = new DocumentsWriterThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new DocumentsWriterThreadState(this);\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    waitReady(state);\n\n    // Allocate segment name if this is the first doc since\n    // last flush:\n    initSegmentName(false);\n\n    state.isIdle = false;\n\n    boolean success = false;\n    try {\n      state.docState.docID = nextDocID;\n\n      assert writer.testPoint(\"DocumentsWriter.ThreadState.init start\");\n\n      if (delTerm != null) {\n        addDeleteTerm(delTerm, state.docState.docID);\n        state.doFlushAfter = timeToFlushDeletes();\n      }\n\n      assert writer.testPoint(\"DocumentsWriter.ThreadState.init after delTerm\");\n\n      nextDocID++;\n      numDocsInRAM++;\n\n      // We must at this point commit to flushing to ensure we\n      // always get N docs when we flush by doc count, even if\n      // > 1 thread is adding documents:\n      if (!flushPending &&\n          maxBufferedDocs != IndexWriterConfig.DISABLE_AUTO_FLUSH\n          && numDocsInRAM >= maxBufferedDocs) {\n        flushPending = true;\n        state.doFlushAfter = true;\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        // Forcefully idle this ThreadState:\n        state.isIdle = true;\n        notifyAll();\n        if (state.doFlushAfter) {\n          state.doFlushAfter = false;\n          flushPending = false;\n        }\n      }\n    }\n\n    return state;\n  }\n\n","sourceOld":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized DocumentsWriterThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    DocumentsWriterThreadState state = threadBindings.get(Thread.currentThread());\n    if (state == null) {\n\n      // First time this thread has called us since last\n      // flush.  Find the least loaded thread state:\n      DocumentsWriterThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        DocumentsWriterThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length >= maxThreadStates)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        DocumentsWriterThreadState[] newArray = new DocumentsWriterThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new DocumentsWriterThreadState(this);\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    waitReady(state);\n\n    // Allocate segment name if this is the first doc since\n    // last flush:\n    initSegmentName(false);\n\n    state.isIdle = false;\n\n    boolean success = false;\n    try {\n      state.docState.docID = nextDocID;\n\n      assert writer.testPoint(\"DocumentsWriter.ThreadState.init start\");\n\n      if (delTerm != null) {\n        addDeleteTerm(delTerm, state.docState.docID);\n        state.doFlushAfter = timeToFlushDeletes();\n      }\n\n      assert writer.testPoint(\"DocumentsWriter.ThreadState.init after delTerm\");\n\n      nextDocID++;\n      numDocsInRAM++;\n\n      // We must at this point commit to flushing to ensure we\n      // always get N docs when we flush by doc count, even if\n      // > 1 thread is adding documents:\n      if (!flushPending &&\n          maxBufferedDocs != IndexWriterConfig.DISABLE_AUTO_FLUSH\n          && numDocsInRAM >= maxBufferedDocs) {\n        flushPending = true;\n        state.doFlushAfter = true;\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        // Forcefully idle this ThreadState:\n        state.isIdle = true;\n        notifyAll();\n        if (state.doFlushAfter) {\n          state.doFlushAfter = false;\n          flushPending = false;\n        }\n      }\n    }\n\n    return state;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"83bbb041887bbef07b8a98d08a0e1713ce137039":["346d5897e4c4e77ed5dbd31f7730ff30973d5971"],"346d5897e4c4e77ed5dbd31f7730ff30973d5971":["8560794cda5bcd510c60e38ed553e9c5a6204983"],"b1405362241b561f5590ff4a87d5d6e173bcd9cf":["fde68de507dbf344495d7b5e8052866fe5f254ab"],"4e1ce9be74263e9659aad8a6ee1f213193710b71":["5350389bf83287111f7760b9e3db3af8e3648474"],"176324efd1eab6bd44a6d81c27c9b3a1a175ba3d":["83bbb041887bbef07b8a98d08a0e1713ce137039"],"fde68de507dbf344495d7b5e8052866fe5f254ab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1cedb00d2dd44640194401179358a2e3ba6051bf":["4e1ce9be74263e9659aad8a6ee1f213193710b71"],"e52fea2c4081a1e552b98506691990be59503168":["1cedb00d2dd44640194401179358a2e3ba6051bf"],"a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be":["ac1242ce6d99813874fddfe4ca5f57779beddb22"],"49adbad5232116eb2448ea8166464e6a68bca007":["176324efd1eab6bd44a6d81c27c9b3a1a175ba3d"],"84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8":["e52fea2c4081a1e552b98506691990be59503168"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2558ddf9e14a97bc597f5b72bb3ecb5b7f6bba8e":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"a9802bb5985cb6cc3e0a3a0ecb2158acf4d5cfcf":["84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8"],"8560794cda5bcd510c60e38ed553e9c5a6204983":["2558ddf9e14a97bc597f5b72bb3ecb5b7f6bba8e"],"5a0af3a442be522899177e5e11384a45a6784a3f":["a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be"],"ac1242ce6d99813874fddfe4ca5f57779beddb22":["49adbad5232116eb2448ea8166464e6a68bca007"],"5350389bf83287111f7760b9e3db3af8e3648474":["5a0af3a442be522899177e5e11384a45a6784a3f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a9802bb5985cb6cc3e0a3a0ecb2158acf4d5cfcf"]},"commit2Childs":{"83bbb041887bbef07b8a98d08a0e1713ce137039":["176324efd1eab6bd44a6d81c27c9b3a1a175ba3d"],"346d5897e4c4e77ed5dbd31f7730ff30973d5971":["83bbb041887bbef07b8a98d08a0e1713ce137039"],"b1405362241b561f5590ff4a87d5d6e173bcd9cf":["2558ddf9e14a97bc597f5b72bb3ecb5b7f6bba8e"],"4e1ce9be74263e9659aad8a6ee1f213193710b71":["1cedb00d2dd44640194401179358a2e3ba6051bf"],"176324efd1eab6bd44a6d81c27c9b3a1a175ba3d":["49adbad5232116eb2448ea8166464e6a68bca007"],"fde68de507dbf344495d7b5e8052866fe5f254ab":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"1cedb00d2dd44640194401179358a2e3ba6051bf":["e52fea2c4081a1e552b98506691990be59503168"],"e52fea2c4081a1e552b98506691990be59503168":["84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8"],"a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be":["5a0af3a442be522899177e5e11384a45a6784a3f"],"49adbad5232116eb2448ea8166464e6a68bca007":["ac1242ce6d99813874fddfe4ca5f57779beddb22"],"84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8":["a9802bb5985cb6cc3e0a3a0ecb2158acf4d5cfcf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fde68de507dbf344495d7b5e8052866fe5f254ab"],"2558ddf9e14a97bc597f5b72bb3ecb5b7f6bba8e":["8560794cda5bcd510c60e38ed553e9c5a6204983"],"8560794cda5bcd510c60e38ed553e9c5a6204983":["346d5897e4c4e77ed5dbd31f7730ff30973d5971"],"a9802bb5985cb6cc3e0a3a0ecb2158acf4d5cfcf":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"ac1242ce6d99813874fddfe4ca5f57779beddb22":["a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be"],"5a0af3a442be522899177e5e11384a45a6784a3f":["5350389bf83287111f7760b9e3db3af8e3648474"],"5350389bf83287111f7760b9e3db3af8e3648474":["4e1ce9be74263e9659aad8a6ee1f213193710b71"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}