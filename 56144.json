{"path":"lucene/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","commits":[{"id":"142adfa88e132bc04810e7cc3a3bb3e9e5750777","date":1304693157,"type":1,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node).mjava","sourceNew":"  void add(Node<?> item) {\n    /*\n     * this non-blocking / 'wait-free' linked list add was inspired by Apache\n     * Harmony's ConcurrentLinkedQueue Implementation.\n     */\n    while (true) {\n      final Node<?> currentTail = this.tail;\n      final Node<?> tailNext = currentTail.next;\n      if (tail == currentTail) {\n        if (tailNext != null) {\n          /*\n           * we are in intermediate state here. the tails next pointer has been\n           * advanced but the tail itself might not be updated yet. help to\n           * advance the tail and try again updating it.\n           */\n          tailUpdater.compareAndSet(this, currentTail, tailNext); // can fail\n        } else {\n          /*\n           * we are in quiescent state and can try to insert the item to the\n           * current tail if we fail to insert we just retry the operation since\n           * somebody else has already added its item\n           */\n          if (currentTail.casNext(null, item)) {\n            /*\n             * now that we are done we need to advance the tail while another\n             * thread could have advanced it already so we can ignore the return\n             * type of this CAS call\n             */\n            tailUpdater.compareAndSet(this, currentTail, item);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  void add(Node item) {\n    /*\n     * this non-blocking / 'wait-free' linked list add was inspired by Apache\n     * Harmony's ConcurrentLinkedQueue Implementation.\n     */\n    while (true) {\n      final Node currentTail = this.tail;\n      final Node tailNext = currentTail.next;\n      if (tail == currentTail) {\n        if (tailNext != null) {\n          /*\n           * we are in intermediate state here. the tails next pointer has been\n           * advanced but the tail itself might not be updated yet. help to\n           * advance the tail and try again updating it.\n           */\n          tailUpdater.compareAndSet(this, currentTail, tailNext); // can fail\n        } else {\n          /*\n           * we are in quiescent state and can try to insert the item to the\n           * current tail if we fail to insert we just retry the operation since\n           * somebody else has already added its item\n           */\n          if (currentTail.casNext(null, item)) {\n            /*\n             * now that we are done we need to advance the tail while another\n             * thread could have advanced it already so we can ignore the return\n             * type of this CAS call\n             */\n            tailUpdater.compareAndSet(this, currentTail, item);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c700f8d0842d3e52bb2bdfbfdc046a137e836edb","date":1305285499,"type":1,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node).mjava","sourceNew":"  void add(Node<?> item) {\n    /*\n     * this non-blocking / 'wait-free' linked list add was inspired by Apache\n     * Harmony's ConcurrentLinkedQueue Implementation.\n     */\n    while (true) {\n      final Node<?> currentTail = this.tail;\n      final Node<?> tailNext = currentTail.next;\n      if (tail == currentTail) {\n        if (tailNext != null) {\n          /*\n           * we are in intermediate state here. the tails next pointer has been\n           * advanced but the tail itself might not be updated yet. help to\n           * advance the tail and try again updating it.\n           */\n          tailUpdater.compareAndSet(this, currentTail, tailNext); // can fail\n        } else {\n          /*\n           * we are in quiescent state and can try to insert the item to the\n           * current tail if we fail to insert we just retry the operation since\n           * somebody else has already added its item\n           */\n          if (currentTail.casNext(null, item)) {\n            /*\n             * now that we are done we need to advance the tail while another\n             * thread could have advanced it already so we can ignore the return\n             * type of this CAS call\n             */\n            tailUpdater.compareAndSet(this, currentTail, item);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  void add(Node item) {\n    /*\n     * this non-blocking / 'wait-free' linked list add was inspired by Apache\n     * Harmony's ConcurrentLinkedQueue Implementation.\n     */\n    while (true) {\n      final Node currentTail = this.tail;\n      final Node tailNext = currentTail.next;\n      if (tail == currentTail) {\n        if (tailNext != null) {\n          /*\n           * we are in intermediate state here. the tails next pointer has been\n           * advanced but the tail itself might not be updated yet. help to\n           * advance the tail and try again updating it.\n           */\n          tailUpdater.compareAndSet(this, currentTail, tailNext); // can fail\n        } else {\n          /*\n           * we are in quiescent state and can try to insert the item to the\n           * current tail if we fail to insert we just retry the operation since\n           * somebody else has already added its item\n           */\n          if (currentTail.casNext(null, item)) {\n            /*\n             * now that we are done we need to advance the tail while another\n             * thread could have advanced it already so we can ignore the return\n             * type of this CAS call\n             */\n            tailUpdater.compareAndSet(this, currentTail, item);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","pathOld":"/dev/null","sourceNew":"  void add(Node<?> item) {\n    /*\n     * this non-blocking / 'wait-free' linked list add was inspired by Apache\n     * Harmony's ConcurrentLinkedQueue Implementation.\n     */\n    while (true) {\n      final Node<?> currentTail = this.tail;\n      final Node<?> tailNext = currentTail.next;\n      if (tail == currentTail) {\n        if (tailNext != null) {\n          /*\n           * we are in intermediate state here. the tails next pointer has been\n           * advanced but the tail itself might not be updated yet. help to\n           * advance the tail and try again updating it.\n           */\n          tailUpdater.compareAndSet(this, currentTail, tailNext); // can fail\n        } else {\n          /*\n           * we are in quiescent state and can try to insert the item to the\n           * current tail if we fail to insert we just retry the operation since\n           * somebody else has already added its item\n           */\n          if (currentTail.casNext(null, item)) {\n            /*\n             * now that we are done we need to advance the tail while another\n             * thread could have advanced it already so we can ignore the return\n             * type of this CAS call\n             */\n            tailUpdater.compareAndSet(this, currentTail, item);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","sourceNew":"  void add(Node<?> item) {\n    /*\n     * this non-blocking / 'wait-free' linked list add was inspired by Apache\n     * Harmony's ConcurrentLinkedQueue Implementation.\n     */\n    while (true) {\n      final Node<?> currentTail = this.tail;\n      final Node<?> tailNext = currentTail.next;\n      if (tail == currentTail) {\n        if (tailNext != null) {\n          /*\n           * we are in intermediate state here. the tails next pointer has been\n           * advanced but the tail itself might not be updated yet. help to\n           * advance the tail and try again updating it.\n           */\n          tailUpdater.compareAndSet(this, currentTail, tailNext); // can fail\n        } else {\n          /*\n           * we are in quiescent state and can try to insert the item to the\n           * current tail if we fail to insert we just retry the operation since\n           * somebody else has already added its item\n           */\n          if (currentTail.casNext(null, item)) {\n            /*\n             * now that we are done we need to advance the tail while another\n             * thread could have advanced it already so we can ignore the return\n             * type of this CAS call\n             */\n            tailUpdater.compareAndSet(this, currentTail, item);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  void add(Node<?> item) {\n    /*\n     * this non-blocking / 'wait-free' linked list add was inspired by Apache\n     * Harmony's ConcurrentLinkedQueue Implementation.\n     */\n    while (true) {\n      final Node<?> currentTail = this.tail;\n      final Node<?> tailNext = currentTail.next;\n      if (tail == currentTail) {\n        if (tailNext != null) {\n          /*\n           * we are in intermediate state here. the tails next pointer has been\n           * advanced but the tail itself might not be updated yet. help to\n           * advance the tail and try again updating it.\n           */\n          tailUpdater.compareAndSet(this, currentTail, tailNext); // can fail\n        } else {\n          /*\n           * we are in quiescent state and can try to insert the item to the\n           * current tail if we fail to insert we just retry the operation since\n           * somebody else has already added its item\n           */\n          if (currentTail.casNext(null, item)) {\n            /*\n             * now that we are done we need to advance the tail while another\n             * thread could have advanced it already so we can ignore the return\n             * type of this CAS call\n             */\n            tailUpdater.compareAndSet(this, currentTail, item);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"142adfa88e132bc04810e7cc3a3bb3e9e5750777":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["142adfa88e132bc04810e7cc3a3bb3e9e5750777"],"a3776dccca01c11e7046323cfad46a3b4a471233":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","142adfa88e132bc04810e7cc3a3bb3e9e5750777"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c700f8d0842d3e52bb2bdfbfdc046a137e836edb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","142adfa88e132bc04810e7cc3a3bb3e9e5750777"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"142adfa88e132bc04810e7cc3a3bb3e9e5750777":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","a3776dccca01c11e7046323cfad46a3b4a471233","c700f8d0842d3e52bb2bdfbfdc046a137e836edb"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a3776dccca01c11e7046323cfad46a3b4a471233":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["142adfa88e132bc04810e7cc3a3bb3e9e5750777","a3776dccca01c11e7046323cfad46a3b4a471233","c700f8d0842d3e52bb2bdfbfdc046a137e836edb"],"c700f8d0842d3e52bb2bdfbfdc046a137e836edb":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a3776dccca01c11e7046323cfad46a3b4a471233","c700f8d0842d3e52bb2bdfbfdc046a137e836edb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}