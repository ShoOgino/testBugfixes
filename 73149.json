{"path":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","commits":[{"id":"2dfdf766e55e943d942055d7de53c7ad6bc45283","date":1441632886,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      extractWeightedSpanTerms(terms, sp, boost);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), terms);\n    } else {\n      Query origQuery = query;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        MultiTermQuery copy = (MultiTermQuery) query.clone();\n        copy.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n        origQuery = copy;\n      }\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten = origQuery.rewrite(reader);\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bbc553081eea52ac8a9c5e1af5ca003289216561","date":1442116486,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      // sum position increments beyond 1\n      int positionGaps = 0;\n      int[] positions = phraseQuery.getPositions();\n      if (positions.length >= 2) {\n        // positions are in increasing order.   max(0,...) is just a safeguard.\n        positionGaps = Math.max(0, positions[positions.length-1] - positions[0] - positions.length + 1);\n      }\n\n      //if original slop is 0 then require inOrder\n      boolean inorder = (phraseQuery.getSlop() == 0);\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n      extractWeightedSpanTerms(terms, sp, boost);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      extractWeightedSpanTerms(terms, sp, boost);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","bugFix":["cfd30f39d4b9b5bdcb2e23379090a0a93789b0df","5d934099a6f0a3ae0285025a1e1b61b7b05fed8f"],"bugIntro":["7b0d0cdee6b728fdf8a8cf5bec3320bb7f67fa16"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"92b4a131f1796dd57cc6698aae3d589d32a29deb","date":1457087316,"type":3,"author":"Luc Vanlerberghe","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      // sum position increments beyond 1\n      int positionGaps = 0;\n      int[] positions = phraseQuery.getPositions();\n      if (positions.length >= 2) {\n        // positions are in increasing order.   max(0,...) is just a safeguard.\n        positionGaps = Math.max(0, positions[positions.length-1] - positions[0] - positions.length + 1);\n      }\n\n      //if original slop is 0 then require inOrder\n      boolean inorder = (phraseQuery.getSlop() == 0);\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n      extractWeightedSpanTerms(terms, sp, boost);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      // sum position increments beyond 1\n      int positionGaps = 0;\n      int[] positions = phraseQuery.getPositions();\n      if (positions.length >= 2) {\n        // positions are in increasing order.   max(0,...) is just a safeguard.\n        positionGaps = Math.max(0, positions[positions.length-1] - positions[0] - positions.length + 1);\n      }\n\n      //if original slop is 0 then require inOrder\n      boolean inorder = (phraseQuery.getSlop() == 0);\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n      extractWeightedSpanTerms(terms, sp, boost);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      // sum position increments beyond 1\n      int positionGaps = 0;\n      int[] positions = phraseQuery.getPositions();\n      if (positions.length >= 2) {\n        // positions are in increasing order.   max(0,...) is just a safeguard.\n        positionGaps = Math.max(0, positions[positions.length-1] - positions[0] - positions.length + 1);\n      }\n\n      //if original slop is 0 then require inOrder\n      boolean inorder = (phraseQuery.getSlop() == 0);\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n      extractWeightedSpanTerms(terms, sp, boost);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      // sum position increments beyond 1\n      int positionGaps = 0;\n      int[] positions = phraseQuery.getPositions();\n      if (positions.length >= 2) {\n        // positions are in increasing order.   max(0,...) is just a safeguard.\n        positionGaps = Math.max(0, positions[positions.length-1] - positions[0] - positions.length + 1);\n      }\n\n      //if original slop is 0 then require inOrder\n      boolean inorder = (phraseQuery.getSlop() == 0);\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n      extractWeightedSpanTerms(terms, sp, boost);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eb9ee9de2835c3956662372b9e2407fe0e0fb731","date":1458917143,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      // sum position increments beyond 1\n      int positionGaps = 0;\n      int[] positions = phraseQuery.getPositions();\n      if (positions.length >= 2) {\n        // positions are in increasing order.   max(0,...) is just a safeguard.\n        positionGaps = Math.max(0, positions[positions.length-1] - positions[0] - positions.length + 1);\n      }\n\n      //if original slop is 0 then require inOrder\n      boolean inorder = (phraseQuery.getSlop() == 0);\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n      extractWeightedSpanTerms(terms, sp, boost);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      // sum position increments beyond 1\n      int positionGaps = 0;\n      int[] positions = phraseQuery.getPositions();\n      if (positions.length >= 2) {\n        // positions are in increasing order.   max(0,...) is just a safeguard.\n        positionGaps = Math.max(0, positions[positions.length-1] - positions[0] - positions.length + 1);\n      }\n\n      //if original slop is 0 then require inOrder\n      boolean inorder = (phraseQuery.getSlop() == 0);\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n      extractWeightedSpanTerms(terms, sp, boost);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","bugFix":["a00afb46b1a8a7ee8772ebbd41076442006ce5e4","081b68cb9e8f4b5405b40bfb223fd7c587171aa1"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7b0d0cdee6b728fdf8a8cf5bec3320bb7f67fa16","date":1463647723,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      }\n      else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      // sum position increments beyond 1\n      int positionGaps = 0;\n      int[] positions = phraseQuery.getPositions();\n      if (positions.length >= 2) {\n        // positions are in increasing order.   max(0,...) is just a safeguard.\n        positionGaps = Math.max(0, positions[positions.length-1] - positions[0] - positions.length + 1);\n      }\n\n      //if original slop is 0 then require inOrder\n      boolean inorder = (phraseQuery.getSlop() == 0);\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n      extractWeightedSpanTerms(terms, sp, boost);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","bugFix":["2dfdf766e55e943d942055d7de53c7ad6bc45283","cfd30f39d4b9b5bdcb2e23379090a0a93789b0df","bbc553081eea52ac8a9c5e1af5ca003289216561","5d934099a6f0a3ae0285025a1e1b61b7b05fed8f"],"bugIntro":["cb2eac46a4023564c3d2b41ec4bc90eb48e61154"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1eb10453c4217aa50392c51e3e89deb8b779bd51","date":1463648949,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      }\n      else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      // sum position increments beyond 1\n      int positionGaps = 0;\n      int[] positions = phraseQuery.getPositions();\n      if (positions.length >= 2) {\n        // positions are in increasing order.   max(0,...) is just a safeguard.\n        positionGaps = Math.max(0, positions[positions.length-1] - positions[0] - positions.length + 1);\n      }\n\n      //if original slop is 0 then require inOrder\n      boolean inorder = (phraseQuery.getSlop() == 0);\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n      extractWeightedSpanTerms(terms, sp, boost);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4c3df679e200c247683001257b3669e2024869d0","date":1463770206,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      }\n      else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else if (query instanceof GeoPointInBBoxQuery) {\n      // nothing\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      }\n      else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["3867285f1eb3f853859c16d64a8a0179f290d143"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3867285f1eb3f853859c16d64a8a0179f290d143","date":1463783330,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      }\n      else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else if (isQueryUnsupported(query.getClass())) {\n      // nothing\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      }\n      else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else if (query instanceof GeoPointInBBoxQuery) {\n      // nothing\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","bugFix":["4c3df679e200c247683001257b3669e2024869d0"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      }\n      else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else if (isQueryUnsupported(query.getClass())) {\n      // nothing\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      // sum position increments beyond 1\n      int positionGaps = 0;\n      int[] positions = phraseQuery.getPositions();\n      if (positions.length >= 2) {\n        // positions are in increasing order.   max(0,...) is just a safeguard.\n        positionGaps = Math.max(0, positions[positions.length-1] - positions[0] - positions.length + 1);\n      }\n\n      //if original slop is 0 then require inOrder\n      boolean inorder = (phraseQuery.getSlop() == 0);\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n      extractWeightedSpanTerms(terms, sp, boost);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"02d468a946da60dfedb2d8d178fc0c40461f9798","date":1465542675,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      }\n      else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery || query instanceof SynonymQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else if (isQueryUnsupported(query.getClass())) {\n      // nothing\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      }\n      else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else if (isQueryUnsupported(query.getClass())) {\n      // nothing\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","bugFix":["5d934099a6f0a3ae0285025a1e1b61b7b05fed8f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cb2eac46a4023564c3d2b41ec4bc90eb48e61154","date":1473429999,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      } else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery || query instanceof SynonymQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Query clause : ((DisjunctionMaxQuery) query)) {\n        extract(clause, boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (Term aTermArray : termArray) {\n            disjuncts.add(new SpanTermQuery(aTermArray));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (List<SpanQuery> disjuncts : disjunctLists) {\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        if (clauses.length == 1) {\n          extractWeightedSpanTerms(terms, clauses[0], boost);\n        } else {\n          final int slop = mpq.getSlop();\n          final boolean inorder = (slop == 0);\n\n          SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n          extractWeightedSpanTerms(terms, sp, boost);\n        }\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else if (isQueryUnsupported(query.getClass())) {\n      // nothing\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      }\n      else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery || query instanceof SynonymQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else if (isQueryUnsupported(query.getClass())) {\n      // nothing\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","bugFix":["2dfdf766e55e943d942055d7de53c7ad6bc45283","ffdf794cee8d43eb612df752c592cef2dc3e75ae","7b0d0cdee6b728fdf8a8cf5bec3320bb7f67fa16","5d934099a6f0a3ae0285025a1e1b61b7b05fed8f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"89424def13674ea17829b41c5883c54ecc31a132","date":1473767373,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      } else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery || query instanceof SynonymQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Query clause : ((DisjunctionMaxQuery) query)) {\n        extract(clause, boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (Term aTermArray : termArray) {\n            disjuncts.add(new SpanTermQuery(aTermArray));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (List<SpanQuery> disjuncts : disjunctLists) {\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        if (clauses.length == 1) {\n          extractWeightedSpanTerms(terms, clauses[0], boost);\n        } else {\n          final int slop = mpq.getSlop();\n          final boolean inorder = (slop == 0);\n\n          SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n          extractWeightedSpanTerms(terms, sp, boost);\n        }\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else if (isQueryUnsupported(query.getClass())) {\n      // nothing\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      }\n      else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery || query instanceof SynonymQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else if (isQueryUnsupported(query.getClass())) {\n      // nothing\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      } else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery || query instanceof SynonymQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Query clause : ((DisjunctionMaxQuery) query)) {\n        extract(clause, boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (Term aTermArray : termArray) {\n            disjuncts.add(new SpanTermQuery(aTermArray));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (List<SpanQuery> disjuncts : disjunctLists) {\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        if (clauses.length == 1) {\n          extractWeightedSpanTerms(terms, clauses[0], boost);\n        } else {\n          final int slop = mpq.getSlop();\n          final boolean inorder = (slop == 0);\n\n          SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n          extractWeightedSpanTerms(terms, sp, boost);\n        }\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else if (isQueryUnsupported(query.getClass())) {\n      // nothing\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      }\n      else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery || query instanceof SynonymQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else if (isQueryUnsupported(query.getClass())) {\n      // nothing\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      } else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery || query instanceof SynonymQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Query clause : ((DisjunctionMaxQuery) query)) {\n        extract(clause, boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (Term aTermArray : termArray) {\n            disjuncts.add(new SpanTermQuery(aTermArray));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (List<SpanQuery> disjuncts : disjunctLists) {\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        if (clauses.length == 1) {\n          extractWeightedSpanTerms(terms, clauses[0], boost);\n        } else {\n          final int slop = mpq.getSlop();\n          final boolean inorder = (slop == 0);\n\n          SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n          extractWeightedSpanTerms(terms, sp, boost);\n        }\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else if (isQueryUnsupported(query.getClass())) {\n      // nothing\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      // sum position increments beyond 1\n      int positionGaps = 0;\n      int[] positions = phraseQuery.getPositions();\n      if (positions.length >= 2) {\n        // positions are in increasing order.   max(0,...) is just a safeguard.\n        positionGaps = Math.max(0, positions[positions.length-1] - positions[0] - positions.length + 1);\n      }\n\n      //if original slop is 0 then require inOrder\n      boolean inorder = (phraseQuery.getSlop() == 0);\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n      extractWeightedSpanTerms(terms, sp, boost);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"203cbba17e28e65424501a76bf0ff5471c8eef06","date":1477315915,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      } else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery || query instanceof SynonymQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Query clause : ((DisjunctionMaxQuery) query)) {\n        extract(clause, boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (Term aTermArray : termArray) {\n            disjuncts.add(new SpanTermQuery(aTermArray));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (List<SpanQuery> disjuncts : disjunctLists) {\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        if (clauses.length == 1) {\n          extractWeightedSpanTerms(terms, clauses[0], boost);\n        } else {\n          final int slop = mpq.getSlop();\n          final boolean inorder = (slop == 0);\n\n          SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n          extractWeightedSpanTerms(terms, sp, boost);\n        }\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else if (isQueryUnsupported(query.getClass())) {\n      // nothing\n    } else {\n      if (query instanceof MultiTermQuery &&\n          (!expandMultiTermQuery || !fieldNameComparator(((MultiTermQuery)query).getField()))) {\n        return;\n      }\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      } else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery || query instanceof SynonymQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Query clause : ((DisjunctionMaxQuery) query)) {\n        extract(clause, boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (Term aTermArray : termArray) {\n            disjuncts.add(new SpanTermQuery(aTermArray));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (List<SpanQuery> disjuncts : disjunctLists) {\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        if (clauses.length == 1) {\n          extractWeightedSpanTerms(terms, clauses[0], boost);\n        } else {\n          final int slop = mpq.getSlop();\n          final boolean inorder = (slop == 0);\n\n          SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n          extractWeightedSpanTerms(terms, sp, boost);\n        }\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else if (isQueryUnsupported(query.getClass())) {\n      // nothing\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","bugFix":["081b68cb9e8f4b5405b40bfb223fd7c587171aa1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60b61628d1912768f51eccaa8ead5a5a32ab34c6","date":1477427681,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      } else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery || query instanceof SynonymQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Query clause : ((DisjunctionMaxQuery) query)) {\n        extract(clause, boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (Term aTermArray : termArray) {\n            disjuncts.add(new SpanTermQuery(aTermArray));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (List<SpanQuery> disjuncts : disjunctLists) {\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        if (clauses.length == 1) {\n          extractWeightedSpanTerms(terms, clauses[0], boost);\n        } else {\n          final int slop = mpq.getSlop();\n          final boolean inorder = (slop == 0);\n\n          SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n          extractWeightedSpanTerms(terms, sp, boost);\n        }\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else if (isQueryUnsupported(query.getClass())) {\n      // nothing\n    } else {\n      if (query instanceof MultiTermQuery &&\n          (!expandMultiTermQuery || !fieldNameComparator(((MultiTermQuery)query).getField()))) {\n        return;\n      }\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      } else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery || query instanceof SynonymQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Query clause : ((DisjunctionMaxQuery) query)) {\n        extract(clause, boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (Term aTermArray : termArray) {\n            disjuncts.add(new SpanTermQuery(aTermArray));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (List<SpanQuery> disjuncts : disjunctLists) {\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        if (clauses.length == 1) {\n          extractWeightedSpanTerms(terms, clauses[0], boost);\n        } else {\n          final int slop = mpq.getSlop();\n          final boolean inorder = (slop == 0);\n\n          SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n          extractWeightedSpanTerms(terms, sp, boost);\n        }\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else if (isQueryUnsupported(query.getClass())) {\n      // nothing\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"80d0e6d59ae23f4a6f30eaf40bfb40742300287f","date":1477598926,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      } else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery || query instanceof SynonymQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Query clause : ((DisjunctionMaxQuery) query)) {\n        extract(clause, boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (Term aTermArray : termArray) {\n            disjuncts.add(new SpanTermQuery(aTermArray));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (List<SpanQuery> disjuncts : disjunctLists) {\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        if (clauses.length == 1) {\n          extractWeightedSpanTerms(terms, clauses[0], boost);\n        } else {\n          final int slop = mpq.getSlop();\n          final boolean inorder = (slop == 0);\n\n          SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n          extractWeightedSpanTerms(terms, sp, boost);\n        }\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else if (isQueryUnsupported(query.getClass())) {\n      // nothing\n    } else {\n      if (query instanceof MultiTermQuery &&\n          (!expandMultiTermQuery || !fieldNameComparator(((MultiTermQuery)query).getField()))) {\n        return;\n      }\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      } else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery || query instanceof SynonymQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Query clause : ((DisjunctionMaxQuery) query)) {\n        extract(clause, boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (Term aTermArray : termArray) {\n            disjuncts.add(new SpanTermQuery(aTermArray));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (List<SpanQuery> disjuncts : disjunctLists) {\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        if (clauses.length == 1) {\n          extractWeightedSpanTerms(terms, clauses[0], boost);\n        } else {\n          final int slop = mpq.getSlop();\n          final boolean inorder = (slop == 0);\n\n          SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n          extractWeightedSpanTerms(terms, sp, boost);\n        }\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else if (isQueryUnsupported(query.getClass())) {\n      // nothing\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"62f3efc82b1ead830448bb27e2af9f89417401ea","date":1513619223,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      } else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery || query instanceof SynonymQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Query clause : ((DisjunctionMaxQuery) query)) {\n        extract(clause, boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (Term aTermArray : termArray) {\n            disjuncts.add(new SpanTermQuery(aTermArray));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (List<SpanQuery> disjuncts : disjunctLists) {\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        if (clauses.length == 1) {\n          extractWeightedSpanTerms(terms, clauses[0], boost);\n        } else {\n          final int slop = mpq.getSlop();\n          final boolean inorder = (slop == 0);\n\n          SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n          extractWeightedSpanTerms(terms, sp, boost);\n        }\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery) {\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else if (query instanceof FunctionScoreQuery) {\n      extract(((FunctionScoreQuery) query).getWrappedQuery(), boost, terms);\n    } else if (isQueryUnsupported(query.getClass())) {\n      // nothing\n    } else {\n      if (query instanceof MultiTermQuery &&\n          (!expandMultiTermQuery || !fieldNameComparator(((MultiTermQuery)query).getField()))) {\n        return;\n      }\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      } else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery || query instanceof SynonymQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Query clause : ((DisjunctionMaxQuery) query)) {\n        extract(clause, boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (Term aTermArray : termArray) {\n            disjuncts.add(new SpanTermQuery(aTermArray));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (List<SpanQuery> disjuncts : disjunctLists) {\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        if (clauses.length == 1) {\n          extractWeightedSpanTerms(terms, clauses[0], boost);\n        } else {\n          final int slop = mpq.getSlop();\n          final boolean inorder = (slop == 0);\n\n          SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n          extractWeightedSpanTerms(terms, sp, boost);\n        }\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else if (isQueryUnsupported(query.getClass())) {\n      // nothing\n    } else {\n      if (query instanceof MultiTermQuery &&\n          (!expandMultiTermQuery || !fieldNameComparator(((MultiTermQuery)query).getField()))) {\n        return;\n      }\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a82662cae660e76ded4de1e9b451633e523d83e1","date":1513619223,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      } else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery || query instanceof SynonymQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Query clause : ((DisjunctionMaxQuery) query)) {\n        extract(clause, boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (Term aTermArray : termArray) {\n            disjuncts.add(new SpanTermQuery(aTermArray));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (List<SpanQuery> disjuncts : disjunctLists) {\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        if (clauses.length == 1) {\n          extractWeightedSpanTerms(terms, clauses[0], boost);\n        } else {\n          final int slop = mpq.getSlop();\n          final boolean inorder = (slop == 0);\n\n          SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n          extractWeightedSpanTerms(terms, sp, boost);\n        }\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof FunctionScoreQuery) {\n      extract(((FunctionScoreQuery) query).getWrappedQuery(), boost, terms);\n    } else if (isQueryUnsupported(query.getClass())) {\n      // nothing\n    } else {\n      if (query instanceof MultiTermQuery &&\n          (!expandMultiTermQuery || !fieldNameComparator(((MultiTermQuery)query).getField()))) {\n        return;\n      }\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      } else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery || query instanceof SynonymQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Query clause : ((DisjunctionMaxQuery) query)) {\n        extract(clause, boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (Term aTermArray : termArray) {\n            disjuncts.add(new SpanTermQuery(aTermArray));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (List<SpanQuery> disjuncts : disjunctLists) {\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        if (clauses.length == 1) {\n          extractWeightedSpanTerms(terms, clauses[0], boost);\n        } else {\n          final int slop = mpq.getSlop();\n          final boolean inorder = (slop == 0);\n\n          SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n          extractWeightedSpanTerms(terms, sp, boost);\n        }\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery) {\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else if (query instanceof FunctionScoreQuery) {\n      extract(((FunctionScoreQuery) query).getWrappedQuery(), boost, terms);\n    } else if (isQueryUnsupported(query.getClass())) {\n      // nothing\n    } else {\n      if (query instanceof MultiTermQuery &&\n          (!expandMultiTermQuery || !fieldNameComparator(((MultiTermQuery)query).getField()))) {\n        return;\n      }\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6e9f769521480a623f897c0d59089b919fa4239","date":1515161835,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      } else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery || query instanceof SynonymQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is index sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Query clause : ((DisjunctionMaxQuery) query)) {\n        extract(clause, boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (Term aTermArray : termArray) {\n            disjuncts.add(new SpanTermQuery(aTermArray));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (List<SpanQuery> disjuncts : disjunctLists) {\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        if (clauses.length == 1) {\n          extractWeightedSpanTerms(terms, clauses[0], boost);\n        } else {\n          final int slop = mpq.getSlop();\n          final boolean inorder = (slop == 0);\n\n          SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n          extractWeightedSpanTerms(terms, sp, boost);\n        }\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof FunctionScoreQuery) {\n      extract(((FunctionScoreQuery) query).getWrappedQuery(), boost, terms);\n    } else if (isQueryUnsupported(query.getClass())) {\n      // nothing\n    } else {\n      if (query instanceof MultiTermQuery &&\n          (!expandMultiTermQuery || !fieldNameComparator(((MultiTermQuery)query).getField()))) {\n        return;\n      }\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      } else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery || query instanceof SynonymQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Query clause : ((DisjunctionMaxQuery) query)) {\n        extract(clause, boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (Term aTermArray : termArray) {\n            disjuncts.add(new SpanTermQuery(aTermArray));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (List<SpanQuery> disjuncts : disjunctLists) {\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        if (clauses.length == 1) {\n          extractWeightedSpanTerms(terms, clauses[0], boost);\n        } else {\n          final int slop = mpq.getSlop();\n          final boolean inorder = (slop == 0);\n\n          SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n          extractWeightedSpanTerms(terms, sp, boost);\n        }\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof FunctionScoreQuery) {\n      extract(((FunctionScoreQuery) query).getWrappedQuery(), boost, terms);\n    } else if (isQueryUnsupported(query.getClass())) {\n      // nothing\n    } else {\n      if (query instanceof MultiTermQuery &&\n          (!expandMultiTermQuery || !fieldNameComparator(((MultiTermQuery)query).getField()))) {\n        return;\n      }\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      } else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery || query instanceof SynonymQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is index sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Query clause : ((DisjunctionMaxQuery) query)) {\n        extract(clause, boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (Term aTermArray : termArray) {\n            disjuncts.add(new SpanTermQuery(aTermArray));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (List<SpanQuery> disjuncts : disjunctLists) {\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        if (clauses.length == 1) {\n          extractWeightedSpanTerms(terms, clauses[0], boost);\n        } else {\n          final int slop = mpq.getSlop();\n          final boolean inorder = (slop == 0);\n\n          SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n          extractWeightedSpanTerms(terms, sp, boost);\n        }\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof FunctionScoreQuery) {\n      extract(((FunctionScoreQuery) query).getWrappedQuery(), boost, terms);\n    } else if (isQueryUnsupported(query.getClass())) {\n      // nothing\n    } else {\n      if (query instanceof MultiTermQuery &&\n          (!expandMultiTermQuery || !fieldNameComparator(((MultiTermQuery)query).getField()))) {\n        return;\n      }\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      } else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery || query instanceof SynonymQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Query clause : ((DisjunctionMaxQuery) query)) {\n        extract(clause, boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (Term aTermArray : termArray) {\n            disjuncts.add(new SpanTermQuery(aTermArray));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (List<SpanQuery> disjuncts : disjunctLists) {\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        if (clauses.length == 1) {\n          extractWeightedSpanTerms(terms, clauses[0], boost);\n        } else {\n          final int slop = mpq.getSlop();\n          final boolean inorder = (slop == 0);\n\n          SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n          extractWeightedSpanTerms(terms, sp, boost);\n        }\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof FunctionScoreQuery) {\n      extract(((FunctionScoreQuery) query).getWrappedQuery(), boost, terms);\n    } else if (isQueryUnsupported(query.getClass())) {\n      // nothing\n    } else {\n      if (query instanceof MultiTermQuery &&\n          (!expandMultiTermQuery || !fieldNameComparator(((MultiTermQuery)query).getField()))) {\n        return;\n      }\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"944feda4f2ab2e2de62f308b3cbb6ba6953902ef","date":1539867181,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      } else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery || query instanceof SynonymQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is index sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Query clause : ((DisjunctionMaxQuery) query)) {\n        extract(clause, boost, terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (Term aTermArray : termArray) {\n            disjuncts.add(new SpanTermQuery(aTermArray));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (List<SpanQuery> disjuncts : disjunctLists) {\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        if (clauses.length == 1) {\n          extractWeightedSpanTerms(terms, clauses[0], boost);\n        } else {\n          final int slop = mpq.getSlop();\n          final boolean inorder = (slop == 0);\n\n          SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n          extractWeightedSpanTerms(terms, sp, boost);\n        }\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof FunctionScoreQuery) {\n      extract(((FunctionScoreQuery) query).getWrappedQuery(), boost, terms);\n    } else if (isQueryUnsupported(query.getClass())) {\n      // nothing\n    } else {\n      if (query instanceof MultiTermQuery &&\n          (!expandMultiTermQuery || !fieldNameComparator(((MultiTermQuery)query).getField()))) {\n        return;\n      }\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      if (phraseQueryTerms.length == 1) {\n        extractWeightedSpanTerms(terms, new SpanTermQuery(phraseQueryTerms[0]), boost);\n      } else {\n        SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n        for (int i = 0; i < phraseQueryTerms.length; i++) {\n          clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n        }\n\n        // sum position increments beyond 1\n        int positionGaps = 0;\n        int[] positions = phraseQuery.getPositions();\n        if (positions.length >= 2) {\n          // positions are in increasing order.   max(0,...) is just a safeguard.\n          positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);\n        }\n\n        //if original slop is 0 then require inOrder\n        boolean inorder = (phraseQuery.getSlop() == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof TermQuery || query instanceof SynonymQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is index sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Query clause : ((DisjunctionMaxQuery) query)) {\n        extract(clause, boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final Term[][] termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.length; ++i) {\n          final Term[] termArray = termArrays[i];\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (Term aTermArray : termArray) {\n            disjuncts.add(new SpanTermQuery(aTermArray));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (List<SpanQuery> disjuncts : disjunctLists) {\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        if (clauses.length == 1) {\n          extractWeightedSpanTerms(terms, clauses[0], boost);\n        } else {\n          final int slop = mpq.getSlop();\n          final boolean inorder = (slop == 0);\n\n          SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n          extractWeightedSpanTerms(terms, sp, boost);\n        }\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof FunctionScoreQuery) {\n      extract(((FunctionScoreQuery) query).getWrappedQuery(), boost, terms);\n    } else if (isQueryUnsupported(query.getClass())) {\n      // nothing\n    } else {\n      if (query instanceof MultiTermQuery &&\n          (!expandMultiTermQuery || !fieldNameComparator(((MultiTermQuery)query).getField()))) {\n        return;\n      }\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a special treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } else {\n        extractUnknownQuery(query, terms);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["a82662cae660e76ded4de1e9b451633e523d83e1","a6e9f769521480a623f897c0d59089b919fa4239"],"4c3df679e200c247683001257b3669e2024869d0":["1eb10453c4217aa50392c51e3e89deb8b779bd51"],"bbc553081eea52ac8a9c5e1af5ca003289216561":["2dfdf766e55e943d942055d7de53c7ad6bc45283"],"62f3efc82b1ead830448bb27e2af9f89417401ea":["60b61628d1912768f51eccaa8ead5a5a32ab34c6"],"eb9ee9de2835c3956662372b9e2407fe0e0fb731":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["eb9ee9de2835c3956662372b9e2407fe0e0fb731","3867285f1eb3f853859c16d64a8a0179f290d143"],"89424def13674ea17829b41c5883c54ecc31a132":["02d468a946da60dfedb2d8d178fc0c40461f9798","cb2eac46a4023564c3d2b41ec4bc90eb48e61154"],"60b61628d1912768f51eccaa8ead5a5a32ab34c6":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","203cbba17e28e65424501a76bf0ff5471c8eef06"],"944feda4f2ab2e2de62f308b3cbb6ba6953902ef":["b94236357aaa22b76c10629851fe4e376e0cea82"],"a6e9f769521480a623f897c0d59089b919fa4239":["a82662cae660e76ded4de1e9b451633e523d83e1"],"a82662cae660e76ded4de1e9b451633e523d83e1":["62f3efc82b1ead830448bb27e2af9f89417401ea"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["02d468a946da60dfedb2d8d178fc0c40461f9798","89424def13674ea17829b41c5883c54ecc31a132"],"1eb10453c4217aa50392c51e3e89deb8b779bd51":["eb9ee9de2835c3956662372b9e2407fe0e0fb731","7b0d0cdee6b728fdf8a8cf5bec3320bb7f67fa16"],"cb2eac46a4023564c3d2b41ec4bc90eb48e61154":["02d468a946da60dfedb2d8d178fc0c40461f9798"],"2dfdf766e55e943d942055d7de53c7ad6bc45283":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["eb9ee9de2835c3956662372b9e2407fe0e0fb731","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"02d468a946da60dfedb2d8d178fc0c40461f9798":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"92b4a131f1796dd57cc6698aae3d589d32a29deb":["bbc553081eea52ac8a9c5e1af5ca003289216561"],"7b0d0cdee6b728fdf8a8cf5bec3320bb7f67fa16":["eb9ee9de2835c3956662372b9e2407fe0e0fb731"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","60b61628d1912768f51eccaa8ead5a5a32ab34c6"],"3867285f1eb3f853859c16d64a8a0179f290d143":["4c3df679e200c247683001257b3669e2024869d0"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["bbc553081eea52ac8a9c5e1af5ca003289216561","92b4a131f1796dd57cc6698aae3d589d32a29deb"],"203cbba17e28e65424501a76bf0ff5471c8eef06":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["944feda4f2ab2e2de62f308b3cbb6ba6953902ef"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["944feda4f2ab2e2de62f308b3cbb6ba6953902ef"],"4c3df679e200c247683001257b3669e2024869d0":["3867285f1eb3f853859c16d64a8a0179f290d143"],"bbc553081eea52ac8a9c5e1af5ca003289216561":["92b4a131f1796dd57cc6698aae3d589d32a29deb","cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"62f3efc82b1ead830448bb27e2af9f89417401ea":["a82662cae660e76ded4de1e9b451633e523d83e1"],"eb9ee9de2835c3956662372b9e2407fe0e0fb731":["d470c8182e92b264680e34081b75e70a9f2b3c89","1eb10453c4217aa50392c51e3e89deb8b779bd51","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","7b0d0cdee6b728fdf8a8cf5bec3320bb7f67fa16"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["02d468a946da60dfedb2d8d178fc0c40461f9798"],"89424def13674ea17829b41c5883c54ecc31a132":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"60b61628d1912768f51eccaa8ead5a5a32ab34c6":["62f3efc82b1ead830448bb27e2af9f89417401ea","80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"a6e9f769521480a623f897c0d59089b919fa4239":["b94236357aaa22b76c10629851fe4e376e0cea82"],"944feda4f2ab2e2de62f308b3cbb6ba6953902ef":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a82662cae660e76ded4de1e9b451633e523d83e1":["b94236357aaa22b76c10629851fe4e376e0cea82","a6e9f769521480a623f897c0d59089b919fa4239"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["60b61628d1912768f51eccaa8ead5a5a32ab34c6","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","203cbba17e28e65424501a76bf0ff5471c8eef06"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2dfdf766e55e943d942055d7de53c7ad6bc45283"],"1eb10453c4217aa50392c51e3e89deb8b779bd51":["4c3df679e200c247683001257b3669e2024869d0"],"cb2eac46a4023564c3d2b41ec4bc90eb48e61154":["89424def13674ea17829b41c5883c54ecc31a132"],"2dfdf766e55e943d942055d7de53c7ad6bc45283":["bbc553081eea52ac8a9c5e1af5ca003289216561"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"02d468a946da60dfedb2d8d178fc0c40461f9798":["89424def13674ea17829b41c5883c54ecc31a132","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","cb2eac46a4023564c3d2b41ec4bc90eb48e61154"],"7b0d0cdee6b728fdf8a8cf5bec3320bb7f67fa16":["1eb10453c4217aa50392c51e3e89deb8b779bd51"],"92b4a131f1796dd57cc6698aae3d589d32a29deb":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":[],"3867285f1eb3f853859c16d64a8a0179f290d143":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["eb9ee9de2835c3956662372b9e2407fe0e0fb731"],"203cbba17e28e65424501a76bf0ff5471c8eef06":["60b61628d1912768f51eccaa8ead5a5a32ab34c6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}