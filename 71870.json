{"path":"solr/core/src/test/org/apache/solr/handler/component/StatsComponentTest#testIndividualStatLocalParams().mjava","commits":[{"id":"d12bbc45d641864ffe03291bc30f178eb34e434c","date":1426001646,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/component/StatsComponentTest#testIndividualStatLocalParams().mjava","pathOld":"/dev/null","sourceNew":"  public void testIndividualStatLocalParams() throws Exception {\n    final String kpre = XPRE + \"lst[@name='stats_fields']/lst[@name='k']/\";\n    \n    assertU(adoc(\"id\", \"1\", \"a_f\", \"2.3\", \"b_f\", \"9.7\", \"a_i\", \"9\", \"foo_t\", \"how now brown cow\"));\n    assertU(commit());\n    \n    // some quick sanity check assertions...\n\n    // trivial check that we only get the exact 2 we ask for\n    assertQ(\"ask for and get only 2 stats\",\n            req(\"q\",\"*:*\", \"stats\", \"true\",\n                \"stats.field\", \"{!key=k mean=true min=true}a_i\")\n            , kpre + \"double[@name='mean'][.='9.0']\"\n            , kpre + \"double[@name='min'][.='9.0']\"\n            , \"count(\" + kpre + \"*)=2\"\n            );\n\n    // for stats that are true/false, sanity check false does it's job\n    assertQ(\"min=true & max=false: only min should come back\",\n            req(\"q\",\"*:*\", \"stats\", \"true\",\n                \"stats.field\", \"{!key=k max=false min=true}a_i\")\n            , kpre + \"double[@name='min'][.='9.0']\"\n            , \"count(\" + kpre + \"*)=1\"\n            );\n    assertQ(\"min=false: localparam stat means ignore default set, \"+\n            \"but since only local param is false no stats should be returned\",\n            req(\"q\",\"*:*\", \"stats\", \"true\",\n                \"stats.field\", \"{!key=k min=false}a_i\")\n            , \"count(\" + kpre + \"*)=0\"\n            );\n\n   double sum = 0;\n   double sumOfSquares = 0;\n   final int count = 20;\n   for (int i = 0; i < count; i++) {\n     assertU(adoc(\"id\", String.valueOf(i), \"a_f\", \"2.3\", \"b_f\", \"9.7\", \"a_i\", String.valueOf(i%10), \"foo_t\", \"how now brown cow\"));\n     sum+=i%10;\n     sumOfSquares+=(i%10)*(i%10);\n   }\n   \n   assertU(commit());\n\n   EnumSet<Stat> allStats = EnumSet.allOf(Stat.class);\n\n   Map<Stat, String> expectedStats = new HashMap<>();\n   expectedStats.put(Stat.min, \"0.0\");\n   expectedStats.put(Stat.max, \"9.0\");\n   expectedStats.put(Stat.missing, \"0\");\n   expectedStats.put(Stat.sum, String.valueOf(sum));\n   expectedStats.put(Stat.count, String.valueOf(count));\n   expectedStats.put(Stat.mean, String.valueOf(sum/count));\n   expectedStats.put(Stat.sumOfSquares, String.valueOf(sumOfSquares));\n   expectedStats.put(Stat.stddev, String.valueOf(Math.sqrt(((count * sumOfSquares) - (sum * sum)) / (20 * (count - 1.0D)))));\n   expectedStats.put(Stat.calcdistinct, \"10\");\n   \n   Map<Stat, String> expectedType = new HashMap<>();\n   expectedType.put(Stat.min, \"double\");\n   expectedType.put(Stat.max, \"double\");\n   expectedType.put(Stat.missing, \"long\");\n   expectedType.put(Stat.sum, \"double\");\n   expectedType.put(Stat.count, \"long\");\n   expectedType.put(Stat.mean, \"double\");\n   expectedType.put(Stat.sumOfSquares, \"double\");\n   expectedType.put(Stat.stddev, \"double\");\n   expectedType.put(Stat.calcdistinct, \"long\");\n\n   // canary in the coal mine\n   assertEquals(\"size of expectedStats doesn't match all known stats; \" + \n                \"enum was updated w/o updating test?\",\n                expectedStats.size(), allStats.size());\n   assertEquals(\"size of expectedType doesn't match all known stats; \" + \n                \"enum was updated w/o updating test?\",\n                expectedType.size(), allStats.size());\n\n   // whitebox test: explicitly ask for isShard=true with an individual stat\n   for (Stat stat : expectedStats.keySet()) {\n     EnumSet<Stat> distribDeps = stat.getDistribDeps();\n\n     StringBuilder exclude = new StringBuilder();\n     List<String> testParas = new ArrayList<String>(distribDeps.size() + 2);\n     int calcdistinctFudge = 0;\n\n     for (Stat perShardStat : distribDeps ){\n       String key = perShardStat.toString();\n       if (perShardStat.equals(Stat.calcdistinct)) {\n         // this abomination breaks all the rules - uses a diff response key and triggers\n         // the additional \"distinctValues\" stat\n         key = \"countDistinct\";\n         calcdistinctFudge++;\n         testParas.add(\"count(\" + kpre + \"arr[@name='distinctValues']/*)=10\");\n       }\n       testParas.add(kpre + expectedType.get(perShardStat) + \n                     \"[@name='\" + key + \"'][.='\" + expectedStats.get(perShardStat) + \"']\");\n       // even if we go out of our way to exclude the dependent stats, \n       // the shard should return them since they are a dependency for the requested stat\n       exclude.append(perShardStat + \"=false \");\n     }\n     testParas.add(\"count(\" + kpre + \"*)=\" + (distribDeps.size() + calcdistinctFudge));\n\n     assertQ(\"ask for only \"+stat+\", with isShard=true, and expect only deps: \" + distribDeps,\n             req(\"q\", \"*:*\", \"isShard\", \"true\", \"stats\", \"true\", \n                 \"stats.field\", \"{!key=k \" + exclude + stat + \"=true}a_i\")\n             , testParas.toArray(new String[testParas.size()])\n             );\n   }\n   \n   // test all the possible combinations (of all possible sizes) of stats params\n   for (int numParams = 1; numParams <= allStats.size(); numParams++) {\n     for (EnumSet<Stat> set : new StatSetCombinations(numParams, allStats)) {\n\n       // EnumSets use natural ordering, we want to randomize the order of the params\n       List<Stat> combo = new ArrayList<Stat>(set);\n       Collections.shuffle(combo, random());\n\n       StringBuilder paras = new StringBuilder(\"{!key=k \");\n       List<String> testParas = new ArrayList<String>(numParams + 2);\n\n       int calcdistinctFudge = 0;\n       for (Stat stat : combo) {\n         String key = stat.toString();\n         if (stat.equals(Stat.calcdistinct)) {\n           // this abomination breaks all the rules - uses a diff response key and triggers\n           // the additional \"distinctValues\" stat\n           key = \"countDistinct\";\n           calcdistinctFudge++; \n           testParas.add(\"count(\" + kpre + \"arr[@name='distinctValues']/*)=10\");\n         }\n         paras.append(stat + \"=true \");\n         testParas.add(kpre + expectedType.get(stat) + \"[@name='\" + key + \"'][.='\" + expectedStats.get(stat) + \"']\");\n       }\n\n       paras.append(\"}a_i\");\n       testParas.add(\"count(\" + kpre + \"*)=\" + (combo.size() + calcdistinctFudge));\n\n       assertQ(\"ask for an get only: \"+ combo,\n               req(\"q\",\"*:*\", \"stats\", \"true\",\n                   \"stats.field\", paras.toString())\n               , testParas.toArray(new String[testParas.size()])\n               );\n     }\n   }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bcf9173fd8d1b123fb45b0c7d188d0c153fb609c","date":1426192682,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/component/StatsComponentTest#testIndividualStatLocalParams().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/component/StatsComponentTest#testIndividualStatLocalParams().mjava","sourceNew":"  public void testIndividualStatLocalParams() throws Exception {\n    final String kpre = XPRE + \"lst[@name='stats_fields']/lst[@name='k']/\";\n    \n    assertU(adoc(\"id\", \"1\", \"a_f\", \"2.3\", \"b_f\", \"9.7\", \"a_i\", \"9\", \"foo_t\", \"how now brown cow\"));\n    assertU(commit());\n    \n    // some quick sanity check assertions...\n\n    // trivial check that we only get the exact 2 we ask for\n    assertQ(\"ask for and get only 2 stats\",\n            req(\"q\",\"*:*\", \"stats\", \"true\",\n                \"stats.field\", \"{!key=k mean=true min=true}a_i\")\n            , kpre + \"double[@name='mean'][.='9.0']\"\n            , kpre + \"double[@name='min'][.='9.0']\"\n            , \"count(\" + kpre + \"*)=2\"\n            );\n\n    // for stats that are true/false, sanity check false does it's job\n    assertQ(\"min=true & max=false: only min should come back\",\n            req(\"q\",\"*:*\", \"stats\", \"true\",\n                \"stats.field\", \"{!key=k max=false min=true}a_i\")\n            , kpre + \"double[@name='min'][.='9.0']\"\n            , \"count(\" + kpre + \"*)=1\"\n            );\n    assertQ(\"min=false: localparam stat means ignore default set, \"+\n            \"but since only local param is false no stats should be returned\",\n            req(\"q\",\"*:*\", \"stats\", \"true\",\n                \"stats.field\", \"{!key=k min=false}a_i\")\n            // section of stats for this field should exist ...\n            , XPRE + \"lst[@name='stats_fields']/lst[@name='k']\"\n            // ...but be empty \n            , \"count(\" + kpre + \"*)=0\"\n            );\n\n   double sum = 0;\n   double sumOfSquares = 0;\n   final int count = 20;\n   for (int i = 0; i < count; i++) {\n     assertU(adoc(\"id\", String.valueOf(i), \"a_f\", \"2.3\", \"b_f\", \"9.7\", \"a_i\", String.valueOf(i%10), \"foo_t\", \"how now brown cow\"));\n     sum+=i%10;\n     sumOfSquares+=(i%10)*(i%10);\n   }\n   \n   assertU(commit());\n\n   EnumSet<Stat> allStats = EnumSet.allOf(Stat.class);\n\n   Map<Stat, String> expectedStats = new HashMap<>();\n   expectedStats.put(Stat.min, \"0.0\");\n   expectedStats.put(Stat.max, \"9.0\");\n   expectedStats.put(Stat.missing, \"0\");\n   expectedStats.put(Stat.sum, String.valueOf(sum));\n   expectedStats.put(Stat.count, String.valueOf(count));\n   expectedStats.put(Stat.mean, String.valueOf(sum/count));\n   expectedStats.put(Stat.sumOfSquares, String.valueOf(sumOfSquares));\n   expectedStats.put(Stat.stddev, String.valueOf(Math.sqrt(((count * sumOfSquares) - (sum * sum)) / (20 * (count - 1.0D)))));\n   expectedStats.put(Stat.calcdistinct, \"10\");\n   \n   Map<Stat, String> expectedType = new HashMap<>();\n   expectedType.put(Stat.min, \"double\");\n   expectedType.put(Stat.max, \"double\");\n   expectedType.put(Stat.missing, \"long\");\n   expectedType.put(Stat.sum, \"double\");\n   expectedType.put(Stat.count, \"long\");\n   expectedType.put(Stat.mean, \"double\");\n   expectedType.put(Stat.sumOfSquares, \"double\");\n   expectedType.put(Stat.stddev, \"double\");\n   expectedType.put(Stat.calcdistinct, \"long\");\n\n   // canary in the coal mine\n   assertEquals(\"size of expectedStats doesn't match all known stats; \" + \n                \"enum was updated w/o updating test?\",\n                expectedStats.size(), allStats.size());\n   assertEquals(\"size of expectedType doesn't match all known stats; \" + \n                \"enum was updated w/o updating test?\",\n                expectedType.size(), allStats.size());\n\n   // whitebox test: explicitly ask for isShard=true with an individual stat\n   for (Stat stat : expectedStats.keySet()) {\n     EnumSet<Stat> distribDeps = stat.getDistribDeps();\n\n     StringBuilder exclude = new StringBuilder();\n     List<String> testParas = new ArrayList<String>(distribDeps.size() + 2);\n     int calcdistinctFudge = 0;\n\n     for (Stat perShardStat : distribDeps ){\n       String key = perShardStat.toString();\n       if (perShardStat.equals(Stat.calcdistinct)) {\n         // this abomination breaks all the rules - uses a diff response key and triggers\n         // the additional \"distinctValues\" stat\n         key = \"countDistinct\";\n         calcdistinctFudge++;\n         testParas.add(\"count(\" + kpre + \"arr[@name='distinctValues']/*)=10\");\n       }\n       testParas.add(kpre + expectedType.get(perShardStat) + \n                     \"[@name='\" + key + \"'][.='\" + expectedStats.get(perShardStat) + \"']\");\n       // even if we go out of our way to exclude the dependent stats, \n       // the shard should return them since they are a dependency for the requested stat\n       exclude.append(perShardStat + \"=false \");\n     }\n     testParas.add(\"count(\" + kpre + \"*)=\" + (distribDeps.size() + calcdistinctFudge));\n\n     assertQ(\"ask for only \"+stat+\", with isShard=true, and expect only deps: \" + distribDeps,\n             req(\"q\", \"*:*\", \"isShard\", \"true\", \"stats\", \"true\", \n                 \"stats.field\", \"{!key=k \" + exclude + stat + \"=true}a_i\")\n             , testParas.toArray(new String[testParas.size()])\n             );\n   }\n   \n   // test all the possible combinations (of all possible sizes) of stats params\n   for (int numParams = 1; numParams <= allStats.size(); numParams++) {\n     for (EnumSet<Stat> set : new StatSetCombinations(numParams, allStats)) {\n\n       // EnumSets use natural ordering, we want to randomize the order of the params\n       List<Stat> combo = new ArrayList<Stat>(set);\n       Collections.shuffle(combo, random());\n\n       StringBuilder paras = new StringBuilder(\"{!key=k \");\n       List<String> testParas = new ArrayList<String>(numParams + 2);\n\n       int calcdistinctFudge = 0;\n       for (Stat stat : combo) {\n         String key = stat.toString();\n         if (stat.equals(Stat.calcdistinct)) {\n           // this abomination breaks all the rules - uses a diff response key and triggers\n           // the additional \"distinctValues\" stat\n           key = \"countDistinct\";\n           calcdistinctFudge++; \n           testParas.add(\"count(\" + kpre + \"arr[@name='distinctValues']/*)=10\");\n         }\n         paras.append(stat + \"=true \");\n         testParas.add(kpre + expectedType.get(stat) + \"[@name='\" + key + \"'][.='\" + expectedStats.get(stat) + \"']\");\n       }\n\n       paras.append(\"}a_i\");\n       testParas.add(\"count(\" + kpre + \"*)=\" + (combo.size() + calcdistinctFudge));\n\n       assertQ(\"ask for an get only: \"+ combo,\n               req(\"q\",\"*:*\", \"stats\", \"true\",\n                   \"stats.field\", paras.toString())\n               , testParas.toArray(new String[testParas.size()])\n               );\n     }\n   }\n\n  }\n\n","sourceOld":"  public void testIndividualStatLocalParams() throws Exception {\n    final String kpre = XPRE + \"lst[@name='stats_fields']/lst[@name='k']/\";\n    \n    assertU(adoc(\"id\", \"1\", \"a_f\", \"2.3\", \"b_f\", \"9.7\", \"a_i\", \"9\", \"foo_t\", \"how now brown cow\"));\n    assertU(commit());\n    \n    // some quick sanity check assertions...\n\n    // trivial check that we only get the exact 2 we ask for\n    assertQ(\"ask for and get only 2 stats\",\n            req(\"q\",\"*:*\", \"stats\", \"true\",\n                \"stats.field\", \"{!key=k mean=true min=true}a_i\")\n            , kpre + \"double[@name='mean'][.='9.0']\"\n            , kpre + \"double[@name='min'][.='9.0']\"\n            , \"count(\" + kpre + \"*)=2\"\n            );\n\n    // for stats that are true/false, sanity check false does it's job\n    assertQ(\"min=true & max=false: only min should come back\",\n            req(\"q\",\"*:*\", \"stats\", \"true\",\n                \"stats.field\", \"{!key=k max=false min=true}a_i\")\n            , kpre + \"double[@name='min'][.='9.0']\"\n            , \"count(\" + kpre + \"*)=1\"\n            );\n    assertQ(\"min=false: localparam stat means ignore default set, \"+\n            \"but since only local param is false no stats should be returned\",\n            req(\"q\",\"*:*\", \"stats\", \"true\",\n                \"stats.field\", \"{!key=k min=false}a_i\")\n            , \"count(\" + kpre + \"*)=0\"\n            );\n\n   double sum = 0;\n   double sumOfSquares = 0;\n   final int count = 20;\n   for (int i = 0; i < count; i++) {\n     assertU(adoc(\"id\", String.valueOf(i), \"a_f\", \"2.3\", \"b_f\", \"9.7\", \"a_i\", String.valueOf(i%10), \"foo_t\", \"how now brown cow\"));\n     sum+=i%10;\n     sumOfSquares+=(i%10)*(i%10);\n   }\n   \n   assertU(commit());\n\n   EnumSet<Stat> allStats = EnumSet.allOf(Stat.class);\n\n   Map<Stat, String> expectedStats = new HashMap<>();\n   expectedStats.put(Stat.min, \"0.0\");\n   expectedStats.put(Stat.max, \"9.0\");\n   expectedStats.put(Stat.missing, \"0\");\n   expectedStats.put(Stat.sum, String.valueOf(sum));\n   expectedStats.put(Stat.count, String.valueOf(count));\n   expectedStats.put(Stat.mean, String.valueOf(sum/count));\n   expectedStats.put(Stat.sumOfSquares, String.valueOf(sumOfSquares));\n   expectedStats.put(Stat.stddev, String.valueOf(Math.sqrt(((count * sumOfSquares) - (sum * sum)) / (20 * (count - 1.0D)))));\n   expectedStats.put(Stat.calcdistinct, \"10\");\n   \n   Map<Stat, String> expectedType = new HashMap<>();\n   expectedType.put(Stat.min, \"double\");\n   expectedType.put(Stat.max, \"double\");\n   expectedType.put(Stat.missing, \"long\");\n   expectedType.put(Stat.sum, \"double\");\n   expectedType.put(Stat.count, \"long\");\n   expectedType.put(Stat.mean, \"double\");\n   expectedType.put(Stat.sumOfSquares, \"double\");\n   expectedType.put(Stat.stddev, \"double\");\n   expectedType.put(Stat.calcdistinct, \"long\");\n\n   // canary in the coal mine\n   assertEquals(\"size of expectedStats doesn't match all known stats; \" + \n                \"enum was updated w/o updating test?\",\n                expectedStats.size(), allStats.size());\n   assertEquals(\"size of expectedType doesn't match all known stats; \" + \n                \"enum was updated w/o updating test?\",\n                expectedType.size(), allStats.size());\n\n   // whitebox test: explicitly ask for isShard=true with an individual stat\n   for (Stat stat : expectedStats.keySet()) {\n     EnumSet<Stat> distribDeps = stat.getDistribDeps();\n\n     StringBuilder exclude = new StringBuilder();\n     List<String> testParas = new ArrayList<String>(distribDeps.size() + 2);\n     int calcdistinctFudge = 0;\n\n     for (Stat perShardStat : distribDeps ){\n       String key = perShardStat.toString();\n       if (perShardStat.equals(Stat.calcdistinct)) {\n         // this abomination breaks all the rules - uses a diff response key and triggers\n         // the additional \"distinctValues\" stat\n         key = \"countDistinct\";\n         calcdistinctFudge++;\n         testParas.add(\"count(\" + kpre + \"arr[@name='distinctValues']/*)=10\");\n       }\n       testParas.add(kpre + expectedType.get(perShardStat) + \n                     \"[@name='\" + key + \"'][.='\" + expectedStats.get(perShardStat) + \"']\");\n       // even if we go out of our way to exclude the dependent stats, \n       // the shard should return them since they are a dependency for the requested stat\n       exclude.append(perShardStat + \"=false \");\n     }\n     testParas.add(\"count(\" + kpre + \"*)=\" + (distribDeps.size() + calcdistinctFudge));\n\n     assertQ(\"ask for only \"+stat+\", with isShard=true, and expect only deps: \" + distribDeps,\n             req(\"q\", \"*:*\", \"isShard\", \"true\", \"stats\", \"true\", \n                 \"stats.field\", \"{!key=k \" + exclude + stat + \"=true}a_i\")\n             , testParas.toArray(new String[testParas.size()])\n             );\n   }\n   \n   // test all the possible combinations (of all possible sizes) of stats params\n   for (int numParams = 1; numParams <= allStats.size(); numParams++) {\n     for (EnumSet<Stat> set : new StatSetCombinations(numParams, allStats)) {\n\n       // EnumSets use natural ordering, we want to randomize the order of the params\n       List<Stat> combo = new ArrayList<Stat>(set);\n       Collections.shuffle(combo, random());\n\n       StringBuilder paras = new StringBuilder(\"{!key=k \");\n       List<String> testParas = new ArrayList<String>(numParams + 2);\n\n       int calcdistinctFudge = 0;\n       for (Stat stat : combo) {\n         String key = stat.toString();\n         if (stat.equals(Stat.calcdistinct)) {\n           // this abomination breaks all the rules - uses a diff response key and triggers\n           // the additional \"distinctValues\" stat\n           key = \"countDistinct\";\n           calcdistinctFudge++; \n           testParas.add(\"count(\" + kpre + \"arr[@name='distinctValues']/*)=10\");\n         }\n         paras.append(stat + \"=true \");\n         testParas.add(kpre + expectedType.get(stat) + \"[@name='\" + key + \"'][.='\" + expectedStats.get(stat) + \"']\");\n       }\n\n       paras.append(\"}a_i\");\n       testParas.add(\"count(\" + kpre + \"*)=\" + (combo.size() + calcdistinctFudge));\n\n       assertQ(\"ask for an get only: \"+ combo,\n               req(\"q\",\"*:*\", \"stats\", \"true\",\n                   \"stats.field\", paras.toString())\n               , testParas.toArray(new String[testParas.size()])\n               );\n     }\n   }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1002283cfd29923d517db7c33e07bb54aac7acd4","date":1427211199,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/component/StatsComponentTest#testIndividualStatLocalParams().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/component/StatsComponentTest#testIndividualStatLocalParams().mjava","sourceNew":"  public void testIndividualStatLocalParams() throws Exception {\n    final String kpre = XPRE + \"lst[@name='stats_fields']/lst[@name='k']/\";\n    \n    assertU(adoc(\"id\", \"1\", \"a_f\", \"2.3\", \"b_f\", \"9.7\", \"a_i\", \"9\", \"foo_t\", \"how now brown cow\"));\n    assertU(commit());\n    \n    AVLTreeDigest tdigest = new AVLTreeDigest(100);\n    \n    // some quick sanity check assertions...\n    // trivial check that we only get the exact 2 we ask for\n    assertQ(\"ask for and get only 2 stats\",\n            req(\"q\",\"*:*\", \"stats\", \"true\",\n                \"stats.field\", \"{!key=k mean=true min=true}a_i\")\n            , kpre + \"double[@name='mean'][.='9.0']\"\n            , kpre + \"double[@name='min'][.='9.0']\"\n            , \"count(\" + kpre + \"*)=2\"\n            );\n\n    // for stats that are true/false, sanity check false does it's job\n    assertQ(\"min=true & max=false: only min should come back\",\n            req(\"q\",\"*:*\", \"stats\", \"true\",\n                \"stats.field\", \"{!key=k max=false min=true}a_i\")\n            , kpre + \"double[@name='min'][.='9.0']\"\n            , \"count(\" + kpre + \"*)=1\"\n            );\n    assertQ(\"min=false: localparam stat means ignore default set, \"+\n            \"but since only local param is false no stats should be returned\",\n            req(\"q\",\"*:*\", \"stats\", \"true\",\n                \"stats.field\", \"{!key=k min=false}a_i\")\n            // section of stats for this field should exist ...\n            , XPRE + \"lst[@name='stats_fields']/lst[@name='k']\"\n            // ...but be empty \n            , \"count(\" + kpre + \"*)=0\"\n            );\n\n    double sum = 0;\n    double sumOfSquares = 0;\n    final int count = 20;\n    for (int i = 0; i < count; i++) {\n      assertU(adoc(\"id\", String.valueOf(i), \"a_f\", \"2.3\", \"b_f\", \"9.7\", \"a_i\",\n          String.valueOf(i % 10), \"foo_t\", \"how now brown cow\"));\n      tdigest.add(i % 10);\n      sum += i % 10;\n      sumOfSquares += (i % 10) * (i % 10);\n    }\n   \n    assertU(commit());\n    \n    ByteBuffer buf = ByteBuffer.allocate(tdigest.smallByteSize());\n    tdigest.asSmallBytes(buf);\n    EnumSet<Stat> allStats = EnumSet.allOf(Stat.class);\n    \n    Map<Stat,String> expectedStats = new HashMap<>();\n    expectedStats.put(Stat.min, \"0.0\");\n    expectedStats.put(Stat.max, \"9.0\");\n    expectedStats.put(Stat.missing, \"0\");\n    expectedStats.put(Stat.sum, String.valueOf(sum));\n    expectedStats.put(Stat.count, String.valueOf(count));\n    expectedStats.put(Stat.mean, String.valueOf(sum / count));\n    expectedStats.put(Stat.sumOfSquares, String.valueOf(sumOfSquares));\n    expectedStats.put(Stat.stddev, String.valueOf(Math.sqrt(((count * sumOfSquares) - (sum * sum))/ (20 * (count - 1.0D)))));\n    expectedStats.put(Stat.calcdistinct, \"10\");\n    // NOTE: per shard expected value\n    expectedStats.put(Stat.percentiles, Base64.byteArrayToBase64(buf.array(), 0, buf.array().length));\n    \n    Map<Stat,String> expectedType = new HashMap<>();\n    expectedType.put(Stat.min, \"double\");\n    expectedType.put(Stat.max, \"double\");\n    expectedType.put(Stat.missing, \"long\");\n    expectedType.put(Stat.sum, \"double\");\n    expectedType.put(Stat.count, \"long\");\n    expectedType.put(Stat.mean, \"double\");\n    expectedType.put(Stat.sumOfSquares, \"double\");\n    expectedType.put(Stat.stddev, \"double\");\n    expectedType.put(Stat.calcdistinct, \"long\");\n    expectedType.put(Stat.percentiles, \"str\");\n   \n    Map<Stat,String> localParasInput = new HashMap<>();\n    localParasInput.put(Stat.min, \"true\");\n    localParasInput.put(Stat.max, \"true\");\n    localParasInput.put(Stat.missing, \"true\");\n    localParasInput.put(Stat.sum, \"true\");\n    localParasInput.put(Stat.count, \"true\");\n    localParasInput.put(Stat.mean, \"true\");\n    localParasInput.put(Stat.sumOfSquares, \"true\");\n    localParasInput.put(Stat.stddev, \"true\");\n    localParasInput.put(Stat.calcdistinct, \"true\");\n    localParasInput.put(Stat.percentiles, \"'90, 99'\");\n\n   // canary in the coal mine\n   assertEquals(\"size of expectedStats doesn't match all known stats; \" + \n                \"enum was updated w/o updating test?\",\n                expectedStats.size(), allStats.size());\n   assertEquals(\"size of expectedType doesn't match all known stats; \" + \n                \"enum was updated w/o updating test?\",\n                expectedType.size(), allStats.size());\n\n   // whitebox test: explicitly ask for isShard=true with an individual stat\n   for (Stat stat : expectedStats.keySet()) {\n     EnumSet<Stat> distribDeps = stat.getDistribDeps();\n\n     StringBuilder exclude = new StringBuilder();\n     List<String> testParas = new ArrayList<String>(distribDeps.size() + 2);\n     int calcdistinctFudge = 0;\n\n     for (Stat perShardStat : distribDeps ){\n       String key = perShardStat.toString();\n       if (perShardStat.equals(Stat.calcdistinct)) {\n         // this abomination breaks all the rules - uses a diff response key and triggers\n         // the additional \"distinctValues\" stat\n         key = \"countDistinct\";\n         calcdistinctFudge++;\n         testParas.add(\"count(\" + kpre + \"arr[@name='distinctValues']/*)=10\");\n       }\n       testParas.add(kpre + expectedType.get(perShardStat) + \n                     \"[@name='\" + key + \"'][.='\" + expectedStats.get(perShardStat) + \"']\");\n       // even if we go out of our way to exclude the dependent stats, \n       // the shard should return them since they are a dependency for the requested stat\n       if (!stat.equals(Stat.percentiles)){\n         exclude.append(perShardStat + \"=false \");\n       }\n     }\n     testParas.add(\"count(\" + kpre + \"*)=\" + (distribDeps.size() + calcdistinctFudge));\n\n     assertQ(\"ask for only \"+stat+\", with isShard=true, and expect only deps: \" + distribDeps,\n             req(\"q\", \"*:*\", \"isShard\", \"true\", \"stats\", \"true\", \n                 \"stats.field\", \"{!key=k \" + exclude + stat +\"=\" + localParasInput.get(stat) + \"}a_i\")\n             , testParas.toArray(new String[testParas.size()])\n             );\n   }\n   \n   // test all the possible combinations (of all possible sizes) of stats params\n   for (int numParams = 1; numParams <= allStats.size(); numParams++) {\n     for (EnumSet<Stat> set : new StatSetCombinations(numParams, allStats)) {\n\n       // EnumSets use natural ordering, we want to randomize the order of the params\n       List<Stat> combo = new ArrayList<Stat>(set);\n       Collections.shuffle(combo, random());\n\n       StringBuilder paras = new StringBuilder(\"{!key=k \");\n       List<String> testParas = new ArrayList<String>(numParams + 2);\n\n       int calcdistinctFudge = 0;\n       for (Stat stat : combo) {\n         String key = stat.toString();\n         if (stat.equals(Stat.calcdistinct)) {\n           // this abomination breaks all the rules - uses a diff response key and triggers\n           // the additional \"distinctValues\" stat\n           key = \"countDistinct\";\n           calcdistinctFudge++; \n           testParas.add(\"count(\" + kpre + \"arr[@name='distinctValues']/*)=10\");\n         }\n         paras.append(stat + \"=\" + localParasInput.get(stat)+ \" \");\n         \n         if (!stat.equals(Stat.percentiles)){\n           testParas.add(kpre + expectedType.get(stat) + \"[@name='\" + key + \"'][.='\" + expectedStats.get(stat) + \"']\");\n         } else {\n           testParas.add(\"count(\" + kpre + \"lst[@name='percentiles']/*)=2\");\n           String p90 = \"\" + tdigest.quantile(0.90D);\n           String p99 = \"\" + tdigest.quantile(0.99D);\n           testParas.add(kpre + \"lst[@name='percentiles']/double[@name='90.0'][.=\"+p90+\"]\");\n           testParas.add(kpre + \"lst[@name='percentiles']/double[@name='99.0'][.=\"+p99+\"]\");\n         }\n       }\n\n       paras.append(\"}a_i\");\n       testParas.add(\"count(\" + kpre + \"*)=\" + (combo.size() + calcdistinctFudge));\n\n       assertQ(\"ask for an get only: \"+ combo,\n               req(\"q\",\"*:*\", \"stats\", \"true\",\n                   \"stats.field\", paras.toString())\n               , testParas.toArray(new String[testParas.size()])\n               );\n     }\n   }\n  }\n\n","sourceOld":"  public void testIndividualStatLocalParams() throws Exception {\n    final String kpre = XPRE + \"lst[@name='stats_fields']/lst[@name='k']/\";\n    \n    assertU(adoc(\"id\", \"1\", \"a_f\", \"2.3\", \"b_f\", \"9.7\", \"a_i\", \"9\", \"foo_t\", \"how now brown cow\"));\n    assertU(commit());\n    \n    // some quick sanity check assertions...\n\n    // trivial check that we only get the exact 2 we ask for\n    assertQ(\"ask for and get only 2 stats\",\n            req(\"q\",\"*:*\", \"stats\", \"true\",\n                \"stats.field\", \"{!key=k mean=true min=true}a_i\")\n            , kpre + \"double[@name='mean'][.='9.0']\"\n            , kpre + \"double[@name='min'][.='9.0']\"\n            , \"count(\" + kpre + \"*)=2\"\n            );\n\n    // for stats that are true/false, sanity check false does it's job\n    assertQ(\"min=true & max=false: only min should come back\",\n            req(\"q\",\"*:*\", \"stats\", \"true\",\n                \"stats.field\", \"{!key=k max=false min=true}a_i\")\n            , kpre + \"double[@name='min'][.='9.0']\"\n            , \"count(\" + kpre + \"*)=1\"\n            );\n    assertQ(\"min=false: localparam stat means ignore default set, \"+\n            \"but since only local param is false no stats should be returned\",\n            req(\"q\",\"*:*\", \"stats\", \"true\",\n                \"stats.field\", \"{!key=k min=false}a_i\")\n            // section of stats for this field should exist ...\n            , XPRE + \"lst[@name='stats_fields']/lst[@name='k']\"\n            // ...but be empty \n            , \"count(\" + kpre + \"*)=0\"\n            );\n\n   double sum = 0;\n   double sumOfSquares = 0;\n   final int count = 20;\n   for (int i = 0; i < count; i++) {\n     assertU(adoc(\"id\", String.valueOf(i), \"a_f\", \"2.3\", \"b_f\", \"9.7\", \"a_i\", String.valueOf(i%10), \"foo_t\", \"how now brown cow\"));\n     sum+=i%10;\n     sumOfSquares+=(i%10)*(i%10);\n   }\n   \n   assertU(commit());\n\n   EnumSet<Stat> allStats = EnumSet.allOf(Stat.class);\n\n   Map<Stat, String> expectedStats = new HashMap<>();\n   expectedStats.put(Stat.min, \"0.0\");\n   expectedStats.put(Stat.max, \"9.0\");\n   expectedStats.put(Stat.missing, \"0\");\n   expectedStats.put(Stat.sum, String.valueOf(sum));\n   expectedStats.put(Stat.count, String.valueOf(count));\n   expectedStats.put(Stat.mean, String.valueOf(sum/count));\n   expectedStats.put(Stat.sumOfSquares, String.valueOf(sumOfSquares));\n   expectedStats.put(Stat.stddev, String.valueOf(Math.sqrt(((count * sumOfSquares) - (sum * sum)) / (20 * (count - 1.0D)))));\n   expectedStats.put(Stat.calcdistinct, \"10\");\n   \n   Map<Stat, String> expectedType = new HashMap<>();\n   expectedType.put(Stat.min, \"double\");\n   expectedType.put(Stat.max, \"double\");\n   expectedType.put(Stat.missing, \"long\");\n   expectedType.put(Stat.sum, \"double\");\n   expectedType.put(Stat.count, \"long\");\n   expectedType.put(Stat.mean, \"double\");\n   expectedType.put(Stat.sumOfSquares, \"double\");\n   expectedType.put(Stat.stddev, \"double\");\n   expectedType.put(Stat.calcdistinct, \"long\");\n\n   // canary in the coal mine\n   assertEquals(\"size of expectedStats doesn't match all known stats; \" + \n                \"enum was updated w/o updating test?\",\n                expectedStats.size(), allStats.size());\n   assertEquals(\"size of expectedType doesn't match all known stats; \" + \n                \"enum was updated w/o updating test?\",\n                expectedType.size(), allStats.size());\n\n   // whitebox test: explicitly ask for isShard=true with an individual stat\n   for (Stat stat : expectedStats.keySet()) {\n     EnumSet<Stat> distribDeps = stat.getDistribDeps();\n\n     StringBuilder exclude = new StringBuilder();\n     List<String> testParas = new ArrayList<String>(distribDeps.size() + 2);\n     int calcdistinctFudge = 0;\n\n     for (Stat perShardStat : distribDeps ){\n       String key = perShardStat.toString();\n       if (perShardStat.equals(Stat.calcdistinct)) {\n         // this abomination breaks all the rules - uses a diff response key and triggers\n         // the additional \"distinctValues\" stat\n         key = \"countDistinct\";\n         calcdistinctFudge++;\n         testParas.add(\"count(\" + kpre + \"arr[@name='distinctValues']/*)=10\");\n       }\n       testParas.add(kpre + expectedType.get(perShardStat) + \n                     \"[@name='\" + key + \"'][.='\" + expectedStats.get(perShardStat) + \"']\");\n       // even if we go out of our way to exclude the dependent stats, \n       // the shard should return them since they are a dependency for the requested stat\n       exclude.append(perShardStat + \"=false \");\n     }\n     testParas.add(\"count(\" + kpre + \"*)=\" + (distribDeps.size() + calcdistinctFudge));\n\n     assertQ(\"ask for only \"+stat+\", with isShard=true, and expect only deps: \" + distribDeps,\n             req(\"q\", \"*:*\", \"isShard\", \"true\", \"stats\", \"true\", \n                 \"stats.field\", \"{!key=k \" + exclude + stat + \"=true}a_i\")\n             , testParas.toArray(new String[testParas.size()])\n             );\n   }\n   \n   // test all the possible combinations (of all possible sizes) of stats params\n   for (int numParams = 1; numParams <= allStats.size(); numParams++) {\n     for (EnumSet<Stat> set : new StatSetCombinations(numParams, allStats)) {\n\n       // EnumSets use natural ordering, we want to randomize the order of the params\n       List<Stat> combo = new ArrayList<Stat>(set);\n       Collections.shuffle(combo, random());\n\n       StringBuilder paras = new StringBuilder(\"{!key=k \");\n       List<String> testParas = new ArrayList<String>(numParams + 2);\n\n       int calcdistinctFudge = 0;\n       for (Stat stat : combo) {\n         String key = stat.toString();\n         if (stat.equals(Stat.calcdistinct)) {\n           // this abomination breaks all the rules - uses a diff response key and triggers\n           // the additional \"distinctValues\" stat\n           key = \"countDistinct\";\n           calcdistinctFudge++; \n           testParas.add(\"count(\" + kpre + \"arr[@name='distinctValues']/*)=10\");\n         }\n         paras.append(stat + \"=true \");\n         testParas.add(kpre + expectedType.get(stat) + \"[@name='\" + key + \"'][.='\" + expectedStats.get(stat) + \"']\");\n       }\n\n       paras.append(\"}a_i\");\n       testParas.add(\"count(\" + kpre + \"*)=\" + (combo.size() + calcdistinctFudge));\n\n       assertQ(\"ask for an get only: \"+ combo,\n               req(\"q\",\"*:*\", \"stats\", \"true\",\n                   \"stats.field\", paras.toString())\n               , testParas.toArray(new String[testParas.size()])\n               );\n     }\n   }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":0,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/handler/component/StatsComponentTest#testIndividualStatLocalParams().mjava","pathOld":"/dev/null","sourceNew":"  public void testIndividualStatLocalParams() throws Exception {\n    final String kpre = XPRE + \"lst[@name='stats_fields']/lst[@name='k']/\";\n    \n    assertU(adoc(\"id\", \"1\", \"a_f\", \"2.3\", \"b_f\", \"9.7\", \"a_i\", \"9\", \"foo_t\", \"how now brown cow\"));\n    assertU(commit());\n    \n    AVLTreeDigest tdigest = new AVLTreeDigest(100);\n    \n    // some quick sanity check assertions...\n    // trivial check that we only get the exact 2 we ask for\n    assertQ(\"ask for and get only 2 stats\",\n            req(\"q\",\"*:*\", \"stats\", \"true\",\n                \"stats.field\", \"{!key=k mean=true min=true}a_i\")\n            , kpre + \"double[@name='mean'][.='9.0']\"\n            , kpre + \"double[@name='min'][.='9.0']\"\n            , \"count(\" + kpre + \"*)=2\"\n            );\n\n    // for stats that are true/false, sanity check false does it's job\n    assertQ(\"min=true & max=false: only min should come back\",\n            req(\"q\",\"*:*\", \"stats\", \"true\",\n                \"stats.field\", \"{!key=k max=false min=true}a_i\")\n            , kpre + \"double[@name='min'][.='9.0']\"\n            , \"count(\" + kpre + \"*)=1\"\n            );\n    assertQ(\"min=false: localparam stat means ignore default set, \"+\n            \"but since only local param is false no stats should be returned\",\n            req(\"q\",\"*:*\", \"stats\", \"true\",\n                \"stats.field\", \"{!key=k min=false}a_i\")\n            // section of stats for this field should exist ...\n            , XPRE + \"lst[@name='stats_fields']/lst[@name='k']\"\n            // ...but be empty \n            , \"count(\" + kpre + \"*)=0\"\n            );\n\n    double sum = 0;\n    double sumOfSquares = 0;\n    final int count = 20;\n    for (int i = 0; i < count; i++) {\n      assertU(adoc(\"id\", String.valueOf(i), \"a_f\", \"2.3\", \"b_f\", \"9.7\", \"a_i\",\n          String.valueOf(i % 10), \"foo_t\", \"how now brown cow\"));\n      tdigest.add(i % 10);\n      sum += i % 10;\n      sumOfSquares += (i % 10) * (i % 10);\n    }\n   \n    assertU(commit());\n    \n    ByteBuffer buf = ByteBuffer.allocate(tdigest.smallByteSize());\n    tdigest.asSmallBytes(buf);\n    EnumSet<Stat> allStats = EnumSet.allOf(Stat.class);\n    \n    Map<Stat,String> expectedStats = new HashMap<>();\n    expectedStats.put(Stat.min, \"0.0\");\n    expectedStats.put(Stat.max, \"9.0\");\n    expectedStats.put(Stat.missing, \"0\");\n    expectedStats.put(Stat.sum, String.valueOf(sum));\n    expectedStats.put(Stat.count, String.valueOf(count));\n    expectedStats.put(Stat.mean, String.valueOf(sum / count));\n    expectedStats.put(Stat.sumOfSquares, String.valueOf(sumOfSquares));\n    expectedStats.put(Stat.stddev, String.valueOf(Math.sqrt(((count * sumOfSquares) - (sum * sum))/ (20 * (count - 1.0D)))));\n    expectedStats.put(Stat.calcdistinct, \"10\");\n    // NOTE: per shard expected value\n    expectedStats.put(Stat.percentiles, Base64.byteArrayToBase64(buf.array(), 0, buf.array().length));\n    \n    Map<Stat,String> expectedType = new HashMap<>();\n    expectedType.put(Stat.min, \"double\");\n    expectedType.put(Stat.max, \"double\");\n    expectedType.put(Stat.missing, \"long\");\n    expectedType.put(Stat.sum, \"double\");\n    expectedType.put(Stat.count, \"long\");\n    expectedType.put(Stat.mean, \"double\");\n    expectedType.put(Stat.sumOfSquares, \"double\");\n    expectedType.put(Stat.stddev, \"double\");\n    expectedType.put(Stat.calcdistinct, \"long\");\n    expectedType.put(Stat.percentiles, \"str\");\n   \n    Map<Stat,String> localParasInput = new HashMap<>();\n    localParasInput.put(Stat.min, \"true\");\n    localParasInput.put(Stat.max, \"true\");\n    localParasInput.put(Stat.missing, \"true\");\n    localParasInput.put(Stat.sum, \"true\");\n    localParasInput.put(Stat.count, \"true\");\n    localParasInput.put(Stat.mean, \"true\");\n    localParasInput.put(Stat.sumOfSquares, \"true\");\n    localParasInput.put(Stat.stddev, \"true\");\n    localParasInput.put(Stat.calcdistinct, \"true\");\n    localParasInput.put(Stat.percentiles, \"'90, 99'\");\n\n   // canary in the coal mine\n   assertEquals(\"size of expectedStats doesn't match all known stats; \" + \n                \"enum was updated w/o updating test?\",\n                expectedStats.size(), allStats.size());\n   assertEquals(\"size of expectedType doesn't match all known stats; \" + \n                \"enum was updated w/o updating test?\",\n                expectedType.size(), allStats.size());\n\n   // whitebox test: explicitly ask for isShard=true with an individual stat\n   for (Stat stat : expectedStats.keySet()) {\n     EnumSet<Stat> distribDeps = stat.getDistribDeps();\n\n     StringBuilder exclude = new StringBuilder();\n     List<String> testParas = new ArrayList<String>(distribDeps.size() + 2);\n     int calcdistinctFudge = 0;\n\n     for (Stat perShardStat : distribDeps ){\n       String key = perShardStat.toString();\n       if (perShardStat.equals(Stat.calcdistinct)) {\n         // this abomination breaks all the rules - uses a diff response key and triggers\n         // the additional \"distinctValues\" stat\n         key = \"countDistinct\";\n         calcdistinctFudge++;\n         testParas.add(\"count(\" + kpre + \"arr[@name='distinctValues']/*)=10\");\n       }\n       testParas.add(kpre + expectedType.get(perShardStat) + \n                     \"[@name='\" + key + \"'][.='\" + expectedStats.get(perShardStat) + \"']\");\n       // even if we go out of our way to exclude the dependent stats, \n       // the shard should return them since they are a dependency for the requested stat\n       if (!stat.equals(Stat.percentiles)){\n         exclude.append(perShardStat + \"=false \");\n       }\n     }\n     testParas.add(\"count(\" + kpre + \"*)=\" + (distribDeps.size() + calcdistinctFudge));\n\n     assertQ(\"ask for only \"+stat+\", with isShard=true, and expect only deps: \" + distribDeps,\n             req(\"q\", \"*:*\", \"isShard\", \"true\", \"stats\", \"true\", \n                 \"stats.field\", \"{!key=k \" + exclude + stat +\"=\" + localParasInput.get(stat) + \"}a_i\")\n             , testParas.toArray(new String[testParas.size()])\n             );\n   }\n   \n   // test all the possible combinations (of all possible sizes) of stats params\n   for (int numParams = 1; numParams <= allStats.size(); numParams++) {\n     for (EnumSet<Stat> set : new StatSetCombinations(numParams, allStats)) {\n\n       // EnumSets use natural ordering, we want to randomize the order of the params\n       List<Stat> combo = new ArrayList<Stat>(set);\n       Collections.shuffle(combo, random());\n\n       StringBuilder paras = new StringBuilder(\"{!key=k \");\n       List<String> testParas = new ArrayList<String>(numParams + 2);\n\n       int calcdistinctFudge = 0;\n       for (Stat stat : combo) {\n         String key = stat.toString();\n         if (stat.equals(Stat.calcdistinct)) {\n           // this abomination breaks all the rules - uses a diff response key and triggers\n           // the additional \"distinctValues\" stat\n           key = \"countDistinct\";\n           calcdistinctFudge++; \n           testParas.add(\"count(\" + kpre + \"arr[@name='distinctValues']/*)=10\");\n         }\n         paras.append(stat + \"=\" + localParasInput.get(stat)+ \" \");\n         \n         if (!stat.equals(Stat.percentiles)){\n           testParas.add(kpre + expectedType.get(stat) + \"[@name='\" + key + \"'][.='\" + expectedStats.get(stat) + \"']\");\n         } else {\n           testParas.add(\"count(\" + kpre + \"lst[@name='percentiles']/*)=2\");\n           String p90 = \"\" + tdigest.quantile(0.90D);\n           String p99 = \"\" + tdigest.quantile(0.99D);\n           testParas.add(kpre + \"lst[@name='percentiles']/double[@name='90.0'][.=\"+p90+\"]\");\n           testParas.add(kpre + \"lst[@name='percentiles']/double[@name='99.0'][.=\"+p99+\"]\");\n         }\n       }\n\n       paras.append(\"}a_i\");\n       testParas.add(\"count(\" + kpre + \"*)=\" + (combo.size() + calcdistinctFudge));\n\n       assertQ(\"ask for an get only: \"+ combo,\n               req(\"q\",\"*:*\", \"stats\", \"true\",\n                   \"stats.field\", paras.toString())\n               , testParas.toArray(new String[testParas.size()])\n               );\n     }\n   }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4a4e2c829188fb99886a64558664d79c9ac0fdf1","date":1431021538,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/component/StatsComponentTest#testIndividualStatLocalParams().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/component/StatsComponentTest#testIndividualStatLocalParams().mjava","sourceNew":"  public void testIndividualStatLocalParams() throws Exception {\n    final String kpre = ExpectedStat.KPRE;\n    \n    assertU(adoc(\"id\", \"1\", \"a_f\", \"2.3\", \"b_f\", \"9.7\", \"a_i\", \"9\", \"foo_t\", \"how now brown cow\"));\n    assertU(commit());\n\n    SolrCore core = h.getCore();\n    SchemaField field = core.getLatestSchema().getField(\"a_i\");\n    HllOptions hllOpts = HllOptions.parseHllOptions(params(\"cardinality\",\"true\"), field);\n    \n    HLL hll = hllOpts.newHLL();\n    HashFunction hasher = hllOpts.getHasher();\n\n    AVLTreeDigest tdigest = new AVLTreeDigest(100);\n    \n    // some quick sanity check assertions...\n    // trivial check that we only get the exact 2 we ask for\n    assertQ(\"ask for and get only 2 stats\",\n            req(\"q\",\"*:*\", \"stats\", \"true\",\n                \"stats.field\", \"{!key=k mean=true min=true}a_i\")\n            , kpre + \"double[@name='mean'][.='9.0']\"\n            , kpre + \"double[@name='min'][.='9.0']\"\n            , \"count(\" + kpre + \"*)=2\"\n            );\n    \n    // for stats that are true/false, sanity check false does it's job\n    assertQ(\"min=true & max=false: only min should come back\",\n            req(\"q\",\"*:*\", \"stats\", \"true\",\n                \"stats.field\", \"{!key=k max=false min=true}a_i\")\n            , kpre + \"double[@name='min'][.='9.0']\"\n            , \"count(\" + kpre + \"*)=1\"\n            );\n    assertQ(\"min=false: localparam stat means ignore default set, \"+\n            \"but since only local param is false no stats should be returned\",\n            req(\"q\",\"*:*\", \"stats\", \"true\",\n                \"stats.field\", \"{!key=k min=false}a_i\")\n            // section of stats for this field should exist ...\n            , XPRE + \"lst[@name='stats_fields']/lst[@name='k']\"\n            // ...but be empty \n            , \"count(\" + kpre + \"*)=0\"\n            );\n    \n    double sum = 0;\n    double sumOfSquares = 0;\n    final int count = 20;\n    for (int i = 0; i < count; i++) {\n      int a_i = i % 10;\n      assertU(adoc(\"id\", String.valueOf(i), \"a_f\", \"2.3\", \"b_f\", \"9.7\", \"a_i\",\n                   String.valueOf(a_i), \"foo_t\", \"how now brown cow\"));\n      tdigest.add(a_i);\n      hll.addRaw(hasher.hashInt(a_i).asLong());\n      sum += a_i;\n      sumOfSquares += (a_i) * (a_i);\n    }\n    double stddev = Math.sqrt(((count * sumOfSquares) - (sum * sum))/ (20 * (count - 1.0D)));\n    \n    assertU(commit());\n    \n    ByteBuffer tdigestBuf = ByteBuffer.allocate(tdigest.smallByteSize());\n    tdigest.asSmallBytes(tdigestBuf);\n    byte[] hllBytes = hll.toBytes();\n\n    EnumSet<Stat> allStats = EnumSet.allOf(Stat.class);\n    \n    final List<ExpectedStat> expected = new ArrayList<ExpectedStat>(allStats.size());\n    ExpectedStat.createSimple(Stat.min, \"true\", \"double\", \"0.0\");\n    ExpectedStat.createSimple(Stat.max, \"true\", \"double\", \"9.0\");\n    ExpectedStat.createSimple(Stat.missing, \"true\", \"long\", \"0\");\n    ExpectedStat.createSimple(Stat.sum, \"true\", \"double\", String.valueOf(sum));\n    ExpectedStat.createSimple(Stat.count, \"true\", \"long\", String.valueOf(count));\n    ExpectedStat.createSimple(Stat.mean, \"true\", \"double\", String.valueOf(sum / count));\n    ExpectedStat.createSimple(Stat.sumOfSquares, \"true\", \"double\", String.valueOf(sumOfSquares));\n    ExpectedStat.createSimple(Stat.stddev, \"true\", \"double\", String.valueOf(stddev));\n    final String countDistinctXpath = kpre + \"long[@name='countDistinct'][.='10']\";\n    ExpectedStat.create(Stat.calcdistinct, \"true\", 2,\n                        Arrays.asList(\"count(\" + kpre + \"arr[@name='distinctValues']/*)=10\",\n                                      countDistinctXpath),\n                        Collections.singletonList(countDistinctXpath));\n    final String percentileShardXpath = kpre + \"str[@name='percentiles'][.='\" \n      + Base64.byteArrayToBase64(tdigestBuf.array(), 0, tdigestBuf.array().length) + \"']\";\n    final String p90 = \"\" + tdigest.quantile(0.90D);\n    final String p99 = \"\" + tdigest.quantile(0.99D);\n    ExpectedStat.create(Stat.percentiles, \"'90, 99'\", 1,\n                        Collections.singletonList(percentileShardXpath),\n                        Arrays.asList(\"count(\" + kpre + \"lst[@name='percentiles']/*)=2\",\n                                      kpre + \"lst[@name='percentiles']/double[@name='90.0'][.=\"+p90+\"]\",\n                                      kpre + \"lst[@name='percentiles']/double[@name='99.0'][.=\"+p99+\"]\"));\n    final String cardinalityShardXpath = kpre + \"str[@name='cardinality'][.='\" \n      + Base64.byteArrayToBase64(hllBytes, 0, hllBytes.length) + \"']\";\n    final String cardinalityXpath = kpre + \"long[@name='cardinality'][.='10']\"; \n    ExpectedStat.create(Stat.cardinality, \"true\", 1,\n                        Collections.singletonList(cardinalityShardXpath),\n                        Collections.singletonList(cardinalityXpath));\n\n    // canary in the coal mine\n    assertEquals(\"num of ExpectedStat doesn't match all known stats; \" + \n                 \"enum was updated w/o updating test?\",\n                 ExpectedStat.ALL.size(), allStats.size());\n    \n    // whitebox test: explicitly ask for isShard=true with each individual stat\n    for (ExpectedStat expect : ExpectedStat.ALL.values()) {\n      Stat stat = expect.stat;\n\n      StringBuilder exclude = new StringBuilder();\n      List<String> testXpaths = new ArrayList<String>(5 + expect.perShardXpaths.size());\n      testXpaths.addAll(expect.perShardXpaths);\n\n      int numKeysExpected = 0;\n      EnumSet<Stat> distribDeps = stat.getDistribDeps();\n      for (Stat perShardDep : distribDeps) {\n        numKeysExpected += ExpectedStat.ALL.get(perShardDep).numResponseKeys;\n\n        // even if we go out of our way to exclude the dependent stats, \n        // the shard should return them since they are a dependency for the requested stat\n        if (!stat.equals(perShardDep)){\n          // NOTE: this only works because all the cases where there are distribDeps\n          // beyond a self dependency are simple true/false options\n          exclude.append(perShardDep + \"=false \");\n        }\n      }\n      // we don't want to find anything we aren't expecting\n      testXpaths.add(\"count(\" + kpre + \"*)=\" + numKeysExpected);\n\n      assertQ(\"ask for only \"+stat+\", with isShard=true, and expect only deps: \" + distribDeps,\n              req(\"q\", \"*:*\", \"isShard\", \"true\", \"stats\", \"true\", \n                  \"stats.field\", \"{!key=k \" + exclude + stat +\"=\" + expect.input + \"}a_i\")\n              , testXpaths.toArray(new String[testXpaths.size()])\n              );\n    }\n    \n    // test all the possible combinations (of all possible sizes) of stats params\n    for (int numParams = 1; numParams <= allStats.size(); numParams++) {\n      for (EnumSet<Stat> set : new StatSetCombinations(numParams, allStats)) {\n        // EnumSets use natural ordering, we want to randomize the order of the params\n        List<Stat> combo = new ArrayList<Stat>(set);\n        Collections.shuffle(combo, random());\n        \n        StringBuilder paras = new StringBuilder(\"{!key=k \");\n        List<String> testXpaths = new ArrayList<String>(numParams + 5);\n\n        int numKeysExpected = 0;\n        for (Stat stat : combo) {\n          ExpectedStat expect = ExpectedStat.ALL.get(stat);\n\n          paras.append(stat + \"=\" + expect.input + \" \");\n\n          numKeysExpected += expect.numResponseKeys;\n          testXpaths.addAll(expect.finalXpaths);\n        }\n\n        paras.append(\"}a_i\");\n\n        // we don't want to find anything we aren't expecting\n        testXpaths.add(\"count(\" + kpre + \"*)=\" + numKeysExpected);\n\n        assertQ(\"ask for and get only: \"+ combo,\n                req(\"q\",\"*:*\", \"stats\", \"true\",\n                    \"stats.field\", paras.toString())\n                , testXpaths.toArray(new String[testXpaths.size()])\n                );\n      }\n    }\n  }\n\n","sourceOld":"  public void testIndividualStatLocalParams() throws Exception {\n    final String kpre = XPRE + \"lst[@name='stats_fields']/lst[@name='k']/\";\n    \n    assertU(adoc(\"id\", \"1\", \"a_f\", \"2.3\", \"b_f\", \"9.7\", \"a_i\", \"9\", \"foo_t\", \"how now brown cow\"));\n    assertU(commit());\n    \n    AVLTreeDigest tdigest = new AVLTreeDigest(100);\n    \n    // some quick sanity check assertions...\n    // trivial check that we only get the exact 2 we ask for\n    assertQ(\"ask for and get only 2 stats\",\n            req(\"q\",\"*:*\", \"stats\", \"true\",\n                \"stats.field\", \"{!key=k mean=true min=true}a_i\")\n            , kpre + \"double[@name='mean'][.='9.0']\"\n            , kpre + \"double[@name='min'][.='9.0']\"\n            , \"count(\" + kpre + \"*)=2\"\n            );\n\n    // for stats that are true/false, sanity check false does it's job\n    assertQ(\"min=true & max=false: only min should come back\",\n            req(\"q\",\"*:*\", \"stats\", \"true\",\n                \"stats.field\", \"{!key=k max=false min=true}a_i\")\n            , kpre + \"double[@name='min'][.='9.0']\"\n            , \"count(\" + kpre + \"*)=1\"\n            );\n    assertQ(\"min=false: localparam stat means ignore default set, \"+\n            \"but since only local param is false no stats should be returned\",\n            req(\"q\",\"*:*\", \"stats\", \"true\",\n                \"stats.field\", \"{!key=k min=false}a_i\")\n            // section of stats for this field should exist ...\n            , XPRE + \"lst[@name='stats_fields']/lst[@name='k']\"\n            // ...but be empty \n            , \"count(\" + kpre + \"*)=0\"\n            );\n\n    double sum = 0;\n    double sumOfSquares = 0;\n    final int count = 20;\n    for (int i = 0; i < count; i++) {\n      assertU(adoc(\"id\", String.valueOf(i), \"a_f\", \"2.3\", \"b_f\", \"9.7\", \"a_i\",\n          String.valueOf(i % 10), \"foo_t\", \"how now brown cow\"));\n      tdigest.add(i % 10);\n      sum += i % 10;\n      sumOfSquares += (i % 10) * (i % 10);\n    }\n   \n    assertU(commit());\n    \n    ByteBuffer buf = ByteBuffer.allocate(tdigest.smallByteSize());\n    tdigest.asSmallBytes(buf);\n    EnumSet<Stat> allStats = EnumSet.allOf(Stat.class);\n    \n    Map<Stat,String> expectedStats = new HashMap<>();\n    expectedStats.put(Stat.min, \"0.0\");\n    expectedStats.put(Stat.max, \"9.0\");\n    expectedStats.put(Stat.missing, \"0\");\n    expectedStats.put(Stat.sum, String.valueOf(sum));\n    expectedStats.put(Stat.count, String.valueOf(count));\n    expectedStats.put(Stat.mean, String.valueOf(sum / count));\n    expectedStats.put(Stat.sumOfSquares, String.valueOf(sumOfSquares));\n    expectedStats.put(Stat.stddev, String.valueOf(Math.sqrt(((count * sumOfSquares) - (sum * sum))/ (20 * (count - 1.0D)))));\n    expectedStats.put(Stat.calcdistinct, \"10\");\n    // NOTE: per shard expected value\n    expectedStats.put(Stat.percentiles, Base64.byteArrayToBase64(buf.array(), 0, buf.array().length));\n    \n    Map<Stat,String> expectedType = new HashMap<>();\n    expectedType.put(Stat.min, \"double\");\n    expectedType.put(Stat.max, \"double\");\n    expectedType.put(Stat.missing, \"long\");\n    expectedType.put(Stat.sum, \"double\");\n    expectedType.put(Stat.count, \"long\");\n    expectedType.put(Stat.mean, \"double\");\n    expectedType.put(Stat.sumOfSquares, \"double\");\n    expectedType.put(Stat.stddev, \"double\");\n    expectedType.put(Stat.calcdistinct, \"long\");\n    expectedType.put(Stat.percentiles, \"str\");\n   \n    Map<Stat,String> localParasInput = new HashMap<>();\n    localParasInput.put(Stat.min, \"true\");\n    localParasInput.put(Stat.max, \"true\");\n    localParasInput.put(Stat.missing, \"true\");\n    localParasInput.put(Stat.sum, \"true\");\n    localParasInput.put(Stat.count, \"true\");\n    localParasInput.put(Stat.mean, \"true\");\n    localParasInput.put(Stat.sumOfSquares, \"true\");\n    localParasInput.put(Stat.stddev, \"true\");\n    localParasInput.put(Stat.calcdistinct, \"true\");\n    localParasInput.put(Stat.percentiles, \"'90, 99'\");\n\n   // canary in the coal mine\n   assertEquals(\"size of expectedStats doesn't match all known stats; \" + \n                \"enum was updated w/o updating test?\",\n                expectedStats.size(), allStats.size());\n   assertEquals(\"size of expectedType doesn't match all known stats; \" + \n                \"enum was updated w/o updating test?\",\n                expectedType.size(), allStats.size());\n\n   // whitebox test: explicitly ask for isShard=true with an individual stat\n   for (Stat stat : expectedStats.keySet()) {\n     EnumSet<Stat> distribDeps = stat.getDistribDeps();\n\n     StringBuilder exclude = new StringBuilder();\n     List<String> testParas = new ArrayList<String>(distribDeps.size() + 2);\n     int calcdistinctFudge = 0;\n\n     for (Stat perShardStat : distribDeps ){\n       String key = perShardStat.toString();\n       if (perShardStat.equals(Stat.calcdistinct)) {\n         // this abomination breaks all the rules - uses a diff response key and triggers\n         // the additional \"distinctValues\" stat\n         key = \"countDistinct\";\n         calcdistinctFudge++;\n         testParas.add(\"count(\" + kpre + \"arr[@name='distinctValues']/*)=10\");\n       }\n       testParas.add(kpre + expectedType.get(perShardStat) + \n                     \"[@name='\" + key + \"'][.='\" + expectedStats.get(perShardStat) + \"']\");\n       // even if we go out of our way to exclude the dependent stats, \n       // the shard should return them since they are a dependency for the requested stat\n       if (!stat.equals(Stat.percentiles)){\n         exclude.append(perShardStat + \"=false \");\n       }\n     }\n     testParas.add(\"count(\" + kpre + \"*)=\" + (distribDeps.size() + calcdistinctFudge));\n\n     assertQ(\"ask for only \"+stat+\", with isShard=true, and expect only deps: \" + distribDeps,\n             req(\"q\", \"*:*\", \"isShard\", \"true\", \"stats\", \"true\", \n                 \"stats.field\", \"{!key=k \" + exclude + stat +\"=\" + localParasInput.get(stat) + \"}a_i\")\n             , testParas.toArray(new String[testParas.size()])\n             );\n   }\n   \n   // test all the possible combinations (of all possible sizes) of stats params\n   for (int numParams = 1; numParams <= allStats.size(); numParams++) {\n     for (EnumSet<Stat> set : new StatSetCombinations(numParams, allStats)) {\n\n       // EnumSets use natural ordering, we want to randomize the order of the params\n       List<Stat> combo = new ArrayList<Stat>(set);\n       Collections.shuffle(combo, random());\n\n       StringBuilder paras = new StringBuilder(\"{!key=k \");\n       List<String> testParas = new ArrayList<String>(numParams + 2);\n\n       int calcdistinctFudge = 0;\n       for (Stat stat : combo) {\n         String key = stat.toString();\n         if (stat.equals(Stat.calcdistinct)) {\n           // this abomination breaks all the rules - uses a diff response key and triggers\n           // the additional \"distinctValues\" stat\n           key = \"countDistinct\";\n           calcdistinctFudge++; \n           testParas.add(\"count(\" + kpre + \"arr[@name='distinctValues']/*)=10\");\n         }\n         paras.append(stat + \"=\" + localParasInput.get(stat)+ \" \");\n         \n         if (!stat.equals(Stat.percentiles)){\n           testParas.add(kpre + expectedType.get(stat) + \"[@name='\" + key + \"'][.='\" + expectedStats.get(stat) + \"']\");\n         } else {\n           testParas.add(\"count(\" + kpre + \"lst[@name='percentiles']/*)=2\");\n           String p90 = \"\" + tdigest.quantile(0.90D);\n           String p99 = \"\" + tdigest.quantile(0.99D);\n           testParas.add(kpre + \"lst[@name='percentiles']/double[@name='90.0'][.=\"+p90+\"]\");\n           testParas.add(kpre + \"lst[@name='percentiles']/double[@name='99.0'][.=\"+p99+\"]\");\n         }\n       }\n\n       paras.append(\"}a_i\");\n       testParas.add(\"count(\" + kpre + \"*)=\" + (combo.size() + calcdistinctFudge));\n\n       assertQ(\"ask for an get only: \"+ combo,\n               req(\"q\",\"*:*\", \"stats\", \"true\",\n                   \"stats.field\", paras.toString())\n               , testParas.toArray(new String[testParas.size()])\n               );\n     }\n   }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e7062fc1cf235b04a88adfc21dc68e040c82561","date":1431110643,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/component/StatsComponentTest#testIndividualStatLocalParams().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/component/StatsComponentTest#testIndividualStatLocalParams().mjava","sourceNew":"  public void testIndividualStatLocalParams() throws Exception {\n    final String kpre = ExpectedStat.KPRE;\n    \n    assertU(adoc(\"id\", \"1\", \"a_f\", \"2.3\", \"b_f\", \"9.7\", \"a_i\", \"9\", \"foo_t\", \"how now brown cow\"));\n    assertU(commit());\n\n    SolrCore core = h.getCore();\n    SchemaField field = core.getLatestSchema().getField(\"a_i\");\n    HllOptions hllOpts = HllOptions.parseHllOptions(params(\"cardinality\",\"true\"), field);\n    \n    HLL hll = hllOpts.newHLL();\n    HashFunction hasher = hllOpts.getHasher();\n\n    AVLTreeDigest tdigest = new AVLTreeDigest(100);\n    \n    // some quick sanity check assertions...\n    // trivial check that we only get the exact 2 we ask for\n    assertQ(\"ask for and get only 2 stats\",\n            req(\"q\",\"*:*\", \"stats\", \"true\",\n                \"stats.field\", \"{!key=k mean=true min=true}a_i\")\n            , kpre + \"double[@name='mean'][.='9.0']\"\n            , kpre + \"double[@name='min'][.='9.0']\"\n            , \"count(\" + kpre + \"*)=2\"\n            );\n    \n    // for stats that are true/false, sanity check false does it's job\n    assertQ(\"min=true & max=false: only min should come back\",\n            req(\"q\",\"*:*\", \"stats\", \"true\",\n                \"stats.field\", \"{!key=k max=false min=true}a_i\")\n            , kpre + \"double[@name='min'][.='9.0']\"\n            , \"count(\" + kpre + \"*)=1\"\n            );\n    assertQ(\"min=false: localparam stat means ignore default set, \"+\n            \"but since only local param is false no stats should be returned\",\n            req(\"q\",\"*:*\", \"stats\", \"true\",\n                \"stats.field\", \"{!key=k min=false}a_i\")\n            // section of stats for this field should exist ...\n            , XPRE + \"lst[@name='stats_fields']/lst[@name='k']\"\n            // ...but be empty \n            , \"count(\" + kpre + \"*)=0\"\n            );\n    \n    double sum = 0;\n    double sumOfSquares = 0;\n    final int count = 20;\n    for (int i = 0; i < count; i++) {\n      int a_i = i % 10;\n      assertU(adoc(\"id\", String.valueOf(i), \"a_f\", \"2.3\", \"b_f\", \"9.7\", \"a_i\",\n                   String.valueOf(a_i), \"foo_t\", \"how now brown cow\"));\n      tdigest.add(a_i);\n      hll.addRaw(hasher.hashInt(a_i).asLong());\n      sum += a_i;\n      sumOfSquares += (a_i) * (a_i);\n    }\n    double stddev = Math.sqrt(((count * sumOfSquares) - (sum * sum))/ (20 * (count - 1.0D)));\n    \n    assertU(commit());\n    \n    ByteBuffer tdigestBuf = ByteBuffer.allocate(tdigest.smallByteSize());\n    tdigest.asSmallBytes(tdigestBuf);\n    byte[] hllBytes = hll.toBytes();\n\n    EnumSet<Stat> allStats = EnumSet.allOf(Stat.class);\n    \n    final List<ExpectedStat> expected = new ArrayList<ExpectedStat>(allStats.size());\n    ExpectedStat.createSimple(Stat.min, \"true\", \"double\", \"0.0\");\n    ExpectedStat.createSimple(Stat.max, \"true\", \"double\", \"9.0\");\n    ExpectedStat.createSimple(Stat.missing, \"true\", \"long\", \"0\");\n    ExpectedStat.createSimple(Stat.sum, \"true\", \"double\", String.valueOf(sum));\n    ExpectedStat.createSimple(Stat.count, \"true\", \"long\", String.valueOf(count));\n    ExpectedStat.createSimple(Stat.mean, \"true\", \"double\", String.valueOf(sum / count));\n    ExpectedStat.createSimple(Stat.sumOfSquares, \"true\", \"double\", String.valueOf(sumOfSquares));\n    ExpectedStat.createSimple(Stat.stddev, \"true\", \"double\", String.valueOf(stddev));\n    final String distinctValsXpath = \"count(\" + kpre + \"arr[@name='distinctValues']/*)=10\";\n    ExpectedStat.create(Stat.distinctValues, \"true\", \n                        Collections.singletonList(distinctValsXpath),\n                        Collections.singletonList(distinctValsXpath));\n    ExpectedStat.createSimple(Stat.countDistinct, \"true\", \"long\", \"10\");\n    final String percentileShardXpath = kpre + \"str[@name='percentiles'][.='\" \n      + Base64.byteArrayToBase64(tdigestBuf.array(), 0, tdigestBuf.array().length) + \"']\";\n    final String p90 = \"\" + tdigest.quantile(0.90D);\n    final String p99 = \"\" + tdigest.quantile(0.99D);\n    ExpectedStat.create(Stat.percentiles, \"'90, 99'\",\n                        Collections.singletonList(percentileShardXpath),\n                        Arrays.asList(\"count(\" + kpre + \"lst[@name='percentiles']/*)=2\",\n                                      kpre + \"lst[@name='percentiles']/double[@name='90.0'][.=\"+p90+\"]\",\n                                      kpre + \"lst[@name='percentiles']/double[@name='99.0'][.=\"+p99+\"]\"));\n    final String cardinalityShardXpath = kpre + \"str[@name='cardinality'][.='\" \n      + Base64.byteArrayToBase64(hllBytes, 0, hllBytes.length) + \"']\";\n    final String cardinalityXpath = kpre + \"long[@name='cardinality'][.='10']\"; \n    ExpectedStat.create(Stat.cardinality, \"true\",\n                        Collections.singletonList(cardinalityShardXpath),\n                        Collections.singletonList(cardinalityXpath));\n\n    // canary in the coal mine\n    assertEquals(\"num of ExpectedStat doesn't match all known stats; \" + \n                 \"enum was updated w/o updating test?\",\n                 ExpectedStat.ALL.size(), allStats.size());\n    \n    // whitebox test: explicitly ask for isShard=true with each individual stat\n    for (ExpectedStat expect : ExpectedStat.ALL.values()) {\n      Stat stat = expect.stat;\n\n      StringBuilder exclude = new StringBuilder();\n      List<String> testXpaths = new ArrayList<String>(5 + expect.perShardXpaths.size());\n      testXpaths.addAll(expect.perShardXpaths);\n\n      int numKeysExpected = 0;\n      EnumSet<Stat> distribDeps = stat.getDistribDeps();\n      for (Stat perShardDep : distribDeps) {\n        numKeysExpected++;\n\n        // even if we go out of our way to exclude the dependent stats, \n        // the shard should return them since they are a dependency for the requested stat\n        if (!stat.equals(perShardDep)){\n          // NOTE: this only works because all the cases where there are distribDeps\n          // beyond a self dependency are simple true/false options\n          exclude.append(perShardDep + \"=false \");\n        }\n      }\n      // we don't want to find anything we aren't expecting\n      testXpaths.add(\"count(\" + kpre + \"*)=\" + numKeysExpected);\n\n      assertQ(\"ask for only \"+stat+\", with isShard=true, and expect only deps: \" + distribDeps,\n              req(\"q\", \"*:*\", \"isShard\", \"true\", \"stats\", \"true\", \n                  \"stats.field\", \"{!key=k \" + exclude + stat +\"=\" + expect.input + \"}a_i\")\n              , testXpaths.toArray(new String[testXpaths.size()])\n              );\n    }\n    \n    // test all the possible combinations (of all possible sizes) of stats params\n    for (int numParams = 1; numParams <= allStats.size(); numParams++) {\n      for (EnumSet<Stat> set : new StatSetCombinations(numParams, allStats)) {\n        // EnumSets use natural ordering, we want to randomize the order of the params\n        List<Stat> combo = new ArrayList<Stat>(set);\n        Collections.shuffle(combo, random());\n        \n        StringBuilder paras = new StringBuilder(\"{!key=k \");\n        List<String> testXpaths = new ArrayList<String>(numParams + 5);\n\n        int numKeysExpected = 0;\n        for (Stat stat : combo) {\n          ExpectedStat expect = ExpectedStat.ALL.get(stat);\n\n          paras.append(stat + \"=\" + expect.input + \" \");\n\n          numKeysExpected++;\n          testXpaths.addAll(expect.finalXpaths);\n        }\n\n        paras.append(\"}a_i\");\n\n        // we don't want to find anything we aren't expecting\n        testXpaths.add(\"count(\" + kpre + \"*)=\" + numKeysExpected);\n\n        assertQ(\"ask for and get only: \"+ combo,\n                req(\"q\",\"*:*\", \"stats\", \"true\",\n                    \"stats.field\", paras.toString())\n                , testXpaths.toArray(new String[testXpaths.size()])\n                );\n      }\n    }\n  }\n\n","sourceOld":"  public void testIndividualStatLocalParams() throws Exception {\n    final String kpre = ExpectedStat.KPRE;\n    \n    assertU(adoc(\"id\", \"1\", \"a_f\", \"2.3\", \"b_f\", \"9.7\", \"a_i\", \"9\", \"foo_t\", \"how now brown cow\"));\n    assertU(commit());\n\n    SolrCore core = h.getCore();\n    SchemaField field = core.getLatestSchema().getField(\"a_i\");\n    HllOptions hllOpts = HllOptions.parseHllOptions(params(\"cardinality\",\"true\"), field);\n    \n    HLL hll = hllOpts.newHLL();\n    HashFunction hasher = hllOpts.getHasher();\n\n    AVLTreeDigest tdigest = new AVLTreeDigest(100);\n    \n    // some quick sanity check assertions...\n    // trivial check that we only get the exact 2 we ask for\n    assertQ(\"ask for and get only 2 stats\",\n            req(\"q\",\"*:*\", \"stats\", \"true\",\n                \"stats.field\", \"{!key=k mean=true min=true}a_i\")\n            , kpre + \"double[@name='mean'][.='9.0']\"\n            , kpre + \"double[@name='min'][.='9.0']\"\n            , \"count(\" + kpre + \"*)=2\"\n            );\n    \n    // for stats that are true/false, sanity check false does it's job\n    assertQ(\"min=true & max=false: only min should come back\",\n            req(\"q\",\"*:*\", \"stats\", \"true\",\n                \"stats.field\", \"{!key=k max=false min=true}a_i\")\n            , kpre + \"double[@name='min'][.='9.0']\"\n            , \"count(\" + kpre + \"*)=1\"\n            );\n    assertQ(\"min=false: localparam stat means ignore default set, \"+\n            \"but since only local param is false no stats should be returned\",\n            req(\"q\",\"*:*\", \"stats\", \"true\",\n                \"stats.field\", \"{!key=k min=false}a_i\")\n            // section of stats for this field should exist ...\n            , XPRE + \"lst[@name='stats_fields']/lst[@name='k']\"\n            // ...but be empty \n            , \"count(\" + kpre + \"*)=0\"\n            );\n    \n    double sum = 0;\n    double sumOfSquares = 0;\n    final int count = 20;\n    for (int i = 0; i < count; i++) {\n      int a_i = i % 10;\n      assertU(adoc(\"id\", String.valueOf(i), \"a_f\", \"2.3\", \"b_f\", \"9.7\", \"a_i\",\n                   String.valueOf(a_i), \"foo_t\", \"how now brown cow\"));\n      tdigest.add(a_i);\n      hll.addRaw(hasher.hashInt(a_i).asLong());\n      sum += a_i;\n      sumOfSquares += (a_i) * (a_i);\n    }\n    double stddev = Math.sqrt(((count * sumOfSquares) - (sum * sum))/ (20 * (count - 1.0D)));\n    \n    assertU(commit());\n    \n    ByteBuffer tdigestBuf = ByteBuffer.allocate(tdigest.smallByteSize());\n    tdigest.asSmallBytes(tdigestBuf);\n    byte[] hllBytes = hll.toBytes();\n\n    EnumSet<Stat> allStats = EnumSet.allOf(Stat.class);\n    \n    final List<ExpectedStat> expected = new ArrayList<ExpectedStat>(allStats.size());\n    ExpectedStat.createSimple(Stat.min, \"true\", \"double\", \"0.0\");\n    ExpectedStat.createSimple(Stat.max, \"true\", \"double\", \"9.0\");\n    ExpectedStat.createSimple(Stat.missing, \"true\", \"long\", \"0\");\n    ExpectedStat.createSimple(Stat.sum, \"true\", \"double\", String.valueOf(sum));\n    ExpectedStat.createSimple(Stat.count, \"true\", \"long\", String.valueOf(count));\n    ExpectedStat.createSimple(Stat.mean, \"true\", \"double\", String.valueOf(sum / count));\n    ExpectedStat.createSimple(Stat.sumOfSquares, \"true\", \"double\", String.valueOf(sumOfSquares));\n    ExpectedStat.createSimple(Stat.stddev, \"true\", \"double\", String.valueOf(stddev));\n    final String countDistinctXpath = kpre + \"long[@name='countDistinct'][.='10']\";\n    ExpectedStat.create(Stat.calcdistinct, \"true\", 2,\n                        Arrays.asList(\"count(\" + kpre + \"arr[@name='distinctValues']/*)=10\",\n                                      countDistinctXpath),\n                        Collections.singletonList(countDistinctXpath));\n    final String percentileShardXpath = kpre + \"str[@name='percentiles'][.='\" \n      + Base64.byteArrayToBase64(tdigestBuf.array(), 0, tdigestBuf.array().length) + \"']\";\n    final String p90 = \"\" + tdigest.quantile(0.90D);\n    final String p99 = \"\" + tdigest.quantile(0.99D);\n    ExpectedStat.create(Stat.percentiles, \"'90, 99'\", 1,\n                        Collections.singletonList(percentileShardXpath),\n                        Arrays.asList(\"count(\" + kpre + \"lst[@name='percentiles']/*)=2\",\n                                      kpre + \"lst[@name='percentiles']/double[@name='90.0'][.=\"+p90+\"]\",\n                                      kpre + \"lst[@name='percentiles']/double[@name='99.0'][.=\"+p99+\"]\"));\n    final String cardinalityShardXpath = kpre + \"str[@name='cardinality'][.='\" \n      + Base64.byteArrayToBase64(hllBytes, 0, hllBytes.length) + \"']\";\n    final String cardinalityXpath = kpre + \"long[@name='cardinality'][.='10']\"; \n    ExpectedStat.create(Stat.cardinality, \"true\", 1,\n                        Collections.singletonList(cardinalityShardXpath),\n                        Collections.singletonList(cardinalityXpath));\n\n    // canary in the coal mine\n    assertEquals(\"num of ExpectedStat doesn't match all known stats; \" + \n                 \"enum was updated w/o updating test?\",\n                 ExpectedStat.ALL.size(), allStats.size());\n    \n    // whitebox test: explicitly ask for isShard=true with each individual stat\n    for (ExpectedStat expect : ExpectedStat.ALL.values()) {\n      Stat stat = expect.stat;\n\n      StringBuilder exclude = new StringBuilder();\n      List<String> testXpaths = new ArrayList<String>(5 + expect.perShardXpaths.size());\n      testXpaths.addAll(expect.perShardXpaths);\n\n      int numKeysExpected = 0;\n      EnumSet<Stat> distribDeps = stat.getDistribDeps();\n      for (Stat perShardDep : distribDeps) {\n        numKeysExpected += ExpectedStat.ALL.get(perShardDep).numResponseKeys;\n\n        // even if we go out of our way to exclude the dependent stats, \n        // the shard should return them since they are a dependency for the requested stat\n        if (!stat.equals(perShardDep)){\n          // NOTE: this only works because all the cases where there are distribDeps\n          // beyond a self dependency are simple true/false options\n          exclude.append(perShardDep + \"=false \");\n        }\n      }\n      // we don't want to find anything we aren't expecting\n      testXpaths.add(\"count(\" + kpre + \"*)=\" + numKeysExpected);\n\n      assertQ(\"ask for only \"+stat+\", with isShard=true, and expect only deps: \" + distribDeps,\n              req(\"q\", \"*:*\", \"isShard\", \"true\", \"stats\", \"true\", \n                  \"stats.field\", \"{!key=k \" + exclude + stat +\"=\" + expect.input + \"}a_i\")\n              , testXpaths.toArray(new String[testXpaths.size()])\n              );\n    }\n    \n    // test all the possible combinations (of all possible sizes) of stats params\n    for (int numParams = 1; numParams <= allStats.size(); numParams++) {\n      for (EnumSet<Stat> set : new StatSetCombinations(numParams, allStats)) {\n        // EnumSets use natural ordering, we want to randomize the order of the params\n        List<Stat> combo = new ArrayList<Stat>(set);\n        Collections.shuffle(combo, random());\n        \n        StringBuilder paras = new StringBuilder(\"{!key=k \");\n        List<String> testXpaths = new ArrayList<String>(numParams + 5);\n\n        int numKeysExpected = 0;\n        for (Stat stat : combo) {\n          ExpectedStat expect = ExpectedStat.ALL.get(stat);\n\n          paras.append(stat + \"=\" + expect.input + \" \");\n\n          numKeysExpected += expect.numResponseKeys;\n          testXpaths.addAll(expect.finalXpaths);\n        }\n\n        paras.append(\"}a_i\");\n\n        // we don't want to find anything we aren't expecting\n        testXpaths.add(\"count(\" + kpre + \"*)=\" + numKeysExpected);\n\n        assertQ(\"ask for and get only: \"+ combo,\n                req(\"q\",\"*:*\", \"stats\", \"true\",\n                    \"stats.field\", paras.toString())\n                , testXpaths.toArray(new String[testXpaths.size()])\n                );\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2e7062fc1cf235b04a88adfc21dc68e040c82561":["4a4e2c829188fb99886a64558664d79c9ac0fdf1"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1002283cfd29923d517db7c33e07bb54aac7acd4"],"4a4e2c829188fb99886a64558664d79c9ac0fdf1":["1002283cfd29923d517db7c33e07bb54aac7acd4"],"bcf9173fd8d1b123fb45b0c7d188d0c153fb609c":["d12bbc45d641864ffe03291bc30f178eb34e434c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d12bbc45d641864ffe03291bc30f178eb34e434c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1002283cfd29923d517db7c33e07bb54aac7acd4":["bcf9173fd8d1b123fb45b0c7d188d0c153fb609c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2e7062fc1cf235b04a88adfc21dc68e040c82561"]},"commit2Childs":{"2e7062fc1cf235b04a88adfc21dc68e040c82561":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"4a4e2c829188fb99886a64558664d79c9ac0fdf1":["2e7062fc1cf235b04a88adfc21dc68e040c82561"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","d12bbc45d641864ffe03291bc30f178eb34e434c"],"bcf9173fd8d1b123fb45b0c7d188d0c153fb609c":["1002283cfd29923d517db7c33e07bb54aac7acd4"],"d12bbc45d641864ffe03291bc30f178eb34e434c":["bcf9173fd8d1b123fb45b0c7d188d0c153fb609c"],"1002283cfd29923d517db7c33e07bb54aac7acd4":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","4a4e2c829188fb99886a64558664d79c9ac0fdf1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}