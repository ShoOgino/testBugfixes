{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#pickPole(Random,PlanetModel,List[GeoPoint]).mjava","commits":[{"id":"d0ae680950e0cfd56d7b4ea40918fee662023726","date":1460293099,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#pickPole(Random,PlanetModel,List[GeoPoint]).mjava","pathOld":"/dev/null","sourceNew":"  /** Pick a random pole that has a good chance of being inside the polygon described by the points.\n   * @param generator is the random number generator to use.\n   * @param planetModel is the planet model to use.\n   * @param points is the list of points available.\n   * @return the randomly-determined pole selection.\n   */\n  private static GeoPoint pickPole(final Random generator, final PlanetModel planetModel, final List<GeoPoint> points) {\n    final int pointIndex = generator.nextInt(points.size());\n    final GeoPoint closePoint = points.get(pointIndex);\n    // We pick a random angle and random arc distance, then generate a point based on closePoint\n    final double angle = generator.nextDouble() * Math.PI * 2.0 - Math.PI;\n    final double arcDistance = MAX_POLE_DISTANCE - generator.nextDouble() * MAX_POLE_DISTANCE;\n    // We come up with a unit circle (x,y,z) coordinate given the random angle and arc distance.  The point is centered around the positive x axis.\n    final double x = Math.cos(arcDistance);\n    final double sinArcDistance = Math.sin(arcDistance);\n    final double y = Math.cos(angle) * sinArcDistance;\n    final double z = Math.sin(angle) * sinArcDistance;\n    // Now, use closePoint for a rotation pole\n    final double sinLatitude = Math.sin(closePoint.getLatitude());\n    final double cosLatitude = Math.cos(closePoint.getLatitude());\n    final double sinLongitude = Math.sin(closePoint.getLongitude());\n    final double cosLongitude = Math.cos(closePoint.getLongitude());\n    // This transformation should take the point (1,0,0) and transform it to the closepoint's actual (x,y,z) coordinates.\n    // Coordinate rotation formula:\n    // x1 = x0 cos T - y0 sin T\n    // y1 = x0 sin T + y0 cos T\n    // We're in essence undoing the following transformation (from GeoPolygonFactory):\n    // x1 = x0 cos az + y0 sin az\n    // y1 = - x0 sin az + y0 cos az\n    // z1 = z0\n    // x2 = x1 cos al + z1 sin al\n    // y2 = y1\n    // z2 = - x1 sin al + z1 cos al\n    // So, we reverse the order of the transformations, AND we transform backwards.\n    // Transforming backwards means using these identities: sin(-angle) = -sin(angle), cos(-angle) = cos(angle)\n    // So:\n    // x1 = x0 cos al - z0 sin al\n    // y1 = y0\n    // z1 = x0 sin al + z0 cos al\n    // x2 = x1 cos az - y1 sin az\n    // y2 = x1 sin az + y1 cos az\n    // z2 = z1\n    final double x1 = x * cosLatitude - z * sinLatitude;\n    final double y1 = y;\n    final double z1 = x * sinLatitude + z * cosLatitude;\n    final double x2 = x1 * cosLongitude - y1 * sinLongitude;\n    final double y2 = x1 * sinLongitude + y1 * cosLongitude;\n    final double z2 = z1;\n    // Finally, scale to put the point on the surface\n    return planetModel.createSurfacePoint(x2, y2, z2);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c4ea54ac6c0e876359818ff9634e6c179769c1e","date":1461111125,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#pickPole(Random,PlanetModel,List[GeoPoint]).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#pickPole(Random,PlanetModel,List[GeoPoint]).mjava","sourceNew":"  /** Pick a random pole that has a good chance of being inside the polygon described by the points.\n   * @param generator is the random number generator to use.\n   * @param planetModel is the planet model to use.\n   * @param points is the list of points available.\n   * @return the randomly-determined pole selection.\n   */\n  private static GeoPoint pickPole(final Random generator, final PlanetModel planetModel, final List<GeoPoint> points) {\n    final int pointIndex = generator.nextInt(points.size());\n    final GeoPoint closePoint = points.get(pointIndex);\n    // We pick a random angle and random arc distance, then generate a point based on closePoint\n    final double angle = generator.nextDouble() * Math.PI * 2.0 - Math.PI;\n    final double maxArcDistance = points.get(0).arcDistance(points.get(1));\n    final double arcDistance = maxArcDistance - generator.nextDouble() * maxArcDistance;\n    // We come up with a unit circle (x,y,z) coordinate given the random angle and arc distance.  The point is centered around the positive x axis.\n    final double x = Math.cos(arcDistance);\n    final double sinArcDistance = Math.sin(arcDistance);\n    final double y = Math.cos(angle) * sinArcDistance;\n    final double z = Math.sin(angle) * sinArcDistance;\n    // Now, use closePoint for a rotation pole\n    final double sinLatitude = Math.sin(closePoint.getLatitude());\n    final double cosLatitude = Math.cos(closePoint.getLatitude());\n    final double sinLongitude = Math.sin(closePoint.getLongitude());\n    final double cosLongitude = Math.cos(closePoint.getLongitude());\n    // This transformation should take the point (1,0,0) and transform it to the closepoint's actual (x,y,z) coordinates.\n    // Coordinate rotation formula:\n    // x1 = x0 cos T - y0 sin T\n    // y1 = x0 sin T + y0 cos T\n    // We're in essence undoing the following transformation (from GeoPolygonFactory):\n    // x1 = x0 cos az + y0 sin az\n    // y1 = - x0 sin az + y0 cos az\n    // z1 = z0\n    // x2 = x1 cos al + z1 sin al\n    // y2 = y1\n    // z2 = - x1 sin al + z1 cos al\n    // So, we reverse the order of the transformations, AND we transform backwards.\n    // Transforming backwards means using these identities: sin(-angle) = -sin(angle), cos(-angle) = cos(angle)\n    // So:\n    // x1 = x0 cos al - z0 sin al\n    // y1 = y0\n    // z1 = x0 sin al + z0 cos al\n    // x2 = x1 cos az - y1 sin az\n    // y2 = x1 sin az + y1 cos az\n    // z2 = z1\n    final double x1 = x * cosLatitude - z * sinLatitude;\n    final double y1 = y;\n    final double z1 = x * sinLatitude + z * cosLatitude;\n    final double x2 = x1 * cosLongitude - y1 * sinLongitude;\n    final double y2 = x1 * sinLongitude + y1 * cosLongitude;\n    final double z2 = z1;\n    // Finally, scale to put the point on the surface\n    return planetModel.createSurfacePoint(x2, y2, z2);\n  }\n\n","sourceOld":"  /** Pick a random pole that has a good chance of being inside the polygon described by the points.\n   * @param generator is the random number generator to use.\n   * @param planetModel is the planet model to use.\n   * @param points is the list of points available.\n   * @return the randomly-determined pole selection.\n   */\n  private static GeoPoint pickPole(final Random generator, final PlanetModel planetModel, final List<GeoPoint> points) {\n    final int pointIndex = generator.nextInt(points.size());\n    final GeoPoint closePoint = points.get(pointIndex);\n    // We pick a random angle and random arc distance, then generate a point based on closePoint\n    final double angle = generator.nextDouble() * Math.PI * 2.0 - Math.PI;\n    final double arcDistance = MAX_POLE_DISTANCE - generator.nextDouble() * MAX_POLE_DISTANCE;\n    // We come up with a unit circle (x,y,z) coordinate given the random angle and arc distance.  The point is centered around the positive x axis.\n    final double x = Math.cos(arcDistance);\n    final double sinArcDistance = Math.sin(arcDistance);\n    final double y = Math.cos(angle) * sinArcDistance;\n    final double z = Math.sin(angle) * sinArcDistance;\n    // Now, use closePoint for a rotation pole\n    final double sinLatitude = Math.sin(closePoint.getLatitude());\n    final double cosLatitude = Math.cos(closePoint.getLatitude());\n    final double sinLongitude = Math.sin(closePoint.getLongitude());\n    final double cosLongitude = Math.cos(closePoint.getLongitude());\n    // This transformation should take the point (1,0,0) and transform it to the closepoint's actual (x,y,z) coordinates.\n    // Coordinate rotation formula:\n    // x1 = x0 cos T - y0 sin T\n    // y1 = x0 sin T + y0 cos T\n    // We're in essence undoing the following transformation (from GeoPolygonFactory):\n    // x1 = x0 cos az + y0 sin az\n    // y1 = - x0 sin az + y0 cos az\n    // z1 = z0\n    // x2 = x1 cos al + z1 sin al\n    // y2 = y1\n    // z2 = - x1 sin al + z1 cos al\n    // So, we reverse the order of the transformations, AND we transform backwards.\n    // Transforming backwards means using these identities: sin(-angle) = -sin(angle), cos(-angle) = cos(angle)\n    // So:\n    // x1 = x0 cos al - z0 sin al\n    // y1 = y0\n    // z1 = x0 sin al + z0 cos al\n    // x2 = x1 cos az - y1 sin az\n    // y2 = x1 sin az + y1 cos az\n    // z2 = z1\n    final double x1 = x * cosLatitude - z * sinLatitude;\n    final double y1 = y;\n    final double z1 = x * sinLatitude + z * cosLatitude;\n    final double x2 = x1 * cosLongitude - y1 * sinLongitude;\n    final double y2 = x1 * sinLongitude + y1 * cosLongitude;\n    final double z2 = z1;\n    // Finally, scale to put the point on the surface\n    return planetModel.createSurfacePoint(x2, y2, z2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b6c62df758561770fbfb93e3328392285f3f618","date":1462109700,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#pickPole(Random,PlanetModel,List[GeoPoint]).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#pickPole(Random,PlanetModel,List[GeoPoint]).mjava","sourceNew":"  /** Pick a random pole that has a good chance of being inside the polygon described by the points.\n   * @param generator is the random number generator to use.\n   * @param planetModel is the planet model to use.\n   * @param points is the list of points available.\n   * @return the randomly-determined pole selection.\n   */\n  private static GeoPoint pickPole(final Random generator, final PlanetModel planetModel, final List<GeoPoint> points) {\n    final int pointIndex = generator.nextInt(points.size());\n    final GeoPoint closePoint = points.get(pointIndex);\n    // We pick a random angle and random arc distance, then generate a point based on closePoint\n    final double angle = generator.nextDouble() * Math.PI * 2.0 - Math.PI;\n    double maxArcDistance = points.get(0).arcDistance(points.get(1));\n    double trialArcDistance = points.get(0).arcDistance(points.get(2));\n    if (trialArcDistance > maxArcDistance) {\n      maxArcDistance = trialArcDistance;\n    }\n    final double arcDistance = maxArcDistance - generator.nextDouble() * maxArcDistance;\n    // We come up with a unit circle (x,y,z) coordinate given the random angle and arc distance.  The point is centered around the positive x axis.\n    final double x = Math.cos(arcDistance);\n    final double sinArcDistance = Math.sin(arcDistance);\n    final double y = Math.cos(angle) * sinArcDistance;\n    final double z = Math.sin(angle) * sinArcDistance;\n    // Now, use closePoint for a rotation pole\n    final double sinLatitude = Math.sin(closePoint.getLatitude());\n    final double cosLatitude = Math.cos(closePoint.getLatitude());\n    final double sinLongitude = Math.sin(closePoint.getLongitude());\n    final double cosLongitude = Math.cos(closePoint.getLongitude());\n    // This transformation should take the point (1,0,0) and transform it to the closepoint's actual (x,y,z) coordinates.\n    // Coordinate rotation formula:\n    // x1 = x0 cos T - y0 sin T\n    // y1 = x0 sin T + y0 cos T\n    // We're in essence undoing the following transformation (from GeoPolygonFactory):\n    // x1 = x0 cos az + y0 sin az\n    // y1 = - x0 sin az + y0 cos az\n    // z1 = z0\n    // x2 = x1 cos al + z1 sin al\n    // y2 = y1\n    // z2 = - x1 sin al + z1 cos al\n    // So, we reverse the order of the transformations, AND we transform backwards.\n    // Transforming backwards means using these identities: sin(-angle) = -sin(angle), cos(-angle) = cos(angle)\n    // So:\n    // x1 = x0 cos al - z0 sin al\n    // y1 = y0\n    // z1 = x0 sin al + z0 cos al\n    // x2 = x1 cos az - y1 sin az\n    // y2 = x1 sin az + y1 cos az\n    // z2 = z1\n    final double x1 = x * cosLatitude - z * sinLatitude;\n    final double y1 = y;\n    final double z1 = x * sinLatitude + z * cosLatitude;\n    final double x2 = x1 * cosLongitude - y1 * sinLongitude;\n    final double y2 = x1 * sinLongitude + y1 * cosLongitude;\n    final double z2 = z1;\n    // Finally, scale to put the point on the surface\n    return planetModel.createSurfacePoint(x2, y2, z2);\n  }\n\n","sourceOld":"  /** Pick a random pole that has a good chance of being inside the polygon described by the points.\n   * @param generator is the random number generator to use.\n   * @param planetModel is the planet model to use.\n   * @param points is the list of points available.\n   * @return the randomly-determined pole selection.\n   */\n  private static GeoPoint pickPole(final Random generator, final PlanetModel planetModel, final List<GeoPoint> points) {\n    final int pointIndex = generator.nextInt(points.size());\n    final GeoPoint closePoint = points.get(pointIndex);\n    // We pick a random angle and random arc distance, then generate a point based on closePoint\n    final double angle = generator.nextDouble() * Math.PI * 2.0 - Math.PI;\n    final double maxArcDistance = points.get(0).arcDistance(points.get(1));\n    final double arcDistance = maxArcDistance - generator.nextDouble() * maxArcDistance;\n    // We come up with a unit circle (x,y,z) coordinate given the random angle and arc distance.  The point is centered around the positive x axis.\n    final double x = Math.cos(arcDistance);\n    final double sinArcDistance = Math.sin(arcDistance);\n    final double y = Math.cos(angle) * sinArcDistance;\n    final double z = Math.sin(angle) * sinArcDistance;\n    // Now, use closePoint for a rotation pole\n    final double sinLatitude = Math.sin(closePoint.getLatitude());\n    final double cosLatitude = Math.cos(closePoint.getLatitude());\n    final double sinLongitude = Math.sin(closePoint.getLongitude());\n    final double cosLongitude = Math.cos(closePoint.getLongitude());\n    // This transformation should take the point (1,0,0) and transform it to the closepoint's actual (x,y,z) coordinates.\n    // Coordinate rotation formula:\n    // x1 = x0 cos T - y0 sin T\n    // y1 = x0 sin T + y0 cos T\n    // We're in essence undoing the following transformation (from GeoPolygonFactory):\n    // x1 = x0 cos az + y0 sin az\n    // y1 = - x0 sin az + y0 cos az\n    // z1 = z0\n    // x2 = x1 cos al + z1 sin al\n    // y2 = y1\n    // z2 = - x1 sin al + z1 cos al\n    // So, we reverse the order of the transformations, AND we transform backwards.\n    // Transforming backwards means using these identities: sin(-angle) = -sin(angle), cos(-angle) = cos(angle)\n    // So:\n    // x1 = x0 cos al - z0 sin al\n    // y1 = y0\n    // z1 = x0 sin al + z0 cos al\n    // x2 = x1 cos az - y1 sin az\n    // y2 = x1 sin az + y1 cos az\n    // z2 = z1\n    final double x1 = x * cosLatitude - z * sinLatitude;\n    final double y1 = y;\n    final double z1 = x * sinLatitude + z * cosLatitude;\n    final double x2 = x1 * cosLongitude - y1 * sinLongitude;\n    final double y2 = x1 * sinLongitude + y1 * cosLongitude;\n    final double z2 = z1;\n    // Finally, scale to put the point on the surface\n    return planetModel.createSurfacePoint(x2, y2, z2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55b50463286869f584cf849d1587a0fcd54d1dfa","date":1462378517,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#pickPole(Random,PlanetModel,List[GeoPoint]).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#pickPole(Random,PlanetModel,List[GeoPoint]).mjava","sourceNew":"  /** Pick a random pole that has a good chance of being inside the polygon described by the points.\n   * @param generator is the random number generator to use.\n   * @param planetModel is the planet model to use.\n   * @param points is the list of points available.\n   * @return the randomly-determined pole selection.\n   */\n  private static GeoPoint pickPole(final Random generator, final PlanetModel planetModel, final List<GeoPoint> points) {\n    final int pointIndex = generator.nextInt(points.size());\n    final GeoPoint closePoint = points.get(pointIndex);\n    // We pick a random angle and random arc distance, then generate a point based on closePoint\n    final double angle = generator.nextDouble() * Math.PI * 2.0 - Math.PI;\n    double maxArcDistance = points.get(0).arcDistance(points.get(1));\n    double trialArcDistance = points.get(0).arcDistance(points.get(2));\n    if (trialArcDistance > maxArcDistance) {\n      maxArcDistance = trialArcDistance;\n    }\n    final double arcDistance = maxArcDistance - generator.nextDouble() * maxArcDistance;\n    // We come up with a unit circle (x,y,z) coordinate given the random angle and arc distance.  The point is centered around the positive x axis.\n    final double x = Math.cos(arcDistance);\n    final double sinArcDistance = Math.sin(arcDistance);\n    final double y = Math.cos(angle) * sinArcDistance;\n    final double z = Math.sin(angle) * sinArcDistance;\n    // Now, use closePoint for a rotation pole\n    final double sinLatitude = Math.sin(closePoint.getLatitude());\n    final double cosLatitude = Math.cos(closePoint.getLatitude());\n    final double sinLongitude = Math.sin(closePoint.getLongitude());\n    final double cosLongitude = Math.cos(closePoint.getLongitude());\n    // This transformation should take the point (1,0,0) and transform it to the closepoint's actual (x,y,z) coordinates.\n    // Coordinate rotation formula:\n    // x1 = x0 cos T - y0 sin T\n    // y1 = x0 sin T + y0 cos T\n    // We're in essence undoing the following transformation (from GeoPolygonFactory):\n    // x1 = x0 cos az + y0 sin az\n    // y1 = - x0 sin az + y0 cos az\n    // z1 = z0\n    // x2 = x1 cos al + z1 sin al\n    // y2 = y1\n    // z2 = - x1 sin al + z1 cos al\n    // So, we reverse the order of the transformations, AND we transform backwards.\n    // Transforming backwards means using these identities: sin(-angle) = -sin(angle), cos(-angle) = cos(angle)\n    // So:\n    // x1 = x0 cos al - z0 sin al\n    // y1 = y0\n    // z1 = x0 sin al + z0 cos al\n    // x2 = x1 cos az - y1 sin az\n    // y2 = x1 sin az + y1 cos az\n    // z2 = z1\n    final double x1 = x * cosLatitude - z * sinLatitude;\n    final double y1 = y;\n    final double z1 = x * sinLatitude + z * cosLatitude;\n    final double x2 = x1 * cosLongitude - y1 * sinLongitude;\n    final double y2 = x1 * sinLongitude + y1 * cosLongitude;\n    final double z2 = z1;\n    // Finally, scale to put the point on the surface\n    return planetModel.createSurfacePoint(x2, y2, z2);\n  }\n\n","sourceOld":"  /** Pick a random pole that has a good chance of being inside the polygon described by the points.\n   * @param generator is the random number generator to use.\n   * @param planetModel is the planet model to use.\n   * @param points is the list of points available.\n   * @return the randomly-determined pole selection.\n   */\n  private static GeoPoint pickPole(final Random generator, final PlanetModel planetModel, final List<GeoPoint> points) {\n    final int pointIndex = generator.nextInt(points.size());\n    final GeoPoint closePoint = points.get(pointIndex);\n    // We pick a random angle and random arc distance, then generate a point based on closePoint\n    final double angle = generator.nextDouble() * Math.PI * 2.0 - Math.PI;\n    final double maxArcDistance = points.get(0).arcDistance(points.get(1));\n    final double arcDistance = maxArcDistance - generator.nextDouble() * maxArcDistance;\n    // We come up with a unit circle (x,y,z) coordinate given the random angle and arc distance.  The point is centered around the positive x axis.\n    final double x = Math.cos(arcDistance);\n    final double sinArcDistance = Math.sin(arcDistance);\n    final double y = Math.cos(angle) * sinArcDistance;\n    final double z = Math.sin(angle) * sinArcDistance;\n    // Now, use closePoint for a rotation pole\n    final double sinLatitude = Math.sin(closePoint.getLatitude());\n    final double cosLatitude = Math.cos(closePoint.getLatitude());\n    final double sinLongitude = Math.sin(closePoint.getLongitude());\n    final double cosLongitude = Math.cos(closePoint.getLongitude());\n    // This transformation should take the point (1,0,0) and transform it to the closepoint's actual (x,y,z) coordinates.\n    // Coordinate rotation formula:\n    // x1 = x0 cos T - y0 sin T\n    // y1 = x0 sin T + y0 cos T\n    // We're in essence undoing the following transformation (from GeoPolygonFactory):\n    // x1 = x0 cos az + y0 sin az\n    // y1 = - x0 sin az + y0 cos az\n    // z1 = z0\n    // x2 = x1 cos al + z1 sin al\n    // y2 = y1\n    // z2 = - x1 sin al + z1 cos al\n    // So, we reverse the order of the transformations, AND we transform backwards.\n    // Transforming backwards means using these identities: sin(-angle) = -sin(angle), cos(-angle) = cos(angle)\n    // So:\n    // x1 = x0 cos al - z0 sin al\n    // y1 = y0\n    // z1 = x0 sin al + z0 cos al\n    // x2 = x1 cos az - y1 sin az\n    // y2 = x1 sin az + y1 cos az\n    // z2 = z1\n    final double x1 = x * cosLatitude - z * sinLatitude;\n    final double y1 = y;\n    final double z1 = x * sinLatitude + z * cosLatitude;\n    final double x2 = x1 * cosLongitude - y1 * sinLongitude;\n    final double y2 = x1 * sinLongitude + y1 * cosLongitude;\n    final double z2 = z1;\n    // Finally, scale to put the point on the surface\n    return planetModel.createSurfacePoint(x2, y2, z2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2c4ea54ac6c0e876359818ff9634e6c179769c1e":["d0ae680950e0cfd56d7b4ea40918fee662023726"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5b6c62df758561770fbfb93e3328392285f3f618"],"5b6c62df758561770fbfb93e3328392285f3f618":["2c4ea54ac6c0e876359818ff9634e6c179769c1e"],"d0ae680950e0cfd56d7b4ea40918fee662023726":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["2c4ea54ac6c0e876359818ff9634e6c179769c1e","5b6c62df758561770fbfb93e3328392285f3f618"]},"commit2Childs":{"2c4ea54ac6c0e876359818ff9634e6c179769c1e":["5b6c62df758561770fbfb93e3328392285f3f618","55b50463286869f584cf849d1587a0fcd54d1dfa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d0ae680950e0cfd56d7b4ea40918fee662023726"],"d0ae680950e0cfd56d7b4ea40918fee662023726":["2c4ea54ac6c0e876359818ff9634e6c179769c1e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"5b6c62df758561770fbfb93e3328392285f3f618":["cd5edd1f2b162a5cfa08efd17851a07373a96817","55b50463286869f584cf849d1587a0fcd54d1dfa"],"55b50463286869f584cf849d1587a0fcd54d1dfa":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","55b50463286869f584cf849d1587a0fcd54d1dfa"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}