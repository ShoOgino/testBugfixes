{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#directUpdate(AbstractUpdateRequest,ClusterState).mjava","commits":[{"id":"d5fc588fc7c6e55c0d778665292d023bf8d5f3b1","date":1378862385,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#directUpdate(AbstractUpdateRequest,ClusterState).mjava","pathOld":"/dev/null","sourceNew":"  private NamedList directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n    if (params == null) {\n      return null;\n    }\n\n    String collection = params.get(\"collection\", defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = clusterState.getCollection(collection);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n\n    NamedList exceptions = new NamedList();\n    NamedList shardResponses = new NamedList();\n\n    Map<String, LBHttpSolrServer.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    Iterator<Map.Entry<String, LBHttpSolrServer.Req>> it = routes.entrySet().iterator();\n\n    long start = System.nanoTime();\n    if(this.parallelUpdates) {\n      ArrayBlockingQueue<RequestTask> finishedTasks = new ArrayBlockingQueue<RequestTask>(routes.size());\n\n      while (it.hasNext()) {\n        Map.Entry<String, LBHttpSolrServer.Req> entry = it.next();\n        String url = entry.getKey();\n        LBHttpSolrServer.Req lbRequest = entry.getValue();\n        threadPool.execute(new RequestTask(url, lbRequest, finishedTasks));\n      }\n\n      while ((shardResponses.size() + exceptions.size()) != routes.size()) {\n        RequestTask requestTask = null;\n        try {\n          requestTask = finishedTasks.take();\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, e);\n        }\n\n        Exception e = requestTask.getException();\n        if (e != null) {\n          exceptions.add(requestTask.getLeader(), e);\n        } else {\n          shardResponses.add(requestTask.getLeader(), requestTask.getRsp().getResponse());\n        }\n      }\n\n      if(exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      while (it.hasNext()) {\n        Map.Entry<String, LBHttpSolrServer.Req> entry = it.next();\n        String url = entry.getKey();\n        LBHttpSolrServer.Req lbRequest = entry.getValue();\n        try{\n          NamedList rsp = lbServer.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch(Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<String>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<String>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4fb788ea821fd2677915770f1cada8122fce2cce","date":1379008291,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#directUpdate(AbstractUpdateRequest,ClusterState).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#directUpdate(AbstractUpdateRequest,ClusterState).mjava","sourceNew":"  private NamedList directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(\"collection\", defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = clusterState.getCollection(collection);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n\n    NamedList exceptions = new NamedList();\n    NamedList shardResponses = new NamedList();\n\n    Map<String, LBHttpSolrServer.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<String, Future<NamedList<?>>>();\n      for (final Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrServer.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbServer.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrServer.Req lbRequest = entry.getValue();\n        try {\n          NamedList rsp = lbServer.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<String>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<String>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n    if (params == null) {\n      return null;\n    }\n\n    String collection = params.get(\"collection\", defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = clusterState.getCollection(collection);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n\n    NamedList exceptions = new NamedList();\n    NamedList shardResponses = new NamedList();\n\n    Map<String, LBHttpSolrServer.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    Iterator<Map.Entry<String, LBHttpSolrServer.Req>> it = routes.entrySet().iterator();\n\n    long start = System.nanoTime();\n    if(this.parallelUpdates) {\n      ArrayBlockingQueue<RequestTask> finishedTasks = new ArrayBlockingQueue<RequestTask>(routes.size());\n\n      while (it.hasNext()) {\n        Map.Entry<String, LBHttpSolrServer.Req> entry = it.next();\n        String url = entry.getKey();\n        LBHttpSolrServer.Req lbRequest = entry.getValue();\n        threadPool.execute(new RequestTask(url, lbRequest, finishedTasks));\n      }\n\n      while ((shardResponses.size() + exceptions.size()) != routes.size()) {\n        RequestTask requestTask = null;\n        try {\n          requestTask = finishedTasks.take();\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, e);\n        }\n\n        Exception e = requestTask.getException();\n        if (e != null) {\n          exceptions.add(requestTask.getLeader(), e);\n        } else {\n          shardResponses.add(requestTask.getLeader(), requestTask.getRsp().getResponse());\n        }\n      }\n\n      if(exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      while (it.hasNext()) {\n        Map.Entry<String, LBHttpSolrServer.Req> entry = it.next();\n        String url = entry.getKey();\n        LBHttpSolrServer.Req lbRequest = entry.getValue();\n        try{\n          NamedList rsp = lbServer.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch(Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<String>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<String>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":["a5f1ef908c2725f453ffce58878db70cc0947a44"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6ada21a57ca8bbc2b585acd8c1245697699c97ac","date":1379443539,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#directUpdate(AbstractUpdateRequest,ClusterState).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#directUpdate(AbstractUpdateRequest,ClusterState).mjava","sourceNew":"  private NamedList directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(\"collection\", defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = clusterState.getCollection(collection);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList exceptions = new NamedList();\n    NamedList shardResponses = new NamedList();\n\n    Map<String, LBHttpSolrServer.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<String, Future<NamedList<?>>>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrServer.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbServer.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrServer.Req lbRequest = entry.getValue();\n        try {\n          NamedList rsp = lbServer.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<String>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<String>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(\"collection\", defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = clusterState.getCollection(collection);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n\n    NamedList exceptions = new NamedList();\n    NamedList shardResponses = new NamedList();\n\n    Map<String, LBHttpSolrServer.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<String, Future<NamedList<?>>>();\n      for (final Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrServer.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbServer.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrServer.Req lbRequest = entry.getValue();\n        try {\n          NamedList rsp = lbServer.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<String>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<String>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#directUpdate(AbstractUpdateRequest,ClusterState).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#directUpdate(AbstractUpdateRequest,ClusterState).mjava","sourceNew":"  private NamedList directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(\"collection\", defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = clusterState.getCollection(collection);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList exceptions = new NamedList();\n    NamedList shardResponses = new NamedList();\n\n    Map<String, LBHttpSolrServer.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrServer.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbServer.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrServer.Req lbRequest = entry.getValue();\n        try {\n          NamedList rsp = lbServer.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(\"collection\", defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = clusterState.getCollection(collection);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList exceptions = new NamedList();\n    NamedList shardResponses = new NamedList();\n\n    Map<String, LBHttpSolrServer.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<String, Future<NamedList<?>>>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrServer.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbServer.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrServer.Req lbRequest = entry.getValue();\n        try {\n          NamedList rsp = lbServer.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<String>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<String>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0881eecc2991506e9decb97365d11f1f4c76c3c6","date":1395596783,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#directUpdate(AbstractUpdateRequest,ClusterState).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#directUpdate(AbstractUpdateRequest,ClusterState).mjava","sourceNew":"  private NamedList directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(\"collection\", defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = clusterState.getCollection(collection);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<Throwable>();\n    NamedList<NamedList> shardResponses = new NamedList<NamedList>();\n\n    Map<String, LBHttpSolrServer.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrServer.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbServer.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrServer.Req lbRequest = entry.getValue();\n        try {\n          NamedList rsp = lbServer.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(\"collection\", defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = clusterState.getCollection(collection);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList exceptions = new NamedList();\n    NamedList shardResponses = new NamedList();\n\n    Map<String, LBHttpSolrServer.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrServer.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbServer.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrServer.Req lbRequest = entry.getValue();\n        try {\n          NamedList rsp = lbServer.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0622fbd990643ae4cacb693db6a0c82cf8916ae2","date":1397637446,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#directUpdate(AbstractUpdateRequest,ClusterState).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#directUpdate(AbstractUpdateRequest,ClusterState).mjava","sourceNew":"  private NamedList directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(\"collection\", defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrServer.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrServer.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbServer.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrServer.Req lbRequest = entry.getValue();\n        try {\n          NamedList rsp = lbServer.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(\"collection\", defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = clusterState.getCollection(collection);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<Throwable>();\n    NamedList<NamedList> shardResponses = new NamedList<NamedList>();\n\n    Map<String, LBHttpSolrServer.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrServer.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbServer.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrServer.Req lbRequest = entry.getValue();\n        try {\n          NamedList rsp = lbServer.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a5f1ef908c2725f453ffce58878db70cc0947a44","date":1397658288,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#directUpdate(AbstractUpdateRequest,ClusterState).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#directUpdate(AbstractUpdateRequest,ClusterState).mjava","sourceNew":"  private NamedList directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(UpdateParams.COLLECTION, defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrServer.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrServer.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbServer.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrServer.Req lbRequest = entry.getValue();\n        try {\n          NamedList rsp = lbServer.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(\"collection\", defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrServer.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrServer.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbServer.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrServer.Req lbRequest = entry.getValue();\n        try {\n          NamedList rsp = lbServer.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":["4fb788ea821fd2677915770f1cada8122fce2cce"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5a233896b7f16ac9b4ed601ef8207d98f1f0500","date":1398857046,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#directUpdate(AbstractUpdateRequest,ClusterState).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#directUpdate(AbstractUpdateRequest,ClusterState).mjava","sourceNew":"  private NamedList directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(UpdateParams.COLLECTION, defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = clusterState.getCollection(collection);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<Throwable>();\n    NamedList<NamedList> shardResponses = new NamedList<NamedList>();\n\n    Map<String, LBHttpSolrServer.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrServer.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbServer.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrServer.Req lbRequest = entry.getValue();\n        try {\n          NamedList rsp = lbServer.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(UpdateParams.COLLECTION, defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrServer.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrServer.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbServer.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrServer.Req lbRequest = entry.getValue();\n        try {\n          NamedList rsp = lbServer.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6f693ed86f289b2e42b46684409b3997f2c264a","date":1404319832,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#directUpdate(AbstractUpdateRequest,ClusterState).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#directUpdate(AbstractUpdateRequest,ClusterState).mjava","sourceNew":"  private NamedList directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(UpdateParams.COLLECTION, defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<Throwable>();\n    NamedList<NamedList> shardResponses = new NamedList<NamedList>();\n\n    Map<String, LBHttpSolrServer.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrServer.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbServer.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrServer.Req lbRequest = entry.getValue();\n        try {\n          NamedList rsp = lbServer.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(UpdateParams.COLLECTION, defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = clusterState.getCollection(collection);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<Throwable>();\n    NamedList<NamedList> shardResponses = new NamedList<NamedList>();\n\n    Map<String, LBHttpSolrServer.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrServer.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbServer.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrServer.Req lbRequest = entry.getValue();\n        try {\n          NamedList rsp = lbServer.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4c07fa58a256dccf8b95364855fd5e9ad4d1401","date":1404386015,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#directUpdate(AbstractUpdateRequest,ClusterState).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#directUpdate(AbstractUpdateRequest,ClusterState).mjava","sourceNew":"  private NamedList directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(UpdateParams.COLLECTION, defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = clusterState.getCollection(collection);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<Throwable>();\n    NamedList<NamedList> shardResponses = new NamedList<NamedList>();\n\n    Map<String, LBHttpSolrServer.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrServer.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbServer.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrServer.Req lbRequest = entry.getValue();\n        try {\n          NamedList rsp = lbServer.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(UpdateParams.COLLECTION, defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<Throwable>();\n    NamedList<NamedList> shardResponses = new NamedList<NamedList>();\n\n    Map<String, LBHttpSolrServer.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrServer.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbServer.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrServer.Req lbRequest = entry.getValue();\n        try {\n          NamedList rsp = lbServer.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9279b175e5e66258442d2123a50f052219a9cc1b","date":1410531077,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#directUpdate(AbstractUpdateRequest,ClusterState).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#directUpdate(AbstractUpdateRequest,ClusterState).mjava","sourceNew":"  private NamedList directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(UpdateParams.COLLECTION, defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<Throwable>();\n    NamedList<NamedList> shardResponses = new NamedList<NamedList>();\n\n    Map<String, LBHttpSolrServer.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrServer.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbServer.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrServer.Req lbRequest = entry.getValue();\n        try {\n          NamedList rsp = lbServer.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(UpdateParams.COLLECTION, defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = clusterState.getCollection(collection);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<Throwable>();\n    NamedList<NamedList> shardResponses = new NamedList<NamedList>();\n\n    Map<String, LBHttpSolrServer.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrServer.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbServer.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrServer.Req lbRequest = entry.getValue();\n        try {\n          NamedList rsp = lbServer.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"471d806b28fa8f148222eb0c300dcab1047a391d","date":1413210204,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#directUpdate(AbstractUpdateRequest,ClusterState).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#directUpdate(AbstractUpdateRequest,ClusterState).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(UpdateParams.COLLECTION, defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrServer.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrServer.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbServer.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrServer.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbServer.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(UpdateParams.COLLECTION, defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<Throwable>();\n    NamedList<NamedList> shardResponses = new NamedList<NamedList>();\n\n    Map<String, LBHttpSolrServer.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrServer.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbServer.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrServer.Req lbRequest = entry.getValue();\n        try {\n          NamedList rsp = lbServer.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#directUpdate(AbstractUpdateRequest,ClusterState).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#directUpdate(AbstractUpdateRequest,ClusterState).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(UpdateParams.COLLECTION, defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrServer.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrServer.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbServer.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrServer.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbServer.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(UpdateParams.COLLECTION, defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<Throwable>();\n    NamedList<NamedList> shardResponses = new NamedList<NamedList>();\n\n    Map<String, LBHttpSolrServer.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrServer.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbServer.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrServer.Req lbRequest = entry.getValue();\n        try {\n          NamedList rsp = lbServer.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,ClusterState).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#directUpdate(AbstractUpdateRequest,ClusterState).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(UpdateParams.COLLECTION, defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrClient.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbClient.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(UpdateParams.COLLECTION, defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrServer.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrServer.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbServer.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrServer.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbServer.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":["a3ca9e9e0800e26a0d02f8fcf73ec4f8362d0214","015571db92de1e6f75d89f34faeb520f99f07b97"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6ada21a57ca8bbc2b585acd8c1245697699c97ac"],"55980207f1977bd1463465de1659b821347e2fa8":["9279b175e5e66258442d2123a50f052219a9cc1b","471d806b28fa8f148222eb0c300dcab1047a391d"],"d5fc588fc7c6e55c0d778665292d023bf8d5f3b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"a5a233896b7f16ac9b4ed601ef8207d98f1f0500":["a5f1ef908c2725f453ffce58878db70cc0947a44"],"0881eecc2991506e9decb97365d11f1f4c76c3c6":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"6ada21a57ca8bbc2b585acd8c1245697699c97ac":["4fb788ea821fd2677915770f1cada8122fce2cce"],"bafca15d8e408346a67f4282ad1143b88023893b":["471d806b28fa8f148222eb0c300dcab1047a391d"],"471d806b28fa8f148222eb0c300dcab1047a391d":["9279b175e5e66258442d2123a50f052219a9cc1b"],"9279b175e5e66258442d2123a50f052219a9cc1b":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"4fb788ea821fd2677915770f1cada8122fce2cce":["d5fc588fc7c6e55c0d778665292d023bf8d5f3b1"],"a6f693ed86f289b2e42b46684409b3997f2c264a":["a5a233896b7f16ac9b4ed601ef8207d98f1f0500"],"a5f1ef908c2725f453ffce58878db70cc0947a44":["0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["0881eecc2991506e9decb97365d11f1f4c76c3c6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bafca15d8e408346a67f4282ad1143b88023893b"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["0881eecc2991506e9decb97365d11f1f4c76c3c6"],"55980207f1977bd1463465de1659b821347e2fa8":[],"d5fc588fc7c6e55c0d778665292d023bf8d5f3b1":["4fb788ea821fd2677915770f1cada8122fce2cce"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["9279b175e5e66258442d2123a50f052219a9cc1b"],"6ada21a57ca8bbc2b585acd8c1245697699c97ac":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a5a233896b7f16ac9b4ed601ef8207d98f1f0500":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"0881eecc2991506e9decb97365d11f1f4c76c3c6":["0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"bafca15d8e408346a67f4282ad1143b88023893b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"471d806b28fa8f148222eb0c300dcab1047a391d":["55980207f1977bd1463465de1659b821347e2fa8","bafca15d8e408346a67f4282ad1143b88023893b"],"9279b175e5e66258442d2123a50f052219a9cc1b":["55980207f1977bd1463465de1659b821347e2fa8","471d806b28fa8f148222eb0c300dcab1047a391d"],"4fb788ea821fd2677915770f1cada8122fce2cce":["6ada21a57ca8bbc2b585acd8c1245697699c97ac"],"a6f693ed86f289b2e42b46684409b3997f2c264a":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"a5f1ef908c2725f453ffce58878db70cc0947a44":["a5a233896b7f16ac9b4ed601ef8207d98f1f0500"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d5fc588fc7c6e55c0d778665292d023bf8d5f3b1"],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["a5f1ef908c2725f453ffce58878db70cc0947a44"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["55980207f1977bd1463465de1659b821347e2fa8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}