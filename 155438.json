{"path":"solr/core/src/java/org/apache/solr/cloud/DeleteSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","commits":[{"id":"424ac616f0aeeb2a3c8b6b94084255a0bcab9628","date":1477057622,"type":0,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/DeleteSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName =  message.getStr(COLLECTION_PROP);\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    Map<String, String> requestMap = new HashMap<>();\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    SolrZkClient zkClient = ocmh.overseer.getZkController().getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          ocmh.sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap);\n        }\n      }\n    }\n\n    ocmh.processResponses(shardRequestResults, shardHandler, false, null, asyncId, requestMap);\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows\", collectionName, commitName,\n          Utils.toJSON(newResult));\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["6afb0ba86024b96e8b34cfc2e15562239dc36360","6afb0ba86024b96e8b34cfc2e15562239dc36360","69e6520a21709190413a63084ed135271aab1a7c","69e6520a21709190413a63084ed135271aab1a7c","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"80d0e6d59ae23f4a6f30eaf40bfb40742300287f","date":1477598926,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/DeleteSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName =  message.getStr(COLLECTION_PROP);\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    Map<String, String> requestMap = new HashMap<>();\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    SolrZkClient zkClient = ocmh.overseer.getZkController().getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          ocmh.sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap);\n        }\n      }\n    }\n\n    ocmh.processResponses(shardRequestResults, shardHandler, false, null, asyncId, requestMap);\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows\", collectionName, commitName,\n          Utils.toJSON(newResult));\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":5,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/DeleteSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName =  message.getStr(COLLECTION_PROP);\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    Map<String, String> requestMap = new HashMap<>();\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          ocmh.sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap);\n        }\n      }\n    }\n\n    ocmh.processResponses(shardRequestResults, shardHandler, false, null, asyncId, requestMap);\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows\", collectionName, commitName,\n          Utils.toJSON(newResult));\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName =  message.getStr(COLLECTION_PROP);\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    Map<String, String> requestMap = new HashMap<>();\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    SolrZkClient zkClient = ocmh.overseer.getZkController().getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          ocmh.sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap);\n        }\n      }\n    }\n\n    ocmh.processResponses(shardRequestResults, shardHandler, false, null, asyncId, requestMap);\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows\", collectionName, commitName,\n          Utils.toJSON(newResult));\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":4,"author":"Karl Wright","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/DeleteSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":null,"sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName =  message.getStr(COLLECTION_PROP);\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    Map<String, String> requestMap = new HashMap<>();\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    SolrZkClient zkClient = ocmh.overseer.getZkController().getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          ocmh.sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap);\n        }\n      }\n    }\n\n    ocmh.processResponses(shardRequestResults, shardHandler, false, null, asyncId, requestMap);\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows\", collectionName, commitName,\n          Utils.toJSON(newResult));\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["424ac616f0aeeb2a3c8b6b94084255a0bcab9628","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","424ac616f0aeeb2a3c8b6b94084255a0bcab9628"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["424ac616f0aeeb2a3c8b6b94084255a0bcab9628"],"424ac616f0aeeb2a3c8b6b94084255a0bcab9628":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b94236357aaa22b76c10629851fe4e376e0cea82"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f","424ac616f0aeeb2a3c8b6b94084255a0bcab9628"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":[],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"424ac616f0aeeb2a3c8b6b94084255a0bcab9628":["b94236357aaa22b76c10629851fe4e376e0cea82","80d0e6d59ae23f4a6f30eaf40bfb40742300287f","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}