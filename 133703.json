{"path":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/IntersectsPrefixTreeFilter#getDocIdSet(AtomicReaderContext,Bits).mjava","commits":[{"id":"c659c37800c0dfd82fa025b5834f4ab065903d11","date":1361851047,"type":0,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/IntersectsPrefixTreeFilter#getDocIdSet(AtomicReaderContext,Bits).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n    return new VisitorTemplate(context, acceptDocs, hasIndexedLeaves) {\n      private OpenBitSet results;\n\n      @Override\n      protected void start() {\n        results = new OpenBitSet(maxDoc);\n      }\n\n      @Override\n      protected DocIdSet finish() {\n        return results;\n      }\n\n      @Override\n      protected boolean visit(Node cell) throws IOException {\n        if (cell.getShapeRel() == SpatialRelation.WITHIN || cell.getLevel() == detailLevel) {\n          collectDocs(results);\n          return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitLeaf(Node cell) throws IOException {\n        collectDocs(results);\n      }\n\n      @Override\n      protected void visitScanned(Node cell, Shape cellShape) throws IOException {\n        if (queryShape.relate(cellShape).intersects())\n          collectDocs(results);\n      }\n\n    }.getDocIdSet();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5aeecf64d57563b4636e7f4222e7ddcde7f8df7b","date":1364392557,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/IntersectsPrefixTreeFilter#getDocIdSet(AtomicReaderContext,Bits).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/IntersectsPrefixTreeFilter#getDocIdSet(AtomicReaderContext,Bits).mjava","sourceNew":"  @Override\n  public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n    return new VisitorTemplate(context, acceptDocs, hasIndexedLeaves) {\n      private FixedBitSet results;\n\n      @Override\n      protected void start() {\n        results = new FixedBitSet(maxDoc);\n      }\n\n      @Override\n      protected DocIdSet finish() {\n        return results;\n      }\n\n      @Override\n      protected boolean visit(Node cell) throws IOException {\n        if (cell.getShapeRel() == SpatialRelation.WITHIN || cell.getLevel() == detailLevel) {\n          collectDocs(results);\n          return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitLeaf(Node cell) throws IOException {\n        collectDocs(results);\n      }\n\n      @Override\n      protected void visitScanned(Node cell) throws IOException {\n        Shape cShape;\n        //if this cell represents a point, use the cell center vs the box\n        // TODO this behavior is debatable; might want to be configurable\n        // (points never have isLeaf())\n        if (cell.getLevel() == grid.getMaxLevels() && !cell.isLeaf())\n          cShape = cell.getCenter();\n        else\n          cShape = cell.getShape();\n        if (queryShape.relate(cShape).intersects())\n          collectDocs(results);\n      }\n\n    }.getDocIdSet();\n  }\n\n","sourceOld":"  @Override\n  public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n    return new VisitorTemplate(context, acceptDocs, hasIndexedLeaves) {\n      private OpenBitSet results;\n\n      @Override\n      protected void start() {\n        results = new OpenBitSet(maxDoc);\n      }\n\n      @Override\n      protected DocIdSet finish() {\n        return results;\n      }\n\n      @Override\n      protected boolean visit(Node cell) throws IOException {\n        if (cell.getShapeRel() == SpatialRelation.WITHIN || cell.getLevel() == detailLevel) {\n          collectDocs(results);\n          return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitLeaf(Node cell) throws IOException {\n        collectDocs(results);\n      }\n\n      @Override\n      protected void visitScanned(Node cell, Shape cellShape) throws IOException {\n        if (queryShape.relate(cellShape).intersects())\n          collectDocs(results);\n      }\n\n    }.getDocIdSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8259c159da2de2e8528524fb76b244b46cbded59","date":1364478249,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/IntersectsPrefixTreeFilter#getDocIdSet(AtomicReaderContext,Bits).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/IntersectsPrefixTreeFilter#getDocIdSet(AtomicReaderContext,Bits).mjava","sourceNew":"  @Override\n  public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n    return new VisitorTemplate(context, acceptDocs, hasIndexedLeaves) {\n      private FixedBitSet results;\n\n      @Override\n      protected void start() {\n        results = new FixedBitSet(maxDoc);\n      }\n\n      @Override\n      protected DocIdSet finish() {\n        return results;\n      }\n\n      @Override\n      protected boolean visit(Cell cell) throws IOException {\n        if (cell.getShapeRel() == SpatialRelation.WITHIN || cell.getLevel() == detailLevel) {\n          collectDocs(results);\n          return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitLeaf(Cell cell) throws IOException {\n        collectDocs(results);\n      }\n\n      @Override\n      protected void visitScanned(Cell cell) throws IOException {\n        Shape cShape;\n        //if this cell represents a point, use the cell center vs the box\n        // TODO this behavior is debatable; might want to be configurable\n        // (points never have isLeaf())\n        if (cell.getLevel() == grid.getMaxLevels() && !cell.isLeaf())\n          cShape = cell.getCenter();\n        else\n          cShape = cell.getShape();\n        if (queryShape.relate(cShape).intersects())\n          collectDocs(results);\n      }\n\n    }.getDocIdSet();\n  }\n\n","sourceOld":"  @Override\n  public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n    return new VisitorTemplate(context, acceptDocs, hasIndexedLeaves) {\n      private FixedBitSet results;\n\n      @Override\n      protected void start() {\n        results = new FixedBitSet(maxDoc);\n      }\n\n      @Override\n      protected DocIdSet finish() {\n        return results;\n      }\n\n      @Override\n      protected boolean visit(Node cell) throws IOException {\n        if (cell.getShapeRel() == SpatialRelation.WITHIN || cell.getLevel() == detailLevel) {\n          collectDocs(results);\n          return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitLeaf(Node cell) throws IOException {\n        collectDocs(results);\n      }\n\n      @Override\n      protected void visitScanned(Node cell) throws IOException {\n        Shape cShape;\n        //if this cell represents a point, use the cell center vs the box\n        // TODO this behavior is debatable; might want to be configurable\n        // (points never have isLeaf())\n        if (cell.getLevel() == grid.getMaxLevels() && !cell.isLeaf())\n          cShape = cell.getCenter();\n        else\n          cShape = cell.getShape();\n        if (queryShape.relate(cShape).intersects())\n          collectDocs(results);\n      }\n\n    }.getDocIdSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f54c29b684839e16d0a7ffd41ee8a1e93e905184","date":1395120410,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/IntersectsPrefixTreeFilter#getDocIdSet(AtomicReaderContext,Bits).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/IntersectsPrefixTreeFilter#getDocIdSet(AtomicReaderContext,Bits).mjava","sourceNew":"  @Override\n  public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n    return new VisitorTemplate(context, acceptDocs, hasIndexedLeaves) {\n      private FixedBitSet results;\n\n      @Override\n      protected void start() {\n        results = new FixedBitSet(maxDoc);\n      }\n\n      @Override\n      protected DocIdSet finish() {\n        return results;\n      }\n\n      @Override\n      protected boolean visit(Cell cell) throws IOException {\n        if (cell.getShapeRel() == SpatialRelation.WITHIN || cell.getLevel() == detailLevel) {\n          collectDocs(results);\n          return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitLeaf(Cell cell) throws IOException {\n        collectDocs(results);\n      }\n\n      @Override\n      protected void visitScanned(Cell cell) throws IOException {\n        if (queryShape.relate(cell.getShape()).intersects())\n          collectDocs(results);\n      }\n\n    }.getDocIdSet();\n  }\n\n","sourceOld":"  @Override\n  public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n    return new VisitorTemplate(context, acceptDocs, hasIndexedLeaves) {\n      private FixedBitSet results;\n\n      @Override\n      protected void start() {\n        results = new FixedBitSet(maxDoc);\n      }\n\n      @Override\n      protected DocIdSet finish() {\n        return results;\n      }\n\n      @Override\n      protected boolean visit(Cell cell) throws IOException {\n        if (cell.getShapeRel() == SpatialRelation.WITHIN || cell.getLevel() == detailLevel) {\n          collectDocs(results);\n          return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitLeaf(Cell cell) throws IOException {\n        collectDocs(results);\n      }\n\n      @Override\n      protected void visitScanned(Cell cell) throws IOException {\n        Shape cShape;\n        //if this cell represents a point, use the cell center vs the box\n        // TODO this behavior is debatable; might want to be configurable\n        // (points never have isLeaf())\n        if (cell.getLevel() == grid.getMaxLevels() && !cell.isLeaf())\n          cShape = cell.getCenter();\n        else\n          cShape = cell.getShape();\n        if (queryShape.relate(cShape).intersects())\n          collectDocs(results);\n      }\n\n    }.getDocIdSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6","date":1397789149,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/IntersectsPrefixTreeFilter#getDocIdSet(AtomicReaderContext,Bits).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/IntersectsPrefixTreeFilter#getDocIdSet(AtomicReaderContext,Bits).mjava","sourceNew":"  @Override\n  public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n    /* Possible optimizations (in IN ADDITION TO THOSE LISTED IN VISITORTEMPLATE):\n\n    * If docFreq is 1 (or < than some small threshold), then check to see if we've already\n      collected it; if so short-circuit. Don't do this just for point data, as there is\n      no benefit, or only marginal benefit when multi-valued.\n\n    * Point query shape optimization when the only indexed data is a point (no leaves).  Result is a term query.\n\n     */\n    return new VisitorTemplate(context, acceptDocs, hasIndexedLeaves) {\n      private FixedBitSet results;\n\n      @Override\n      protected void start() {\n        results = new FixedBitSet(maxDoc);\n      }\n\n      @Override\n      protected DocIdSet finish() {\n        return results;\n      }\n\n      @Override\n      protected boolean visit(Cell cell) throws IOException {\n        if (cell.getShapeRel() == SpatialRelation.WITHIN || cell.getLevel() == detailLevel) {\n          collectDocs(results);\n          return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitLeaf(Cell cell) throws IOException {\n        collectDocs(results);\n      }\n\n      @Override\n      protected void visitScanned(Cell cell) throws IOException {\n        if (queryShape.relate(cell.getShape()).intersects())\n          collectDocs(results);\n      }\n\n    }.getDocIdSet();\n  }\n\n","sourceOld":"  @Override\n  public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n    return new VisitorTemplate(context, acceptDocs, hasIndexedLeaves) {\n      private FixedBitSet results;\n\n      @Override\n      protected void start() {\n        results = new FixedBitSet(maxDoc);\n      }\n\n      @Override\n      protected DocIdSet finish() {\n        return results;\n      }\n\n      @Override\n      protected boolean visit(Cell cell) throws IOException {\n        if (cell.getShapeRel() == SpatialRelation.WITHIN || cell.getLevel() == detailLevel) {\n          collectDocs(results);\n          return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitLeaf(Cell cell) throws IOException {\n        collectDocs(results);\n      }\n\n      @Override\n      protected void visitScanned(Cell cell) throws IOException {\n        if (queryShape.relate(cell.getShape()).intersects())\n          collectDocs(results);\n      }\n\n    }.getDocIdSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":4,"author":"Ryan Ernst","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/IntersectsPrefixTreeFilter#getDocIdSet(AtomicReaderContext,Bits).mjava","sourceNew":null,"sourceOld":"  @Override\n  public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n    /* Possible optimizations (in IN ADDITION TO THOSE LISTED IN VISITORTEMPLATE):\n\n    * If docFreq is 1 (or < than some small threshold), then check to see if we've already\n      collected it; if so short-circuit. Don't do this just for point data, as there is\n      no benefit, or only marginal benefit when multi-valued.\n\n    * Point query shape optimization when the only indexed data is a point (no leaves).  Result is a term query.\n\n     */\n    return new VisitorTemplate(context, acceptDocs, hasIndexedLeaves) {\n      private FixedBitSet results;\n\n      @Override\n      protected void start() {\n        results = new FixedBitSet(maxDoc);\n      }\n\n      @Override\n      protected DocIdSet finish() {\n        return results;\n      }\n\n      @Override\n      protected boolean visit(Cell cell) throws IOException {\n        if (cell.getShapeRel() == SpatialRelation.WITHIN || cell.getLevel() == detailLevel) {\n          collectDocs(results);\n          return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitLeaf(Cell cell) throws IOException {\n        collectDocs(results);\n      }\n\n      @Override\n      protected void visitScanned(Cell cell) throws IOException {\n        if (queryShape.relate(cell.getShape()).intersects())\n          collectDocs(results);\n      }\n\n    }.getDocIdSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f54c29b684839e16d0a7ffd41ee8a1e93e905184":["8259c159da2de2e8528524fb76b244b46cbded59"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6":["f54c29b684839e16d0a7ffd41ee8a1e93e905184"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"8259c159da2de2e8528524fb76b244b46cbded59":["5aeecf64d57563b4636e7f4222e7ddcde7f8df7b"],"5aeecf64d57563b4636e7f4222e7ddcde7f8df7b":["c659c37800c0dfd82fa025b5834f4ab065903d11"],"c659c37800c0dfd82fa025b5834f4ab065903d11":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"f54c29b684839e16d0a7ffd41ee8a1e93e905184":["8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c659c37800c0dfd82fa025b5834f4ab065903d11"],"8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8259c159da2de2e8528524fb76b244b46cbded59":["f54c29b684839e16d0a7ffd41ee8a1e93e905184"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"5aeecf64d57563b4636e7f4222e7ddcde7f8df7b":["8259c159da2de2e8528524fb76b244b46cbded59"],"c659c37800c0dfd82fa025b5834f4ab065903d11":["5aeecf64d57563b4636e7f4222e7ddcde7f8df7b"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}