{"path":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.IntFieldValueCollector#IntFieldValueCollector(int,int,int,int,int,String,GroupHeadSelector,SortSpec,boolean,FieldType,IntIntHashMap,FunctionQuery,IndexSearcher).mjava","commits":[{"id":"0325de99180d346d61d36938843a5c8451fe26ae","date":1447368726,"type":1,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.IntFieldValueCollector#IntFieldValueCollector(int,int,int,int,int,String,GroupHeadSelector,SortSpec,boolean,FieldType,IntIntHashMap,FunctionQuery,IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.IntFieldValueCollector#IntFieldValueCollector(int,int,int,int,int,String,String,boolean,boolean,FieldType,IntIntHashMap,FunctionQuery,IndexSearcher).mjava","sourceNew":"    public IntFieldValueCollector(int maxDoc,\n                                  int size,\n                                  int segments,\n                                  int nullValue,\n                                  int nullPolicy,\n                                  String collapseField,\n                                  GroupHeadSelector groupHeadSelector,\n                                  SortSpec sortSpec,\n                                  boolean needsScores,\n                                  FieldType fieldType,\n                                  IntIntHashMap boostDocsMap,\n                                  FunctionQuery funcQuery,\n                                  IndexSearcher searcher) throws IOException{\n\n      assert ! GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type);\n      \n      this.maxDoc = maxDoc;\n      this.contexts = new LeafReaderContext[segments];\n      this.collapseField = collapseField;\n      this.nullValue = nullValue;\n      this.nullPolicy = nullPolicy;\n      this.needsScores = needsScores;\n      if (null != sortSpec) {\n        this.collapseStrategy = new IntSortSpecStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap, sortSpec, searcher);\n      } else if (funcQuery != null) {\n        this.collapseStrategy =  new IntValueSourceStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap, funcQuery, searcher);\n      } else {\n        if(fieldType instanceof TrieIntField) {\n          this.collapseStrategy = new IntIntStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n        } else if(fieldType instanceof TrieFloatField) {\n          this.collapseStrategy = new IntFloatStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n        } else {\n          throw new IOException(\"min/max must be TrieInt or TrieFloat when collapsing on numeric fields .\");\n        }\n      }\n    }\n\n","sourceOld":"    public IntFieldValueCollector(int maxDoc,\n                                  int size,\n                                  int segments,\n                                  int nullValue,\n                                  int nullPolicy,\n                                  String collapseField,\n                                  String field,\n                                  boolean max,\n                                  boolean needsScores,\n                                  FieldType fieldType,\n                                  IntIntHashMap boostDocsMap,\n                                  FunctionQuery funcQuery,\n                                  IndexSearcher searcher) throws IOException{\n\n      this.maxDoc = maxDoc;\n      this.contexts = new LeafReaderContext[segments];\n      this.collapseField = collapseField;\n      this.nullValue = nullValue;\n      this.nullPolicy = nullPolicy;\n      this.needsScores = needsScores;\n      if(funcQuery != null) {\n        this.collapseStrategy =  new IntValueSourceStrategy(maxDoc, field, size, collapseField, nullValue, nullPolicy, max, this.needsScores, boostDocsMap, funcQuery, searcher);\n      } else {\n        if(fieldType instanceof TrieIntField) {\n          this.collapseStrategy = new IntIntStrategy(maxDoc, size, collapseField, field, nullValue, nullPolicy, max, this.needsScores, boostDocsMap);\n        } else if(fieldType instanceof TrieFloatField) {\n          this.collapseStrategy = new IntFloatStrategy(maxDoc, size, collapseField, field, nullValue, nullPolicy, max, this.needsScores, boostDocsMap);\n        } else {\n          throw new IOException(\"min/max must be TrieInt or TrieFloat when collapsing on numeric fields .\");\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ea826cad27aae1c1287b70d2eaf0202ec6aa754","date":1490169633,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.IntFieldValueCollector#IntFieldValueCollector(int,int,int,int,int,String,GroupHeadSelector,SortSpec,boolean,FieldType,IntIntHashMap,FunctionQuery,IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.IntFieldValueCollector#IntFieldValueCollector(int,int,int,int,int,String,GroupHeadSelector,SortSpec,boolean,FieldType,IntIntHashMap,FunctionQuery,IndexSearcher).mjava","sourceNew":"    public IntFieldValueCollector(int maxDoc,\n                                  int size,\n                                  int segments,\n                                  int nullValue,\n                                  int nullPolicy,\n                                  String collapseField,\n                                  GroupHeadSelector groupHeadSelector,\n                                  SortSpec sortSpec,\n                                  boolean needsScores,\n                                  FieldType fieldType,\n                                  IntIntHashMap boostDocsMap,\n                                  FunctionQuery funcQuery,\n                                  IndexSearcher searcher) throws IOException{\n\n      assert ! GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type);\n      \n      this.maxDoc = maxDoc;\n      this.contexts = new LeafReaderContext[segments];\n      this.collapseField = collapseField;\n      this.nullValue = nullValue;\n      this.nullPolicy = nullPolicy;\n      this.needsScores = needsScores;\n      if (null != sortSpec) {\n        this.collapseStrategy = new IntSortSpecStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap, sortSpec, searcher);\n      } else if (funcQuery != null) {\n        this.collapseStrategy =  new IntValueSourceStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap, funcQuery, searcher);\n      } else {\n        if (fieldType instanceof TrieIntField || fieldType instanceof IntPointField) {\n          this.collapseStrategy = new IntIntStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n        } else if (fieldType instanceof TrieFloatField || fieldType instanceof FloatPointField) {\n          this.collapseStrategy = new IntFloatStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n        } else {\n          throw new IOException(\"min/max must be Int or Float field types when collapsing on numeric fields\");\n        }\n      }\n    }\n\n","sourceOld":"    public IntFieldValueCollector(int maxDoc,\n                                  int size,\n                                  int segments,\n                                  int nullValue,\n                                  int nullPolicy,\n                                  String collapseField,\n                                  GroupHeadSelector groupHeadSelector,\n                                  SortSpec sortSpec,\n                                  boolean needsScores,\n                                  FieldType fieldType,\n                                  IntIntHashMap boostDocsMap,\n                                  FunctionQuery funcQuery,\n                                  IndexSearcher searcher) throws IOException{\n\n      assert ! GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type);\n      \n      this.maxDoc = maxDoc;\n      this.contexts = new LeafReaderContext[segments];\n      this.collapseField = collapseField;\n      this.nullValue = nullValue;\n      this.nullPolicy = nullPolicy;\n      this.needsScores = needsScores;\n      if (null != sortSpec) {\n        this.collapseStrategy = new IntSortSpecStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap, sortSpec, searcher);\n      } else if (funcQuery != null) {\n        this.collapseStrategy =  new IntValueSourceStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap, funcQuery, searcher);\n      } else {\n        if(fieldType instanceof TrieIntField) {\n          this.collapseStrategy = new IntIntStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n        } else if(fieldType instanceof TrieFloatField) {\n          this.collapseStrategy = new IntFloatStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n        } else {\n          throw new IOException(\"min/max must be TrieInt or TrieFloat when collapsing on numeric fields .\");\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa09e86cb64347ee96ff0a59f09b539abd620e57","date":1490280013,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.IntFieldValueCollector#IntFieldValueCollector(int,int,int,int,int,String,GroupHeadSelector,SortSpec,boolean,FieldType,IntIntHashMap,FunctionQuery,IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.IntFieldValueCollector#IntFieldValueCollector(int,int,int,int,int,String,GroupHeadSelector,SortSpec,boolean,FieldType,IntIntHashMap,FunctionQuery,IndexSearcher).mjava","sourceNew":"    public IntFieldValueCollector(int maxDoc,\n                                  int size,\n                                  int segments,\n                                  int nullValue,\n                                  int nullPolicy,\n                                  String collapseField,\n                                  GroupHeadSelector groupHeadSelector,\n                                  SortSpec sortSpec,\n                                  boolean needsScores,\n                                  FieldType fieldType,\n                                  IntIntHashMap boostDocsMap,\n                                  FunctionQuery funcQuery,\n                                  IndexSearcher searcher) throws IOException{\n\n      assert ! GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type);\n      \n      this.maxDoc = maxDoc;\n      this.contexts = new LeafReaderContext[segments];\n      this.collapseField = collapseField;\n      this.nullValue = nullValue;\n      this.nullPolicy = nullPolicy;\n      this.needsScores = needsScores;\n      if (null != sortSpec) {\n        this.collapseStrategy = new IntSortSpecStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap, sortSpec, searcher);\n      } else if (funcQuery != null) {\n        this.collapseStrategy =  new IntValueSourceStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap, funcQuery, searcher);\n      } else {\n        if (fieldType instanceof TrieIntField || fieldType instanceof IntPointField) {\n          this.collapseStrategy = new IntIntStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n        } else if (fieldType instanceof TrieFloatField || fieldType instanceof FloatPointField) {\n          this.collapseStrategy = new IntFloatStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n        } else {\n          throw new IOException(\"min/max must be Int or Float field types when collapsing on numeric fields\");\n        }\n      }\n    }\n\n","sourceOld":"    public IntFieldValueCollector(int maxDoc,\n                                  int size,\n                                  int segments,\n                                  int nullValue,\n                                  int nullPolicy,\n                                  String collapseField,\n                                  GroupHeadSelector groupHeadSelector,\n                                  SortSpec sortSpec,\n                                  boolean needsScores,\n                                  FieldType fieldType,\n                                  IntIntHashMap boostDocsMap,\n                                  FunctionQuery funcQuery,\n                                  IndexSearcher searcher) throws IOException{\n\n      assert ! GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type);\n      \n      this.maxDoc = maxDoc;\n      this.contexts = new LeafReaderContext[segments];\n      this.collapseField = collapseField;\n      this.nullValue = nullValue;\n      this.nullPolicy = nullPolicy;\n      this.needsScores = needsScores;\n      if (null != sortSpec) {\n        this.collapseStrategy = new IntSortSpecStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap, sortSpec, searcher);\n      } else if (funcQuery != null) {\n        this.collapseStrategy =  new IntValueSourceStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap, funcQuery, searcher);\n      } else {\n        if(fieldType instanceof TrieIntField) {\n          this.collapseStrategy = new IntIntStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n        } else if(fieldType instanceof TrieFloatField) {\n          this.collapseStrategy = new IntFloatStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n        } else {\n          throw new IOException(\"min/max must be TrieInt or TrieFloat when collapsing on numeric fields .\");\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d048016075a0b8589fcfc77fdf8e2a29fc80964","date":1494631326,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.IntFieldValueCollector#IntFieldValueCollector(int,int,int,int,int,String,GroupHeadSelector,SortSpec,boolean,FieldType,IntIntHashMap,FunctionQuery,IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.IntFieldValueCollector#IntFieldValueCollector(int,int,int,int,int,String,GroupHeadSelector,SortSpec,boolean,FieldType,IntIntHashMap,FunctionQuery,IndexSearcher).mjava","sourceNew":"    public IntFieldValueCollector(int maxDoc,\n                                  int size,\n                                  int segments,\n                                  int nullValue,\n                                  int nullPolicy,\n                                  String collapseField,\n                                  GroupHeadSelector groupHeadSelector,\n                                  SortSpec sortSpec,\n                                  boolean needsScores,\n                                  FieldType fieldType,\n                                  IntIntHashMap boostDocsMap,\n                                  FunctionQuery funcQuery,\n                                  IndexSearcher searcher) throws IOException{\n\n      assert ! GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type);\n      \n      this.maxDoc = maxDoc;\n      this.contexts = new LeafReaderContext[segments];\n      this.collapseField = collapseField;\n      this.nullValue = nullValue;\n      this.nullPolicy = nullPolicy;\n      this.needsScores = needsScores;\n      if (null != sortSpec) {\n        this.collapseStrategy = new IntSortSpecStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap, sortSpec, searcher);\n      } else if (funcQuery != null) {\n        this.collapseStrategy =  new IntValueSourceStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap, funcQuery, searcher);\n      } else {\n        NumberType numType = fieldType.getNumberType();\n        assert null != numType; // shouldn't make it here for non-numeric types\n        switch (numType) {\n          case INTEGER: {\n            this.collapseStrategy = new IntIntStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n            break;\n          }\n          case FLOAT: {\n            this.collapseStrategy = new IntFloatStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n            break;\n          }\n          default: {\n            throw new IOException(\"min/max must be Int or Float field types when collapsing on numeric fields\");\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public IntFieldValueCollector(int maxDoc,\n                                  int size,\n                                  int segments,\n                                  int nullValue,\n                                  int nullPolicy,\n                                  String collapseField,\n                                  GroupHeadSelector groupHeadSelector,\n                                  SortSpec sortSpec,\n                                  boolean needsScores,\n                                  FieldType fieldType,\n                                  IntIntHashMap boostDocsMap,\n                                  FunctionQuery funcQuery,\n                                  IndexSearcher searcher) throws IOException{\n\n      assert ! GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type);\n      \n      this.maxDoc = maxDoc;\n      this.contexts = new LeafReaderContext[segments];\n      this.collapseField = collapseField;\n      this.nullValue = nullValue;\n      this.nullPolicy = nullPolicy;\n      this.needsScores = needsScores;\n      if (null != sortSpec) {\n        this.collapseStrategy = new IntSortSpecStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap, sortSpec, searcher);\n      } else if (funcQuery != null) {\n        this.collapseStrategy =  new IntValueSourceStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap, funcQuery, searcher);\n      } else {\n        if (fieldType instanceof TrieIntField || fieldType instanceof IntPointField) {\n          this.collapseStrategy = new IntIntStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n        } else if (fieldType instanceof TrieFloatField || fieldType instanceof FloatPointField) {\n          this.collapseStrategy = new IntFloatStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n        } else {\n          throw new IOException(\"min/max must be Int or Float field types when collapsing on numeric fields\");\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":["432fdfa612cbca5b4cf9125a2c6aa055cd53cadb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.IntFieldValueCollector#IntFieldValueCollector(int,int,int,int,int,String,GroupHeadSelector,SortSpec,boolean,FieldType,IntIntHashMap,FunctionQuery,IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.IntFieldValueCollector#IntFieldValueCollector(int,int,int,int,int,String,GroupHeadSelector,SortSpec,boolean,FieldType,IntIntHashMap,FunctionQuery,IndexSearcher).mjava","sourceNew":"    public IntFieldValueCollector(int maxDoc,\n                                  int size,\n                                  int segments,\n                                  int nullValue,\n                                  int nullPolicy,\n                                  String collapseField,\n                                  GroupHeadSelector groupHeadSelector,\n                                  SortSpec sortSpec,\n                                  boolean needsScores,\n                                  FieldType fieldType,\n                                  IntIntHashMap boostDocsMap,\n                                  FunctionQuery funcQuery,\n                                  IndexSearcher searcher) throws IOException{\n\n      assert ! GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type);\n      \n      this.maxDoc = maxDoc;\n      this.contexts = new LeafReaderContext[segments];\n      this.collapseField = collapseField;\n      this.nullValue = nullValue;\n      this.nullPolicy = nullPolicy;\n      this.needsScores = needsScores;\n      if (null != sortSpec) {\n        this.collapseStrategy = new IntSortSpecStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap, sortSpec, searcher);\n      } else if (funcQuery != null) {\n        this.collapseStrategy =  new IntValueSourceStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap, funcQuery, searcher);\n      } else {\n        NumberType numType = fieldType.getNumberType();\n        assert null != numType; // shouldn't make it here for non-numeric types\n        switch (numType) {\n          case INTEGER: {\n            this.collapseStrategy = new IntIntStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n            break;\n          }\n          case FLOAT: {\n            this.collapseStrategy = new IntFloatStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n            break;\n          }\n          default: {\n            throw new IOException(\"min/max must be Int or Float field types when collapsing on numeric fields\");\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public IntFieldValueCollector(int maxDoc,\n                                  int size,\n                                  int segments,\n                                  int nullValue,\n                                  int nullPolicy,\n                                  String collapseField,\n                                  GroupHeadSelector groupHeadSelector,\n                                  SortSpec sortSpec,\n                                  boolean needsScores,\n                                  FieldType fieldType,\n                                  IntIntHashMap boostDocsMap,\n                                  FunctionQuery funcQuery,\n                                  IndexSearcher searcher) throws IOException{\n\n      assert ! GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type);\n      \n      this.maxDoc = maxDoc;\n      this.contexts = new LeafReaderContext[segments];\n      this.collapseField = collapseField;\n      this.nullValue = nullValue;\n      this.nullPolicy = nullPolicy;\n      this.needsScores = needsScores;\n      if (null != sortSpec) {\n        this.collapseStrategy = new IntSortSpecStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap, sortSpec, searcher);\n      } else if (funcQuery != null) {\n        this.collapseStrategy =  new IntValueSourceStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap, funcQuery, searcher);\n      } else {\n        if (fieldType instanceof TrieIntField || fieldType instanceof IntPointField) {\n          this.collapseStrategy = new IntIntStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n        } else if (fieldType instanceof TrieFloatField || fieldType instanceof FloatPointField) {\n          this.collapseStrategy = new IntFloatStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n        } else {\n          throw new IOException(\"min/max must be Int or Float field types when collapsing on numeric fields\");\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"446ec69a32a7e8cb8bf6eb8be693e96ab5f5a0d3","date":1556831715,"type":5,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.IntFieldValueCollector#IntFieldValueCollector(int,int,int,int,int,String,GroupHeadSelector,SortSpec,boolean,boolean,FieldType,IntIntHashMap,FunctionQuery,IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.IntFieldValueCollector#IntFieldValueCollector(int,int,int,int,int,String,GroupHeadSelector,SortSpec,boolean,FieldType,IntIntHashMap,FunctionQuery,IndexSearcher).mjava","sourceNew":"    public IntFieldValueCollector(int maxDoc,\n                                  int size,\n                                  int segments,\n                                  int nullValue,\n                                  int nullPolicy,\n                                  String collapseField,\n                                  GroupHeadSelector groupHeadSelector,\n                                  SortSpec sortSpec,\n                                  boolean needsScores4Collapsing,\n                                  boolean needsScores,\n                                  FieldType fieldType,\n                                  IntIntHashMap boostDocsMap,\n                                  FunctionQuery funcQuery,\n                                  IndexSearcher searcher) throws IOException{\n\n      assert ! GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type);\n      \n      this.maxDoc = maxDoc;\n      this.contexts = new LeafReaderContext[segments];\n      this.collapseField = collapseField;\n      this.nullValue = nullValue;\n      this.nullPolicy = nullPolicy;\n      this.needsScores4Collapsing = needsScores4Collapsing;\n      this.needsScores = needsScores;\n      if (null != sortSpec) {\n        this.collapseStrategy = new IntSortSpecStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores4Collapsing, this.needsScores, boostDocsMap, sortSpec, searcher);\n      } else if (funcQuery != null) {\n        this.collapseStrategy =  new IntValueSourceStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores4Collapsing, this.needsScores, boostDocsMap, funcQuery, searcher);\n      } else {\n        NumberType numType = fieldType.getNumberType();\n        assert null != numType; // shouldn't make it here for non-numeric types\n        switch (numType) {\n          case INTEGER: {\n            this.collapseStrategy = new IntIntStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n            break;\n          }\n          case FLOAT: {\n            this.collapseStrategy = new IntFloatStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n            break;\n          }\n          default: {\n            throw new IOException(\"min/max must be Int or Float field types when collapsing on numeric fields\");\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public IntFieldValueCollector(int maxDoc,\n                                  int size,\n                                  int segments,\n                                  int nullValue,\n                                  int nullPolicy,\n                                  String collapseField,\n                                  GroupHeadSelector groupHeadSelector,\n                                  SortSpec sortSpec,\n                                  boolean needsScores,\n                                  FieldType fieldType,\n                                  IntIntHashMap boostDocsMap,\n                                  FunctionQuery funcQuery,\n                                  IndexSearcher searcher) throws IOException{\n\n      assert ! GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type);\n      \n      this.maxDoc = maxDoc;\n      this.contexts = new LeafReaderContext[segments];\n      this.collapseField = collapseField;\n      this.nullValue = nullValue;\n      this.nullPolicy = nullPolicy;\n      this.needsScores = needsScores;\n      if (null != sortSpec) {\n        this.collapseStrategy = new IntSortSpecStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap, sortSpec, searcher);\n      } else if (funcQuery != null) {\n        this.collapseStrategy =  new IntValueSourceStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap, funcQuery, searcher);\n      } else {\n        NumberType numType = fieldType.getNumberType();\n        assert null != numType; // shouldn't make it here for non-numeric types\n        switch (numType) {\n          case INTEGER: {\n            this.collapseStrategy = new IntIntStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n            break;\n          }\n          case FLOAT: {\n            this.collapseStrategy = new IntFloatStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n            break;\n          }\n          default: {\n            throw new IOException(\"min/max must be Int or Float field types when collapsing on numeric fields\");\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"e9017cf144952056066919f1ebc7897ff9bd71b1":["fa09e86cb64347ee96ff0a59f09b539abd620e57","4d048016075a0b8589fcfc77fdf8e2a29fc80964"],"4d048016075a0b8589fcfc77fdf8e2a29fc80964":["5ea826cad27aae1c1287b70d2eaf0202ec6aa754"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"446ec69a32a7e8cb8bf6eb8be693e96ab5f5a0d3":["4d048016075a0b8589fcfc77fdf8e2a29fc80964"],"fa09e86cb64347ee96ff0a59f09b539abd620e57":["0325de99180d346d61d36938843a5c8451fe26ae"],"0325de99180d346d61d36938843a5c8451fe26ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["446ec69a32a7e8cb8bf6eb8be693e96ab5f5a0d3"],"5ea826cad27aae1c1287b70d2eaf0202ec6aa754":["0325de99180d346d61d36938843a5c8451fe26ae"]},"commit2Childs":{"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"4d048016075a0b8589fcfc77fdf8e2a29fc80964":["e9017cf144952056066919f1ebc7897ff9bd71b1","446ec69a32a7e8cb8bf6eb8be693e96ab5f5a0d3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0325de99180d346d61d36938843a5c8451fe26ae"],"fa09e86cb64347ee96ff0a59f09b539abd620e57":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"446ec69a32a7e8cb8bf6eb8be693e96ab5f5a0d3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0325de99180d346d61d36938843a5c8451fe26ae":["fa09e86cb64347ee96ff0a59f09b539abd620e57","5ea826cad27aae1c1287b70d2eaf0202ec6aa754"],"5ea826cad27aae1c1287b70d2eaf0202ec6aa754":["4d048016075a0b8589fcfc77fdf8e2a29fc80964"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}