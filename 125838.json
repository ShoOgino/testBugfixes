{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#validateIndexSort().mjava","commits":[{"id":"ceaef6cfc68c8ab22a684192e469a8280f9e6e70","date":1462354657,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#validateIndexSort().mjava","pathOld":"/dev/null","sourceNew":"  /** Confirms that the incoming index sort (if any) matches the existing index sort (if any).  This is unfortunately just best effort,\n   *  because it could be the old index only has flushed segments. */\n  private void validateIndexSort() {\n    Sort indexSort = config.getIndexSort();\n    if (indexSort != null) {\n      for(SegmentCommitInfo info : segmentInfos) {\n        Sort segmentIndexSort = info.info.getIndexSort();\n        if (segmentIndexSort != null && indexSort.equals(segmentIndexSort) == false) {\n          throw new IllegalArgumentException(\"cannot change previous indexSort=\" + segmentIndexSort + \" (from segment=\" + info + \") to new indexSort=\" + indexSort);\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["86a0a50d2d14aaee1e635bbec914468551f7f9a2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3d33e731a93d4b57e662ff094f64f94a745422d4","date":1463128289,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#validateIndexSort().mjava","pathOld":"/dev/null","sourceNew":"  /** Confirms that the incoming index sort (if any) matches the existing index sort (if any).  This is unfortunately just best effort,\n   *  because it could be the old index only has flushed segments. */\n  private void validateIndexSort() {\n    Sort indexSort = config.getIndexSort();\n    if (indexSort != null) {\n      for(SegmentCommitInfo info : segmentInfos) {\n        Sort segmentIndexSort = info.info.getIndexSort();\n        if (segmentIndexSort != null && indexSort.equals(segmentIndexSort) == false) {\n          throw new IllegalArgumentException(\"cannot change previous indexSort=\" + segmentIndexSort + \" (from segment=\" + info + \") to new indexSort=\" + indexSort);\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ad30c6a479e764150a3316e57263319775f1df2","date":1463395403,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#validateIndexSort().mjava","pathOld":"/dev/null","sourceNew":"  /** Confirms that the incoming index sort (if any) matches the existing index sort (if any).  This is unfortunately just best effort,\n   *  because it could be the old index only has flushed segments. */\n  private void validateIndexSort() {\n    Sort indexSort = config.getIndexSort();\n    if (indexSort != null) {\n      for(SegmentCommitInfo info : segmentInfos) {\n        Sort segmentIndexSort = info.info.getIndexSort();\n        if (segmentIndexSort != null && indexSort.equals(segmentIndexSort) == false) {\n          throw new IllegalArgumentException(\"cannot change previous indexSort=\" + segmentIndexSort + \" (from segment=\" + info + \") to new indexSort=\" + indexSort);\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#validateIndexSort().mjava","pathOld":"/dev/null","sourceNew":"  /** Confirms that the incoming index sort (if any) matches the existing index sort (if any).  This is unfortunately just best effort,\n   *  because it could be the old index only has flushed segments. */\n  private void validateIndexSort() {\n    Sort indexSort = config.getIndexSort();\n    if (indexSort != null) {\n      for(SegmentCommitInfo info : segmentInfos) {\n        Sort segmentIndexSort = info.info.getIndexSort();\n        if (segmentIndexSort != null && indexSort.equals(segmentIndexSort) == false) {\n          throw new IllegalArgumentException(\"cannot change previous indexSort=\" + segmentIndexSort + \" (from segment=\" + info + \") to new indexSort=\" + indexSort);\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#validateIndexSort().mjava","pathOld":"/dev/null","sourceNew":"  /** Confirms that the incoming index sort (if any) matches the existing index sort (if any).  This is unfortunately just best effort,\n   *  because it could be the old index only has flushed segments. */\n  private void validateIndexSort() {\n    Sort indexSort = config.getIndexSort();\n    if (indexSort != null) {\n      for(SegmentCommitInfo info : segmentInfos) {\n        Sort segmentIndexSort = info.info.getIndexSort();\n        if (segmentIndexSort != null && indexSort.equals(segmentIndexSort) == false) {\n          throw new IllegalArgumentException(\"cannot change previous indexSort=\" + segmentIndexSort + \" (from segment=\" + info + \") to new indexSort=\" + indexSort);\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"86a0a50d2d14aaee1e635bbec914468551f7f9a2","date":1482234306,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#validateIndexSort().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#validateIndexSort().mjava","sourceNew":"  /** Confirms that the incoming index sort (if any) matches the existing index sort (if any).\n   *  This is unfortunately just best effort, because it could be the old index only has unsorted flushed segments built\n   *  before {@link Version#LUCENE_7_0_0} (flushed segments are sorted in Lucene 7.0).  */\n  private void validateIndexSort() {\n    Sort indexSort = config.getIndexSort();\n    if (indexSort != null) {\n      for(SegmentCommitInfo info : segmentInfos) {\n        Sort segmentIndexSort = info.info.getIndexSort();\n        if (segmentIndexSort != null && indexSort.equals(segmentIndexSort) == false) {\n          throw new IllegalArgumentException(\"cannot change previous indexSort=\" + segmentIndexSort + \" (from segment=\" + info + \") to new indexSort=\" + indexSort);\n        } else if (segmentIndexSort == null) {\n          // Flushed segments are not sorted if they were built with a version prior to 7.0\n          assert info.info.getVersion().onOrAfter(Version.LUCENE_7_0_0) == false;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Confirms that the incoming index sort (if any) matches the existing index sort (if any).  This is unfortunately just best effort,\n   *  because it could be the old index only has flushed segments. */\n  private void validateIndexSort() {\n    Sort indexSort = config.getIndexSort();\n    if (indexSort != null) {\n      for(SegmentCommitInfo info : segmentInfos) {\n        Sort segmentIndexSort = info.info.getIndexSort();\n        if (segmentIndexSort != null && indexSort.equals(segmentIndexSort) == false) {\n          throw new IllegalArgumentException(\"cannot change previous indexSort=\" + segmentIndexSort + \" (from segment=\" + info + \") to new indexSort=\" + indexSort);\n        }\n      }\n    }\n  }\n\n","bugFix":["ceaef6cfc68c8ab22a684192e469a8280f9e6e70"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","date":1482251961,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#validateIndexSort().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#validateIndexSort().mjava","sourceNew":"  /** Confirms that the incoming index sort (if any) matches the existing index sort (if any).\n   *  This is unfortunately just best effort, because it could be the old index only has unsorted flushed segments built\n   *  before {@link Version#LUCENE_7_0_0} (flushed segments are sorted in Lucene 7.0).  */\n  private void validateIndexSort() {\n    Sort indexSort = config.getIndexSort();\n    if (indexSort != null) {\n      for(SegmentCommitInfo info : segmentInfos) {\n        Sort segmentIndexSort = info.info.getIndexSort();\n        if (segmentIndexSort != null && indexSort.equals(segmentIndexSort) == false) {\n          throw new IllegalArgumentException(\"cannot change previous indexSort=\" + segmentIndexSort + \" (from segment=\" + info + \") to new indexSort=\" + indexSort);\n        } else if (segmentIndexSort == null) {\n          // Flushed segments are not sorted if they were built with a version prior to 7.0\n          assert info.info.getVersion().onOrAfter(Version.LUCENE_7_0_0) == false;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Confirms that the incoming index sort (if any) matches the existing index sort (if any).  This is unfortunately just best effort,\n   *  because it could be the old index only has flushed segments. */\n  private void validateIndexSort() {\n    Sort indexSort = config.getIndexSort();\n    if (indexSort != null) {\n      for(SegmentCommitInfo info : segmentInfos) {\n        Sort segmentIndexSort = info.info.getIndexSort();\n        if (segmentIndexSort != null && indexSort.equals(segmentIndexSort) == false) {\n          throw new IllegalArgumentException(\"cannot change previous indexSort=\" + segmentIndexSort + \" (from segment=\" + info + \") to new indexSort=\" + indexSort);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b31aa9374598567491a72318d1446061cdd4a759","date":1484659367,"type":3,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#validateIndexSort().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#validateIndexSort().mjava","sourceNew":"  /** Confirms that the incoming index sort (if any) matches the existing index sort (if any).\n   *  This is unfortunately just best effort, because it could be the old index only has unsorted flushed segments built\n   *  before {@link Version#LUCENE_6_5_0} (flushed segments are sorted in Lucene 7.0).  */\n  private void validateIndexSort() throws CorruptIndexException {\n    Sort indexSort = config.getIndexSort();\n    if (indexSort != null) {\n      for(SegmentCommitInfo info : segmentInfos) {\n        Sort segmentIndexSort = info.info.getIndexSort();\n        if (segmentIndexSort != null && indexSort.equals(segmentIndexSort) == false) {\n          throw new IllegalArgumentException(\"cannot change previous indexSort=\" + segmentIndexSort + \" (from segment=\" + info + \") to new indexSort=\" + indexSort);\n        } else if (segmentIndexSort == null && info.info.getVersion().onOrAfter(Version.LUCENE_6_5_0)) {\n          // Flushed segments are not sorted if they were built with a version prior to 6.5.0\n          throw new CorruptIndexException(\"segment not sorted with indexSort=\" + segmentIndexSort, info.info.toString());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Confirms that the incoming index sort (if any) matches the existing index sort (if any).\n   *  This is unfortunately just best effort, because it could be the old index only has unsorted flushed segments built\n   *  before {@link Version#LUCENE_7_0_0} (flushed segments are sorted in Lucene 7.0).  */\n  private void validateIndexSort() {\n    Sort indexSort = config.getIndexSort();\n    if (indexSort != null) {\n      for(SegmentCommitInfo info : segmentInfos) {\n        Sort segmentIndexSort = info.info.getIndexSort();\n        if (segmentIndexSort != null && indexSort.equals(segmentIndexSort) == false) {\n          throw new IllegalArgumentException(\"cannot change previous indexSort=\" + segmentIndexSort + \" (from segment=\" + info + \") to new indexSort=\" + indexSort);\n        } else if (segmentIndexSort == null) {\n          // Flushed segments are not sorted if they were built with a version prior to 7.0\n          assert info.info.getVersion().onOrAfter(Version.LUCENE_7_0_0) == false;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"302d34f2c66e8d489ee13078305c330cbf67b226","date":1484754357,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#validateIndexSort().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#validateIndexSort().mjava","sourceNew":"  /** Confirms that the incoming index sort (if any) matches the existing index sort (if any).\n   *  This is unfortunately just best effort, because it could be the old index only has unsorted flushed segments built\n   *  before {@link Version#LUCENE_6_5_0} (flushed segments are sorted in Lucene 7.0).  */\n  private void validateIndexSort() throws CorruptIndexException {\n    Sort indexSort = config.getIndexSort();\n    if (indexSort != null) {\n      for(SegmentCommitInfo info : segmentInfos) {\n        Sort segmentIndexSort = info.info.getIndexSort();\n        if (segmentIndexSort != null && indexSort.equals(segmentIndexSort) == false) {\n          throw new IllegalArgumentException(\"cannot change previous indexSort=\" + segmentIndexSort + \" (from segment=\" + info + \") to new indexSort=\" + indexSort);\n        } else if (segmentIndexSort == null && info.info.getVersion().onOrAfter(Version.LUCENE_6_5_0)) {\n          // Flushed segments are not sorted if they were built with a version prior to 6.5.0\n          throw new CorruptIndexException(\"segment not sorted with indexSort=\" + segmentIndexSort, info.info.toString());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Confirms that the incoming index sort (if any) matches the existing index sort (if any).\n   *  This is unfortunately just best effort, because it could be the old index only has unsorted flushed segments built\n   *  before {@link Version#LUCENE_7_0_0} (flushed segments are sorted in Lucene 7.0).  */\n  private void validateIndexSort() {\n    Sort indexSort = config.getIndexSort();\n    if (indexSort != null) {\n      for(SegmentCommitInfo info : segmentInfos) {\n        Sort segmentIndexSort = info.info.getIndexSort();\n        if (segmentIndexSort != null && indexSort.equals(segmentIndexSort) == false) {\n          throw new IllegalArgumentException(\"cannot change previous indexSort=\" + segmentIndexSort + \" (from segment=\" + info + \") to new indexSort=\" + indexSort);\n        } else if (segmentIndexSort == null) {\n          // Flushed segments are not sorted if they were built with a version prior to 7.0\n          assert info.info.getVersion().onOrAfter(Version.LUCENE_7_0_0) == false;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cd7538cbbd9c304bc5396980e9802cd3a5bcf8e4","date":1499084229,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#validateIndexSort().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#validateIndexSort().mjava","sourceNew":"  /** Confirms that the incoming index sort (if any) matches the existing index sort (if any).  */\n  private void validateIndexSort() throws CorruptIndexException {\n    Sort indexSort = config.getIndexSort();\n    if (indexSort != null) {\n      for(SegmentCommitInfo info : segmentInfos) {\n        Sort segmentIndexSort = info.info.getIndexSort();\n        if (segmentIndexSort != null && indexSort.equals(segmentIndexSort) == false) {\n          throw new IllegalArgumentException(\"cannot change previous indexSort=\" + segmentIndexSort + \" (from segment=\" + info + \") to new indexSort=\" + indexSort);\n        } else if (segmentIndexSort == null) {\n          // Flushed segments are not sorted if they were built with a version prior to 6.5.0\n          throw new CorruptIndexException(\"segment not sorted with indexSort=\" + segmentIndexSort, info.info.toString());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Confirms that the incoming index sort (if any) matches the existing index sort (if any).\n   *  This is unfortunately just best effort, because it could be the old index only has unsorted flushed segments built\n   *  before {@link Version#LUCENE_6_5_0} (flushed segments are sorted in Lucene 7.0).  */\n  private void validateIndexSort() throws CorruptIndexException {\n    Sort indexSort = config.getIndexSort();\n    if (indexSort != null) {\n      for(SegmentCommitInfo info : segmentInfos) {\n        Sort segmentIndexSort = info.info.getIndexSort();\n        if (segmentIndexSort != null && indexSort.equals(segmentIndexSort) == false) {\n          throw new IllegalArgumentException(\"cannot change previous indexSort=\" + segmentIndexSort + \" (from segment=\" + info + \") to new indexSort=\" + indexSort);\n        } else if (segmentIndexSort == null && info.info.getVersion().onOrAfter(Version.LUCENE_6_5_0)) {\n          // Flushed segments are not sorted if they were built with a version prior to 6.5.0\n          throw new CorruptIndexException(\"segment not sorted with indexSort=\" + segmentIndexSort, info.info.toString());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cc018b79379c67835b40b1259cd3dc931df60944","date":1499109112,"type":3,"author":"Anshum Gupta","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#validateIndexSort().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#validateIndexSort().mjava","sourceNew":"  /** Confirms that the incoming index sort (if any) matches the existing index sort (if any).  */\n  private void validateIndexSort() throws CorruptIndexException {\n    Sort indexSort = config.getIndexSort();\n    if (indexSort != null) {\n      for(SegmentCommitInfo info : segmentInfos) {\n        Sort segmentIndexSort = info.info.getIndexSort();\n        if (segmentIndexSort != null && indexSort.equals(segmentIndexSort) == false) {\n          throw new IllegalArgumentException(\"cannot change previous indexSort=\" + segmentIndexSort + \" (from segment=\" + info + \") to new indexSort=\" + indexSort);\n        } else if (segmentIndexSort == null) {\n          // Flushed segments are not sorted if they were built with a version prior to 6.5.0\n          throw new CorruptIndexException(\"segment not sorted with indexSort=\" + segmentIndexSort, info.info.toString());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Confirms that the incoming index sort (if any) matches the existing index sort (if any).\n   *  This is unfortunately just best effort, because it could be the old index only has unsorted flushed segments built\n   *  before {@link Version#LUCENE_6_5_0} (flushed segments are sorted in Lucene 7.0).  */\n  private void validateIndexSort() throws CorruptIndexException {\n    Sort indexSort = config.getIndexSort();\n    if (indexSort != null) {\n      for(SegmentCommitInfo info : segmentInfos) {\n        Sort segmentIndexSort = info.info.getIndexSort();\n        if (segmentIndexSort != null && indexSort.equals(segmentIndexSort) == false) {\n          throw new IllegalArgumentException(\"cannot change previous indexSort=\" + segmentIndexSort + \" (from segment=\" + info + \") to new indexSort=\" + indexSort);\n        } else if (segmentIndexSort == null && info.info.getVersion().onOrAfter(Version.LUCENE_6_5_0)) {\n          // Flushed segments are not sorted if they were built with a version prior to 6.5.0\n          throw new CorruptIndexException(\"segment not sorted with indexSort=\" + segmentIndexSort, info.info.toString());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30c8e5574b55d57947e989443dfde611646530ee","date":1499131153,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#validateIndexSort().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#validateIndexSort().mjava","sourceNew":"  /** Confirms that the incoming index sort (if any) matches the existing index sort (if any).  */\n  private void validateIndexSort() throws CorruptIndexException {\n    Sort indexSort = config.getIndexSort();\n    if (indexSort != null) {\n      for(SegmentCommitInfo info : segmentInfos) {\n        Sort segmentIndexSort = info.info.getIndexSort();\n        if (segmentIndexSort != null && indexSort.equals(segmentIndexSort) == false) {\n          throw new IllegalArgumentException(\"cannot change previous indexSort=\" + segmentIndexSort + \" (from segment=\" + info + \") to new indexSort=\" + indexSort);\n        } else if (segmentIndexSort == null) {\n          // Flushed segments are not sorted if they were built with a version prior to 6.5.0\n          throw new CorruptIndexException(\"segment not sorted with indexSort=\" + segmentIndexSort, info.info.toString());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Confirms that the incoming index sort (if any) matches the existing index sort (if any).\n   *  This is unfortunately just best effort, because it could be the old index only has unsorted flushed segments built\n   *  before {@link Version#LUCENE_6_5_0} (flushed segments are sorted in Lucene 7.0).  */\n  private void validateIndexSort() throws CorruptIndexException {\n    Sort indexSort = config.getIndexSort();\n    if (indexSort != null) {\n      for(SegmentCommitInfo info : segmentInfos) {\n        Sort segmentIndexSort = info.info.getIndexSort();\n        if (segmentIndexSort != null && indexSort.equals(segmentIndexSort) == false) {\n          throw new IllegalArgumentException(\"cannot change previous indexSort=\" + segmentIndexSort + \" (from segment=\" + info + \") to new indexSort=\" + indexSort);\n        } else if (segmentIndexSort == null && info.info.getVersion().onOrAfter(Version.LUCENE_6_5_0)) {\n          // Flushed segments are not sorted if they were built with a version prior to 6.5.0\n          throw new CorruptIndexException(\"segment not sorted with indexSort=\" + segmentIndexSort, info.info.toString());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6e22133c22c69a013e8c3c14bb986e7848c7296e","date":1537859647,"type":3,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#validateIndexSort().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#validateIndexSort().mjava","sourceNew":"  /** Confirms that the incoming index sort (if any) matches the existing index sort (if any).  */\n  private void validateIndexSort() {\n    Sort indexSort = config.getIndexSort();\n    if (indexSort != null) {\n      for(SegmentCommitInfo info : segmentInfos) {\n        Sort segmentIndexSort = info.info.getIndexSort();\n        if (segmentIndexSort == null || isCongruentSort(indexSort, segmentIndexSort) == false) {\n          throw new IllegalArgumentException(\"cannot change previous indexSort=\" + segmentIndexSort + \" (from segment=\" + info + \") to new indexSort=\" + indexSort);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Confirms that the incoming index sort (if any) matches the existing index sort (if any).  */\n  private void validateIndexSort() throws CorruptIndexException {\n    Sort indexSort = config.getIndexSort();\n    if (indexSort != null) {\n      for(SegmentCommitInfo info : segmentInfos) {\n        Sort segmentIndexSort = info.info.getIndexSort();\n        if (segmentIndexSort != null && indexSort.equals(segmentIndexSort) == false) {\n          throw new IllegalArgumentException(\"cannot change previous indexSort=\" + segmentIndexSort + \" (from segment=\" + info + \") to new indexSort=\" + indexSort);\n        } else if (segmentIndexSort == null) {\n          // Flushed segments are not sorted if they were built with a version prior to 6.5.0\n          throw new CorruptIndexException(\"segment not sorted with indexSort=\" + segmentIndexSort, info.info.toString());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"30c8e5574b55d57947e989443dfde611646530ee":["b31aa9374598567491a72318d1446061cdd4a759","cc018b79379c67835b40b1259cd3dc931df60944"],"0ad30c6a479e764150a3316e57263319775f1df2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3d33e731a93d4b57e662ff094f64f94a745422d4"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d470c8182e92b264680e34081b75e70a9f2b3c89"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0ad30c6a479e764150a3316e57263319775f1df2"],"cd7538cbbd9c304bc5396980e9802cd3a5bcf8e4":["b31aa9374598567491a72318d1446061cdd4a759"],"302d34f2c66e8d489ee13078305c330cbf67b226":["5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","b31aa9374598567491a72318d1446061cdd4a759"],"6e22133c22c69a013e8c3c14bb986e7848c7296e":["cc018b79379c67835b40b1259cd3dc931df60944"],"ceaef6cfc68c8ab22a684192e469a8280f9e6e70":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","86a0a50d2d14aaee1e635bbec914468551f7f9a2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cc018b79379c67835b40b1259cd3dc931df60944":["b31aa9374598567491a72318d1446061cdd4a759","cd7538cbbd9c304bc5396980e9802cd3a5bcf8e4"],"b31aa9374598567491a72318d1446061cdd4a759":["86a0a50d2d14aaee1e635bbec914468551f7f9a2"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ceaef6cfc68c8ab22a684192e469a8280f9e6e70"],"86a0a50d2d14aaee1e635bbec914468551f7f9a2":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6e22133c22c69a013e8c3c14bb986e7848c7296e"]},"commit2Childs":{"30c8e5574b55d57947e989443dfde611646530ee":[],"0ad30c6a479e764150a3316e57263319775f1df2":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","86a0a50d2d14aaee1e635bbec914468551f7f9a2"],"cd7538cbbd9c304bc5396980e9802cd3a5bcf8e4":["cc018b79379c67835b40b1259cd3dc931df60944"],"302d34f2c66e8d489ee13078305c330cbf67b226":[],"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf":["302d34f2c66e8d489ee13078305c330cbf67b226"],"6e22133c22c69a013e8c3c14bb986e7848c7296e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ceaef6cfc68c8ab22a684192e469a8280f9e6e70":["3d33e731a93d4b57e662ff094f64f94a745422d4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0ad30c6a479e764150a3316e57263319775f1df2","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","ceaef6cfc68c8ab22a684192e469a8280f9e6e70","3d33e731a93d4b57e662ff094f64f94a745422d4"],"cc018b79379c67835b40b1259cd3dc931df60944":["30c8e5574b55d57947e989443dfde611646530ee","6e22133c22c69a013e8c3c14bb986e7848c7296e"],"b31aa9374598567491a72318d1446061cdd4a759":["30c8e5574b55d57947e989443dfde611646530ee","cd7538cbbd9c304bc5396980e9802cd3a5bcf8e4","302d34f2c66e8d489ee13078305c330cbf67b226","cc018b79379c67835b40b1259cd3dc931df60944"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["0ad30c6a479e764150a3316e57263319775f1df2"],"86a0a50d2d14aaee1e635bbec914468551f7f9a2":["5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","b31aa9374598567491a72318d1446061cdd4a759"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["30c8e5574b55d57947e989443dfde611646530ee","302d34f2c66e8d489ee13078305c330cbf67b226","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}