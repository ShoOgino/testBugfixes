{"path":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(Analyzer,BooleanClause.Occur,String,String,boolean,int).mjava","commits":[{"id":"c1c1dd5dce93e4fa48898dabc7e012560acda425","date":1381334364,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(Analyzer,BooleanClause.Occur,String,String,boolean,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Creates a query from the analysis chain.\n   * <p>\n   * Expert: this is more useful for subclasses such as queryparsers. \n   * If using this class directly, just use {@link #createBooleanQuery(String, String)}\n   * and {@link #createPhraseQuery(String, String)}\n   * @param analyzer analyzer used for this query\n   * @param operator default boolean operator used for this query\n   * @param field field to create queries against\n   * @param queryText text to be passed to the analysis chain\n   * @param quoted true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected final Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n    CachingTokenFilter buffer = null;\n    TermToBytesRefAttribute termAtt = null;\n    PositionIncrementAttribute posIncrAtt = null;\n    int numTokens = 0;\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n    boolean hasMoreTokens = false;    \n    \n    try (TokenStream source = analyzer.tokenStream(field, queryText)) {\n      source.reset();\n      buffer = new CachingTokenFilter(source);\n      buffer.reset();\n\n      if (buffer.hasAttribute(TermToBytesRefAttribute.class)) {\n        termAtt = buffer.getAttribute(TermToBytesRefAttribute.class);\n      }\n      if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n        posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n      }\n\n      if (termAtt != null) {\n        try {\n          hasMoreTokens = buffer.incrementToken();\n          while (hasMoreTokens) {\n            numTokens++;\n            int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;\n            if (positionIncrement != 0) {\n              positionCount += positionIncrement;\n            } else {\n              severalTokensAtSamePosition = true;\n            }\n            hasMoreTokens = buffer.incrementToken();\n          }\n        } catch (IOException e) {\n          // ignore\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n    \n    // rewind the buffer stream\n    buffer.reset();\n\n    BytesRef bytes = termAtt == null ? null : termAtt.getBytesRef();\n\n    if (numTokens == 0)\n      return null;\n    else if (numTokens == 1) {\n      try {\n        boolean hasNext = buffer.incrementToken();\n        assert hasNext == true;\n        termAtt.fillBytesRef();\n      } catch (IOException e) {\n        // safe to ignore, because we know the number of tokens\n      }\n      return newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));\n    } else {\n      if (severalTokensAtSamePosition || (!quoted)) {\n        if (positionCount == 1 || (!quoted)) {\n          // no phrase query:\n          \n          if (positionCount == 1) {\n            // simple case: only one position, with synonyms\n            BooleanQuery q = newBooleanQuery(true);\n            for (int i = 0; i < numTokens; i++) {\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                termAtt.fillBytesRef();\n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n              Query currentQuery = newTermQuery(\n                  new Term(field, BytesRef.deepCopyOf(bytes)));\n              q.add(currentQuery, BooleanClause.Occur.SHOULD);\n            }\n            return q;\n          } else {\n            // multiple positions\n            BooleanQuery q = newBooleanQuery(false);\n            Query currentQuery = null;\n            for (int i = 0; i < numTokens; i++) {\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                termAtt.fillBytesRef();\n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n              if (posIncrAtt != null && posIncrAtt.getPositionIncrement() == 0) {\n                if (!(currentQuery instanceof BooleanQuery)) {\n                  Query t = currentQuery;\n                  currentQuery = newBooleanQuery(true);\n                  ((BooleanQuery)currentQuery).add(t, BooleanClause.Occur.SHOULD);\n                }\n                ((BooleanQuery)currentQuery).add(newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes))), BooleanClause.Occur.SHOULD);\n              } else {\n                if (currentQuery != null) {\n                  q.add(currentQuery, operator);\n                }\n                currentQuery = newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));\n              }\n            }\n            q.add(currentQuery, operator);\n            return q;\n          }\n        } else {\n          // phrase query:\n          MultiPhraseQuery mpq = newMultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List<Term> multiTerms = new ArrayList<Term>();\n          int position = -1;\n          for (int i = 0; i < numTokens; i++) {\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              termAtt.fillBytesRef();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add(multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add(multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += positionIncrement;\n            multiTerms.add(new Term(field, BytesRef.deepCopyOf(bytes)));\n          }\n          if (enablePositionIncrements) {\n            mpq.add(multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add(multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      } else {\n        PhraseQuery pq = newPhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n\n        for (int i = 0; i < numTokens; i++) {\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            termAtt.fillBytesRef();\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          if (enablePositionIncrements) {\n            position += positionIncrement;\n            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)),position);\n          } else {\n            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["8b49777657109e40eeddc1c8b0f7850d3c06e1ed"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(Analyzer,BooleanClause.Occur,String,String,boolean,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(Analyzer,BooleanClause.Occur,String,String,boolean,int).mjava","sourceNew":"  /**\n   * Creates a query from the analysis chain.\n   * <p>\n   * Expert: this is more useful for subclasses such as queryparsers. \n   * If using this class directly, just use {@link #createBooleanQuery(String, String)}\n   * and {@link #createPhraseQuery(String, String)}\n   * @param analyzer analyzer used for this query\n   * @param operator default boolean operator used for this query\n   * @param field field to create queries against\n   * @param queryText text to be passed to the analysis chain\n   * @param quoted true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected final Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n    CachingTokenFilter buffer = null;\n    TermToBytesRefAttribute termAtt = null;\n    PositionIncrementAttribute posIncrAtt = null;\n    int numTokens = 0;\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n    boolean hasMoreTokens = false;    \n    \n    try (TokenStream source = analyzer.tokenStream(field, queryText)) {\n      source.reset();\n      buffer = new CachingTokenFilter(source);\n      buffer.reset();\n\n      if (buffer.hasAttribute(TermToBytesRefAttribute.class)) {\n        termAtt = buffer.getAttribute(TermToBytesRefAttribute.class);\n      }\n      if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n        posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n      }\n\n      if (termAtt != null) {\n        try {\n          hasMoreTokens = buffer.incrementToken();\n          while (hasMoreTokens) {\n            numTokens++;\n            int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;\n            if (positionIncrement != 0) {\n              positionCount += positionIncrement;\n            } else {\n              severalTokensAtSamePosition = true;\n            }\n            hasMoreTokens = buffer.incrementToken();\n          }\n        } catch (IOException e) {\n          // ignore\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n    \n    // rewind the buffer stream\n    buffer.reset();\n\n    BytesRef bytes = termAtt == null ? null : termAtt.getBytesRef();\n\n    if (numTokens == 0)\n      return null;\n    else if (numTokens == 1) {\n      try {\n        boolean hasNext = buffer.incrementToken();\n        assert hasNext == true;\n        termAtt.fillBytesRef();\n      } catch (IOException e) {\n        // safe to ignore, because we know the number of tokens\n      }\n      return newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));\n    } else {\n      if (severalTokensAtSamePosition || (!quoted)) {\n        if (positionCount == 1 || (!quoted)) {\n          // no phrase query:\n          \n          if (positionCount == 1) {\n            // simple case: only one position, with synonyms\n            BooleanQuery q = newBooleanQuery(true);\n            for (int i = 0; i < numTokens; i++) {\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                termAtt.fillBytesRef();\n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n              Query currentQuery = newTermQuery(\n                  new Term(field, BytesRef.deepCopyOf(bytes)));\n              q.add(currentQuery, BooleanClause.Occur.SHOULD);\n            }\n            return q;\n          } else {\n            // multiple positions\n            BooleanQuery q = newBooleanQuery(false);\n            Query currentQuery = null;\n            for (int i = 0; i < numTokens; i++) {\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                termAtt.fillBytesRef();\n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n              if (posIncrAtt != null && posIncrAtt.getPositionIncrement() == 0) {\n                if (!(currentQuery instanceof BooleanQuery)) {\n                  Query t = currentQuery;\n                  currentQuery = newBooleanQuery(true);\n                  ((BooleanQuery)currentQuery).add(t, BooleanClause.Occur.SHOULD);\n                }\n                ((BooleanQuery)currentQuery).add(newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes))), BooleanClause.Occur.SHOULD);\n              } else {\n                if (currentQuery != null) {\n                  q.add(currentQuery, operator);\n                }\n                currentQuery = newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));\n              }\n            }\n            q.add(currentQuery, operator);\n            return q;\n          }\n        } else {\n          // phrase query:\n          MultiPhraseQuery mpq = newMultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List<Term> multiTerms = new ArrayList<>();\n          int position = -1;\n          for (int i = 0; i < numTokens; i++) {\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              termAtt.fillBytesRef();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add(multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add(multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += positionIncrement;\n            multiTerms.add(new Term(field, BytesRef.deepCopyOf(bytes)));\n          }\n          if (enablePositionIncrements) {\n            mpq.add(multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add(multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      } else {\n        PhraseQuery pq = newPhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n\n        for (int i = 0; i < numTokens; i++) {\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            termAtt.fillBytesRef();\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          if (enablePositionIncrements) {\n            position += positionIncrement;\n            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)),position);\n          } else {\n            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a query from the analysis chain.\n   * <p>\n   * Expert: this is more useful for subclasses such as queryparsers. \n   * If using this class directly, just use {@link #createBooleanQuery(String, String)}\n   * and {@link #createPhraseQuery(String, String)}\n   * @param analyzer analyzer used for this query\n   * @param operator default boolean operator used for this query\n   * @param field field to create queries against\n   * @param queryText text to be passed to the analysis chain\n   * @param quoted true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected final Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n    CachingTokenFilter buffer = null;\n    TermToBytesRefAttribute termAtt = null;\n    PositionIncrementAttribute posIncrAtt = null;\n    int numTokens = 0;\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n    boolean hasMoreTokens = false;    \n    \n    try (TokenStream source = analyzer.tokenStream(field, queryText)) {\n      source.reset();\n      buffer = new CachingTokenFilter(source);\n      buffer.reset();\n\n      if (buffer.hasAttribute(TermToBytesRefAttribute.class)) {\n        termAtt = buffer.getAttribute(TermToBytesRefAttribute.class);\n      }\n      if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n        posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n      }\n\n      if (termAtt != null) {\n        try {\n          hasMoreTokens = buffer.incrementToken();\n          while (hasMoreTokens) {\n            numTokens++;\n            int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;\n            if (positionIncrement != 0) {\n              positionCount += positionIncrement;\n            } else {\n              severalTokensAtSamePosition = true;\n            }\n            hasMoreTokens = buffer.incrementToken();\n          }\n        } catch (IOException e) {\n          // ignore\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n    \n    // rewind the buffer stream\n    buffer.reset();\n\n    BytesRef bytes = termAtt == null ? null : termAtt.getBytesRef();\n\n    if (numTokens == 0)\n      return null;\n    else if (numTokens == 1) {\n      try {\n        boolean hasNext = buffer.incrementToken();\n        assert hasNext == true;\n        termAtt.fillBytesRef();\n      } catch (IOException e) {\n        // safe to ignore, because we know the number of tokens\n      }\n      return newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));\n    } else {\n      if (severalTokensAtSamePosition || (!quoted)) {\n        if (positionCount == 1 || (!quoted)) {\n          // no phrase query:\n          \n          if (positionCount == 1) {\n            // simple case: only one position, with synonyms\n            BooleanQuery q = newBooleanQuery(true);\n            for (int i = 0; i < numTokens; i++) {\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                termAtt.fillBytesRef();\n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n              Query currentQuery = newTermQuery(\n                  new Term(field, BytesRef.deepCopyOf(bytes)));\n              q.add(currentQuery, BooleanClause.Occur.SHOULD);\n            }\n            return q;\n          } else {\n            // multiple positions\n            BooleanQuery q = newBooleanQuery(false);\n            Query currentQuery = null;\n            for (int i = 0; i < numTokens; i++) {\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                termAtt.fillBytesRef();\n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n              if (posIncrAtt != null && posIncrAtt.getPositionIncrement() == 0) {\n                if (!(currentQuery instanceof BooleanQuery)) {\n                  Query t = currentQuery;\n                  currentQuery = newBooleanQuery(true);\n                  ((BooleanQuery)currentQuery).add(t, BooleanClause.Occur.SHOULD);\n                }\n                ((BooleanQuery)currentQuery).add(newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes))), BooleanClause.Occur.SHOULD);\n              } else {\n                if (currentQuery != null) {\n                  q.add(currentQuery, operator);\n                }\n                currentQuery = newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));\n              }\n            }\n            q.add(currentQuery, operator);\n            return q;\n          }\n        } else {\n          // phrase query:\n          MultiPhraseQuery mpq = newMultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List<Term> multiTerms = new ArrayList<Term>();\n          int position = -1;\n          for (int i = 0; i < numTokens; i++) {\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              termAtt.fillBytesRef();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add(multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add(multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += positionIncrement;\n            multiTerms.add(new Term(field, BytesRef.deepCopyOf(bytes)));\n          }\n          if (enablePositionIncrements) {\n            mpq.add(multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add(multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      } else {\n        PhraseQuery pq = newPhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n\n        for (int i = 0; i < numTokens; i++) {\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            termAtt.fillBytesRef();\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          if (enablePositionIncrements) {\n            position += positionIncrement;\n            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)),position);\n          } else {\n            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["8b49777657109e40eeddc1c8b0f7850d3c06e1ed"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"63241596de245e96a0a3c36c7b03eb92130b81db","date":1398708795,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(Analyzer,BooleanClause.Occur,String,String,boolean,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(Analyzer,BooleanClause.Occur,String,String,boolean,int).mjava","sourceNew":"  /**\n   * Creates a query from the analysis chain.\n   * <p>\n   * Expert: this is more useful for subclasses such as queryparsers. \n   * If using this class directly, just use {@link #createBooleanQuery(String, String)}\n   * and {@link #createPhraseQuery(String, String)}\n   * @param analyzer analyzer used for this query\n   * @param operator default boolean operator used for this query\n   * @param field field to create queries against\n   * @param queryText text to be passed to the analysis chain\n   * @param quoted true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected final Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n    CachingTokenFilter buffer = null;\n    TermToBytesRefAttribute termAtt = null;\n    PositionIncrementAttribute posIncrAtt = null;\n    int numTokens = 0;\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n    boolean hasMoreTokens = false;    \n    \n    try (TokenStream source = analyzer.tokenStream(field, queryText)) {\n      source.reset();\n      buffer = new CachingTokenFilter(source);\n      buffer.reset();\n\n      termAtt = buffer.getAttribute(TermToBytesRefAttribute.class);\n      posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n\n      if (termAtt != null) {\n        try {\n          hasMoreTokens = buffer.incrementToken();\n          while (hasMoreTokens) {\n            numTokens++;\n            int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;\n            if (positionIncrement != 0) {\n              positionCount += positionIncrement;\n            } else {\n              severalTokensAtSamePosition = true;\n            }\n            hasMoreTokens = buffer.incrementToken();\n          }\n        } catch (IOException e) {\n          // ignore\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n    \n    // rewind the buffer stream\n    buffer.reset();\n\n    BytesRef bytes = termAtt == null ? null : termAtt.getBytesRef();\n\n    if (numTokens == 0)\n      return null;\n    else if (numTokens == 1) {\n      try {\n        boolean hasNext = buffer.incrementToken();\n        assert hasNext == true;\n        termAtt.fillBytesRef();\n      } catch (IOException e) {\n        // safe to ignore, because we know the number of tokens\n      }\n      return newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));\n    } else {\n      if (severalTokensAtSamePosition || (!quoted)) {\n        if (positionCount == 1 || (!quoted)) {\n          // no phrase query:\n          \n          if (positionCount == 1) {\n            // simple case: only one position, with synonyms\n            BooleanQuery q = newBooleanQuery(true);\n            for (int i = 0; i < numTokens; i++) {\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                termAtt.fillBytesRef();\n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n              Query currentQuery = newTermQuery(\n                  new Term(field, BytesRef.deepCopyOf(bytes)));\n              q.add(currentQuery, BooleanClause.Occur.SHOULD);\n            }\n            return q;\n          } else {\n            // multiple positions\n            BooleanQuery q = newBooleanQuery(false);\n            Query currentQuery = null;\n            for (int i = 0; i < numTokens; i++) {\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                termAtt.fillBytesRef();\n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n              if (posIncrAtt != null && posIncrAtt.getPositionIncrement() == 0) {\n                if (!(currentQuery instanceof BooleanQuery)) {\n                  Query t = currentQuery;\n                  currentQuery = newBooleanQuery(true);\n                  ((BooleanQuery)currentQuery).add(t, BooleanClause.Occur.SHOULD);\n                }\n                ((BooleanQuery)currentQuery).add(newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes))), BooleanClause.Occur.SHOULD);\n              } else {\n                if (currentQuery != null) {\n                  q.add(currentQuery, operator);\n                }\n                currentQuery = newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));\n              }\n            }\n            q.add(currentQuery, operator);\n            return q;\n          }\n        } else {\n          // phrase query:\n          MultiPhraseQuery mpq = newMultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List<Term> multiTerms = new ArrayList<>();\n          int position = -1;\n          for (int i = 0; i < numTokens; i++) {\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              termAtt.fillBytesRef();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add(multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add(multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += positionIncrement;\n            multiTerms.add(new Term(field, BytesRef.deepCopyOf(bytes)));\n          }\n          if (enablePositionIncrements) {\n            mpq.add(multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add(multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      } else {\n        PhraseQuery pq = newPhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n\n        for (int i = 0; i < numTokens; i++) {\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            termAtt.fillBytesRef();\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          if (enablePositionIncrements) {\n            position += positionIncrement;\n            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)),position);\n          } else {\n            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a query from the analysis chain.\n   * <p>\n   * Expert: this is more useful for subclasses such as queryparsers. \n   * If using this class directly, just use {@link #createBooleanQuery(String, String)}\n   * and {@link #createPhraseQuery(String, String)}\n   * @param analyzer analyzer used for this query\n   * @param operator default boolean operator used for this query\n   * @param field field to create queries against\n   * @param queryText text to be passed to the analysis chain\n   * @param quoted true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected final Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n    CachingTokenFilter buffer = null;\n    TermToBytesRefAttribute termAtt = null;\n    PositionIncrementAttribute posIncrAtt = null;\n    int numTokens = 0;\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n    boolean hasMoreTokens = false;    \n    \n    try (TokenStream source = analyzer.tokenStream(field, queryText)) {\n      source.reset();\n      buffer = new CachingTokenFilter(source);\n      buffer.reset();\n\n      if (buffer.hasAttribute(TermToBytesRefAttribute.class)) {\n        termAtt = buffer.getAttribute(TermToBytesRefAttribute.class);\n      }\n      if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n        posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n      }\n\n      if (termAtt != null) {\n        try {\n          hasMoreTokens = buffer.incrementToken();\n          while (hasMoreTokens) {\n            numTokens++;\n            int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;\n            if (positionIncrement != 0) {\n              positionCount += positionIncrement;\n            } else {\n              severalTokensAtSamePosition = true;\n            }\n            hasMoreTokens = buffer.incrementToken();\n          }\n        } catch (IOException e) {\n          // ignore\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n    \n    // rewind the buffer stream\n    buffer.reset();\n\n    BytesRef bytes = termAtt == null ? null : termAtt.getBytesRef();\n\n    if (numTokens == 0)\n      return null;\n    else if (numTokens == 1) {\n      try {\n        boolean hasNext = buffer.incrementToken();\n        assert hasNext == true;\n        termAtt.fillBytesRef();\n      } catch (IOException e) {\n        // safe to ignore, because we know the number of tokens\n      }\n      return newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));\n    } else {\n      if (severalTokensAtSamePosition || (!quoted)) {\n        if (positionCount == 1 || (!quoted)) {\n          // no phrase query:\n          \n          if (positionCount == 1) {\n            // simple case: only one position, with synonyms\n            BooleanQuery q = newBooleanQuery(true);\n            for (int i = 0; i < numTokens; i++) {\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                termAtt.fillBytesRef();\n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n              Query currentQuery = newTermQuery(\n                  new Term(field, BytesRef.deepCopyOf(bytes)));\n              q.add(currentQuery, BooleanClause.Occur.SHOULD);\n            }\n            return q;\n          } else {\n            // multiple positions\n            BooleanQuery q = newBooleanQuery(false);\n            Query currentQuery = null;\n            for (int i = 0; i < numTokens; i++) {\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                termAtt.fillBytesRef();\n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n              if (posIncrAtt != null && posIncrAtt.getPositionIncrement() == 0) {\n                if (!(currentQuery instanceof BooleanQuery)) {\n                  Query t = currentQuery;\n                  currentQuery = newBooleanQuery(true);\n                  ((BooleanQuery)currentQuery).add(t, BooleanClause.Occur.SHOULD);\n                }\n                ((BooleanQuery)currentQuery).add(newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes))), BooleanClause.Occur.SHOULD);\n              } else {\n                if (currentQuery != null) {\n                  q.add(currentQuery, operator);\n                }\n                currentQuery = newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));\n              }\n            }\n            q.add(currentQuery, operator);\n            return q;\n          }\n        } else {\n          // phrase query:\n          MultiPhraseQuery mpq = newMultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List<Term> multiTerms = new ArrayList<>();\n          int position = -1;\n          for (int i = 0; i < numTokens; i++) {\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              termAtt.fillBytesRef();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add(multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add(multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += positionIncrement;\n            multiTerms.add(new Term(field, BytesRef.deepCopyOf(bytes)));\n          }\n          if (enablePositionIncrements) {\n            mpq.add(multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add(multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      } else {\n        PhraseQuery pq = newPhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n\n        for (int i = 0; i < numTokens; i++) {\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            termAtt.fillBytesRef();\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          if (enablePositionIncrements) {\n            position += positionIncrement;\n            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)),position);\n          } else {\n            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["8b49777657109e40eeddc1c8b0f7850d3c06e1ed"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3394716f52b34ab259ad5247e7595d9f9db6e935","date":1398791921,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(Analyzer,BooleanClause.Occur,String,String,boolean,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(Analyzer,BooleanClause.Occur,String,String,boolean,int).mjava","sourceNew":"  /**\n   * Creates a query from the analysis chain.\n   * <p>\n   * Expert: this is more useful for subclasses such as queryparsers. \n   * If using this class directly, just use {@link #createBooleanQuery(String, String)}\n   * and {@link #createPhraseQuery(String, String)}\n   * @param analyzer analyzer used for this query\n   * @param operator default boolean operator used for this query\n   * @param field field to create queries against\n   * @param queryText text to be passed to the analysis chain\n   * @param quoted true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected final Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n    CachingTokenFilter buffer = null;\n    TermToBytesRefAttribute termAtt = null;\n    PositionIncrementAttribute posIncrAtt = null;\n    int numTokens = 0;\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n    boolean hasMoreTokens = false;    \n    \n    try (TokenStream source = analyzer.tokenStream(field, queryText)) {\n      source.reset();\n      buffer = new CachingTokenFilter(source);\n      buffer.reset();\n\n      termAtt = buffer.getAttribute(TermToBytesRefAttribute.class);\n      posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n\n      if (termAtt != null) {\n        try {\n          hasMoreTokens = buffer.incrementToken();\n          while (hasMoreTokens) {\n            numTokens++;\n            int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;\n            if (positionIncrement != 0) {\n              positionCount += positionIncrement;\n            } else {\n              severalTokensAtSamePosition = true;\n            }\n            hasMoreTokens = buffer.incrementToken();\n          }\n        } catch (IOException e) {\n          // ignore\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n    \n    // rewind the buffer stream\n    buffer.reset();\n\n    BytesRef bytes = termAtt == null ? null : termAtt.getBytesRef();\n\n    if (numTokens == 0)\n      return null;\n    else if (numTokens == 1) {\n      try {\n        boolean hasNext = buffer.incrementToken();\n        assert hasNext == true;\n        termAtt.fillBytesRef();\n      } catch (IOException e) {\n        // safe to ignore, because we know the number of tokens\n      }\n      return newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));\n    } else {\n      if (severalTokensAtSamePosition || (!quoted)) {\n        if (positionCount == 1 || (!quoted)) {\n          // no phrase query:\n          \n          if (positionCount == 1) {\n            // simple case: only one position, with synonyms\n            BooleanQuery q = newBooleanQuery(true);\n            for (int i = 0; i < numTokens; i++) {\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                termAtt.fillBytesRef();\n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n              Query currentQuery = newTermQuery(\n                  new Term(field, BytesRef.deepCopyOf(bytes)));\n              q.add(currentQuery, BooleanClause.Occur.SHOULD);\n            }\n            return q;\n          } else {\n            // multiple positions\n            BooleanQuery q = newBooleanQuery(false);\n            Query currentQuery = null;\n            for (int i = 0; i < numTokens; i++) {\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                termAtt.fillBytesRef();\n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n              if (posIncrAtt != null && posIncrAtt.getPositionIncrement() == 0) {\n                if (!(currentQuery instanceof BooleanQuery)) {\n                  Query t = currentQuery;\n                  currentQuery = newBooleanQuery(true);\n                  ((BooleanQuery)currentQuery).add(t, BooleanClause.Occur.SHOULD);\n                }\n                ((BooleanQuery)currentQuery).add(newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes))), BooleanClause.Occur.SHOULD);\n              } else {\n                if (currentQuery != null) {\n                  q.add(currentQuery, operator);\n                }\n                currentQuery = newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));\n              }\n            }\n            q.add(currentQuery, operator);\n            return q;\n          }\n        } else {\n          // phrase query:\n          MultiPhraseQuery mpq = newMultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List<Term> multiTerms = new ArrayList<>();\n          int position = -1;\n          for (int i = 0; i < numTokens; i++) {\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              termAtt.fillBytesRef();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add(multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add(multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += positionIncrement;\n            multiTerms.add(new Term(field, BytesRef.deepCopyOf(bytes)));\n          }\n          if (enablePositionIncrements) {\n            mpq.add(multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add(multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      } else {\n        PhraseQuery pq = newPhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n\n        for (int i = 0; i < numTokens; i++) {\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            termAtt.fillBytesRef();\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          if (enablePositionIncrements) {\n            position += positionIncrement;\n            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)),position);\n          } else {\n            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a query from the analysis chain.\n   * <p>\n   * Expert: this is more useful for subclasses such as queryparsers. \n   * If using this class directly, just use {@link #createBooleanQuery(String, String)}\n   * and {@link #createPhraseQuery(String, String)}\n   * @param analyzer analyzer used for this query\n   * @param operator default boolean operator used for this query\n   * @param field field to create queries against\n   * @param queryText text to be passed to the analysis chain\n   * @param quoted true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected final Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n    CachingTokenFilter buffer = null;\n    TermToBytesRefAttribute termAtt = null;\n    PositionIncrementAttribute posIncrAtt = null;\n    int numTokens = 0;\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n    boolean hasMoreTokens = false;    \n    \n    try (TokenStream source = analyzer.tokenStream(field, queryText)) {\n      source.reset();\n      buffer = new CachingTokenFilter(source);\n      buffer.reset();\n\n      if (buffer.hasAttribute(TermToBytesRefAttribute.class)) {\n        termAtt = buffer.getAttribute(TermToBytesRefAttribute.class);\n      }\n      if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n        posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n      }\n\n      if (termAtt != null) {\n        try {\n          hasMoreTokens = buffer.incrementToken();\n          while (hasMoreTokens) {\n            numTokens++;\n            int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;\n            if (positionIncrement != 0) {\n              positionCount += positionIncrement;\n            } else {\n              severalTokensAtSamePosition = true;\n            }\n            hasMoreTokens = buffer.incrementToken();\n          }\n        } catch (IOException e) {\n          // ignore\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n    \n    // rewind the buffer stream\n    buffer.reset();\n\n    BytesRef bytes = termAtt == null ? null : termAtt.getBytesRef();\n\n    if (numTokens == 0)\n      return null;\n    else if (numTokens == 1) {\n      try {\n        boolean hasNext = buffer.incrementToken();\n        assert hasNext == true;\n        termAtt.fillBytesRef();\n      } catch (IOException e) {\n        // safe to ignore, because we know the number of tokens\n      }\n      return newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));\n    } else {\n      if (severalTokensAtSamePosition || (!quoted)) {\n        if (positionCount == 1 || (!quoted)) {\n          // no phrase query:\n          \n          if (positionCount == 1) {\n            // simple case: only one position, with synonyms\n            BooleanQuery q = newBooleanQuery(true);\n            for (int i = 0; i < numTokens; i++) {\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                termAtt.fillBytesRef();\n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n              Query currentQuery = newTermQuery(\n                  new Term(field, BytesRef.deepCopyOf(bytes)));\n              q.add(currentQuery, BooleanClause.Occur.SHOULD);\n            }\n            return q;\n          } else {\n            // multiple positions\n            BooleanQuery q = newBooleanQuery(false);\n            Query currentQuery = null;\n            for (int i = 0; i < numTokens; i++) {\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                termAtt.fillBytesRef();\n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n              if (posIncrAtt != null && posIncrAtt.getPositionIncrement() == 0) {\n                if (!(currentQuery instanceof BooleanQuery)) {\n                  Query t = currentQuery;\n                  currentQuery = newBooleanQuery(true);\n                  ((BooleanQuery)currentQuery).add(t, BooleanClause.Occur.SHOULD);\n                }\n                ((BooleanQuery)currentQuery).add(newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes))), BooleanClause.Occur.SHOULD);\n              } else {\n                if (currentQuery != null) {\n                  q.add(currentQuery, operator);\n                }\n                currentQuery = newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));\n              }\n            }\n            q.add(currentQuery, operator);\n            return q;\n          }\n        } else {\n          // phrase query:\n          MultiPhraseQuery mpq = newMultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List<Term> multiTerms = new ArrayList<>();\n          int position = -1;\n          for (int i = 0; i < numTokens; i++) {\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              termAtt.fillBytesRef();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add(multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add(multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += positionIncrement;\n            multiTerms.add(new Term(field, BytesRef.deepCopyOf(bytes)));\n          }\n          if (enablePositionIncrements) {\n            mpq.add(multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add(multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      } else {\n        PhraseQuery pq = newPhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n\n        for (int i = 0; i < numTokens; i++) {\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            termAtt.fillBytesRef();\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          if (enablePositionIncrements) {\n            position += positionIncrement;\n            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)),position);\n          } else {\n            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","date":1398844771,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(Analyzer,BooleanClause.Occur,String,String,boolean,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(Analyzer,BooleanClause.Occur,String,String,boolean,int).mjava","sourceNew":"  /**\n   * Creates a query from the analysis chain.\n   * <p>\n   * Expert: this is more useful for subclasses such as queryparsers. \n   * If using this class directly, just use {@link #createBooleanQuery(String, String)}\n   * and {@link #createPhraseQuery(String, String)}\n   * @param analyzer analyzer used for this query\n   * @param operator default boolean operator used for this query\n   * @param field field to create queries against\n   * @param queryText text to be passed to the analysis chain\n   * @param quoted true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected final Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n    CachingTokenFilter buffer = null;\n    TermToBytesRefAttribute termAtt = null;\n    PositionIncrementAttribute posIncrAtt = null;\n    int numTokens = 0;\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n    boolean hasMoreTokens = false;    \n    \n    try (TokenStream source = analyzer.tokenStream(field, queryText)) {\n      source.reset();\n      buffer = new CachingTokenFilter(source);\n      buffer.reset();\n\n      termAtt = buffer.getAttribute(TermToBytesRefAttribute.class);\n      posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n\n      if (termAtt != null) {\n        try {\n          hasMoreTokens = buffer.incrementToken();\n          while (hasMoreTokens) {\n            numTokens++;\n            int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;\n            if (positionIncrement != 0) {\n              positionCount += positionIncrement;\n            } else {\n              severalTokensAtSamePosition = true;\n            }\n            hasMoreTokens = buffer.incrementToken();\n          }\n        } catch (IOException e) {\n          // ignore\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n    \n    // rewind the buffer stream\n    buffer.reset();\n\n    BytesRef bytes = termAtt == null ? null : termAtt.getBytesRef();\n\n    if (numTokens == 0)\n      return null;\n    else if (numTokens == 1) {\n      try {\n        boolean hasNext = buffer.incrementToken();\n        assert hasNext == true;\n        termAtt.fillBytesRef();\n      } catch (IOException e) {\n        // safe to ignore, because we know the number of tokens\n      }\n      return newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));\n    } else {\n      if (severalTokensAtSamePosition || (!quoted)) {\n        if (positionCount == 1 || (!quoted)) {\n          // no phrase query:\n          \n          if (positionCount == 1) {\n            // simple case: only one position, with synonyms\n            BooleanQuery q = newBooleanQuery(true);\n            for (int i = 0; i < numTokens; i++) {\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                termAtt.fillBytesRef();\n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n              Query currentQuery = newTermQuery(\n                  new Term(field, BytesRef.deepCopyOf(bytes)));\n              q.add(currentQuery, BooleanClause.Occur.SHOULD);\n            }\n            return q;\n          } else {\n            // multiple positions\n            BooleanQuery q = newBooleanQuery(false);\n            Query currentQuery = null;\n            for (int i = 0; i < numTokens; i++) {\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                termAtt.fillBytesRef();\n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n              if (posIncrAtt != null && posIncrAtt.getPositionIncrement() == 0) {\n                if (!(currentQuery instanceof BooleanQuery)) {\n                  Query t = currentQuery;\n                  currentQuery = newBooleanQuery(true);\n                  ((BooleanQuery)currentQuery).add(t, BooleanClause.Occur.SHOULD);\n                }\n                ((BooleanQuery)currentQuery).add(newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes))), BooleanClause.Occur.SHOULD);\n              } else {\n                if (currentQuery != null) {\n                  q.add(currentQuery, operator);\n                }\n                currentQuery = newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));\n              }\n            }\n            q.add(currentQuery, operator);\n            return q;\n          }\n        } else {\n          // phrase query:\n          MultiPhraseQuery mpq = newMultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List<Term> multiTerms = new ArrayList<>();\n          int position = -1;\n          for (int i = 0; i < numTokens; i++) {\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              termAtt.fillBytesRef();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add(multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add(multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += positionIncrement;\n            multiTerms.add(new Term(field, BytesRef.deepCopyOf(bytes)));\n          }\n          if (enablePositionIncrements) {\n            mpq.add(multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add(multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      } else {\n        PhraseQuery pq = newPhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n\n        for (int i = 0; i < numTokens; i++) {\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            termAtt.fillBytesRef();\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          if (enablePositionIncrements) {\n            position += positionIncrement;\n            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)),position);\n          } else {\n            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a query from the analysis chain.\n   * <p>\n   * Expert: this is more useful for subclasses such as queryparsers. \n   * If using this class directly, just use {@link #createBooleanQuery(String, String)}\n   * and {@link #createPhraseQuery(String, String)}\n   * @param analyzer analyzer used for this query\n   * @param operator default boolean operator used for this query\n   * @param field field to create queries against\n   * @param queryText text to be passed to the analysis chain\n   * @param quoted true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected final Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n    CachingTokenFilter buffer = null;\n    TermToBytesRefAttribute termAtt = null;\n    PositionIncrementAttribute posIncrAtt = null;\n    int numTokens = 0;\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n    boolean hasMoreTokens = false;    \n    \n    try (TokenStream source = analyzer.tokenStream(field, queryText)) {\n      source.reset();\n      buffer = new CachingTokenFilter(source);\n      buffer.reset();\n\n      if (buffer.hasAttribute(TermToBytesRefAttribute.class)) {\n        termAtt = buffer.getAttribute(TermToBytesRefAttribute.class);\n      }\n      if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n        posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n      }\n\n      if (termAtt != null) {\n        try {\n          hasMoreTokens = buffer.incrementToken();\n          while (hasMoreTokens) {\n            numTokens++;\n            int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;\n            if (positionIncrement != 0) {\n              positionCount += positionIncrement;\n            } else {\n              severalTokensAtSamePosition = true;\n            }\n            hasMoreTokens = buffer.incrementToken();\n          }\n        } catch (IOException e) {\n          // ignore\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n    \n    // rewind the buffer stream\n    buffer.reset();\n\n    BytesRef bytes = termAtt == null ? null : termAtt.getBytesRef();\n\n    if (numTokens == 0)\n      return null;\n    else if (numTokens == 1) {\n      try {\n        boolean hasNext = buffer.incrementToken();\n        assert hasNext == true;\n        termAtt.fillBytesRef();\n      } catch (IOException e) {\n        // safe to ignore, because we know the number of tokens\n      }\n      return newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));\n    } else {\n      if (severalTokensAtSamePosition || (!quoted)) {\n        if (positionCount == 1 || (!quoted)) {\n          // no phrase query:\n          \n          if (positionCount == 1) {\n            // simple case: only one position, with synonyms\n            BooleanQuery q = newBooleanQuery(true);\n            for (int i = 0; i < numTokens; i++) {\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                termAtt.fillBytesRef();\n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n              Query currentQuery = newTermQuery(\n                  new Term(field, BytesRef.deepCopyOf(bytes)));\n              q.add(currentQuery, BooleanClause.Occur.SHOULD);\n            }\n            return q;\n          } else {\n            // multiple positions\n            BooleanQuery q = newBooleanQuery(false);\n            Query currentQuery = null;\n            for (int i = 0; i < numTokens; i++) {\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                termAtt.fillBytesRef();\n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n              if (posIncrAtt != null && posIncrAtt.getPositionIncrement() == 0) {\n                if (!(currentQuery instanceof BooleanQuery)) {\n                  Query t = currentQuery;\n                  currentQuery = newBooleanQuery(true);\n                  ((BooleanQuery)currentQuery).add(t, BooleanClause.Occur.SHOULD);\n                }\n                ((BooleanQuery)currentQuery).add(newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes))), BooleanClause.Occur.SHOULD);\n              } else {\n                if (currentQuery != null) {\n                  q.add(currentQuery, operator);\n                }\n                currentQuery = newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));\n              }\n            }\n            q.add(currentQuery, operator);\n            return q;\n          }\n        } else {\n          // phrase query:\n          MultiPhraseQuery mpq = newMultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List<Term> multiTerms = new ArrayList<>();\n          int position = -1;\n          for (int i = 0; i < numTokens; i++) {\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              termAtt.fillBytesRef();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add(multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add(multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += positionIncrement;\n            multiTerms.add(new Term(field, BytesRef.deepCopyOf(bytes)));\n          }\n          if (enablePositionIncrements) {\n            mpq.add(multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add(multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      } else {\n        PhraseQuery pq = newPhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n\n        for (int i = 0; i < numTokens; i++) {\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            termAtt.fillBytesRef();\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          if (enablePositionIncrements) {\n            position += positionIncrement;\n            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)),position);\n          } else {\n            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55244759f906151d96839f8451dee793acb06e75","date":1418999882,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(Analyzer,BooleanClause.Occur,String,String,boolean,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(Analyzer,BooleanClause.Occur,String,String,boolean,int).mjava","sourceNew":"  /**\n   * Creates a query from the analysis chain.\n   * <p>\n   * Expert: this is more useful for subclasses such as queryparsers. \n   * If using this class directly, just use {@link #createBooleanQuery(String, String)}\n   * and {@link #createPhraseQuery(String, String)}\n   * @param analyzer analyzer used for this query\n   * @param operator default boolean operator used for this query\n   * @param field field to create queries against\n   * @param queryText text to be passed to the analysis chain\n   * @param quoted true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected final Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n    CachingTokenFilter buffer = null;\n    TermToBytesRefAttribute termAtt = null;\n    PositionIncrementAttribute posIncrAtt = null;\n    int numTokens = 0;\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n    boolean hasMoreTokens = false;    \n    \n    try (TokenStream source = analyzer.tokenStream(field, queryText)) {\n      buffer = new CachingTokenFilter(source);\n      buffer.reset();\n\n      termAtt = buffer.getAttribute(TermToBytesRefAttribute.class);\n      posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n\n      if (termAtt != null) {\n        try {\n          hasMoreTokens = buffer.incrementToken();\n          while (hasMoreTokens) {\n            numTokens++;\n            int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;\n            if (positionIncrement != 0) {\n              positionCount += positionIncrement;\n            } else {\n              severalTokensAtSamePosition = true;\n            }\n            hasMoreTokens = buffer.incrementToken();\n          }\n        } catch (IOException e) {\n          // ignore\n        }\n\n        // rewind the buffer stream\n        buffer.reset();//will never through on subsequent reset calls\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n\n    BytesRef bytes = termAtt == null ? null : termAtt.getBytesRef();\n\n    if (numTokens == 0)\n      return null;\n    else if (numTokens == 1) {\n      try {\n        boolean hasNext = buffer.incrementToken();\n        assert hasNext == true;\n        termAtt.fillBytesRef();\n      } catch (IOException e) {\n        // safe to ignore, because we know the number of tokens\n      }\n      return newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));\n    } else {\n      if (severalTokensAtSamePosition || (!quoted)) {\n        if (positionCount == 1 || (!quoted)) {\n          // no phrase query:\n          \n          if (positionCount == 1) {\n            // simple case: only one position, with synonyms\n            BooleanQuery q = newBooleanQuery(true);\n            for (int i = 0; i < numTokens; i++) {\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                termAtt.fillBytesRef();\n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n              Query currentQuery = newTermQuery(\n                  new Term(field, BytesRef.deepCopyOf(bytes)));\n              q.add(currentQuery, BooleanClause.Occur.SHOULD);\n            }\n            return q;\n          } else {\n            // multiple positions\n            BooleanQuery q = newBooleanQuery(false);\n            Query currentQuery = null;\n            for (int i = 0; i < numTokens; i++) {\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                termAtt.fillBytesRef();\n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n              if (posIncrAtt != null && posIncrAtt.getPositionIncrement() == 0) {\n                if (!(currentQuery instanceof BooleanQuery)) {\n                  Query t = currentQuery;\n                  currentQuery = newBooleanQuery(true);\n                  ((BooleanQuery)currentQuery).add(t, BooleanClause.Occur.SHOULD);\n                }\n                ((BooleanQuery)currentQuery).add(newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes))), BooleanClause.Occur.SHOULD);\n              } else {\n                if (currentQuery != null) {\n                  q.add(currentQuery, operator);\n                }\n                currentQuery = newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));\n              }\n            }\n            q.add(currentQuery, operator);\n            return q;\n          }\n        } else {\n          // phrase query:\n          MultiPhraseQuery mpq = newMultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List<Term> multiTerms = new ArrayList<>();\n          int position = -1;\n          for (int i = 0; i < numTokens; i++) {\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              termAtt.fillBytesRef();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add(multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add(multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += positionIncrement;\n            multiTerms.add(new Term(field, BytesRef.deepCopyOf(bytes)));\n          }\n          if (enablePositionIncrements) {\n            mpq.add(multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add(multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      } else {\n        PhraseQuery pq = newPhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n\n        for (int i = 0; i < numTokens; i++) {\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            termAtt.fillBytesRef();\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          if (enablePositionIncrements) {\n            position += positionIncrement;\n            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)),position);\n          } else {\n            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a query from the analysis chain.\n   * <p>\n   * Expert: this is more useful for subclasses such as queryparsers. \n   * If using this class directly, just use {@link #createBooleanQuery(String, String)}\n   * and {@link #createPhraseQuery(String, String)}\n   * @param analyzer analyzer used for this query\n   * @param operator default boolean operator used for this query\n   * @param field field to create queries against\n   * @param queryText text to be passed to the analysis chain\n   * @param quoted true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected final Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n    CachingTokenFilter buffer = null;\n    TermToBytesRefAttribute termAtt = null;\n    PositionIncrementAttribute posIncrAtt = null;\n    int numTokens = 0;\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n    boolean hasMoreTokens = false;    \n    \n    try (TokenStream source = analyzer.tokenStream(field, queryText)) {\n      source.reset();\n      buffer = new CachingTokenFilter(source);\n      buffer.reset();\n\n      termAtt = buffer.getAttribute(TermToBytesRefAttribute.class);\n      posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n\n      if (termAtt != null) {\n        try {\n          hasMoreTokens = buffer.incrementToken();\n          while (hasMoreTokens) {\n            numTokens++;\n            int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;\n            if (positionIncrement != 0) {\n              positionCount += positionIncrement;\n            } else {\n              severalTokensAtSamePosition = true;\n            }\n            hasMoreTokens = buffer.incrementToken();\n          }\n        } catch (IOException e) {\n          // ignore\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n    \n    // rewind the buffer stream\n    buffer.reset();\n\n    BytesRef bytes = termAtt == null ? null : termAtt.getBytesRef();\n\n    if (numTokens == 0)\n      return null;\n    else if (numTokens == 1) {\n      try {\n        boolean hasNext = buffer.incrementToken();\n        assert hasNext == true;\n        termAtt.fillBytesRef();\n      } catch (IOException e) {\n        // safe to ignore, because we know the number of tokens\n      }\n      return newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));\n    } else {\n      if (severalTokensAtSamePosition || (!quoted)) {\n        if (positionCount == 1 || (!quoted)) {\n          // no phrase query:\n          \n          if (positionCount == 1) {\n            // simple case: only one position, with synonyms\n            BooleanQuery q = newBooleanQuery(true);\n            for (int i = 0; i < numTokens; i++) {\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                termAtt.fillBytesRef();\n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n              Query currentQuery = newTermQuery(\n                  new Term(field, BytesRef.deepCopyOf(bytes)));\n              q.add(currentQuery, BooleanClause.Occur.SHOULD);\n            }\n            return q;\n          } else {\n            // multiple positions\n            BooleanQuery q = newBooleanQuery(false);\n            Query currentQuery = null;\n            for (int i = 0; i < numTokens; i++) {\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                termAtt.fillBytesRef();\n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n              if (posIncrAtt != null && posIncrAtt.getPositionIncrement() == 0) {\n                if (!(currentQuery instanceof BooleanQuery)) {\n                  Query t = currentQuery;\n                  currentQuery = newBooleanQuery(true);\n                  ((BooleanQuery)currentQuery).add(t, BooleanClause.Occur.SHOULD);\n                }\n                ((BooleanQuery)currentQuery).add(newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes))), BooleanClause.Occur.SHOULD);\n              } else {\n                if (currentQuery != null) {\n                  q.add(currentQuery, operator);\n                }\n                currentQuery = newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));\n              }\n            }\n            q.add(currentQuery, operator);\n            return q;\n          }\n        } else {\n          // phrase query:\n          MultiPhraseQuery mpq = newMultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List<Term> multiTerms = new ArrayList<>();\n          int position = -1;\n          for (int i = 0; i < numTokens; i++) {\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              termAtt.fillBytesRef();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add(multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add(multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += positionIncrement;\n            multiTerms.add(new Term(field, BytesRef.deepCopyOf(bytes)));\n          }\n          if (enablePositionIncrements) {\n            mpq.add(multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add(multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      } else {\n        PhraseQuery pq = newPhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n\n        for (int i = 0; i < numTokens; i++) {\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            termAtt.fillBytesRef();\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          if (enablePositionIncrements) {\n            position += positionIncrement;\n            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)),position);\n          } else {\n            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f6a724f3ec10207bc28cd9df28ff4c5c7ca07046","date":1419008139,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(Analyzer,BooleanClause.Occur,String,String,boolean,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(Analyzer,BooleanClause.Occur,String,String,boolean,int).mjava","sourceNew":"  /**\n   * Creates a query from the analysis chain.\n   * <p>\n   * Expert: this is more useful for subclasses such as queryparsers. \n   * If using this class directly, just use {@link #createBooleanQuery(String, String)}\n   * and {@link #createPhraseQuery(String, String)}\n   * @param analyzer analyzer used for this query\n   * @param operator default boolean operator used for this query\n   * @param field field to create queries against\n   * @param queryText text to be passed to the analysis chain\n   * @param quoted true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected final Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n    CachingTokenFilter buffer = null;\n    TermToBytesRefAttribute termAtt = null;\n    PositionIncrementAttribute posIncrAtt = null;\n    int numTokens = 0;\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n    boolean hasMoreTokens = false;\n\n    try (TokenStream source = analyzer.tokenStream(field, queryText)) {\n      buffer = new CachingTokenFilter(source);\n      buffer.reset();\n\n      termAtt = buffer.getAttribute(TermToBytesRefAttribute.class);\n      posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n\n      if (termAtt != null) {\n        try {\n          hasMoreTokens = buffer.incrementToken();\n          while (hasMoreTokens) {\n            numTokens++;\n            int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;\n            if (positionIncrement != 0) {\n              positionCount += positionIncrement;\n            } else {\n              severalTokensAtSamePosition = true;\n            }\n            hasMoreTokens = buffer.incrementToken();\n          }\n        } catch (IOException e) {\n          // ignore\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n\n    // rewind the buffer stream\n    try {\n      if (numTokens > 0) {\n        buffer.reset();//will never throw; the buffer is cached\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n\n    BytesRef bytes = termAtt == null ? null : termAtt.getBytesRef();\n\n    if (numTokens == 0) {\n      return null;\n    } else if (numTokens == 1) {\n      try {\n        boolean hasNext = buffer.incrementToken();\n        assert hasNext == true;\n        termAtt.fillBytesRef();\n      } catch (IOException e) {\n        // safe to ignore, because we know the number of tokens\n      }\n      return newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));\n    } else {\n      if (severalTokensAtSamePosition || (!quoted)) {\n        if (positionCount == 1 || (!quoted)) {\n          // no phrase query:\n          \n          if (positionCount == 1) {\n            // simple case: only one position, with synonyms\n            BooleanQuery q = newBooleanQuery(true);\n            for (int i = 0; i < numTokens; i++) {\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                termAtt.fillBytesRef();\n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n              Query currentQuery = newTermQuery(\n                  new Term(field, BytesRef.deepCopyOf(bytes)));\n              q.add(currentQuery, BooleanClause.Occur.SHOULD);\n            }\n            return q;\n          } else {\n            // multiple positions\n            BooleanQuery q = newBooleanQuery(false);\n            Query currentQuery = null;\n            for (int i = 0; i < numTokens; i++) {\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                termAtt.fillBytesRef();\n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n              if (posIncrAtt != null && posIncrAtt.getPositionIncrement() == 0) {\n                if (!(currentQuery instanceof BooleanQuery)) {\n                  Query t = currentQuery;\n                  currentQuery = newBooleanQuery(true);\n                  ((BooleanQuery)currentQuery).add(t, BooleanClause.Occur.SHOULD);\n                }\n                ((BooleanQuery)currentQuery).add(newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes))), BooleanClause.Occur.SHOULD);\n              } else {\n                if (currentQuery != null) {\n                  q.add(currentQuery, operator);\n                }\n                currentQuery = newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));\n              }\n            }\n            q.add(currentQuery, operator);\n            return q;\n          }\n        } else {\n          // phrase query:\n          MultiPhraseQuery mpq = newMultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List<Term> multiTerms = new ArrayList<>();\n          int position = -1;\n          for (int i = 0; i < numTokens; i++) {\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              termAtt.fillBytesRef();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add(multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add(multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += positionIncrement;\n            multiTerms.add(new Term(field, BytesRef.deepCopyOf(bytes)));\n          }\n          if (enablePositionIncrements) {\n            mpq.add(multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add(multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      } else {\n        PhraseQuery pq = newPhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n\n        for (int i = 0; i < numTokens; i++) {\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            termAtt.fillBytesRef();\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          if (enablePositionIncrements) {\n            position += positionIncrement;\n            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)),position);\n          } else {\n            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a query from the analysis chain.\n   * <p>\n   * Expert: this is more useful for subclasses such as queryparsers. \n   * If using this class directly, just use {@link #createBooleanQuery(String, String)}\n   * and {@link #createPhraseQuery(String, String)}\n   * @param analyzer analyzer used for this query\n   * @param operator default boolean operator used for this query\n   * @param field field to create queries against\n   * @param queryText text to be passed to the analysis chain\n   * @param quoted true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected final Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n    CachingTokenFilter buffer = null;\n    TermToBytesRefAttribute termAtt = null;\n    PositionIncrementAttribute posIncrAtt = null;\n    int numTokens = 0;\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n    boolean hasMoreTokens = false;    \n    \n    try (TokenStream source = analyzer.tokenStream(field, queryText)) {\n      buffer = new CachingTokenFilter(source);\n      buffer.reset();\n\n      termAtt = buffer.getAttribute(TermToBytesRefAttribute.class);\n      posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n\n      if (termAtt != null) {\n        try {\n          hasMoreTokens = buffer.incrementToken();\n          while (hasMoreTokens) {\n            numTokens++;\n            int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;\n            if (positionIncrement != 0) {\n              positionCount += positionIncrement;\n            } else {\n              severalTokensAtSamePosition = true;\n            }\n            hasMoreTokens = buffer.incrementToken();\n          }\n        } catch (IOException e) {\n          // ignore\n        }\n\n        // rewind the buffer stream\n        buffer.reset();//will never through on subsequent reset calls\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n\n    BytesRef bytes = termAtt == null ? null : termAtt.getBytesRef();\n\n    if (numTokens == 0)\n      return null;\n    else if (numTokens == 1) {\n      try {\n        boolean hasNext = buffer.incrementToken();\n        assert hasNext == true;\n        termAtt.fillBytesRef();\n      } catch (IOException e) {\n        // safe to ignore, because we know the number of tokens\n      }\n      return newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));\n    } else {\n      if (severalTokensAtSamePosition || (!quoted)) {\n        if (positionCount == 1 || (!quoted)) {\n          // no phrase query:\n          \n          if (positionCount == 1) {\n            // simple case: only one position, with synonyms\n            BooleanQuery q = newBooleanQuery(true);\n            for (int i = 0; i < numTokens; i++) {\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                termAtt.fillBytesRef();\n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n              Query currentQuery = newTermQuery(\n                  new Term(field, BytesRef.deepCopyOf(bytes)));\n              q.add(currentQuery, BooleanClause.Occur.SHOULD);\n            }\n            return q;\n          } else {\n            // multiple positions\n            BooleanQuery q = newBooleanQuery(false);\n            Query currentQuery = null;\n            for (int i = 0; i < numTokens; i++) {\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                termAtt.fillBytesRef();\n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n              if (posIncrAtt != null && posIncrAtt.getPositionIncrement() == 0) {\n                if (!(currentQuery instanceof BooleanQuery)) {\n                  Query t = currentQuery;\n                  currentQuery = newBooleanQuery(true);\n                  ((BooleanQuery)currentQuery).add(t, BooleanClause.Occur.SHOULD);\n                }\n                ((BooleanQuery)currentQuery).add(newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes))), BooleanClause.Occur.SHOULD);\n              } else {\n                if (currentQuery != null) {\n                  q.add(currentQuery, operator);\n                }\n                currentQuery = newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));\n              }\n            }\n            q.add(currentQuery, operator);\n            return q;\n          }\n        } else {\n          // phrase query:\n          MultiPhraseQuery mpq = newMultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List<Term> multiTerms = new ArrayList<>();\n          int position = -1;\n          for (int i = 0; i < numTokens; i++) {\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              termAtt.fillBytesRef();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add(multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add(multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += positionIncrement;\n            multiTerms.add(new Term(field, BytesRef.deepCopyOf(bytes)));\n          }\n          if (enablePositionIncrements) {\n            mpq.add(multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add(multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      } else {\n        PhraseQuery pq = newPhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n\n        for (int i = 0; i < numTokens; i++) {\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            termAtt.fillBytesRef();\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          if (enablePositionIncrements) {\n            position += positionIncrement;\n            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)),position);\n          } else {\n            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["8b49777657109e40eeddc1c8b0f7850d3c06e1ed"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8b49777657109e40eeddc1c8b0f7850d3c06e1ed","date":1428506188,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(Analyzer,BooleanClause.Occur,String,String,boolean,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(Analyzer,BooleanClause.Occur,String,String,boolean,int).mjava","sourceNew":"  /**\n   * Creates a query from the analysis chain.\n   * <p>\n   * Expert: this is more useful for subclasses such as queryparsers. \n   * If using this class directly, just use {@link #createBooleanQuery(String, String)}\n   * and {@link #createPhraseQuery(String, String)}\n   * @param analyzer analyzer used for this query\n   * @param operator default boolean operator used for this query\n   * @param field field to create queries against\n   * @param queryText text to be passed to the analysis chain\n   * @param quoted true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected final Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n    \n    // Use the analyzer to get all the tokens, and then build an appropriate\n    // query based on the analysis chain.\n    \n    try (TokenStream source = analyzer.tokenStream(field, queryText);\n         CachingTokenFilter stream = new CachingTokenFilter(source)) {\n      \n      TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n      PositionIncrementAttribute posIncAtt = stream.addAttribute(PositionIncrementAttribute.class);\n      \n      if (termAtt == null) {\n        return null; \n      }\n      \n      // phase 1: read through the stream and assess the situation:\n      // counting the number of tokens/positions and marking if we have any synonyms.\n      \n      int numTokens = 0;\n      int positionCount = 0;\n      boolean hasSynonyms = false;\n\n      stream.reset();\n      while (stream.incrementToken()) {\n        numTokens++;\n        int positionIncrement = posIncAtt.getPositionIncrement();\n        if (positionIncrement != 0) {\n          positionCount += positionIncrement;\n        } else {\n          hasSynonyms = true;\n        }\n      }\n      \n      // phase 2: based on token count, presence of synonyms, and options\n      // formulate a single term, boolean, or phrase.\n      \n      if (numTokens == 0) {\n        return null;\n      } else if (numTokens == 1) {\n        // single term\n        return analyzeTerm(field, stream);\n      } else if (quoted && positionCount > 1) {\n        // phrase\n        if (hasSynonyms) {\n          // complex phrase with synonyms\n          return analyzeMultiPhrase(field, stream, phraseSlop);\n        } else {\n          // simple phrase\n          return analyzePhrase(field, stream, phraseSlop);\n        }\n      } else {\n        // boolean\n        if (positionCount == 1) {\n          // only one position, with synonyms\n          return analyzeBoolean(field, stream);\n        } else {\n          // complex case: multiple positions\n          return analyzeMultiBoolean(field, stream, operator);\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a query from the analysis chain.\n   * <p>\n   * Expert: this is more useful for subclasses such as queryparsers. \n   * If using this class directly, just use {@link #createBooleanQuery(String, String)}\n   * and {@link #createPhraseQuery(String, String)}\n   * @param analyzer analyzer used for this query\n   * @param operator default boolean operator used for this query\n   * @param field field to create queries against\n   * @param queryText text to be passed to the analysis chain\n   * @param quoted true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected final Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n    CachingTokenFilter buffer = null;\n    TermToBytesRefAttribute termAtt = null;\n    PositionIncrementAttribute posIncrAtt = null;\n    int numTokens = 0;\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n    boolean hasMoreTokens = false;\n\n    try (TokenStream source = analyzer.tokenStream(field, queryText)) {\n      buffer = new CachingTokenFilter(source);\n      buffer.reset();\n\n      termAtt = buffer.getAttribute(TermToBytesRefAttribute.class);\n      posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n\n      if (termAtt != null) {\n        try {\n          hasMoreTokens = buffer.incrementToken();\n          while (hasMoreTokens) {\n            numTokens++;\n            int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;\n            if (positionIncrement != 0) {\n              positionCount += positionIncrement;\n            } else {\n              severalTokensAtSamePosition = true;\n            }\n            hasMoreTokens = buffer.incrementToken();\n          }\n        } catch (IOException e) {\n          // ignore\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n\n    // rewind the buffer stream\n    try {\n      if (numTokens > 0) {\n        buffer.reset();//will never throw; the buffer is cached\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n\n    BytesRef bytes = termAtt == null ? null : termAtt.getBytesRef();\n\n    if (numTokens == 0) {\n      return null;\n    } else if (numTokens == 1) {\n      try {\n        boolean hasNext = buffer.incrementToken();\n        assert hasNext == true;\n        termAtt.fillBytesRef();\n      } catch (IOException e) {\n        // safe to ignore, because we know the number of tokens\n      }\n      return newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));\n    } else {\n      if (severalTokensAtSamePosition || (!quoted)) {\n        if (positionCount == 1 || (!quoted)) {\n          // no phrase query:\n          \n          if (positionCount == 1) {\n            // simple case: only one position, with synonyms\n            BooleanQuery q = newBooleanQuery(true);\n            for (int i = 0; i < numTokens; i++) {\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                termAtt.fillBytesRef();\n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n              Query currentQuery = newTermQuery(\n                  new Term(field, BytesRef.deepCopyOf(bytes)));\n              q.add(currentQuery, BooleanClause.Occur.SHOULD);\n            }\n            return q;\n          } else {\n            // multiple positions\n            BooleanQuery q = newBooleanQuery(false);\n            Query currentQuery = null;\n            for (int i = 0; i < numTokens; i++) {\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                termAtt.fillBytesRef();\n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n              if (posIncrAtt != null && posIncrAtt.getPositionIncrement() == 0) {\n                if (!(currentQuery instanceof BooleanQuery)) {\n                  Query t = currentQuery;\n                  currentQuery = newBooleanQuery(true);\n                  ((BooleanQuery)currentQuery).add(t, BooleanClause.Occur.SHOULD);\n                }\n                ((BooleanQuery)currentQuery).add(newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes))), BooleanClause.Occur.SHOULD);\n              } else {\n                if (currentQuery != null) {\n                  q.add(currentQuery, operator);\n                }\n                currentQuery = newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));\n              }\n            }\n            q.add(currentQuery, operator);\n            return q;\n          }\n        } else {\n          // phrase query:\n          MultiPhraseQuery mpq = newMultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List<Term> multiTerms = new ArrayList<>();\n          int position = -1;\n          for (int i = 0; i < numTokens; i++) {\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              termAtt.fillBytesRef();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add(multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add(multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += positionIncrement;\n            multiTerms.add(new Term(field, BytesRef.deepCopyOf(bytes)));\n          }\n          if (enablePositionIncrements) {\n            mpq.add(multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add(multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      } else {\n        PhraseQuery pq = newPhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n\n        for (int i = 0; i < numTokens; i++) {\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            termAtt.fillBytesRef();\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          if (enablePositionIncrements) {\n            position += positionIncrement;\n            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)),position);\n          } else {\n            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","bugFix":["63241596de245e96a0a3c36c7b03eb92130b81db","634f330c54fd3f9f491d52036dc3f40b4f4d8934","c1c1dd5dce93e4fa48898dabc7e012560acda425","f6a724f3ec10207bc28cd9df28ff4c5c7ca07046"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"862812e92a417c556229d16d45bffc8c8a98b159","date":1479294625,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(Analyzer,BooleanClause.Occur,String,String,boolean,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(Analyzer,BooleanClause.Occur,String,String,boolean,int).mjava","sourceNew":"  /**\n   * Creates a query from the analysis chain.\n   * <p>\n   * Expert: this is more useful for subclasses such as queryparsers. \n   * If using this class directly, just use {@link #createBooleanQuery(String, String)}\n   * and {@link #createPhraseQuery(String, String)}\n   * @param analyzer analyzer used for this query\n   * @param operator default boolean operator used for this query\n   * @param field field to create queries against\n   * @param queryText text to be passed to the analysis chain\n   * @param quoted true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n    \n    // Use the analyzer to get all the tokens, and then build an appropriate\n    // query based on the analysis chain.\n    \n    try (TokenStream source = analyzer.tokenStream(field, queryText);\n         CachingTokenFilter stream = new CachingTokenFilter(source)) {\n      \n      TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n      PositionIncrementAttribute posIncAtt = stream.addAttribute(PositionIncrementAttribute.class);\n      \n      if (termAtt == null) {\n        return null; \n      }\n      \n      // phase 1: read through the stream and assess the situation:\n      // counting the number of tokens/positions and marking if we have any synonyms.\n      \n      int numTokens = 0;\n      int positionCount = 0;\n      boolean hasSynonyms = false;\n\n      stream.reset();\n      while (stream.incrementToken()) {\n        numTokens++;\n        int positionIncrement = posIncAtt.getPositionIncrement();\n        if (positionIncrement != 0) {\n          positionCount += positionIncrement;\n        } else {\n          hasSynonyms = true;\n        }\n      }\n      \n      // phase 2: based on token count, presence of synonyms, and options\n      // formulate a single term, boolean, or phrase.\n      \n      if (numTokens == 0) {\n        return null;\n      } else if (numTokens == 1) {\n        // single term\n        return analyzeTerm(field, stream);\n      } else if (quoted && positionCount > 1) {\n        // phrase\n        if (hasSynonyms) {\n          // complex phrase with synonyms\n          return analyzeMultiPhrase(field, stream, phraseSlop);\n        } else {\n          // simple phrase\n          return analyzePhrase(field, stream, phraseSlop);\n        }\n      } else {\n        // boolean\n        if (positionCount == 1) {\n          // only one position, with synonyms\n          return analyzeBoolean(field, stream);\n        } else {\n          // complex case: multiple positions\n          return analyzeMultiBoolean(field, stream, operator);\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a query from the analysis chain.\n   * <p>\n   * Expert: this is more useful for subclasses such as queryparsers. \n   * If using this class directly, just use {@link #createBooleanQuery(String, String)}\n   * and {@link #createPhraseQuery(String, String)}\n   * @param analyzer analyzer used for this query\n   * @param operator default boolean operator used for this query\n   * @param field field to create queries against\n   * @param queryText text to be passed to the analysis chain\n   * @param quoted true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected final Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n    \n    // Use the analyzer to get all the tokens, and then build an appropriate\n    // query based on the analysis chain.\n    \n    try (TokenStream source = analyzer.tokenStream(field, queryText);\n         CachingTokenFilter stream = new CachingTokenFilter(source)) {\n      \n      TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n      PositionIncrementAttribute posIncAtt = stream.addAttribute(PositionIncrementAttribute.class);\n      \n      if (termAtt == null) {\n        return null; \n      }\n      \n      // phase 1: read through the stream and assess the situation:\n      // counting the number of tokens/positions and marking if we have any synonyms.\n      \n      int numTokens = 0;\n      int positionCount = 0;\n      boolean hasSynonyms = false;\n\n      stream.reset();\n      while (stream.incrementToken()) {\n        numTokens++;\n        int positionIncrement = posIncAtt.getPositionIncrement();\n        if (positionIncrement != 0) {\n          positionCount += positionIncrement;\n        } else {\n          hasSynonyms = true;\n        }\n      }\n      \n      // phase 2: based on token count, presence of synonyms, and options\n      // formulate a single term, boolean, or phrase.\n      \n      if (numTokens == 0) {\n        return null;\n      } else if (numTokens == 1) {\n        // single term\n        return analyzeTerm(field, stream);\n      } else if (quoted && positionCount > 1) {\n        // phrase\n        if (hasSynonyms) {\n          // complex phrase with synonyms\n          return analyzeMultiPhrase(field, stream, phraseSlop);\n        } else {\n          // simple phrase\n          return analyzePhrase(field, stream, phraseSlop);\n        }\n      } else {\n        // boolean\n        if (positionCount == 1) {\n          // only one position, with synonyms\n          return analyzeBoolean(field, stream);\n        } else {\n          // complex case: multiple positions\n          return analyzeMultiBoolean(field, stream, operator);\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e859e664a65796dadf8aaf65db6f66f3a885368","date":1479487334,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(Analyzer,BooleanClause.Occur,String,String,boolean,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(Analyzer,BooleanClause.Occur,String,String,boolean,int).mjava","sourceNew":"  /**\n   * Creates a query from the analysis chain.\n   * <p>\n   * Expert: this is more useful for subclasses such as queryparsers. \n   * If using this class directly, just use {@link #createBooleanQuery(String, String)}\n   * and {@link #createPhraseQuery(String, String)}\n   * @param analyzer analyzer used for this query\n   * @param operator default boolean operator used for this query\n   * @param field field to create queries against\n   * @param queryText text to be passed to the analysis chain\n   * @param quoted true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n    \n    // Use the analyzer to get all the tokens, and then build an appropriate\n    // query based on the analysis chain.\n    \n    try (TokenStream source = analyzer.tokenStream(field, queryText);\n         CachingTokenFilter stream = new CachingTokenFilter(source)) {\n      \n      TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n      PositionIncrementAttribute posIncAtt = stream.addAttribute(PositionIncrementAttribute.class);\n      \n      if (termAtt == null) {\n        return null; \n      }\n      \n      // phase 1: read through the stream and assess the situation:\n      // counting the number of tokens/positions and marking if we have any synonyms.\n      \n      int numTokens = 0;\n      int positionCount = 0;\n      boolean hasSynonyms = false;\n\n      stream.reset();\n      while (stream.incrementToken()) {\n        numTokens++;\n        int positionIncrement = posIncAtt.getPositionIncrement();\n        if (positionIncrement != 0) {\n          positionCount += positionIncrement;\n        } else {\n          hasSynonyms = true;\n        }\n      }\n      \n      // phase 2: based on token count, presence of synonyms, and options\n      // formulate a single term, boolean, or phrase.\n      \n      if (numTokens == 0) {\n        return null;\n      } else if (numTokens == 1) {\n        // single term\n        return analyzeTerm(field, stream);\n      } else if (quoted && positionCount > 1) {\n        // phrase\n        if (hasSynonyms) {\n          // complex phrase with synonyms\n          return analyzeMultiPhrase(field, stream, phraseSlop);\n        } else {\n          // simple phrase\n          return analyzePhrase(field, stream, phraseSlop);\n        }\n      } else {\n        // boolean\n        if (positionCount == 1) {\n          // only one position, with synonyms\n          return analyzeBoolean(field, stream);\n        } else {\n          // complex case: multiple positions\n          return analyzeMultiBoolean(field, stream, operator);\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a query from the analysis chain.\n   * <p>\n   * Expert: this is more useful for subclasses such as queryparsers. \n   * If using this class directly, just use {@link #createBooleanQuery(String, String)}\n   * and {@link #createPhraseQuery(String, String)}\n   * @param analyzer analyzer used for this query\n   * @param operator default boolean operator used for this query\n   * @param field field to create queries against\n   * @param queryText text to be passed to the analysis chain\n   * @param quoted true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected final Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n    \n    // Use the analyzer to get all the tokens, and then build an appropriate\n    // query based on the analysis chain.\n    \n    try (TokenStream source = analyzer.tokenStream(field, queryText);\n         CachingTokenFilter stream = new CachingTokenFilter(source)) {\n      \n      TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n      PositionIncrementAttribute posIncAtt = stream.addAttribute(PositionIncrementAttribute.class);\n      \n      if (termAtt == null) {\n        return null; \n      }\n      \n      // phase 1: read through the stream and assess the situation:\n      // counting the number of tokens/positions and marking if we have any synonyms.\n      \n      int numTokens = 0;\n      int positionCount = 0;\n      boolean hasSynonyms = false;\n\n      stream.reset();\n      while (stream.incrementToken()) {\n        numTokens++;\n        int positionIncrement = posIncAtt.getPositionIncrement();\n        if (positionIncrement != 0) {\n          positionCount += positionIncrement;\n        } else {\n          hasSynonyms = true;\n        }\n      }\n      \n      // phase 2: based on token count, presence of synonyms, and options\n      // formulate a single term, boolean, or phrase.\n      \n      if (numTokens == 0) {\n        return null;\n      } else if (numTokens == 1) {\n        // single term\n        return analyzeTerm(field, stream);\n      } else if (quoted && positionCount > 1) {\n        // phrase\n        if (hasSynonyms) {\n          // complex phrase with synonyms\n          return analyzeMultiPhrase(field, stream, phraseSlop);\n        } else {\n          // simple phrase\n          return analyzePhrase(field, stream, phraseSlop);\n        }\n      } else {\n        // boolean\n        if (positionCount == 1) {\n          // only one position, with synonyms\n          return analyzeBoolean(field, stream);\n        } else {\n          // complex case: multiple positions\n          return analyzeMultiBoolean(field, stream, operator);\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd564443cc619840b8e9859c46194b087f94ffce","date":1479727773,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(Analyzer,BooleanClause.Occur,String,String,boolean,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(Analyzer,BooleanClause.Occur,String,String,boolean,int).mjava","sourceNew":"  /**\n   * Creates a query from the analysis chain.\n   * <p>\n   * Expert: this is more useful for subclasses such as queryparsers.\n   * If using this class directly, just use {@link #createBooleanQuery(String, String)}\n   * and {@link #createPhraseQuery(String, String)}.  This is a complex method and\n   * it is usually not necessary to override it in a subclass; instead, override\n   * methods like {@link #newBooleanQuery}, etc., if possible.\n   *\n   * @param analyzer analyzer used for this query\n   * @param operator default boolean operator used for this query\n   * @param field field to create queries against\n   * @param queryText text to be passed to the analysis chain\n   * @param quoted true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n    \n    // Use the analyzer to get all the tokens, and then build an appropriate\n    // query based on the analysis chain.\n    \n    try (TokenStream source = analyzer.tokenStream(field, queryText);\n         CachingTokenFilter stream = new CachingTokenFilter(source)) {\n      \n      TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n      PositionIncrementAttribute posIncAtt = stream.addAttribute(PositionIncrementAttribute.class);\n      \n      if (termAtt == null) {\n        return null; \n      }\n      \n      // phase 1: read through the stream and assess the situation:\n      // counting the number of tokens/positions and marking if we have any synonyms.\n      \n      int numTokens = 0;\n      int positionCount = 0;\n      boolean hasSynonyms = false;\n\n      stream.reset();\n      while (stream.incrementToken()) {\n        numTokens++;\n        int positionIncrement = posIncAtt.getPositionIncrement();\n        if (positionIncrement != 0) {\n          positionCount += positionIncrement;\n        } else {\n          hasSynonyms = true;\n        }\n      }\n      \n      // phase 2: based on token count, presence of synonyms, and options\n      // formulate a single term, boolean, or phrase.\n      \n      if (numTokens == 0) {\n        return null;\n      } else if (numTokens == 1) {\n        // single term\n        return analyzeTerm(field, stream);\n      } else if (quoted && positionCount > 1) {\n        // phrase\n        if (hasSynonyms) {\n          // complex phrase with synonyms\n          return analyzeMultiPhrase(field, stream, phraseSlop);\n        } else {\n          // simple phrase\n          return analyzePhrase(field, stream, phraseSlop);\n        }\n      } else {\n        // boolean\n        if (positionCount == 1) {\n          // only one position, with synonyms\n          return analyzeBoolean(field, stream);\n        } else {\n          // complex case: multiple positions\n          return analyzeMultiBoolean(field, stream, operator);\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a query from the analysis chain.\n   * <p>\n   * Expert: this is more useful for subclasses such as queryparsers. \n   * If using this class directly, just use {@link #createBooleanQuery(String, String)}\n   * and {@link #createPhraseQuery(String, String)}\n   * @param analyzer analyzer used for this query\n   * @param operator default boolean operator used for this query\n   * @param field field to create queries against\n   * @param queryText text to be passed to the analysis chain\n   * @param quoted true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n    \n    // Use the analyzer to get all the tokens, and then build an appropriate\n    // query based on the analysis chain.\n    \n    try (TokenStream source = analyzer.tokenStream(field, queryText);\n         CachingTokenFilter stream = new CachingTokenFilter(source)) {\n      \n      TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n      PositionIncrementAttribute posIncAtt = stream.addAttribute(PositionIncrementAttribute.class);\n      \n      if (termAtt == null) {\n        return null; \n      }\n      \n      // phase 1: read through the stream and assess the situation:\n      // counting the number of tokens/positions and marking if we have any synonyms.\n      \n      int numTokens = 0;\n      int positionCount = 0;\n      boolean hasSynonyms = false;\n\n      stream.reset();\n      while (stream.incrementToken()) {\n        numTokens++;\n        int positionIncrement = posIncAtt.getPositionIncrement();\n        if (positionIncrement != 0) {\n          positionCount += positionIncrement;\n        } else {\n          hasSynonyms = true;\n        }\n      }\n      \n      // phase 2: based on token count, presence of synonyms, and options\n      // formulate a single term, boolean, or phrase.\n      \n      if (numTokens == 0) {\n        return null;\n      } else if (numTokens == 1) {\n        // single term\n        return analyzeTerm(field, stream);\n      } else if (quoted && positionCount > 1) {\n        // phrase\n        if (hasSynonyms) {\n          // complex phrase with synonyms\n          return analyzeMultiPhrase(field, stream, phraseSlop);\n        } else {\n          // simple phrase\n          return analyzePhrase(field, stream, phraseSlop);\n        }\n      } else {\n        // boolean\n        if (positionCount == 1) {\n          // only one position, with synonyms\n          return analyzeBoolean(field, stream);\n        } else {\n          // complex case: multiple positions\n          return analyzeMultiBoolean(field, stream, operator);\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cd70af1186a18d10a788433cc33be44327a83ce7","date":1479767946,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(Analyzer,BooleanClause.Occur,String,String,boolean,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(Analyzer,BooleanClause.Occur,String,String,boolean,int).mjava","sourceNew":"  /**\n   * Creates a query from the analysis chain.\n   * <p>\n   * Expert: this is more useful for subclasses such as queryparsers.\n   * If using this class directly, just use {@link #createBooleanQuery(String, String)}\n   * and {@link #createPhraseQuery(String, String)}.  This is a complex method and\n   * it is usually not necessary to override it in a subclass; instead, override\n   * methods like {@link #newBooleanQuery}, etc., if possible.\n   *\n   * @param analyzer analyzer used for this query\n   * @param operator default boolean operator used for this query\n   * @param field field to create queries against\n   * @param queryText text to be passed to the analysis chain\n   * @param quoted true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n    \n    // Use the analyzer to get all the tokens, and then build an appropriate\n    // query based on the analysis chain.\n    \n    try (TokenStream source = analyzer.tokenStream(field, queryText);\n         CachingTokenFilter stream = new CachingTokenFilter(source)) {\n      \n      TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n      PositionIncrementAttribute posIncAtt = stream.addAttribute(PositionIncrementAttribute.class);\n      \n      if (termAtt == null) {\n        return null; \n      }\n      \n      // phase 1: read through the stream and assess the situation:\n      // counting the number of tokens/positions and marking if we have any synonyms.\n      \n      int numTokens = 0;\n      int positionCount = 0;\n      boolean hasSynonyms = false;\n\n      stream.reset();\n      while (stream.incrementToken()) {\n        numTokens++;\n        int positionIncrement = posIncAtt.getPositionIncrement();\n        if (positionIncrement != 0) {\n          positionCount += positionIncrement;\n        } else {\n          hasSynonyms = true;\n        }\n      }\n      \n      // phase 2: based on token count, presence of synonyms, and options\n      // formulate a single term, boolean, or phrase.\n      \n      if (numTokens == 0) {\n        return null;\n      } else if (numTokens == 1) {\n        // single term\n        return analyzeTerm(field, stream);\n      } else if (quoted && positionCount > 1) {\n        // phrase\n        if (hasSynonyms) {\n          // complex phrase with synonyms\n          return analyzeMultiPhrase(field, stream, phraseSlop);\n        } else {\n          // simple phrase\n          return analyzePhrase(field, stream, phraseSlop);\n        }\n      } else {\n        // boolean\n        if (positionCount == 1) {\n          // only one position, with synonyms\n          return analyzeBoolean(field, stream);\n        } else {\n          // complex case: multiple positions\n          return analyzeMultiBoolean(field, stream, operator);\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a query from the analysis chain.\n   * <p>\n   * Expert: this is more useful for subclasses such as queryparsers. \n   * If using this class directly, just use {@link #createBooleanQuery(String, String)}\n   * and {@link #createPhraseQuery(String, String)}\n   * @param analyzer analyzer used for this query\n   * @param operator default boolean operator used for this query\n   * @param field field to create queries against\n   * @param queryText text to be passed to the analysis chain\n   * @param quoted true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n    \n    // Use the analyzer to get all the tokens, and then build an appropriate\n    // query based on the analysis chain.\n    \n    try (TokenStream source = analyzer.tokenStream(field, queryText);\n         CachingTokenFilter stream = new CachingTokenFilter(source)) {\n      \n      TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n      PositionIncrementAttribute posIncAtt = stream.addAttribute(PositionIncrementAttribute.class);\n      \n      if (termAtt == null) {\n        return null; \n      }\n      \n      // phase 1: read through the stream and assess the situation:\n      // counting the number of tokens/positions and marking if we have any synonyms.\n      \n      int numTokens = 0;\n      int positionCount = 0;\n      boolean hasSynonyms = false;\n\n      stream.reset();\n      while (stream.incrementToken()) {\n        numTokens++;\n        int positionIncrement = posIncAtt.getPositionIncrement();\n        if (positionIncrement != 0) {\n          positionCount += positionIncrement;\n        } else {\n          hasSynonyms = true;\n        }\n      }\n      \n      // phase 2: based on token count, presence of synonyms, and options\n      // formulate a single term, boolean, or phrase.\n      \n      if (numTokens == 0) {\n        return null;\n      } else if (numTokens == 1) {\n        // single term\n        return analyzeTerm(field, stream);\n      } else if (quoted && positionCount > 1) {\n        // phrase\n        if (hasSynonyms) {\n          // complex phrase with synonyms\n          return analyzeMultiPhrase(field, stream, phraseSlop);\n        } else {\n          // simple phrase\n          return analyzePhrase(field, stream, phraseSlop);\n        }\n      } else {\n        // boolean\n        if (positionCount == 1) {\n          // only one position, with synonyms\n          return analyzeBoolean(field, stream);\n        } else {\n          // complex case: multiple positions\n          return analyzeMultiBoolean(field, stream, operator);\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e52c30617998e1bc2a946cc226f52e9b35162b1e","date":1483438353,"type":3,"author":"Matt Weber","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(Analyzer,BooleanClause.Occur,String,String,boolean,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(Analyzer,BooleanClause.Occur,String,String,boolean,int).mjava","sourceNew":"  /**\n   * Creates a query from the analysis chain.\n   * <p>\n   * Expert: this is more useful for subclasses such as queryparsers.\n   * If using this class directly, just use {@link #createBooleanQuery(String, String)}\n   * and {@link #createPhraseQuery(String, String)}.  This is a complex method and\n   * it is usually not necessary to override it in a subclass; instead, override\n   * methods like {@link #newBooleanQuery}, etc., if possible.\n   *\n   * @param analyzer   analyzer used for this query\n   * @param operator   default boolean operator used for this query\n   * @param field      field to create queries against\n   * @param queryText  text to be passed to the analysis chain\n   * @param quoted     true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n\n    // Use the analyzer to get all the tokens, and then build an appropriate\n    // query based on the analysis chain.\n    try (TokenStream source = analyzer.tokenStream(field, queryText)) {\n      return createFieldQuery(source, operator, field, quoted, phraseSlop);\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a query from the analysis chain.\n   * <p>\n   * Expert: this is more useful for subclasses such as queryparsers.\n   * If using this class directly, just use {@link #createBooleanQuery(String, String)}\n   * and {@link #createPhraseQuery(String, String)}.  This is a complex method and\n   * it is usually not necessary to override it in a subclass; instead, override\n   * methods like {@link #newBooleanQuery}, etc., if possible.\n   *\n   * @param analyzer analyzer used for this query\n   * @param operator default boolean operator used for this query\n   * @param field field to create queries against\n   * @param queryText text to be passed to the analysis chain\n   * @param quoted true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n    \n    // Use the analyzer to get all the tokens, and then build an appropriate\n    // query based on the analysis chain.\n    \n    try (TokenStream source = analyzer.tokenStream(field, queryText);\n         CachingTokenFilter stream = new CachingTokenFilter(source)) {\n      \n      TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n      PositionIncrementAttribute posIncAtt = stream.addAttribute(PositionIncrementAttribute.class);\n      \n      if (termAtt == null) {\n        return null; \n      }\n      \n      // phase 1: read through the stream and assess the situation:\n      // counting the number of tokens/positions and marking if we have any synonyms.\n      \n      int numTokens = 0;\n      int positionCount = 0;\n      boolean hasSynonyms = false;\n\n      stream.reset();\n      while (stream.incrementToken()) {\n        numTokens++;\n        int positionIncrement = posIncAtt.getPositionIncrement();\n        if (positionIncrement != 0) {\n          positionCount += positionIncrement;\n        } else {\n          hasSynonyms = true;\n        }\n      }\n      \n      // phase 2: based on token count, presence of synonyms, and options\n      // formulate a single term, boolean, or phrase.\n      \n      if (numTokens == 0) {\n        return null;\n      } else if (numTokens == 1) {\n        // single term\n        return analyzeTerm(field, stream);\n      } else if (quoted && positionCount > 1) {\n        // phrase\n        if (hasSynonyms) {\n          // complex phrase with synonyms\n          return analyzeMultiPhrase(field, stream, phraseSlop);\n        } else {\n          // simple phrase\n          return analyzePhrase(field, stream, phraseSlop);\n        }\n      } else {\n        // boolean\n        if (positionCount == 1) {\n          // only one position, with synonyms\n          return analyzeBoolean(field, stream);\n        } else {\n          // complex case: multiple positions\n          return analyzeMultiBoolean(field, stream, operator);\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(Analyzer,BooleanClause.Occur,String,String,boolean,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createFieldQuery(Analyzer,BooleanClause.Occur,String,String,boolean,int).mjava","sourceNew":"  /**\n   * Creates a query from the analysis chain.\n   * <p>\n   * Expert: this is more useful for subclasses such as queryparsers.\n   * If using this class directly, just use {@link #createBooleanQuery(String, String)}\n   * and {@link #createPhraseQuery(String, String)}.  This is a complex method and\n   * it is usually not necessary to override it in a subclass; instead, override\n   * methods like {@link #newBooleanQuery}, etc., if possible.\n   *\n   * @param analyzer   analyzer used for this query\n   * @param operator   default boolean operator used for this query\n   * @param field      field to create queries against\n   * @param queryText  text to be passed to the analysis chain\n   * @param quoted     true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n\n    // Use the analyzer to get all the tokens, and then build an appropriate\n    // query based on the analysis chain.\n    try (TokenStream source = analyzer.tokenStream(field, queryText)) {\n      return createFieldQuery(source, operator, field, quoted, phraseSlop);\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a query from the analysis chain.\n   * <p>\n   * Expert: this is more useful for subclasses such as queryparsers.\n   * If using this class directly, just use {@link #createBooleanQuery(String, String)}\n   * and {@link #createPhraseQuery(String, String)}.  This is a complex method and\n   * it is usually not necessary to override it in a subclass; instead, override\n   * methods like {@link #newBooleanQuery}, etc., if possible.\n   *\n   * @param analyzer analyzer used for this query\n   * @param operator default boolean operator used for this query\n   * @param field field to create queries against\n   * @param queryText text to be passed to the analysis chain\n   * @param quoted true if phrases should be generated when terms occur at more than one position\n   * @param phraseSlop slop factor for phrase/multiphrase queries\n   */\n  protected Query createFieldQuery(Analyzer analyzer, BooleanClause.Occur operator, String field, String queryText, boolean quoted, int phraseSlop) {\n    assert operator == BooleanClause.Occur.SHOULD || operator == BooleanClause.Occur.MUST;\n    \n    // Use the analyzer to get all the tokens, and then build an appropriate\n    // query based on the analysis chain.\n    \n    try (TokenStream source = analyzer.tokenStream(field, queryText);\n         CachingTokenFilter stream = new CachingTokenFilter(source)) {\n      \n      TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n      PositionIncrementAttribute posIncAtt = stream.addAttribute(PositionIncrementAttribute.class);\n      \n      if (termAtt == null) {\n        return null; \n      }\n      \n      // phase 1: read through the stream and assess the situation:\n      // counting the number of tokens/positions and marking if we have any synonyms.\n      \n      int numTokens = 0;\n      int positionCount = 0;\n      boolean hasSynonyms = false;\n\n      stream.reset();\n      while (stream.incrementToken()) {\n        numTokens++;\n        int positionIncrement = posIncAtt.getPositionIncrement();\n        if (positionIncrement != 0) {\n          positionCount += positionIncrement;\n        } else {\n          hasSynonyms = true;\n        }\n      }\n      \n      // phase 2: based on token count, presence of synonyms, and options\n      // formulate a single term, boolean, or phrase.\n      \n      if (numTokens == 0) {\n        return null;\n      } else if (numTokens == 1) {\n        // single term\n        return analyzeTerm(field, stream);\n      } else if (quoted && positionCount > 1) {\n        // phrase\n        if (hasSynonyms) {\n          // complex phrase with synonyms\n          return analyzeMultiPhrase(field, stream, phraseSlop);\n        } else {\n          // simple phrase\n          return analyzePhrase(field, stream, phraseSlop);\n        }\n      } else {\n        // boolean\n        if (positionCount == 1) {\n          // only one position, with synonyms\n          return analyzeBoolean(field, stream);\n        } else {\n          // complex case: multiple positions\n          return analyzeMultiBoolean(field, stream, operator);\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error analyzing query text\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["c1c1dd5dce93e4fa48898dabc7e012560acda425"],"8b49777657109e40eeddc1c8b0f7850d3c06e1ed":["f6a724f3ec10207bc28cd9df28ff4c5c7ca07046"],"e52c30617998e1bc2a946cc226f52e9b35162b1e":["bd564443cc619840b8e9859c46194b087f94ffce"],"bd564443cc619840b8e9859c46194b087f94ffce":["862812e92a417c556229d16d45bffc8c8a98b159"],"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","3394716f52b34ab259ad5247e7595d9f9db6e935"],"cd70af1186a18d10a788433cc33be44327a83ce7":["2e859e664a65796dadf8aaf65db6f66f3a885368","bd564443cc619840b8e9859c46194b087f94ffce"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["cd70af1186a18d10a788433cc33be44327a83ce7","e52c30617998e1bc2a946cc226f52e9b35162b1e"],"3394716f52b34ab259ad5247e7595d9f9db6e935":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","63241596de245e96a0a3c36c7b03eb92130b81db"],"c1c1dd5dce93e4fa48898dabc7e012560acda425":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"63241596de245e96a0a3c36c7b03eb92130b81db":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"862812e92a417c556229d16d45bffc8c8a98b159":["8b49777657109e40eeddc1c8b0f7850d3c06e1ed"],"f6a724f3ec10207bc28cd9df28ff4c5c7ca07046":["55244759f906151d96839f8451dee793acb06e75"],"2e859e664a65796dadf8aaf65db6f66f3a885368":["8b49777657109e40eeddc1c8b0f7850d3c06e1ed","862812e92a417c556229d16d45bffc8c8a98b159"],"55244759f906151d96839f8451dee793acb06e75":["3394716f52b34ab259ad5247e7595d9f9db6e935"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e52c30617998e1bc2a946cc226f52e9b35162b1e"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","3394716f52b34ab259ad5247e7595d9f9db6e935","63241596de245e96a0a3c36c7b03eb92130b81db"],"8b49777657109e40eeddc1c8b0f7850d3c06e1ed":["862812e92a417c556229d16d45bffc8c8a98b159","2e859e664a65796dadf8aaf65db6f66f3a885368"],"e52c30617998e1bc2a946cc226f52e9b35162b1e":["f03e4bed5023ec3ef93a771b8888cae991cf448d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bd564443cc619840b8e9859c46194b087f94ffce":["e52c30617998e1bc2a946cc226f52e9b35162b1e","cd70af1186a18d10a788433cc33be44327a83ce7"],"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":[],"cd70af1186a18d10a788433cc33be44327a83ce7":["f03e4bed5023ec3ef93a771b8888cae991cf448d"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":[],"3394716f52b34ab259ad5247e7595d9f9db6e935":["c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","55244759f906151d96839f8451dee793acb06e75"],"c1c1dd5dce93e4fa48898dabc7e012560acda425":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"63241596de245e96a0a3c36c7b03eb92130b81db":["3394716f52b34ab259ad5247e7595d9f9db6e935"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c1c1dd5dce93e4fa48898dabc7e012560acda425"],"f6a724f3ec10207bc28cd9df28ff4c5c7ca07046":["8b49777657109e40eeddc1c8b0f7850d3c06e1ed"],"862812e92a417c556229d16d45bffc8c8a98b159":["bd564443cc619840b8e9859c46194b087f94ffce","2e859e664a65796dadf8aaf65db6f66f3a885368"],"2e859e664a65796dadf8aaf65db6f66f3a885368":["cd70af1186a18d10a788433cc33be44327a83ce7"],"55244759f906151d96839f8451dee793acb06e75":["f6a724f3ec10207bc28cd9df28ff4c5c7ca07046"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","f03e4bed5023ec3ef93a771b8888cae991cf448d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}