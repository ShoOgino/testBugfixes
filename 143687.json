{"path":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","commits":[{"id":"00e1c8e1340d9e31d2c6bee5f72d9040ce569049","date":1431584404,"type":1,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#setContext().mjava","sourceNew":"  private void init() throws Exception {\n    //The states of client that is invalid in this request\n    Aliases aliases = null;\n    String corename = \"\";\n    String origCorename = null;\n    // set a request timer which can be reused by requests if needed\n    req.setAttribute(SolrRequestParsers.REQUEST_TIMER_SERVLET_ATTRIBUTE, new RTimer());\n    // put the core container in request attribute\n    req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n    path = req.getServletPath();\n    if (req.getPathInfo() != null) {\n      // this lets you handle /update/commit when /update is a servlet\n      path += req.getPathInfo();\n    }\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    boolean usingAliases = false;\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    } else {\n      //otherwise, we should find a core from the path\n      idx = path.indexOf(\"/\", 1);\n      if (idx > 1) {\n        // try to get the corename as a request parameter first\n        corename = path.substring(1, idx);\n\n        // look at aliases\n        if (cores.isZooKeeperAware()) {\n          origCorename = corename;\n          ZkStateReader reader = cores.getZkController().getZkStateReader();\n          aliases = reader.getAliases();\n          if (aliases != null && aliases.collectionAliasSize() > 0) {\n            usingAliases = true;\n            String alias = aliases.getCollectionAlias(corename);\n            if (alias != null) {\n              collectionsList = StrUtils.splitSmart(alias, \",\", true);\n              corename = collectionsList.get(0);\n            }\n          }\n        }\n\n        core = cores.getCore(corename);\n        if (core != null) {\n          path = path.substring(idx);\n        }\n      }\n      if (core == null) {\n        if (!cores.isZooKeeperAware()) {\n          core = cores.getCore(\"\");\n        }\n      }\n    }\n\n    if (core != null) addMDCValues();\n\n    if (core == null && cores.isZooKeeperAware()) {\n      // we couldn't find the core - lets make sure a collection was not specified instead\n      core = getCoreByCollection(corename);\n      if (core != null) {\n        // we found a core, update the path\n        path = path.substring(idx);\n        addMDCValues();\n        if (collectionsList == null)\n          collectionsList = new ArrayList<>();\n        collectionsList.add(corename);\n      }\n\n      // if we couldn't find it locally, look on other nodes\n      extractRemotePath(corename, origCorename, idx);\n      if (action != null) return;\n\n      // try the default core\n      if (core == null) {\n        core = cores.getCore(\"\");\n        if (core != null) addMDCValues();\n      }\n    }\n\n    // With a valid core...\n    if (core != null) {\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        if (usingAliases) {\n          processAliases(aliases, collectionsList);\n        }\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    SolrDispatchFilter.log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","sourceOld":"  private void setContext() throws Exception {\n    //The states of client that is invalid in this request\n    Aliases aliases = null;\n    String corename = \"\";\n    String origCorename = null;\n    // set a request timer which can be reused by requests if needed\n    req.setAttribute(SolrRequestParsers.REQUEST_TIMER_SERVLET_ATTRIBUTE, new RTimer());\n    // put the core container in request attribute\n    req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n    path = req.getServletPath();\n    if (req.getPathInfo() != null) {\n      // this lets you handle /update/commit when /update is a servlet\n      path += req.getPathInfo();\n    }\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    boolean usingAliases = false;\n    List<String> collectionsList = null;\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      action = ADMIN;\n      return;\n    } else {\n      //otherwise, we should find a core from the path\n      idx = path.indexOf(\"/\", 1);\n      if (idx > 1) {\n        // try to get the corename as a request parameter first\n        corename = path.substring(1, idx);\n\n        // look at aliases\n        if (cores.isZooKeeperAware()) {\n          origCorename = corename;\n          ZkStateReader reader = cores.getZkController().getZkStateReader();\n          aliases = reader.getAliases();\n          if (aliases != null && aliases.collectionAliasSize() > 0) {\n            usingAliases = true;\n            String alias = aliases.getCollectionAlias(corename);\n            if (alias != null) {\n              collectionsList = StrUtils.splitSmart(alias, \",\", true);\n              corename = collectionsList.get(0);\n            }\n          }\n        }\n\n        core = cores.getCore(corename);\n        if (core != null) {\n          path = path.substring(idx);\n        }\n      }\n      if (core == null) {\n        if (!cores.isZooKeeperAware()) {\n          core = cores.getCore(\"\");\n        }\n      }\n    }\n\n    if (core != null) addMDCValues();\n\n    if (core == null && cores.isZooKeeperAware()) {\n      // we couldn't find the core - lets make sure a collection was not specified instead\n      core = getCoreByCollection(corename);\n      if (core != null) {\n        // we found a core, update the path\n        path = path.substring(idx);\n        addMDCValues();\n      }\n\n      // if we couldn't find it locally, look on other nodes\n      extractRemotePath(corename, origCorename, idx);\n      if (action != null) return;\n\n      // try the default core\n      if (core == null) {\n        core = cores.getCore(\"\");\n        if (core != null) addMDCValues();\n      }\n    }\n\n    // With a valid core...\n    if (core != null) {\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        if (usingAliases) {\n          processAliases(aliases, collectionsList);\n        }\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    SolrDispatchFilter.log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"439c63ae5d22132fca810a0029a854e97d2c1a3e","date":1432733612,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","sourceNew":"  private void init() throws Exception {\n    //The states of client that is invalid in this request\n    Aliases aliases = null;\n    String corename = \"\";\n    String origCorename = null;\n    // set a request timer which can be reused by requests if needed\n    req.setAttribute(SolrRequestParsers.REQUEST_TIMER_SERVLET_ATTRIBUTE, new RTimer());\n    // put the core container in request attribute\n    req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n    path = req.getServletPath();\n    if (req.getPathInfo() != null) {\n      // this lets you handle /update/commit when /update is a servlet\n      path += req.getPathInfo();\n    }\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    boolean usingAliases = false;\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    } else {\n      //otherwise, we should find a core from the path\n      idx = path.indexOf(\"/\", 1);\n      if (idx > 1) {\n        // try to get the corename as a request parameter first\n        corename = path.substring(1, idx);\n\n        // look at aliases\n        if (cores.isZooKeeperAware()) {\n          origCorename = corename;\n          ZkStateReader reader = cores.getZkController().getZkStateReader();\n          aliases = reader.getAliases();\n          if (aliases != null && aliases.collectionAliasSize() > 0) {\n            usingAliases = true;\n            String alias = aliases.getCollectionAlias(corename);\n            if (alias != null) {\n              collectionsList = StrUtils.splitSmart(alias, \",\", true);\n              corename = collectionsList.get(0);\n            }\n          }\n        }\n\n        core = cores.getCore(corename);\n        if (core != null) {\n          path = path.substring(idx);\n        }\n      }\n      if (core == null) {\n        if (!cores.isZooKeeperAware()) {\n          core = cores.getCore(\"\");\n        }\n      }\n    }\n\n    if (core == null && cores.isZooKeeperAware()) {\n      // we couldn't find the core - lets make sure a collection was not specified instead\n      core = getCoreByCollection(corename);\n      if (core != null) {\n        // we found a core, update the path\n        path = path.substring(idx);\n        if (collectionsList == null)\n          collectionsList = new ArrayList<>();\n        collectionsList.add(corename);\n      }\n\n      // if we couldn't find it locally, look on other nodes\n      extractRemotePath(corename, origCorename, idx);\n      if (action != null) return;\n\n      // try the default core\n      if (core == null) {\n        core = cores.getCore(\"\");\n      }\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        if (usingAliases) {\n          processAliases(aliases, collectionsList);\n        }\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    SolrDispatchFilter.log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","sourceOld":"  private void init() throws Exception {\n    //The states of client that is invalid in this request\n    Aliases aliases = null;\n    String corename = \"\";\n    String origCorename = null;\n    // set a request timer which can be reused by requests if needed\n    req.setAttribute(SolrRequestParsers.REQUEST_TIMER_SERVLET_ATTRIBUTE, new RTimer());\n    // put the core container in request attribute\n    req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n    path = req.getServletPath();\n    if (req.getPathInfo() != null) {\n      // this lets you handle /update/commit when /update is a servlet\n      path += req.getPathInfo();\n    }\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    boolean usingAliases = false;\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    } else {\n      //otherwise, we should find a core from the path\n      idx = path.indexOf(\"/\", 1);\n      if (idx > 1) {\n        // try to get the corename as a request parameter first\n        corename = path.substring(1, idx);\n\n        // look at aliases\n        if (cores.isZooKeeperAware()) {\n          origCorename = corename;\n          ZkStateReader reader = cores.getZkController().getZkStateReader();\n          aliases = reader.getAliases();\n          if (aliases != null && aliases.collectionAliasSize() > 0) {\n            usingAliases = true;\n            String alias = aliases.getCollectionAlias(corename);\n            if (alias != null) {\n              collectionsList = StrUtils.splitSmart(alias, \",\", true);\n              corename = collectionsList.get(0);\n            }\n          }\n        }\n\n        core = cores.getCore(corename);\n        if (core != null) {\n          path = path.substring(idx);\n        }\n      }\n      if (core == null) {\n        if (!cores.isZooKeeperAware()) {\n          core = cores.getCore(\"\");\n        }\n      }\n    }\n\n    if (core != null) addMDCValues();\n\n    if (core == null && cores.isZooKeeperAware()) {\n      // we couldn't find the core - lets make sure a collection was not specified instead\n      core = getCoreByCollection(corename);\n      if (core != null) {\n        // we found a core, update the path\n        path = path.substring(idx);\n        addMDCValues();\n        if (collectionsList == null)\n          collectionsList = new ArrayList<>();\n        collectionsList.add(corename);\n      }\n\n      // if we couldn't find it locally, look on other nodes\n      extractRemotePath(corename, origCorename, idx);\n      if (action != null) return;\n\n      // try the default core\n      if (core == null) {\n        core = cores.getCore(\"\");\n        if (core != null) addMDCValues();\n      }\n    }\n\n    // With a valid core...\n    if (core != null) {\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        if (usingAliases) {\n          processAliases(aliases, collectionsList);\n        }\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    SolrDispatchFilter.log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"275019a81d0883a1db4560391b072d1fbe272ec4","date":1432741049,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","sourceNew":"  private void init() throws Exception {\n    //The states of client that is invalid in this request\n    Aliases aliases = null;\n    String corename = \"\";\n    String origCorename = null;\n    // set a request timer which can be reused by requests if needed\n    req.setAttribute(SolrRequestParsers.REQUEST_TIMER_SERVLET_ATTRIBUTE, new RTimer());\n    // put the core container in request attribute\n    req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n    path = req.getServletPath();\n    if (req.getPathInfo() != null) {\n      // this lets you handle /update/commit when /update is a servlet\n      path += req.getPathInfo();\n    }\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    boolean usingAliases = false;\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    } else {\n      //otherwise, we should find a core from the path\n      idx = path.indexOf(\"/\", 1);\n      if (idx > 1) {\n        // try to get the corename as a request parameter first\n        corename = path.substring(1, idx);\n\n        // look at aliases\n        if (cores.isZooKeeperAware()) {\n          origCorename = corename;\n          ZkStateReader reader = cores.getZkController().getZkStateReader();\n          aliases = reader.getAliases();\n          if (aliases != null && aliases.collectionAliasSize() > 0) {\n            usingAliases = true;\n            String alias = aliases.getCollectionAlias(corename);\n            if (alias != null) {\n              collectionsList = StrUtils.splitSmart(alias, \",\", true);\n              corename = collectionsList.get(0);\n            }\n          }\n        }\n\n        core = cores.getCore(corename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else if (cores.isCoreLoading(corename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        } else {\n          // the core may have just finished loading\n          core = cores.getCore(corename);\n          if (core != null) {\n            path = path.substring(idx);\n          } \n        }\n      }\n      if (core == null) {\n        if (!cores.isZooKeeperAware()) {\n          core = cores.getCore(\"\");\n        }\n      }\n    }\n\n    if (core == null && cores.isZooKeeperAware()) {\n      // we couldn't find the core - lets make sure a collection was not specified instead\n      core = getCoreByCollection(corename);\n      if (core != null) {\n        // we found a core, update the path\n        path = path.substring(idx);\n        if (collectionsList == null)\n          collectionsList = new ArrayList<>();\n        collectionsList.add(corename);\n      }\n\n      // if we couldn't find it locally, look on other nodes\n      extractRemotePath(corename, origCorename, idx);\n      if (action != null) return;\n\n      // try the default core\n      if (core == null) {\n        core = cores.getCore(\"\");\n      }\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        if (usingAliases) {\n          processAliases(aliases, collectionsList);\n        }\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    SolrDispatchFilter.log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","sourceOld":"  private void init() throws Exception {\n    //The states of client that is invalid in this request\n    Aliases aliases = null;\n    String corename = \"\";\n    String origCorename = null;\n    // set a request timer which can be reused by requests if needed\n    req.setAttribute(SolrRequestParsers.REQUEST_TIMER_SERVLET_ATTRIBUTE, new RTimer());\n    // put the core container in request attribute\n    req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n    path = req.getServletPath();\n    if (req.getPathInfo() != null) {\n      // this lets you handle /update/commit when /update is a servlet\n      path += req.getPathInfo();\n    }\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    boolean usingAliases = false;\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    } else {\n      //otherwise, we should find a core from the path\n      idx = path.indexOf(\"/\", 1);\n      if (idx > 1) {\n        // try to get the corename as a request parameter first\n        corename = path.substring(1, idx);\n\n        // look at aliases\n        if (cores.isZooKeeperAware()) {\n          origCorename = corename;\n          ZkStateReader reader = cores.getZkController().getZkStateReader();\n          aliases = reader.getAliases();\n          if (aliases != null && aliases.collectionAliasSize() > 0) {\n            usingAliases = true;\n            String alias = aliases.getCollectionAlias(corename);\n            if (alias != null) {\n              collectionsList = StrUtils.splitSmart(alias, \",\", true);\n              corename = collectionsList.get(0);\n            }\n          }\n        }\n\n        core = cores.getCore(corename);\n        if (core != null) {\n          path = path.substring(idx);\n        }\n      }\n      if (core == null) {\n        if (!cores.isZooKeeperAware()) {\n          core = cores.getCore(\"\");\n        }\n      }\n    }\n\n    if (core == null && cores.isZooKeeperAware()) {\n      // we couldn't find the core - lets make sure a collection was not specified instead\n      core = getCoreByCollection(corename);\n      if (core != null) {\n        // we found a core, update the path\n        path = path.substring(idx);\n        if (collectionsList == null)\n          collectionsList = new ArrayList<>();\n        collectionsList.add(corename);\n      }\n\n      // if we couldn't find it locally, look on other nodes\n      extractRemotePath(corename, origCorename, idx);\n      if (action != null) return;\n\n      // try the default core\n      if (core == null) {\n        core = cores.getCore(\"\");\n      }\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        if (usingAliases) {\n          processAliases(aliases, collectionsList);\n        }\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    SolrDispatchFilter.log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"104456f4eeacc857f7e1e6408e1483de8c2bd658","date":1439164522,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","sourceNew":"  private void init() throws Exception {\n    //The states of client that is invalid in this request\n    Aliases aliases = null;\n    String corename = \"\";\n    String origCorename = null;\n    // set a request timer which can be reused by requests if needed\n    req.setAttribute(SolrRequestParsers.REQUEST_TIMER_SERVLET_ATTRIBUTE, new RTimerTree());\n    // put the core container in request attribute\n    req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n    path = req.getServletPath();\n    if (req.getPathInfo() != null) {\n      // this lets you handle /update/commit when /update is a servlet\n      path += req.getPathInfo();\n    }\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    boolean usingAliases = false;\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    } else {\n      //otherwise, we should find a core from the path\n      idx = path.indexOf(\"/\", 1);\n      if (idx > 1) {\n        // try to get the corename as a request parameter first\n        corename = path.substring(1, idx);\n\n        // look at aliases\n        if (cores.isZooKeeperAware()) {\n          origCorename = corename;\n          ZkStateReader reader = cores.getZkController().getZkStateReader();\n          aliases = reader.getAliases();\n          if (aliases != null && aliases.collectionAliasSize() > 0) {\n            usingAliases = true;\n            String alias = aliases.getCollectionAlias(corename);\n            if (alias != null) {\n              collectionsList = StrUtils.splitSmart(alias, \",\", true);\n              corename = collectionsList.get(0);\n            }\n          }\n        }\n\n        core = cores.getCore(corename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else if (cores.isCoreLoading(corename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        } else {\n          // the core may have just finished loading\n          core = cores.getCore(corename);\n          if (core != null) {\n            path = path.substring(idx);\n          } \n        }\n      }\n      if (core == null) {\n        if (!cores.isZooKeeperAware()) {\n          core = cores.getCore(\"\");\n        }\n      }\n    }\n\n    if (core == null && cores.isZooKeeperAware()) {\n      // we couldn't find the core - lets make sure a collection was not specified instead\n      core = getCoreByCollection(corename);\n      if (core != null) {\n        // we found a core, update the path\n        path = path.substring(idx);\n        if (collectionsList == null)\n          collectionsList = new ArrayList<>();\n        collectionsList.add(corename);\n      }\n\n      // if we couldn't find it locally, look on other nodes\n      extractRemotePath(corename, origCorename, idx);\n      if (action != null) return;\n\n      // try the default core\n      if (core == null) {\n        core = cores.getCore(\"\");\n      }\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        if (usingAliases) {\n          processAliases(aliases, collectionsList);\n        }\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    SolrDispatchFilter.log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","sourceOld":"  private void init() throws Exception {\n    //The states of client that is invalid in this request\n    Aliases aliases = null;\n    String corename = \"\";\n    String origCorename = null;\n    // set a request timer which can be reused by requests if needed\n    req.setAttribute(SolrRequestParsers.REQUEST_TIMER_SERVLET_ATTRIBUTE, new RTimer());\n    // put the core container in request attribute\n    req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n    path = req.getServletPath();\n    if (req.getPathInfo() != null) {\n      // this lets you handle /update/commit when /update is a servlet\n      path += req.getPathInfo();\n    }\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    boolean usingAliases = false;\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    } else {\n      //otherwise, we should find a core from the path\n      idx = path.indexOf(\"/\", 1);\n      if (idx > 1) {\n        // try to get the corename as a request parameter first\n        corename = path.substring(1, idx);\n\n        // look at aliases\n        if (cores.isZooKeeperAware()) {\n          origCorename = corename;\n          ZkStateReader reader = cores.getZkController().getZkStateReader();\n          aliases = reader.getAliases();\n          if (aliases != null && aliases.collectionAliasSize() > 0) {\n            usingAliases = true;\n            String alias = aliases.getCollectionAlias(corename);\n            if (alias != null) {\n              collectionsList = StrUtils.splitSmart(alias, \",\", true);\n              corename = collectionsList.get(0);\n            }\n          }\n        }\n\n        core = cores.getCore(corename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else if (cores.isCoreLoading(corename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        } else {\n          // the core may have just finished loading\n          core = cores.getCore(corename);\n          if (core != null) {\n            path = path.substring(idx);\n          } \n        }\n      }\n      if (core == null) {\n        if (!cores.isZooKeeperAware()) {\n          core = cores.getCore(\"\");\n        }\n      }\n    }\n\n    if (core == null && cores.isZooKeeperAware()) {\n      // we couldn't find the core - lets make sure a collection was not specified instead\n      core = getCoreByCollection(corename);\n      if (core != null) {\n        // we found a core, update the path\n        path = path.substring(idx);\n        if (collectionsList == null)\n          collectionsList = new ArrayList<>();\n        collectionsList.add(corename);\n      }\n\n      // if we couldn't find it locally, look on other nodes\n      extractRemotePath(corename, origCorename, idx);\n      if (action != null) return;\n\n      // try the default core\n      if (core == null) {\n        core = cores.getCore(\"\");\n      }\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        if (usingAliases) {\n          processAliases(aliases, collectionsList);\n        }\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    SolrDispatchFilter.log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8e644f11c9d0dc0769d5dd5f842612a9dfa6ecde","date":1447990946,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","sourceNew":"  private void init() throws Exception {\n    //The states of client that is invalid in this request\n    Aliases aliases = null;\n    String corename = \"\";\n    String origCorename = null;\n    // set a request timer which can be reused by requests if needed\n    req.setAttribute(SolrRequestParsers.REQUEST_TIMER_SERVLET_ATTRIBUTE, new RTimerTree());\n    // put the core container in request attribute\n    req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n    path = req.getServletPath();\n    if (req.getPathInfo() != null) {\n      // this lets you handle /update/commit when /update is a servlet\n      path += req.getPathInfo();\n    }\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    boolean usingAliases = false;\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    } else {\n      //otherwise, we should find a core from the path\n      idx = path.indexOf(\"/\", 1);\n      if (idx > 1) {\n        // try to get the corename as a request parameter first\n        corename = path.substring(1, idx);\n\n        // look at aliases\n        if (cores.isZooKeeperAware()) {\n          origCorename = corename;\n          ZkStateReader reader = cores.getZkController().getZkStateReader();\n          aliases = reader.getAliases();\n          if (aliases != null && aliases.collectionAliasSize() > 0) {\n            usingAliases = true;\n            String alias = aliases.getCollectionAlias(corename);\n            if (alias != null) {\n              collectionsList = StrUtils.splitSmart(alias, \",\", true);\n              corename = collectionsList.get(0);\n            }\n          }\n        }\n\n        core = cores.getCore(corename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else if (cores.isCoreLoading(corename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        } else {\n          // the core may have just finished loading\n          core = cores.getCore(corename);\n          if (core != null) {\n            path = path.substring(idx);\n          } \n        }\n      }\n      if (core == null) {\n        if (!cores.isZooKeeperAware()) {\n          core = cores.getCore(\"\");\n        }\n      }\n    }\n\n    if (core == null && cores.isZooKeeperAware()) {\n      // we couldn't find the core - lets make sure a collection was not specified instead\n      core = getCoreByCollection(corename);\n      if (core != null) {\n        // we found a core, update the path\n        path = path.substring(idx);\n        if (collectionsList == null)\n          collectionsList = new ArrayList<>();\n        collectionsList.add(corename);\n      }\n\n      // if we couldn't find it locally, look on other nodes\n      extractRemotePath(corename, origCorename, idx);\n      if (action != null) return;\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        if (usingAliases) {\n          processAliases(aliases, collectionsList);\n        }\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    SolrDispatchFilter.log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","sourceOld":"  private void init() throws Exception {\n    //The states of client that is invalid in this request\n    Aliases aliases = null;\n    String corename = \"\";\n    String origCorename = null;\n    // set a request timer which can be reused by requests if needed\n    req.setAttribute(SolrRequestParsers.REQUEST_TIMER_SERVLET_ATTRIBUTE, new RTimerTree());\n    // put the core container in request attribute\n    req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n    path = req.getServletPath();\n    if (req.getPathInfo() != null) {\n      // this lets you handle /update/commit when /update is a servlet\n      path += req.getPathInfo();\n    }\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    boolean usingAliases = false;\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    } else {\n      //otherwise, we should find a core from the path\n      idx = path.indexOf(\"/\", 1);\n      if (idx > 1) {\n        // try to get the corename as a request parameter first\n        corename = path.substring(1, idx);\n\n        // look at aliases\n        if (cores.isZooKeeperAware()) {\n          origCorename = corename;\n          ZkStateReader reader = cores.getZkController().getZkStateReader();\n          aliases = reader.getAliases();\n          if (aliases != null && aliases.collectionAliasSize() > 0) {\n            usingAliases = true;\n            String alias = aliases.getCollectionAlias(corename);\n            if (alias != null) {\n              collectionsList = StrUtils.splitSmart(alias, \",\", true);\n              corename = collectionsList.get(0);\n            }\n          }\n        }\n\n        core = cores.getCore(corename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else if (cores.isCoreLoading(corename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        } else {\n          // the core may have just finished loading\n          core = cores.getCore(corename);\n          if (core != null) {\n            path = path.substring(idx);\n          } \n        }\n      }\n      if (core == null) {\n        if (!cores.isZooKeeperAware()) {\n          core = cores.getCore(\"\");\n        }\n      }\n    }\n\n    if (core == null && cores.isZooKeeperAware()) {\n      // we couldn't find the core - lets make sure a collection was not specified instead\n      core = getCoreByCollection(corename);\n      if (core != null) {\n        // we found a core, update the path\n        path = path.substring(idx);\n        if (collectionsList == null)\n          collectionsList = new ArrayList<>();\n        collectionsList.add(corename);\n      }\n\n      // if we couldn't find it locally, look on other nodes\n      extractRemotePath(corename, origCorename, idx);\n      if (action != null) return;\n\n      // try the default core\n      if (core == null) {\n        core = cores.getCore(\"\");\n      }\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        if (usingAliases) {\n          processAliases(aliases, collectionsList);\n        }\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    SolrDispatchFilter.log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9367dbf5b00d7764583d991c1888f4acc9c9991a","date":1449048142,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","sourceNew":"  private void init() throws Exception {\n    //The states of client that is invalid in this request\n    Aliases aliases = null;\n    String corename = \"\";\n    String origCorename = null;\n    // set a request timer which can be reused by requests if needed\n    req.setAttribute(SolrRequestParsers.REQUEST_TIMER_SERVLET_ATTRIBUTE, new RTimerTree());\n    // put the core container in request attribute\n    req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n    path = req.getServletPath();\n    if (req.getPathInfo() != null) {\n      // this lets you handle /update/commit when /update is a servlet\n      path += req.getPathInfo();\n    }\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    boolean usingAliases = false;\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    } else {\n      //otherwise, we should find a core from the path\n      idx = path.indexOf(\"/\", 1);\n      if (idx > 1) {\n        // try to get the corename as a request parameter first\n        corename = path.substring(1, idx);\n\n        // look at aliases\n        if (cores.isZooKeeperAware()) {\n          origCorename = corename;\n          ZkStateReader reader = cores.getZkController().getZkStateReader();\n          aliases = reader.getAliases();\n          if (aliases != null && aliases.collectionAliasSize() > 0) {\n            usingAliases = true;\n            String alias = aliases.getCollectionAlias(corename);\n            if (alias != null) {\n              collectionsList = StrUtils.splitSmart(alias, \",\", true);\n              corename = collectionsList.get(0);\n            }\n          }\n        }\n\n        core = cores.getCore(corename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else if (cores.isCoreLoading(corename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        } else {\n          // the core may have just finished loading\n          core = cores.getCore(corename);\n          if (core != null) {\n            path = path.substring(idx);\n          } \n        }\n      }\n      if (core == null) {\n        if (!cores.isZooKeeperAware()) {\n          core = cores.getCore(\"\");\n        }\n      }\n    }\n\n    if (core == null && cores.isZooKeeperAware()) {\n      // we couldn't find the core - lets make sure a collection was not specified instead\n      core = getCoreByCollection(corename);\n      if (core != null) {\n        // we found a core, update the path\n        path = path.substring(idx);\n        if (collectionsList == null)\n          collectionsList = new ArrayList<>();\n        collectionsList.add(corename);\n      }\n\n      // if we couldn't find it locally, look on other nodes\n      extractRemotePath(corename, origCorename, idx);\n      if (action != null) return;\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        if (usingAliases) {\n          processAliases(aliases, collectionsList);\n        }\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","sourceOld":"  private void init() throws Exception {\n    //The states of client that is invalid in this request\n    Aliases aliases = null;\n    String corename = \"\";\n    String origCorename = null;\n    // set a request timer which can be reused by requests if needed\n    req.setAttribute(SolrRequestParsers.REQUEST_TIMER_SERVLET_ATTRIBUTE, new RTimerTree());\n    // put the core container in request attribute\n    req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n    path = req.getServletPath();\n    if (req.getPathInfo() != null) {\n      // this lets you handle /update/commit when /update is a servlet\n      path += req.getPathInfo();\n    }\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    boolean usingAliases = false;\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    } else {\n      //otherwise, we should find a core from the path\n      idx = path.indexOf(\"/\", 1);\n      if (idx > 1) {\n        // try to get the corename as a request parameter first\n        corename = path.substring(1, idx);\n\n        // look at aliases\n        if (cores.isZooKeeperAware()) {\n          origCorename = corename;\n          ZkStateReader reader = cores.getZkController().getZkStateReader();\n          aliases = reader.getAliases();\n          if (aliases != null && aliases.collectionAliasSize() > 0) {\n            usingAliases = true;\n            String alias = aliases.getCollectionAlias(corename);\n            if (alias != null) {\n              collectionsList = StrUtils.splitSmart(alias, \",\", true);\n              corename = collectionsList.get(0);\n            }\n          }\n        }\n\n        core = cores.getCore(corename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else if (cores.isCoreLoading(corename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        } else {\n          // the core may have just finished loading\n          core = cores.getCore(corename);\n          if (core != null) {\n            path = path.substring(idx);\n          } \n        }\n      }\n      if (core == null) {\n        if (!cores.isZooKeeperAware()) {\n          core = cores.getCore(\"\");\n        }\n      }\n    }\n\n    if (core == null && cores.isZooKeeperAware()) {\n      // we couldn't find the core - lets make sure a collection was not specified instead\n      core = getCoreByCollection(corename);\n      if (core != null) {\n        // we found a core, update the path\n        path = path.substring(idx);\n        if (collectionsList == null)\n          collectionsList = new ArrayList<>();\n        collectionsList.add(corename);\n      }\n\n      // if we couldn't find it locally, look on other nodes\n      extractRemotePath(corename, origCorename, idx);\n      if (action != null) return;\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        if (usingAliases) {\n          processAliases(aliases, collectionsList);\n        }\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    SolrDispatchFilter.log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"08e881a61d5dffc3a403f2892fb747aca86bab0c","date":1479199723,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","sourceNew":"  void init() throws Exception {\n    //The states of client that is invalid in this request\n    Aliases aliases = null;\n    String corename = \"\";\n    String origCorename = null;\n    // set a request timer which can be reused by requests if needed\n    req.setAttribute(SolrRequestParsers.REQUEST_TIMER_SERVLET_ATTRIBUTE, new RTimerTree());\n    // put the core container in request attribute\n    req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n    path = req.getServletPath();\n    if (req.getPathInfo() != null) {\n      // this lets you handle /update/commit when /update is a servlet\n      path += req.getPathInfo();\n    }\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    boolean usingAliases = false;\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    } else {\n      //otherwise, we should find a core from the path\n      idx = path.indexOf(\"/\", 1);\n      if (idx > 1) {\n        // try to get the corename as a request parameter first\n        corename = path.substring(1, idx);\n\n        // look at aliases\n        if (cores.isZooKeeperAware()) {\n          origCorename = corename;\n          ZkStateReader reader = cores.getZkController().getZkStateReader();\n          aliases = reader.getAliases();\n          if (aliases != null && aliases.collectionAliasSize() > 0) {\n            usingAliases = true;\n            String alias = aliases.getCollectionAlias(corename);\n            if (alias != null) {\n              collectionsList = StrUtils.splitSmart(alias, \",\", true);\n              corename = collectionsList.get(0);\n            }\n          }\n        }\n\n        core = cores.getCore(corename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else if (cores.isCoreLoading(corename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        } else {\n          // the core may have just finished loading\n          core = cores.getCore(corename);\n          if (core != null) {\n            path = path.substring(idx);\n          } \n        }\n      }\n      if (core == null) {\n        if (!cores.isZooKeeperAware()) {\n          core = cores.getCore(\"\");\n        }\n      }\n    }\n\n    if (core == null && cores.isZooKeeperAware()) {\n      // we couldn't find the core - lets make sure a collection was not specified instead\n      boolean isPreferLeader = false;\n      if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n        isPreferLeader = true;\n      }\n      core = getCoreByCollection(corename, isPreferLeader);\n      if (core != null) {\n        // we found a core, update the path\n        path = path.substring(idx);\n        if (collectionsList == null)\n          collectionsList = new ArrayList<>();\n        collectionsList.add(corename);\n      }\n\n      // if we couldn't find it locally, look on other nodes\n      extractRemotePath(corename, origCorename, idx);\n      if (action != null) return;\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        if (usingAliases) {\n          processAliases(aliases, collectionsList);\n        }\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","sourceOld":"  private void init() throws Exception {\n    //The states of client that is invalid in this request\n    Aliases aliases = null;\n    String corename = \"\";\n    String origCorename = null;\n    // set a request timer which can be reused by requests if needed\n    req.setAttribute(SolrRequestParsers.REQUEST_TIMER_SERVLET_ATTRIBUTE, new RTimerTree());\n    // put the core container in request attribute\n    req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n    path = req.getServletPath();\n    if (req.getPathInfo() != null) {\n      // this lets you handle /update/commit when /update is a servlet\n      path += req.getPathInfo();\n    }\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    boolean usingAliases = false;\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    } else {\n      //otherwise, we should find a core from the path\n      idx = path.indexOf(\"/\", 1);\n      if (idx > 1) {\n        // try to get the corename as a request parameter first\n        corename = path.substring(1, idx);\n\n        // look at aliases\n        if (cores.isZooKeeperAware()) {\n          origCorename = corename;\n          ZkStateReader reader = cores.getZkController().getZkStateReader();\n          aliases = reader.getAliases();\n          if (aliases != null && aliases.collectionAliasSize() > 0) {\n            usingAliases = true;\n            String alias = aliases.getCollectionAlias(corename);\n            if (alias != null) {\n              collectionsList = StrUtils.splitSmart(alias, \",\", true);\n              corename = collectionsList.get(0);\n            }\n          }\n        }\n\n        core = cores.getCore(corename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else if (cores.isCoreLoading(corename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        } else {\n          // the core may have just finished loading\n          core = cores.getCore(corename);\n          if (core != null) {\n            path = path.substring(idx);\n          } \n        }\n      }\n      if (core == null) {\n        if (!cores.isZooKeeperAware()) {\n          core = cores.getCore(\"\");\n        }\n      }\n    }\n\n    if (core == null && cores.isZooKeeperAware()) {\n      // we couldn't find the core - lets make sure a collection was not specified instead\n      core = getCoreByCollection(corename);\n      if (core != null) {\n        // we found a core, update the path\n        path = path.substring(idx);\n        if (collectionsList == null)\n          collectionsList = new ArrayList<>();\n        collectionsList.add(corename);\n      }\n\n      // if we couldn't find it locally, look on other nodes\n      extractRemotePath(corename, origCorename, idx);\n      if (action != null) return;\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        if (usingAliases) {\n          processAliases(aliases, collectionsList);\n        }\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","bugFix":["00e1c8e1340d9e31d2c6bee5f72d9040ce569049","a760e2135dfe20a04dea360873d4de1c6a0280bb"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"21019aa828c8c9b0153877543a8b3f200bf2ca19","date":1479224450,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","sourceNew":"  void init() throws Exception {\n    //The states of client that is invalid in this request\n    Aliases aliases = null;\n    String corename = \"\";\n    String origCorename = null;\n    // set a request timer which can be reused by requests if needed\n    req.setAttribute(SolrRequestParsers.REQUEST_TIMER_SERVLET_ATTRIBUTE, new RTimerTree());\n    // put the core container in request attribute\n    req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n    path = req.getServletPath();\n    if (req.getPathInfo() != null) {\n      // this lets you handle /update/commit when /update is a servlet\n      path += req.getPathInfo();\n    }\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    boolean usingAliases = false;\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    } else {\n      //otherwise, we should find a core from the path\n      idx = path.indexOf(\"/\", 1);\n      if (idx > 1) {\n        // try to get the corename as a request parameter first\n        corename = path.substring(1, idx);\n\n        // look at aliases\n        if (cores.isZooKeeperAware()) {\n          origCorename = corename;\n          ZkStateReader reader = cores.getZkController().getZkStateReader();\n          aliases = reader.getAliases();\n          if (aliases != null && aliases.collectionAliasSize() > 0) {\n            usingAliases = true;\n            String alias = aliases.getCollectionAlias(corename);\n            if (alias != null) {\n              collectionsList = StrUtils.splitSmart(alias, \",\", true);\n              corename = collectionsList.get(0);\n            }\n          }\n        }\n\n        core = cores.getCore(corename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else if (cores.isCoreLoading(corename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        } else {\n          // the core may have just finished loading\n          core = cores.getCore(corename);\n          if (core != null) {\n            path = path.substring(idx);\n          } \n        }\n      }\n      if (core == null) {\n        if (!cores.isZooKeeperAware()) {\n          core = cores.getCore(\"\");\n        }\n      }\n    }\n\n    if (core == null && cores.isZooKeeperAware()) {\n      // we couldn't find the core - lets make sure a collection was not specified instead\n      boolean isPreferLeader = false;\n      if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n        isPreferLeader = true;\n      }\n      core = getCoreByCollection(corename, isPreferLeader);\n      if (core != null) {\n        // we found a core, update the path\n        path = path.substring(idx);\n        if (collectionsList == null)\n          collectionsList = new ArrayList<>();\n        collectionsList.add(corename);\n      }\n\n      // if we couldn't find it locally, look on other nodes\n      extractRemotePath(corename, origCorename, idx);\n      if (action != null) return;\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        if (usingAliases) {\n          processAliases(aliases, collectionsList);\n        }\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","sourceOld":"  private void init() throws Exception {\n    //The states of client that is invalid in this request\n    Aliases aliases = null;\n    String corename = \"\";\n    String origCorename = null;\n    // set a request timer which can be reused by requests if needed\n    req.setAttribute(SolrRequestParsers.REQUEST_TIMER_SERVLET_ATTRIBUTE, new RTimerTree());\n    // put the core container in request attribute\n    req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n    path = req.getServletPath();\n    if (req.getPathInfo() != null) {\n      // this lets you handle /update/commit when /update is a servlet\n      path += req.getPathInfo();\n    }\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    boolean usingAliases = false;\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    } else {\n      //otherwise, we should find a core from the path\n      idx = path.indexOf(\"/\", 1);\n      if (idx > 1) {\n        // try to get the corename as a request parameter first\n        corename = path.substring(1, idx);\n\n        // look at aliases\n        if (cores.isZooKeeperAware()) {\n          origCorename = corename;\n          ZkStateReader reader = cores.getZkController().getZkStateReader();\n          aliases = reader.getAliases();\n          if (aliases != null && aliases.collectionAliasSize() > 0) {\n            usingAliases = true;\n            String alias = aliases.getCollectionAlias(corename);\n            if (alias != null) {\n              collectionsList = StrUtils.splitSmart(alias, \",\", true);\n              corename = collectionsList.get(0);\n            }\n          }\n        }\n\n        core = cores.getCore(corename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else if (cores.isCoreLoading(corename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        } else {\n          // the core may have just finished loading\n          core = cores.getCore(corename);\n          if (core != null) {\n            path = path.substring(idx);\n          } \n        }\n      }\n      if (core == null) {\n        if (!cores.isZooKeeperAware()) {\n          core = cores.getCore(\"\");\n        }\n      }\n    }\n\n    if (core == null && cores.isZooKeeperAware()) {\n      // we couldn't find the core - lets make sure a collection was not specified instead\n      core = getCoreByCollection(corename);\n      if (core != null) {\n        // we found a core, update the path\n        path = path.substring(idx);\n        if (collectionsList == null)\n          collectionsList = new ArrayList<>();\n        collectionsList.add(corename);\n      }\n\n      // if we couldn't find it locally, look on other nodes\n      extractRemotePath(corename, origCorename, idx);\n      if (action != null) return;\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        if (usingAliases) {\n          processAliases(aliases, collectionsList);\n        }\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fcf710a8fcd590cf55c855d422c7a10fce3e6117","date":1485842253,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","sourceNew":"  protected void init() throws Exception {\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    boolean usingAliases = false;\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    } else {\n      //otherwise, we should find a core from the path\n      idx = path.indexOf(\"/\", 1);\n      if (idx > 1) {\n        // try to get the corename as a request parameter first\n        corename = path.substring(1, idx);\n\n        // look at aliases\n        if (cores.isZooKeeperAware()) {\n          origCorename = corename;\n          ZkStateReader reader = cores.getZkController().getZkStateReader();\n          aliases = reader.getAliases();\n          if (aliases != null && aliases.collectionAliasSize() > 0) {\n            usingAliases = true;\n            String alias = aliases.getCollectionAlias(corename);\n            if (alias != null) {\n              collectionsList = StrUtils.splitSmart(alias, \",\", true);\n              corename = collectionsList.get(0);\n            }\n          }\n        }\n\n        core = cores.getCore(corename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else if (cores.isCoreLoading(corename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        } else {\n          // the core may have just finished loading\n          core = cores.getCore(corename);\n          if (core != null) {\n            path = path.substring(idx);\n          }\n        }\n      }\n      if (core == null) {\n        if (!cores.isZooKeeperAware()) {\n          core = cores.getCore(\"\");\n        }\n      }\n    }\n\n    if (core == null && cores.isZooKeeperAware()) {\n      // we couldn't find the core - lets make sure a collection was not specified instead\n      boolean isPreferLeader = false;\n      if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n        isPreferLeader = true;\n      }\n      core = getCoreByCollection(corename, isPreferLeader);\n      if (core != null) {\n        // we found a core, update the path\n        path = path.substring(idx);\n        if (collectionsList == null)\n          collectionsList = new ArrayList<>();\n        collectionsList.add(corename);\n      }\n\n      // if we couldn't find it locally, look on other nodes\n      extractRemotePath(corename, origCorename, idx);\n      if (action != null) return;\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        if (usingAliases) {\n          processAliases(aliases, collectionsList);\n        }\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","sourceOld":"  void init() throws Exception {\n    //The states of client that is invalid in this request\n    Aliases aliases = null;\n    String corename = \"\";\n    String origCorename = null;\n    // set a request timer which can be reused by requests if needed\n    req.setAttribute(SolrRequestParsers.REQUEST_TIMER_SERVLET_ATTRIBUTE, new RTimerTree());\n    // put the core container in request attribute\n    req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n    path = req.getServletPath();\n    if (req.getPathInfo() != null) {\n      // this lets you handle /update/commit when /update is a servlet\n      path += req.getPathInfo();\n    }\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    boolean usingAliases = false;\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    } else {\n      //otherwise, we should find a core from the path\n      idx = path.indexOf(\"/\", 1);\n      if (idx > 1) {\n        // try to get the corename as a request parameter first\n        corename = path.substring(1, idx);\n\n        // look at aliases\n        if (cores.isZooKeeperAware()) {\n          origCorename = corename;\n          ZkStateReader reader = cores.getZkController().getZkStateReader();\n          aliases = reader.getAliases();\n          if (aliases != null && aliases.collectionAliasSize() > 0) {\n            usingAliases = true;\n            String alias = aliases.getCollectionAlias(corename);\n            if (alias != null) {\n              collectionsList = StrUtils.splitSmart(alias, \",\", true);\n              corename = collectionsList.get(0);\n            }\n          }\n        }\n\n        core = cores.getCore(corename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else if (cores.isCoreLoading(corename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        } else {\n          // the core may have just finished loading\n          core = cores.getCore(corename);\n          if (core != null) {\n            path = path.substring(idx);\n          } \n        }\n      }\n      if (core == null) {\n        if (!cores.isZooKeeperAware()) {\n          core = cores.getCore(\"\");\n        }\n      }\n    }\n\n    if (core == null && cores.isZooKeeperAware()) {\n      // we couldn't find the core - lets make sure a collection was not specified instead\n      boolean isPreferLeader = false;\n      if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n        isPreferLeader = true;\n      }\n      core = getCoreByCollection(corename, isPreferLeader);\n      if (core != null) {\n        // we found a core, update the path\n        path = path.substring(idx);\n        if (collectionsList == null)\n          collectionsList = new ArrayList<>();\n        collectionsList.add(corename);\n      }\n\n      // if we couldn't find it locally, look on other nodes\n      extractRemotePath(corename, origCorename, idx);\n      if (action != null) return;\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        if (usingAliases) {\n          processAliases(aliases, collectionsList);\n        }\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c3523a0ab04c3002eee3896c75ea5f10f388bcc","date":1485968422,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","sourceNew":"  protected void init() throws Exception {\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    boolean usingAliases = false;\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    } else {\n      //otherwise, we should find a core from the path\n      idx = path.indexOf(\"/\", 1);\n      if (idx > 1) {\n        // try to get the corename as a request parameter first\n        corename = path.substring(1, idx);\n\n        // look at aliases\n        if (cores.isZooKeeperAware()) {\n          origCorename = corename;\n          ZkStateReader reader = cores.getZkController().getZkStateReader();\n          aliases = reader.getAliases();\n          if (aliases != null && aliases.collectionAliasSize() > 0) {\n            usingAliases = true;\n            String alias = aliases.getCollectionAlias(corename);\n            if (alias != null) {\n              collectionsList = StrUtils.splitSmart(alias, \",\", true);\n              corename = collectionsList.get(0);\n            }\n          }\n        }\n\n        core = cores.getCore(corename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else if (cores.isCoreLoading(corename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        } else {\n          // the core may have just finished loading\n          core = cores.getCore(corename);\n          if (core != null) {\n            path = path.substring(idx);\n          }\n        }\n      }\n      if (core == null) {\n        if (!cores.isZooKeeperAware()) {\n          core = cores.getCore(\"\");\n        }\n      }\n    }\n\n    if (core == null && cores.isZooKeeperAware()) {\n      // we couldn't find the core - lets make sure a collection was not specified instead\n      boolean isPreferLeader = false;\n      if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n        isPreferLeader = true;\n      }\n      core = getCoreByCollection(corename, isPreferLeader);\n      if (core != null) {\n        // we found a core, update the path\n        path = path.substring(idx);\n        if (collectionsList == null)\n          collectionsList = new ArrayList<>();\n        collectionsList.add(corename);\n      }\n\n      // if we couldn't find it locally, look on other nodes\n      extractRemotePath(corename, origCorename, idx);\n      if (action != null) return;\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        if (usingAliases) {\n          processAliases(aliases, collectionsList);\n        }\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","sourceOld":"  void init() throws Exception {\n    //The states of client that is invalid in this request\n    Aliases aliases = null;\n    String corename = \"\";\n    String origCorename = null;\n    // set a request timer which can be reused by requests if needed\n    req.setAttribute(SolrRequestParsers.REQUEST_TIMER_SERVLET_ATTRIBUTE, new RTimerTree());\n    // put the core container in request attribute\n    req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n    path = req.getServletPath();\n    if (req.getPathInfo() != null) {\n      // this lets you handle /update/commit when /update is a servlet\n      path += req.getPathInfo();\n    }\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    boolean usingAliases = false;\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    } else {\n      //otherwise, we should find a core from the path\n      idx = path.indexOf(\"/\", 1);\n      if (idx > 1) {\n        // try to get the corename as a request parameter first\n        corename = path.substring(1, idx);\n\n        // look at aliases\n        if (cores.isZooKeeperAware()) {\n          origCorename = corename;\n          ZkStateReader reader = cores.getZkController().getZkStateReader();\n          aliases = reader.getAliases();\n          if (aliases != null && aliases.collectionAliasSize() > 0) {\n            usingAliases = true;\n            String alias = aliases.getCollectionAlias(corename);\n            if (alias != null) {\n              collectionsList = StrUtils.splitSmart(alias, \",\", true);\n              corename = collectionsList.get(0);\n            }\n          }\n        }\n\n        core = cores.getCore(corename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else if (cores.isCoreLoading(corename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        } else {\n          // the core may have just finished loading\n          core = cores.getCore(corename);\n          if (core != null) {\n            path = path.substring(idx);\n          } \n        }\n      }\n      if (core == null) {\n        if (!cores.isZooKeeperAware()) {\n          core = cores.getCore(\"\");\n        }\n      }\n    }\n\n    if (core == null && cores.isZooKeeperAware()) {\n      // we couldn't find the core - lets make sure a collection was not specified instead\n      boolean isPreferLeader = false;\n      if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n        isPreferLeader = true;\n      }\n      core = getCoreByCollection(corename, isPreferLeader);\n      if (core != null) {\n        // we found a core, update the path\n        path = path.substring(idx);\n        if (collectionsList == null)\n          collectionsList = new ArrayList<>();\n        collectionsList.add(corename);\n      }\n\n      // if we couldn't find it locally, look on other nodes\n      extractRemotePath(corename, origCorename, idx);\n      if (action != null) return;\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        if (usingAliases) {\n          processAliases(aliases, collectionsList);\n        }\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a44383d1bc1b3dfe9db7b05ecda8951270911aab","date":1486011386,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","sourceNew":"  protected void init() throws Exception {\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    boolean usingAliases = false;\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    } else {\n      //otherwise, we should find a core from the path\n      idx = path.indexOf(\"/\", 1);\n      if (idx > 1) {\n        // try to get the corename as a request parameter first\n        corename = path.substring(1, idx);\n\n        // look at aliases\n        if (cores.isZooKeeperAware()) {\n          origCorename = corename;\n          ZkStateReader reader = cores.getZkController().getZkStateReader();\n          aliases = reader.getAliases();\n          if (aliases != null && aliases.collectionAliasSize() > 0) {\n            usingAliases = true;\n            String alias = aliases.getCollectionAlias(corename);\n            if (alias != null) {\n              collectionsList = StrUtils.splitSmart(alias, \",\", true);\n              corename = collectionsList.get(0);\n            }\n          }\n        }\n\n        core = cores.getCore(corename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else if (cores.isCoreLoading(corename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        } else {\n          // the core may have just finished loading\n          core = cores.getCore(corename);\n          if (core != null) {\n            path = path.substring(idx);\n          }\n        }\n      }\n      if (core == null) {\n        if (!cores.isZooKeeperAware()) {\n          core = cores.getCore(\"\");\n        }\n      }\n    }\n\n    if (core == null && cores.isZooKeeperAware()) {\n      // we couldn't find the core - lets make sure a collection was not specified instead\n      boolean isPreferLeader = false;\n      if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n        isPreferLeader = true;\n      }\n      core = getCoreByCollection(corename, isPreferLeader);\n      if (core != null) {\n        // we found a core, update the path\n        path = path.substring(idx);\n        if (collectionsList == null)\n          collectionsList = new ArrayList<>();\n        collectionsList.add(corename);\n      }\n\n      // if we couldn't find it locally, look on other nodes\n      extractRemotePath(corename, origCorename, idx);\n      if (action != null) return;\n      //core is not available locally or remotely\n      autoCreateSystemColl();\n      if(action != null) return;\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        if (usingAliases) {\n          processAliases(aliases, collectionsList);\n        }\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","sourceOld":"  protected void init() throws Exception {\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    boolean usingAliases = false;\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    } else {\n      //otherwise, we should find a core from the path\n      idx = path.indexOf(\"/\", 1);\n      if (idx > 1) {\n        // try to get the corename as a request parameter first\n        corename = path.substring(1, idx);\n\n        // look at aliases\n        if (cores.isZooKeeperAware()) {\n          origCorename = corename;\n          ZkStateReader reader = cores.getZkController().getZkStateReader();\n          aliases = reader.getAliases();\n          if (aliases != null && aliases.collectionAliasSize() > 0) {\n            usingAliases = true;\n            String alias = aliases.getCollectionAlias(corename);\n            if (alias != null) {\n              collectionsList = StrUtils.splitSmart(alias, \",\", true);\n              corename = collectionsList.get(0);\n            }\n          }\n        }\n\n        core = cores.getCore(corename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else if (cores.isCoreLoading(corename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        } else {\n          // the core may have just finished loading\n          core = cores.getCore(corename);\n          if (core != null) {\n            path = path.substring(idx);\n          }\n        }\n      }\n      if (core == null) {\n        if (!cores.isZooKeeperAware()) {\n          core = cores.getCore(\"\");\n        }\n      }\n    }\n\n    if (core == null && cores.isZooKeeperAware()) {\n      // we couldn't find the core - lets make sure a collection was not specified instead\n      boolean isPreferLeader = false;\n      if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n        isPreferLeader = true;\n      }\n      core = getCoreByCollection(corename, isPreferLeader);\n      if (core != null) {\n        // we found a core, update the path\n        path = path.substring(idx);\n        if (collectionsList == null)\n          collectionsList = new ArrayList<>();\n        collectionsList.add(corename);\n      }\n\n      // if we couldn't find it locally, look on other nodes\n      extractRemotePath(corename, origCorename, idx);\n      if (action != null) return;\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        if (usingAliases) {\n          processAliases(aliases, collectionsList);\n        }\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ee750b40d46c97f5211190d360670a9d5584a762","date":1486021535,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","sourceNew":"  protected void init() throws Exception {\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    boolean usingAliases = false;\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    } else {\n      //otherwise, we should find a core from the path\n      idx = path.indexOf(\"/\", 1);\n      if (idx > 1) {\n        // try to get the corename as a request parameter first\n        corename = path.substring(1, idx);\n\n        // look at aliases\n        if (cores.isZooKeeperAware()) {\n          origCorename = corename;\n          ZkStateReader reader = cores.getZkController().getZkStateReader();\n          aliases = reader.getAliases();\n          if (aliases != null && aliases.collectionAliasSize() > 0) {\n            usingAliases = true;\n            String alias = aliases.getCollectionAlias(corename);\n            if (alias != null) {\n              collectionsList = StrUtils.splitSmart(alias, \",\", true);\n              corename = collectionsList.get(0);\n            }\n          }\n        }\n\n        core = cores.getCore(corename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else if (cores.isCoreLoading(corename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        } else {\n          // the core may have just finished loading\n          core = cores.getCore(corename);\n          if (core != null) {\n            path = path.substring(idx);\n          }\n        }\n      }\n      if (core == null) {\n        if (!cores.isZooKeeperAware()) {\n          core = cores.getCore(\"\");\n        }\n      }\n    }\n\n    if (core == null && cores.isZooKeeperAware()) {\n      // we couldn't find the core - lets make sure a collection was not specified instead\n      boolean isPreferLeader = false;\n      if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n        isPreferLeader = true;\n      }\n      core = getCoreByCollection(corename, isPreferLeader);\n      if (core != null) {\n        // we found a core, update the path\n        path = path.substring(idx);\n        if (collectionsList == null)\n          collectionsList = new ArrayList<>();\n        collectionsList.add(corename);\n      }\n\n      // if we couldn't find it locally, look on other nodes\n      extractRemotePath(corename, origCorename, idx);\n      if (action != null) return;\n      //core is not available locally or remotely\n      autoCreateSystemColl(corename);\n      if(action != null) return;\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        if (usingAliases) {\n          processAliases(aliases, collectionsList);\n        }\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","sourceOld":"  protected void init() throws Exception {\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    boolean usingAliases = false;\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    } else {\n      //otherwise, we should find a core from the path\n      idx = path.indexOf(\"/\", 1);\n      if (idx > 1) {\n        // try to get the corename as a request parameter first\n        corename = path.substring(1, idx);\n\n        // look at aliases\n        if (cores.isZooKeeperAware()) {\n          origCorename = corename;\n          ZkStateReader reader = cores.getZkController().getZkStateReader();\n          aliases = reader.getAliases();\n          if (aliases != null && aliases.collectionAliasSize() > 0) {\n            usingAliases = true;\n            String alias = aliases.getCollectionAlias(corename);\n            if (alias != null) {\n              collectionsList = StrUtils.splitSmart(alias, \",\", true);\n              corename = collectionsList.get(0);\n            }\n          }\n        }\n\n        core = cores.getCore(corename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else if (cores.isCoreLoading(corename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        } else {\n          // the core may have just finished loading\n          core = cores.getCore(corename);\n          if (core != null) {\n            path = path.substring(idx);\n          }\n        }\n      }\n      if (core == null) {\n        if (!cores.isZooKeeperAware()) {\n          core = cores.getCore(\"\");\n        }\n      }\n    }\n\n    if (core == null && cores.isZooKeeperAware()) {\n      // we couldn't find the core - lets make sure a collection was not specified instead\n      boolean isPreferLeader = false;\n      if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n        isPreferLeader = true;\n      }\n      core = getCoreByCollection(corename, isPreferLeader);\n      if (core != null) {\n        // we found a core, update the path\n        path = path.substring(idx);\n        if (collectionsList == null)\n          collectionsList = new ArrayList<>();\n        collectionsList.add(corename);\n      }\n\n      // if we couldn't find it locally, look on other nodes\n      extractRemotePath(corename, origCorename, idx);\n      if (action != null) return;\n      //core is not available locally or remotely\n      autoCreateSystemColl();\n      if(action != null) return;\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        if (usingAliases) {\n          processAliases(aliases, collectionsList);\n        }\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9d03b984af6c0085aa4985799de48f8c203844a","date":1498707843,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","sourceNew":"  protected void init() throws Exception {\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    boolean usingAliases = false;\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    } else {\n      //otherwise, we should find a core from the path\n      idx = path.indexOf(\"/\", 1);\n      if (idx > 1) {\n        // try to get the corename as a request parameter first\n        corename = path.substring(1, idx);\n\n        // look at aliases\n        if (cores.isZooKeeperAware()) {\n          origCorename = corename;\n          ZkStateReader reader = cores.getZkController().getZkStateReader();\n          aliases = reader.getAliases();\n          if (aliases != null && aliases.collectionAliasSize() > 0) {\n            usingAliases = true;\n            String alias = aliases.getCollectionAlias(corename);\n            if (alias != null) {\n              collectionsList = StrUtils.splitSmart(alias, \",\", true);\n              corename = collectionsList.get(0);\n            }\n          }\n        }\n\n        core = cores.getCore(corename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else if (cores.isCoreLoading(corename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        } else {\n          // the core may have just finished loading\n          core = cores.getCore(corename);\n          if (core != null) {\n            path = path.substring(idx);\n          }\n        }\n      }\n      if (core == null) {\n        if (!cores.isZooKeeperAware()) {\n          core = cores.getCore(\"\");\n        }\n      }\n    }\n\n    if (core == null && cores.isZooKeeperAware()) {\n      // we couldn't find the core - lets make sure a collection was not specified instead\n      boolean isPreferLeader = false;\n      if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n        isPreferLeader = true;\n      }\n      core = getCoreByCollection(corename, isPreferLeader);\n      if (core != null) {\n        // we found a core, update the path\n        path = path.substring(idx);\n        if (collectionsList == null)\n          collectionsList = new ArrayList<>();\n        collectionsList.add(corename);\n      }\n\n      // if we couldn't find it locally, look on other nodes\n      extractRemotePath(corename, origCorename, idx);\n      if (action != null) return;\n      //core is not available locally or remotely\n      autoCreateSystemColl(corename);\n      if(action != null) return;\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        invalidStates = checkStateVersionsAreValid(solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n\n        if (usingAliases) {\n          processAliases(aliases, collectionsList);\n        }\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","sourceOld":"  protected void init() throws Exception {\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    boolean usingAliases = false;\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    } else {\n      //otherwise, we should find a core from the path\n      idx = path.indexOf(\"/\", 1);\n      if (idx > 1) {\n        // try to get the corename as a request parameter first\n        corename = path.substring(1, idx);\n\n        // look at aliases\n        if (cores.isZooKeeperAware()) {\n          origCorename = corename;\n          ZkStateReader reader = cores.getZkController().getZkStateReader();\n          aliases = reader.getAliases();\n          if (aliases != null && aliases.collectionAliasSize() > 0) {\n            usingAliases = true;\n            String alias = aliases.getCollectionAlias(corename);\n            if (alias != null) {\n              collectionsList = StrUtils.splitSmart(alias, \",\", true);\n              corename = collectionsList.get(0);\n            }\n          }\n        }\n\n        core = cores.getCore(corename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else if (cores.isCoreLoading(corename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        } else {\n          // the core may have just finished loading\n          core = cores.getCore(corename);\n          if (core != null) {\n            path = path.substring(idx);\n          }\n        }\n      }\n      if (core == null) {\n        if (!cores.isZooKeeperAware()) {\n          core = cores.getCore(\"\");\n        }\n      }\n    }\n\n    if (core == null && cores.isZooKeeperAware()) {\n      // we couldn't find the core - lets make sure a collection was not specified instead\n      boolean isPreferLeader = false;\n      if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n        isPreferLeader = true;\n      }\n      core = getCoreByCollection(corename, isPreferLeader);\n      if (core != null) {\n        // we found a core, update the path\n        path = path.substring(idx);\n        if (collectionsList == null)\n          collectionsList = new ArrayList<>();\n        collectionsList.add(corename);\n      }\n\n      // if we couldn't find it locally, look on other nodes\n      extractRemotePath(corename, origCorename, idx);\n      if (action != null) return;\n      //core is not available locally or remotely\n      autoCreateSystemColl(corename);\n      if(action != null) return;\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        if (usingAliases) {\n          processAliases(aliases, collectionsList);\n        }\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","sourceNew":"  protected void init() throws Exception {\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    boolean usingAliases = false;\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    } else {\n      //otherwise, we should find a core from the path\n      idx = path.indexOf(\"/\", 1);\n      if (idx > 1) {\n        // try to get the corename as a request parameter first\n        corename = path.substring(1, idx);\n\n        // look at aliases\n        if (cores.isZooKeeperAware()) {\n          origCorename = corename;\n          ZkStateReader reader = cores.getZkController().getZkStateReader();\n          aliases = reader.getAliases();\n          if (aliases != null && aliases.collectionAliasSize() > 0) {\n            usingAliases = true;\n            String alias = aliases.getCollectionAlias(corename);\n            if (alias != null) {\n              collectionsList = StrUtils.splitSmart(alias, \",\", true);\n              corename = collectionsList.get(0);\n            }\n          }\n        }\n\n        core = cores.getCore(corename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else if (cores.isCoreLoading(corename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        } else {\n          // the core may have just finished loading\n          core = cores.getCore(corename);\n          if (core != null) {\n            path = path.substring(idx);\n          }\n        }\n      }\n      if (core == null) {\n        if (!cores.isZooKeeperAware()) {\n          core = cores.getCore(\"\");\n        }\n      }\n    }\n\n    if (core == null && cores.isZooKeeperAware()) {\n      // we couldn't find the core - lets make sure a collection was not specified instead\n      boolean isPreferLeader = false;\n      if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n        isPreferLeader = true;\n      }\n      core = getCoreByCollection(corename, isPreferLeader);\n      if (core != null) {\n        // we found a core, update the path\n        path = path.substring(idx);\n        if (collectionsList == null)\n          collectionsList = new ArrayList<>();\n        collectionsList.add(corename);\n      }\n\n      // if we couldn't find it locally, look on other nodes\n      extractRemotePath(corename, origCorename, idx);\n      if (action != null) return;\n      //core is not available locally or remotely\n      autoCreateSystemColl(corename);\n      if(action != null) return;\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        invalidStates = checkStateVersionsAreValid(solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n\n        if (usingAliases) {\n          processAliases(aliases, collectionsList);\n        }\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","sourceOld":"  protected void init() throws Exception {\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    boolean usingAliases = false;\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    } else {\n      //otherwise, we should find a core from the path\n      idx = path.indexOf(\"/\", 1);\n      if (idx > 1) {\n        // try to get the corename as a request parameter first\n        corename = path.substring(1, idx);\n\n        // look at aliases\n        if (cores.isZooKeeperAware()) {\n          origCorename = corename;\n          ZkStateReader reader = cores.getZkController().getZkStateReader();\n          aliases = reader.getAliases();\n          if (aliases != null && aliases.collectionAliasSize() > 0) {\n            usingAliases = true;\n            String alias = aliases.getCollectionAlias(corename);\n            if (alias != null) {\n              collectionsList = StrUtils.splitSmart(alias, \",\", true);\n              corename = collectionsList.get(0);\n            }\n          }\n        }\n\n        core = cores.getCore(corename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else if (cores.isCoreLoading(corename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        } else {\n          // the core may have just finished loading\n          core = cores.getCore(corename);\n          if (core != null) {\n            path = path.substring(idx);\n          }\n        }\n      }\n      if (core == null) {\n        if (!cores.isZooKeeperAware()) {\n          core = cores.getCore(\"\");\n        }\n      }\n    }\n\n    if (core == null && cores.isZooKeeperAware()) {\n      // we couldn't find the core - lets make sure a collection was not specified instead\n      boolean isPreferLeader = false;\n      if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n        isPreferLeader = true;\n      }\n      core = getCoreByCollection(corename, isPreferLeader);\n      if (core != null) {\n        // we found a core, update the path\n        path = path.substring(idx);\n        if (collectionsList == null)\n          collectionsList = new ArrayList<>();\n        collectionsList.add(corename);\n      }\n\n      // if we couldn't find it locally, look on other nodes\n      extractRemotePath(corename, origCorename, idx);\n      if (action != null) return;\n      //core is not available locally or remotely\n      autoCreateSystemColl(corename);\n      if(action != null) return;\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        if (usingAliases) {\n          processAliases(aliases, collectionsList);\n        }\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30c8e5574b55d57947e989443dfde611646530ee","date":1499131153,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","sourceNew":"  protected void init() throws Exception {\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    boolean usingAliases = false;\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    } else {\n      //otherwise, we should find a core from the path\n      idx = path.indexOf(\"/\", 1);\n      if (idx > 1) {\n        // try to get the corename as a request parameter first\n        corename = path.substring(1, idx);\n\n        // look at aliases\n        if (cores.isZooKeeperAware()) {\n          origCorename = corename;\n          ZkStateReader reader = cores.getZkController().getZkStateReader();\n          aliases = reader.getAliases();\n          if (aliases != null && aliases.collectionAliasSize() > 0) {\n            usingAliases = true;\n            String alias = aliases.getCollectionAlias(corename);\n            if (alias != null) {\n              collectionsList = StrUtils.splitSmart(alias, \",\", true);\n              corename = collectionsList.get(0);\n            }\n          }\n        }\n\n        core = cores.getCore(corename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else if (cores.isCoreLoading(corename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        } else {\n          // the core may have just finished loading\n          core = cores.getCore(corename);\n          if (core != null) {\n            path = path.substring(idx);\n          }\n        }\n      }\n      if (core == null) {\n        if (!cores.isZooKeeperAware()) {\n          core = cores.getCore(\"\");\n        }\n      }\n    }\n\n    if (core == null && cores.isZooKeeperAware()) {\n      // we couldn't find the core - lets make sure a collection was not specified instead\n      boolean isPreferLeader = false;\n      if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n        isPreferLeader = true;\n      }\n      core = getCoreByCollection(corename, isPreferLeader);\n      if (core != null) {\n        // we found a core, update the path\n        path = path.substring(idx);\n        if (collectionsList == null)\n          collectionsList = new ArrayList<>();\n        collectionsList.add(corename);\n      }\n\n      // if we couldn't find it locally, look on other nodes\n      extractRemotePath(corename, origCorename, idx);\n      if (action != null) return;\n      //core is not available locally or remotely\n      autoCreateSystemColl(corename);\n      if(action != null) return;\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        invalidStates = checkStateVersionsAreValid(solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n\n        if (usingAliases) {\n          processAliases(aliases, collectionsList);\n        }\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","sourceOld":"  protected void init() throws Exception {\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    boolean usingAliases = false;\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    } else {\n      //otherwise, we should find a core from the path\n      idx = path.indexOf(\"/\", 1);\n      if (idx > 1) {\n        // try to get the corename as a request parameter first\n        corename = path.substring(1, idx);\n\n        // look at aliases\n        if (cores.isZooKeeperAware()) {\n          origCorename = corename;\n          ZkStateReader reader = cores.getZkController().getZkStateReader();\n          aliases = reader.getAliases();\n          if (aliases != null && aliases.collectionAliasSize() > 0) {\n            usingAliases = true;\n            String alias = aliases.getCollectionAlias(corename);\n            if (alias != null) {\n              collectionsList = StrUtils.splitSmart(alias, \",\", true);\n              corename = collectionsList.get(0);\n            }\n          }\n        }\n\n        core = cores.getCore(corename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else if (cores.isCoreLoading(corename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        } else {\n          // the core may have just finished loading\n          core = cores.getCore(corename);\n          if (core != null) {\n            path = path.substring(idx);\n          }\n        }\n      }\n      if (core == null) {\n        if (!cores.isZooKeeperAware()) {\n          core = cores.getCore(\"\");\n        }\n      }\n    }\n\n    if (core == null && cores.isZooKeeperAware()) {\n      // we couldn't find the core - lets make sure a collection was not specified instead\n      boolean isPreferLeader = false;\n      if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n        isPreferLeader = true;\n      }\n      core = getCoreByCollection(corename, isPreferLeader);\n      if (core != null) {\n        // we found a core, update the path\n        path = path.substring(idx);\n        if (collectionsList == null)\n          collectionsList = new ArrayList<>();\n        collectionsList.add(corename);\n      }\n\n      // if we couldn't find it locally, look on other nodes\n      extractRemotePath(corename, origCorename, idx);\n      if (action != null) return;\n      //core is not available locally or remotely\n      autoCreateSystemColl(corename);\n      if(action != null) return;\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        if (usingAliases) {\n          processAliases(aliases, collectionsList);\n        }\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b824daa61db3f30b91a22213d6c04e1fa2e2b06","date":1508385744,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","sourceNew":"  protected void init() throws Exception {\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    }\n\n    // Parse a core or collection name from the path and attempt to see if it's a core name\n    idx = path.indexOf(\"/\", 1);\n    if (idx > 1) {\n      origCorename = path.substring(1, idx);\n\n      // Try to resolve a Solr core name\n      core = cores.getCore(origCorename);\n      if (core != null) {\n        path = path.substring(idx);\n      } else {\n        if (cores.isCoreLoading(origCorename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        }\n        // the core may have just finished loading\n        core = cores.getCore(origCorename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else {\n          if (!cores.isZooKeeperAware()) {\n            core = cores.getCore(\"\");\n          }\n        }\n      }\n    }\n\n    if (cores.isZooKeeperAware()) {\n      // init collectionList (usually one name but not when there are aliases)\n      String def = core != null ? core.getCoreDescriptor().getCollectionName() : origCorename;\n      collectionsList = resolveCollectionListOrAlias(queryParams.get(COLLECTION_PROP, def)); // &collection= takes precedence\n\n      if (core == null) {\n        // lookup core from collection, or route away if need to\n        String collectionName = collectionsList.isEmpty() ? null : collectionsList.get(0); // route to 1st\n        //TODO try the other collections if can't find a local replica of the first?   (and do to V2HttpSolrCall)\n\n        boolean isPreferLeader = (path.endsWith(\"/update\") || path.contains(\"/update/\"));\n\n        core = getCoreByCollection(collectionName, isPreferLeader); // find a local replica/core for the collection\n        if (core != null) {\n          if (idx > 0) {\n            path = path.substring(idx);\n          }\n        } else {\n          // if we couldn't find it locally, look on other nodes\n          extractRemotePath(collectionName, origCorename, idx);\n          if (action != null) return;\n          //core is not available locally or remotely\n          autoCreateSystemColl(collectionName);\n          if (action != null) return;\n        }\n      }\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        invalidStates = checkStateVersionsAreValid(solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n\n        addCollectionParamIfNeeded(getCollectionsList());\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","sourceOld":"  protected void init() throws Exception {\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    boolean usingAliases = false;\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    } else {\n      //otherwise, we should find a core from the path\n      idx = path.indexOf(\"/\", 1);\n      if (idx > 1) {\n        // try to get the corename as a request parameter first\n        corename = path.substring(1, idx);\n\n        // look at aliases\n        if (cores.isZooKeeperAware()) {\n          origCorename = corename;\n          ZkStateReader reader = cores.getZkController().getZkStateReader();\n          aliases = reader.getAliases();\n          if (aliases != null && aliases.collectionAliasSize() > 0) {\n            usingAliases = true;\n            String alias = aliases.getCollectionAlias(corename);\n            if (alias != null) {\n              collectionsList = StrUtils.splitSmart(alias, \",\", true);\n              corename = collectionsList.get(0);\n            }\n          }\n        }\n\n        core = cores.getCore(corename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else if (cores.isCoreLoading(corename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        } else {\n          // the core may have just finished loading\n          core = cores.getCore(corename);\n          if (core != null) {\n            path = path.substring(idx);\n          }\n        }\n      }\n      if (core == null) {\n        if (!cores.isZooKeeperAware()) {\n          core = cores.getCore(\"\");\n        }\n      }\n    }\n\n    if (core == null && cores.isZooKeeperAware()) {\n      // we couldn't find the core - lets make sure a collection was not specified instead\n      boolean isPreferLeader = false;\n      if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n        isPreferLeader = true;\n      }\n      core = getCoreByCollection(corename, isPreferLeader);\n      if (core != null) {\n        // we found a core, update the path\n        path = path.substring(idx);\n        if (collectionsList == null)\n          collectionsList = new ArrayList<>();\n        collectionsList.add(corename);\n      }\n\n      // if we couldn't find it locally, look on other nodes\n      extractRemotePath(corename, origCorename, idx);\n      if (action != null) return;\n      //core is not available locally or remotely\n      autoCreateSystemColl(corename);\n      if(action != null) return;\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        invalidStates = checkStateVersionsAreValid(solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n\n        if (usingAliases) {\n          processAliases(aliases, collectionsList);\n        }\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","bugFix":null,"bugIntro":["9125399a2b1542e8303716ed9020cb6cd4a7aa93"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9125399a2b1542e8303716ed9020cb6cd4a7aa93","date":1510160069,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","sourceNew":"  protected void init() throws Exception {\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    }\n\n    // Parse a core or collection name from the path and attempt to see if it's a core name\n    idx = path.indexOf(\"/\", 1);\n    if (idx > 1) {\n      origCorename = path.substring(1, idx);\n\n      // Try to resolve a Solr core name\n      core = cores.getCore(origCorename);\n      if (core != null) {\n        path = path.substring(idx);\n      } else {\n        if (cores.isCoreLoading(origCorename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        }\n        // the core may have just finished loading\n        core = cores.getCore(origCorename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else {\n          if (!cores.isZooKeeperAware()) {\n            core = cores.getCore(\"\");\n          }\n        }\n      }\n    }\n\n    if (cores.isZooKeeperAware()) {\n      // init collectionList (usually one name but not when there are aliases)\n      String def = core != null ? core.getCoreDescriptor().getCollectionName() : origCorename;\n      collectionsList = resolveCollectionListOrAlias(queryParams.get(COLLECTION_PROP, def)); // &collection= takes precedence\n\n      if (core == null) {\n        // lookup core from collection, or route away if need to\n        String collectionName = collectionsList.isEmpty() ? null : collectionsList.get(0); // route to 1st\n        //TODO try the other collections if can't find a local replica of the first?   (and do to V2HttpSolrCall)\n\n        boolean isPreferLeader = (path.endsWith(\"/update\") || path.contains(\"/update/\"));\n\n        core = getCoreByCollection(collectionName, isPreferLeader); // find a local replica/core for the collection\n        if (core != null) {\n          if (idx > 0) {\n            path = path.substring(idx);\n          }\n        } else {\n          // if we couldn't find it locally, look on other nodes\n          if (idx > 0) {\n            extractRemotePath(collectionName, origCorename);\n            if (action == REMOTEQUERY) {\n              path = path.substring(idx);\n              return;\n            }\n          }\n          //core is not available locally or remotely\n          autoCreateSystemColl(collectionName);\n          if (action != null) return;\n        }\n      }\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        invalidStates = checkStateVersionsAreValid(solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n\n        addCollectionParamIfNeeded(getCollectionsList());\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","sourceOld":"  protected void init() throws Exception {\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    }\n\n    // Parse a core or collection name from the path and attempt to see if it's a core name\n    idx = path.indexOf(\"/\", 1);\n    if (idx > 1) {\n      origCorename = path.substring(1, idx);\n\n      // Try to resolve a Solr core name\n      core = cores.getCore(origCorename);\n      if (core != null) {\n        path = path.substring(idx);\n      } else {\n        if (cores.isCoreLoading(origCorename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        }\n        // the core may have just finished loading\n        core = cores.getCore(origCorename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else {\n          if (!cores.isZooKeeperAware()) {\n            core = cores.getCore(\"\");\n          }\n        }\n      }\n    }\n\n    if (cores.isZooKeeperAware()) {\n      // init collectionList (usually one name but not when there are aliases)\n      String def = core != null ? core.getCoreDescriptor().getCollectionName() : origCorename;\n      collectionsList = resolveCollectionListOrAlias(queryParams.get(COLLECTION_PROP, def)); // &collection= takes precedence\n\n      if (core == null) {\n        // lookup core from collection, or route away if need to\n        String collectionName = collectionsList.isEmpty() ? null : collectionsList.get(0); // route to 1st\n        //TODO try the other collections if can't find a local replica of the first?   (and do to V2HttpSolrCall)\n\n        boolean isPreferLeader = (path.endsWith(\"/update\") || path.contains(\"/update/\"));\n\n        core = getCoreByCollection(collectionName, isPreferLeader); // find a local replica/core for the collection\n        if (core != null) {\n          if (idx > 0) {\n            path = path.substring(idx);\n          }\n        } else {\n          // if we couldn't find it locally, look on other nodes\n          extractRemotePath(collectionName, origCorename, idx);\n          if (action != null) return;\n          //core is not available locally or remotely\n          autoCreateSystemColl(collectionName);\n          if (action != null) return;\n        }\n      }\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        invalidStates = checkStateVersionsAreValid(solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n\n        addCollectionParamIfNeeded(getCollectionsList());\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","bugFix":["6b824daa61db3f30b91a22213d6c04e1fa2e2b06"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ed5005b977107bba28c700351216f1595e7abe4f","date":1585964712,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","sourceNew":"  protected void init() throws Exception {\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    }\n\n    // Parse a core or collection name from the path and attempt to see if it's a core name\n    idx = path.indexOf(\"/\", 1);\n    if (idx > 1) {\n      origCorename = path.substring(1, idx);\n\n      // Try to resolve a Solr core name\n      core = cores.getCore(origCorename);\n      if (core != null) {\n        path = path.substring(idx);\n      } else {\n        if (cores.isCoreLoading(origCorename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        }\n        // the core may have just finished loading\n        core = cores.getCore(origCorename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else {\n          if (!cores.isZooKeeperAware()) {\n            core = cores.getCore(\"\");\n          }\n        }\n      }\n    }\n\n    if (cores.isZooKeeperAware()) {\n      // init collectionList (usually one name but not when there are aliases)\n      String def = core != null ? core.getCoreDescriptor().getCollectionName() : origCorename;\n      collectionsList = resolveCollectionListOrAlias(queryParams.get(COLLECTION_PROP, def)); // &collection= takes precedence\n\n      if (core == null) {\n        // lookup core from collection, or route away if need to\n        String collectionName = collectionsList.isEmpty() ? null : collectionsList.get(0); // route to 1st\n        //TODO try the other collections if can't find a local replica of the first?   (and do to V2HttpSolrCall)\n\n        boolean isPreferLeader = (path.endsWith(\"/update\") || path.contains(\"/update/\"));\n\n        core = getCoreByCollection(collectionName, isPreferLeader); // find a local replica/core for the collection\n        if (core != null) {\n          if (idx > 0) {\n            path = path.substring(idx);\n          }\n        } else {\n          // if we couldn't find it locally, look on other nodes\n          if (idx > 0) {\n            extractRemotePath(collectionName, origCorename);\n            if (action == REMOTEQUERY) {\n              path = path.substring(idx);\n              return;\n            }\n          }\n          //core is not available locally or remotely\n          autoCreateSystemColl(collectionName);\n          if (action != null) return;\n        }\n      }\n    }\n\n    // With a valid core...\n    if (core != null) {\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        invalidStates = checkStateVersionsAreValid(solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n\n        addCollectionParamIfNeeded(getCollectionsList());\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","sourceOld":"  protected void init() throws Exception {\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    }\n\n    // Parse a core or collection name from the path and attempt to see if it's a core name\n    idx = path.indexOf(\"/\", 1);\n    if (idx > 1) {\n      origCorename = path.substring(1, idx);\n\n      // Try to resolve a Solr core name\n      core = cores.getCore(origCorename);\n      if (core != null) {\n        path = path.substring(idx);\n      } else {\n        if (cores.isCoreLoading(origCorename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        }\n        // the core may have just finished loading\n        core = cores.getCore(origCorename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else {\n          if (!cores.isZooKeeperAware()) {\n            core = cores.getCore(\"\");\n          }\n        }\n      }\n    }\n\n    if (cores.isZooKeeperAware()) {\n      // init collectionList (usually one name but not when there are aliases)\n      String def = core != null ? core.getCoreDescriptor().getCollectionName() : origCorename;\n      collectionsList = resolveCollectionListOrAlias(queryParams.get(COLLECTION_PROP, def)); // &collection= takes precedence\n\n      if (core == null) {\n        // lookup core from collection, or route away if need to\n        String collectionName = collectionsList.isEmpty() ? null : collectionsList.get(0); // route to 1st\n        //TODO try the other collections if can't find a local replica of the first?   (and do to V2HttpSolrCall)\n\n        boolean isPreferLeader = (path.endsWith(\"/update\") || path.contains(\"/update/\"));\n\n        core = getCoreByCollection(collectionName, isPreferLeader); // find a local replica/core for the collection\n        if (core != null) {\n          if (idx > 0) {\n            path = path.substring(idx);\n          }\n        } else {\n          // if we couldn't find it locally, look on other nodes\n          if (idx > 0) {\n            extractRemotePath(collectionName, origCorename);\n            if (action == REMOTEQUERY) {\n              path = path.substring(idx);\n              return;\n            }\n          }\n          //core is not available locally or remotely\n          autoCreateSystemColl(collectionName);\n          if (action != null) return;\n        }\n      }\n    }\n\n    // With a valid core...\n    if (core != null) {\n      MDCLoggingContext.setCore(core);\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        invalidStates = checkStateVersionsAreValid(solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n\n        addCollectionParamIfNeeded(getCollectionsList());\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54faedfb0e03479a38f5ee82f2dfaeea536e9404","date":1587251295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#init().mjava","sourceNew":"  protected void init() throws Exception {\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    }\n\n    // Parse a core or collection name from the path and attempt to see if it's a core name\n    idx = path.indexOf(\"/\", 1);\n    if (idx > 1) {\n      origCorename = path.substring(1, idx);\n\n      // Try to resolve a Solr core name\n      core = cores.getCore(origCorename);\n      if (core != null) {\n        path = path.substring(idx);\n      } else {\n        if (cores.isCoreLoading(origCorename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        }\n        // the core may have just finished loading\n        core = cores.getCore(origCorename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else {\n          if (!cores.isZooKeeperAware()) {\n            core = cores.getCore(\"\");\n          }\n        }\n      }\n    }\n\n    if (cores.isZooKeeperAware()) {\n      // init collectionList (usually one name but not when there are aliases)\n      String def = core != null ? core.getCoreDescriptor().getCollectionName() : origCorename;\n      collectionsList = resolveCollectionListOrAlias(queryParams.get(COLLECTION_PROP, def)); // &collection= takes precedence\n\n      if (core == null) {\n        // lookup core from collection, or route away if need to\n        String collectionName = collectionsList.isEmpty() ? null : collectionsList.get(0); // route to 1st\n        //TODO try the other collections if can't find a local replica of the first?   (and do to V2HttpSolrCall)\n\n        boolean isPreferLeader = (path.endsWith(\"/update\") || path.contains(\"/update/\"));\n\n        core = getCoreByCollection(collectionName, isPreferLeader); // find a local replica/core for the collection\n        if (core != null) {\n          if (idx > 0) {\n            path = path.substring(idx);\n          }\n        } else {\n          // if we couldn't find it locally, look on other nodes\n          if (idx > 0) {\n            extractRemotePath(collectionName, origCorename);\n            if (action == REMOTEQUERY) {\n              path = path.substring(idx);\n              return;\n            }\n          }\n          //core is not available locally or remotely\n          autoCreateSystemColl(collectionName);\n          if (action != null) return;\n        }\n      }\n    }\n\n    // With a valid core...\n    if (core != null) {\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        invalidStates = checkStateVersionsAreValid(solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n\n        addCollectionParamIfNeeded(getCollectionsList());\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    log.debug(\"no handler or core retrieved for {}, follow through...\", path);\n\n    action = PASSTHROUGH;\n  }\n\n","sourceOld":"  protected void init() throws Exception {\n    // check for management path\n    String alternate = cores.getManagementPath();\n    if (alternate != null && path.startsWith(alternate)) {\n      path = path.substring(0, alternate.length());\n    }\n\n    // unused feature ?\n    int idx = path.indexOf(':');\n    if (idx > 0) {\n      // save the portion after the ':' for a 'handler' path parameter\n      path = path.substring(0, idx);\n    }\n\n    // Check for container handlers\n    handler = cores.getRequestHandler(path);\n    if (handler != null) {\n      solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n      solrReq.getContext().put(CoreContainer.class.getName(), cores);\n      requestType = RequestType.ADMIN;\n      action = ADMIN;\n      return;\n    }\n\n    // Parse a core or collection name from the path and attempt to see if it's a core name\n    idx = path.indexOf(\"/\", 1);\n    if (idx > 1) {\n      origCorename = path.substring(1, idx);\n\n      // Try to resolve a Solr core name\n      core = cores.getCore(origCorename);\n      if (core != null) {\n        path = path.substring(idx);\n      } else {\n        if (cores.isCoreLoading(origCorename)) { // extra mem barriers, so don't look at this before trying to get core\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCore is loading\");\n        }\n        // the core may have just finished loading\n        core = cores.getCore(origCorename);\n        if (core != null) {\n          path = path.substring(idx);\n        } else {\n          if (!cores.isZooKeeperAware()) {\n            core = cores.getCore(\"\");\n          }\n        }\n      }\n    }\n\n    if (cores.isZooKeeperAware()) {\n      // init collectionList (usually one name but not when there are aliases)\n      String def = core != null ? core.getCoreDescriptor().getCollectionName() : origCorename;\n      collectionsList = resolveCollectionListOrAlias(queryParams.get(COLLECTION_PROP, def)); // &collection= takes precedence\n\n      if (core == null) {\n        // lookup core from collection, or route away if need to\n        String collectionName = collectionsList.isEmpty() ? null : collectionsList.get(0); // route to 1st\n        //TODO try the other collections if can't find a local replica of the first?   (and do to V2HttpSolrCall)\n\n        boolean isPreferLeader = (path.endsWith(\"/update\") || path.contains(\"/update/\"));\n\n        core = getCoreByCollection(collectionName, isPreferLeader); // find a local replica/core for the collection\n        if (core != null) {\n          if (idx > 0) {\n            path = path.substring(idx);\n          }\n        } else {\n          // if we couldn't find it locally, look on other nodes\n          if (idx > 0) {\n            extractRemotePath(collectionName, origCorename);\n            if (action == REMOTEQUERY) {\n              path = path.substring(idx);\n              return;\n            }\n          }\n          //core is not available locally or remotely\n          autoCreateSystemColl(collectionName);\n          if (action != null) return;\n        }\n      }\n    }\n\n    // With a valid core...\n    if (core != null) {\n      config = core.getSolrConfig();\n      // get or create/cache the parser for the core\n      SolrRequestParsers parser = config.getRequestParsers();\n\n      // Determine the handler from the url path if not set\n      // (we might already have selected the cores handler)\n      extractHandlerFromURLPath(parser);\n      if (action != null) return;\n\n      // With a valid handler and a valid core...\n      if (handler != null) {\n        // if not a /select, create the request\n        if (solrReq == null) {\n          solrReq = parser.parse(core, path, req);\n        }\n\n        invalidStates = checkStateVersionsAreValid(solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n\n        addCollectionParamIfNeeded(getCollectionsList());\n\n        action = PROCESS;\n        return; // we are done with a valid handler\n      }\n    }\n    log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n\n    action = PASSTHROUGH;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a44383d1bc1b3dfe9db7b05ecda8951270911aab":["fcf710a8fcd590cf55c855d422c7a10fce3e6117"],"6b824daa61db3f30b91a22213d6c04e1fa2e2b06":["28288370235ed02234a64753cdbf0c6ec096304a"],"21019aa828c8c9b0153877543a8b3f200bf2ca19":["9367dbf5b00d7764583d991c1888f4acc9c9991a","08e881a61d5dffc3a403f2892fb747aca86bab0c"],"fcf710a8fcd590cf55c855d422c7a10fce3e6117":["08e881a61d5dffc3a403f2892fb747aca86bab0c"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":["21019aa828c8c9b0153877543a8b3f200bf2ca19","fcf710a8fcd590cf55c855d422c7a10fce3e6117"],"ed5005b977107bba28c700351216f1595e7abe4f":["9125399a2b1542e8303716ed9020cb6cd4a7aa93"],"30c8e5574b55d57947e989443dfde611646530ee":["ee750b40d46c97f5211190d360670a9d5584a762","28288370235ed02234a64753cdbf0c6ec096304a"],"ee750b40d46c97f5211190d360670a9d5584a762":["a44383d1bc1b3dfe9db7b05ecda8951270911aab"],"9367dbf5b00d7764583d991c1888f4acc9c9991a":["8e644f11c9d0dc0769d5dd5f842612a9dfa6ecde"],"104456f4eeacc857f7e1e6408e1483de8c2bd658":["275019a81d0883a1db4560391b072d1fbe272ec4"],"c9d03b984af6c0085aa4985799de48f8c203844a":["ee750b40d46c97f5211190d360670a9d5584a762"],"9125399a2b1542e8303716ed9020cb6cd4a7aa93":["6b824daa61db3f30b91a22213d6c04e1fa2e2b06"],"28288370235ed02234a64753cdbf0c6ec096304a":["ee750b40d46c97f5211190d360670a9d5584a762","c9d03b984af6c0085aa4985799de48f8c203844a"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["00e1c8e1340d9e31d2c6bee5f72d9040ce569049"],"08e881a61d5dffc3a403f2892fb747aca86bab0c":["9367dbf5b00d7764583d991c1888f4acc9c9991a"],"54faedfb0e03479a38f5ee82f2dfaeea536e9404":["ed5005b977107bba28c700351216f1595e7abe4f"],"8e644f11c9d0dc0769d5dd5f842612a9dfa6ecde":["104456f4eeacc857f7e1e6408e1483de8c2bd658"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"275019a81d0883a1db4560391b072d1fbe272ec4":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["54faedfb0e03479a38f5ee82f2dfaeea536e9404"],"00e1c8e1340d9e31d2c6bee5f72d9040ce569049":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a44383d1bc1b3dfe9db7b05ecda8951270911aab":["ee750b40d46c97f5211190d360670a9d5584a762"],"6b824daa61db3f30b91a22213d6c04e1fa2e2b06":["9125399a2b1542e8303716ed9020cb6cd4a7aa93"],"21019aa828c8c9b0153877543a8b3f200bf2ca19":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc"],"fcf710a8fcd590cf55c855d422c7a10fce3e6117":["a44383d1bc1b3dfe9db7b05ecda8951270911aab","7c3523a0ab04c3002eee3896c75ea5f10f388bcc"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":[],"ed5005b977107bba28c700351216f1595e7abe4f":["54faedfb0e03479a38f5ee82f2dfaeea536e9404"],"30c8e5574b55d57947e989443dfde611646530ee":[],"ee750b40d46c97f5211190d360670a9d5584a762":["30c8e5574b55d57947e989443dfde611646530ee","c9d03b984af6c0085aa4985799de48f8c203844a","28288370235ed02234a64753cdbf0c6ec096304a"],"9367dbf5b00d7764583d991c1888f4acc9c9991a":["21019aa828c8c9b0153877543a8b3f200bf2ca19","08e881a61d5dffc3a403f2892fb747aca86bab0c"],"104456f4eeacc857f7e1e6408e1483de8c2bd658":["8e644f11c9d0dc0769d5dd5f842612a9dfa6ecde"],"c9d03b984af6c0085aa4985799de48f8c203844a":["28288370235ed02234a64753cdbf0c6ec096304a"],"28288370235ed02234a64753cdbf0c6ec096304a":["6b824daa61db3f30b91a22213d6c04e1fa2e2b06","30c8e5574b55d57947e989443dfde611646530ee"],"9125399a2b1542e8303716ed9020cb6cd4a7aa93":["ed5005b977107bba28c700351216f1595e7abe4f"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["275019a81d0883a1db4560391b072d1fbe272ec4"],"08e881a61d5dffc3a403f2892fb747aca86bab0c":["21019aa828c8c9b0153877543a8b3f200bf2ca19","fcf710a8fcd590cf55c855d422c7a10fce3e6117"],"8e644f11c9d0dc0769d5dd5f842612a9dfa6ecde":["9367dbf5b00d7764583d991c1888f4acc9c9991a"],"54faedfb0e03479a38f5ee82f2dfaeea536e9404":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["00e1c8e1340d9e31d2c6bee5f72d9040ce569049"],"275019a81d0883a1db4560391b072d1fbe272ec4":["104456f4eeacc857f7e1e6408e1483de8c2bd658"],"00e1c8e1340d9e31d2c6bee5f72d9040ce569049":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc","30c8e5574b55d57947e989443dfde611646530ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}