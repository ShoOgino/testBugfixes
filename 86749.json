{"path":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.PagingTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","commits":[{"id":"901e951cec2e6af4e503209a6721c8834db23279","date":1420556599,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.PagingTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      final int afterDoc = after.doc - context.docBase;\n      if (scoreDocsInOrder) {\n        return new ScorerLeafCollector(scoreDocsInOrder) {\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n\n            // This collector cannot handle these scores:\n            assert score != Float.NEGATIVE_INFINITY;\n            assert !Float.isNaN(score);\n\n            totalHits++;\n\n            if (score > after.score || (score == after.score && doc <= afterDoc)) {\n              // hit was collected on a previous page\n              return;\n            }\n\n            if (score <= pqTop.score) {\n              // Since docs are returned in-order (i.e., increasing doc Id), a document\n              // with equal score to pqTop.score cannot compete since HitQueue favors\n              // documents with lower doc Ids. Therefore reject those docs too.\n              return;\n            }\n            collectedHits++;\n            pqTop.doc = doc + docBase;\n            pqTop.score = score;\n            pqTop = pq.updateTop();\n          }\n        };\n      } else {\n        return new ScorerLeafCollector(scoreDocsInOrder) {\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n\n            // This collector cannot handle NaN\n            assert !Float.isNaN(score);\n\n            totalHits++;\n            if (score > after.score || (score == after.score && doc <= afterDoc)) {\n              // hit was collected on a previous page\n              return;\n            }\n            if (score < pqTop.score) {\n              // Doesn't compete w/ bottom entry in queue\n              return;\n            }\n            doc += docBase;\n            if (score == pqTop.score && doc > pqTop.doc) {\n              // Break tie in score by doc ID:\n              return;\n            }\n            collectedHits++;\n            pqTop.doc = doc;\n            pqTop.score = score;\n            pqTop = pq.updateTop();\n          }\n        };\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f","date":1421314520,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.PagingTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.PagingTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      final int afterDoc = after.doc - context.docBase;\n      return new ScorerLeafCollector() {\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector cannot handle these scores:\n          assert score != Float.NEGATIVE_INFINITY;\n          assert !Float.isNaN(score);\n\n          totalHits++;\n\n          if (score > after.score || (score == after.score && doc <= afterDoc)) {\n            // hit was collected on a previous page\n            return;\n          }\n\n          if (score <= pqTop.score) {\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          collectedHits++;\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      final int afterDoc = after.doc - context.docBase;\n      if (scoreDocsInOrder) {\n        return new ScorerLeafCollector(scoreDocsInOrder) {\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n\n            // This collector cannot handle these scores:\n            assert score != Float.NEGATIVE_INFINITY;\n            assert !Float.isNaN(score);\n\n            totalHits++;\n\n            if (score > after.score || (score == after.score && doc <= afterDoc)) {\n              // hit was collected on a previous page\n              return;\n            }\n\n            if (score <= pqTop.score) {\n              // Since docs are returned in-order (i.e., increasing doc Id), a document\n              // with equal score to pqTop.score cannot compete since HitQueue favors\n              // documents with lower doc Ids. Therefore reject those docs too.\n              return;\n            }\n            collectedHits++;\n            pqTop.doc = doc + docBase;\n            pqTop.score = score;\n            pqTop = pq.updateTop();\n          }\n        };\n      } else {\n        return new ScorerLeafCollector(scoreDocsInOrder) {\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n\n            // This collector cannot handle NaN\n            assert !Float.isNaN(score);\n\n            totalHits++;\n            if (score > after.score || (score == after.score && doc <= afterDoc)) {\n              // hit was collected on a previous page\n              return;\n            }\n            if (score < pqTop.score) {\n              // Doesn't compete w/ bottom entry in queue\n              return;\n            }\n            doc += docBase;\n            if (score == pqTop.score && doc > pqTop.doc) {\n              // Break tie in score by doc ID:\n              return;\n            }\n            collectedHits++;\n            pqTop.doc = doc;\n            pqTop.score = score;\n            pqTop = pq.updateTop();\n          }\n        };\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"784ee6cdfa2c32c6eb6c2cd6383ffe4bd320c1fb","date":1512565563,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.PagingTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.PagingTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      final int afterDoc = after.doc - context.docBase;\n      return new ScorerLeafCollector() {\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n\n          if (score > after.score || (score == after.score && doc <= afterDoc)) {\n            // hit was collected on a previous page\n            return;\n          }\n\n          if (score <= pqTop.score) {\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          collectedHits++;\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      final int afterDoc = after.doc - context.docBase;\n      return new ScorerLeafCollector() {\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector cannot handle these scores:\n          assert score != Float.NEGATIVE_INFINITY;\n          assert !Float.isNaN(score);\n\n          totalHits++;\n\n          if (score > after.score || (score == after.score && doc <= afterDoc)) {\n            // hit was collected on a previous page\n            return;\n          }\n\n          if (score <= pqTop.score) {\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          collectedHits++;\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5003664d14ef48a0557ce1d8a684b15d62efe912","date":1539883534,"type":3,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.PagingTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.PagingTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      final int afterDoc = after.doc - context.docBase;\n\n      return new ScorerLeafCollector() {\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n\n          if (score > after.score || (score == after.score && doc <= afterDoc)) {\n            // hit was collected on a previous page\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO && totalHits >= totalHitsThreshold) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            return;\n          }\n\n          if (score <= pqTop.score) {\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          collectedHits++;\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      final int afterDoc = after.doc - context.docBase;\n      return new ScorerLeafCollector() {\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n\n          if (score > after.score || (score == after.score && doc <= afterDoc)) {\n            // hit was collected on a previous page\n            return;\n          }\n\n          if (score <= pqTop.score) {\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          collectedHits++;\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":["5374ec368ef9441d694af8df95b2ffbae3d7f03b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5374ec368ef9441d694af8df95b2ffbae3d7f03b","date":1548748689,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.PagingTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.PagingTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      final int afterDoc = after.doc - context.docBase;\n\n      return new ScorerLeafCollector() {\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n\n          if (score > after.score || (score == after.score && doc <= afterDoc)) {\n            // hit was collected on a previous page\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO && totalHits > totalHitsThreshold) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            return;\n          }\n\n          if (score <= pqTop.score) {\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          collectedHits++;\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      final int afterDoc = after.doc - context.docBase;\n\n      return new ScorerLeafCollector() {\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n\n          if (score > after.score || (score == after.score && doc <= afterDoc)) {\n            // hit was collected on a previous page\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO && totalHits >= totalHitsThreshold) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            return;\n          }\n\n          if (score <= pqTop.score) {\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          collectedHits++;\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n      };\n    }\n\n","bugFix":["5003664d14ef48a0557ce1d8a684b15d62efe912"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e19eef45a852c3316ae52fdf941731448ece967a","date":1567670879,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.PagingTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.PagingTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      final int afterDoc = after.doc - context.docBase;\n\n      return new ScorerLeafCollector() {\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (score > after.score || (score == after.score && doc <= afterDoc)) {\n            // hit was collected on a previous page\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO && hitsThresholdChecker.isThresholdReached()) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            return;\n          }\n\n          if (score <= pqTop.score) {\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          collectedHits++;\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      final int afterDoc = after.doc - context.docBase;\n\n      return new ScorerLeafCollector() {\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n\n          if (score > after.score || (score == after.score && doc <= afterDoc)) {\n            // hit was collected on a previous page\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO && totalHits > totalHitsThreshold) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            return;\n          }\n\n          if (score <= pqTop.score) {\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          collectedHits++;\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5319c194edd3bf49f39c6d198107ed213c1d3670","date":1569842580,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.PagingTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.PagingTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      final int afterDoc = after.doc - context.docBase;\n\n      return new ScorerLeafCollector() {\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (score > after.score || (score == after.score && doc <= afterDoc)) {\n            // hit was collected on a previous page\n            if ((totalHitsRelation == TotalHits.Relation.EQUAL_TO || shouldUpdateMinScore())\n                  && hitsThresholdChecker.isThresholdReached()) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            return;\n          }\n\n          if (score <= pqTop.score) {\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          collectedHits++;\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      final int afterDoc = after.doc - context.docBase;\n\n      return new ScorerLeafCollector() {\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (score > after.score || (score == after.score && doc <= afterDoc)) {\n            // hit was collected on a previous page\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO && hitsThresholdChecker.isThresholdReached()) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            return;\n          }\n\n          if (score <= pqTop.score) {\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          collectedHits++;\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f00d3f1ad3bbb957062c4871ec23f49edda800c6","date":1569925943,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.PagingTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.PagingTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      final int afterDoc = after.doc - context.docBase;\n\n      return new ScorerLeafCollector() {\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (score > after.score || (score == after.score && doc <= afterDoc)) {\n            // hit was collected on a previous page\n            updateMinCompetitiveScore(scorer, totalHitsRelation == TotalHits.Relation.EQUAL_TO);\n            return;\n          }\n\n          if (score <= pqTop.score) {\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          collectedHits++;\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer, true);\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      final int afterDoc = after.doc - context.docBase;\n\n      return new ScorerLeafCollector() {\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (score > after.score || (score == after.score && doc <= afterDoc)) {\n            // hit was collected on a previous page\n            if ((totalHitsRelation == TotalHits.Relation.EQUAL_TO || shouldUpdateMinScore())\n                  && hitsThresholdChecker.isThresholdReached()) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            return;\n          }\n\n          if (score <= pqTop.score) {\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          collectedHits++;\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74844ead01492c17079ed382d0924f4df2fa72e3","date":1569970726,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.PagingTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.PagingTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      final int afterDoc = after.doc - context.docBase;\n\n      return new ScorerLeafCollector() {\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (score > after.score || (score == after.score && doc <= afterDoc)) {\n            // hit was collected on a previous page\n            updateMinCompetitiveScore(scorer, totalHitsRelation == TotalHits.Relation.EQUAL_TO);\n            return;\n          }\n\n          if (score <= pqTop.score) {\n            // the document is not competitive but we need to update the minimum competitive score\n            // if we just reached the total hits threshold or if the global minimum score (bottomValueChecker)\n            // has been updated\n            updateMinCompetitiveScore(scorer, totalHitsRelation == TotalHits.Relation.EQUAL_TO);\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          collectedHits++;\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer, true);\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      final int afterDoc = after.doc - context.docBase;\n\n      return new ScorerLeafCollector() {\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (score > after.score || (score == after.score && doc <= afterDoc)) {\n            // hit was collected on a previous page\n            updateMinCompetitiveScore(scorer, totalHitsRelation == TotalHits.Relation.EQUAL_TO);\n            return;\n          }\n\n          if (score <= pqTop.score) {\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          collectedHits++;\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer, true);\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0db0ef4e326916fc107ab6e066754d3ecba5197b","date":1570005243,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.PagingTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.PagingTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      final int afterDoc = after.doc - context.docBase;\n\n      return new ScorerLeafCollector() {\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (score > after.score || (score == after.score && doc <= afterDoc)) {\n            // hit was collected on a previous page\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // we can start setting the min competitive score if we just\n              // reached totalHitsThreshold\n              updateMinCompetitiveScore(scorer);\n            }\n            return;\n          }\n\n          if (score <= pqTop.score) {\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // we can start setting the min competitive score if we just\n              // reached totalHitsThreshold\n              updateMinCompetitiveScore(scorer);\n            }\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n\n            return;\n          }\n          collectedHits++;\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      final int afterDoc = after.doc - context.docBase;\n\n      return new ScorerLeafCollector() {\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (score > after.score || (score == after.score && doc <= afterDoc)) {\n            // hit was collected on a previous page\n            updateMinCompetitiveScore(scorer, totalHitsRelation == TotalHits.Relation.EQUAL_TO);\n            return;\n          }\n\n          if (score <= pqTop.score) {\n            // the document is not competitive but we need to update the minimum competitive score\n            // if we just reached the total hits threshold or if the global minimum score (bottomValueChecker)\n            // has been updated\n            updateMinCompetitiveScore(scorer, totalHitsRelation == TotalHits.Relation.EQUAL_TO);\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          collectedHits++;\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer, true);\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f0c10c01b195758b50e02599868e4093eb712f57","date":1570008306,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.PagingTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.PagingTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      final int afterDoc = after.doc - context.docBase;\n\n      return new ScorerLeafCollector() {\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (score > after.score || (score == after.score && doc <= afterDoc)) {\n            // hit was collected on a previous page\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO && hitsThresholdChecker.isThresholdReached()) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            return;\n          }\n\n          if (score <= pqTop.score) {\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO && hitsThresholdChecker.isThresholdReached()) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          collectedHits++;\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      final int afterDoc = after.doc - context.docBase;\n\n      return new ScorerLeafCollector() {\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (score > after.score || (score == after.score && doc <= afterDoc)) {\n            // hit was collected on a previous page\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // we can start setting the min competitive score if we just\n              // reached totalHitsThreshold\n              updateMinCompetitiveScore(scorer);\n            }\n            return;\n          }\n\n          if (score <= pqTop.score) {\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // we can start setting the min competitive score if we just\n              // reached totalHitsThreshold\n              updateMinCompetitiveScore(scorer);\n            }\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n\n            return;\n          }\n          collectedHits++;\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"807314aa41c10866aec273a0e54fd0d24d8971de","date":1570435832,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.PagingTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.PagingTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - context.docBase;\n\n      return new ScorerLeafCollector() {\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (minScoreAcc != null && totalHits % minScoreAcc.modInterval == 0) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n\n          if (score > after.score || (score == after.score && doc <= afterDoc)) {\n            // hit was collected on a previous page\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            return;\n          }\n\n          if (score <= pqTop.score) {\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          collectedHits++;\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      final int afterDoc = after.doc - context.docBase;\n\n      return new ScorerLeafCollector() {\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (score > after.score || (score == after.score && doc <= afterDoc)) {\n            // hit was collected on a previous page\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO && hitsThresholdChecker.isThresholdReached()) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            return;\n          }\n\n          if (score <= pqTop.score) {\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO && hitsThresholdChecker.isThresholdReached()) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          collectedHits++;\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e54bf71d0bc209042b2f8985bba5b9d57e360a3e","date":1571657829,"type":3,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.PagingTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.PagingTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - context.docBase;\n\n      return new ScorerLeafCollector() {\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (minScoreAcc != null && (totalHits & minScoreAcc.modInterval) == 0) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n\n          if (score > after.score || (score == after.score && doc <= afterDoc)) {\n            // hit was collected on a previous page\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            return;\n          }\n\n          if (score <= pqTop.score) {\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          collectedHits++;\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - context.docBase;\n\n      return new ScorerLeafCollector() {\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (minScoreAcc != null && totalHits % minScoreAcc.modInterval == 0) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n\n          if (score > after.score || (score == after.score && doc <= afterDoc)) {\n            // hit was collected on a previous page\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            return;\n          }\n\n          if (score <= pqTop.score) {\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          collectedHits++;\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f","date":1571662992,"type":3,"author":"Jim Ferenczi","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.PagingTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.PagingTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - context.docBase;\n\n      return new ScorerLeafCollector() {\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (minScoreAcc != null && (totalHits & minScoreAcc.modInterval) == 0) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n\n          if (score > after.score || (score == after.score && doc <= afterDoc)) {\n            // hit was collected on a previous page\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            return;\n          }\n\n          if (score <= pqTop.score) {\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          collectedHits++;\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      final int afterDoc = after.doc - context.docBase;\n\n      return new ScorerLeafCollector() {\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (score > after.score || (score == after.score && doc <= afterDoc)) {\n            // hit was collected on a previous page\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO && hitsThresholdChecker.isThresholdReached()) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            return;\n          }\n\n          if (score <= pqTop.score) {\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          collectedHits++;\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e19eef45a852c3316ae52fdf941731448ece967a":["5374ec368ef9441d694af8df95b2ffbae3d7f03b"],"807314aa41c10866aec273a0e54fd0d24d8971de":["f0c10c01b195758b50e02599868e4093eb712f57"],"784ee6cdfa2c32c6eb6c2cd6383ffe4bd320c1fb":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"901e951cec2e6af4e503209a6721c8834db23279":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5003664d14ef48a0557ce1d8a684b15d62efe912":["784ee6cdfa2c32c6eb6c2cd6383ffe4bd320c1fb"],"f00d3f1ad3bbb957062c4871ec23f49edda800c6":["5319c194edd3bf49f39c6d198107ed213c1d3670"],"3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f":["e19eef45a852c3316ae52fdf941731448ece967a","e54bf71d0bc209042b2f8985bba5b9d57e360a3e"],"0db0ef4e326916fc107ab6e066754d3ecba5197b":["74844ead01492c17079ed382d0924f4df2fa72e3"],"e54bf71d0bc209042b2f8985bba5b9d57e360a3e":["807314aa41c10866aec273a0e54fd0d24d8971de"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["901e951cec2e6af4e503209a6721c8834db23279"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f0c10c01b195758b50e02599868e4093eb712f57":["0db0ef4e326916fc107ab6e066754d3ecba5197b"],"74844ead01492c17079ed382d0924f4df2fa72e3":["f00d3f1ad3bbb957062c4871ec23f49edda800c6"],"5374ec368ef9441d694af8df95b2ffbae3d7f03b":["5003664d14ef48a0557ce1d8a684b15d62efe912"],"5319c194edd3bf49f39c6d198107ed213c1d3670":["e19eef45a852c3316ae52fdf941731448ece967a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f"]},"commit2Childs":{"e19eef45a852c3316ae52fdf941731448ece967a":["3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f","5319c194edd3bf49f39c6d198107ed213c1d3670"],"807314aa41c10866aec273a0e54fd0d24d8971de":["e54bf71d0bc209042b2f8985bba5b9d57e360a3e"],"784ee6cdfa2c32c6eb6c2cd6383ffe4bd320c1fb":["5003664d14ef48a0557ce1d8a684b15d62efe912"],"901e951cec2e6af4e503209a6721c8834db23279":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"5003664d14ef48a0557ce1d8a684b15d62efe912":["5374ec368ef9441d694af8df95b2ffbae3d7f03b"],"f00d3f1ad3bbb957062c4871ec23f49edda800c6":["74844ead01492c17079ed382d0924f4df2fa72e3"],"3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0db0ef4e326916fc107ab6e066754d3ecba5197b":["f0c10c01b195758b50e02599868e4093eb712f57"],"e54bf71d0bc209042b2f8985bba5b9d57e360a3e":["3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["784ee6cdfa2c32c6eb6c2cd6383ffe4bd320c1fb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["901e951cec2e6af4e503209a6721c8834db23279"],"f0c10c01b195758b50e02599868e4093eb712f57":["807314aa41c10866aec273a0e54fd0d24d8971de"],"74844ead01492c17079ed382d0924f4df2fa72e3":["0db0ef4e326916fc107ab6e066754d3ecba5197b"],"5374ec368ef9441d694af8df95b2ffbae3d7f03b":["e19eef45a852c3316ae52fdf941731448ece967a"],"5319c194edd3bf49f39c6d198107ed213c1d3670":["f00d3f1ad3bbb957062c4871ec23f49edda800c6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}