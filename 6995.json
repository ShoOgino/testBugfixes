{"path":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#runTestBytes(Bytes.Mode,boolean).mjava","commits":[{"id":"01f60198ece724a6e96cd0b45f289cf42ff83d4f","date":1286864103,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"/dev/null","sourceNew":"  // nocommit -- for sorted test, do our own Sort of the\n  // values and verify it's identical\n  public void runTestBytes(final Bytes.Mode mode,\n      final boolean fixedSize) throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator()\n        : null;\n\n    Directory dir = newDirectory();\n    Writer w = Bytes\n        .getWriter(dir, \"test\", mode, comp, fixedSize);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int lenMin, lenMax;\n    if (fixedSize) {\n      lenMin = lenMax = 3 + random.nextInt(7);\n    } else {\n      lenMin = 1;\n      lenMax = 15 + random.nextInt(6);\n    }\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomUnicodeString(random, lenMin, lenMax);\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n\n    Reader r = Bytes.getReader(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = r.getEnum();\n      assertNotNull(\"enum is null\", bytesEnum);\n      ValuesAttribute attr = bytesEnum.addAttribute(ValuesAttribute.class);\n      assertNotNull(\"attribute is null\", attr);\n      BytesRef ref = attr.bytes();\n      assertNotNull(\"BytesRef is null - enum not initialized to use bytes\", attr);\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length() + \" lenRight: \" + utf8String.length() , values[idx],  utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc+1));\n\n      bytesEnum.close();\n    }\n    \n    \n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      Reader.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = r.loadSorted(comp);\n      } else {\n        s = r.load();\n        ss = null;\n      }\n\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.bytes(idx));\n        assertEquals(\"doc \" + idx, values[idx], s.bytes(idx).utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx))\n              .utf8ToString());\n          Reader.SortedSource.LookupResult result = ss.getByValue(new BytesRef(\n              values[idx]));\n          assertTrue(result.found);\n          assertEquals(ss.ord(idx), result.ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomUnicodeString(\n              random, lenMin, lenMax));\n          SortedSource.LookupResult result = ss.getByValue(bytesValue);\n          if (result.found) {\n            assert result.ord > 0;\n            assertTrue(bytesValue.bytesEquals(ss.getByOrd(result.ord)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), result.ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert result.ord >= 0;\n            if (result.ord == 0) {\n              final BytesRef firstRef = ss.getByOrd(1);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (result.ord == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // random string fell between two of our values\n              final BytesRef before = (BytesRef) ss.getByOrd(result.ord)\n                  .clone();\n              final BytesRef after = ss.getByOrd(result.ord + 1);\n              assertTrue(before.compareTo(bytesValue) < 0);\n              assertTrue(bytesValue.compareTo(after) < 0);\n\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e28c49f1fb6215a550fdadcf3805aa629b63ec0","date":1288081775,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  // nocommit -- for sorted test, do our own Sort of the\n  // values and verify it's identical\n  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int lenMin, lenMax;\n    if (fixedSize) {\n      lenMin = lenMax = 3 + random.nextInt(7);\n    } else {\n      lenMin = 1;\n      lenMax = 15 + random.nextInt(6);\n    }\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomUnicodeString(random, lenMin, lenMax);\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = r.getEnum();\n      assertNotNull(\"enum is null\", bytesEnum);\n      ValuesAttribute attr = bytesEnum.addAttribute(ValuesAttribute.class);\n      assertNotNull(\"attribute is null\", attr);\n      BytesRef ref = attr.bytes();\n      assertNotNull(\"BytesRef is null - enum not initialized to use bytes\",\n          attr);\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = r.loadSorted(comp);\n      } else {\n        s = r.load();\n        ss = null;\n      }\n\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.bytes(idx));\n        assertEquals(\"doc \" + idx, values[idx], s.bytes(idx).utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx))\n              .utf8ToString());\n          DocValues.SortedSource.LookupResult result = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(result.found);\n          assertEquals(ss.ord(idx), result.ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomUnicodeString(\n              random, lenMin, lenMax));\n          SortedSource.LookupResult result = ss.getByValue(bytesValue);\n          if (result.found) {\n            assert result.ord > 0;\n            assertTrue(bytesValue.bytesEquals(ss.getByOrd(result.ord)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), result.ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert result.ord >= 0;\n            if (result.ord == 0) {\n              final BytesRef firstRef = ss.getByOrd(1);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (result.ord == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // random string fell between two of our values\n              final BytesRef before = (BytesRef) ss.getByOrd(result.ord)\n                  .clone();\n              final BytesRef after = ss.getByOrd(result.ord + 1);\n              assertTrue(before.compareTo(bytesValue) < 0);\n              assertTrue(bytesValue.compareTo(after) < 0);\n\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // nocommit -- for sorted test, do our own Sort of the\n  // values and verify it's identical\n  public void runTestBytes(final Bytes.Mode mode,\n      final boolean fixedSize) throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator()\n        : null;\n\n    Directory dir = newDirectory();\n    Writer w = Bytes\n        .getWriter(dir, \"test\", mode, comp, fixedSize);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int lenMin, lenMax;\n    if (fixedSize) {\n      lenMin = lenMax = 3 + random.nextInt(7);\n    } else {\n      lenMin = 1;\n      lenMax = 15 + random.nextInt(6);\n    }\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomUnicodeString(random, lenMin, lenMax);\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n\n    Reader r = Bytes.getReader(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = r.getEnum();\n      assertNotNull(\"enum is null\", bytesEnum);\n      ValuesAttribute attr = bytesEnum.addAttribute(ValuesAttribute.class);\n      assertNotNull(\"attribute is null\", attr);\n      BytesRef ref = attr.bytes();\n      assertNotNull(\"BytesRef is null - enum not initialized to use bytes\", attr);\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length() + \" lenRight: \" + utf8String.length() , values[idx],  utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc+1));\n\n      bytesEnum.close();\n    }\n    \n    \n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      Reader.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = r.loadSorted(comp);\n      } else {\n        s = r.load();\n        ss = null;\n      }\n\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.bytes(idx));\n        assertEquals(\"doc \" + idx, values[idx], s.bytes(idx).utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx))\n              .utf8ToString());\n          Reader.SortedSource.LookupResult result = ss.getByValue(new BytesRef(\n              values[idx]));\n          assertTrue(result.found);\n          assertEquals(ss.ord(idx), result.ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomUnicodeString(\n              random, lenMin, lenMax));\n          SortedSource.LookupResult result = ss.getByValue(bytesValue);\n          if (result.found) {\n            assert result.ord > 0;\n            assertTrue(bytesValue.bytesEquals(ss.getByOrd(result.ord)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), result.ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert result.ord >= 0;\n            if (result.ord == 0) {\n              final BytesRef firstRef = ss.getByOrd(1);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (result.ord == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // random string fell between two of our values\n              final BytesRef before = (BytesRef) ss.getByOrd(result.ord)\n                  .clone();\n              final BytesRef after = ss.getByOrd(result.ord + 1);\n              assertTrue(before.compareTo(bytesValue) < 0);\n              assertTrue(bytesValue.compareTo(after) < 0);\n\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"39f3757037aa8f710c0cbf9a76a332de735f58b0","date":1288384416,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  // nocommit -- for sorted test, do our own Sort of the\n  // values and verify it's identical\n  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int lenMin, lenMax;\n    if (fixedSize) {\n      lenMin = lenMax = 3 + random.nextInt(7);\n    } else {\n      lenMin = 1;\n      lenMax = 15 + random.nextInt(6);\n    }\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomUnicodeString(random, lenMin, lenMax);\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = r.getEnum();\n      assertNotNull(\"enum is null\", bytesEnum);\n      ValuesAttribute attr = bytesEnum.addAttribute(ValuesAttribute.class);\n      assertNotNull(\"attribute is null\", attr);\n      BytesRef ref = attr.bytes();\n      assertNotNull(\"BytesRef is null - enum not initialized to use bytes\",\n          attr);\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = r.loadSorted(comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx).utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx))\n              .utf8ToString());\n          DocValues.SortedSource.LookupResult result = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(result.found);\n          assertEquals(ss.ord(idx), result.ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomUnicodeString(\n              random, lenMin, lenMax));\n          SortedSource.LookupResult result = ss.getByValue(bytesValue);\n          if (result.found) {\n            assert result.ord > 0;\n            assertTrue(bytesValue.bytesEquals(ss.getByOrd(result.ord)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), result.ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert result.ord >= 0;\n            if (result.ord == 0) {\n              final BytesRef firstRef = ss.getByOrd(1);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (result.ord == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // random string fell between two of our values\n              final BytesRef before = (BytesRef) ss.getByOrd(result.ord)\n                  .clone();\n              final BytesRef after = ss.getByOrd(result.ord + 1);\n              assertTrue(before.compareTo(bytesValue) < 0);\n              assertTrue(bytesValue.compareTo(after) < 0);\n\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // nocommit -- for sorted test, do our own Sort of the\n  // values and verify it's identical\n  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int lenMin, lenMax;\n    if (fixedSize) {\n      lenMin = lenMax = 3 + random.nextInt(7);\n    } else {\n      lenMin = 1;\n      lenMax = 15 + random.nextInt(6);\n    }\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomUnicodeString(random, lenMin, lenMax);\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = r.getEnum();\n      assertNotNull(\"enum is null\", bytesEnum);\n      ValuesAttribute attr = bytesEnum.addAttribute(ValuesAttribute.class);\n      assertNotNull(\"attribute is null\", attr);\n      BytesRef ref = attr.bytes();\n      assertNotNull(\"BytesRef is null - enum not initialized to use bytes\",\n          attr);\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = r.loadSorted(comp);\n      } else {\n        s = r.load();\n        ss = null;\n      }\n\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.bytes(idx));\n        assertEquals(\"doc \" + idx, values[idx], s.bytes(idx).utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx))\n              .utf8ToString());\n          DocValues.SortedSource.LookupResult result = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(result.found);\n          assertEquals(ss.ord(idx), result.ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomUnicodeString(\n              random, lenMin, lenMax));\n          SortedSource.LookupResult result = ss.getByValue(bytesValue);\n          if (result.found) {\n            assert result.ord > 0;\n            assertTrue(bytesValue.bytesEquals(ss.getByOrd(result.ord)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), result.ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert result.ord >= 0;\n            if (result.ord == 0) {\n              final BytesRef firstRef = ss.getByOrd(1);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (result.ord == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // random string fell between two of our values\n              final BytesRef before = (BytesRef) ss.getByOrd(result.ord)\n                  .clone();\n              final BytesRef after = ss.getByOrd(result.ord + 1);\n              assertTrue(before.compareTo(bytesValue) < 0);\n              assertTrue(bytesValue.compareTo(after) < 0);\n\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0637f89202e27b25802435a9cf789fc0890c8a67","date":1288436161,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  // nocommit -- for sorted test, do our own Sort of the\n  // values and verify it's identical\n  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int lenMin, lenMax;\n    if (fixedSize) {\n      lenMin = lenMax = 3 + random.nextInt(7);\n    } else {\n      lenMin = 1;\n      lenMax = 15 + random.nextInt(6);\n    }\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomUnicodeString(random, lenMin, lenMax);\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = r.getEnum();\n      assertNotNull(\"enum is null\", bytesEnum);\n      ValuesAttribute attr = bytesEnum.addAttribute(ValuesAttribute.class);\n      assertNotNull(\"attribute is null\", attr);\n      BytesRef ref = attr.bytes();\n      assertNotNull(\"BytesRef is null - enum not initialized to use bytes\",\n          attr);\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx).utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx))\n              .utf8ToString());\n          DocValues.SortedSource.LookupResult result = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(result.found);\n          assertEquals(ss.ord(idx), result.ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomUnicodeString(\n              random, lenMin, lenMax));\n          SortedSource.LookupResult result = ss.getByValue(bytesValue);\n          if (result.found) {\n            assert result.ord > 0;\n            assertTrue(bytesValue.bytesEquals(ss.getByOrd(result.ord)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), result.ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert result.ord >= 0;\n            if (result.ord == 0) {\n              final BytesRef firstRef = ss.getByOrd(1);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (result.ord == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // random string fell between two of our values\n              final BytesRef before = (BytesRef) ss.getByOrd(result.ord)\n                  .clone();\n              final BytesRef after = ss.getByOrd(result.ord + 1);\n              assertTrue(before.compareTo(bytesValue) < 0);\n              assertTrue(bytesValue.compareTo(after) < 0);\n\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // nocommit -- for sorted test, do our own Sort of the\n  // values and verify it's identical\n  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int lenMin, lenMax;\n    if (fixedSize) {\n      lenMin = lenMax = 3 + random.nextInt(7);\n    } else {\n      lenMin = 1;\n      lenMax = 15 + random.nextInt(6);\n    }\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomUnicodeString(random, lenMin, lenMax);\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = r.getEnum();\n      assertNotNull(\"enum is null\", bytesEnum);\n      ValuesAttribute attr = bytesEnum.addAttribute(ValuesAttribute.class);\n      assertNotNull(\"attribute is null\", attr);\n      BytesRef ref = attr.bytes();\n      assertNotNull(\"BytesRef is null - enum not initialized to use bytes\",\n          attr);\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = r.loadSorted(comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx).utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx))\n              .utf8ToString());\n          DocValues.SortedSource.LookupResult result = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(result.found);\n          assertEquals(ss.ord(idx), result.ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomUnicodeString(\n              random, lenMin, lenMax));\n          SortedSource.LookupResult result = ss.getByValue(bytesValue);\n          if (result.found) {\n            assert result.ord > 0;\n            assertTrue(bytesValue.bytesEquals(ss.getByOrd(result.ord)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), result.ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert result.ord >= 0;\n            if (result.ord == 0) {\n              final BytesRef firstRef = ss.getByOrd(1);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (result.ord == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // random string fell between two of our values\n              final BytesRef before = (BytesRef) ss.getByOrd(result.ord)\n                  .clone();\n              final BytesRef after = ss.getByOrd(result.ord + 1);\n              assertTrue(before.compareTo(bytesValue) < 0);\n              assertTrue(bytesValue.compareTo(after) < 0);\n\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b5c559c875836474bafae7243263d93b1b1965db","date":1289581659,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int lenMin, lenMax;\n    if (fixedSize) {\n      lenMin = lenMax = 3 + random.nextInt(7);\n    } else {\n      lenMin = 1;\n      lenMax = 15 + random.nextInt(6);\n    }\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomUnicodeString(random, lenMin, lenMax);\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = r.getEnum();\n      assertNotNull(\"enum is null\", bytesEnum);\n      ValuesAttribute attr = bytesEnum.addAttribute(ValuesAttribute.class);\n      assertNotNull(\"attribute is null\", attr);\n      BytesRef ref = attr.bytes();\n      assertNotNull(\"BytesRef is null - enum not initialized to use bytes\",\n          attr);\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx).utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx))\n              .utf8ToString());\n          DocValues.SortedSource.LookupResult result = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(result.found);\n          assertEquals(ss.ord(idx), result.ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomUnicodeString(\n              random, lenMin, lenMax));\n          SortedSource.LookupResult result = ss.getByValue(bytesValue);\n          if (result.found) {\n            assert result.ord > 0;\n            assertTrue(bytesValue.bytesEquals(ss.getByOrd(result.ord)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), result.ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert result.ord >= 0;\n            if (result.ord == 0) {\n              final BytesRef firstRef = ss.getByOrd(1);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (result.ord == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // random string fell between two of our values\n              final BytesRef before = (BytesRef) ss.getByOrd(result.ord)\n                  .clone();\n              final BytesRef after = ss.getByOrd(result.ord + 1);\n              assertTrue(before.compareTo(bytesValue) < 0);\n              assertTrue(bytesValue.compareTo(after) < 0);\n\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // nocommit -- for sorted test, do our own Sort of the\n  // values and verify it's identical\n  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int lenMin, lenMax;\n    if (fixedSize) {\n      lenMin = lenMax = 3 + random.nextInt(7);\n    } else {\n      lenMin = 1;\n      lenMax = 15 + random.nextInt(6);\n    }\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomUnicodeString(random, lenMin, lenMax);\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = r.getEnum();\n      assertNotNull(\"enum is null\", bytesEnum);\n      ValuesAttribute attr = bytesEnum.addAttribute(ValuesAttribute.class);\n      assertNotNull(\"attribute is null\", attr);\n      BytesRef ref = attr.bytes();\n      assertNotNull(\"BytesRef is null - enum not initialized to use bytes\",\n          attr);\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx).utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx))\n              .utf8ToString());\n          DocValues.SortedSource.LookupResult result = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(result.found);\n          assertEquals(ss.ord(idx), result.ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomUnicodeString(\n              random, lenMin, lenMax));\n          SortedSource.LookupResult result = ss.getByValue(bytesValue);\n          if (result.found) {\n            assert result.ord > 0;\n            assertTrue(bytesValue.bytesEquals(ss.getByOrd(result.ord)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), result.ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert result.ord >= 0;\n            if (result.ord == 0) {\n              final BytesRef firstRef = ss.getByOrd(1);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (result.ord == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // random string fell between two of our values\n              final BytesRef before = (BytesRef) ss.getByOrd(result.ord)\n                  .clone();\n              final BytesRef after = ss.getByOrd(result.ord + 1);\n              assertTrue(before.compareTo(bytesValue) < 0);\n              assertTrue(bytesValue.compareTo(after) < 0);\n\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"39f3757037aa8f710c0cbf9a76a332de735f58b0":["0e28c49f1fb6215a550fdadcf3805aa629b63ec0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0637f89202e27b25802435a9cf789fc0890c8a67":["39f3757037aa8f710c0cbf9a76a332de735f58b0"],"0e28c49f1fb6215a550fdadcf3805aa629b63ec0":["01f60198ece724a6e96cd0b45f289cf42ff83d4f"],"01f60198ece724a6e96cd0b45f289cf42ff83d4f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b5c559c875836474bafae7243263d93b1b1965db":["0637f89202e27b25802435a9cf789fc0890c8a67"]},"commit2Childs":{"39f3757037aa8f710c0cbf9a76a332de735f58b0":["0637f89202e27b25802435a9cf789fc0890c8a67"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["01f60198ece724a6e96cd0b45f289cf42ff83d4f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0e28c49f1fb6215a550fdadcf3805aa629b63ec0":["39f3757037aa8f710c0cbf9a76a332de735f58b0"],"0637f89202e27b25802435a9cf789fc0890c8a67":["b5c559c875836474bafae7243263d93b1b1965db"],"01f60198ece724a6e96cd0b45f289cf42ff83d4f":["0e28c49f1fb6215a550fdadcf3805aa629b63ec0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b5c559c875836474bafae7243263d93b1b1965db":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b5c559c875836474bafae7243263d93b1b1965db"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}