{"path":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","commits":[{"id":"6c228eadc8ab12c4b442521f5890283801a6cab5","date":1358509063,"type":1,"author":"Tommaso Teofili","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(String,DistribPhase).mjava","sourceNew":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.REPLAY)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(\"distrib.from\");\n    boolean localIsLeader = req.getCore().getCoreDescriptor().getCloudDescriptor().isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n    }\n    \n    if (isLeader && !localIsLeader) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"ClusterState says we are the leader, but locally we don't think so\");\n    }\n  }\n\n","sourceOld":"  private void doDefensiveChecks(String shardId, DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.REPLAY)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(\"distrib.from\");\n    boolean localIsLeader = req.getCore().getCoreDescriptor().getCloudDescriptor().isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n    }\n    \n    if (isLeader && !localIsLeader) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"ClusterState says we are the leader, but locally we don't think so\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c4015cd39dff8d4dec562d909f9766debac53aa6","date":1358548736,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(String,DistribPhase).mjava","sourceNew":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.REPLAY)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(\"distrib.from\");\n    boolean localIsLeader = req.getCore().getCoreDescriptor().getCloudDescriptor().isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n    }\n    \n    if (isLeader && !localIsLeader) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"ClusterState says we are the leader, but locally we don't think so\");\n    }\n  }\n\n","sourceOld":"  private void doDefensiveChecks(String shardId, DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.REPLAY)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(\"distrib.from\");\n    boolean localIsLeader = req.getCore().getCoreDescriptor().getCloudDescriptor().isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n    }\n    \n    if (isLeader && !localIsLeader) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"ClusterState says we are the leader, but locally we don't think so\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0beaed456aa3358e5e4a99ea2aea994ef6c81de3","date":1365434191,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","sourceNew":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.REPLAY)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(\"distrib.from\");\n    ClusterState clusterState = zkController.getClusterState();\n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    Slice mySlice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(\"distrib.from.parent\");\n      if (fromShard != null)  {\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = zkController.getClusterState().getCollection(collection).getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else  {\n      log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n    }\n    }\n    \n    if (isLeader && !localIsLeader) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"ClusterState says we are the leader, but locally we don't think so\");\n    }\n  }\n\n","sourceOld":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.REPLAY)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(\"distrib.from\");\n    boolean localIsLeader = req.getCore().getCoreDescriptor().getCloudDescriptor().isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n    }\n    \n    if (isLeader && !localIsLeader) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"ClusterState says we are the leader, but locally we don't think so\");\n    }\n  }\n\n","bugFix":null,"bugIntro":["6776b3c3ed554ace17893a807da5b7a0a6d364c8"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6776b3c3ed554ace17893a807da5b7a0a6d364c8","date":1367964133,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","sourceNew":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.REPLAY)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(\"distrib.from\");\n    ClusterState clusterState = zkController.getClusterState();\n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    Slice mySlice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(\"distrib.from.parent\");\n      if (fromShard != null) {\n        if (!Slice.CONSTRUCTION.equals(mySlice.getState()))  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are not in construction state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = zkController.getClusterState().getCollection(collection).getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n      }\n    }\n\n    if (isLeader && !localIsLeader) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"ClusterState says we are the leader, but locally we don't think so\");\n    }\n  }\n\n","sourceOld":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.REPLAY)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(\"distrib.from\");\n    ClusterState clusterState = zkController.getClusterState();\n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    Slice mySlice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(\"distrib.from.parent\");\n      if (fromShard != null)  {\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = zkController.getClusterState().getCollection(collection).getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else  {\n      log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n    }\n    }\n    \n    if (isLeader && !localIsLeader) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"ClusterState says we are the leader, but locally we don't think so\");\n    }\n  }\n\n","bugFix":["a6378064655e76cd7b908b1cab4ce425b384b508","d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1","6013b4c7388f1627659c8f96c44abd10a294d3a6","0beaed456aa3358e5e4a99ea2aea994ef6c81de3"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8a2f1187198fd8201881b815eea2fa3ba7b8ec5f","date":1369845628,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","sourceNew":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(\"distrib.from\");\n    ClusterState clusterState = zkController.getClusterState();\n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    Slice mySlice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(\"distrib.from.parent\");\n      if (fromShard != null) {\n        if (!Slice.CONSTRUCTION.equals(mySlice.getState()))  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are not in construction state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = zkController.getClusterState().getCollection(collection).getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n      }\n    }\n\n    if (isLeader && !localIsLeader) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"ClusterState says we are the leader, but locally we don't think so\");\n    }\n  }\n\n","sourceOld":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.REPLAY)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(\"distrib.from\");\n    ClusterState clusterState = zkController.getClusterState();\n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    Slice mySlice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(\"distrib.from.parent\");\n      if (fromShard != null) {\n        if (!Slice.CONSTRUCTION.equals(mySlice.getState()))  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are not in construction state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = zkController.getClusterState().getCollection(collection).getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n      }\n    }\n\n    if (isLeader && !localIsLeader) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"ClusterState says we are the leader, but locally we don't think so\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"849494cf2f3a96af5c8c84995108ddd8456fcd04","date":1372277913,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","sourceNew":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(\"distrib.from\");\n    ClusterState clusterState = zkController.getClusterState();\n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    Slice mySlice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(\"distrib.from.parent\");\n      if (fromShard != null) {\n        if (!Slice.CONSTRUCTION.equals(mySlice.getState()))  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are not in construction state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = zkController.getClusterState().getCollection(collection).getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n      }\n    }\n\n    if (isLeader && !localIsLeader) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","sourceOld":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(\"distrib.from\");\n    ClusterState clusterState = zkController.getClusterState();\n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    Slice mySlice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(\"distrib.from.parent\");\n      if (fromShard != null) {\n        if (!Slice.CONSTRUCTION.equals(mySlice.getState()))  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are not in construction state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = zkController.getClusterState().getCollection(collection).getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n      }\n    }\n\n    if (isLeader && !localIsLeader) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"ClusterState says we are the leader, but locally we don't think so\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"96adbab674ae121f8b6b3e10474070b4bd97a219","date":1373614333,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","sourceNew":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(\"distrib.from\");\n    ClusterState clusterState = zkController.getClusterState();\n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    Slice mySlice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(\"distrib.from.parent\");\n      if (fromShard != null) {\n        if (!Slice.CONSTRUCTION.equals(mySlice.getState()))  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are not in construction state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = zkController.getClusterState().getCollection(collection).getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","sourceOld":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(\"distrib.from\");\n    ClusterState clusterState = zkController.getClusterState();\n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    Slice mySlice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(\"distrib.from.parent\");\n      if (fromShard != null) {\n        if (!Slice.CONSTRUCTION.equals(mySlice.getState()))  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are not in construction state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = zkController.getClusterState().getCollection(collection).getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n      }\n    }\n\n    if (isLeader && !localIsLeader) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","sourceNew":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(\"distrib.from\");\n    ClusterState clusterState = zkController.getClusterState();\n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    Slice mySlice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(\"distrib.from.parent\");\n      if (fromShard != null) {\n        if (!Slice.CONSTRUCTION.equals(mySlice.getState()))  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are not in construction state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = zkController.getClusterState().getCollection(collection).getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","sourceOld":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(\"distrib.from\");\n    ClusterState clusterState = zkController.getClusterState();\n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    Slice mySlice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(\"distrib.from.parent\");\n      if (fromShard != null) {\n        if (!Slice.CONSTRUCTION.equals(mySlice.getState()))  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are not in construction state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = zkController.getClusterState().getCollection(collection).getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n      }\n    }\n\n    if (isLeader && !localIsLeader) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"ClusterState says we are the leader, but locally we don't think so\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc841231667f1f315bae6799c068f9aad6543967","date":1381415189,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","sourceNew":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(\"distrib.from\");\n    ClusterState clusterState = zkController.getClusterState();\n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    Slice mySlice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(\"distrib.from.parent\");\n      if (fromShard != null) {\n        if (Slice.ACTIVE.equals(mySlice.getState()))  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = zkController.getClusterState().getCollection(collection).getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","sourceOld":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(\"distrib.from\");\n    ClusterState clusterState = zkController.getClusterState();\n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    Slice mySlice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(\"distrib.from.parent\");\n      if (fromShard != null) {\n        if (!Slice.CONSTRUCTION.equals(mySlice.getState()))  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are not in construction state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = zkController.getClusterState().getCollection(collection).getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"da888af1ab894358122a22229051215f58cf4d54","date":1384408702,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","sourceNew":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(\"distrib.from\");\n    ClusterState clusterState = zkController.getClusterState();\n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    Slice mySlice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(\"distrib.from.parent\");\n      if (fromShard != null) {\n        if (Slice.ACTIVE.equals(mySlice.getState()))  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = zkController.getClusterState().getCollection(collection).getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(\"distrib.from.collection\"); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n        }\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","sourceOld":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(\"distrib.from\");\n    ClusterState clusterState = zkController.getClusterState();\n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    Slice mySlice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(\"distrib.from.parent\");\n      if (fromShard != null) {\n        if (Slice.ACTIVE.equals(mySlice.getState()))  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = zkController.getClusterState().getCollection(collection).getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3333dd7044501b4f20231ea55ab64e688285d153","date":1384785078,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","sourceNew":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(DISTRIB_FROM);\n    ClusterState clusterState = zkController.getClusterState();\n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    Slice mySlice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);\n      if (fromShard != null) {\n        if (Slice.ACTIVE.equals(mySlice.getState()))  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = zkController.getClusterState().getCollection(collection).getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n        }\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","sourceOld":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(\"distrib.from\");\n    ClusterState clusterState = zkController.getClusterState();\n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    Slice mySlice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(\"distrib.from.parent\");\n      if (fromShard != null) {\n        if (Slice.ACTIVE.equals(mySlice.getState()))  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = zkController.getClusterState().getCollection(collection).getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(\"distrib.from.collection\"); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n        }\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","sourceNew":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(DISTRIB_FROM);\n    ClusterState clusterState = zkController.getClusterState();\n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    Slice mySlice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);\n      if (fromShard != null) {\n        if (Slice.ACTIVE.equals(mySlice.getState()))  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = zkController.getClusterState().getCollection(collection).getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n        }\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","sourceOld":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(\"distrib.from\");\n    ClusterState clusterState = zkController.getClusterState();\n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    Slice mySlice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(\"distrib.from.parent\");\n      if (fromShard != null) {\n        if (Slice.ACTIVE.equals(mySlice.getState()))  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = zkController.getClusterState().getCollection(collection).getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(\"distrib.from.collection\"); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n        }\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14d5815ecbef89580f5c48990bcd433f04f8563a","date":1399564106,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","sourceNew":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(DISTRIB_FROM);\n    ClusterState clusterState = zkController.getClusterState();\n        \n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    Slice mySlice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);\n      if (fromShard != null) {\n        if (Slice.ACTIVE.equals(mySlice.getState()))  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = zkController.getClusterState().getCollection(collection).getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n        }\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","sourceOld":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(DISTRIB_FROM);\n    ClusterState clusterState = zkController.getClusterState();\n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    Slice mySlice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);\n      if (fromShard != null) {\n        if (Slice.ACTIVE.equals(mySlice.getState()))  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = zkController.getClusterState().getCollection(collection).getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n        }\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6e36353d7461af8d2329a78a71457cf8e3c1e88f","date":1411572107,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","sourceNew":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(DISTRIB_FROM);\n    ClusterState clusterState = zkController.getClusterState();\n        \n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    Slice mySlice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);\n      if (fromShard != null) {\n        if (Slice.ACTIVE.equals(mySlice.getState()))  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = zkController.getClusterState().getCollection(collection).getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n          SolrException solrExc = new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n          solrExc.setMetadata(\"cause\", \"LeaderChanged\");\n          throw solrExc;\n        }\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","sourceOld":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(DISTRIB_FROM);\n    ClusterState clusterState = zkController.getClusterState();\n        \n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    Slice mySlice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);\n      if (fromShard != null) {\n        if (Slice.ACTIVE.equals(mySlice.getState()))  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = zkController.getClusterState().getCollection(collection).getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n        }\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296","date":1427866967,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","sourceNew":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(DISTRIB_FROM);\n    ClusterState clusterState = zkController.getClusterState();\n        \n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    Slice mySlice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);\n      if (fromShard != null) {\n        if (mySlice.getState() == Slice.State.ACTIVE)  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = zkController.getClusterState().getCollection(collection).getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n          SolrException solrExc = new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n          solrExc.setMetadata(\"cause\", \"LeaderChanged\");\n          throw solrExc;\n        }\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","sourceOld":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(DISTRIB_FROM);\n    ClusterState clusterState = zkController.getClusterState();\n        \n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    Slice mySlice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);\n      if (fromShard != null) {\n        if (Slice.ACTIVE.equals(mySlice.getState()))  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = zkController.getClusterState().getCollection(collection).getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n          SolrException solrExc = new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n          solrExc.setMetadata(\"cause\", \"LeaderChanged\");\n          throw solrExc;\n        }\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0c924d4069ef5a5bc479a493befe0121aada6896","date":1427901860,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","sourceNew":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(DISTRIB_FROM);\n    ClusterState clusterState = zkController.getClusterState();\n        \n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    Slice mySlice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);\n      if (fromShard != null) {\n        if (mySlice.getState() == Slice.State.ACTIVE)  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = zkController.getClusterState().getCollection(collection).getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n          SolrException solrExc = new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n          solrExc.setMetadata(\"cause\", \"LeaderChanged\");\n          throw solrExc;\n        }\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","sourceOld":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(DISTRIB_FROM);\n    ClusterState clusterState = zkController.getClusterState();\n        \n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    Slice mySlice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);\n      if (fromShard != null) {\n        if (Slice.ACTIVE.equals(mySlice.getState()))  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = zkController.getClusterState().getCollection(collection).getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n          SolrException solrExc = new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n          solrExc.setMetadata(\"cause\", \"LeaderChanged\");\n          throw solrExc;\n        }\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04c8df3f10a676c3de5dbf390f17a2de2d45cacd","date":1461615626,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","sourceNew":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(DISTRIB_FROM);\n    ClusterState clusterState = zkController.getClusterState();\n        \n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    DocCollection docCollection = clusterState.getCollection(collection);\n    Slice mySlice = docCollection.getSlice(cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);\n      if (fromShard != null) {\n        if (mySlice.getState() == Slice.State.ACTIVE)  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = docCollection.getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n          SolrException solrExc = new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n          solrExc.setMetadata(\"cause\", \"LeaderChanged\");\n          throw solrExc;\n        }\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","sourceOld":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(DISTRIB_FROM);\n    ClusterState clusterState = zkController.getClusterState();\n        \n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    Slice mySlice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);\n      if (fromShard != null) {\n        if (mySlice.getState() == Slice.State.ACTIVE)  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = zkController.getClusterState().getCollection(collection).getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n          SolrException solrExc = new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n          solrExc.setMetadata(\"cause\", \"LeaderChanged\");\n          throw solrExc;\n        }\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7f901826e47f75f810d7aae24b0455d21ea1fe2","date":1461678892,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","sourceNew":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(DISTRIB_FROM);\n    ClusterState clusterState = zkController.getClusterState();\n        \n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    DocCollection docCollection = clusterState.getCollection(collection);\n    Slice mySlice = docCollection.getSlice(cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);\n      if (fromShard != null) {\n        if (mySlice.getState() == Slice.State.ACTIVE)  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = docCollection.getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n          SolrException solrExc = new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n          solrExc.setMetadata(\"cause\", \"LeaderChanged\");\n          throw solrExc;\n        }\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","sourceOld":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(DISTRIB_FROM);\n    ClusterState clusterState = zkController.getClusterState();\n        \n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    Slice mySlice = clusterState.getSlice(collection, cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);\n      if (fromShard != null) {\n        if (mySlice.getState() == Slice.State.ACTIVE)  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = zkController.getClusterState().getCollection(collection).getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n          SolrException solrExc = new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n          solrExc.setMetadata(\"cause\", \"LeaderChanged\");\n          throw solrExc;\n        }\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"601f914e4448cab7640fecfb5d15f8f2e2af0bf6","date":1508947828,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","sourceNew":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(DISTRIB_FROM);\n    ClusterState clusterState = zkController.getClusterState();\n\n    DocCollection docCollection = clusterState.getCollection(collection);\n    Slice mySlice = docCollection.getSlice(cloudDesc.getShardId());\n    boolean localIsLeader = cloudDesc.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);\n      if (fromShard != null) {\n        if (mySlice.getState() == Slice.State.ACTIVE)  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = docCollection.getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n          SolrException solrExc = new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n          solrExc.setMetadata(\"cause\", \"LeaderChanged\");\n          throw solrExc;\n        }\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","sourceOld":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(DISTRIB_FROM);\n    ClusterState clusterState = zkController.getClusterState();\n        \n    CloudDescriptor cloudDescriptor = req.getCore().getCoreDescriptor().getCloudDescriptor();\n    DocCollection docCollection = clusterState.getCollection(collection);\n    Slice mySlice = docCollection.getSlice(cloudDescriptor.getShardId());\n    boolean localIsLeader = cloudDescriptor.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);\n      if (fromShard != null) {\n        if (mySlice.getState() == Slice.State.ACTIVE)  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = docCollection.getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n          SolrException solrExc = new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n          solrExc.setMetadata(\"cause\", \"LeaderChanged\");\n          throw solrExc;\n        }\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1a77e5e21cbd575a8240b0e3926164f15295f4e8","date":1544979500,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","sourceNew":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(DISTRIB_FROM);\n    ClusterState clusterState = zkController.getClusterState();\n\n    DocCollection docCollection = clusterState.getCollection(collection);\n    Slice mySlice = docCollection.getSlice(cloudDesc.getShardId());\n    boolean localIsLeader = cloudDesc.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);\n      if (fromShard != null) {\n        if (mySlice.getState() == Slice.State.ACTIVE)  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = docCollection.getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n          SolrException solrExc = new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n          solrExc.setMetadata(\"cause\", \"LeaderChanged\");\n          throw solrExc;\n        }\n      }\n    }\n\n    int count = 0;\n    while (((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) && count < 5) {\n      count++;\n      // re-getting localIsLeader since we published to ZK first before setting localIsLeader value\n      localIsLeader = cloudDesc.isLeader();\n      try {\n        Thread.sleep(500);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","sourceOld":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(DISTRIB_FROM);\n    ClusterState clusterState = zkController.getClusterState();\n\n    DocCollection docCollection = clusterState.getCollection(collection);\n    Slice mySlice = docCollection.getSlice(cloudDesc.getShardId());\n    boolean localIsLeader = cloudDesc.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);\n      if (fromShard != null) {\n        if (mySlice.getState() == Slice.State.ACTIVE)  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = docCollection.getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n          SolrException solrExc = new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n          solrExc.setMetadata(\"cause\", \"LeaderChanged\");\n          throw solrExc;\n        }\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9d70e774cb25c8a8d2c3e5e84200f235f9168d87","date":1553016391,"type":5,"author":"Bar Rotstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedZkUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","sourceNew":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(DISTRIB_FROM);\n    ClusterState clusterState = zkController.getClusterState();\n\n    DocCollection docCollection = clusterState.getCollection(collection);\n    Slice mySlice = docCollection.getSlice(cloudDesc.getShardId());\n    boolean localIsLeader = cloudDesc.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);\n      if (fromShard != null) {\n        if (mySlice.getState() == Slice.State.ACTIVE)  {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = docCollection.getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n          SolrException solrExc = new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n          solrExc.setMetadata(\"cause\", \"LeaderChanged\");\n          throw solrExc;\n        }\n      }\n    }\n\n    int count = 0;\n    while (((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) && count < 5) {\n      count++;\n      // re-getting localIsLeader since we published to ZK first before setting localIsLeader value\n      localIsLeader = cloudDesc.isLeader();\n      try {\n        Thread.sleep(500);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","sourceOld":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(DISTRIB_FROM);\n    ClusterState clusterState = zkController.getClusterState();\n\n    DocCollection docCollection = clusterState.getCollection(collection);\n    Slice mySlice = docCollection.getSlice(cloudDesc.getShardId());\n    boolean localIsLeader = cloudDesc.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);\n      if (fromShard != null) {\n        if (mySlice.getState() == Slice.State.ACTIVE)  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = docCollection.getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n          SolrException solrExc = new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n          solrExc.setMetadata(\"cause\", \"LeaderChanged\");\n          throw solrExc;\n        }\n      }\n    }\n\n    int count = 0;\n    while (((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) && count < 5) {\n      count++;\n      // re-getting localIsLeader since we published to ZK first before setting localIsLeader value\n      localIsLeader = cloudDesc.isLeader();\n      try {\n        Thread.sleep(500);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6c228eadc8ab12c4b442521f5890283801a6cab5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["8a2f1187198fd8201881b815eea2fa3ba7b8ec5f","96adbab674ae121f8b6b3e10474070b4bd97a219"],"c4015cd39dff8d4dec562d909f9766debac53aa6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6c228eadc8ab12c4b442521f5890283801a6cab5"],"d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296":["6e36353d7461af8d2329a78a71457cf8e3c1e88f"],"6776b3c3ed554ace17893a807da5b7a0a6d364c8":["0beaed456aa3358e5e4a99ea2aea994ef6c81de3"],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296","04c8df3f10a676c3de5dbf390f17a2de2d45cacd"],"0beaed456aa3358e5e4a99ea2aea994ef6c81de3":["6c228eadc8ab12c4b442521f5890283801a6cab5"],"04c8df3f10a676c3de5dbf390f17a2de2d45cacd":["d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296"],"0c924d4069ef5a5bc479a493befe0121aada6896":["6e36353d7461af8d2329a78a71457cf8e3c1e88f","d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296"],"da888af1ab894358122a22229051215f58cf4d54":["bc841231667f1f315bae6799c068f9aad6543967"],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["8a2f1187198fd8201881b815eea2fa3ba7b8ec5f"],"8a2f1187198fd8201881b815eea2fa3ba7b8ec5f":["6776b3c3ed554ace17893a807da5b7a0a6d364c8"],"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["601f914e4448cab7640fecfb5d15f8f2e2af0bf6"],"601f914e4448cab7640fecfb5d15f8f2e2af0bf6":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"bc841231667f1f315bae6799c068f9aad6543967":["96adbab674ae121f8b6b3e10474070b4bd97a219"],"96adbab674ae121f8b6b3e10474070b4bd97a219":["849494cf2f3a96af5c8c84995108ddd8456fcd04"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["da888af1ab894358122a22229051215f58cf4d54","3333dd7044501b4f20231ea55ab64e688285d153"],"14d5815ecbef89580f5c48990bcd433f04f8563a":["3333dd7044501b4f20231ea55ab64e688285d153"],"9d70e774cb25c8a8d2c3e5e84200f235f9168d87":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"],"6e36353d7461af8d2329a78a71457cf8e3c1e88f":["14d5815ecbef89580f5c48990bcd433f04f8563a"],"3333dd7044501b4f20231ea55ab64e688285d153":["da888af1ab894358122a22229051215f58cf4d54"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9d70e774cb25c8a8d2c3e5e84200f235f9168d87"]},"commit2Childs":{"6c228eadc8ab12c4b442521f5890283801a6cab5":["c4015cd39dff8d4dec562d909f9766debac53aa6","0beaed456aa3358e5e4a99ea2aea994ef6c81de3"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"c4015cd39dff8d4dec562d909f9766debac53aa6":[],"d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296":["f7f901826e47f75f810d7aae24b0455d21ea1fe2","04c8df3f10a676c3de5dbf390f17a2de2d45cacd","0c924d4069ef5a5bc479a493befe0121aada6896"],"6776b3c3ed554ace17893a807da5b7a0a6d364c8":["8a2f1187198fd8201881b815eea2fa3ba7b8ec5f"],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["601f914e4448cab7640fecfb5d15f8f2e2af0bf6"],"0beaed456aa3358e5e4a99ea2aea994ef6c81de3":["6776b3c3ed554ace17893a807da5b7a0a6d364c8"],"04c8df3f10a676c3de5dbf390f17a2de2d45cacd":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"0c924d4069ef5a5bc479a493befe0121aada6896":[],"8a2f1187198fd8201881b815eea2fa3ba7b8ec5f":["37a0f60745e53927c4c876cfe5b5a58170f0646c","849494cf2f3a96af5c8c84995108ddd8456fcd04"],"da888af1ab894358122a22229051215f58cf4d54":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","3333dd7044501b4f20231ea55ab64e688285d153"],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["96adbab674ae121f8b6b3e10474070b4bd97a219"],"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["9d70e774cb25c8a8d2c3e5e84200f235f9168d87"],"601f914e4448cab7640fecfb5d15f8f2e2af0bf6":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"],"96adbab674ae121f8b6b3e10474070b4bd97a219":["37a0f60745e53927c4c876cfe5b5a58170f0646c","bc841231667f1f315bae6799c068f9aad6543967"],"bc841231667f1f315bae6799c068f9aad6543967":["da888af1ab894358122a22229051215f58cf4d54"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6c228eadc8ab12c4b442521f5890283801a6cab5","c4015cd39dff8d4dec562d909f9766debac53aa6"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"14d5815ecbef89580f5c48990bcd433f04f8563a":["6e36353d7461af8d2329a78a71457cf8e3c1e88f"],"6e36353d7461af8d2329a78a71457cf8e3c1e88f":["d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296","0c924d4069ef5a5bc479a493befe0121aada6896"],"3333dd7044501b4f20231ea55ab64e688285d153":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","14d5815ecbef89580f5c48990bcd433f04f8563a"],"9d70e774cb25c8a8d2c3e5e84200f235f9168d87":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","c4015cd39dff8d4dec562d909f9766debac53aa6","0c924d4069ef5a5bc479a493befe0121aada6896","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}