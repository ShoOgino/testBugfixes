{"path":"lucene/core/src/java/org/apache/lucene/search/SynonymQuery#mergeImpacts(ImpactsEnum[],float[]).mjava","commits":[{"id":"df25592b82060bc1c800e87bf019444bf0ddf9d4","date":1552296011,"type":1,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SynonymQuery#mergeImpacts(ImpactsEnum[],float[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SynonymQuery#mergeImpacts(ImpactsEnum[]).mjava","sourceNew":"  /**\n   * Merge impacts for multiple synonyms.\n   */\n  static ImpactsSource mergeImpacts(ImpactsEnum[] impactsEnums, float[] boosts) {\n    assert impactsEnums.length == boosts.length;\n    return new ImpactsSource() {\n\n      class SubIterator {\n        final Iterator<Impact> iterator;\n        int previousFreq;\n        Impact current;\n\n        SubIterator(Iterator<Impact> iterator) {\n          this.iterator = iterator;\n          this.current = iterator.next();\n        }\n\n        void next() {\n          previousFreq = current.freq;\n          if (iterator.hasNext() == false) {\n            current = null;\n          } else {\n            current = iterator.next();\n          }\n        }\n\n      }\n\n      @Override\n      public Impacts getImpacts() throws IOException {\n        final Impacts[] impacts = new Impacts[impactsEnums.length];\n        // Use the impacts that have the lower next boundary as a lead.\n        // It will decide on the number of levels and the block boundaries.\n        Impacts tmpLead = null;\n        for (int i = 0; i < impactsEnums.length; ++i) {\n          impacts[i] = impactsEnums[i].getImpacts();\n          if (tmpLead == null || impacts[i].getDocIdUpTo(0) < tmpLead.getDocIdUpTo(0)) {\n            tmpLead = impacts[i];\n          }\n        }\n        final Impacts lead = tmpLead;\n        return new Impacts() {\n\n          @Override\n          public int numLevels() {\n            // Delegate to the lead\n            return lead.numLevels();\n          }\n\n          @Override\n          public int getDocIdUpTo(int level) {\n            // Delegate to the lead\n            return lead.getDocIdUpTo(level);\n          }\n\n          /**\n           * Return the minimum level whose impacts are valid up to {@code docIdUpTo},\n           * or {@code -1} if there is no such level.\n           */\n          private int getLevel(Impacts impacts, int docIdUpTo) {\n            for (int level = 0, numLevels = impacts.numLevels(); level < numLevels; ++level) {\n              if (impacts.getDocIdUpTo(level) >= docIdUpTo) {\n                return level;\n              }\n            }\n            return -1;\n          }\n\n          @Override\n          public List<Impact> getImpacts(int level) {\n            final int docIdUpTo = getDocIdUpTo(level);\n\n            List<List<Impact>> toMerge = new ArrayList<>();\n\n            for (int i = 0; i < impactsEnums.length; ++i) {\n              if (impactsEnums[i].docID() <= docIdUpTo) {\n                int impactsLevel = getLevel(impacts[i], docIdUpTo);\n                if (impactsLevel == -1) {\n                  // One instance doesn't have impacts that cover up to docIdUpTo\n                  // Return impacts that trigger the maximum score\n                  return Collections.singletonList(new Impact(Integer.MAX_VALUE, 1L));\n                }\n                final List<Impact> impactList;\n                if (boosts[i] != 1f) {\n                  float boost = boosts[i];\n                  impactList = impacts[i].getImpacts(impactsLevel)\n                      .stream()\n                      .map(impact -> new Impact((int) Math.ceil(impact.freq * boost), impact.norm))\n                      .collect(Collectors.toList());\n                } else {\n                  impactList = impacts[i].getImpacts(impactsLevel);\n                }\n                toMerge.add(impactList);\n              }\n            }\n            assert toMerge.size() > 0; // otherwise it would mean the docID is > docIdUpTo, which is wrong\n\n            if (toMerge.size() == 1) {\n              // common if one synonym is common and the other one is rare\n              return toMerge.get(0);\n            }\n\n            PriorityQueue<SubIterator> pq = new PriorityQueue<SubIterator>(impacts.length) {\n              @Override\n              protected boolean lessThan(SubIterator a, SubIterator b) {\n                if (a.current == null) { // means iteration is finished\n                  return false;\n                }\n                if (b.current == null) {\n                  return true;\n                }\n                return Long.compareUnsigned(a.current.norm, b.current.norm) < 0;\n              }\n            };\n            for (List<Impact> impacts : toMerge) {\n              pq.add(new SubIterator(impacts.iterator()));\n            }\n\n            List<Impact> mergedImpacts = new ArrayList<>();\n\n            // Idea: merge impacts by norm. The tricky thing is that we need to\n            // consider norm values that are not in the impacts too. For\n            // instance if the list of impacts is [{freq=2,norm=10}, {freq=4,norm=12}],\n            // there might well be a document that has a freq of 2 and a length of 11,\n            // which was just not added to the list of impacts because {freq=2,norm=10}\n            // is more competitive. So the way it works is that we track the sum of\n            // the term freqs that we have seen so far in order to account for these\n            // implicit impacts.\n\n            long sumTf = 0;\n            SubIterator top = pq.top();\n            do {\n              final long norm = top.current.norm;\n              do {\n                sumTf += top.current.freq - top.previousFreq;\n                top.next();\n                top = pq.updateTop();\n              } while (top.current != null && top.current.norm == norm);\n\n              final int freqUpperBound = (int) Math.min(Integer.MAX_VALUE, sumTf);\n              if (mergedImpacts.isEmpty()) {\n                mergedImpacts.add(new Impact(freqUpperBound, norm));\n              } else {\n                Impact prevImpact = mergedImpacts.get(mergedImpacts.size() - 1);\n                assert Long.compareUnsigned(prevImpact.norm, norm) < 0;\n                if (freqUpperBound > prevImpact.freq) {\n                  mergedImpacts.add(new Impact(freqUpperBound, norm));\n                } // otherwise the previous impact is already more competitive\n              }\n            } while (top.current != null);\n\n            return mergedImpacts;\n          }\n        };\n      }\n\n      @Override\n      public void advanceShallow(int target) throws IOException {\n        for (ImpactsEnum impactsEnum : impactsEnums) {\n          if (impactsEnum.docID() < target) {\n            impactsEnum.advanceShallow(target);\n          }\n        }\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Merge impacts for multiple synonyms.\n   */\n  static ImpactsSource mergeImpacts(ImpactsEnum[] impactsEnums) {\n    return new ImpactsSource() {\n\n      class SubIterator {\n        final Iterator<Impact> iterator;\n        int previousFreq;\n        Impact current;\n\n        SubIterator(Iterator<Impact> iterator) {\n          this.iterator = iterator;\n          this.current = iterator.next();\n        }\n\n        void next() {\n          previousFreq = current.freq;\n          if (iterator.hasNext() == false) {\n            current = null;\n          } else {\n            current = iterator.next();\n          }\n        }\n\n      }\n\n      @Override\n      public Impacts getImpacts() throws IOException {\n        final Impacts[] impacts = new Impacts[impactsEnums.length];\n        // Use the impacts that have the lower next boundary as a lead.\n        // It will decide on the number of levels and the block boundaries.\n        Impacts tmpLead = null;\n        for (int i = 0; i < impactsEnums.length; ++i) {\n          impacts[i] = impactsEnums[i].getImpacts();\n          if (tmpLead == null || impacts[i].getDocIdUpTo(0) < tmpLead.getDocIdUpTo(0)) {\n            tmpLead = impacts[i];\n          }\n        }\n        final Impacts lead = tmpLead;\n        return new Impacts() {\n\n          @Override\n          public int numLevels() {\n            // Delegate to the lead\n            return lead.numLevels();\n          }\n\n          @Override\n          public int getDocIdUpTo(int level) {\n            // Delegate to the lead\n            return lead.getDocIdUpTo(level);\n          }\n\n          /**\n           * Return the minimum level whose impacts are valid up to {@code docIdUpTo},\n           * or {@code -1} if there is no such level.\n           */\n          private int getLevel(Impacts impacts, int docIdUpTo) {\n            for (int level = 0, numLevels = impacts.numLevels(); level < numLevels; ++level) {\n              if (impacts.getDocIdUpTo(level) >= docIdUpTo) {\n                return level;\n              }\n            }\n            return -1;\n          }\n\n          @Override\n          public List<Impact> getImpacts(int level) {\n            final int docIdUpTo = getDocIdUpTo(level);\n\n            List<List<Impact>> toMerge = new ArrayList<>();\n\n            for (int i = 0; i < impactsEnums.length; ++i) {\n              if (impactsEnums[i].docID() <= docIdUpTo) {\n                int impactsLevel = getLevel(impacts[i], docIdUpTo);\n                if (impactsLevel == -1) {\n                  // One instance doesn't have impacts that cover up to docIdUpTo\n                  // Return impacts that trigger the maximum score\n                  return Collections.singletonList(new Impact(Integer.MAX_VALUE, 1L));\n                }\n                toMerge.add(impacts[i].getImpacts(impactsLevel));\n              }\n            }\n            assert toMerge.size() > 0; // otherwise it would mean the docID is > docIdUpTo, which is wrong\n\n            if (toMerge.size() == 1) {\n              // common if one synonym is common and the other one is rare\n              return toMerge.get(0);\n            }\n\n            PriorityQueue<SubIterator> pq = new PriorityQueue<SubIterator>(impacts.length) {\n              @Override\n              protected boolean lessThan(SubIterator a, SubIterator b) {\n                if (a.current == null) { // means iteration is finished\n                  return false;\n                }\n                if (b.current == null) {\n                  return true;\n                }\n                return Long.compareUnsigned(a.current.norm, b.current.norm) < 0;\n              }\n            };\n            for (List<Impact> impacts : toMerge) {\n              pq.add(new SubIterator(impacts.iterator()));\n            }\n\n            List<Impact> mergedImpacts = new ArrayList<>();\n\n            // Idea: merge impacts by norm. The tricky thing is that we need to\n            // consider norm values that are not in the impacts too. For\n            // instance if the list of impacts is [{freq=2,norm=10}, {freq=4,norm=12}],\n            // there might well be a document that has a freq of 2 and a length of 11,\n            // which was just not added to the list of impacts because {freq=2,norm=10}\n            // is more competitive. So the way it works is that we track the sum of\n            // the term freqs that we have seen so far in order to account for these\n            // implicit impacts.\n\n            long sumTf = 0;\n            SubIterator top = pq.top();\n            do {\n              final long norm = top.current.norm;\n              do {\n                sumTf += top.current.freq - top.previousFreq;\n                top.next();\n                top = pq.updateTop();\n              } while (top.current != null && top.current.norm == norm);\n\n              final int freqUpperBound = (int) Math.min(Integer.MAX_VALUE, sumTf);\n              if (mergedImpacts.isEmpty()) {\n                mergedImpacts.add(new Impact(freqUpperBound, norm));\n              } else {\n                Impact prevImpact = mergedImpacts.get(mergedImpacts.size() - 1);\n                assert Long.compareUnsigned(prevImpact.norm, norm) < 0;\n                if (freqUpperBound > prevImpact.freq) {\n                  mergedImpacts.add(new Impact(freqUpperBound, norm));\n                } // otherwise the previous impact is already more competitive\n              }\n            } while (top.current != null);\n\n            return mergedImpacts;\n          }\n        };\n      }\n\n      @Override\n      public void advanceShallow(int target) throws IOException {\n        for (ImpactsEnum impactsEnum : impactsEnums) {\n          if (impactsEnum.docID() < target) {\n            impactsEnum.advanceShallow(target);\n          }\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"df25592b82060bc1c800e87bf019444bf0ddf9d4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["df25592b82060bc1c800e87bf019444bf0ddf9d4"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["df25592b82060bc1c800e87bf019444bf0ddf9d4"],"df25592b82060bc1c800e87bf019444bf0ddf9d4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}