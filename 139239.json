{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","sourceNew":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #close(boolean)}\n   * with <tt>false</tt>, which aborts all running merges,\n   * then any thread still running this method might hit a\n   * {@link MergePolicy.MergeAbortedException}.\n   */\n  public void forceMergeDeletes(boolean doWait)\n    throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    MergePolicy.MergeSpecification spec;\n\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos);\n      if (spec != null) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes\");\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge))\n              running = true;\n            Throwable t = merge.getException();\n            if (t != null) {\n              IOException ioe = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n              ioe.initCause(t);\n              throw ioe;\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #close(boolean)}\n   * with <tt>false</tt>, which aborts all running merges,\n   * then any thread still running this method might hit a\n   * {@link MergePolicy.MergeAbortedException}.\n   */\n  public void forceMergeDeletes(boolean doWait)\n    throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    MergePolicy.MergeSpecification spec;\n\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos);\n      if (spec != null) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes\");\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge))\n              running = true;\n            Throwable t = merge.getException();\n            if (t != null) {\n              IOException ioe = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n              ioe.initCause(t);\n              throw ioe;\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9d153abcf92dc5329d98571a8c3035df9bd80648","date":1337702630,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","sourceNew":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #close(boolean)}\n   * with <tt>false</tt>, which aborts all running merges,\n   * then any thread still running this method might hit a\n   * {@link MergePolicy.MergeAbortedException}.\n   */\n  public void forceMergeDeletes(boolean doWait)\n    throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    MergePolicy.MergeSpecification spec;\n\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos);\n      if (spec != null) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes\");\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              IOException ioe = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n              ioe.initCause(t);\n              throw ioe;\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #close(boolean)}\n   * with <tt>false</tt>, which aborts all running merges,\n   * then any thread still running this method might hit a\n   * {@link MergePolicy.MergeAbortedException}.\n   */\n  public void forceMergeDeletes(boolean doWait)\n    throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    MergePolicy.MergeSpecification spec;\n\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos);\n      if (spec != null) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes\");\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge))\n              running = true;\n            Throwable t = merge.getException();\n            if (t != null) {\n              IOException ioe = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n              ioe.initCause(t);\n              throw ioe;\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","sourceNew":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #close(boolean)}\n   * with <tt>false</tt>, which aborts all running merges,\n   * then any thread still running this method might hit a\n   * {@link MergePolicy.MergeAbortedException}.\n   */\n  public void forceMergeDeletes(boolean doWait)\n    throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    MergePolicy.MergeSpecification spec;\n\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos);\n      if (spec != null) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes\");\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              IOException ioe = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n              ioe.initCause(t);\n              throw ioe;\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #close(boolean)}\n   * with <tt>false</tt>, which aborts all running merges,\n   * then any thread still running this method might hit a\n   * {@link MergePolicy.MergeAbortedException}.\n   */\n  public void forceMergeDeletes(boolean doWait)\n    throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    MergePolicy.MergeSpecification spec;\n\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos);\n      if (spec != null) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes\");\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge))\n              running = true;\n            Throwable t = merge.getException();\n            if (t != null) {\n              IOException ioe = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n              ioe.initCause(t);\n              throw ioe;\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","sourceNew":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #close(boolean)}\n   * with <tt>false</tt>, which aborts all running merges,\n   * then any thread still running this method might hit a\n   * {@link MergePolicy.MergeAbortedException}.\n   */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    MergePolicy.MergeSpecification spec;\n\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos);\n      if (spec != null) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes\");\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              IOException ioe = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n              ioe.initCause(t);\n              throw ioe;\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #close(boolean)}\n   * with <tt>false</tt>, which aborts all running merges,\n   * then any thread still running this method might hit a\n   * {@link MergePolicy.MergeAbortedException}.\n   */\n  public void forceMergeDeletes(boolean doWait)\n    throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    MergePolicy.MergeSpecification spec;\n\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos);\n      if (spec != null) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes\");\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              IOException ioe = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n              ioe.initCause(t);\n              throw ioe;\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":["51cd38b90c674ebecc798654e3574d5790a9aced"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","sourceNew":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #close(boolean)}\n   * with <tt>false</tt>, which aborts all running merges,\n   * then any thread still running this method might hit a\n   * {@link MergePolicy.MergeAbortedException}.\n   */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    MergePolicy.MergeSpecification spec;\n\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos);\n      if (spec != null) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes\");\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              IOException ioe = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n              ioe.initCause(t);\n              throw ioe;\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #close(boolean)}\n   * with <tt>false</tt>, which aborts all running merges,\n   * then any thread still running this method might hit a\n   * {@link MergePolicy.MergeAbortedException}.\n   */\n  public void forceMergeDeletes(boolean doWait)\n    throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    MergePolicy.MergeSpecification spec;\n\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos);\n      if (spec != null) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes\");\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              IOException ioe = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n              ioe.initCause(t);\n              throw ioe;\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4853751884e55469b8cc1abab8fa0788eab240c9","date":1394565067,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","sourceNew":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #close(boolean)}\n   * with <tt>false</tt>, which aborts all running merges,\n   * then any thread still running this method might hit a\n   * {@link MergePolicy.MergeAbortedException}.\n   */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    MergePolicy.MergeSpecification spec;\n    boolean newMergesFound = false;\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this, MergeTrigger.EXPLICIT, newMergesFound);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes\");\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              IOException ioe = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n              ioe.initCause(t);\n              throw ioe;\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #close(boolean)}\n   * with <tt>false</tt>, which aborts all running merges,\n   * then any thread still running this method might hit a\n   * {@link MergePolicy.MergeAbortedException}.\n   */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    MergePolicy.MergeSpecification spec;\n\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos);\n      if (spec != null) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes\");\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              IOException ioe = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n              ioe.initCause(t);\n              throw ioe;\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","sourceNew":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #abortMerges}, which\n   * aborts all running merges, then any thread still\n   * running this method might hit a {@link\n   * MergePolicy.MergeAbortedException}. */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    MergePolicy.MergeSpecification spec;\n    boolean newMergesFound = false;\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this, MergeTrigger.EXPLICIT, newMergesFound);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes\");\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              IOException ioe = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n              ioe.initCause(t);\n              throw ioe;\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #close(boolean)}\n   * with <tt>false</tt>, which aborts all running merges,\n   * then any thread still running this method might hit a\n   * {@link MergePolicy.MergeAbortedException}.\n   */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    MergePolicy.MergeSpecification spec;\n    boolean newMergesFound = false;\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this, MergeTrigger.EXPLICIT, newMergesFound);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes\");\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              IOException ioe = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n              ioe.initCause(t);\n              throw ioe;\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":["15fbe8579d34349a8c79cbc5c933530dd5b6742a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3de2e9a536c4115b4f53f14b6ab496ba3af1840c","date":1400252137,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","sourceNew":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #abortMerges}, which\n   * aborts all running merges, then any thread still\n   * running this method might hit a {@link\n   * MergePolicy.MergeAbortedException}. */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    MergePolicy.MergeSpecification spec;\n    boolean newMergesFound = false;\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this, MergeTrigger.EXPLICIT, newMergesFound);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes\");\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            throw new IOException(\"background merge hit exception: \" + merge.segString(directory), merge.getException());\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #abortMerges}, which\n   * aborts all running merges, then any thread still\n   * running this method might hit a {@link\n   * MergePolicy.MergeAbortedException}. */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    MergePolicy.MergeSpecification spec;\n    boolean newMergesFound = false;\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this, MergeTrigger.EXPLICIT, newMergesFound);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes\");\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              IOException ioe = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n              ioe.initCause(t);\n              throw ioe;\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ccc69a67d5c846a04c7f71e28cb1914e3af895f3","date":1400252660,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","sourceNew":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #abortMerges}, which\n   * aborts all running merges, then any thread still\n   * running this method might hit a {@link\n   * MergePolicy.MergeAbortedException}. */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    MergePolicy.MergeSpecification spec;\n    boolean newMergesFound = false;\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this, MergeTrigger.EXPLICIT, newMergesFound);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes\");\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            throw new IOException(\"background merge hit exception: \" + merge.segString(directory), merge.getException());\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #abortMerges}, which\n   * aborts all running merges, then any thread still\n   * running this method might hit a {@link\n   * MergePolicy.MergeAbortedException}. */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    MergePolicy.MergeSpecification spec;\n    boolean newMergesFound = false;\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this, MergeTrigger.EXPLICIT, newMergesFound);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes\");\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              IOException ioe = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n              ioe.initCause(t);\n              throw ioe;\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a975ffe54e32c49d1e7dc52ce01093c62feb7032","date":1400254895,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","sourceNew":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #abortMerges}, which\n   * aborts all running merges, then any thread still\n   * running this method might hit a {@link\n   * MergePolicy.MergeAbortedException}. */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    MergePolicy.MergeSpecification spec;\n    boolean newMergesFound = false;\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this, MergeTrigger.EXPLICIT, newMergesFound);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes\");\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              throw new IOException(\"background merge hit exception: \" + merge.segString(directory), merge.getException());\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #abortMerges}, which\n   * aborts all running merges, then any thread still\n   * running this method might hit a {@link\n   * MergePolicy.MergeAbortedException}. */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    MergePolicy.MergeSpecification spec;\n    boolean newMergesFound = false;\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this, MergeTrigger.EXPLICIT, newMergesFound);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes\");\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            throw new IOException(\"background merge hit exception: \" + merge.segString(directory), merge.getException());\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0fed8f2bfff635cb127812e520aff4d017fb862f","date":1400255719,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","sourceNew":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #abortMerges}, which\n   * aborts all running merges, then any thread still\n   * running this method might hit a {@link\n   * MergePolicy.MergeAbortedException}. */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    MergePolicy.MergeSpecification spec;\n    boolean newMergesFound = false;\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this, MergeTrigger.EXPLICIT, newMergesFound);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes\");\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              throw new IOException(\"background merge hit exception: \" + merge.segString(directory), t);\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #abortMerges}, which\n   * aborts all running merges, then any thread still\n   * running this method might hit a {@link\n   * MergePolicy.MergeAbortedException}. */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    MergePolicy.MergeSpecification spec;\n    boolean newMergesFound = false;\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this, MergeTrigger.EXPLICIT, newMergesFound);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes\");\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              throw new IOException(\"background merge hit exception: \" + merge.segString(directory), merge.getException());\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","sourceNew":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #abortMerges}, which\n   * aborts all running merges, then any thread still\n   * running this method might hit a {@link\n   * MergePolicy.MergeAbortedException}. */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    MergePolicy.MergeSpecification spec;\n    boolean newMergesFound = false;\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this, MergeTrigger.EXPLICIT, newMergesFound);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes\");\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              throw new IOException(\"background merge hit exception: \" + merge.segString(directory), t);\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #abortMerges}, which\n   * aborts all running merges, then any thread still\n   * running this method might hit a {@link\n   * MergePolicy.MergeAbortedException}. */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    MergePolicy.MergeSpecification spec;\n    boolean newMergesFound = false;\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this, MergeTrigger.EXPLICIT, newMergesFound);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes\");\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              IOException ioe = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n              ioe.initCause(t);\n              throw ioe;\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"027bee21e09164c9ee230395405076d1e0034b30","date":1401521821,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","sourceNew":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #abortMerges}, which\n   * aborts all running merges, then any thread still\n   * running this method might hit a {@link\n   * MergePolicy.MergeAbortedException}. */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    MergePolicy.MergeSpecification spec;\n    boolean newMergesFound = false;\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos, this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this, MergeTrigger.EXPLICIT, newMergesFound);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes\");\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              throw new IOException(\"background merge hit exception: \" + merge.segString(directory), t);\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #abortMerges}, which\n   * aborts all running merges, then any thread still\n   * running this method might hit a {@link\n   * MergePolicy.MergeAbortedException}. */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    MergePolicy.MergeSpecification spec;\n    boolean newMergesFound = false;\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this, MergeTrigger.EXPLICIT, newMergesFound);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes\");\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              throw new IOException(\"background merge hit exception: \" + merge.segString(directory), t);\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ee59f646cf24586a449cad77391a60a3ac8d8959","date":1408015131,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","sourceNew":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #abortMerges}, which\n   * aborts all running merges, then any thread still\n   * running this method might hit a {@link\n   * MergePolicy.MergeAbortedException}. */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    MergePolicy.MergeSpecification spec;\n    boolean newMergesFound = false;\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos, this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this, MergeTrigger.EXPLICIT, newMergesFound);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes\");\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              throw new IOException(\"background merge hit exception: \" + merge.segString(directory), t);\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #abortMerges}, which\n   * aborts all running merges, then any thread still\n   * running this method might hit a {@link\n   * MergePolicy.MergeAbortedException}. */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    MergePolicy.MergeSpecification spec;\n    boolean newMergesFound = false;\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos, this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this, MergeTrigger.EXPLICIT, newMergesFound);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes\");\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              throw new IOException(\"background merge hit exception: \" + merge.segString(directory), t);\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"949847c0040cd70a68222d526cb0da7bf6cbb3c2","date":1410997182,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","sourceNew":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   * <p><b>NOTE</b>: if you call {@link #abortMerges}, which\n   * aborts all running merges, then any thread still\n   * running this method might hit a {@link\n   * MergePolicy.MergeAbortedException}. */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    MergePolicy.MergeSpecification spec;\n    boolean newMergesFound = false;\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos, this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this, MergeTrigger.EXPLICIT, newMergesFound);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (tragedy != null) {\n            throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete forceMergeDeletes\", tragedy);\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              throw new IOException(\"background merge hit exception: \" + merge.segString(directory), t);\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: if you call {@link #abortMerges}, which\n   * aborts all running merges, then any thread still\n   * running this method might hit a {@link\n   * MergePolicy.MergeAbortedException}. */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    MergePolicy.MergeSpecification spec;\n    boolean newMergesFound = false;\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos, this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this, MergeTrigger.EXPLICIT, newMergesFound);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes\");\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              throw new IOException(\"background merge hit exception: \" + merge.segString(directory), t);\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15fbe8579d34349a8c79cbc5c933530dd5b6742a","date":1418066328,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","sourceNew":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads. */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    MergePolicy.MergeSpecification spec;\n    boolean newMergesFound = false;\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos, this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this, MergeTrigger.EXPLICIT, newMergesFound);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (tragedy != null) {\n            throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete forceMergeDeletes\", tragedy);\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              throw new IOException(\"background merge hit exception: \" + merge.segString(directory), t);\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   * <p><b>NOTE</b>: if you call {@link #abortMerges}, which\n   * aborts all running merges, then any thread still\n   * running this method might hit a {@link\n   * MergePolicy.MergeAbortedException}. */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    MergePolicy.MergeSpecification spec;\n    boolean newMergesFound = false;\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos, this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this, MergeTrigger.EXPLICIT, newMergesFound);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (tragedy != null) {\n            throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete forceMergeDeletes\", tragedy);\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              throw new IOException(\"background merge hit exception: \" + merge.segString(directory), t);\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a","e9665d17707cc21b1db995118ff36129723139ab"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5faf65b6692f15cca0f87bf8666c87899afc619f","date":1420468108,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","sourceNew":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads. */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    MergePolicy.MergeSpecification spec;\n    boolean newMergesFound = false;\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos, this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this, MergeTrigger.EXPLICIT, newMergesFound);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (tragedy != null) {\n            throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete forceMergeDeletes\", tragedy);\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              throw new IOException(\"background merge hit exception: \" + merge.segString(), t);\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads. */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    MergePolicy.MergeSpecification spec;\n    boolean newMergesFound = false;\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos, this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this, MergeTrigger.EXPLICIT, newMergesFound);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (tragedy != null) {\n            throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete forceMergeDeletes\", tragedy);\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              throw new IOException(\"background merge hit exception: \" + merge.segString(directory), t);\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"845b760a99e5f369fcd0a5d723a87b8def6a3f56","date":1521117993,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","sourceNew":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads. */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    MergePolicy.MergeSpecification spec;\n    boolean newMergesFound = false;\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos, this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this, MergeTrigger.EXPLICIT, newMergesFound);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (tragedy.get() != null) {\n            throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete forceMergeDeletes\", tragedy.get());\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              throw new IOException(\"background merge hit exception: \" + merge.segString(), t);\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads. */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    MergePolicy.MergeSpecification spec;\n    boolean newMergesFound = false;\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos, this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this, MergeTrigger.EXPLICIT, newMergesFound);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (tragedy != null) {\n            throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete forceMergeDeletes\", tragedy);\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              throw new IOException(\"background merge hit exception: \" + merge.segString(), t);\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2178aefcd4690bd53785e9673e2c918cdb64165","date":1587583605,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","sourceNew":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads. */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    MergePolicy.MergeSpecification spec;\n    boolean newMergesFound = false;\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos, this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this, MergeTrigger.EXPLICIT);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (tragedy.get() != null) {\n            throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete forceMergeDeletes\", tragedy.get());\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              throw new IOException(\"background merge hit exception: \" + merge.segString(), t);\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads. */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    MergePolicy.MergeSpecification spec;\n    boolean newMergesFound = false;\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos, this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this, MergeTrigger.EXPLICIT, newMergesFound);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (tragedy.get() != null) {\n            throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete forceMergeDeletes\", tragedy.get());\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              throw new IOException(\"background merge hit exception: \" + merge.segString(), t);\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89697e7abc9807639c384eecf5a2a6eef1080426","date":1587733375,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMergeDeletes(boolean).mjava","sourceNew":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads. */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    MergePolicy.MergeSpecification spec;\n    boolean newMergesFound = false;\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos, this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(mergeSource, MergeTrigger.EXPLICIT);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (tragedy.get() != null) {\n            throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete forceMergeDeletes\", tragedy.get());\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              throw new IOException(\"background merge hit exception: \" + merge.segString(), t);\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMergeDeletes()}, except you can\n   *  specify whether the call should block until the\n   *  operation completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads. */\n  public void forceMergeDeletes(boolean doWait)\n    throws IOException {\n    ensureOpen();\n\n    flush(true, true);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMergeDeletes: index now \" + segString());\n    }\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    MergePolicy.MergeSpecification spec;\n    boolean newMergesFound = false;\n    synchronized(this) {\n      spec = mergePolicy.findForcedDeletesMerges(segmentInfos, this);\n      newMergesFound = spec != null;\n      if (newMergesFound) {\n        final int numMerges = spec.merges.size();\n        for(int i=0;i<numMerges;i++)\n          registerMerge(spec.merges.get(i));\n      }\n    }\n\n    mergeScheduler.merge(this, MergeTrigger.EXPLICIT);\n\n    if (spec != null && doWait) {\n      final int numMerges = spec.merges.size();\n      synchronized(this) {\n        boolean running = true;\n        while(running) {\n\n          if (tragedy.get() != null) {\n            throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete forceMergeDeletes\", tragedy.get());\n          }\n\n          // Check each merge that MergePolicy asked us to\n          // do, to see if any of them are still running and\n          // if any of them have hit an exception.\n          running = false;\n          for(int i=0;i<numMerges;i++) {\n            final MergePolicy.OneMerge merge = spec.merges.get(i);\n            if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {\n              running = true;\n            }\n            Throwable t = merge.getException();\n            if (t != null) {\n              throw new IOException(\"background merge hit exception: \" + merge.segString(), t);\n            }\n          }\n\n          // If any of our merges are still running, wait:\n          if (running)\n            doWait();\n        }\n      }\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4853751884e55469b8cc1abab8fa0788eab240c9":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"ee59f646cf24586a449cad77391a60a3ac8d8959":["027bee21e09164c9ee230395405076d1e0034b30"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9d153abcf92dc5329d98571a8c3035df9bd80648":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"56572ec06f1407c066d6b7399413178b33176cd8":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a","0fed8f2bfff635cb127812e520aff4d017fb862f"],"a975ffe54e32c49d1e7dc52ce01093c62feb7032":["3de2e9a536c4115b4f53f14b6ab496ba3af1840c"],"ccc69a67d5c846a04c7f71e28cb1914e3af895f3":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a","3de2e9a536c4115b4f53f14b6ab496ba3af1840c"],"89697e7abc9807639c384eecf5a2a6eef1080426":["d2178aefcd4690bd53785e9673e2c918cdb64165"],"d2178aefcd4690bd53785e9673e2c918cdb64165":["845b760a99e5f369fcd0a5d723a87b8def6a3f56"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","9d153abcf92dc5329d98571a8c3035df9bd80648"],"0fed8f2bfff635cb127812e520aff4d017fb862f":["a975ffe54e32c49d1e7dc52ce01093c62feb7032"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5faf65b6692f15cca0f87bf8666c87899afc619f":["15fbe8579d34349a8c79cbc5c933530dd5b6742a"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["4853751884e55469b8cc1abab8fa0788eab240c9"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"949847c0040cd70a68222d526cb0da7bf6cbb3c2":["ee59f646cf24586a449cad77391a60a3ac8d8959"],"027bee21e09164c9ee230395405076d1e0034b30":["0fed8f2bfff635cb127812e520aff4d017fb862f"],"3de2e9a536c4115b4f53f14b6ab496ba3af1840c":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"15fbe8579d34349a8c79cbc5c933530dd5b6742a":["949847c0040cd70a68222d526cb0da7bf6cbb3c2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["89697e7abc9807639c384eecf5a2a6eef1080426"]},"commit2Childs":{"4853751884e55469b8cc1abab8fa0788eab240c9":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["d2178aefcd4690bd53785e9673e2c918cdb64165"],"ee59f646cf24586a449cad77391a60a3ac8d8959":["949847c0040cd70a68222d526cb0da7bf6cbb3c2"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["9d153abcf92dc5329d98571a8c3035df9bd80648","615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"9d153abcf92dc5329d98571a8c3035df9bd80648":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"56572ec06f1407c066d6b7399413178b33176cd8":[],"a975ffe54e32c49d1e7dc52ce01093c62feb7032":["0fed8f2bfff635cb127812e520aff4d017fb862f"],"ccc69a67d5c846a04c7f71e28cb1914e3af895f3":[],"89697e7abc9807639c384eecf5a2a6eef1080426":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d2178aefcd4690bd53785e9673e2c918cdb64165":["89697e7abc9807639c384eecf5a2a6eef1080426"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["fe33227f6805edab2036cbb80645cc4e2d1fa424","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"0fed8f2bfff635cb127812e520aff4d017fb862f":["56572ec06f1407c066d6b7399413178b33176cd8","027bee21e09164c9ee230395405076d1e0034b30"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["845b760a99e5f369fcd0a5d723a87b8def6a3f56"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["56572ec06f1407c066d6b7399413178b33176cd8","ccc69a67d5c846a04c7f71e28cb1914e3af895f3","3de2e9a536c4115b4f53f14b6ab496ba3af1840c"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["4853751884e55469b8cc1abab8fa0788eab240c9","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"949847c0040cd70a68222d526cb0da7bf6cbb3c2":["15fbe8579d34349a8c79cbc5c933530dd5b6742a"],"027bee21e09164c9ee230395405076d1e0034b30":["ee59f646cf24586a449cad77391a60a3ac8d8959"],"3de2e9a536c4115b4f53f14b6ab496ba3af1840c":["a975ffe54e32c49d1e7dc52ce01093c62feb7032","ccc69a67d5c846a04c7f71e28cb1914e3af895f3"],"15fbe8579d34349a8c79cbc5c933530dd5b6742a":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["56572ec06f1407c066d6b7399413178b33176cd8","ccc69a67d5c846a04c7f71e28cb1914e3af895f3","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}