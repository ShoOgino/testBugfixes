{"path":"src/java/org/apache/lucene/index/IndexWriter#abort().mjava","commits":[{"id":"8b6187898fc4413ccd18229711786550a280383c","date":1173776782,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#abort().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any of the changes that have occurred since it was\n   * opened. This removes any temporary files that had been\n   * created, after which the state of the index will be the\n   * same as it was when this writer was first opened.  This\n   * can only be called when this IndexWriter was opened\n   * with <code>autoCommit=false</code>.\n   * @throws IllegalStateException if this is called when\n   *  the writer was opened with <code>autoCommit=true</code>.\n   * @throws IOException if there is a low-level IO error\n   */\n  public void abort() throws IOException {\n    if (!autoCommit) {\n\n      // Keep the same segmentInfos instance but replace all\n      // of its SegmentInfo instances.  This is so the next\n      // attempt to commit using this instance of IndexWriter\n      // will always write to a new generation (\"write once\").\n      segmentInfos.clear();\n      segmentInfos.addAll(rollbackSegmentInfos);\n\n      // Ask deleter to locate unreferenced files & remove\n      // them:\n      deleter.checkpoint(segmentInfos, false);\n      deleter.refresh();\n\n      ramSegmentInfos = new SegmentInfos();\n      bufferedDeleteTerms.clear();\n      numBufferedDeleteTerms = 0;\n\n      commitPending = false;\n      close();\n\n    } else {\n      throw new IllegalStateException(\"abort() can only be called when IndexWriter was opened with autoCommit=false\");\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["fde68de507dbf344495d7b5e8052866fe5f254ab"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"328c1568e471f0c6eaa49ec00334ca59e573710f","date":1173897963,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#abort().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#abort().mjava","sourceNew":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any of the changes that have occurred since it was\n   * opened. This removes any temporary files that had been\n   * created, after which the state of the index will be the\n   * same as it was when this writer was first opened.  This\n   * can only be called when this IndexWriter was opened\n   * with <code>autoCommit=false</code>.\n   * @throws IllegalStateException if this is called when\n   *  the writer was opened with <code>autoCommit=true</code>.\n   * @throws IOException if there is a low-level IO error\n   */\n  public void abort() throws IOException {\n    ensureOpen();\n    if (!autoCommit) {\n\n      // Keep the same segmentInfos instance but replace all\n      // of its SegmentInfo instances.  This is so the next\n      // attempt to commit using this instance of IndexWriter\n      // will always write to a new generation (\"write once\").\n      segmentInfos.clear();\n      segmentInfos.addAll(rollbackSegmentInfos);\n\n      // Ask deleter to locate unreferenced files & remove\n      // them:\n      deleter.checkpoint(segmentInfos, false);\n      deleter.refresh();\n\n      ramSegmentInfos = new SegmentInfos();\n      bufferedDeleteTerms.clear();\n      numBufferedDeleteTerms = 0;\n\n      commitPending = false;\n      close();\n\n    } else {\n      throw new IllegalStateException(\"abort() can only be called when IndexWriter was opened with autoCommit=false\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any of the changes that have occurred since it was\n   * opened. This removes any temporary files that had been\n   * created, after which the state of the index will be the\n   * same as it was when this writer was first opened.  This\n   * can only be called when this IndexWriter was opened\n   * with <code>autoCommit=false</code>.\n   * @throws IllegalStateException if this is called when\n   *  the writer was opened with <code>autoCommit=true</code>.\n   * @throws IOException if there is a low-level IO error\n   */\n  public void abort() throws IOException {\n    if (!autoCommit) {\n\n      // Keep the same segmentInfos instance but replace all\n      // of its SegmentInfo instances.  This is so the next\n      // attempt to commit using this instance of IndexWriter\n      // will always write to a new generation (\"write once\").\n      segmentInfos.clear();\n      segmentInfos.addAll(rollbackSegmentInfos);\n\n      // Ask deleter to locate unreferenced files & remove\n      // them:\n      deleter.checkpoint(segmentInfos, false);\n      deleter.refresh();\n\n      ramSegmentInfos = new SegmentInfos();\n      bufferedDeleteTerms.clear();\n      numBufferedDeleteTerms = 0;\n\n      commitPending = false;\n      close();\n\n    } else {\n      throw new IllegalStateException(\"abort() can only be called when IndexWriter was opened with autoCommit=false\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"45224778ec37da27339da4de043475c91e28a536","date":1173997377,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#abort().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#abort().mjava","sourceNew":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any of the changes that have occurred since it was\n   * opened. This removes any temporary files that had been\n   * created, after which the state of the index will be the\n   * same as it was when this writer was first opened.  This\n   * can only be called when this IndexWriter was opened\n   * with <code>autoCommit=false</code>.\n   * @throws IllegalStateException if this is called when\n   *  the writer was opened with <code>autoCommit=true</code>.\n   * @throws IOException if there is a low-level IO error\n   */\n  public synchronized void abort() throws IOException {\n    ensureOpen();\n    if (!autoCommit) {\n\n      // Keep the same segmentInfos instance but replace all\n      // of its SegmentInfo instances.  This is so the next\n      // attempt to commit using this instance of IndexWriter\n      // will always write to a new generation (\"write once\").\n      segmentInfos.clear();\n      segmentInfos.addAll(rollbackSegmentInfos);\n\n      // Ask deleter to locate unreferenced files & remove\n      // them:\n      deleter.checkpoint(segmentInfos, false);\n      deleter.refresh();\n\n      ramSegmentInfos = new SegmentInfos();\n      bufferedDeleteTerms.clear();\n      numBufferedDeleteTerms = 0;\n\n      commitPending = false;\n      close();\n\n    } else {\n      throw new IllegalStateException(\"abort() can only be called when IndexWriter was opened with autoCommit=false\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any of the changes that have occurred since it was\n   * opened. This removes any temporary files that had been\n   * created, after which the state of the index will be the\n   * same as it was when this writer was first opened.  This\n   * can only be called when this IndexWriter was opened\n   * with <code>autoCommit=false</code>.\n   * @throws IllegalStateException if this is called when\n   *  the writer was opened with <code>autoCommit=true</code>.\n   * @throws IOException if there is a low-level IO error\n   */\n  public void abort() throws IOException {\n    ensureOpen();\n    if (!autoCommit) {\n\n      // Keep the same segmentInfos instance but replace all\n      // of its SegmentInfo instances.  This is so the next\n      // attempt to commit using this instance of IndexWriter\n      // will always write to a new generation (\"write once\").\n      segmentInfos.clear();\n      segmentInfos.addAll(rollbackSegmentInfos);\n\n      // Ask deleter to locate unreferenced files & remove\n      // them:\n      deleter.checkpoint(segmentInfos, false);\n      deleter.refresh();\n\n      ramSegmentInfos = new SegmentInfos();\n      bufferedDeleteTerms.clear();\n      numBufferedDeleteTerms = 0;\n\n      commitPending = false;\n      close();\n\n    } else {\n      throw new IllegalStateException(\"abort() can only be called when IndexWriter was opened with autoCommit=false\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4350b17bd363cd13a95171b8df1ca62ea4c3e71c","date":1183562198,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#abort().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#abort().mjava","sourceNew":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any of the changes that have occurred since it was\n   * opened. This removes any temporary files that had been\n   * created, after which the state of the index will be the\n   * same as it was when this writer was first opened.  This\n   * can only be called when this IndexWriter was opened\n   * with <code>autoCommit=false</code>.\n   * @throws IllegalStateException if this is called when\n   *  the writer was opened with <code>autoCommit=true</code>.\n   * @throws IOException if there is a low-level IO error\n   */\n  public synchronized void abort() throws IOException {\n    ensureOpen();\n    if (!autoCommit) {\n\n      // Keep the same segmentInfos instance but replace all\n      // of its SegmentInfo instances.  This is so the next\n      // attempt to commit using this instance of IndexWriter\n      // will always write to a new generation (\"write once\").\n      segmentInfos.clear();\n      segmentInfos.addAll(rollbackSegmentInfos);\n\n      docWriter.abort();\n\n      // Ask deleter to locate unreferenced files & remove\n      // them:\n      deleter.checkpoint(segmentInfos, false);\n      deleter.refresh();\n\n      bufferedDeleteTerms.clear();\n      numBufferedDeleteTerms = 0;\n\n      commitPending = false;\n      docWriter.abort();\n      close();\n\n    } else {\n      throw new IllegalStateException(\"abort() can only be called when IndexWriter was opened with autoCommit=false\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any of the changes that have occurred since it was\n   * opened. This removes any temporary files that had been\n   * created, after which the state of the index will be the\n   * same as it was when this writer was first opened.  This\n   * can only be called when this IndexWriter was opened\n   * with <code>autoCommit=false</code>.\n   * @throws IllegalStateException if this is called when\n   *  the writer was opened with <code>autoCommit=true</code>.\n   * @throws IOException if there is a low-level IO error\n   */\n  public synchronized void abort() throws IOException {\n    ensureOpen();\n    if (!autoCommit) {\n\n      // Keep the same segmentInfos instance but replace all\n      // of its SegmentInfo instances.  This is so the next\n      // attempt to commit using this instance of IndexWriter\n      // will always write to a new generation (\"write once\").\n      segmentInfos.clear();\n      segmentInfos.addAll(rollbackSegmentInfos);\n\n      // Ask deleter to locate unreferenced files & remove\n      // them:\n      deleter.checkpoint(segmentInfos, false);\n      deleter.refresh();\n\n      ramSegmentInfos = new SegmentInfos();\n      bufferedDeleteTerms.clear();\n      numBufferedDeleteTerms = 0;\n\n      commitPending = false;\n      close();\n\n    } else {\n      throw new IllegalStateException(\"abort() can only be called when IndexWriter was opened with autoCommit=false\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fde68de507dbf344495d7b5e8052866fe5f254ab","date":1189434831,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#abort().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#abort().mjava","sourceNew":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any of the changes that have occurred since it was\n   * opened. This removes any temporary files that had been\n   * created, after which the state of the index will be the\n   * same as it was when this writer was first opened.  This\n   * can only be called when this IndexWriter was opened\n   * with <code>autoCommit=false</code>.\n   * @throws IllegalStateException if this is called when\n   *  the writer was opened with <code>autoCommit=true</code>.\n   * @throws IOException if there is a low-level IO error\n   */\n  public synchronized void abort() throws IOException {\n    ensureOpen();\n    if (!autoCommit) {\n\n      // Keep the same segmentInfos instance but replace all\n      // of its SegmentInfo instances.  This is so the next\n      // attempt to commit using this instance of IndexWriter\n      // will always write to a new generation (\"write once\").\n      segmentInfos.clear();\n      segmentInfos.addAll(rollbackSegmentInfos);\n\n      docWriter.abort();\n\n      // Ask deleter to locate unreferenced files & remove\n      // them:\n      deleter.checkpoint(segmentInfos, false);\n      deleter.refresh();\n\n      commitPending = false;\n      docWriter.abort();\n      close();\n\n    } else {\n      throw new IllegalStateException(\"abort() can only be called when IndexWriter was opened with autoCommit=false\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any of the changes that have occurred since it was\n   * opened. This removes any temporary files that had been\n   * created, after which the state of the index will be the\n   * same as it was when this writer was first opened.  This\n   * can only be called when this IndexWriter was opened\n   * with <code>autoCommit=false</code>.\n   * @throws IllegalStateException if this is called when\n   *  the writer was opened with <code>autoCommit=true</code>.\n   * @throws IOException if there is a low-level IO error\n   */\n  public synchronized void abort() throws IOException {\n    ensureOpen();\n    if (!autoCommit) {\n\n      // Keep the same segmentInfos instance but replace all\n      // of its SegmentInfo instances.  This is so the next\n      // attempt to commit using this instance of IndexWriter\n      // will always write to a new generation (\"write once\").\n      segmentInfos.clear();\n      segmentInfos.addAll(rollbackSegmentInfos);\n\n      docWriter.abort();\n\n      // Ask deleter to locate unreferenced files & remove\n      // them:\n      deleter.checkpoint(segmentInfos, false);\n      deleter.refresh();\n\n      bufferedDeleteTerms.clear();\n      numBufferedDeleteTerms = 0;\n\n      commitPending = false;\n      docWriter.abort();\n      close();\n\n    } else {\n      throw new IllegalStateException(\"abort() can only be called when IndexWriter was opened with autoCommit=false\");\n    }\n  }\n\n","bugFix":["8b6187898fc4413ccd18229711786550a280383c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b1405362241b561f5590ff4a87d5d6e173bcd9cf","date":1190107634,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#abort().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#abort().mjava","sourceNew":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any of the changes that have occurred since it was\n   * opened. This removes any temporary files that had been\n   * created, after which the state of the index will be the\n   * same as it was when this writer was first opened.  This\n   * can only be called when this IndexWriter was opened\n   * with <code>autoCommit=false</code>.\n   * @throws IllegalStateException if this is called when\n   *  the writer was opened with <code>autoCommit=true</code>.\n   * @throws IOException if there is a low-level IO error\n   */\n  public void abort() throws IOException {\n    ensureOpen();\n    if (autoCommit)\n      throw new IllegalStateException(\"abort() can only be called when IndexWriter was opened with autoCommit=false\");\n\n    boolean doClose;\n    synchronized(this) {\n      // Ensure that only one thread actually gets to do the closing:\n      if (!closing) {\n        doClose = true;\n        closing = true;\n      } else\n        doClose = false;\n    }\n\n    if (doClose) {\n\n      finishMerges(false);\n\n      // Must pre-close these two, in case they set\n      // commitPending=true, so that we can then set it to\n      // false before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      synchronized(this) {\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort();\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n        finishMerges(false);\n      }\n\n      commitPending = false;\n      closeInternal(false);\n    } else\n      waitForClose();\n  }\n\n","sourceOld":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any of the changes that have occurred since it was\n   * opened. This removes any temporary files that had been\n   * created, after which the state of the index will be the\n   * same as it was when this writer was first opened.  This\n   * can only be called when this IndexWriter was opened\n   * with <code>autoCommit=false</code>.\n   * @throws IllegalStateException if this is called when\n   *  the writer was opened with <code>autoCommit=true</code>.\n   * @throws IOException if there is a low-level IO error\n   */\n  public synchronized void abort() throws IOException {\n    ensureOpen();\n    if (!autoCommit) {\n\n      // Keep the same segmentInfos instance but replace all\n      // of its SegmentInfo instances.  This is so the next\n      // attempt to commit using this instance of IndexWriter\n      // will always write to a new generation (\"write once\").\n      segmentInfos.clear();\n      segmentInfos.addAll(rollbackSegmentInfos);\n\n      docWriter.abort();\n\n      // Ask deleter to locate unreferenced files & remove\n      // them:\n      deleter.checkpoint(segmentInfos, false);\n      deleter.refresh();\n\n      commitPending = false;\n      docWriter.abort();\n      close();\n\n    } else {\n      throw new IllegalStateException(\"abort() can only be called when IndexWriter was opened with autoCommit=false\");\n    }\n  }\n\n","bugFix":null,"bugIntro":["83bbb041887bbef07b8a98d08a0e1713ce137039","346d5897e4c4e77ed5dbd31f7730ff30973d5971"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"346d5897e4c4e77ed5dbd31f7730ff30973d5971","date":1198317988,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#abort().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#abort().mjava","sourceNew":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any of the changes that have occurred since it was\n   * opened. This removes any temporary files that had been\n   * created, after which the state of the index will be the\n   * same as it was when this writer was first opened.  This\n   * can only be called when this IndexWriter was opened\n   * with <code>autoCommit=false</code>.\n   * @throws IllegalStateException if this is called when\n   *  the writer was opened with <code>autoCommit=true</code>.\n   * @throws IOException if there is a low-level IO error\n   */\n  public void abort() throws IOException {\n    ensureOpen();\n    if (autoCommit)\n      throw new IllegalStateException(\"abort() can only be called when IndexWriter was opened with autoCommit=false\");\n\n    boolean doClose;\n    synchronized(this) {\n      // Ensure that only one thread actually gets to do the closing:\n      if (!closing) {\n        doClose = true;\n        closing = true;\n      } else\n        doClose = false;\n    }\n\n    if (doClose) {\n\n      finishMerges(false);\n\n      // Must pre-close these two, in case they set\n      // commitPending=true, so that we can then set it to\n      // false before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      synchronized(this) {\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort();\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      commitPending = false;\n      closeInternal(false);\n    } else\n      waitForClose();\n  }\n\n","sourceOld":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any of the changes that have occurred since it was\n   * opened. This removes any temporary files that had been\n   * created, after which the state of the index will be the\n   * same as it was when this writer was first opened.  This\n   * can only be called when this IndexWriter was opened\n   * with <code>autoCommit=false</code>.\n   * @throws IllegalStateException if this is called when\n   *  the writer was opened with <code>autoCommit=true</code>.\n   * @throws IOException if there is a low-level IO error\n   */\n  public void abort() throws IOException {\n    ensureOpen();\n    if (autoCommit)\n      throw new IllegalStateException(\"abort() can only be called when IndexWriter was opened with autoCommit=false\");\n\n    boolean doClose;\n    synchronized(this) {\n      // Ensure that only one thread actually gets to do the closing:\n      if (!closing) {\n        doClose = true;\n        closing = true;\n      } else\n        doClose = false;\n    }\n\n    if (doClose) {\n\n      finishMerges(false);\n\n      // Must pre-close these two, in case they set\n      // commitPending=true, so that we can then set it to\n      // false before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      synchronized(this) {\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort();\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n        finishMerges(false);\n      }\n\n      commitPending = false;\n      closeInternal(false);\n    } else\n      waitForClose();\n  }\n\n","bugFix":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"83bbb041887bbef07b8a98d08a0e1713ce137039","date":1200330381,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#abort().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#abort().mjava","sourceNew":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any of the changes that have occurred since it was\n   * opened. This removes any temporary files that had been\n   * created, after which the state of the index will be the\n   * same as it was when this writer was first opened.  This\n   * can only be called when this IndexWriter was opened\n   * with <code>autoCommit=false</code>.\n   * @throws IllegalStateException if this is called when\n   *  the writer was opened with <code>autoCommit=true</code>.\n   * @throws IOException if there is a low-level IO error\n   */\n  public void abort() throws IOException {\n    ensureOpen();\n    if (autoCommit)\n      throw new IllegalStateException(\"abort() can only be called when IndexWriter was opened with autoCommit=false\");\n\n    boolean doClose;\n    synchronized(this) {\n      // Ensure that only one thread actually gets to do the closing:\n      if (!closing) {\n        doClose = true;\n        closing = true;\n      } else\n        doClose = false;\n    }\n\n    if (doClose) {\n\n      finishMerges(false);\n\n      // Must pre-close these two, in case they set\n      // commitPending=true, so that we can then set it to\n      // false before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      synchronized(this) {\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort(null);\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      commitPending = false;\n      closeInternal(false);\n    } else\n      waitForClose();\n  }\n\n","sourceOld":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any of the changes that have occurred since it was\n   * opened. This removes any temporary files that had been\n   * created, after which the state of the index will be the\n   * same as it was when this writer was first opened.  This\n   * can only be called when this IndexWriter was opened\n   * with <code>autoCommit=false</code>.\n   * @throws IllegalStateException if this is called when\n   *  the writer was opened with <code>autoCommit=true</code>.\n   * @throws IOException if there is a low-level IO error\n   */\n  public void abort() throws IOException {\n    ensureOpen();\n    if (autoCommit)\n      throw new IllegalStateException(\"abort() can only be called when IndexWriter was opened with autoCommit=false\");\n\n    boolean doClose;\n    synchronized(this) {\n      // Ensure that only one thread actually gets to do the closing:\n      if (!closing) {\n        doClose = true;\n        closing = true;\n      } else\n        doClose = false;\n    }\n\n    if (doClose) {\n\n      finishMerges(false);\n\n      // Must pre-close these two, in case they set\n      // commitPending=true, so that we can then set it to\n      // false before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      synchronized(this) {\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort();\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      commitPending = false;\n      closeInternal(false);\n    } else\n      waitForClose();\n  }\n\n","bugFix":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be","date":1204801324,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#abort().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#abort().mjava","sourceNew":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any of the changes that have occurred since it was\n   * opened. This removes any temporary files that had been\n   * created, after which the state of the index will be the\n   * same as it was when this writer was first opened.  This\n   * can only be called when this IndexWriter was opened\n   * with <code>autoCommit=false</code>.\n   * @throws IllegalStateException if this is called when\n   *  the writer was opened with <code>autoCommit=true</code>.\n   * @throws IOException if there is a low-level IO error\n   */\n  public void abort() throws IOException {\n    ensureOpen();\n    if (autoCommit)\n      throw new IllegalStateException(\"abort() can only be called when IndexWriter was opened with autoCommit=false\");\n\n    boolean doClose;\n    synchronized(this) {\n      // Ensure that only one thread actually gets to do the closing:\n      if (!closing) {\n        doClose = true;\n        closing = true;\n      } else\n        doClose = false;\n    }\n\n    if (doClose) {\n\n      finishMerges(false);\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      synchronized(this) {\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort(null);\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      lastCommitChangeCount = changeCount;\n      closeInternal(false);\n    } else\n      waitForClose();\n  }\n\n","sourceOld":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any of the changes that have occurred since it was\n   * opened. This removes any temporary files that had been\n   * created, after which the state of the index will be the\n   * same as it was when this writer was first opened.  This\n   * can only be called when this IndexWriter was opened\n   * with <code>autoCommit=false</code>.\n   * @throws IllegalStateException if this is called when\n   *  the writer was opened with <code>autoCommit=true</code>.\n   * @throws IOException if there is a low-level IO error\n   */\n  public void abort() throws IOException {\n    ensureOpen();\n    if (autoCommit)\n      throw new IllegalStateException(\"abort() can only be called when IndexWriter was opened with autoCommit=false\");\n\n    boolean doClose;\n    synchronized(this) {\n      // Ensure that only one thread actually gets to do the closing:\n      if (!closing) {\n        doClose = true;\n        closing = true;\n      } else\n        doClose = false;\n    }\n\n    if (doClose) {\n\n      finishMerges(false);\n\n      // Must pre-close these two, in case they set\n      // commitPending=true, so that we can then set it to\n      // false before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      synchronized(this) {\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort(null);\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      commitPending = false;\n      closeInternal(false);\n    } else\n      waitForClose();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"455aeff4fef915340c5b19d71d5e147034e83093","date":1210099270,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#abort().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#abort().mjava","sourceNew":"  /**\n   * @deprecated Please use {@link #rollback} instead.\n   */\n  public void abort() throws IOException {\n    rollback();\n  }\n\n","sourceOld":"  /**\n   * Close the <code>IndexWriter</code> without committing\n   * any of the changes that have occurred since it was\n   * opened. This removes any temporary files that had been\n   * created, after which the state of the index will be the\n   * same as it was when this writer was first opened.  This\n   * can only be called when this IndexWriter was opened\n   * with <code>autoCommit=false</code>.\n   * @throws IllegalStateException if this is called when\n   *  the writer was opened with <code>autoCommit=true</code>.\n   * @throws IOException if there is a low-level IO error\n   */\n  public void abort() throws IOException {\n    ensureOpen();\n    if (autoCommit)\n      throw new IllegalStateException(\"abort() can only be called when IndexWriter was opened with autoCommit=false\");\n\n    boolean doClose;\n    synchronized(this) {\n      // Ensure that only one thread actually gets to do the closing:\n      if (!closing) {\n        doClose = true;\n        closing = true;\n      } else\n        doClose = false;\n    }\n\n    if (doClose) {\n\n      finishMerges(false);\n\n      // Must pre-close these two, in case they increment\n      // changeCount so that we can then set it to false\n      // before calling closeInternal\n      mergePolicy.close();\n      mergeScheduler.close();\n\n      synchronized(this) {\n        // Keep the same segmentInfos instance but replace all\n        // of its SegmentInfo instances.  This is so the next\n        // attempt to commit using this instance of IndexWriter\n        // will always write to a new generation (\"write\n        // once\").\n        segmentInfos.clear();\n        segmentInfos.addAll(rollbackSegmentInfos);\n\n        docWriter.abort(null);\n\n        // Ask deleter to locate unreferenced files & remove\n        // them:\n        deleter.checkpoint(segmentInfos, false);\n        deleter.refresh();\n      }\n\n      lastCommitChangeCount = changeCount;\n      closeInternal(false);\n    } else\n      waitForClose();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"560b3a3bb8efcae105d6ae5fbee0f8b03c7decc7","date":1255555265,"type":4,"author":"Michael Busch","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/index/IndexWriter#abort().mjava","sourceNew":null,"sourceOld":"  /**\n   * @deprecated Please use {@link #rollback} instead.\n   */\n  public void abort() throws IOException {\n    rollback();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"83bbb041887bbef07b8a98d08a0e1713ce137039":["346d5897e4c4e77ed5dbd31f7730ff30973d5971"],"346d5897e4c4e77ed5dbd31f7730ff30973d5971":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"b1405362241b561f5590ff4a87d5d6e173bcd9cf":["fde68de507dbf344495d7b5e8052866fe5f254ab"],"328c1568e471f0c6eaa49ec00334ca59e573710f":["8b6187898fc4413ccd18229711786550a280383c"],"fde68de507dbf344495d7b5e8052866fe5f254ab":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c"],"45224778ec37da27339da4de043475c91e28a536":["328c1568e471f0c6eaa49ec00334ca59e573710f"],"455aeff4fef915340c5b19d71d5e147034e83093":["a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be"],"560b3a3bb8efcae105d6ae5fbee0f8b03c7decc7":["455aeff4fef915340c5b19d71d5e147034e83093"],"a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be":["83bbb041887bbef07b8a98d08a0e1713ce137039"],"4350b17bd363cd13a95171b8df1ca62ea4c3e71c":["45224778ec37da27339da4de043475c91e28a536"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8b6187898fc4413ccd18229711786550a280383c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["560b3a3bb8efcae105d6ae5fbee0f8b03c7decc7"]},"commit2Childs":{"83bbb041887bbef07b8a98d08a0e1713ce137039":["a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be"],"346d5897e4c4e77ed5dbd31f7730ff30973d5971":["83bbb041887bbef07b8a98d08a0e1713ce137039"],"b1405362241b561f5590ff4a87d5d6e173bcd9cf":["346d5897e4c4e77ed5dbd31f7730ff30973d5971"],"328c1568e471f0c6eaa49ec00334ca59e573710f":["45224778ec37da27339da4de043475c91e28a536"],"fde68de507dbf344495d7b5e8052866fe5f254ab":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"45224778ec37da27339da4de043475c91e28a536":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c"],"455aeff4fef915340c5b19d71d5e147034e83093":["560b3a3bb8efcae105d6ae5fbee0f8b03c7decc7"],"a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be":["455aeff4fef915340c5b19d71d5e147034e83093"],"560b3a3bb8efcae105d6ae5fbee0f8b03c7decc7":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4350b17bd363cd13a95171b8df1ca62ea4c3e71c":["fde68de507dbf344495d7b5e8052866fe5f254ab"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8b6187898fc4413ccd18229711786550a280383c"],"8b6187898fc4413ccd18229711786550a280383c":["328c1568e471f0c6eaa49ec00334ca59e573710f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}