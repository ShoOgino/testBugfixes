{"path":"solr/contrib/analysis-extras/src/test/org/apache/solr/update/processor/TestOpenNLPExtractNamedEntitiesUpdateProcessorFactory#testEquivalentExtraction().mjava","commits":[{"id":"afc5b4b2446e392448f36ae4f5a164540f2ccb65","date":1513355058,"type":0,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/contrib/analysis-extras/src/test/org/apache/solr/update/processor/TestOpenNLPExtractNamedEntitiesUpdateProcessorFactory#testEquivalentExtraction().mjava","pathOld":"/dev/null","sourceNew":"  public void testEquivalentExtraction() throws Exception {\n    SolrInputDocument d;\n\n    // regardless of chain, all of these checks should be equivalent\n    for (String chain : Arrays.asList(\"extract-single\", \"extract-single-regex\",\n        \"extract-multi\", \"extract-multi-regex\",\n        \"extract-array\", \"extract-array-regex\",\n        \"extract-selector\", \"extract-selector-regex\")) {\n\n      // simple extract\n      d = processAdd(chain,\n          doc(f(\"id\", \"1111\"),\n              f(\"source0_s\", \"Totally Flashman.\"), // not extracted\n              f(\"source1_s\", \"One nation under Flashman.\", \"Good Flashman.\")));\n      assertNotNull(chain, d);\n      assertEquals(chain, Arrays.asList(\"Flashman\", \"Flashman\"), d.getFieldValues(\"dest_s\"));\n\n      // append to existing values\n      d = processAdd(chain,\n          doc(f(\"id\", \"1111\"),\n              field(\"dest_s\", \"orig1\", \"orig2\"),\n              f(\"source0_s\", \"Flashman. In totality.\"), // not extracted\n              f(\"source1_s\", \"Two nations under Flashman.\", \"Meh Flashman.\")));\n      assertNotNull(chain, d);\n      assertEquals(chain, Arrays.asList(\"orig1\", \"orig2\", \"Flashman\", \"Flashman\"), d.getFieldValues(\"dest_s\"));\n    }\n\n    // should be equivalent for any chain matching source1_s and source2_s (but not source0_s)\n    for (String chain : Arrays.asList(\"extract-multi\", \"extract-multi-regex\",\n        \"extract-array\", \"extract-array-regex\",\n        \"extract-selector\", \"extract-selector-regex\")) {\n\n      // simple extract\n      d = processAdd(chain,\n          doc(f(\"id\", \"1111\"),\n              f(\"source0_s\", \"Not Flashman.\"), // not extracted\n              f(\"source1_s\", \"Could have had a Flashman.\", \"Bad Flashman.\"),\n              f(\"source2_s\", \"Indubitably Flashman.\")));\n      assertNotNull(chain, d);\n      assertEquals(chain, Arrays.asList(\"Flashman\", \"Flashman\", \"Flashman\"), d.getFieldValues(\"dest_s\"));\n\n      // append to existing values\n      d = processAdd(chain,\n          doc(f(\"id\", \"1111\"),\n              field(\"dest_s\", \"orig1\", \"orig2\"),\n              f(\"source0_s\", \"Never Flashman.\"), // not extracted\n              f(\"source1_s\", \"Seeking Flashman.\", \"Evil incarnate Flashman.\"),\n              f(\"source2_s\", \"Perfunctorily Flashman.\")));\n      assertNotNull(chain, d);\n      assertEquals(chain, Arrays.asList(\"orig1\", \"orig2\", \"Flashman\", \"Flashman\", \"Flashman\"), d.getFieldValues(\"dest_s\"));\n    }\n\n    // any chain that copies source1_s to dest_s should be equivalent for these assertions\n    for (String chain : Arrays.asList(\"extract-single\", \"extract-single-regex\",\n        \"extract-multi\", \"extract-multi-regex\",\n        \"extract-array\", \"extract-array-regex\",\n        \"extract-selector\", \"extract-selector-regex\")) {\n\n      // simple extract\n      d = processAdd(chain,\n          doc(f(\"id\", \"1111\"),\n              f(\"source1_s\", \"Always Flashman.\", \"Flashman. Noone else.\")));\n      assertNotNull(chain, d);\n      assertEquals(chain, Arrays.asList(\"Flashman\", \"Flashman\"), d.getFieldValues(\"dest_s\"));\n\n      // append to existing values\n      d = processAdd(chain,\n          doc(f(\"id\", \"1111\"),\n              field(\"dest_s\", \"orig1\", \"orig2\"),\n              f(\"source1_s\", \"Flashman.  And, scene.\", \"Contemporary Flashman. Yeesh.\")));\n      assertNotNull(chain, d);\n      assertEquals(chain, Arrays.asList(\"orig1\", \"orig2\", \"Flashman\", \"Flashman\"), d.getFieldValues(\"dest_s\"));\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["afc5b4b2446e392448f36ae4f5a164540f2ccb65"],"afc5b4b2446e392448f36ae4f5a164540f2ccb65":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["afc5b4b2446e392448f36ae4f5a164540f2ccb65"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"afc5b4b2446e392448f36ae4f5a164540f2ccb65":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}