{"path":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getCurrentSegmentGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          IndexInput genInput = null;\n          try {\n            genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n          } catch (FileNotFoundException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: FileNotFoundException \" + e);\n            }\n          } catch (IOException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n          }\n  \n          if (genInput != null) {\n            try {\n              int version = genInput.readInt();\n              if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                long gen0 = genInput.readLong();\n                long gen1 = genInput.readLong();\n                if (infoStream != null) {\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                }\n                if (gen0 == gen1) {\n                  // The file is consistent.\n                  genB = gen0;\n                }\n              } else {\n                throw new IndexFormatTooNewException(genInput, version, FORMAT_SEGMENTS_GEN_CURRENT, FORMAT_SEGMENTS_GEN_CURRENT);\n              }\n            } catch (IOException err2) {\n              // rethrow any format exception\n              if (err2 instanceof CorruptIndexException) throw err2;\n            } finally {\n              genInput.close();\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getCurrentSegmentGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          IndexInput genInput = null;\n          try {\n            genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n          } catch (FileNotFoundException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: FileNotFoundException \" + e);\n            }\n          } catch (IOException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n          }\n  \n          if (genInput != null) {\n            try {\n              int version = genInput.readInt();\n              if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                long gen0 = genInput.readLong();\n                long gen1 = genInput.readLong();\n                if (infoStream != null) {\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                }\n                if (gen0 == gen1) {\n                  // The file is consistent.\n                  genB = gen0;\n                }\n              } else {\n                throw new IndexFormatTooNewException(genInput, version, FORMAT_SEGMENTS_GEN_CURRENT, FORMAT_SEGMENTS_GEN_CURRENT);\n              }\n            } catch (IOException err2) {\n              // rethrow any format exception\n              if (err2 instanceof CorruptIndexException) throw err2;\n            } finally {\n              genInput.close();\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"438e995b4e32916f631722aab36254146830fefb","date":1328903827,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getLastCommitGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          IndexInput genInput = null;\n          try {\n            genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n          } catch (FileNotFoundException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: FileNotFoundException \" + e);\n            }\n          } catch (IOException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n          }\n  \n          if (genInput != null) {\n            try {\n              int version = genInput.readInt();\n              if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                long gen0 = genInput.readLong();\n                long gen1 = genInput.readLong();\n                if (infoStream != null) {\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                }\n                if (gen0 == gen1) {\n                  // The file is consistent.\n                  genB = gen0;\n                }\n              } else {\n                throw new IndexFormatTooNewException(genInput, version, FORMAT_SEGMENTS_GEN_CURRENT, FORMAT_SEGMENTS_GEN_CURRENT);\n              }\n            } catch (IOException err2) {\n              // rethrow any format exception\n              if (err2 instanceof CorruptIndexException) throw err2;\n            } finally {\n              genInput.close();\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getCurrentSegmentGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          IndexInput genInput = null;\n          try {\n            genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n          } catch (FileNotFoundException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: FileNotFoundException \" + e);\n            }\n          } catch (IOException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n          }\n  \n          if (genInput != null) {\n            try {\n              int version = genInput.readInt();\n              if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                long gen0 = genInput.readLong();\n                long gen1 = genInput.readLong();\n                if (infoStream != null) {\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                }\n                if (gen0 == gen1) {\n                  // The file is consistent.\n                  genB = gen0;\n                }\n              } else {\n                throw new IndexFormatTooNewException(genInput, version, FORMAT_SEGMENTS_GEN_CURRENT, FORMAT_SEGMENTS_GEN_CURRENT);\n              }\n            } catch (IOException err2) {\n              // rethrow any format exception\n              if (err2 instanceof CorruptIndexException) throw err2;\n            } finally {\n              genInput.close();\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getLastCommitGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          IndexInput genInput = null;\n          try {\n            genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n          } catch (FileNotFoundException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: FileNotFoundException \" + e);\n            }\n          } catch (IOException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n          }\n  \n          if (genInput != null) {\n            try {\n              int version = genInput.readInt();\n              if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                long gen0 = genInput.readLong();\n                long gen1 = genInput.readLong();\n                if (infoStream != null) {\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                }\n                if (gen0 == gen1) {\n                  // The file is consistent.\n                  genB = gen0;\n                }\n              } else {\n                throw new IndexFormatTooNewException(genInput, version, FORMAT_SEGMENTS_GEN_CURRENT, FORMAT_SEGMENTS_GEN_CURRENT);\n              }\n            } catch (IOException err2) {\n              // rethrow any format exception\n              if (err2 instanceof CorruptIndexException) throw err2;\n            } finally {\n              genInput.close();\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getLastCommitGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          IndexInput genInput = null;\n          try {\n            genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n          } catch (FileNotFoundException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: FileNotFoundException \" + e);\n            }\n          } catch (IOException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n          }\n  \n          if (genInput != null) {\n            try {\n              int version = genInput.readInt();\n              if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                long gen0 = genInput.readLong();\n                long gen1 = genInput.readLong();\n                if (infoStream != null) {\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                }\n                if (gen0 == gen1) {\n                  // The file is consistent.\n                  genB = gen0;\n                }\n              } else {\n                throw new IndexFormatTooNewException(genInput, version, FORMAT_SEGMENTS_GEN_CURRENT, FORMAT_SEGMENTS_GEN_CURRENT);\n              }\n            } catch (IOException err2) {\n              // rethrow any format exception\n              if (err2 instanceof CorruptIndexException) throw err2;\n            } finally {\n              genInput.close();\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":["0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getLastCommitGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          IndexInput genInput = null;\n          try {\n            genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n          } catch (FileNotFoundException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: FileNotFoundException \" + e);\n            }\n          } catch (IOException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n          }\n  \n          if (genInput != null) {\n            try {\n              int version = genInput.readInt();\n              if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                long gen0 = genInput.readLong();\n                long gen1 = genInput.readLong();\n                if (infoStream != null) {\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                }\n                if (gen0 == gen1) {\n                  // The file is consistent.\n                  genB = gen0;\n                }\n              } else {\n                throw new IndexFormatTooNewException(genInput, version, FORMAT_SEGMENTS_GEN_CURRENT, FORMAT_SEGMENTS_GEN_CURRENT);\n              }\n            } catch (IOException err2) {\n              // rethrow any format exception\n              if (err2 instanceof CorruptIndexException) throw err2;\n            } finally {\n              genInput.close();\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getLastCommitGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          IndexInput genInput = null;\n          try {\n            genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n          } catch (FileNotFoundException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: FileNotFoundException \" + e);\n            }\n          } catch (IOException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n          }\n  \n          if (genInput != null) {\n            try {\n              int version = genInput.readInt();\n              if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                long gen0 = genInput.readLong();\n                long gen1 = genInput.readLong();\n                if (infoStream != null) {\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                }\n                if (gen0 == gen1) {\n                  // The file is consistent.\n                  genB = gen0;\n                }\n              } else {\n                throw new IndexFormatTooNewException(genInput, version, FORMAT_SEGMENTS_GEN_CURRENT, FORMAT_SEGMENTS_GEN_CURRENT);\n              }\n            } catch (IOException err2) {\n              // rethrow any format exception\n              if (err2 instanceof CorruptIndexException) throw err2;\n            } finally {\n              genInput.close();\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c14aed69f37b57db63b1fccc0740b17060a08f2b","date":1348227091,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    /** Run {@link #doBody} on the provided commit. */\n    public Object run(IndexCommit commit) throws IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getLastCommitGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          IndexInput genInput = null;\n          try {\n            genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n          } catch (FileNotFoundException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: FileNotFoundException \" + e);\n            }\n          } catch (IOException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n          }\n  \n          if (genInput != null) {\n            try {\n              int version = genInput.readInt();\n              if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                long gen0 = genInput.readLong();\n                long gen1 = genInput.readLong();\n                if (infoStream != null) {\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                }\n                if (gen0 == gen1) {\n                  // The file is consistent.\n                  genB = gen0;\n                }\n              } else {\n                throw new IndexFormatTooNewException(genInput, version, FORMAT_SEGMENTS_GEN_CURRENT, FORMAT_SEGMENTS_GEN_CURRENT);\n              }\n            } catch (IOException err2) {\n              // rethrow any format exception\n              if (err2 instanceof CorruptIndexException) throw err2;\n            } finally {\n              genInput.close();\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getLastCommitGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          IndexInput genInput = null;\n          try {\n            genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n          } catch (FileNotFoundException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: FileNotFoundException \" + e);\n            }\n          } catch (IOException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n          }\n  \n          if (genInput != null) {\n            try {\n              int version = genInput.readInt();\n              if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                long gen0 = genInput.readLong();\n                long gen1 = genInput.readLong();\n                if (infoStream != null) {\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                }\n                if (gen0 == gen1) {\n                  // The file is consistent.\n                  genB = gen0;\n                }\n              } else {\n                throw new IndexFormatTooNewException(genInput, version, FORMAT_SEGMENTS_GEN_CURRENT, FORMAT_SEGMENTS_GEN_CURRENT);\n              }\n            } catch (IOException err2) {\n              // rethrow any format exception\n              if (err2 instanceof CorruptIndexException) throw err2;\n            } finally {\n              genInput.close();\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4e8c7f04b36257c51a136e30f7ebaa119362d3a5","date":1370984527,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    /** Run {@link #doBody} on the provided commit. */\n    public Object run(IndexCommit commit) throws IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getLastCommitGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          IndexInput genInput = null;\n          try {\n            genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n          } catch (IOException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n          }\n  \n          if (genInput != null) {\n            try {\n              int version = genInput.readInt();\n              if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                long gen0 = genInput.readLong();\n                long gen1 = genInput.readLong();\n                if (infoStream != null) {\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                }\n                if (gen0 == gen1) {\n                  // The file is consistent.\n                  genB = gen0;\n                }\n              } else {\n                throw new IndexFormatTooNewException(genInput, version, FORMAT_SEGMENTS_GEN_CURRENT, FORMAT_SEGMENTS_GEN_CURRENT);\n              }\n            } catch (IOException err2) {\n              // rethrow any format exception\n              if (err2 instanceof CorruptIndexException) throw err2;\n            } finally {\n              genInput.close();\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /** Run {@link #doBody} on the provided commit. */\n    public Object run(IndexCommit commit) throws IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getLastCommitGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          IndexInput genInput = null;\n          try {\n            genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n          } catch (FileNotFoundException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: FileNotFoundException \" + e);\n            }\n          } catch (IOException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n          }\n  \n          if (genInput != null) {\n            try {\n              int version = genInput.readInt();\n              if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                long gen0 = genInput.readLong();\n                long gen1 = genInput.readLong();\n                if (infoStream != null) {\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                }\n                if (gen0 == gen1) {\n                  // The file is consistent.\n                  genB = gen0;\n                }\n              } else {\n                throw new IndexFormatTooNewException(genInput, version, FORMAT_SEGMENTS_GEN_CURRENT, FORMAT_SEGMENTS_GEN_CURRENT);\n              }\n            } catch (IOException err2) {\n              // rethrow any format exception\n              if (err2 instanceof CorruptIndexException) throw err2;\n            } finally {\n              genInput.close();\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cd4e13d997cf4fb810398a20a299c2c5a9f6b796","date":1395594336,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    /** Run {@link #doBody} on the provided commit. */\n    public Object run(IndexCommit commit) throws IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getLastCommitGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          IndexInput genInput = null;\n          try {\n            genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n          } catch (IOException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n          }\n  \n          if (genInput != null) {\n            try {\n              int version = genInput.readInt();\n              if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                long gen0 = genInput.readLong();\n                long gen1 = genInput.readLong();\n                if (infoStream != null) {\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                }\n                if (gen0 == gen1) {\n                  // The file is consistent.\n                  genB = gen0;\n                }\n              } else {\n                throw new IndexFormatTooNewException(genInput, version, FORMAT_SEGMENTS_GEN_CURRENT, FORMAT_SEGMENTS_GEN_CURRENT);\n              }\n            } catch (IOException err2) {\n              // rethrow any format exception\n              if (err2 instanceof CorruptIndexException) throw err2;\n            } finally {\n              genInput.close();\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            boolean prevExists;\n\n            try {\n              directory.openInput(prevSegmentFileName, IOContext.DEFAULT).close();\n              prevExists = true;\n            } catch (IOException ioe) {\n              prevExists = false;\n            }\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /** Run {@link #doBody} on the provided commit. */\n    public Object run(IndexCommit commit) throws IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getLastCommitGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          IndexInput genInput = null;\n          try {\n            genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n          } catch (IOException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n          }\n  \n          if (genInput != null) {\n            try {\n              int version = genInput.readInt();\n              if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                long gen0 = genInput.readLong();\n                long gen1 = genInput.readLong();\n                if (infoStream != null) {\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                }\n                if (gen0 == gen1) {\n                  // The file is consistent.\n                  genB = gen0;\n                }\n              } else {\n                throw new IndexFormatTooNewException(genInput, version, FORMAT_SEGMENTS_GEN_CURRENT, FORMAT_SEGMENTS_GEN_CURRENT);\n              }\n            } catch (IOException err2) {\n              // rethrow any format exception\n              if (err2 instanceof CorruptIndexException) throw err2;\n            } finally {\n              genInput.close();\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1f3b037cd083286b2af89f96e768f85dcd8072d6","date":1396337805,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    /** Run {@link #doBody} on the provided commit. */\n    public Object run(IndexCommit commit) throws IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getLastCommitGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          ChecksumIndexInput genInput = null;\n          try {\n            genInput = directory.openChecksumInput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n          } catch (IOException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n          }\n  \n          if (genInput != null) {\n            try {\n              int version = genInput.readInt();\n              if (version == FORMAT_SEGMENTS_GEN_47 || version == FORMAT_SEGMENTS_GEN_CHECKSUM) {\n                long gen0 = genInput.readLong();\n                long gen1 = genInput.readLong();\n                if (infoStream != null) {\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                }\n                if (version == FORMAT_SEGMENTS_GEN_CHECKSUM) {\n                  CodecUtil.checkFooter(genInput);\n                } else {\n                  CodecUtil.checkEOF(genInput);\n                }\n                if (gen0 == gen1) {\n                  // The file is consistent.\n                  genB = gen0;\n                }\n              } else {\n                throw new IndexFormatTooNewException(genInput, version, FORMAT_SEGMENTS_GEN_START, FORMAT_SEGMENTS_GEN_CURRENT);\n              }\n            } catch (IOException err2) {\n              // rethrow any format exception\n              if (err2 instanceof CorruptIndexException) throw err2;\n            } finally {\n              genInput.close();\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            boolean prevExists;\n\n            try {\n              directory.openInput(prevSegmentFileName, IOContext.DEFAULT).close();\n              prevExists = true;\n            } catch (IOException ioe) {\n              prevExists = false;\n            }\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /** Run {@link #doBody} on the provided commit. */\n    public Object run(IndexCommit commit) throws IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getLastCommitGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          IndexInput genInput = null;\n          try {\n            genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n          } catch (IOException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n          }\n  \n          if (genInput != null) {\n            try {\n              int version = genInput.readInt();\n              if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                long gen0 = genInput.readLong();\n                long gen1 = genInput.readLong();\n                if (infoStream != null) {\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                }\n                if (gen0 == gen1) {\n                  // The file is consistent.\n                  genB = gen0;\n                }\n              } else {\n                throw new IndexFormatTooNewException(genInput, version, FORMAT_SEGMENTS_GEN_CURRENT, FORMAT_SEGMENTS_GEN_CURRENT);\n              }\n            } catch (IOException err2) {\n              // rethrow any format exception\n              if (err2 instanceof CorruptIndexException) throw err2;\n            } finally {\n              genInput.close();\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            boolean prevExists;\n\n            try {\n              directory.openInput(prevSegmentFileName, IOContext.DEFAULT).close();\n              prevExists = true;\n            } catch (IOException ioe) {\n              prevExists = false;\n            }\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    /** Run {@link #doBody} on the provided commit. */\n    public Object run(IndexCommit commit) throws IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getLastCommitGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          ChecksumIndexInput genInput = null;\n          try {\n            genInput = directory.openChecksumInput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n          } catch (IOException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n          }\n  \n          if (genInput != null) {\n            try {\n              int version = genInput.readInt();\n              if (version == FORMAT_SEGMENTS_GEN_47 || version == FORMAT_SEGMENTS_GEN_CHECKSUM) {\n                long gen0 = genInput.readLong();\n                long gen1 = genInput.readLong();\n                if (infoStream != null) {\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                }\n                if (version == FORMAT_SEGMENTS_GEN_CHECKSUM) {\n                  CodecUtil.checkFooter(genInput);\n                } else {\n                  CodecUtil.checkEOF(genInput);\n                }\n                if (gen0 == gen1) {\n                  // The file is consistent.\n                  genB = gen0;\n                }\n              } else {\n                throw new IndexFormatTooNewException(genInput, version, FORMAT_SEGMENTS_GEN_START, FORMAT_SEGMENTS_GEN_CURRENT);\n              }\n            } catch (IOException err2) {\n              // rethrow any format exception\n              if (err2 instanceof CorruptIndexException) throw err2;\n            } finally {\n              genInput.close();\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            boolean prevExists;\n\n            try {\n              directory.openInput(prevSegmentFileName, IOContext.DEFAULT).close();\n              prevExists = true;\n            } catch (IOException ioe) {\n              prevExists = false;\n            }\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /** Run {@link #doBody} on the provided commit. */\n    public Object run(IndexCommit commit) throws IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getLastCommitGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          IndexInput genInput = null;\n          try {\n            genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n          } catch (IOException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n          }\n  \n          if (genInput != null) {\n            try {\n              int version = genInput.readInt();\n              if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                long gen0 = genInput.readLong();\n                long gen1 = genInput.readLong();\n                if (infoStream != null) {\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                }\n                if (gen0 == gen1) {\n                  // The file is consistent.\n                  genB = gen0;\n                }\n              } else {\n                throw new IndexFormatTooNewException(genInput, version, FORMAT_SEGMENTS_GEN_CURRENT, FORMAT_SEGMENTS_GEN_CURRENT);\n              }\n            } catch (IOException err2) {\n              // rethrow any format exception\n              if (err2 instanceof CorruptIndexException) throw err2;\n            } finally {\n              genInput.close();\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            boolean prevExists;\n\n            try {\n              directory.openInput(prevSegmentFileName, IOContext.DEFAULT).close();\n              prevExists = true;\n            } catch (IOException ioe) {\n              prevExists = false;\n            }\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13","date":1409346855,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    /** Run {@link #doBody} on the provided commit. */\n    public Object run(IndexCommit commit) throws IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getLastCommitGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          ChecksumIndexInput genInput = null;\n          try {\n            genInput = directory.openChecksumInput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n          } catch (IOException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n          }\n  \n          if (genInput != null) {\n            try {\n              int version = genInput.readInt();\n              if (version == FORMAT_SEGMENTS_GEN_47 || version == FORMAT_SEGMENTS_GEN_CHECKSUM) {\n                long gen0 = genInput.readLong();\n                long gen1 = genInput.readLong();\n                if (infoStream != null) {\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                }\n                if (version == FORMAT_SEGMENTS_GEN_CHECKSUM) {\n                  CodecUtil.checkFooter(genInput);\n                } else {\n                  CodecUtil.checkEOF(genInput);\n                }\n                if (gen0 == gen1) {\n                  // The file is consistent.\n                  genB = gen0;\n                }\n              } else {\n                throw new IndexFormatTooNewException(genInput, version, FORMAT_SEGMENTS_GEN_START, FORMAT_SEGMENTS_GEN_CURRENT);\n              }\n            } catch (IOException err2) {\n              // rethrow any format exception\n              if (err2 instanceof CorruptIndexException) throw err2;\n            } finally {\n              genInput.close();\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // TODO: we should use the new IO apis in Java7 to get better exceptions on why the open failed.  E.g. we don't want to fall back\n          // if the open failed for a \"different\" reason (too many open files, access denied) than \"the commit was in progress\"\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            boolean prevExists;\n\n            try {\n              directory.openInput(prevSegmentFileName, IOContext.DEFAULT).close();\n              prevExists = true;\n            } catch (IOException ioe) {\n              prevExists = false;\n            }\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /** Run {@link #doBody} on the provided commit. */\n    public Object run(IndexCommit commit) throws IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getLastCommitGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          ChecksumIndexInput genInput = null;\n          try {\n            genInput = directory.openChecksumInput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n          } catch (IOException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n          }\n  \n          if (genInput != null) {\n            try {\n              int version = genInput.readInt();\n              if (version == FORMAT_SEGMENTS_GEN_47 || version == FORMAT_SEGMENTS_GEN_CHECKSUM) {\n                long gen0 = genInput.readLong();\n                long gen1 = genInput.readLong();\n                if (infoStream != null) {\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                }\n                if (version == FORMAT_SEGMENTS_GEN_CHECKSUM) {\n                  CodecUtil.checkFooter(genInput);\n                } else {\n                  CodecUtil.checkEOF(genInput);\n                }\n                if (gen0 == gen1) {\n                  // The file is consistent.\n                  genB = gen0;\n                }\n              } else {\n                throw new IndexFormatTooNewException(genInput, version, FORMAT_SEGMENTS_GEN_START, FORMAT_SEGMENTS_GEN_CURRENT);\n              }\n            } catch (IOException err2) {\n              // rethrow any format exception\n              if (err2 instanceof CorruptIndexException) throw err2;\n            } finally {\n              genInput.close();\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            boolean prevExists;\n\n            try {\n              directory.openInput(prevSegmentFileName, IOContext.DEFAULT).close();\n              prevExists = true;\n            } catch (IOException ioe) {\n              prevExists = false;\n            }\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46e4a8bdfbafda795ef9c39a2bc2d47095770299","date":1410411846,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    /** Run {@link #doBody} on the provided commit. */\n    public Object run(IndexCommit commit) throws IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      long lastGen = -1;\n      long gen = -1;\n      IOException exc = null;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means an IW deleted our commit while opening\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      for (;;) {\n        lastGen = gen;\n        String files[] = directory.listAll();\n        String files2[] = directory.listAll();\n        Arrays.sort(files);\n        Arrays.sort(files2);\n        if (!Arrays.equals(files, files2)) {\n          // listAll() is weakly consistent, this means we hit \"concurrent modification exception\"\n          continue;\n        }\n        gen = getLastCommitGeneration(files);\n        \n        if (infoStream != null) {\n          message(\"directory listing gen=\" + gen);\n        }\n        \n        if (gen == -1) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        } else if (gen > lastGen) {\n          String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen);\n        \n          try {\n            Object v = doBody(segmentFileName);\n            if (infoStream != null) {\n              message(\"success on \" + segmentFileName);\n            }\n            return v;\n          } catch (IOException err) {\n            // Save the original root cause:\n            if (exc == null) {\n              exc = err;\n            }\n\n            if (infoStream != null) {\n              message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: gen = \" + gen);\n            }\n          }\n        } else {\n          throw exc;\n        }\n      }\n    }\n\n","sourceOld":"    /** Run {@link #doBody} on the provided commit. */\n    public Object run(IndexCommit commit) throws IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getLastCommitGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          ChecksumIndexInput genInput = null;\n          try {\n            genInput = directory.openChecksumInput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n          } catch (IOException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n          }\n  \n          if (genInput != null) {\n            try {\n              int version = genInput.readInt();\n              if (version == FORMAT_SEGMENTS_GEN_47 || version == FORMAT_SEGMENTS_GEN_CHECKSUM) {\n                long gen0 = genInput.readLong();\n                long gen1 = genInput.readLong();\n                if (infoStream != null) {\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                }\n                if (version == FORMAT_SEGMENTS_GEN_CHECKSUM) {\n                  CodecUtil.checkFooter(genInput);\n                } else {\n                  CodecUtil.checkEOF(genInput);\n                }\n                if (gen0 == gen1) {\n                  // The file is consistent.\n                  genB = gen0;\n                }\n              } else {\n                throw new IndexFormatTooNewException(genInput, version, FORMAT_SEGMENTS_GEN_START, FORMAT_SEGMENTS_GEN_CURRENT);\n              }\n            } catch (IOException err2) {\n              // rethrow any format exception\n              if (err2 instanceof CorruptIndexException) throw err2;\n            } finally {\n              genInput.close();\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // TODO: we should use the new IO apis in Java7 to get better exceptions on why the open failed.  E.g. we don't want to fall back\n          // if the open failed for a \"different\" reason (too many open files, access denied) than \"the commit was in progress\"\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            boolean prevExists;\n\n            try {\n              directory.openInput(prevSegmentFileName, IOContext.DEFAULT).close();\n              prevExists = true;\n            } catch (IOException ioe) {\n              prevExists = false;\n            }\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3384e6013a93e4d11b7d75388693f8d0388602bf","date":1413951663,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    /** Run {@link #doBody} on the provided commit. */\n    public T run(IndexCommit commit) throws IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      long lastGen = -1;\n      long gen = -1;\n      IOException exc = null;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means an IW deleted our commit while opening\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      for (;;) {\n        lastGen = gen;\n        String files[] = directory.listAll();\n        String files2[] = directory.listAll();\n        Arrays.sort(files);\n        Arrays.sort(files2);\n        if (!Arrays.equals(files, files2)) {\n          // listAll() is weakly consistent, this means we hit \"concurrent modification exception\"\n          continue;\n        }\n        gen = getLastCommitGeneration(files);\n        \n        if (infoStream != null) {\n          message(\"directory listing gen=\" + gen);\n        }\n        \n        if (gen == -1) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        } else if (gen > lastGen) {\n          String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen);\n        \n          try {\n            T t = doBody(segmentFileName);\n            if (infoStream != null) {\n              message(\"success on \" + segmentFileName);\n            }\n            return t;\n          } catch (IOException err) {\n            // Save the original root cause:\n            if (exc == null) {\n              exc = err;\n            }\n\n            if (infoStream != null) {\n              message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: gen = \" + gen);\n            }\n          }\n        } else {\n          throw exc;\n        }\n      }\n    }\n\n","sourceOld":"    /** Run {@link #doBody} on the provided commit. */\n    public Object run(IndexCommit commit) throws IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      long lastGen = -1;\n      long gen = -1;\n      IOException exc = null;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means an IW deleted our commit while opening\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      for (;;) {\n        lastGen = gen;\n        String files[] = directory.listAll();\n        String files2[] = directory.listAll();\n        Arrays.sort(files);\n        Arrays.sort(files2);\n        if (!Arrays.equals(files, files2)) {\n          // listAll() is weakly consistent, this means we hit \"concurrent modification exception\"\n          continue;\n        }\n        gen = getLastCommitGeneration(files);\n        \n        if (infoStream != null) {\n          message(\"directory listing gen=\" + gen);\n        }\n        \n        if (gen == -1) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        } else if (gen > lastGen) {\n          String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen);\n        \n          try {\n            Object v = doBody(segmentFileName);\n            if (infoStream != null) {\n              message(\"success on \" + segmentFileName);\n            }\n            return v;\n          } catch (IOException err) {\n            // Save the original root cause:\n            if (exc == null) {\n              exc = err;\n            }\n\n            if (infoStream != null) {\n              message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: gen = \" + gen);\n            }\n          }\n        } else {\n          throw exc;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db68c63cbfaa8698b9c4475f75ed2b9c9696d238","date":1414118621,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    /** Run {@link #doBody} on the provided commit. */\n    public T run(IndexCommit commit) throws IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      long lastGen = -1;\n      long gen = -1;\n      IOException exc = null;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means an IW deleted our commit while opening\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      for (;;) {\n        lastGen = gen;\n        String files[] = directory.listAll();\n        String files2[] = directory.listAll();\n        Arrays.sort(files);\n        Arrays.sort(files2);\n        if (!Arrays.equals(files, files2)) {\n          // listAll() is weakly consistent, this means we hit \"concurrent modification exception\"\n          continue;\n        }\n        gen = getLastCommitGeneration(files);\n        \n        if (infoStream != null) {\n          message(\"directory listing gen=\" + gen);\n        }\n        \n        if (gen == -1) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        } else if (gen > lastGen) {\n          String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen);\n        \n          try {\n            T t = doBody(segmentFileName);\n            if (infoStream != null) {\n              message(\"success on \" + segmentFileName);\n            }\n            return t;\n          } catch (IOException err) {\n            // Save the original root cause:\n            if (exc == null) {\n              exc = err;\n            }\n\n            if (infoStream != null) {\n              message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: gen = \" + gen);\n            }\n          }\n        } else {\n          throw exc;\n        }\n      }\n    }\n\n","sourceOld":"    /** Run {@link #doBody} on the provided commit. */\n    public Object run(IndexCommit commit) throws IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      long lastGen = -1;\n      long gen = -1;\n      IOException exc = null;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means an IW deleted our commit while opening\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      for (;;) {\n        lastGen = gen;\n        String files[] = directory.listAll();\n        String files2[] = directory.listAll();\n        Arrays.sort(files);\n        Arrays.sort(files2);\n        if (!Arrays.equals(files, files2)) {\n          // listAll() is weakly consistent, this means we hit \"concurrent modification exception\"\n          continue;\n        }\n        gen = getLastCommitGeneration(files);\n        \n        if (infoStream != null) {\n          message(\"directory listing gen=\" + gen);\n        }\n        \n        if (gen == -1) {\n          throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n        } else if (gen > lastGen) {\n          String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen);\n        \n          try {\n            Object v = doBody(segmentFileName);\n            if (infoStream != null) {\n              message(\"success on \" + segmentFileName);\n            }\n            return v;\n          } catch (IOException err) {\n            // Save the original root cause:\n            if (exc == null) {\n              exc = err;\n            }\n\n            if (infoStream != null) {\n              message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: gen = \" + gen);\n            }\n          }\n        } else {\n          throw exc;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5eb2511ababf862ea11e10761c70ee560cd84510":["cd4e13d997cf4fb810398a20a299c2c5a9f6b796","1f3b037cd083286b2af89f96e768f85dcd8072d6"],"1f3b037cd083286b2af89f96e768f85dcd8072d6":["cd4e13d997cf4fb810398a20a299c2c5a9f6b796"],"4e8c7f04b36257c51a136e30f7ebaa119362d3a5":["c14aed69f37b57db63b1fccc0740b17060a08f2b"],"cd4e13d997cf4fb810398a20a299c2c5a9f6b796":["4e8c7f04b36257c51a136e30f7ebaa119362d3a5"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13":["1f3b037cd083286b2af89f96e768f85dcd8072d6"],"3384e6013a93e4d11b7d75388693f8d0388602bf":["46e4a8bdfbafda795ef9c39a2bc2d47095770299"],"46e4a8bdfbafda795ef9c39a2bc2d47095770299":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["438e995b4e32916f631722aab36254146830fefb","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["46e4a8bdfbafda795ef9c39a2bc2d47095770299","3384e6013a93e4d11b7d75388693f8d0388602bf"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["438e995b4e32916f631722aab36254146830fefb"],"c14aed69f37b57db63b1fccc0740b17060a08f2b":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"438e995b4e32916f631722aab36254146830fefb":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"]},"commit2Childs":{"5eb2511ababf862ea11e10761c70ee560cd84510":[],"1f3b037cd083286b2af89f96e768f85dcd8072d6":["5eb2511ababf862ea11e10761c70ee560cd84510","98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"],"4e8c7f04b36257c51a136e30f7ebaa119362d3a5":["cd4e13d997cf4fb810398a20a299c2c5a9f6b796"],"cd4e13d997cf4fb810398a20a299c2c5a9f6b796":["5eb2511ababf862ea11e10761c70ee560cd84510","1f3b037cd083286b2af89f96e768f85dcd8072d6"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["438e995b4e32916f631722aab36254146830fefb"],"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13":["46e4a8bdfbafda795ef9c39a2bc2d47095770299"],"3384e6013a93e4d11b7d75388693f8d0388602bf":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"46e4a8bdfbafda795ef9c39a2bc2d47095770299":["3384e6013a93e4d11b7d75388693f8d0388602bf","db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["fe33227f6805edab2036cbb80645cc4e2d1fa424","c14aed69f37b57db63b1fccc0740b17060a08f2b"],"c14aed69f37b57db63b1fccc0740b17060a08f2b":["4e8c7f04b36257c51a136e30f7ebaa119362d3a5"],"438e995b4e32916f631722aab36254146830fefb":["fe33227f6805edab2036cbb80645cc4e2d1fa424","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5eb2511ababf862ea11e10761c70ee560cd84510","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}