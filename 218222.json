{"path":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","sourceNew":"  /**\n   * Initialize PhrasePositions in place.\n   * There is a one time initialization for this scorer (taking place at the first doc that matches all terms):\n   * <ul>\n   *  <li>Detect groups of repeating pps: those with same tpPos (tpPos==position in the doc) but different offsets in query.\n   *  <li>For each such group:\n   *  <ul>\n   *   <li>form an inner linked list of the repeating ones.\n   *   <li>propagate all group members but first so that they land on different tpPos().\n   *  </ul>\n   *  <li>Mark whether there are repetitions at all, so that scoring queries with no repetitions has no overhead due to this computation.\n   *  <li>Insert to pq only non repeating PPs, or PPs that are the first in a repeating group.\n   * </ul>\n   * Examples:\n   * <ol>\n   *  <li>no repetitions: <b>\"ho my\"~2</b>\n   *  <li>repetitions: <b>\"ho my my\"~2</b>\n   *  <li>repetitions: <b>\"my ho my\"~2</b>\n   * </ol>\n   * @return end (max position), or Integer.MIN_VALUE if any term ran out (i.e. done) \n   */\n  private int initPhrasePositions() throws IOException {\n    int end = Integer.MIN_VALUE;\n    \n    // no repeats at all (most common case is also the simplest one)\n    if (checkedRepeats && !hasRepeats) {\n      // build queue from list\n      pq.clear();\n      for (PhrasePositions pp=min,prev=null; prev!=max; pp=(prev=pp).next) {  // iterate cyclic list: done once handled max\n        pp.firstPosition();\n        if (pp.position > end) {\n          end = pp.position;\n        }\n        pq.add(pp);         // build pq from list\n      }\n      return end;\n    }\n    \n    //printPositions(System.err, \"Init: 1: Bef position\");\n    \n    // position the pp's\n    for (PhrasePositions pp=min,prev=null; prev!=max; pp=(prev=pp).next) {  // iterate cyclic list: done once handled max  \n      pp.firstPosition();\n    }\n    \n    //printPositions(System.err, \"Init: 2: Aft position\");\n    \n    // one time initialization for this scorer (done only for the first candidate doc)\n    if (!checkedRepeats) {\n      checkedRepeats = true;\n      ArrayList<PhrasePositions> ppsA = new ArrayList<PhrasePositions>();\n      PhrasePositions dummyPP = new PhrasePositions(null, -1, -1);\n      // check for repeats\n      for (PhrasePositions pp=min,prev=null; prev!=max; pp=(prev=pp).next) {  // iterate cyclic list: done once handled max\n        if (pp.nextRepeating != null) {\n          continue; // a repetition of an earlier pp\n        }\n        ppsA.add(pp);\n        int tpPos = tpPos(pp);\n        for (PhrasePositions prevB=pp, pp2=pp.next; pp2!= min; pp2=pp2.next) {\n          if (\n              pp2.nextRepeating != null  // already detected as a repetition of an earlier pp\n              || pp.offset == pp2.offset // not a repetition: the two PPs are originally in same offset in the query! \n              || tpPos(pp2) != tpPos) {  // not a repetition\n            continue; \n          }\n          // a repetition\n          hasRepeats = true;\n          prevB.nextRepeating = pp2;  // add pp2 to the repeats linked list\n          pp2.nextRepeating = dummyPP; // allows not to handle the last pp in a sub-list\n          prevB = pp2;\n        }\n      }\n      if (hasRepeats) {\n        // clean dummy markers\n        for (PhrasePositions pp=min,prev=null; prev!=max; pp=(prev=pp).next) {  // iterate cyclic list: done once handled max\n          if (pp.nextRepeating == dummyPP) {\n            pp.nextRepeating = null;\n          }\n        }\n      }\n      nrPps = ppsA.toArray(new PhrasePositions[0]);\n      pq = new PhraseQueue(nrPps.length);\n    }\n    \n    //printPositions(System.err, \"Init: 3: Aft check-repeats\");\n    \n    // with repeats must advance some repeating pp's so they all start with differing tp's\n    if (hasRepeats) {\n      for (PhrasePositions pp: nrPps) {\n        if ((end=advanceRepeats(pp, end)) == Integer.MIN_VALUE) {\n          return Integer.MIN_VALUE; // ran out of a term -- done (no valid matches in current doc)\n        }\n      }\n    }\n    \n    //printPositions(System.err, \"Init: 4: Aft advance-repeats\");\n    \n    // build queue from non repeating pps \n    pq.clear();\n    for (PhrasePositions pp: nrPps) {\n      if (pp.position > end) {\n        end = pp.position;\n      }\n      pq.add(pp);\n    }\n    \n    return end;\n  }\n\n","sourceOld":"  /**\n   * Initialize PhrasePositions in place.\n   * There is a one time initialization for this scorer (taking place at the first doc that matches all terms):\n   * <ul>\n   *  <li>Detect groups of repeating pps: those with same tpPos (tpPos==position in the doc) but different offsets in query.\n   *  <li>For each such group:\n   *  <ul>\n   *   <li>form an inner linked list of the repeating ones.\n   *   <li>propagate all group members but first so that they land on different tpPos().\n   *  </ul>\n   *  <li>Mark whether there are repetitions at all, so that scoring queries with no repetitions has no overhead due to this computation.\n   *  <li>Insert to pq only non repeating PPs, or PPs that are the first in a repeating group.\n   * </ul>\n   * Examples:\n   * <ol>\n   *  <li>no repetitions: <b>\"ho my\"~2</b>\n   *  <li>repetitions: <b>\"ho my my\"~2</b>\n   *  <li>repetitions: <b>\"my ho my\"~2</b>\n   * </ol>\n   * @return end (max position), or Integer.MIN_VALUE if any term ran out (i.e. done) \n   */\n  private int initPhrasePositions() throws IOException {\n    int end = Integer.MIN_VALUE;\n    \n    // no repeats at all (most common case is also the simplest one)\n    if (checkedRepeats && !hasRepeats) {\n      // build queue from list\n      pq.clear();\n      for (PhrasePositions pp=min,prev=null; prev!=max; pp=(prev=pp).next) {  // iterate cyclic list: done once handled max\n        pp.firstPosition();\n        if (pp.position > end) {\n          end = pp.position;\n        }\n        pq.add(pp);         // build pq from list\n      }\n      return end;\n    }\n    \n    //printPositions(System.err, \"Init: 1: Bef position\");\n    \n    // position the pp's\n    for (PhrasePositions pp=min,prev=null; prev!=max; pp=(prev=pp).next) {  // iterate cyclic list: done once handled max  \n      pp.firstPosition();\n    }\n    \n    //printPositions(System.err, \"Init: 2: Aft position\");\n    \n    // one time initialization for this scorer (done only for the first candidate doc)\n    if (!checkedRepeats) {\n      checkedRepeats = true;\n      ArrayList<PhrasePositions> ppsA = new ArrayList<PhrasePositions>();\n      PhrasePositions dummyPP = new PhrasePositions(null, -1, -1);\n      // check for repeats\n      for (PhrasePositions pp=min,prev=null; prev!=max; pp=(prev=pp).next) {  // iterate cyclic list: done once handled max\n        if (pp.nextRepeating != null) {\n          continue; // a repetition of an earlier pp\n        }\n        ppsA.add(pp);\n        int tpPos = tpPos(pp);\n        for (PhrasePositions prevB=pp, pp2=pp.next; pp2!= min; pp2=pp2.next) {\n          if (\n              pp2.nextRepeating != null  // already detected as a repetition of an earlier pp\n              || pp.offset == pp2.offset // not a repetition: the two PPs are originally in same offset in the query! \n              || tpPos(pp2) != tpPos) {  // not a repetition\n            continue; \n          }\n          // a repetition\n          hasRepeats = true;\n          prevB.nextRepeating = pp2;  // add pp2 to the repeats linked list\n          pp2.nextRepeating = dummyPP; // allows not to handle the last pp in a sub-list\n          prevB = pp2;\n        }\n      }\n      if (hasRepeats) {\n        // clean dummy markers\n        for (PhrasePositions pp=min,prev=null; prev!=max; pp=(prev=pp).next) {  // iterate cyclic list: done once handled max\n          if (pp.nextRepeating == dummyPP) {\n            pp.nextRepeating = null;\n          }\n        }\n      }\n      nrPps = ppsA.toArray(new PhrasePositions[0]);\n      pq = new PhraseQueue(nrPps.length);\n    }\n    \n    //printPositions(System.err, \"Init: 3: Aft check-repeats\");\n    \n    // with repeats must advance some repeating pp's so they all start with differing tp's\n    if (hasRepeats) {\n      for (PhrasePositions pp: nrPps) {\n        if ((end=advanceRepeats(pp, end)) == Integer.MIN_VALUE) {\n          return Integer.MIN_VALUE; // ran out of a term -- done (no valid matches in current doc)\n        }\n      }\n    }\n    \n    //printPositions(System.err, \"Init: 4: Aft advance-repeats\");\n    \n    // build queue from non repeating pps \n    pq.clear();\n    for (PhrasePositions pp: nrPps) {\n      if (pp.position > end) {\n        end = pp.position;\n      }\n      pq.add(pp);\n    }\n    \n    return end;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2eaa5d4d2618a012373ae4574ebb6563933aa9f6","date":1331337973,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","sourceNew":"  /**\n   * Initialize PhrasePositions in place.\n   * A one time initialization for this scorer (on first doc matching all terms):\n   * <ul>\n   *  <li>Check if there are repetitions\n   *  <li>If there are, find groups of repetitions.\n   * </ul>\n   * Examples:\n   * <ol>\n   *  <li>no repetitions: <b>\"ho my\"~2</b>\n   *  <li>repetitions: <b>\"ho my my\"~2</b>\n   *  <li>repetitions: <b>\"my ho my\"~2</b>\n   * </ol>\n   * @return false if PPs are exhausted (and so current doc will not be a match) \n   */\n  private boolean initPhrasePositions() throws IOException {\n    end = Integer.MIN_VALUE;\n    if (!checkedRpts) {\n      return initFirstTime();\n    }\n    if (!hasRpts) {\n      initSimple();\n      return true; // PPs available\n    }\n    return initComplex();\n  }\n\n","sourceOld":"  /**\n   * Initialize PhrasePositions in place.\n   * There is a one time initialization for this scorer (taking place at the first doc that matches all terms):\n   * <ul>\n   *  <li>Detect groups of repeating pps: those with same tpPos (tpPos==position in the doc) but different offsets in query.\n   *  <li>For each such group:\n   *  <ul>\n   *   <li>form an inner linked list of the repeating ones.\n   *   <li>propagate all group members but first so that they land on different tpPos().\n   *  </ul>\n   *  <li>Mark whether there are repetitions at all, so that scoring queries with no repetitions has no overhead due to this computation.\n   *  <li>Insert to pq only non repeating PPs, or PPs that are the first in a repeating group.\n   * </ul>\n   * Examples:\n   * <ol>\n   *  <li>no repetitions: <b>\"ho my\"~2</b>\n   *  <li>repetitions: <b>\"ho my my\"~2</b>\n   *  <li>repetitions: <b>\"my ho my\"~2</b>\n   * </ol>\n   * @return end (max position), or Integer.MIN_VALUE if any term ran out (i.e. done) \n   */\n  private int initPhrasePositions() throws IOException {\n    int end = Integer.MIN_VALUE;\n    \n    // no repeats at all (most common case is also the simplest one)\n    if (checkedRepeats && !hasRepeats) {\n      // build queue from list\n      pq.clear();\n      for (PhrasePositions pp=min,prev=null; prev!=max; pp=(prev=pp).next) {  // iterate cyclic list: done once handled max\n        pp.firstPosition();\n        if (pp.position > end) {\n          end = pp.position;\n        }\n        pq.add(pp);         // build pq from list\n      }\n      return end;\n    }\n    \n    //printPositions(System.err, \"Init: 1: Bef position\");\n    \n    // position the pp's\n    for (PhrasePositions pp=min,prev=null; prev!=max; pp=(prev=pp).next) {  // iterate cyclic list: done once handled max  \n      pp.firstPosition();\n    }\n    \n    //printPositions(System.err, \"Init: 2: Aft position\");\n    \n    // one time initialization for this scorer (done only for the first candidate doc)\n    if (!checkedRepeats) {\n      checkedRepeats = true;\n      ArrayList<PhrasePositions> ppsA = new ArrayList<PhrasePositions>();\n      PhrasePositions dummyPP = new PhrasePositions(null, -1, -1);\n      // check for repeats\n      for (PhrasePositions pp=min,prev=null; prev!=max; pp=(prev=pp).next) {  // iterate cyclic list: done once handled max\n        if (pp.nextRepeating != null) {\n          continue; // a repetition of an earlier pp\n        }\n        ppsA.add(pp);\n        int tpPos = tpPos(pp);\n        for (PhrasePositions prevB=pp, pp2=pp.next; pp2!= min; pp2=pp2.next) {\n          if (\n              pp2.nextRepeating != null  // already detected as a repetition of an earlier pp\n              || pp.offset == pp2.offset // not a repetition: the two PPs are originally in same offset in the query! \n              || tpPos(pp2) != tpPos) {  // not a repetition\n            continue; \n          }\n          // a repetition\n          hasRepeats = true;\n          prevB.nextRepeating = pp2;  // add pp2 to the repeats linked list\n          pp2.nextRepeating = dummyPP; // allows not to handle the last pp in a sub-list\n          prevB = pp2;\n        }\n      }\n      if (hasRepeats) {\n        // clean dummy markers\n        for (PhrasePositions pp=min,prev=null; prev!=max; pp=(prev=pp).next) {  // iterate cyclic list: done once handled max\n          if (pp.nextRepeating == dummyPP) {\n            pp.nextRepeating = null;\n          }\n        }\n      }\n      nrPps = ppsA.toArray(new PhrasePositions[0]);\n      pq = new PhraseQueue(nrPps.length);\n    }\n    \n    //printPositions(System.err, \"Init: 3: Aft check-repeats\");\n    \n    // with repeats must advance some repeating pp's so they all start with differing tp's\n    if (hasRepeats) {\n      for (PhrasePositions pp: nrPps) {\n        if ((end=advanceRepeats(pp, end)) == Integer.MIN_VALUE) {\n          return Integer.MIN_VALUE; // ran out of a term -- done (no valid matches in current doc)\n        }\n      }\n    }\n    \n    //printPositions(System.err, \"Init: 4: Aft advance-repeats\");\n    \n    // build queue from non repeating pps \n    pq.clear();\n    for (PhrasePositions pp: nrPps) {\n      if (pp.position > end) {\n        end = pp.position;\n      }\n      pq.add(pp);\n    }\n    \n    return end;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","sourceNew":"  /**\n   * Initialize PhrasePositions in place.\n   * A one time initialization for this scorer (on first doc matching all terms):\n   * <ul>\n   *  <li>Check if there are repetitions\n   *  <li>If there are, find groups of repetitions.\n   * </ul>\n   * Examples:\n   * <ol>\n   *  <li>no repetitions: <b>\"ho my\"~2</b>\n   *  <li>repetitions: <b>\"ho my my\"~2</b>\n   *  <li>repetitions: <b>\"my ho my\"~2</b>\n   * </ol>\n   * @return false if PPs are exhausted (and so current doc will not be a match) \n   */\n  private boolean initPhrasePositions() throws IOException {\n    end = Integer.MIN_VALUE;\n    if (!checkedRpts) {\n      return initFirstTime();\n    }\n    if (!hasRpts) {\n      initSimple();\n      return true; // PPs available\n    }\n    return initComplex();\n  }\n\n","sourceOld":"  /**\n   * Initialize PhrasePositions in place.\n   * There is a one time initialization for this scorer (taking place at the first doc that matches all terms):\n   * <ul>\n   *  <li>Detect groups of repeating pps: those with same tpPos (tpPos==position in the doc) but different offsets in query.\n   *  <li>For each such group:\n   *  <ul>\n   *   <li>form an inner linked list of the repeating ones.\n   *   <li>propagate all group members but first so that they land on different tpPos().\n   *  </ul>\n   *  <li>Mark whether there are repetitions at all, so that scoring queries with no repetitions has no overhead due to this computation.\n   *  <li>Insert to pq only non repeating PPs, or PPs that are the first in a repeating group.\n   * </ul>\n   * Examples:\n   * <ol>\n   *  <li>no repetitions: <b>\"ho my\"~2</b>\n   *  <li>repetitions: <b>\"ho my my\"~2</b>\n   *  <li>repetitions: <b>\"my ho my\"~2</b>\n   * </ol>\n   * @return end (max position), or Integer.MIN_VALUE if any term ran out (i.e. done) \n   */\n  private int initPhrasePositions() throws IOException {\n    int end = Integer.MIN_VALUE;\n    \n    // no repeats at all (most common case is also the simplest one)\n    if (checkedRepeats && !hasRepeats) {\n      // build queue from list\n      pq.clear();\n      for (PhrasePositions pp=min,prev=null; prev!=max; pp=(prev=pp).next) {  // iterate cyclic list: done once handled max\n        pp.firstPosition();\n        if (pp.position > end) {\n          end = pp.position;\n        }\n        pq.add(pp);         // build pq from list\n      }\n      return end;\n    }\n    \n    //printPositions(System.err, \"Init: 1: Bef position\");\n    \n    // position the pp's\n    for (PhrasePositions pp=min,prev=null; prev!=max; pp=(prev=pp).next) {  // iterate cyclic list: done once handled max  \n      pp.firstPosition();\n    }\n    \n    //printPositions(System.err, \"Init: 2: Aft position\");\n    \n    // one time initialization for this scorer (done only for the first candidate doc)\n    if (!checkedRepeats) {\n      checkedRepeats = true;\n      ArrayList<PhrasePositions> ppsA = new ArrayList<PhrasePositions>();\n      PhrasePositions dummyPP = new PhrasePositions(null, -1, -1);\n      // check for repeats\n      for (PhrasePositions pp=min,prev=null; prev!=max; pp=(prev=pp).next) {  // iterate cyclic list: done once handled max\n        if (pp.nextRepeating != null) {\n          continue; // a repetition of an earlier pp\n        }\n        ppsA.add(pp);\n        int tpPos = tpPos(pp);\n        for (PhrasePositions prevB=pp, pp2=pp.next; pp2!= min; pp2=pp2.next) {\n          if (\n              pp2.nextRepeating != null  // already detected as a repetition of an earlier pp\n              || pp.offset == pp2.offset // not a repetition: the two PPs are originally in same offset in the query! \n              || tpPos(pp2) != tpPos) {  // not a repetition\n            continue; \n          }\n          // a repetition\n          hasRepeats = true;\n          prevB.nextRepeating = pp2;  // add pp2 to the repeats linked list\n          pp2.nextRepeating = dummyPP; // allows not to handle the last pp in a sub-list\n          prevB = pp2;\n        }\n      }\n      if (hasRepeats) {\n        // clean dummy markers\n        for (PhrasePositions pp=min,prev=null; prev!=max; pp=(prev=pp).next) {  // iterate cyclic list: done once handled max\n          if (pp.nextRepeating == dummyPP) {\n            pp.nextRepeating = null;\n          }\n        }\n      }\n      nrPps = ppsA.toArray(new PhrasePositions[0]);\n      pq = new PhraseQueue(nrPps.length);\n    }\n    \n    //printPositions(System.err, \"Init: 3: Aft check-repeats\");\n    \n    // with repeats must advance some repeating pp's so they all start with differing tp's\n    if (hasRepeats) {\n      for (PhrasePositions pp: nrPps) {\n        if ((end=advanceRepeats(pp, end)) == Integer.MIN_VALUE) {\n          return Integer.MIN_VALUE; // ran out of a term -- done (no valid matches in current doc)\n        }\n      }\n    }\n    \n    //printPositions(System.err, \"Init: 4: Aft advance-repeats\");\n    \n    // build queue from non repeating pps \n    pq.clear();\n    for (PhrasePositions pp: nrPps) {\n      if (pp.position > end) {\n        end = pp.position;\n      }\n      pq.add(pp);\n    }\n    \n    return end;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b11b9d5eaf9707760ca5151530830a825197023","date":1525941319,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseMatcher#initPhrasePositions().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","sourceNew":"  /**\n   * Initialize PhrasePositions in place.\n   * A one time initialization for this scorer (on first doc matching all terms):\n   * <ul>\n   *  <li>Check if there are repetitions\n   *  <li>If there are, find groups of repetitions.\n   * </ul>\n   * Examples:\n   * <ol>\n   *  <li>no repetitions: <b>\"ho my\"~2</b>\n   *  <li>repetitions: <b>\"ho my my\"~2</b>\n   *  <li>repetitions: <b>\"my ho my\"~2</b>\n   * </ol>\n   * @return false if PPs are exhausted (and so current doc will not be a match) \n   */\n  private boolean initPhrasePositions() throws IOException {\n    end = Integer.MIN_VALUE;\n    if (!checkedRpts) {\n      return initFirstTime();\n    }\n    if (!hasRpts) {\n      initSimple();\n      return true; // PPs available\n    }\n    return initComplex();\n  }\n\n","sourceOld":"  /**\n   * Initialize PhrasePositions in place.\n   * A one time initialization for this scorer (on first doc matching all terms):\n   * <ul>\n   *  <li>Check if there are repetitions\n   *  <li>If there are, find groups of repetitions.\n   * </ul>\n   * Examples:\n   * <ol>\n   *  <li>no repetitions: <b>\"ho my\"~2</b>\n   *  <li>repetitions: <b>\"ho my my\"~2</b>\n   *  <li>repetitions: <b>\"my ho my\"~2</b>\n   * </ol>\n   * @return false if PPs are exhausted (and so current doc will not be a match) \n   */\n  private boolean initPhrasePositions() throws IOException {\n    end = Integer.MIN_VALUE;\n    if (!checkedRpts) {\n      return initFirstTime();\n    }\n    if (!hasRpts) {\n      initSimple();\n      return true; // PPs available\n    }\n    return initComplex();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"38e3b736c7ca086d61b7dbb841c905ee115490da":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","2eaa5d4d2618a012373ae4574ebb6563933aa9f6"],"2eaa5d4d2618a012373ae4574ebb6563933aa9f6":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3b11b9d5eaf9707760ca5151530830a825197023":["2eaa5d4d2618a012373ae4574ebb6563933aa9f6"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3b11b9d5eaf9707760ca5151530830a825197023"]},"commit2Childs":{"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"2eaa5d4d2618a012373ae4574ebb6563933aa9f6":["38e3b736c7ca086d61b7dbb841c905ee115490da","3b11b9d5eaf9707760ca5151530830a825197023"],"3b11b9d5eaf9707760ca5151530830a825197023":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["38e3b736c7ca086d61b7dbb841c905ee115490da","2eaa5d4d2618a012373ae4574ebb6563933aa9f6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["38e3b736c7ca086d61b7dbb841c905ee115490da","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}