{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/JDBCStream#determineValueSelector(int,ResultSetMetaData).mjava","commits":[{"id":"17361387c1023c3b72fb3bcf3d258318ab54deb7","date":1494596656,"type":0,"author":"jdyer1","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/JDBCStream#determineValueSelector(int,ResultSetMetaData).mjava","pathOld":"/dev/null","sourceNew":"  protected ResultSetValueSelector determineValueSelector(int columnIdx, ResultSetMetaData metadata) throws SQLException {\n    final int columnNumber = columnIdx + 1; // cause it starts at 1\n    // Use getColumnLabel instead of getColumnName to make sure fields renamed with AS as picked up properly\n    final String columnName = metadata.getColumnLabel(columnNumber);\n    final int jdbcType = metadata.getColumnType(columnNumber);      \n    final String className = metadata.getColumnClassName(columnNumber);\n    ResultSetValueSelector valueSelector = null;\n    \n    // Directly supported types can be just directly returned - no conversion really necessary\n    if(directSupportedTypes.contains(className)){\n      valueSelector = new ResultSetValueSelector() {\n        @Override\n        public Object selectValue(ResultSet resultSet) throws SQLException {\n          Object obj = resultSet.getObject(columnNumber);\n          if(resultSet.wasNull()){ return null; }\n          if(obj instanceof String) {\n            String s = (String)obj;\n            if(s.indexOf(sep) > -1) {\n              s = s.substring(1);\n              return s.split(sep);\n            }\n          }\n\n          return obj;\n        }\n        @Override\n        public String getColumnName() {\n          return columnName;\n        }\n      };\n    } \n    // We're checking the Java class names because there are lots of SQL types across\n    // lots of database drivers that can be mapped to standard Java types. Basically, \n    // this makes it easier and we don't have to worry about esoteric type names in the \n    // JDBC family of types\n    else if(Short.class.getName().equals(className)) {\n      valueSelector = new ResultSetValueSelector() {\n        @Override\n        public Object selectValue(ResultSet resultSet) throws SQLException {\n          Short obj = resultSet.getShort(columnNumber);\n          if(resultSet.wasNull()){ return null; }\n          return obj.longValue();\n        }\n        @Override\n        public String getColumnName() {\n          return columnName;\n        }\n      };\n    } else if(Integer.class.getName().equals(className)) {\n      valueSelector = new ResultSetValueSelector() {\n        @Override\n        public Object selectValue(ResultSet resultSet) throws SQLException {\n          Integer obj = resultSet.getInt(columnNumber);\n          if(resultSet.wasNull()){ return null; }\n          return obj.longValue();\n        }\n        @Override\n        public String getColumnName() {\n          return columnName;\n        }\n      };\n    } else if(Float.class.getName().equals(className)) {\n      valueSelector = new ResultSetValueSelector() {\n        @Override\n        public Object selectValue(ResultSet resultSet) throws SQLException {\n          Float obj = resultSet.getFloat(columnNumber);\n          if(resultSet.wasNull()){ return null; }\n          return obj.doubleValue();\n        }\n        @Override\n        public String getColumnName() {\n          return columnName;\n        }\n      };\n    } \n    // Here we are switching to check against the SQL type because date/times are\n    // notorious for not being consistent. We don't know if the driver is mapping\n    // to a java.time.* type or some old-school type. \n    else if (jdbcType == Types.DATE) {\n      valueSelector = new ResultSetValueSelector() {\n        @Override\n        public Object selectValue(ResultSet resultSet) throws SQLException {\n          Date sqlDate = resultSet.getDate(columnNumber);\n          return resultSet.wasNull() ? null : sqlDate.toString();\n        }\n        @Override\n        public String getColumnName() {\n          return columnName;\n        }\n      };\n    } else if (jdbcType == Types.TIME ) {\n      valueSelector = new ResultSetValueSelector() {\n        @Override\n        public Object selectValue(ResultSet resultSet) throws SQLException {\n          Time sqlTime = resultSet.getTime(columnNumber);\n          return resultSet.wasNull() ? null : sqlTime.toString();\n        }\n        @Override\n        public String getColumnName() {\n          return columnName;\n        }\n      };\n    } else if (jdbcType == Types.TIMESTAMP) {\n      valueSelector = new ResultSetValueSelector() {\n        @Override\n        public Object selectValue(ResultSet resultSet) throws SQLException {\n          Timestamp sqlTimestamp = resultSet.getTimestamp(columnNumber);\n          return resultSet.wasNull() ? null : sqlTimestamp.toInstant().toString();\n        }\n        @Override\n        public String getColumnName() {\n          return columnName;\n        }\n      };\n    } \n    // Now we're going to start seeing if things are assignable from the returned type\n    // to a more general type - this allows us to cover cases where something we weren't \n    // explicitly expecting, but can handle, is being returned.\n    else {\n      Class<?> clazz;\n      try {\n        clazz = Class.forName(className, false, getClass().getClassLoader());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n      final int scale = metadata.getScale(columnNumber);\n      if (Number.class.isAssignableFrom(clazz)) {\n        if (scale > 0) {\n          valueSelector = new ResultSetValueSelector() {\n            @Override\n            public Object selectValue(ResultSet resultSet) throws SQLException {\n              BigDecimal bd = resultSet.getBigDecimal(columnNumber);\n              return resultSet.wasNull() ? null : bd.doubleValue();                \n            }\n            @Override\n            public String getColumnName() {\n              return columnName;\n            }\n          };            \n        } else {\n          valueSelector = new ResultSetValueSelector() {\n            @Override\n            public Object selectValue(ResultSet resultSet) throws SQLException {\n              BigDecimal bd = resultSet.getBigDecimal(columnNumber);\n              return resultSet.wasNull() ? null : bd.longValue();\n            }\n            @Override\n            public String getColumnName() {\n              return columnName;\n            }\n          };            \n        }          \n      } else if (Clob.class.isAssignableFrom(clazz)) {\n        valueSelector = new ResultSetValueSelector() {\n          @Override\n          public Object selectValue(ResultSet resultSet) throws SQLException {\n            Clob c = resultSet.getClob(columnNumber);\n            if (resultSet.wasNull()) {\n              return null;\n            }\n            long length = c.length();\n            int lengthInt = (int) length;\n            if (length != lengthInt) {\n              throw new SQLException(String.format(Locale.ROOT,\n                  \"Encountered a clob of length #%l in column '%s' (col #%d).  Max supported length is #%i.\",\n                  length, columnName, columnNumber, Integer.MAX_VALUE));\n            }\n            return c.getSubString(1, lengthInt);\n          }\n          @Override\n          public String getColumnName() {\n            return columnName;\n          }\n        };\n      } \n    }\n    return valueSelector;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/JDBCStream#determineValueSelector(int,ResultSetMetaData).mjava","pathOld":"/dev/null","sourceNew":"  protected ResultSetValueSelector determineValueSelector(int columnIdx, ResultSetMetaData metadata) throws SQLException {\n    final int columnNumber = columnIdx + 1; // cause it starts at 1\n    // Use getColumnLabel instead of getColumnName to make sure fields renamed with AS as picked up properly\n    final String columnName = metadata.getColumnLabel(columnNumber);\n    final int jdbcType = metadata.getColumnType(columnNumber);      \n    final String className = metadata.getColumnClassName(columnNumber);\n    ResultSetValueSelector valueSelector = null;\n    \n    // Directly supported types can be just directly returned - no conversion really necessary\n    if(directSupportedTypes.contains(className)){\n      valueSelector = new ResultSetValueSelector() {\n        @Override\n        public Object selectValue(ResultSet resultSet) throws SQLException {\n          Object obj = resultSet.getObject(columnNumber);\n          if(resultSet.wasNull()){ return null; }\n          if(obj instanceof String) {\n            String s = (String)obj;\n            if(s.indexOf(sep) > -1) {\n              s = s.substring(1);\n              return s.split(sep);\n            }\n          }\n\n          return obj;\n        }\n        @Override\n        public String getColumnName() {\n          return columnName;\n        }\n      };\n    } \n    // We're checking the Java class names because there are lots of SQL types across\n    // lots of database drivers that can be mapped to standard Java types. Basically, \n    // this makes it easier and we don't have to worry about esoteric type names in the \n    // JDBC family of types\n    else if(Short.class.getName().equals(className)) {\n      valueSelector = new ResultSetValueSelector() {\n        @Override\n        public Object selectValue(ResultSet resultSet) throws SQLException {\n          Short obj = resultSet.getShort(columnNumber);\n          if(resultSet.wasNull()){ return null; }\n          return obj.longValue();\n        }\n        @Override\n        public String getColumnName() {\n          return columnName;\n        }\n      };\n    } else if(Integer.class.getName().equals(className)) {\n      valueSelector = new ResultSetValueSelector() {\n        @Override\n        public Object selectValue(ResultSet resultSet) throws SQLException {\n          Integer obj = resultSet.getInt(columnNumber);\n          if(resultSet.wasNull()){ return null; }\n          return obj.longValue();\n        }\n        @Override\n        public String getColumnName() {\n          return columnName;\n        }\n      };\n    } else if(Float.class.getName().equals(className)) {\n      valueSelector = new ResultSetValueSelector() {\n        @Override\n        public Object selectValue(ResultSet resultSet) throws SQLException {\n          Float obj = resultSet.getFloat(columnNumber);\n          if(resultSet.wasNull()){ return null; }\n          return obj.doubleValue();\n        }\n        @Override\n        public String getColumnName() {\n          return columnName;\n        }\n      };\n    } \n    // Here we are switching to check against the SQL type because date/times are\n    // notorious for not being consistent. We don't know if the driver is mapping\n    // to a java.time.* type or some old-school type. \n    else if (jdbcType == Types.DATE) {\n      valueSelector = new ResultSetValueSelector() {\n        @Override\n        public Object selectValue(ResultSet resultSet) throws SQLException {\n          Date sqlDate = resultSet.getDate(columnNumber);\n          return resultSet.wasNull() ? null : sqlDate.toString();\n        }\n        @Override\n        public String getColumnName() {\n          return columnName;\n        }\n      };\n    } else if (jdbcType == Types.TIME ) {\n      valueSelector = new ResultSetValueSelector() {\n        @Override\n        public Object selectValue(ResultSet resultSet) throws SQLException {\n          Time sqlTime = resultSet.getTime(columnNumber);\n          return resultSet.wasNull() ? null : sqlTime.toString();\n        }\n        @Override\n        public String getColumnName() {\n          return columnName;\n        }\n      };\n    } else if (jdbcType == Types.TIMESTAMP) {\n      valueSelector = new ResultSetValueSelector() {\n        @Override\n        public Object selectValue(ResultSet resultSet) throws SQLException {\n          Timestamp sqlTimestamp = resultSet.getTimestamp(columnNumber);\n          return resultSet.wasNull() ? null : sqlTimestamp.toInstant().toString();\n        }\n        @Override\n        public String getColumnName() {\n          return columnName;\n        }\n      };\n    } \n    // Now we're going to start seeing if things are assignable from the returned type\n    // to a more general type - this allows us to cover cases where something we weren't \n    // explicitly expecting, but can handle, is being returned.\n    else {\n      Class<?> clazz;\n      try {\n        clazz = Class.forName(className, false, getClass().getClassLoader());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n      final int scale = metadata.getScale(columnNumber);\n      if (Number.class.isAssignableFrom(clazz)) {\n        if (scale > 0) {\n          valueSelector = new ResultSetValueSelector() {\n            @Override\n            public Object selectValue(ResultSet resultSet) throws SQLException {\n              BigDecimal bd = resultSet.getBigDecimal(columnNumber);\n              return resultSet.wasNull() ? null : bd.doubleValue();                \n            }\n            @Override\n            public String getColumnName() {\n              return columnName;\n            }\n          };            \n        } else {\n          valueSelector = new ResultSetValueSelector() {\n            @Override\n            public Object selectValue(ResultSet resultSet) throws SQLException {\n              BigDecimal bd = resultSet.getBigDecimal(columnNumber);\n              return resultSet.wasNull() ? null : bd.longValue();\n            }\n            @Override\n            public String getColumnName() {\n              return columnName;\n            }\n          };            \n        }          \n      } else if (Clob.class.isAssignableFrom(clazz)) {\n        valueSelector = new ResultSetValueSelector() {\n          @Override\n          public Object selectValue(ResultSet resultSet) throws SQLException {\n            Clob c = resultSet.getClob(columnNumber);\n            if (resultSet.wasNull()) {\n              return null;\n            }\n            long length = c.length();\n            int lengthInt = (int) length;\n            if (length != lengthInt) {\n              throw new SQLException(String.format(Locale.ROOT,\n                  \"Encountered a clob of length #%l in column '%s' (col #%d).  Max supported length is #%i.\",\n                  length, columnName, columnNumber, Integer.MAX_VALUE));\n            }\n            return c.getSubString(1, lengthInt);\n          }\n          @Override\n          public String getColumnName() {\n            return columnName;\n          }\n        };\n      } \n    }\n    return valueSelector;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"17361387c1023c3b72fb3bcf3d258318ab54deb7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","17361387c1023c3b72fb3bcf3d258318ab54deb7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["17361387c1023c3b72fb3bcf3d258318ab54deb7"]},"commit2Childs":{"17361387c1023c3b72fb3bcf3d258318ab54deb7":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["17361387c1023c3b72fb3bcf3d258318ab54deb7","e9017cf144952056066919f1ebc7897ff9bd71b1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}