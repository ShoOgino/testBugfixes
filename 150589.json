{"path":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","commits":[{"id":"a076c3c721f685b7559308fdc2cd72d91bba67e5","date":1464168992,"type":1,"author":"Mike McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e121d43b5a10f2df530f406f935102656e9c4e8","date":1464198131,"type":1,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83870855d82aba6819217abeff5a40779dbb28b4","date":1464291012,"type":1,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":1,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"744b111b17d15d490a648eb021bfa240e7f11556","date":1487008069,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            case SORTED_INTEGER:\n            case SORTED_FLOAT:\n            case SORTED_LONG:\n            case SORTED_DOUBLE:\n              type = DocValuesType.SORTED_NUMERIC;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"022a4de90e0479b604264ca9c2e134c996454ab3","date":1487118265,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            case SORTED_INTEGER:\n            case SORTED_FLOAT:\n            case SORTED_LONG:\n            case SORTED_DOUBLE:\n              type = DocValuesType.SORTED_NUMERIC;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96","date":1487122334,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            case SORTED_INTEGER:\n            case SORTED_FLOAT:\n            case SORTED_LONG:\n            case SORTED_DOUBLE:\n              type = DocValuesType.SORTED_NUMERIC;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"897b06b1364bd1f658a8be7591e43f0851458e7f","date":1487123008,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            case SORTED_INTEGER:\n            case SORTED_FLOAT:\n            case SORTED_LONG:\n            case SORTED_DOUBLE:\n              type = DocValuesType.SORTED_NUMERIC;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":null,"bugIntro":["79900e89f08cc17c4bcf49789dd61a2236ee7840"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"83c8471489eeb663dabdc354a41bea707f560bc9","date":1492417766,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Function)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            case SORTED_INTEGER:\n            case SORTED_FLOAT:\n            case SORTED_LONG:\n            case SORTED_DOUBLE:\n              type = DocValuesType.SORTED_NUMERIC;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            case SORTED_INTEGER:\n            case SORTED_FLOAT:\n            case SORTED_LONG:\n            case SORTED_DOUBLE:\n              type = DocValuesType.SORTED_NUMERIC;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"79900e89f08cc17c4bcf49789dd61a2236ee7840","date":1492541915,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Function)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Function)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            case SORTED_INTEGER:\n            case SORTED_FLOAT:\n            case SORTED_LONG:\n            case SORTED_DOUBLE:\n              type = DocValuesType.SORTED_NUMERIC;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":["897b06b1364bd1f658a8be7591e43f0851458e7f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Function)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Map)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            case SORTED_INTEGER:\n            case SORTED_FLOAT:\n            case SORTED_LONG:\n            case SORTED_DOUBLE:\n              type = DocValuesType.SORTED_NUMERIC;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eeba0a4d0845889a402dd225793d62f009d029c9","date":1527938093,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Function)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes(), fi.isSoftDeletesField()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Function)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab548c8f96022b4780f7500a30b19b4f4a5feeb6","date":1527940044,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Function)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Function)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes(), fi.isSoftDeletesField()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7e4ca6dc9612ff741d8713743e2bccfae5eadac","date":1528093718,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Function)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes(), fi.isSoftDeletesField()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Function)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Function)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes(), fi.isSoftDeletesField()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Function)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","pathOld":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Function)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes(), fi.isSoftDeletesField()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Function)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a07eeba66d4090af0095b50cbd1795a3d6182c1d","date":1538797239,"type":5,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#wrap(LeafReader,Function[String,Type]).mjava","pathOld":"solr/core/src/java/org/apache/solr/uninverting/UninvertingReader#UninvertingReader(LeafReader,Map[String,Type]).mjava","sourceNew":"  /**\n   * Create a new UninvertingReader with the specified mapping, wrapped around the input.  It may be deemed that there\n   * is no mapping to do, in which case the input is returned.\n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Function)} instead.\n   *\n   * @lucene.internal\n   */\n  public static LeafReader wrap(LeafReader in, Function<String, Type> mapping) {\n    boolean wrap = false;\n\n    // Calculate a new FieldInfos that has DocValuesType where we didn't before\n    ArrayList<FieldInfo> newFieldInfos = new ArrayList<>(in.getFieldInfos().size());\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      // fields which currently don't have docValues, but are uninvertable (indexed or points data present)\n      if (type == DocValuesType.NONE &&\n          (fi.getIndexOptions() != IndexOptions.NONE || (fi.getPointNumBytes() > 0 && fi.getPointDimensionCount() == 1))) {\n        Type t = mapping.apply(fi.name); // could definitely return null, thus still can't uninvert it\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      if (type != fi.getDocValuesType()) { // we changed it\n        wrap = true;\n        newFieldInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n            fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n            fi.getPointDimensionCount(), fi.getPointNumBytes(), fi.isSoftDeletesField()));\n      } else {\n        newFieldInfos.add(fi);\n      }\n    }\n    if (!wrap) {\n      return in;\n    } else {\n      FieldInfos fieldInfos = new FieldInfos(newFieldInfos.toArray(new FieldInfo[newFieldInfos.size()]));\n      return new UninvertingReader(in, mapping, fieldInfos);\n    }\n  }\n\n","sourceOld":"  /** \n   * Create a new UninvertingReader with the specified mapping \n   * <p>\n   * Expert: This should almost never be used. Use {@link #wrap(DirectoryReader, Function)}\n   * instead.\n   *  \n   * @lucene.internal\n   */\n  public UninvertingReader(LeafReader in, Map<String,Type> mapping) {\n    super(in);\n    this.mapping = mapping;\n    ArrayList<FieldInfo> filteredInfos = new ArrayList<>();\n    for (FieldInfo fi : in.getFieldInfos()) {\n      DocValuesType type = fi.getDocValuesType();\n      if (type == DocValuesType.NONE) {        \n        Type t = mapping.get(fi.name);\n        if (t != null) {\n          if (t == Type.INTEGER_POINT || t == Type.LONG_POINT || t == Type.FLOAT_POINT || t == Type.DOUBLE_POINT) {\n            // type uses points\n            if (fi.getPointDimensionCount() == 0) {\n              continue;\n            }\n          } else {\n            // type uses inverted index\n            if (fi.getIndexOptions() == IndexOptions.NONE) {\n              continue;\n            }\n          }\n          switch(t) {\n            case INTEGER_POINT:\n            case LONG_POINT:\n            case FLOAT_POINT:\n            case DOUBLE_POINT:\n            case LEGACY_INTEGER:\n            case LEGACY_LONG:\n            case LEGACY_FLOAT:\n            case LEGACY_DOUBLE:\n              type = DocValuesType.NUMERIC;\n              break;\n            case BINARY:\n              type = DocValuesType.BINARY;\n              break;\n            case SORTED:\n              type = DocValuesType.SORTED;\n              break;\n            case SORTED_SET_BINARY:\n            case SORTED_SET_INTEGER:\n            case SORTED_SET_FLOAT:\n            case SORTED_SET_LONG:\n            case SORTED_SET_DOUBLE:\n              type = DocValuesType.SORTED_SET;\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),\n          fi.hasPayloads(), fi.getIndexOptions(), type, fi.getDocValuesGen(), fi.attributes(),\n          fi.getPointDimensionCount(), fi.getPointNumBytes(), fi.isSoftDeletesField()));\n    }\n    fieldInfos = new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["897b06b1364bd1f658a8be7591e43f0851458e7f"],"a076c3c721f685b7559308fdc2cd72d91bba67e5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"897b06b1364bd1f658a8be7591e43f0851458e7f":["b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96"],"0e121d43b5a10f2df530f406f935102656e9c4e8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a076c3c721f685b7559308fdc2cd72d91bba67e5"],"79900e89f08cc17c4bcf49789dd61a2236ee7840":["83c8471489eeb663dabdc354a41bea707f560bc9"],"83870855d82aba6819217abeff5a40779dbb28b4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0e121d43b5a10f2df530f406f935102656e9c4e8"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0e121d43b5a10f2df530f406f935102656e9c4e8"],"b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96":["022a4de90e0479b604264ca9c2e134c996454ab3"],"022a4de90e0479b604264ca9c2e134c996454ab3":["0e121d43b5a10f2df530f406f935102656e9c4e8","744b111b17d15d490a648eb021bfa240e7f11556"],"83c8471489eeb663dabdc354a41bea707f560bc9":["897b06b1364bd1f658a8be7591e43f0851458e7f"],"ab548c8f96022b4780f7500a30b19b4f4a5feeb6":["eeba0a4d0845889a402dd225793d62f009d029c9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["79900e89f08cc17c4bcf49789dd61a2236ee7840","b7e4ca6dc9612ff741d8713743e2bccfae5eadac"],"b7e4ca6dc9612ff741d8713743e2bccfae5eadac":["ab548c8f96022b4780f7500a30b19b4f4a5feeb6"],"eeba0a4d0845889a402dd225793d62f009d029c9":["79900e89f08cc17c4bcf49789dd61a2236ee7840"],"a07eeba66d4090af0095b50cbd1795a3d6182c1d":["b7e4ca6dc9612ff741d8713743e2bccfae5eadac"],"744b111b17d15d490a648eb021bfa240e7f11556":["0e121d43b5a10f2df530f406f935102656e9c4e8"],"f592209545c71895260367152601e9200399776d":["ab548c8f96022b4780f7500a30b19b4f4a5feeb6","b7e4ca6dc9612ff741d8713743e2bccfae5eadac"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a07eeba66d4090af0095b50cbd1795a3d6182c1d"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":[],"a076c3c721f685b7559308fdc2cd72d91bba67e5":["0e121d43b5a10f2df530f406f935102656e9c4e8"],"897b06b1364bd1f658a8be7591e43f0851458e7f":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","83c8471489eeb663dabdc354a41bea707f560bc9"],"0e121d43b5a10f2df530f406f935102656e9c4e8":["83870855d82aba6819217abeff5a40779dbb28b4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","022a4de90e0479b604264ca9c2e134c996454ab3","744b111b17d15d490a648eb021bfa240e7f11556"],"79900e89f08cc17c4bcf49789dd61a2236ee7840":["b70042a8a492f7054d480ccdd2be9796510d4327","eeba0a4d0845889a402dd225793d62f009d029c9"],"83870855d82aba6819217abeff5a40779dbb28b4":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96":["897b06b1364bd1f658a8be7591e43f0851458e7f"],"022a4de90e0479b604264ca9c2e134c996454ab3":["b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96"],"83c8471489eeb663dabdc354a41bea707f560bc9":["79900e89f08cc17c4bcf49789dd61a2236ee7840"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a076c3c721f685b7559308fdc2cd72d91bba67e5","0e121d43b5a10f2df530f406f935102656e9c4e8","83870855d82aba6819217abeff5a40779dbb28b4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"ab548c8f96022b4780f7500a30b19b4f4a5feeb6":["b7e4ca6dc9612ff741d8713743e2bccfae5eadac","f592209545c71895260367152601e9200399776d"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"eeba0a4d0845889a402dd225793d62f009d029c9":["ab548c8f96022b4780f7500a30b19b4f4a5feeb6"],"b7e4ca6dc9612ff741d8713743e2bccfae5eadac":["b70042a8a492f7054d480ccdd2be9796510d4327","a07eeba66d4090af0095b50cbd1795a3d6182c1d","f592209545c71895260367152601e9200399776d"],"a07eeba66d4090af0095b50cbd1795a3d6182c1d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"744b111b17d15d490a648eb021bfa240e7f11556":["022a4de90e0479b604264ca9c2e134c996454ab3"],"f592209545c71895260367152601e9200399776d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","83870855d82aba6819217abeff5a40779dbb28b4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}