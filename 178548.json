{"path":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource,boolean).mjava","commits":[{"id":"ad8024a22d8bd3a09b7f618f41cdfe117ae6fe96","date":1576143009,"type":1,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param                     loader the resource loader\n   * @param name                the configuration name\n   * @param is                  the configuration stream\n   * @param isConfigsetTrusted  false if configset was uploaded using unsecured configset upload API, true otherwise\n   */\n  private SolrConfig(SolrResourceLoader loader, String name, InputSource is, boolean isConfigsetTrusted)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs(isConfigsetTrusted);\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(CaffeineCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(CaffeineCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df724d84dab24a0cc54bec95a8680867adc7f171","date":1576156608,"type":1,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param                     loader the resource loader\n   * @param name                the configuration name\n   * @param is                  the configuration stream\n   * @param isConfigsetTrusted  false if configset was uploaded using unsecured configset upload API, true otherwise\n   */\n  private SolrConfig(SolrResourceLoader loader, String name, InputSource is, boolean isConfigsetTrusted)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs(isConfigsetTrusted);\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(CaffeineCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(CaffeineCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"67e7133ec7a1c6d99481e4b39f8005797f06c5e8","date":1582739245,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource,boolean).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param                     loader the resource loader\n   * @param name                the configuration name\n   * @param is                  the configuration stream\n   * @param isConfigsetTrusted  false if configset was uploaded using unsecured configset upload API, true otherwise\n   */\n  private SolrConfig(SolrResourceLoader loader, String name, InputSource is, boolean isConfigsetTrusted)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs(isConfigsetTrusted);\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(CaffeineCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param                     loader the resource loader\n   * @param name                the configuration name\n   * @param is                  the configuration stream\n   * @param isConfigsetTrusted  false if configset was uploaded using unsecured configset upload API, true otherwise\n   */\n  private SolrConfig(SolrResourceLoader loader, String name, InputSource is, boolean isConfigsetTrusted)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs(isConfigsetTrusted);\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(CaffeineCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3","date":1583932828,"type":5,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,boolean,Properties).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource,boolean).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   * @param loader              the resource loader\n   * @param name                the configuration name\n   * @param isConfigsetTrusted  false if configset was uploaded using unsecured configset upload API, true otherwise\n   * @param substitutableProperties optional properties to substitute into the XML\n   */\n  private SolrConfig(SolrResourceLoader loader, String name, boolean isConfigsetTrusted, Properties substitutableProperties)\n      throws ParserConfigurationException, IOException, SAXException {\n    // insist we have non-null substituteProperties; it might get overlayed\n    super(loader, name, null, \"/config/\", substitutableProperties == null ? new Properties() : substitutableProperties);\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs(loader, isConfigsetTrusted);\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(CaffeineCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param                     loader the resource loader\n   * @param name                the configuration name\n   * @param is                  the configuration stream\n   * @param isConfigsetTrusted  false if configset was uploaded using unsecured configset upload API, true otherwise\n   */\n  private SolrConfig(SolrResourceLoader loader, String name, InputSource is, boolean isConfigsetTrusted)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs(isConfigsetTrusted);\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(CaffeineCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"df724d84dab24a0cc54bec95a8680867adc7f171":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ad8024a22d8bd3a09b7f618f41cdfe117ae6fe96"],"ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3":["67e7133ec7a1c6d99481e4b39f8005797f06c5e8"],"67e7133ec7a1c6d99481e4b39f8005797f06c5e8":["ad8024a22d8bd3a09b7f618f41cdfe117ae6fe96"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ad8024a22d8bd3a09b7f618f41cdfe117ae6fe96":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3"]},"commit2Childs":{"df724d84dab24a0cc54bec95a8680867adc7f171":[],"ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["df724d84dab24a0cc54bec95a8680867adc7f171","ad8024a22d8bd3a09b7f618f41cdfe117ae6fe96"],"67e7133ec7a1c6d99481e4b39f8005797f06c5e8":["ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3"],"ad8024a22d8bd3a09b7f618f41cdfe117ae6fe96":["df724d84dab24a0cc54bec95a8680867adc7f171","67e7133ec7a1c6d99481e4b39f8005797f06c5e8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["df724d84dab24a0cc54bec95a8680867adc7f171","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}