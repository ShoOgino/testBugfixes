{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","commits":[{"id":"9f34c5d933e4285a78285d5ec91cd6b4baf2bb81","date":1343947587,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"/dev/null","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use the other deleteDocument methods\n   *  (e.g., {@link #deleteDocuments(Term)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final AtomicReader reader;\n    if (readerIn instanceof AtomicReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (AtomicReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<AtomicReaderContext> leaves = readerIn.getTopReaderContext().leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentInfoPerCommit info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedDeletesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.getDocCount()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["d743dbdc40bef0a47a5d54d99623ef0c2eb5923e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8fd5be977c105554c6a7b68afcdbc511439723ab","date":1344115570,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"/dev/null","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use the other deleteDocument methods\n   *  (e.g., {@link #deleteDocuments(Term)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final AtomicReader reader;\n    if (readerIn instanceof AtomicReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (AtomicReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<AtomicReaderContext> leaves = readerIn.getTopReaderContext().leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentInfoPerCommit info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedDeletesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.getDocCount()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"/dev/null","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use the other deleteDocument methods\n   *  (e.g., {@link #deleteDocuments(Term)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final AtomicReader reader;\n    if (readerIn instanceof AtomicReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (AtomicReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<AtomicReaderContext> leaves = readerIn.getTopReaderContext().leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentInfoPerCommit info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedDeletesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.getDocCount()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d743dbdc40bef0a47a5d54d99623ef0c2eb5923e","date":1344896544,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use the other deleteDocument methods\n   *  (e.g., {@link #deleteDocuments(Term)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final AtomicReader reader;\n    if (readerIn instanceof AtomicReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (AtomicReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<AtomicReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentInfoPerCommit info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedDeletesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.getDocCount()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","sourceOld":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use the other deleteDocument methods\n   *  (e.g., {@link #deleteDocuments(Term)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final AtomicReader reader;\n    if (readerIn instanceof AtomicReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (AtomicReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<AtomicReaderContext> leaves = readerIn.getTopReaderContext().leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentInfoPerCommit info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedDeletesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.getDocCount()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","bugFix":["9f34c5d933e4285a78285d5ec91cd6b4baf2bb81"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","date":1345029782,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use the other deleteDocument methods\n   *  (e.g., {@link #deleteDocuments(Term)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final AtomicReader reader;\n    if (readerIn instanceof AtomicReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (AtomicReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<AtomicReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentInfoPerCommit info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedDeletesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.getDocCount()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","sourceOld":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use the other deleteDocument methods\n   *  (e.g., {@link #deleteDocuments(Term)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final AtomicReader reader;\n    if (readerIn instanceof AtomicReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (AtomicReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<AtomicReaderContext> leaves = readerIn.getTopReaderContext().leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentInfoPerCommit info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedDeletesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.getDocCount()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3c188105a9aae04f56c24996f98f8333fc825d2e","date":1345031914,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use the other deleteDocument methods\n   *  (e.g., {@link #deleteDocuments(Term)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final AtomicReader reader;\n    if (readerIn instanceof AtomicReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (AtomicReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<AtomicReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentInfoPerCommit info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedDeletesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.getDocCount()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","sourceOld":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use the other deleteDocument methods\n   *  (e.g., {@link #deleteDocuments(Term)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final AtomicReader reader;\n    if (readerIn instanceof AtomicReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (AtomicReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<AtomicReaderContext> leaves = readerIn.getTopReaderContext().leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentInfoPerCommit info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedDeletesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.getDocCount()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1c93396a1df03720cb20e2c2f513a6fa59b21e4c","date":1345032673,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use the other deleteDocument methods\n   *  (e.g., {@link #deleteDocuments(Term)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final AtomicReader reader;\n    if (readerIn instanceof AtomicReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (AtomicReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<AtomicReaderContext> leaves = readerIn.getTopReaderContext().leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentInfoPerCommit info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedDeletesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.getDocCount()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","sourceOld":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use the other deleteDocument methods\n   *  (e.g., {@link #deleteDocuments(Term)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final AtomicReader reader;\n    if (readerIn instanceof AtomicReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (AtomicReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<AtomicReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentInfoPerCommit info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedDeletesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.getDocCount()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b05c56a41b733e02a189c48895922b5bd8c7f3d1","date":1345033322,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use the other deleteDocument methods\n   *  (e.g., {@link #deleteDocuments(Term)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final AtomicReader reader;\n    if (readerIn instanceof AtomicReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (AtomicReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<AtomicReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentInfoPerCommit info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedDeletesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.getDocCount()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","sourceOld":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use the other deleteDocument methods\n   *  (e.g., {@link #deleteDocuments(Term)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final AtomicReader reader;\n    if (readerIn instanceof AtomicReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (AtomicReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<AtomicReaderContext> leaves = readerIn.getTopReaderContext().leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentInfoPerCommit info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedDeletesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.getDocCount()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7fb69741e63408e9caa5d5608a4e0d4001a28966","date":1351700573,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use the other deleteDocument methods\n   *  (e.g., {@link #deleteDocuments(Term)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final AtomicReader reader;\n    if (readerIn instanceof AtomicReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (AtomicReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<AtomicReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentInfoPerCommit info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedDeletesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.getDocCount()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changeCount++;\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","sourceOld":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use the other deleteDocument methods\n   *  (e.g., {@link #deleteDocuments(Term)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final AtomicReader reader;\n    if (readerIn instanceof AtomicReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (AtomicReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<AtomicReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentInfoPerCommit info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedDeletesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.getDocCount()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":["3af8c90c5e965a1a8011e827ab59de734c7dfb79"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3af8c90c5e965a1a8011e827ab59de734c7dfb79","date":1368108782,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use the other deleteDocument methods\n   *  (e.g., {@link #deleteDocuments(Term)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final AtomicReader reader;\n    if (readerIn instanceof AtomicReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (AtomicReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<AtomicReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentInfoPerCommit info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedDeletesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.getDocCount()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","sourceOld":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use the other deleteDocument methods\n   *  (e.g., {@link #deleteDocuments(Term)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final AtomicReader reader;\n    if (readerIn instanceof AtomicReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (AtomicReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<AtomicReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentInfoPerCommit info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedDeletesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.getDocCount()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changeCount++;\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","bugFix":["7fb69741e63408e9caa5d5608a4e0d4001a28966"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","date":1383367127,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use the other deleteDocument methods\n   *  (e.g., {@link #deleteDocuments(Term)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final AtomicReader reader;\n    if (readerIn instanceof AtomicReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (AtomicReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<AtomicReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.getDocCount()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","sourceOld":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use the other deleteDocument methods\n   *  (e.g., {@link #deleteDocuments(Term)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final AtomicReader reader;\n    if (readerIn instanceof AtomicReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (AtomicReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<AtomicReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentInfoPerCommit info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedDeletesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.getDocCount()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c3762f22fc1bf57957efeaf962d3393a5bb1b151","date":1400601035,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final AtomicReader reader;\n    if (readerIn instanceof AtomicReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (AtomicReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<AtomicReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.getDocCount()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","sourceOld":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use the other deleteDocument methods\n   *  (e.g., {@link #deleteDocuments(Term)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final AtomicReader reader;\n    if (readerIn instanceof AtomicReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (AtomicReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<AtomicReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.getDocCount()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7605579001505896d48b07160075a5c8b8e128e","date":1400758727,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final AtomicReader reader;\n    if (readerIn instanceof AtomicReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (AtomicReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<AtomicReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.getDocCount()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","sourceOld":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use the other deleteDocument methods\n   *  (e.g., {@link #deleteDocuments(Term)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final AtomicReader reader;\n    if (readerIn instanceof AtomicReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (AtomicReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<AtomicReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.getDocCount()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.getDocCount()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","sourceOld":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final AtomicReader reader;\n    if (readerIn instanceof AtomicReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (AtomicReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<AtomicReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.getDocCount()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0267c69e2456a3477a1ad785723f2135da3117e","date":1425317087,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.maxDoc()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","sourceOld":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.getDocCount()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b06445ae1731e049327712db0454e5643ca9b7fe","date":1425329139,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.maxDoc()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","sourceOld":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.getDocCount()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.maxDoc()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","sourceOld":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.getDocCount()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a1862266772deb28cdcb7d996b64d2177022687","date":1453077824,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.maxDoc()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","sourceOld":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter,boolean)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.maxDoc()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f6df47cbfd656ea50ca2996361f7954531ee18b","date":1464133540,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns a valid (&gt; 0) sequence\n   *  number; else, it returns -1 and the caller must then\n   *  separately delete by Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized long tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.maxDoc()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n\n          return docWriter.deleteQueue.seqNo.getAndIncrement();\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.maxDoc()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"16ebfabc294f23b88b6a39722a02c9d39b353195","date":1464343867,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns a valid (&gt; 0) sequence\n   *  number; else, it returns -1 and the caller must then\n   *  separately delete by Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized long tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.maxDoc()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n\n          return docWriter.deleteQueue.getNextSequenceNumber();\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns a valid (&gt; 0) sequence\n   *  number; else, it returns -1 and the caller must then\n   *  separately delete by Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized long tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.maxDoc()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n\n          return docWriter.deleteQueue.seqNo.getAndIncrement();\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n\n    return -1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6483e4260c08168709c02238ae083a51519a28dd","date":1465117546,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns a valid (&gt; 0) sequence\n   *  number; else, it returns -1 and the caller must then\n   *  separately delete by Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized long tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.maxDoc()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n\n          return docWriter.deleteQueue.getNextSequenceNumber();\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.maxDoc()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"191128ac5b85671b1671e2c857437694283b6ebf","date":1465297861,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns a valid (&gt; 0) sequence\n   *  number; else, it returns -1 and the caller must then\n   *  separately delete by Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized long tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.maxDoc()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n\n          return docWriter.deleteQueue.getNextSequenceNumber();\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.maxDoc()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"730b7b729dd280f1fec51e6b252f24c4de2a68e1","date":1465891767,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns a valid (&gt; 0) sequence\n   *  number; else, it returns -1 and the caller must then\n   *  separately delete by Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized long tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.maxDoc()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return docWriter.deleteQueue.getNextSequenceNumber();\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns a valid (&gt; 0) sequence\n   *  number; else, it returns -1 and the caller must then\n   *  separately delete by Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized long tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.maxDoc()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n\n          return docWriter.deleteQueue.getNextSequenceNumber();\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n\n    return -1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57dc82c7b33cd580e7ab5179019bc78f3d7f8e79","date":1465913303,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns a valid (&gt; 0) sequence\n   *  number; else, it returns -1 and the caller must then\n   *  separately delete by Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized long tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.maxDoc()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return docWriter.deleteQueue.getNextSequenceNumber();\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns a valid (&gt; 0) sequence\n   *  number; else, it returns -1 and the caller must then\n   *  separately delete by Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized long tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.maxDoc()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n\n          return docWriter.deleteQueue.getNextSequenceNumber();\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n\n    return -1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns a valid (&gt; 0) sequence\n   *  number; else, it returns -1 and the caller must then\n   *  separately delete by Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized long tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.maxDoc()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return docWriter.deleteQueue.getNextSequenceNumber();\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns true; else, it\n   *  returns false the caller must then separately delete by\n   *  Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized boolean tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.maxDoc()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return true;\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4363cd33f6eff7fb4753574a441e2d18c1022a4","date":1498067235,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns a valid (&gt; 0) sequence\n   *  number; else, it returns -1 and the caller must then\n   *  separately delete by Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized long tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.maxDoc()) {\n              dropDeletedSegment(rld.info);\n              checkpoint();\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          return docWriter.deleteQueue.getNextSequenceNumber();\n        }\n      }\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns a valid (&gt; 0) sequence\n   *  number; else, it returns -1 and the caller must then\n   *  separately delete by Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized long tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.maxDoc()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return docWriter.deleteQueue.getNextSequenceNumber();\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n\n    return -1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns a valid (&gt; 0) sequence\n   *  number; else, it returns -1 and the caller must then\n   *  separately delete by Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized long tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.maxDoc()) {\n              dropDeletedSegment(rld.info);\n              checkpoint();\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          return docWriter.deleteQueue.getNextSequenceNumber();\n        }\n      }\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns a valid (&gt; 0) sequence\n   *  number; else, it returns -1 and the caller must then\n   *  separately delete by Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized long tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.maxDoc()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return docWriter.deleteQueue.getNextSequenceNumber();\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n\n    return -1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns a valid (&gt; 0) sequence\n   *  number; else, it returns -1 and the caller must then\n   *  separately delete by Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized long tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.maxDoc()) {\n              dropDeletedSegment(rld.info);\n              checkpoint();\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          return docWriter.deleteQueue.getNextSequenceNumber();\n        }\n      }\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns a valid (&gt; 0) sequence\n   *  number; else, it returns -1 and the caller must then\n   *  separately delete by Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized long tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          rld.initWritableLiveDocs();\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.maxDoc()) {\n              // If a merge has already registered for this\n              // segment, we leave it in the readerPool; the\n              // merge will skip merging it and will then drop\n              // it once it's done:\n              if (!mergingSegments.contains(rld.info)) {\n                segmentInfos.remove(rld.info);\n                readerPool.drop(rld.info);\n                checkpoint();\n              }\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          //System.out.println(\"  yes \" + info.info.name + \" \" + docID);\n          return docWriter.deleteQueue.getNextSequenceNumber();\n        }\n      } else {\n        //System.out.println(\"  no rld \" + info.info.name + \" \" + docID);\n      }\n    } else {\n      //System.out.println(\"  no seg \" + info.info.name + \" \" + docID);\n    }\n\n    return -1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d60c1bb96a28a26d197c36299f7b6c9c5da617a1","date":1522484702,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns a valid (&gt; 0) sequence\n   *  number; else, it returns -1 and the caller must then\n   *  separately delete by Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized long tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          if (rld.delete(docID)) {\n            if (rld.isFullyDeleted()) {\n              dropDeletedSegment(rld.info);\n              checkpoint();\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          return docWriter.deleteQueue.getNextSequenceNumber();\n        }\n      }\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns a valid (&gt; 0) sequence\n   *  number; else, it returns -1 and the caller must then\n   *  separately delete by Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized long tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.maxDoc()) {\n              dropDeletedSegment(rld.info);\n              checkpoint();\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          return docWriter.deleteQueue.getNextSequenceNumber();\n        }\n      }\n    }\n\n    return -1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa5e39259dfd4a68287c824d3b7e1bc9097dc895","date":1522505041,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns a valid (&gt; 0) sequence\n   *  number; else, it returns -1 and the caller must then\n   *  separately delete by Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized long tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          if (rld.delete(docID)) {\n            if (rld.isFullyDeleted()) {\n              dropDeletedSegment(rld.info);\n              checkpoint();\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          return docWriter.deleteQueue.getNextSequenceNumber();\n        }\n      }\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns a valid (&gt; 0) sequence\n   *  number; else, it returns -1 and the caller must then\n   *  separately delete by Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized long tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          if (rld.delete(docID)) {\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            if (fullDelCount == rld.info.info.maxDoc()) {\n              dropDeletedSegment(rld.info);\n              checkpoint();\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          return docWriter.deleteQueue.getNextSequenceNumber();\n        }\n      }\n    }\n\n    return -1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ee0394b8176abd7c90a4be8c05465be1879db79","date":1522842314,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns a valid (&gt; 0) sequence\n   *  number; else, it returns -1 and the caller must then\n   *  separately delete by Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized long tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          if (rld.delete(docID)) {\n            if (isFullyDeleted(rld)) {\n              dropDeletedSegment(rld.info);\n              checkpoint();\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          return docWriter.deleteQueue.getNextSequenceNumber();\n        }\n      }\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns a valid (&gt; 0) sequence\n   *  number; else, it returns -1 and the caller must then\n   *  separately delete by Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized long tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          if (rld.delete(docID)) {\n            if (rld.isFullyDeleted()) {\n              dropDeletedSegment(rld.info);\n              checkpoint();\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          return docWriter.deleteQueue.getNextSequenceNumber();\n        }\n      }\n    }\n\n    return -1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1926100d9b67becc9701c54266fee3ba7878a5f0","date":1524472150,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns a valid (&gt; 0) sequence\n   *  number; else, it returns -1 and the caller must then\n   *  separately delete by Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized long tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = getPooledInstance(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          if (rld.delete(docID)) {\n            if (isFullyDeleted(rld)) {\n              dropDeletedSegment(rld.info);\n              checkpoint();\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          return docWriter.deleteQueue.getNextSequenceNumber();\n        }\n      }\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns a valid (&gt; 0) sequence\n   *  number; else, it returns -1 and the caller must then\n   *  separately delete by Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized long tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = readerPool.get(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          if (rld.delete(docID)) {\n            if (isFullyDeleted(rld)) {\n              dropDeletedSegment(rld.info);\n              checkpoint();\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          return docWriter.deleteQueue.getNextSequenceNumber();\n        }\n      }\n    }\n\n    return -1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0d5f8ee8ea79c9827f54a6484c70bb02f9857dd","date":1525696559,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryDeleteDocument(IndexReader,int).mjava","sourceNew":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns a valid (&gt; 0) sequence\n   *  number; else, it returns -1 and the caller must then\n   *  separately delete by Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized long tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n    // NOTE: DON'T use docID inside the closure\n    return tryModifyDocument(readerIn, docID, (leafDocId, rld) -> {\n      if (rld.delete(leafDocId)) {\n        if (isFullyDeleted(rld)) {\n          dropDeletedSegment(rld.info);\n          checkpoint();\n        }\n\n        // Must bump changeCount so if no other changes\n        // happened, we still commit this change:\n        changed();\n      }\n    });\n  }\n\n","sourceOld":"  /** Expert: attempts to delete by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the delete succeeds and this method returns a valid (&gt; 0) sequence\n   *  number; else, it returns -1 and the caller must then\n   *  separately delete by Term or Query.\n   *\n   *  <b>NOTE</b>: this method can only delete documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to delete documents indexed after opening the NRT\n   *  reader you must use {@link #deleteDocuments(Term...)}). */\n  public synchronized long tryDeleteDocument(IndexReader readerIn, int docID) throws IOException {\n\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n      \n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = getPooledInstance(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          if (rld.delete(docID)) {\n            if (isFullyDeleted(rld)) {\n              dropDeletedSegment(rld.info);\n              checkpoint();\n            }\n\n            // Must bump changeCount so if no other changes\n            // happened, we still commit this change:\n            changed();\n          }\n          return docWriter.deleteQueue.getNextSequenceNumber();\n        }\n      }\n    }\n\n    return -1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["3af8c90c5e965a1a8011e827ab59de734c7dfb79"],"9f34c5d933e4285a78285d5ec91cd6b4baf2bb81":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c3762f22fc1bf57957efeaf962d3393a5bb1b151":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"3c188105a9aae04f56c24996f98f8333fc825d2e":["8fd5be977c105554c6a7b68afcdbc511439723ab"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":["1c93396a1df03720cb20e2c2f513a6fa59b21e4c","d743dbdc40bef0a47a5d54d99623ef0c2eb5923e"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["57dc82c7b33cd580e7ab5179019bc78f3d7f8e79"],"aa5e39259dfd4a68287c824d3b7e1bc9097dc895":["28288370235ed02234a64753cdbf0c6ec096304a","d60c1bb96a28a26d197c36299f7b6c9c5da617a1"],"191128ac5b85671b1671e2c857437694283b6ebf":["2a1862266772deb28cdcb7d996b64d2177022687","6483e4260c08168709c02238ae083a51519a28dd"],"b7605579001505896d48b07160075a5c8b8e128e":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","c3762f22fc1bf57957efeaf962d3393a5bb1b151"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["d6f074e73200c07d54f242d3880a8da5a35ff97b","d743dbdc40bef0a47a5d54d99623ef0c2eb5923e"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["c3762f22fc1bf57957efeaf962d3393a5bb1b151"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["c9fb5f46e264daf5ba3860defe623a89d202dd87","b0267c69e2456a3477a1ad785723f2135da3117e"],"2a1862266772deb28cdcb7d996b64d2177022687":["b0267c69e2456a3477a1ad785723f2135da3117e"],"b06445ae1731e049327712db0454e5643ca9b7fe":["c9fb5f46e264daf5ba3860defe623a89d202dd87","b0267c69e2456a3477a1ad785723f2135da3117e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"57dc82c7b33cd580e7ab5179019bc78f3d7f8e79":["191128ac5b85671b1671e2c857437694283b6ebf","730b7b729dd280f1fec51e6b252f24c4de2a68e1"],"5ee0394b8176abd7c90a4be8c05465be1879db79":["aa5e39259dfd4a68287c824d3b7e1bc9097dc895"],"b0267c69e2456a3477a1ad785723f2135da3117e":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"1c93396a1df03720cb20e2c2f513a6fa59b21e4c":["3c188105a9aae04f56c24996f98f8333fc825d2e"],"730b7b729dd280f1fec51e6b252f24c4de2a68e1":["191128ac5b85671b1671e2c857437694283b6ebf"],"6483e4260c08168709c02238ae083a51519a28dd":["2a1862266772deb28cdcb7d996b64d2177022687","16ebfabc294f23b88b6a39722a02c9d39b353195"],"1926100d9b67becc9701c54266fee3ba7878a5f0":["5ee0394b8176abd7c90a4be8c05465be1879db79"],"d60c1bb96a28a26d197c36299f7b6c9c5da617a1":["28288370235ed02234a64753cdbf0c6ec096304a"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9f34c5d933e4285a78285d5ec91cd6b4baf2bb81"],"16ebfabc294f23b88b6a39722a02c9d39b353195":["0f6df47cbfd656ea50ca2996361f7954531ee18b"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["57dc82c7b33cd580e7ab5179019bc78f3d7f8e79","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"28288370235ed02234a64753cdbf0c6ec096304a":["57dc82c7b33cd580e7ab5179019bc78f3d7f8e79","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["2a1862266772deb28cdcb7d996b64d2177022687","57dc82c7b33cd580e7ab5179019bc78f3d7f8e79"],"c0d5f8ee8ea79c9827f54a6484c70bb02f9857dd":["1926100d9b67becc9701c54266fee3ba7878a5f0"],"3af8c90c5e965a1a8011e827ab59de734c7dfb79":["7fb69741e63408e9caa5d5608a4e0d4001a28966"],"7fb69741e63408e9caa5d5608a4e0d4001a28966":["d743dbdc40bef0a47a5d54d99623ef0c2eb5923e"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9f34c5d933e4285a78285d5ec91cd6b4baf2bb81"],"d743dbdc40bef0a47a5d54d99623ef0c2eb5923e":["9f34c5d933e4285a78285d5ec91cd6b4baf2bb81"],"0f6df47cbfd656ea50ca2996361f7954531ee18b":["2a1862266772deb28cdcb7d996b64d2177022687"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c0d5f8ee8ea79c9827f54a6484c70bb02f9857dd"]},"commit2Childs":{"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["c3762f22fc1bf57957efeaf962d3393a5bb1b151","b7605579001505896d48b07160075a5c8b8e128e"],"9f34c5d933e4285a78285d5ec91cd6b4baf2bb81":["8fd5be977c105554c6a7b68afcdbc511439723ab","d6f074e73200c07d54f242d3880a8da5a35ff97b","d743dbdc40bef0a47a5d54d99623ef0c2eb5923e"],"c3762f22fc1bf57957efeaf962d3393a5bb1b151":["b7605579001505896d48b07160075a5c8b8e128e","c9fb5f46e264daf5ba3860defe623a89d202dd87"],"3c188105a9aae04f56c24996f98f8333fc825d2e":["1c93396a1df03720cb20e2c2f513a6fa59b21e4c"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":[],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"aa5e39259dfd4a68287c824d3b7e1bc9097dc895":["5ee0394b8176abd7c90a4be8c05465be1879db79"],"191128ac5b85671b1671e2c857437694283b6ebf":["57dc82c7b33cd580e7ab5179019bc78f3d7f8e79","730b7b729dd280f1fec51e6b252f24c4de2a68e1"],"b7605579001505896d48b07160075a5c8b8e128e":[],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":[],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe","b0267c69e2456a3477a1ad785723f2135da3117e"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"2a1862266772deb28cdcb7d996b64d2177022687":["191128ac5b85671b1671e2c857437694283b6ebf","6483e4260c08168709c02238ae083a51519a28dd","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0f6df47cbfd656ea50ca2996361f7954531ee18b"],"b06445ae1731e049327712db0454e5643ca9b7fe":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9f34c5d933e4285a78285d5ec91cd6b4baf2bb81","8fd5be977c105554c6a7b68afcdbc511439723ab","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"57dc82c7b33cd580e7ab5179019bc78f3d7f8e79":["f4363cd33f6eff7fb4753574a441e2d18c1022a4","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"b0267c69e2456a3477a1ad785723f2135da3117e":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","2a1862266772deb28cdcb7d996b64d2177022687","b06445ae1731e049327712db0454e5643ca9b7fe"],"5ee0394b8176abd7c90a4be8c05465be1879db79":["1926100d9b67becc9701c54266fee3ba7878a5f0"],"1c93396a1df03720cb20e2c2f513a6fa59b21e4c":["b05c56a41b733e02a189c48895922b5bd8c7f3d1"],"730b7b729dd280f1fec51e6b252f24c4de2a68e1":["57dc82c7b33cd580e7ab5179019bc78f3d7f8e79"],"6483e4260c08168709c02238ae083a51519a28dd":["191128ac5b85671b1671e2c857437694283b6ebf"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["3c188105a9aae04f56c24996f98f8333fc825d2e"],"d60c1bb96a28a26d197c36299f7b6c9c5da617a1":["aa5e39259dfd4a68287c824d3b7e1bc9097dc895"],"1926100d9b67becc9701c54266fee3ba7878a5f0":["c0d5f8ee8ea79c9827f54a6484c70bb02f9857dd"],"16ebfabc294f23b88b6a39722a02c9d39b353195":["6483e4260c08168709c02238ae083a51519a28dd"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["aa5e39259dfd4a68287c824d3b7e1bc9097dc895","d60c1bb96a28a26d197c36299f7b6c9c5da617a1"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"c0d5f8ee8ea79c9827f54a6484c70bb02f9857dd":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3af8c90c5e965a1a8011e827ab59de734c7dfb79":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198"],"7fb69741e63408e9caa5d5608a4e0d4001a28966":["3af8c90c5e965a1a8011e827ab59de734c7dfb79"],"d743dbdc40bef0a47a5d54d99623ef0c2eb5923e":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","7fb69741e63408e9caa5d5608a4e0d4001a28966"],"0f6df47cbfd656ea50ca2996361f7954531ee18b":["16ebfabc294f23b88b6a39722a02c9d39b353195"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","b7605579001505896d48b07160075a5c8b8e128e","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}