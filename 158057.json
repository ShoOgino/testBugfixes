{"path":"lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestNumericQueryParser#beforeClass().mjava","commits":[{"id":"a7e86426ca0513cfc495c3a2c0bb0c7abe03988d","date":1310245513,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestNumericQueryParser#beforeClass().mjava","pathOld":"/dev/null","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random))\n            .setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,NumericField> numericFieldMap = new HashMap<String,NumericField>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericField.DataType type : NumericField.DataType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n      \n      NumericField field = new NumericField(type.name(), PRECISION_STEP,\n          Field.Store.YES, true);\n      \n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n      \n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericField.DataType.LONG));\n    NumericField dateField = new NumericField(DATE_FIELD_NAME, PRECISION_STEP,\n        Field.Store.YES, true);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n\n//  SimpleDateFormat df = new SimpleDateFormat( \n//      \"yyyy.MM.dd G 'at' HH:mm:ss z\", LOCALE.ENGLISH);\n// assumes localized date pattern will have at least year, month, day, hour, minute\n  SimpleDateFormat df = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n      randomDateStyle(random), randomDateStyle(random), LOCALE.ENGLISH);\n  System.out.println(df.toPattern());\n  // most of date pattern do not include era, so we add it here. Also,\n  // sometimes second is not available, we make sure it's present too\n  df.applyPattern(df.toPattern() + \" G s Z yyyy\");\n  df.setTimeZone(TIMEZONE);\n  System.out.println(TIMEZONE);\n  System.out.println(TIMEZONE);\n  System.out.println(TIMEZONE);\n  long l1 = 0;\n  long l2 = -30000;\n  String d1 = df.format(new Date(l1));\n  String d2 = df.format(new Date(l2));\n  long newL1 = df.parse(d1).getTime();\n  long newL2 = df.parse(d2).getTime();\n  \n  System.out.println(l1 + \" => \" + d1 + \" => \" + newL1);\n  System.out.println(l2 + \" => \" + d2 + \" => \" + newL2);\n  \n   \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["a78a90fc9701e511308346ea29f4f5e548bb39fe","fa0f44f887719e97183771e977cfc4bfb485b766","e91b7614171e0a6a82351457c2870d2a0124ba9a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"08cbf46083e5da06462231794b96d24df6712fc9","date":1310445670,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestNumericQueryParser#beforeClass().mjava","pathOld":"lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestNumericQueryParser#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    init();\n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random))\n            .setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,NumericField> numericFieldMap = new HashMap<String,NumericField>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericField.DataType type : NumericField.DataType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n      \n      NumericField field = new NumericField(type.name(), PRECISION_STEP,\n          Field.Store.YES, true);\n      \n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n      \n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericField.DataType.LONG));\n    NumericField dateField = new NumericField(DATE_FIELD_NAME, PRECISION_STEP,\n        Field.Store.YES, true);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n\n//  SimpleDateFormat df = new SimpleDateFormat( \n//      \"yyyy.MM.dd G 'at' HH:mm:ss z\", LOCALE.ENGLISH);\n// assumes localized date pattern will have at least year, month, day, hour, minute\n  SimpleDateFormat df = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n      randomDateStyle(random), randomDateStyle(random), LOCALE.ENGLISH);\n  System.out.println(df.toPattern());\n  // most of date pattern do not include era, so we add it here. Also,\n  // sometimes second is not available, we make sure it's present too\n  df.applyPattern(df.toPattern() + \" G s Z yyyy\");\n  df.setTimeZone(TIMEZONE);\n  System.out.println(TIMEZONE);\n  System.out.println(TIMEZONE);\n  System.out.println(TIMEZONE);\n  long l1 = 0;\n  long l2 = -30000;\n  String d1 = df.format(new Date(l1));\n  String d2 = df.format(new Date(l2));\n  long newL1 = df.parse(d1).getTime();\n  long newL2 = df.parse(d2).getTime();\n  \n  System.out.println(l1 + \" => \" + d1 + \" => \" + newL1);\n  System.out.println(l2 + \" => \" + d2 + \" => \" + newL2);\n  \n   \n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random))\n            .setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,NumericField> numericFieldMap = new HashMap<String,NumericField>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericField.DataType type : NumericField.DataType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n      \n      NumericField field = new NumericField(type.name(), PRECISION_STEP,\n          Field.Store.YES, true);\n      \n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n      \n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericField.DataType.LONG));\n    NumericField dateField = new NumericField(DATE_FIELD_NAME, PRECISION_STEP,\n        Field.Store.YES, true);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n\n//  SimpleDateFormat df = new SimpleDateFormat( \n//      \"yyyy.MM.dd G 'at' HH:mm:ss z\", LOCALE.ENGLISH);\n// assumes localized date pattern will have at least year, month, day, hour, minute\n  SimpleDateFormat df = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n      randomDateStyle(random), randomDateStyle(random), LOCALE.ENGLISH);\n  System.out.println(df.toPattern());\n  // most of date pattern do not include era, so we add it here. Also,\n  // sometimes second is not available, we make sure it's present too\n  df.applyPattern(df.toPattern() + \" G s Z yyyy\");\n  df.setTimeZone(TIMEZONE);\n  System.out.println(TIMEZONE);\n  System.out.println(TIMEZONE);\n  System.out.println(TIMEZONE);\n  long l1 = 0;\n  long l2 = -30000;\n  String d1 = df.format(new Date(l1));\n  String d2 = df.format(new Date(l2));\n  long newL1 = df.parse(d1).getTime();\n  long newL2 = df.parse(d2).getTime();\n  \n  System.out.println(l1 + \" => \" + d1 + \" => \" + newL1);\n  System.out.println(l2 + \" => \" + d2 + \" => \" + newL2);\n  \n   \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cf7d991c51b580d4b7bf2ad583dba058c0a2dd1","date":1310612214,"type":5,"author":"Christopher John Male","isMerge":false,"pathNew":"modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","pathOld":"lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestNumericQueryParser#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    init();\n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random))\n            .setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,NumericField> numericFieldMap = new HashMap<String,NumericField>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericField.DataType type : NumericField.DataType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n      \n      NumericField field = new NumericField(type.name(), PRECISION_STEP,\n          Field.Store.YES, true);\n      \n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n      \n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericField.DataType.LONG));\n    NumericField dateField = new NumericField(DATE_FIELD_NAME, PRECISION_STEP,\n        Field.Store.YES, true);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n\n//  SimpleDateFormat df = new SimpleDateFormat( \n//      \"yyyy.MM.dd G 'at' HH:mm:ss z\", LOCALE.ENGLISH);\n// assumes localized date pattern will have at least year, month, day, hour, minute\n  SimpleDateFormat df = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n      randomDateStyle(random), randomDateStyle(random), LOCALE.ENGLISH);\n  System.out.println(df.toPattern());\n  // most of date pattern do not include era, so we add it here. Also,\n  // sometimes second is not available, we make sure it's present too\n  df.applyPattern(df.toPattern() + \" G s Z yyyy\");\n  df.setTimeZone(TIMEZONE);\n  System.out.println(TIMEZONE);\n  System.out.println(TIMEZONE);\n  System.out.println(TIMEZONE);\n  long l1 = 0;\n  long l2 = -30000;\n  String d1 = df.format(new Date(l1));\n  String d2 = df.format(new Date(l2));\n  long newL1 = df.parse(d1).getTime();\n  long newL2 = df.parse(d2).getTime();\n  \n  System.out.println(l1 + \" => \" + d1 + \" => \" + newL1);\n  System.out.println(l2 + \" => \" + d2 + \" => \" + newL2);\n  \n   \n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    init();\n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random))\n            .setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,NumericField> numericFieldMap = new HashMap<String,NumericField>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericField.DataType type : NumericField.DataType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n      \n      NumericField field = new NumericField(type.name(), PRECISION_STEP,\n          Field.Store.YES, true);\n      \n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n      \n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericField.DataType.LONG));\n    NumericField dateField = new NumericField(DATE_FIELD_NAME, PRECISION_STEP,\n        Field.Store.YES, true);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n\n//  SimpleDateFormat df = new SimpleDateFormat( \n//      \"yyyy.MM.dd G 'at' HH:mm:ss z\", LOCALE.ENGLISH);\n// assumes localized date pattern will have at least year, month, day, hour, minute\n  SimpleDateFormat df = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n      randomDateStyle(random), randomDateStyle(random), LOCALE.ENGLISH);\n  System.out.println(df.toPattern());\n  // most of date pattern do not include era, so we add it here. Also,\n  // sometimes second is not available, we make sure it's present too\n  df.applyPattern(df.toPattern() + \" G s Z yyyy\");\n  df.setTimeZone(TIMEZONE);\n  System.out.println(TIMEZONE);\n  System.out.println(TIMEZONE);\n  System.out.println(TIMEZONE);\n  long l1 = 0;\n  long l2 = -30000;\n  String d1 = df.format(new Date(l1));\n  String d2 = df.format(new Date(l2));\n  long newL1 = df.parse(d1).getTime();\n  long newL2 = df.parse(d2).getTime();\n  \n  System.out.println(l1 + \" => \" + d1 + \" => \" + newL1);\n  System.out.println(l2 + \" => \" + d2 + \" => \" + newL2);\n  \n   \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"4cf7d991c51b580d4b7bf2ad583dba058c0a2dd1":["08cbf46083e5da06462231794b96d24df6712fc9"],"a7e86426ca0513cfc495c3a2c0bb0c7abe03988d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"08cbf46083e5da06462231794b96d24df6712fc9":["a7e86426ca0513cfc495c3a2c0bb0c7abe03988d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4cf7d991c51b580d4b7bf2ad583dba058c0a2dd1"]},"commit2Childs":{"4cf7d991c51b580d4b7bf2ad583dba058c0a2dd1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a7e86426ca0513cfc495c3a2c0bb0c7abe03988d":["08cbf46083e5da06462231794b96d24df6712fc9"],"08cbf46083e5da06462231794b96d24df6712fc9":["4cf7d991c51b580d4b7bf2ad583dba058c0a2dd1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a7e86426ca0513cfc495c3a2c0bb0c7abe03988d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}