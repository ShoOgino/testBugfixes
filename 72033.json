{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/io/graph/GatherNodesStream#read().mjava","commits":[{"id":"afdf6ff5b1319d8ae254212f1203a6233ed3e1dc","date":1461010196,"type":0,"author":"jbernste","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/graph/GatherNodesStream#read().mjava","pathOld":"/dev/null","sourceNew":"  public Tuple read() throws IOException {\n\n    if (out == null) {\n      List<String> joinBatch = new ArrayList();\n      List<Future<List<Tuple>>> futures = new ArrayList();\n      Map<String, Node> level = new HashMap();\n\n      ExecutorService threadPool = null;\n      try {\n        threadPool = ExecutorUtil.newMDCAwareFixedThreadPool(4, new SolrjNamedThreadFactory(\"GatherNodesStream\"));\n\n        Map<String, Node> roots = new HashMap();\n\n        while (true) {\n          Tuple tuple = tupleStream.read();\n          if (tuple.EOF) {\n            if (joinBatch.size() > 0) {\n              JoinRunner joinRunner = new JoinRunner(joinBatch);\n              Future future = threadPool.submit(joinRunner);\n              futures.add(future);\n            }\n            break;\n          }\n\n          String value = tuple.getString(traverseFrom);\n\n          if(traversal.getDepth() == 0) {\n            //This gathers the root nodes\n            //We check to see if there are dupes in the root nodes because root streams may not have been uniqued.\n            String key = collection+\".\"+value;\n            if(!roots.containsKey(key)) {\n              Node node = new Node(value, trackTraversal);\n              if (metrics != null) {\n                List<Metric> _metrics = new ArrayList();\n                for (Metric metric : metrics) {\n                  _metrics.add(metric.newInstance());\n                }\n                node.setMetrics(_metrics);\n              }\n\n              roots.put(key, node);\n            } else {\n              continue;\n            }\n          }\n\n          joinBatch.add(value);\n          if (joinBatch.size() == 400) {\n            JoinRunner joinRunner = new JoinRunner(joinBatch);\n            Future future = threadPool.submit(joinRunner);\n            futures.add(future);\n            joinBatch = new ArrayList();\n          }\n        }\n\n        if(traversal.getDepth() == 0) {\n          traversal.addLevel(roots, collection, traverseFrom);\n        }\n\n        this.traversal.setScatter(scatter);\n\n        if(useDefaultTraversal) {\n          this.trackTraversal = traversal.getTrackTraversal();\n        } else {\n          this.traversal.setTrackTraversal(trackTraversal);\n        }\n\n        for (Future<List<Tuple>> future : futures) {\n          List<Tuple> tuples = future.get();\n          for (Tuple tuple : tuples) {\n            String _traverseTo = tuple.getString(traverseTo);\n            String _gather = tuple.getString(gather);\n            String key = collection + \".\" + _gather;\n            if (!traversal.visited(key, _traverseTo, tuple)) {\n              Node node = level.get(key);\n              if (node != null) {\n                node.add((traversal.getDepth()-1)+\"^\"+_traverseTo, tuple);\n              } else {\n                node = new Node(_gather, trackTraversal);\n                if (metrics != null) {\n                  List<Metric> _metrics = new ArrayList();\n                  for (Metric metric : metrics) {\n                    _metrics.add(metric.newInstance());\n                  }\n                  node.setMetrics(_metrics);\n                }\n                node.add((traversal.getDepth()-1)+\"^\"+_traverseTo, tuple);\n                level.put(key, node);\n              }\n            }\n          }\n        }\n\n        traversal.addLevel(level, collection, gather);\n        out = traversal.iterator();\n      } catch(Exception e) {\n        throw new RuntimeException(e);\n      } finally {\n        threadPool.shutdown();\n      }\n    }\n\n    if (out.hasNext()) {\n      return out.next();\n    } else {\n      Map map = new HashMap();\n      map.put(\"EOF\", true);\n      Tuple tuple = new Tuple(map);\n      return tuple;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e15955b4980562a0c1c81d08654904f3fadb83b","date":1461068916,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/graph/GatherNodesStream#read().mjava","pathOld":"/dev/null","sourceNew":"  public Tuple read() throws IOException {\n\n    if (out == null) {\n      List<String> joinBatch = new ArrayList();\n      List<Future<List<Tuple>>> futures = new ArrayList();\n      Map<String, Node> level = new HashMap();\n\n      ExecutorService threadPool = null;\n      try {\n        threadPool = ExecutorUtil.newMDCAwareFixedThreadPool(4, new SolrjNamedThreadFactory(\"GatherNodesStream\"));\n\n        Map<String, Node> roots = new HashMap();\n\n        while (true) {\n          Tuple tuple = tupleStream.read();\n          if (tuple.EOF) {\n            if (joinBatch.size() > 0) {\n              JoinRunner joinRunner = new JoinRunner(joinBatch);\n              Future future = threadPool.submit(joinRunner);\n              futures.add(future);\n            }\n            break;\n          }\n\n          String value = tuple.getString(traverseFrom);\n\n          if(traversal.getDepth() == 0) {\n            //This gathers the root nodes\n            //We check to see if there are dupes in the root nodes because root streams may not have been uniqued.\n            String key = collection+\".\"+value;\n            if(!roots.containsKey(key)) {\n              Node node = new Node(value, trackTraversal);\n              if (metrics != null) {\n                List<Metric> _metrics = new ArrayList();\n                for (Metric metric : metrics) {\n                  _metrics.add(metric.newInstance());\n                }\n                node.setMetrics(_metrics);\n              }\n\n              roots.put(key, node);\n            } else {\n              continue;\n            }\n          }\n\n          joinBatch.add(value);\n          if (joinBatch.size() == 400) {\n            JoinRunner joinRunner = new JoinRunner(joinBatch);\n            Future future = threadPool.submit(joinRunner);\n            futures.add(future);\n            joinBatch = new ArrayList();\n          }\n        }\n\n        if(traversal.getDepth() == 0) {\n          traversal.addLevel(roots, collection, traverseFrom);\n        }\n\n        this.traversal.setScatter(scatter);\n\n        if(useDefaultTraversal) {\n          this.trackTraversal = traversal.getTrackTraversal();\n        } else {\n          this.traversal.setTrackTraversal(trackTraversal);\n        }\n\n        for (Future<List<Tuple>> future : futures) {\n          List<Tuple> tuples = future.get();\n          for (Tuple tuple : tuples) {\n            String _traverseTo = tuple.getString(traverseTo);\n            String _gather = tuple.getString(gather);\n            String key = collection + \".\" + _gather;\n            if (!traversal.visited(key, _traverseTo, tuple)) {\n              Node node = level.get(key);\n              if (node != null) {\n                node.add((traversal.getDepth()-1)+\"^\"+_traverseTo, tuple);\n              } else {\n                node = new Node(_gather, trackTraversal);\n                if (metrics != null) {\n                  List<Metric> _metrics = new ArrayList();\n                  for (Metric metric : metrics) {\n                    _metrics.add(metric.newInstance());\n                  }\n                  node.setMetrics(_metrics);\n                }\n                node.add((traversal.getDepth()-1)+\"^\"+_traverseTo, tuple);\n                level.put(key, node);\n              }\n            }\n          }\n        }\n\n        traversal.addLevel(level, collection, gather);\n        out = traversal.iterator();\n      } catch(Exception e) {\n        throw new RuntimeException(e);\n      } finally {\n        threadPool.shutdown();\n      }\n    }\n\n    if (out.hasNext()) {\n      return out.next();\n    } else {\n      Map map = new HashMap();\n      map.put(\"EOF\", true);\n      Tuple tuple = new Tuple(map);\n      return tuple;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb03700c9690d16b15fb4f56f6ec36b128fd894e","date":1586745995,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/graph/GatherNodesStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/graph/GatherNodesStream#read().mjava","sourceNew":"  public Tuple read() throws IOException {\n\n    if (out == null) {\n      List<String> joinBatch = new ArrayList();\n      List<Future<List<Tuple>>> futures = new ArrayList();\n      Map<String, Node> level = new HashMap();\n\n      ExecutorService threadPool = null;\n      try {\n        threadPool = ExecutorUtil.newMDCAwareFixedThreadPool(4, new SolrNamedThreadFactory(\"GatherNodesStream\"));\n\n        Map<String, Node> roots = new HashMap();\n\n        while (true) {\n          Tuple tuple = tupleStream.read();\n          if (tuple.EOF) {\n            if (joinBatch.size() > 0) {\n              JoinRunner joinRunner = new JoinRunner(joinBatch);\n              Future future = threadPool.submit(joinRunner);\n              futures.add(future);\n            }\n            break;\n          }\n\n          String value = tuple.getString(traverseFrom);\n\n          if(traversal.getDepth() == 0) {\n            //This gathers the root nodes\n            //We check to see if there are dupes in the root nodes because root streams may not have been uniqued.\n            String key = collection+\".\"+value;\n            if(!roots.containsKey(key)) {\n              Node node = new Node(value, trackTraversal);\n              if (metrics != null) {\n                List<Metric> _metrics = new ArrayList();\n                for (Metric metric : metrics) {\n                  _metrics.add(metric.newInstance());\n                }\n                node.setMetrics(_metrics);\n              }\n\n              roots.put(key, node);\n            } else {\n              continue;\n            }\n          }\n\n          joinBatch.add(value);\n          if (joinBatch.size() == 400) {\n            JoinRunner joinRunner = new JoinRunner(joinBatch);\n            Future future = threadPool.submit(joinRunner);\n            futures.add(future);\n            joinBatch = new ArrayList();\n          }\n        }\n\n        if(traversal.getDepth() == 0) {\n          traversal.addLevel(roots, collection, traverseFrom);\n        }\n\n        this.traversal.setScatter(scatter);\n\n        if(useDefaultTraversal) {\n          this.trackTraversal = traversal.getTrackTraversal();\n        } else {\n          this.traversal.setTrackTraversal(trackTraversal);\n        }\n\n        for (Future<List<Tuple>> future : futures) {\n          List<Tuple> tuples = future.get();\n          for (Tuple tuple : tuples) {\n            String _traverseTo = tuple.getString(traverseTo);\n            String _gather = tuple.getString(gather);\n            String key = collection + \".\" + _gather;\n            if (!traversal.visited(key, _traverseTo, tuple)) {\n              Node node = level.get(key);\n              if (node != null) {\n                node.add((traversal.getDepth()-1)+\"^\"+_traverseTo, tuple);\n              } else {\n                node = new Node(_gather, trackTraversal);\n                if (metrics != null) {\n                  List<Metric> _metrics = new ArrayList();\n                  for (Metric metric : metrics) {\n                    _metrics.add(metric.newInstance());\n                  }\n                  node.setMetrics(_metrics);\n                }\n                node.add((traversal.getDepth()-1)+\"^\"+_traverseTo, tuple);\n                level.put(key, node);\n              }\n            }\n          }\n        }\n\n        traversal.addLevel(level, collection, gather);\n        out = traversal.iterator();\n      } catch(Exception e) {\n        throw new RuntimeException(e);\n      } finally {\n        threadPool.shutdown();\n      }\n    }\n\n    if (out.hasNext()) {\n      return out.next();\n    } else {\n      Map map = new HashMap();\n      map.put(\"EOF\", true);\n      Tuple tuple = new Tuple(map);\n      return tuple;\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n\n    if (out == null) {\n      List<String> joinBatch = new ArrayList();\n      List<Future<List<Tuple>>> futures = new ArrayList();\n      Map<String, Node> level = new HashMap();\n\n      ExecutorService threadPool = null;\n      try {\n        threadPool = ExecutorUtil.newMDCAwareFixedThreadPool(4, new SolrjNamedThreadFactory(\"GatherNodesStream\"));\n\n        Map<String, Node> roots = new HashMap();\n\n        while (true) {\n          Tuple tuple = tupleStream.read();\n          if (tuple.EOF) {\n            if (joinBatch.size() > 0) {\n              JoinRunner joinRunner = new JoinRunner(joinBatch);\n              Future future = threadPool.submit(joinRunner);\n              futures.add(future);\n            }\n            break;\n          }\n\n          String value = tuple.getString(traverseFrom);\n\n          if(traversal.getDepth() == 0) {\n            //This gathers the root nodes\n            //We check to see if there are dupes in the root nodes because root streams may not have been uniqued.\n            String key = collection+\".\"+value;\n            if(!roots.containsKey(key)) {\n              Node node = new Node(value, trackTraversal);\n              if (metrics != null) {\n                List<Metric> _metrics = new ArrayList();\n                for (Metric metric : metrics) {\n                  _metrics.add(metric.newInstance());\n                }\n                node.setMetrics(_metrics);\n              }\n\n              roots.put(key, node);\n            } else {\n              continue;\n            }\n          }\n\n          joinBatch.add(value);\n          if (joinBatch.size() == 400) {\n            JoinRunner joinRunner = new JoinRunner(joinBatch);\n            Future future = threadPool.submit(joinRunner);\n            futures.add(future);\n            joinBatch = new ArrayList();\n          }\n        }\n\n        if(traversal.getDepth() == 0) {\n          traversal.addLevel(roots, collection, traverseFrom);\n        }\n\n        this.traversal.setScatter(scatter);\n\n        if(useDefaultTraversal) {\n          this.trackTraversal = traversal.getTrackTraversal();\n        } else {\n          this.traversal.setTrackTraversal(trackTraversal);\n        }\n\n        for (Future<List<Tuple>> future : futures) {\n          List<Tuple> tuples = future.get();\n          for (Tuple tuple : tuples) {\n            String _traverseTo = tuple.getString(traverseTo);\n            String _gather = tuple.getString(gather);\n            String key = collection + \".\" + _gather;\n            if (!traversal.visited(key, _traverseTo, tuple)) {\n              Node node = level.get(key);\n              if (node != null) {\n                node.add((traversal.getDepth()-1)+\"^\"+_traverseTo, tuple);\n              } else {\n                node = new Node(_gather, trackTraversal);\n                if (metrics != null) {\n                  List<Metric> _metrics = new ArrayList();\n                  for (Metric metric : metrics) {\n                    _metrics.add(metric.newInstance());\n                  }\n                  node.setMetrics(_metrics);\n                }\n                node.add((traversal.getDepth()-1)+\"^\"+_traverseTo, tuple);\n                level.put(key, node);\n              }\n            }\n          }\n        }\n\n        traversal.addLevel(level, collection, gather);\n        out = traversal.iterator();\n      } catch(Exception e) {\n        throw new RuntimeException(e);\n      } finally {\n        threadPool.shutdown();\n      }\n    }\n\n    if (out.hasNext()) {\n      return out.next();\n    } else {\n      Map map = new HashMap();\n      map.put(\"EOF\", true);\n      Tuple tuple = new Tuple(map);\n      return tuple;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"804a8d5358fe7b7563b85ee7838714d720b89272","date":1591624987,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/graph/GatherNodesStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/graph/GatherNodesStream#read().mjava","sourceNew":"  public Tuple read() throws IOException {\n\n    if (out == null) {\n      List<String> joinBatch = new ArrayList();\n      List<Future<List<Tuple>>> futures = new ArrayList();\n      Map<String, Node> level = new HashMap();\n\n      ExecutorService threadPool = null;\n      try {\n        threadPool = ExecutorUtil.newMDCAwareFixedThreadPool(4, new SolrNamedThreadFactory(\"GatherNodesStream\"));\n\n        Map<String, Node> roots = new HashMap();\n\n        while (true) {\n          Tuple tuple = tupleStream.read();\n          if (tuple.EOF) {\n            if (joinBatch.size() > 0) {\n              JoinRunner joinRunner = new JoinRunner(joinBatch);\n              Future future = threadPool.submit(joinRunner);\n              futures.add(future);\n            }\n            break;\n          }\n\n          String value = tuple.getString(traverseFrom);\n\n          if(traversal.getDepth() == 0) {\n            //This gathers the root nodes\n            //We check to see if there are dupes in the root nodes because root streams may not have been uniqued.\n            String key = collection+\".\"+value;\n            if(!roots.containsKey(key)) {\n              Node node = new Node(value, trackTraversal);\n              if (metrics != null) {\n                List<Metric> _metrics = new ArrayList();\n                for (Metric metric : metrics) {\n                  _metrics.add(metric.newInstance());\n                }\n                node.setMetrics(_metrics);\n              }\n\n              roots.put(key, node);\n            } else {\n              continue;\n            }\n          }\n\n          joinBatch.add(value);\n          if (joinBatch.size() == 400) {\n            JoinRunner joinRunner = new JoinRunner(joinBatch);\n            Future future = threadPool.submit(joinRunner);\n            futures.add(future);\n            joinBatch = new ArrayList();\n          }\n        }\n\n        if(traversal.getDepth() == 0) {\n          traversal.addLevel(roots, collection, traverseFrom);\n        }\n\n        this.traversal.setScatter(scatter);\n\n        if(useDefaultTraversal) {\n          this.trackTraversal = traversal.getTrackTraversal();\n        } else {\n          this.traversal.setTrackTraversal(trackTraversal);\n        }\n\n        for (Future<List<Tuple>> future : futures) {\n          List<Tuple> tuples = future.get();\n          for (Tuple tuple : tuples) {\n            String _traverseTo = tuple.getString(traverseTo);\n            String _gather = tuple.getString(gather);\n            String key = collection + \".\" + _gather;\n            if (!traversal.visited(key, _traverseTo, tuple)) {\n              Node node = level.get(key);\n              if (node != null) {\n                node.add((traversal.getDepth()-1)+\"^\"+_traverseTo, tuple);\n              } else {\n                node = new Node(_gather, trackTraversal);\n                if (metrics != null) {\n                  List<Metric> _metrics = new ArrayList();\n                  for (Metric metric : metrics) {\n                    _metrics.add(metric.newInstance());\n                  }\n                  node.setMetrics(_metrics);\n                }\n                node.add((traversal.getDepth()-1)+\"^\"+_traverseTo, tuple);\n                level.put(key, node);\n              }\n            }\n          }\n        }\n\n        traversal.addLevel(level, collection, gather);\n        out = traversal.iterator();\n      } catch(Exception e) {\n        throw new RuntimeException(e);\n      } finally {\n        threadPool.shutdown();\n      }\n    }\n\n    if (out.hasNext()) {\n      return out.next();\n    } else {\n      return Tuple.EOF();\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n\n    if (out == null) {\n      List<String> joinBatch = new ArrayList();\n      List<Future<List<Tuple>>> futures = new ArrayList();\n      Map<String, Node> level = new HashMap();\n\n      ExecutorService threadPool = null;\n      try {\n        threadPool = ExecutorUtil.newMDCAwareFixedThreadPool(4, new SolrNamedThreadFactory(\"GatherNodesStream\"));\n\n        Map<String, Node> roots = new HashMap();\n\n        while (true) {\n          Tuple tuple = tupleStream.read();\n          if (tuple.EOF) {\n            if (joinBatch.size() > 0) {\n              JoinRunner joinRunner = new JoinRunner(joinBatch);\n              Future future = threadPool.submit(joinRunner);\n              futures.add(future);\n            }\n            break;\n          }\n\n          String value = tuple.getString(traverseFrom);\n\n          if(traversal.getDepth() == 0) {\n            //This gathers the root nodes\n            //We check to see if there are dupes in the root nodes because root streams may not have been uniqued.\n            String key = collection+\".\"+value;\n            if(!roots.containsKey(key)) {\n              Node node = new Node(value, trackTraversal);\n              if (metrics != null) {\n                List<Metric> _metrics = new ArrayList();\n                for (Metric metric : metrics) {\n                  _metrics.add(metric.newInstance());\n                }\n                node.setMetrics(_metrics);\n              }\n\n              roots.put(key, node);\n            } else {\n              continue;\n            }\n          }\n\n          joinBatch.add(value);\n          if (joinBatch.size() == 400) {\n            JoinRunner joinRunner = new JoinRunner(joinBatch);\n            Future future = threadPool.submit(joinRunner);\n            futures.add(future);\n            joinBatch = new ArrayList();\n          }\n        }\n\n        if(traversal.getDepth() == 0) {\n          traversal.addLevel(roots, collection, traverseFrom);\n        }\n\n        this.traversal.setScatter(scatter);\n\n        if(useDefaultTraversal) {\n          this.trackTraversal = traversal.getTrackTraversal();\n        } else {\n          this.traversal.setTrackTraversal(trackTraversal);\n        }\n\n        for (Future<List<Tuple>> future : futures) {\n          List<Tuple> tuples = future.get();\n          for (Tuple tuple : tuples) {\n            String _traverseTo = tuple.getString(traverseTo);\n            String _gather = tuple.getString(gather);\n            String key = collection + \".\" + _gather;\n            if (!traversal.visited(key, _traverseTo, tuple)) {\n              Node node = level.get(key);\n              if (node != null) {\n                node.add((traversal.getDepth()-1)+\"^\"+_traverseTo, tuple);\n              } else {\n                node = new Node(_gather, trackTraversal);\n                if (metrics != null) {\n                  List<Metric> _metrics = new ArrayList();\n                  for (Metric metric : metrics) {\n                    _metrics.add(metric.newInstance());\n                  }\n                  node.setMetrics(_metrics);\n                }\n                node.add((traversal.getDepth()-1)+\"^\"+_traverseTo, tuple);\n                level.put(key, node);\n              }\n            }\n          }\n        }\n\n        traversal.addLevel(level, collection, gather);\n        out = traversal.iterator();\n      } catch(Exception e) {\n        throw new RuntimeException(e);\n      } finally {\n        threadPool.shutdown();\n      }\n    }\n\n    if (out.hasNext()) {\n      return out.next();\n    } else {\n      Map map = new HashMap();\n      map.put(\"EOF\", true);\n      Tuple tuple = new Tuple(map);\n      return tuple;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d","date":1592006776,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/graph/GatherNodesStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/graph/GatherNodesStream#read().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  public Tuple read() throws IOException {\n\n    if (out == null) {\n      List<String> joinBatch = new ArrayList<>();\n      List<Future<List<Tuple>>> futures = new ArrayList<>();\n      Map<String, Node> level = new HashMap<>();\n\n      ExecutorService threadPool = null;\n      try {\n        threadPool = ExecutorUtil.newMDCAwareFixedThreadPool(4, new SolrNamedThreadFactory(\"GatherNodesStream\"));\n\n        Map<String, Node> roots = new HashMap<>();\n\n        while (true) {\n          Tuple tuple = tupleStream.read();\n          if (tuple.EOF) {\n            if (joinBatch.size() > 0) {\n              JoinRunner joinRunner = new JoinRunner(joinBatch);\n              @SuppressWarnings({\"rawtypes\"})\n              Future future = threadPool.submit(joinRunner);\n              futures.add(future);\n            }\n            break;\n          }\n\n          String value = tuple.getString(traverseFrom);\n\n          if(traversal.getDepth() == 0) {\n            //This gathers the root nodes\n            //We check to see if there are dupes in the root nodes because root streams may not have been uniqued.\n            String key = collection+\".\"+value;\n            if(!roots.containsKey(key)) {\n              Node node = new Node(value, trackTraversal);\n              if (metrics != null) {\n                List<Metric> _metrics = new ArrayList<>();\n                for (Metric metric : metrics) {\n                  _metrics.add(metric.newInstance());\n                }\n                node.setMetrics(_metrics);\n              }\n\n              roots.put(key, node);\n            } else {\n              continue;\n            }\n          }\n\n          joinBatch.add(value);\n          if (joinBatch.size() == 400) {\n            JoinRunner joinRunner = new JoinRunner(joinBatch);\n            @SuppressWarnings({\"rawtypes\"})\n            Future future = threadPool.submit(joinRunner);\n            futures.add(future);\n            joinBatch = new ArrayList<>();\n          }\n        }\n\n        if(traversal.getDepth() == 0) {\n          traversal.addLevel(roots, collection, traverseFrom);\n        }\n\n        this.traversal.setScatter(scatter);\n\n        if(useDefaultTraversal) {\n          this.trackTraversal = traversal.getTrackTraversal();\n        } else {\n          this.traversal.setTrackTraversal(trackTraversal);\n        }\n\n        for (Future<List<Tuple>> future : futures) {\n          List<Tuple> tuples = future.get();\n          for (Tuple tuple : tuples) {\n            String _traverseTo = tuple.getString(traverseTo);\n            String _gather = tuple.getString(gather);\n            String key = collection + \".\" + _gather;\n            if (!traversal.visited(key, _traverseTo, tuple)) {\n              Node node = level.get(key);\n              if (node != null) {\n                node.add((traversal.getDepth()-1)+\"^\"+_traverseTo, tuple);\n              } else {\n                node = new Node(_gather, trackTraversal);\n                if (metrics != null) {\n                  List<Metric> _metrics = new ArrayList<>();\n                  for (Metric metric : metrics) {\n                    _metrics.add(metric.newInstance());\n                  }\n                  node.setMetrics(_metrics);\n                }\n                node.add((traversal.getDepth()-1)+\"^\"+_traverseTo, tuple);\n                level.put(key, node);\n              }\n            }\n          }\n        }\n\n        traversal.addLevel(level, collection, gather);\n        out = traversal.iterator();\n      } catch(Exception e) {\n        throw new RuntimeException(e);\n      } finally {\n        threadPool.shutdown();\n      }\n    }\n\n    if (out.hasNext()) {\n      return out.next();\n    } else {\n      return Tuple.EOF();\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n\n    if (out == null) {\n      List<String> joinBatch = new ArrayList();\n      List<Future<List<Tuple>>> futures = new ArrayList();\n      Map<String, Node> level = new HashMap();\n\n      ExecutorService threadPool = null;\n      try {\n        threadPool = ExecutorUtil.newMDCAwareFixedThreadPool(4, new SolrNamedThreadFactory(\"GatherNodesStream\"));\n\n        Map<String, Node> roots = new HashMap();\n\n        while (true) {\n          Tuple tuple = tupleStream.read();\n          if (tuple.EOF) {\n            if (joinBatch.size() > 0) {\n              JoinRunner joinRunner = new JoinRunner(joinBatch);\n              Future future = threadPool.submit(joinRunner);\n              futures.add(future);\n            }\n            break;\n          }\n\n          String value = tuple.getString(traverseFrom);\n\n          if(traversal.getDepth() == 0) {\n            //This gathers the root nodes\n            //We check to see if there are dupes in the root nodes because root streams may not have been uniqued.\n            String key = collection+\".\"+value;\n            if(!roots.containsKey(key)) {\n              Node node = new Node(value, trackTraversal);\n              if (metrics != null) {\n                List<Metric> _metrics = new ArrayList();\n                for (Metric metric : metrics) {\n                  _metrics.add(metric.newInstance());\n                }\n                node.setMetrics(_metrics);\n              }\n\n              roots.put(key, node);\n            } else {\n              continue;\n            }\n          }\n\n          joinBatch.add(value);\n          if (joinBatch.size() == 400) {\n            JoinRunner joinRunner = new JoinRunner(joinBatch);\n            Future future = threadPool.submit(joinRunner);\n            futures.add(future);\n            joinBatch = new ArrayList();\n          }\n        }\n\n        if(traversal.getDepth() == 0) {\n          traversal.addLevel(roots, collection, traverseFrom);\n        }\n\n        this.traversal.setScatter(scatter);\n\n        if(useDefaultTraversal) {\n          this.trackTraversal = traversal.getTrackTraversal();\n        } else {\n          this.traversal.setTrackTraversal(trackTraversal);\n        }\n\n        for (Future<List<Tuple>> future : futures) {\n          List<Tuple> tuples = future.get();\n          for (Tuple tuple : tuples) {\n            String _traverseTo = tuple.getString(traverseTo);\n            String _gather = tuple.getString(gather);\n            String key = collection + \".\" + _gather;\n            if (!traversal.visited(key, _traverseTo, tuple)) {\n              Node node = level.get(key);\n              if (node != null) {\n                node.add((traversal.getDepth()-1)+\"^\"+_traverseTo, tuple);\n              } else {\n                node = new Node(_gather, trackTraversal);\n                if (metrics != null) {\n                  List<Metric> _metrics = new ArrayList();\n                  for (Metric metric : metrics) {\n                    _metrics.add(metric.newInstance());\n                  }\n                  node.setMetrics(_metrics);\n                }\n                node.add((traversal.getDepth()-1)+\"^\"+_traverseTo, tuple);\n                level.put(key, node);\n              }\n            }\n          }\n        }\n\n        traversal.addLevel(level, collection, gather);\n        out = traversal.iterator();\n      } catch(Exception e) {\n        throw new RuntimeException(e);\n      } finally {\n        threadPool.shutdown();\n      }\n    }\n\n    if (out.hasNext()) {\n      return out.next();\n    } else {\n      return Tuple.EOF();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"afdf6ff5b1319d8ae254212f1203a6233ed3e1dc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d":["804a8d5358fe7b7563b85ee7838714d720b89272"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["0e15955b4980562a0c1c81d08654904f3fadb83b"],"0e15955b4980562a0c1c81d08654904f3fadb83b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","afdf6ff5b1319d8ae254212f1203a6233ed3e1dc"],"804a8d5358fe7b7563b85ee7838714d720b89272":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d"]},"commit2Childs":{"afdf6ff5b1319d8ae254212f1203a6233ed3e1dc":["0e15955b4980562a0c1c81d08654904f3fadb83b"],"0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["afdf6ff5b1319d8ae254212f1203a6233ed3e1dc","0e15955b4980562a0c1c81d08654904f3fadb83b"],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["804a8d5358fe7b7563b85ee7838714d720b89272"],"0e15955b4980562a0c1c81d08654904f3fadb83b":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"],"804a8d5358fe7b7563b85ee7838714d720b89272":["0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}