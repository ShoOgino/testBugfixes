{"path":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float).mjava","commits":[{"id":"1774e2854ef0f77de7f31ba1d9586139928e06fe","date":1285965652,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float).mjava","pathOld":"/dev/null","sourceNew":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy) throws IOException {\n    \n    FuzzyTermsEnum e = new FuzzyTermsEnum(ir, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    MultiTermQuery.BoostAttribute boostAtt =\n      e.attributes().addAttribute(MultiTermQuery.BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      boostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"33a8b1f99104f4144f210f5d068411c297cd7163","date":1287152748,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float).mjava","pathOld":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float).mjava","sourceNew":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MultiTermQuery.MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MultiTermQuery.MaxNonCompetitiveBoostAttribute.class);\n    FuzzyTermsEnum e = new FuzzyTermsEnum(ir, atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    MultiTermQuery.BoostAttribute boostAtt =\n      e.attributes().addAttribute(MultiTermQuery.BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy) throws IOException {\n    \n    FuzzyTermsEnum e = new FuzzyTermsEnum(ir, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    MultiTermQuery.BoostAttribute boostAtt =\n      e.attributes().addAttribute(MultiTermQuery.BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      boostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ecea1664e8617d82eca3b8055a3c37cb4da8511","date":1287578668,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float).mjava","pathOld":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float).mjava","sourceNew":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MultiTermQuery.MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MultiTermQuery.MaxNonCompetitiveBoostAttribute.class);\n    FuzzyTermsEnum e = new FuzzyTermsEnum(ir, atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    MultiTermQuery.BoostAttribute boostAtt =\n      e.attributes().addAttribute(MultiTermQuery.BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy) throws IOException {\n    \n    FuzzyTermsEnum e = new FuzzyTermsEnum(ir, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    MultiTermQuery.BoostAttribute boostAtt =\n      e.attributes().addAttribute(MultiTermQuery.BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      boostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"744486748bc5bee772100e49230e5bca39bac99a","date":1289776426,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float).mjava","pathOld":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float).mjava","sourceNew":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    FuzzyTermsEnum e = new FuzzyTermsEnum(ir, atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MultiTermQuery.MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MultiTermQuery.MaxNonCompetitiveBoostAttribute.class);\n    FuzzyTermsEnum e = new FuzzyTermsEnum(ir, atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    MultiTermQuery.BoostAttribute boostAtt =\n      e.attributes().addAttribute(MultiTermQuery.BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ab1f5591dc05f1f2b5407d809c9699f75554a32","date":1290008586,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float).mjava","pathOld":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float).mjava","sourceNew":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    FuzzyTermsEnum e = new FuzzyTermsEnum(ir, atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MultiTermQuery.MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MultiTermQuery.MaxNonCompetitiveBoostAttribute.class);\n    FuzzyTermsEnum e = new FuzzyTermsEnum(ir, atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    MultiTermQuery.BoostAttribute boostAtt =\n      e.attributes().addAttribute(MultiTermQuery.BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e8dd2a69747e9f2922fd8b6970bd1661b26a692d","date":1291080135,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float).mjava","pathOld":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float).mjava","sourceNew":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    FuzzyTermsEnum e = new FuzzyTermsEnum(MultiFields.getTerms(ir, term.field()).iterator(), atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    FuzzyTermsEnum e = new FuzzyTermsEnum(ir, atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":["b78fd44c119574bf1529f13e122a1ecfea5f83c0","b78fd44c119574bf1529f13e122a1ecfea5f83c0","b78fd44c119574bf1529f13e122a1ecfea5f83c0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3bb13258feba31ab676502787ab2e1779f129b7a","date":1291596436,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float).mjava","pathOld":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float).mjava","sourceNew":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    FuzzyTermsEnum e = new FuzzyTermsEnum(MultiFields.getTerms(ir, term.field()).iterator(), atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    FuzzyTermsEnum e = new FuzzyTermsEnum(ir, atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float).mjava","pathOld":"/dev/null","sourceNew":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    FuzzyTermsEnum e = new FuzzyTermsEnum(MultiFields.getTerms(ir, term.field()).iterator(), atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e230a61047bc041516c811baa08a7174d6f8322a","date":1306175633,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float).mjava","pathOld":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float).mjava","sourceNew":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    FuzzyTermsEnum e = new FuzzyTermsEnum(MultiFields.getTerms(ir, term.field()).iterator(), atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    FuzzyTermsEnum e = new FuzzyTermsEnum(MultiFields.getTerms(ir, term.field()).iterator(), atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","pathOld":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float).mjava","sourceNew":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy, final CharsRef spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    FuzzyTermsEnum e = new FuzzyTermsEnum(MultiFields.getTerms(ir, term.field()).iterator(), atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToChars(spare).toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    FuzzyTermsEnum e = new FuzzyTermsEnum(MultiFields.getTerms(ir, term.field()).iterator(), atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e10cb22a8bdb44339e282925a29182bb2f3174d","date":1306841137,"type":5,"author":"Simon Willnauer","isMerge":true,"pathNew":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","pathOld":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float).mjava","sourceNew":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy, final CharsRef spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    FuzzyTermsEnum e = new FuzzyTermsEnum(MultiFields.getTerms(ir, term.field()).iterator(), atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToChars(spare).toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    FuzzyTermsEnum e = new FuzzyTermsEnum(MultiFields.getTerms(ir, term.field()).iterator(), atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9ab1f5591dc05f1f2b5407d809c9699f75554a32":["4ecea1664e8617d82eca3b8055a3c37cb4da8511","744486748bc5bee772100e49230e5bca39bac99a"],"e230a61047bc041516c811baa08a7174d6f8322a":["e8dd2a69747e9f2922fd8b6970bd1661b26a692d"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e8dd2a69747e9f2922fd8b6970bd1661b26a692d"],"33a8b1f99104f4144f210f5d068411c297cd7163":["1774e2854ef0f77de7f31ba1d9586139928e06fe"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["e8dd2a69747e9f2922fd8b6970bd1661b26a692d","e230a61047bc041516c811baa08a7174d6f8322a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1774e2854ef0f77de7f31ba1d9586139928e06fe":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4ecea1664e8617d82eca3b8055a3c37cb4da8511":["1774e2854ef0f77de7f31ba1d9586139928e06fe","33a8b1f99104f4144f210f5d068411c297cd7163"],"e8dd2a69747e9f2922fd8b6970bd1661b26a692d":["744486748bc5bee772100e49230e5bca39bac99a"],"744486748bc5bee772100e49230e5bca39bac99a":["33a8b1f99104f4144f210f5d068411c297cd7163"],"3bb13258feba31ab676502787ab2e1779f129b7a":["9ab1f5591dc05f1f2b5407d809c9699f75554a32","e8dd2a69747e9f2922fd8b6970bd1661b26a692d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e230a61047bc041516c811baa08a7174d6f8322a"],"2e10cb22a8bdb44339e282925a29182bb2f3174d":["3bb13258feba31ab676502787ab2e1779f129b7a","e230a61047bc041516c811baa08a7174d6f8322a"]},"commit2Childs":{"9ab1f5591dc05f1f2b5407d809c9699f75554a32":["3bb13258feba31ab676502787ab2e1779f129b7a"],"e230a61047bc041516c811baa08a7174d6f8322a":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","cd5edd1f2b162a5cfa08efd17851a07373a96817","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"33a8b1f99104f4144f210f5d068411c297cd7163":["4ecea1664e8617d82eca3b8055a3c37cb4da8511","744486748bc5bee772100e49230e5bca39bac99a"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","1774e2854ef0f77de7f31ba1d9586139928e06fe"],"1774e2854ef0f77de7f31ba1d9586139928e06fe":["33a8b1f99104f4144f210f5d068411c297cd7163","4ecea1664e8617d82eca3b8055a3c37cb4da8511"],"4ecea1664e8617d82eca3b8055a3c37cb4da8511":["9ab1f5591dc05f1f2b5407d809c9699f75554a32"],"744486748bc5bee772100e49230e5bca39bac99a":["9ab1f5591dc05f1f2b5407d809c9699f75554a32","e8dd2a69747e9f2922fd8b6970bd1661b26a692d"],"e8dd2a69747e9f2922fd8b6970bd1661b26a692d":["e230a61047bc041516c811baa08a7174d6f8322a","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","3bb13258feba31ab676502787ab2e1779f129b7a"],"3bb13258feba31ab676502787ab2e1779f129b7a":["2e10cb22a8bdb44339e282925a29182bb2f3174d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"2e10cb22a8bdb44339e282925a29182bb2f3174d":[]},"heads":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","cd5edd1f2b162a5cfa08efd17851a07373a96817","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}