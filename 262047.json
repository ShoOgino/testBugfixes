{"path":"lucene/queryparser/src/java/org/apache/lucene/queryparser/simple/SimpleQueryParser#parseFuzziness(State).mjava","commits":[{"id":"bae2070aa7aaff000145c4978276eb085e2ff279","date":1391309822,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queryparser/src/java/org/apache/lucene/queryparser/simple/SimpleQueryParser#parseFuzziness(State).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Helper parsing fuzziness from parsing state\n   * @return slop/edit distance, 0 in the case of non-parsing slop/edit string\n   */\n  private int parseFuzziness(State state) {\n    char slopText[] = new char[state.length];\n    int slopLength = 0;\n\n    if (state.data[state.index] == '~') {\n      while (state.index < state.length) {\n        state.index++;\n        // it's possible that the ~ was at the end, so check after incrementing\n        // to make sure we don't go out of bounds\n        if (state.index < state.length) {\n          if (tokenFinished(state)) {\n            break;\n          }\n          slopText[slopLength] = state.data[state.index];\n          slopLength++;\n        }\n      }\n      int fuzziness = 0;\n      try {\n        fuzziness = Integer.parseInt(new String(slopText, 0, slopLength));\n      } catch (NumberFormatException e) {\n        // swallow number format exceptions parsing fuzziness\n      }\n      // negative -> 0\n      if (fuzziness < 0) {\n        fuzziness = 0;\n      }\n      return fuzziness;\n    }\n    return 0;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d6abde50ad1f829ba5faf4007a212f715db7277","date":1488887747,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/queryparser/src/java/org/apache/lucene/queryparser/simple/SimpleQueryParser#parseFuzziness(State).mjava","pathOld":"lucene/queryparser/src/java/org/apache/lucene/queryparser/simple/SimpleQueryParser#parseFuzziness(State).mjava","sourceNew":"  /**\n   * Helper parsing fuzziness from parsing state\n   * @return slop/edit distance, 0 in the case of non-parsing slop/edit string\n   */\n  private int parseFuzziness(State state) {\n    char slopText[] = new char[state.length];\n    int slopLength = 0;\n\n    if (state.data[state.index] == '~') {\n      while (state.index < state.length) {\n        state.index++;\n        // it's possible that the ~ was at the end, so check after incrementing\n        // to make sure we don't go out of bounds\n        if (state.index < state.length) {\n          if (tokenFinished(state)) {\n            break;\n          }\n          slopText[slopLength] = state.data[state.index];\n          slopLength++;\n        }\n      }\n      int fuzziness = 0;\n      try {\n        String fuzzyString =  new String(slopText, 0, slopLength);\n        if (\"\".equals(fuzzyString)) {\n          // Use automatic fuzziness, ~2\n          fuzziness = 2;\n        } else {\n          fuzziness = Integer.parseInt(fuzzyString);\n        }\n      } catch (NumberFormatException e) {\n        // swallow number format exceptions parsing fuzziness\n      }\n      // negative -> 0\n      if (fuzziness < 0) {\n        fuzziness = 0;\n      }\n      return fuzziness;\n    }\n    return 0;\n  }\n\n","sourceOld":"  /**\n   * Helper parsing fuzziness from parsing state\n   * @return slop/edit distance, 0 in the case of non-parsing slop/edit string\n   */\n  private int parseFuzziness(State state) {\n    char slopText[] = new char[state.length];\n    int slopLength = 0;\n\n    if (state.data[state.index] == '~') {\n      while (state.index < state.length) {\n        state.index++;\n        // it's possible that the ~ was at the end, so check after incrementing\n        // to make sure we don't go out of bounds\n        if (state.index < state.length) {\n          if (tokenFinished(state)) {\n            break;\n          }\n          slopText[slopLength] = state.data[state.index];\n          slopLength++;\n        }\n      }\n      int fuzziness = 0;\n      try {\n        fuzziness = Integer.parseInt(new String(slopText, 0, slopLength));\n      } catch (NumberFormatException e) {\n        // swallow number format exceptions parsing fuzziness\n      }\n      // negative -> 0\n      if (fuzziness < 0) {\n        fuzziness = 0;\n      }\n      return fuzziness;\n    }\n    return 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4d6abde50ad1f829ba5faf4007a212f715db7277":["bae2070aa7aaff000145c4978276eb085e2ff279"],"bae2070aa7aaff000145c4978276eb085e2ff279":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4d6abde50ad1f829ba5faf4007a212f715db7277"]},"commit2Childs":{"4d6abde50ad1f829ba5faf4007a212f715db7277":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bae2070aa7aaff000145c4978276eb085e2ff279":["4d6abde50ad1f829ba5faf4007a212f715db7277"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bae2070aa7aaff000145c4978276eb085e2ff279"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}