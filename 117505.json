{"path":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#maybeStall(MergeSource).mjava","commits":[{"id":"89697e7abc9807639c384eecf5a2a6eef1080426","date":1587733375,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#maybeStall(MergeSource).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#maybeStall(IndexWriter).mjava","sourceNew":"  /** This is invoked by {@link #merge} to possibly stall the incoming\n   *  thread when there are too many merges running or pending.  The \n   *  default behavior is to force this thread, which is producing too\n   *  many segments for merging to keep up, to wait until merges catch\n   *  up. Applications that can take other less drastic measures, such\n   *  as limiting how many threads are allowed to index, can do nothing\n   *  here and throttle elsewhere.\n   *\n   *  If this method wants to stall but the calling thread is a merge\n   *  thread, it should return false to tell caller not to kick off\n   *  any new merges. */\n  protected synchronized boolean maybeStall(MergeSource mergeSource) {\n    long startStallTime = 0;\n    while (mergeSource.hasPendingMerges() && mergeThreadCount() >= maxMergeCount) {\n\n      // This means merging has fallen too far behind: we\n      // have already created maxMergeCount threads, and\n      // now there's at least one more merge pending.\n      // Note that only maxThreadCount of\n      // those created merge threads will actually be\n      // running; the rest will be paused (see\n      // updateMergeThreads).  We stall this producer\n      // thread to prevent creation of new segments,\n      // until merging has caught up:\n\n      if (mergeThreads.contains(Thread.currentThread())) {\n        // Never stall a merge thread since this blocks the thread from\n        // finishing and calling updateMergeThreads, and blocking it\n        // accomplishes nothing anyway (it's not really a segment producer):\n        return false;\n      }\n\n      if (verbose() && startStallTime == 0) {\n        message(\"    too many merges; stalling...\");\n      }\n      startStallTime = System.currentTimeMillis();\n      doStall();\n    }\n\n    if (verbose() && startStallTime != 0) {\n      message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /** This is invoked by {@link #merge} to possibly stall the incoming\n   *  thread when there are too many merges running or pending.  The \n   *  default behavior is to force this thread, which is producing too\n   *  many segments for merging to keep up, to wait until merges catch\n   *  up. Applications that can take other less drastic measures, such\n   *  as limiting how many threads are allowed to index, can do nothing\n   *  here and throttle elsewhere.\n   *\n   *  If this method wants to stall but the calling thread is a merge\n   *  thread, it should return false to tell caller not to kick off\n   *  any new merges. */\n\n  protected synchronized boolean maybeStall(IndexWriter writer) {\n    long startStallTime = 0;\n    while (writer.hasPendingMerges() && mergeThreadCount() >= maxMergeCount) {\n\n      // This means merging has fallen too far behind: we\n      // have already created maxMergeCount threads, and\n      // now there's at least one more merge pending.\n      // Note that only maxThreadCount of\n      // those created merge threads will actually be\n      // running; the rest will be paused (see\n      // updateMergeThreads).  We stall this producer\n      // thread to prevent creation of new segments,\n      // until merging has caught up:\n\n      if (mergeThreads.contains(Thread.currentThread())) {\n        // Never stall a merge thread since this blocks the thread from\n        // finishing and calling updateMergeThreads, and blocking it\n        // accomplishes nothing anyway (it's not really a segment producer):\n        return false;\n      }\n\n      if (verbose() && startStallTime == 0) {\n        message(\"    too many merges; stalling...\");\n      }\n      startStallTime = System.currentTimeMillis();\n      doStall();\n    }\n\n    if (verbose() && startStallTime != 0) {\n      message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"89697e7abc9807639c384eecf5a2a6eef1080426":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["89697e7abc9807639c384eecf5a2a6eef1080426"]},"commit2Childs":{"89697e7abc9807639c384eecf5a2a6eef1080426":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["89697e7abc9807639c384eecf5a2a6eef1080426"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}