{"path":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector#createSharedManager(Sort,int,FieldDoc,int).mjava","commits":[{"id":"e19eef45a852c3316ae52fdf941731448ece967a","date":1567670879,"type":0,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector#createSharedManager(Sort,int,FieldDoc,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Create a CollectorManager which uses a shared hit counter to maintain number of hits\n   */\n  public static CollectorManager<TopFieldCollector, TopFieldDocs> createSharedManager(Sort sort, int numHits, FieldDoc after,\n                                                                                 int totalHitsThreshold) {\n    return new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = HitsThresholdChecker.createShared(totalHitsThreshold);\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        return create(sort, numHits, after, hitsThresholdChecker);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(sort, 0, numHits, topDocs);\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"32dc2e73f68d239029f9fe76729eda505b75bb6e","date":1569593453,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector#createSharedManager(Sort,int,FieldDoc,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector#createSharedManager(Sort,int,FieldDoc,int).mjava","sourceNew":"  /**\n   * Create a CollectorManager which uses a shared hit counter to maintain number of hits\n   * and a shared bottom value checker to propagate the minimum score accross segments if\n   * the primary sort is by relevancy.\n   */\n  public static CollectorManager<TopFieldCollector, TopFieldDocs> createSharedManager(Sort sort, int numHits, FieldDoc after, int totalHitsThreshold) {\n    return new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = HitsThresholdChecker.createShared(totalHitsThreshold);\n      private final BottomValueChecker bottomValueChecker = BottomValueChecker.createMaxBottomScoreChecker();\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        return create(sort, numHits, after, hitsThresholdChecker, bottomValueChecker);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(sort, 0, numHits, topDocs);\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Create a CollectorManager which uses a shared hit counter to maintain number of hits\n   */\n  public static CollectorManager<TopFieldCollector, TopFieldDocs> createSharedManager(Sort sort, int numHits, FieldDoc after,\n                                                                                 int totalHitsThreshold) {\n    return new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = HitsThresholdChecker.createShared(totalHitsThreshold);\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        return create(sort, numHits, after, hitsThresholdChecker);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(sort, 0, numHits, topDocs);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5319c194edd3bf49f39c6d198107ed213c1d3670","date":1569842580,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector#createSharedManager(Sort,int,FieldDoc,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector#createSharedManager(Sort,int,FieldDoc,int).mjava","sourceNew":"  /**\n   * Create a CollectorManager which uses a shared hit counter to maintain number of hits\n   * and a shared bottom value checker to propagate the minimum score accross segments if\n   * the primary sort is by relevancy.\n   */\n  public static CollectorManager<TopFieldCollector, TopFieldDocs> createSharedManager(Sort sort, int numHits, FieldDoc after,\n                                                                                 int totalHitsThreshold) {\n    return new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = HitsThresholdChecker.createShared(totalHitsThreshold);\n      private final BottomValueChecker bottomValueChecker = BottomValueChecker.createMaxBottomScoreChecker();\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        return create(sort, numHits, after, hitsThresholdChecker, bottomValueChecker);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(sort, 0, numHits, topDocs);\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Create a CollectorManager which uses a shared hit counter to maintain number of hits\n   * and a shared bottom value checker to propagate the minimum score accross segments if\n   * the primary sort is by relevancy.\n   */\n  public static CollectorManager<TopFieldCollector, TopFieldDocs> createSharedManager(Sort sort, int numHits, FieldDoc after, int totalHitsThreshold) {\n    return new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = HitsThresholdChecker.createShared(totalHitsThreshold);\n      private final BottomValueChecker bottomValueChecker = BottomValueChecker.createMaxBottomScoreChecker();\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        return create(sort, numHits, after, hitsThresholdChecker, bottomValueChecker);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(sort, 0, numHits, topDocs);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"807314aa41c10866aec273a0e54fd0d24d8971de","date":1570435832,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector#createSharedManager(Sort,int,FieldDoc,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector#createSharedManager(Sort,int,FieldDoc,int).mjava","sourceNew":"  /**\n   * Create a CollectorManager which uses a shared hit counter to maintain number of hits\n   * and a shared {@link MaxScoreAccumulator} to propagate the minimum score accross segments if\n   * the primary sort is by relevancy.\n   */\n  public static CollectorManager<TopFieldCollector, TopFieldDocs> createSharedManager(Sort sort, int numHits, FieldDoc after,\n                                                                                 int totalHitsThreshold) {\n    return new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = HitsThresholdChecker.createShared(totalHitsThreshold);\n      private final MaxScoreAccumulator minScoreAcc = new MaxScoreAccumulator();\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        return create(sort, numHits, after, hitsThresholdChecker, minScoreAcc);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(sort, 0, numHits, topDocs);\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Create a CollectorManager which uses a shared hit counter to maintain number of hits\n   * and a shared bottom value checker to propagate the minimum score accross segments if\n   * the primary sort is by relevancy.\n   */\n  public static CollectorManager<TopFieldCollector, TopFieldDocs> createSharedManager(Sort sort, int numHits, FieldDoc after,\n                                                                                 int totalHitsThreshold) {\n    return new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = HitsThresholdChecker.createShared(totalHitsThreshold);\n      private final BottomValueChecker bottomValueChecker = BottomValueChecker.createMaxBottomScoreChecker();\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        return create(sort, numHits, after, hitsThresholdChecker, bottomValueChecker);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(sort, 0, numHits, topDocs);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f","date":1571662992,"type":3,"author":"Jim Ferenczi","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector#createSharedManager(Sort,int,FieldDoc,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector#createSharedManager(Sort,int,FieldDoc,int).mjava","sourceNew":"  /**\n   * Create a CollectorManager which uses a shared hit counter to maintain number of hits\n   * and a shared {@link MaxScoreAccumulator} to propagate the minimum score accross segments if\n   * the primary sort is by relevancy.\n   */\n  public static CollectorManager<TopFieldCollector, TopFieldDocs> createSharedManager(Sort sort, int numHits, FieldDoc after,\n                                                                                 int totalHitsThreshold) {\n    return new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = HitsThresholdChecker.createShared(totalHitsThreshold);\n      private final MaxScoreAccumulator minScoreAcc = new MaxScoreAccumulator();\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        return create(sort, numHits, after, hitsThresholdChecker, minScoreAcc);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(sort, 0, numHits, topDocs);\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Create a CollectorManager which uses a shared hit counter to maintain number of hits\n   */\n  public static CollectorManager<TopFieldCollector, TopFieldDocs> createSharedManager(Sort sort, int numHits, FieldDoc after,\n                                                                                 int totalHitsThreshold) {\n    return new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = HitsThresholdChecker.createShared(totalHitsThreshold);\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        return create(sort, numHits, after, hitsThresholdChecker);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(sort, 0, numHits, topDocs);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60a97329527e682292497dd2f6fae1c519840bae","date":1587668642,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector#createSharedManager(Sort,int,FieldDoc,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector#createSharedManager(Sort,int,FieldDoc,int).mjava","sourceNew":"  /**\n   * Create a CollectorManager which uses a shared hit counter to maintain number of hits\n   * and a shared {@link MaxScoreAccumulator} to propagate the minimum score accross segments if\n   * the primary sort is by relevancy.\n   */\n  public static CollectorManager<TopFieldCollector, TopFieldDocs> createSharedManager(Sort sort, int numHits, FieldDoc after,\n                                                                                 int totalHitsThreshold) {\n    return new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = HitsThresholdChecker.createShared(Math.max(totalHitsThreshold, numHits));\n      private final MaxScoreAccumulator minScoreAcc = new MaxScoreAccumulator();\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        return create(sort, numHits, after, hitsThresholdChecker, minScoreAcc);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(sort, 0, numHits, topDocs);\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Create a CollectorManager which uses a shared hit counter to maintain number of hits\n   * and a shared {@link MaxScoreAccumulator} to propagate the minimum score accross segments if\n   * the primary sort is by relevancy.\n   */\n  public static CollectorManager<TopFieldCollector, TopFieldDocs> createSharedManager(Sort sort, int numHits, FieldDoc after,\n                                                                                 int totalHitsThreshold) {\n    return new CollectorManager<>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = HitsThresholdChecker.createShared(totalHitsThreshold);\n      private final MaxScoreAccumulator minScoreAcc = new MaxScoreAccumulator();\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        return create(sort, numHits, after, hitsThresholdChecker, minScoreAcc);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(sort, 0, numHits, topDocs);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e19eef45a852c3316ae52fdf941731448ece967a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"807314aa41c10866aec273a0e54fd0d24d8971de":["5319c194edd3bf49f39c6d198107ed213c1d3670"],"3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f":["e19eef45a852c3316ae52fdf941731448ece967a","807314aa41c10866aec273a0e54fd0d24d8971de"],"32dc2e73f68d239029f9fe76729eda505b75bb6e":["e19eef45a852c3316ae52fdf941731448ece967a"],"60a97329527e682292497dd2f6fae1c519840bae":["3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5319c194edd3bf49f39c6d198107ed213c1d3670":["32dc2e73f68d239029f9fe76729eda505b75bb6e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["60a97329527e682292497dd2f6fae1c519840bae"]},"commit2Childs":{"e19eef45a852c3316ae52fdf941731448ece967a":["3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f","32dc2e73f68d239029f9fe76729eda505b75bb6e"],"807314aa41c10866aec273a0e54fd0d24d8971de":["3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f"],"3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f":["60a97329527e682292497dd2f6fae1c519840bae"],"32dc2e73f68d239029f9fe76729eda505b75bb6e":["5319c194edd3bf49f39c6d198107ed213c1d3670"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e19eef45a852c3316ae52fdf941731448ece967a"],"60a97329527e682292497dd2f6fae1c519840bae":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5319c194edd3bf49f39c6d198107ed213c1d3670":["807314aa41c10866aec273a0e54fd0d24d8971de"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}