{"path":"lucene/core/src/test/org/apache/lucene/index/TestIntBlockPool#testMultipleWriterReader().mjava","commits":[{"id":"30fd30bfbfa6b9e036bcd99c8339712e965d4a63","date":1351859294,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIntBlockPool#testMultipleWriterReader().mjava","pathOld":"/dev/null","sourceNew":"  public void testMultipleWriterReader() {\n    Counter bytesUsed = Counter.newCounter();\n    IntBlockPool pool = new IntBlockPool(new ByteTrackingAllocator(bytesUsed));\n    for (int j = 0; j < 2; j++) {\n      List<StartEndAndValues> holders = new ArrayList<TestIntBlockPool.StartEndAndValues>();\n      int num = atLeast(4);\n      for (int i = 0; i < num; i++) {\n        holders.add(new StartEndAndValues(random().nextInt(1000)));\n      }\n      IntBlockPool.SliceWriter writer = new IntBlockPool.SliceWriter(pool);\n      IntBlockPool.SliceReader reader = new IntBlockPool.SliceReader(pool);\n      \n      int numValuesToWrite = atLeast(10000);\n      for (int i = 0; i < numValuesToWrite; i++) {\n        StartEndAndValues values = holders\n            .get(random().nextInt(holders.size()));\n        if (values.valueCount == 0) {\n          values.start = writer.startNewSlice();\n        } else {\n          writer.reset(values.end);\n        }\n        writer.writeInt(values.nextValue());\n        values.end = writer.getCurrentOffset();\n        if (random().nextInt(5) == 0) {\n          // pick one and reader the ints\n          assertReader(reader, holders.get(random().nextInt(holders.size())));\n        }\n      }\n      \n      while (!holders.isEmpty()) {\n        StartEndAndValues values = holders.remove(random().nextInt(\n            holders.size()));\n        assertReader(reader, values);\n      }\n      if (random().nextBoolean()) {\n        pool.reset(true, false);\n        assertEquals(0, bytesUsed.get());\n      } else {\n        pool.reset(true, true);\n        assertEquals(IntBlockPool.INT_BLOCK_SIZE\n            * RamUsageEstimator.NUM_BYTES_INT, bytesUsed.get());\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIntBlockPool#testMultipleWriterReader().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIntBlockPool#testMultipleWriterReader().mjava","sourceNew":"  public void testMultipleWriterReader() {\n    Counter bytesUsed = Counter.newCounter();\n    IntBlockPool pool = new IntBlockPool(new ByteTrackingAllocator(bytesUsed));\n    for (int j = 0; j < 2; j++) {\n      List<StartEndAndValues> holders = new ArrayList<>();\n      int num = atLeast(4);\n      for (int i = 0; i < num; i++) {\n        holders.add(new StartEndAndValues(random().nextInt(1000)));\n      }\n      IntBlockPool.SliceWriter writer = new IntBlockPool.SliceWriter(pool);\n      IntBlockPool.SliceReader reader = new IntBlockPool.SliceReader(pool);\n      \n      int numValuesToWrite = atLeast(10000);\n      for (int i = 0; i < numValuesToWrite; i++) {\n        StartEndAndValues values = holders\n            .get(random().nextInt(holders.size()));\n        if (values.valueCount == 0) {\n          values.start = writer.startNewSlice();\n        } else {\n          writer.reset(values.end);\n        }\n        writer.writeInt(values.nextValue());\n        values.end = writer.getCurrentOffset();\n        if (random().nextInt(5) == 0) {\n          // pick one and reader the ints\n          assertReader(reader, holders.get(random().nextInt(holders.size())));\n        }\n      }\n      \n      while (!holders.isEmpty()) {\n        StartEndAndValues values = holders.remove(random().nextInt(\n            holders.size()));\n        assertReader(reader, values);\n      }\n      if (random().nextBoolean()) {\n        pool.reset(true, false);\n        assertEquals(0, bytesUsed.get());\n      } else {\n        pool.reset(true, true);\n        assertEquals(IntBlockPool.INT_BLOCK_SIZE\n            * RamUsageEstimator.NUM_BYTES_INT, bytesUsed.get());\n      }\n    }\n  }\n\n","sourceOld":"  public void testMultipleWriterReader() {\n    Counter bytesUsed = Counter.newCounter();\n    IntBlockPool pool = new IntBlockPool(new ByteTrackingAllocator(bytesUsed));\n    for (int j = 0; j < 2; j++) {\n      List<StartEndAndValues> holders = new ArrayList<TestIntBlockPool.StartEndAndValues>();\n      int num = atLeast(4);\n      for (int i = 0; i < num; i++) {\n        holders.add(new StartEndAndValues(random().nextInt(1000)));\n      }\n      IntBlockPool.SliceWriter writer = new IntBlockPool.SliceWriter(pool);\n      IntBlockPool.SliceReader reader = new IntBlockPool.SliceReader(pool);\n      \n      int numValuesToWrite = atLeast(10000);\n      for (int i = 0; i < numValuesToWrite; i++) {\n        StartEndAndValues values = holders\n            .get(random().nextInt(holders.size()));\n        if (values.valueCount == 0) {\n          values.start = writer.startNewSlice();\n        } else {\n          writer.reset(values.end);\n        }\n        writer.writeInt(values.nextValue());\n        values.end = writer.getCurrentOffset();\n        if (random().nextInt(5) == 0) {\n          // pick one and reader the ints\n          assertReader(reader, holders.get(random().nextInt(holders.size())));\n        }\n      }\n      \n      while (!holders.isEmpty()) {\n        StartEndAndValues values = holders.remove(random().nextInt(\n            holders.size()));\n        assertReader(reader, values);\n      }\n      if (random().nextBoolean()) {\n        pool.reset(true, false);\n        assertEquals(0, bytesUsed.get());\n      } else {\n        pool.reset(true, true);\n        assertEquals(IntBlockPool.INT_BLOCK_SIZE\n            * RamUsageEstimator.NUM_BYTES_INT, bytesUsed.get());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f226a8b088dd9c8f6ab287a77237c4aa00a238e5","date":1456187572,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIntBlockPool#testMultipleWriterReader().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIntBlockPool#testMultipleWriterReader().mjava","sourceNew":"  public void testMultipleWriterReader() {\n    Counter bytesUsed = Counter.newCounter();\n    IntBlockPool pool = new IntBlockPool(new ByteTrackingAllocator(bytesUsed));\n    for (int j = 0; j < 2; j++) {\n      List<StartEndAndValues> holders = new ArrayList<>();\n      int num = atLeast(4);\n      for (int i = 0; i < num; i++) {\n        holders.add(new StartEndAndValues(random().nextInt(1000)));\n      }\n      IntBlockPool.SliceWriter writer = new IntBlockPool.SliceWriter(pool);\n      IntBlockPool.SliceReader reader = new IntBlockPool.SliceReader(pool);\n      \n      int numValuesToWrite = atLeast(10000);\n      for (int i = 0; i < numValuesToWrite; i++) {\n        StartEndAndValues values = holders\n            .get(random().nextInt(holders.size()));\n        if (values.valueCount == 0) {\n          values.start = writer.startNewSlice();\n        } else {\n          writer.reset(values.end);\n        }\n        writer.writeInt(values.nextValue());\n        values.end = writer.getCurrentOffset();\n        if (random().nextInt(5) == 0) {\n          // pick one and reader the ints\n          assertReader(reader, holders.get(random().nextInt(holders.size())));\n        }\n      }\n      \n      while (!holders.isEmpty()) {\n        StartEndAndValues values = holders.remove(random().nextInt(\n            holders.size()));\n        assertReader(reader, values);\n      }\n      if (random().nextBoolean()) {\n        pool.reset(true, false);\n        assertEquals(0, bytesUsed.get());\n      } else {\n        pool.reset(true, true);\n        assertEquals(IntBlockPool.INT_BLOCK_SIZE * Integer.BYTES, bytesUsed.get());\n      }\n    }\n  }\n\n","sourceOld":"  public void testMultipleWriterReader() {\n    Counter bytesUsed = Counter.newCounter();\n    IntBlockPool pool = new IntBlockPool(new ByteTrackingAllocator(bytesUsed));\n    for (int j = 0; j < 2; j++) {\n      List<StartEndAndValues> holders = new ArrayList<>();\n      int num = atLeast(4);\n      for (int i = 0; i < num; i++) {\n        holders.add(new StartEndAndValues(random().nextInt(1000)));\n      }\n      IntBlockPool.SliceWriter writer = new IntBlockPool.SliceWriter(pool);\n      IntBlockPool.SliceReader reader = new IntBlockPool.SliceReader(pool);\n      \n      int numValuesToWrite = atLeast(10000);\n      for (int i = 0; i < numValuesToWrite; i++) {\n        StartEndAndValues values = holders\n            .get(random().nextInt(holders.size()));\n        if (values.valueCount == 0) {\n          values.start = writer.startNewSlice();\n        } else {\n          writer.reset(values.end);\n        }\n        writer.writeInt(values.nextValue());\n        values.end = writer.getCurrentOffset();\n        if (random().nextInt(5) == 0) {\n          // pick one and reader the ints\n          assertReader(reader, holders.get(random().nextInt(holders.size())));\n        }\n      }\n      \n      while (!holders.isEmpty()) {\n        StartEndAndValues values = holders.remove(random().nextInt(\n            holders.size()));\n        assertReader(reader, values);\n      }\n      if (random().nextBoolean()) {\n        pool.reset(true, false);\n        assertEquals(0, bytesUsed.get());\n      } else {\n        pool.reset(true, true);\n        assertEquals(IntBlockPool.INT_BLOCK_SIZE\n            * RamUsageEstimator.NUM_BYTES_INT, bytesUsed.get());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"419a8f52c6635419beb951255cacbbb281044c57","date":1456189353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIntBlockPool#testMultipleWriterReader().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIntBlockPool#testMultipleWriterReader().mjava","sourceNew":"  public void testMultipleWriterReader() {\n    Counter bytesUsed = Counter.newCounter();\n    IntBlockPool pool = new IntBlockPool(new ByteTrackingAllocator(bytesUsed));\n    for (int j = 0; j < 2; j++) {\n      List<StartEndAndValues> holders = new ArrayList<>();\n      int num = atLeast(4);\n      for (int i = 0; i < num; i++) {\n        holders.add(new StartEndAndValues(random().nextInt(1000)));\n      }\n      IntBlockPool.SliceWriter writer = new IntBlockPool.SliceWriter(pool);\n      IntBlockPool.SliceReader reader = new IntBlockPool.SliceReader(pool);\n      \n      int numValuesToWrite = atLeast(10000);\n      for (int i = 0; i < numValuesToWrite; i++) {\n        StartEndAndValues values = holders\n            .get(random().nextInt(holders.size()));\n        if (values.valueCount == 0) {\n          values.start = writer.startNewSlice();\n        } else {\n          writer.reset(values.end);\n        }\n        writer.writeInt(values.nextValue());\n        values.end = writer.getCurrentOffset();\n        if (random().nextInt(5) == 0) {\n          // pick one and reader the ints\n          assertReader(reader, holders.get(random().nextInt(holders.size())));\n        }\n      }\n      \n      while (!holders.isEmpty()) {\n        StartEndAndValues values = holders.remove(random().nextInt(\n            holders.size()));\n        assertReader(reader, values);\n      }\n      if (random().nextBoolean()) {\n        pool.reset(true, false);\n        assertEquals(0, bytesUsed.get());\n      } else {\n        pool.reset(true, true);\n        assertEquals(IntBlockPool.INT_BLOCK_SIZE * Integer.BYTES, bytesUsed.get());\n      }\n    }\n  }\n\n","sourceOld":"  public void testMultipleWriterReader() {\n    Counter bytesUsed = Counter.newCounter();\n    IntBlockPool pool = new IntBlockPool(new ByteTrackingAllocator(bytesUsed));\n    for (int j = 0; j < 2; j++) {\n      List<StartEndAndValues> holders = new ArrayList<>();\n      int num = atLeast(4);\n      for (int i = 0; i < num; i++) {\n        holders.add(new StartEndAndValues(random().nextInt(1000)));\n      }\n      IntBlockPool.SliceWriter writer = new IntBlockPool.SliceWriter(pool);\n      IntBlockPool.SliceReader reader = new IntBlockPool.SliceReader(pool);\n      \n      int numValuesToWrite = atLeast(10000);\n      for (int i = 0; i < numValuesToWrite; i++) {\n        StartEndAndValues values = holders\n            .get(random().nextInt(holders.size()));\n        if (values.valueCount == 0) {\n          values.start = writer.startNewSlice();\n        } else {\n          writer.reset(values.end);\n        }\n        writer.writeInt(values.nextValue());\n        values.end = writer.getCurrentOffset();\n        if (random().nextInt(5) == 0) {\n          // pick one and reader the ints\n          assertReader(reader, holders.get(random().nextInt(holders.size())));\n        }\n      }\n      \n      while (!holders.isEmpty()) {\n        StartEndAndValues values = holders.remove(random().nextInt(\n            holders.size()));\n        assertReader(reader, values);\n      }\n      if (random().nextBoolean()) {\n        pool.reset(true, false);\n        assertEquals(0, bytesUsed.get());\n      } else {\n        pool.reset(true, true);\n        assertEquals(IntBlockPool.INT_BLOCK_SIZE\n            * RamUsageEstimator.NUM_BYTES_INT, bytesUsed.get());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["30fd30bfbfa6b9e036bcd99c8339712e965d4a63"],"30fd30bfbfa6b9e036bcd99c8339712e965d4a63":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"419a8f52c6635419beb951255cacbbb281044c57":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","f226a8b088dd9c8f6ab287a77237c4aa00a238e5"],"f226a8b088dd9c8f6ab287a77237c4aa00a238e5":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["419a8f52c6635419beb951255cacbbb281044c57"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["419a8f52c6635419beb951255cacbbb281044c57","f226a8b088dd9c8f6ab287a77237c4aa00a238e5"],"30fd30bfbfa6b9e036bcd99c8339712e965d4a63":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["30fd30bfbfa6b9e036bcd99c8339712e965d4a63"],"419a8f52c6635419beb951255cacbbb281044c57":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f226a8b088dd9c8f6ab287a77237c4aa00a238e5":["419a8f52c6635419beb951255cacbbb281044c57"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}