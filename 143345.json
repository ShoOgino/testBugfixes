{"path":"src/java/org/apache/solr/update/processor/TextProfileSignature#add(String).mjava","commits":[{"id":"80c633e661becbcb6deb6ea2ef4588d230102f50","date":1234308117,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/update/processor/TextProfileSignature#add(String).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void add(String content) {\n    HashMap<String, Token> tokens = new HashMap<String, Token>();\n\n    StringBuilder curToken = new StringBuilder();\n    int maxFreq = 0;\n    for (int i = 0; i < content.length(); i++) {\n      char c = content.charAt(i);\n      if (Character.isLetterOrDigit(c)) {\n        curToken.append(Character.toLowerCase(c));\n      } else {\n        if (curToken.length() > 0) {\n          if (curToken.length() > minTokenLen) {\n            // add it\n            String s = curToken.toString();\n            Token tok = tokens.get(s);\n            if (tok == null) {\n              tok = new Token(0, s);\n              tokens.put(s, tok);\n            }\n            tok.cnt++;\n            if (tok.cnt > maxFreq)\n              maxFreq = tok.cnt;\n          }\n          curToken.setLength(0);\n        }\n      }\n    }\n    // check the last token\n    if (curToken.length() > minTokenLen) {\n      // add it\n      String s = curToken.toString();\n      Token tok = tokens.get(s);\n      if (tok == null) {\n        tok = new Token(0, s);\n        tokens.put(s, tok);\n      }\n      tok.cnt++;\n      if (tok.cnt > maxFreq)\n        maxFreq = tok.cnt;\n    }\n    Iterator<Token> it = tokens.values().iterator();\n    ArrayList<Token> profile = new ArrayList<Token>();\n    // calculate the QUANT value\n    int quant = Math.round(maxFreq * quantRate);\n    if (quant < 2) {\n      if (maxFreq > 1)\n        quant = 2;\n      else\n        quant = 1;\n    }\n    while (it.hasNext()) {\n      Token t = it.next();\n      // round down to the nearest QUANT\n      t.cnt = (t.cnt / quant) * quant;\n      // discard the frequencies below the QUANT\n      if (t.cnt < quant) {\n        continue;\n      }\n      profile.add(t);\n    }\n    Collections.sort(profile, new TokenComparator());\n    StringBuilder newText = new StringBuilder();\n    it = profile.iterator();\n    while (it.hasNext()) {\n      Token t = it.next();\n      if (newText.length() > 0)\n        newText.append(\"\\n\");\n      newText.append(t.toString());\n    }\n\n    super.add(newText.toString());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/update/processor/TextProfileSignature#add(String).mjava","pathOld":"src/java/org/apache/solr/update/processor/TextProfileSignature#add(String).mjava","sourceNew":"  @Override\n  public void add(String content) {\n    HashMap<String, Token> tokens = new HashMap<String, Token>();\n\n    StringBuilder curToken = new StringBuilder();\n    int maxFreq = 0;\n    for (int i = 0; i < content.length(); i++) {\n      char c = content.charAt(i);\n      if (Character.isLetterOrDigit(c)) {\n        curToken.append(Character.toLowerCase(c));\n      } else {\n        if (curToken.length() > 0) {\n          if (curToken.length() > minTokenLen) {\n            // add it\n            String s = curToken.toString();\n            Token tok = tokens.get(s);\n            if (tok == null) {\n              tok = new Token(0, s);\n              tokens.put(s, tok);\n            }\n            tok.cnt++;\n            if (tok.cnt > maxFreq)\n              maxFreq = tok.cnt;\n          }\n          curToken.setLength(0);\n        }\n      }\n    }\n    // check the last token\n    if (curToken.length() > minTokenLen) {\n      // add it\n      String s = curToken.toString();\n      Token tok = tokens.get(s);\n      if (tok == null) {\n        tok = new Token(0, s);\n        tokens.put(s, tok);\n      }\n      tok.cnt++;\n      if (tok.cnt > maxFreq)\n        maxFreq = tok.cnt;\n    }\n    Iterator<Token> it = tokens.values().iterator();\n    ArrayList<Token> profile = new ArrayList<Token>();\n    // calculate the QUANT value\n    int quant = Math.round(maxFreq * quantRate);\n    if (quant < 2) {\n      if (maxFreq > 1)\n        quant = 2;\n      else\n        quant = 1;\n    }\n    while (it.hasNext()) {\n      Token t = it.next();\n      // round down to the nearest QUANT\n      t.cnt = (t.cnt / quant) * quant;\n      // discard the frequencies below the QUANT\n      if (t.cnt < quant) {\n        continue;\n      }\n      profile.add(t);\n    }\n    Collections.sort(profile, new TokenComparator());\n    StringBuilder newText = new StringBuilder();\n    it = profile.iterator();\n    while (it.hasNext()) {\n      Token t = it.next();\n      if (newText.length() > 0)\n        newText.append(\"\\n\");\n      newText.append(t.toString());\n    }\n\n    super.add(newText.toString());\n  }\n\n","sourceOld":"  @Override\n  public void add(String content) {\n    HashMap<String, Token> tokens = new HashMap<String, Token>();\n\n    StringBuilder curToken = new StringBuilder();\n    int maxFreq = 0;\n    for (int i = 0; i < content.length(); i++) {\n      char c = content.charAt(i);\n      if (Character.isLetterOrDigit(c)) {\n        curToken.append(Character.toLowerCase(c));\n      } else {\n        if (curToken.length() > 0) {\n          if (curToken.length() > minTokenLen) {\n            // add it\n            String s = curToken.toString();\n            Token tok = tokens.get(s);\n            if (tok == null) {\n              tok = new Token(0, s);\n              tokens.put(s, tok);\n            }\n            tok.cnt++;\n            if (tok.cnt > maxFreq)\n              maxFreq = tok.cnt;\n          }\n          curToken.setLength(0);\n        }\n      }\n    }\n    // check the last token\n    if (curToken.length() > minTokenLen) {\n      // add it\n      String s = curToken.toString();\n      Token tok = tokens.get(s);\n      if (tok == null) {\n        tok = new Token(0, s);\n        tokens.put(s, tok);\n      }\n      tok.cnt++;\n      if (tok.cnt > maxFreq)\n        maxFreq = tok.cnt;\n    }\n    Iterator<Token> it = tokens.values().iterator();\n    ArrayList<Token> profile = new ArrayList<Token>();\n    // calculate the QUANT value\n    int quant = Math.round(maxFreq * quantRate);\n    if (quant < 2) {\n      if (maxFreq > 1)\n        quant = 2;\n      else\n        quant = 1;\n    }\n    while (it.hasNext()) {\n      Token t = it.next();\n      // round down to the nearest QUANT\n      t.cnt = (t.cnt / quant) * quant;\n      // discard the frequencies below the QUANT\n      if (t.cnt < quant) {\n        continue;\n      }\n      profile.add(t);\n    }\n    Collections.sort(profile, new TokenComparator());\n    StringBuilder newText = new StringBuilder();\n    it = profile.iterator();\n    while (it.hasNext()) {\n      Token t = it.next();\n      if (newText.length() > 0)\n        newText.append(\"\\n\");\n      newText.append(t.toString());\n    }\n\n    super.add(newText.toString());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"ad94625fb8d088209f46650c8097196fec67f00c":["80c633e661becbcb6deb6ea2ef4588d230102f50"],"80c633e661becbcb6deb6ea2ef4588d230102f50":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["80c633e661becbcb6deb6ea2ef4588d230102f50"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"80c633e661becbcb6deb6ea2ef4588d230102f50":["ad94625fb8d088209f46650c8097196fec67f00c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}