{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,Iterable[Number]).mjava","commits":[{"id":"32fb848e256860b63adc9c2b068f386032c77b67","date":1357587205,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,Iterable[Number]).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,long,long).mjava","sourceNew":"    @Override\n    public void addNumericField(FieldInfo field, Iterable<Number> values) throws IOException {\n      assert fieldSeen(field.name);\n      assert (field.getDocValuesType() != null && (DocValues.isNumber(field.getDocValuesType()) || DocValues.isFloat(field.getDocValuesType()))) ||\n        (field.getNormType() != null && (DocValues.isNumber(field.getNormType()) || DocValues.isFloat(field.getNormType()))): \"field=\" + field.name;\n      writeFieldEntry(field);\n\n      // first pass to find min/max\n      long minValue = Long.MAX_VALUE;\n      long maxValue = Long.MIN_VALUE;\n      for(Number n : values) {\n        long v = n.longValue();\n        minValue = Math.min(minValue, v);\n        maxValue = Math.max(maxValue, v);\n      }\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n      \n      // build up our fixed-width \"simple text packed ints\"\n      // format\n      BigInteger maxBig = BigInteger.valueOf(maxValue);\n      BigInteger minBig = BigInteger.valueOf(minValue);\n      BigInteger diffBig = maxBig.subtract(minBig);\n      int maxBytesPerValue = diffBig.toString().length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      final String patternString = sb.toString();\n      \n      final DecimalFormat encoder = new DecimalFormat(patternString, new DecimalFormatSymbols(Locale.ROOT));\n      \n      int numDocsWritten = 0;\n\n      // second pass to write the values\n      for(Number n : values) {\n        long value = n.longValue();\n        assert value >= minValue;\n        Number delta = BigInteger.valueOf(value).subtract(BigInteger.valueOf(minValue));\n        String s = encoder.format(delta);\n        assert s.length() == patternString.length();\n        SimpleTextUtil.write(data, s, scratch);\n        SimpleTextUtil.writeNewline(data);\n        numDocsWritten++;\n        assert numDocsWritten <= numDocs;\n      }\n\n      assert numDocs == numDocsWritten: \"numDocs=\" + numDocs + \" numDocsWritten=\" + numDocsWritten;\n    }\n\n","sourceOld":"    @Override\n    public NumericDocValuesConsumer addNumericField(FieldInfo field, final long minValue, long maxValue) throws IOException {\n      assert fieldSeen(field.name);\n      assert (field.getDocValuesType() != null && (DocValues.isNumber(field.getDocValuesType()) || DocValues.isFloat(field.getDocValuesType()))) ||\n        (field.getNormType() != null && (DocValues.isNumber(field.getNormType()) || DocValues.isFloat(field.getNormType()))): \"field=\" + field.name;\n      writeFieldEntry(field);\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n      \n      SimpleTextUtil.write(data, MAXVALUE);\n      SimpleTextUtil.write(data, Long.toString(maxValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      assert maxValue >= minValue;\n\n      // build up our fixed-width \"simple text packed ints\"\n      // format\n      BigInteger maxBig = BigInteger.valueOf(maxValue);\n      BigInteger minBig = BigInteger.valueOf(minValue);\n      BigInteger diffBig = maxBig.subtract(minBig);\n      int maxBytesPerValue = diffBig.toString().length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      final String patternString = sb.toString();\n      \n      final DecimalFormat encoder = new DecimalFormat(patternString, new DecimalFormatSymbols(Locale.ROOT));\n      return new NumericDocValuesConsumer() {\n        int numDocsWritten = 0;\n\n        @Override\n        public void add(long value) throws IOException {\n          assert value >= minValue;\n          Number delta = BigInteger.valueOf(value).subtract(BigInteger.valueOf(minValue));\n          String s = encoder.format(delta);\n          assert s.length() == patternString.length();\n          SimpleTextUtil.write(data, s, scratch);\n          SimpleTextUtil.writeNewline(data);\n          numDocsWritten++;\n          assert numDocsWritten <= numDocs;\n        }\n\n        @Override\n        public void finish() throws IOException {\n          assert numDocs == numDocsWritten: \"numDocs=\" + numDocs + \" numDocsWritten=\" + numDocsWritten;\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0837ab0472feecb3a54260729d845f839e1cbd72","date":1358283639,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,Iterable[Number]).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,Iterable[Number]).mjava","sourceNew":"    @Override\n    public void addNumericField(FieldInfo field, Iterable<Number> values) throws IOException {\n      assert fieldSeen(field.name);\n      // nocommit: this must be multiple asserts\n      //assert (field.getDocValuesType() != null && (DocValues.isNumber(field.getDocValuesType()) || DocValues.isFloat(field.getDocValuesType()))) ||\n      //  (field.getNormType() != null && (DocValues.isNumber(field.getNormType()) || DocValues.isFloat(field.getNormType()))): \"field=\" + field.name;\n      writeFieldEntry(field);\n\n      // first pass to find min/max\n      long minValue = Long.MAX_VALUE;\n      long maxValue = Long.MIN_VALUE;\n      for(Number n : values) {\n        long v = n.longValue();\n        minValue = Math.min(minValue, v);\n        maxValue = Math.max(maxValue, v);\n      }\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n      \n      // build up our fixed-width \"simple text packed ints\"\n      // format\n      BigInteger maxBig = BigInteger.valueOf(maxValue);\n      BigInteger minBig = BigInteger.valueOf(minValue);\n      BigInteger diffBig = maxBig.subtract(minBig);\n      int maxBytesPerValue = diffBig.toString().length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      final String patternString = sb.toString();\n      \n      final DecimalFormat encoder = new DecimalFormat(patternString, new DecimalFormatSymbols(Locale.ROOT));\n      \n      int numDocsWritten = 0;\n\n      // second pass to write the values\n      for(Number n : values) {\n        long value = n.longValue();\n        assert value >= minValue;\n        Number delta = BigInteger.valueOf(value).subtract(BigInteger.valueOf(minValue));\n        String s = encoder.format(delta);\n        assert s.length() == patternString.length();\n        SimpleTextUtil.write(data, s, scratch);\n        SimpleTextUtil.writeNewline(data);\n        numDocsWritten++;\n        assert numDocsWritten <= numDocs;\n      }\n\n      assert numDocs == numDocsWritten: \"numDocs=\" + numDocs + \" numDocsWritten=\" + numDocsWritten;\n    }\n\n","sourceOld":"    @Override\n    public void addNumericField(FieldInfo field, Iterable<Number> values) throws IOException {\n      assert fieldSeen(field.name);\n      assert (field.getDocValuesType() != null && (DocValues.isNumber(field.getDocValuesType()) || DocValues.isFloat(field.getDocValuesType()))) ||\n        (field.getNormType() != null && (DocValues.isNumber(field.getNormType()) || DocValues.isFloat(field.getNormType()))): \"field=\" + field.name;\n      writeFieldEntry(field);\n\n      // first pass to find min/max\n      long minValue = Long.MAX_VALUE;\n      long maxValue = Long.MIN_VALUE;\n      for(Number n : values) {\n        long v = n.longValue();\n        minValue = Math.min(minValue, v);\n        maxValue = Math.max(maxValue, v);\n      }\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n      \n      // build up our fixed-width \"simple text packed ints\"\n      // format\n      BigInteger maxBig = BigInteger.valueOf(maxValue);\n      BigInteger minBig = BigInteger.valueOf(minValue);\n      BigInteger diffBig = maxBig.subtract(minBig);\n      int maxBytesPerValue = diffBig.toString().length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      final String patternString = sb.toString();\n      \n      final DecimalFormat encoder = new DecimalFormat(patternString, new DecimalFormatSymbols(Locale.ROOT));\n      \n      int numDocsWritten = 0;\n\n      // second pass to write the values\n      for(Number n : values) {\n        long value = n.longValue();\n        assert value >= minValue;\n        Number delta = BigInteger.valueOf(value).subtract(BigInteger.valueOf(minValue));\n        String s = encoder.format(delta);\n        assert s.length() == patternString.length();\n        SimpleTextUtil.write(data, s, scratch);\n        SimpleTextUtil.writeNewline(data);\n        numDocsWritten++;\n        assert numDocsWritten <= numDocs;\n      }\n\n      assert numDocs == numDocsWritten: \"numDocs=\" + numDocs + \" numDocsWritten=\" + numDocsWritten;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200","date":1358521790,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,Iterable[Number]).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,Iterable[Number]).mjava","sourceNew":"    @Override\n    public void addNumericField(FieldInfo field, Iterable<Number> values) throws IOException {\n      assert fieldSeen(field.name);\n      // nocommit: this must be multiple asserts\n      //assert (field.getDocValuesType() != null && (DocValues.isNumber(field.getDocValuesType()) || DocValues.isFloat(field.getDocValuesType()))) ||\n      //  (field.getNormType() != null && (DocValues.isNumber(field.getNormType()) || DocValues.isFloat(field.getNormType()))): \"field=\" + field.name;\n      writeFieldEntry(field);\n\n      // first pass to find min/max\n      long minValue = Long.MAX_VALUE;\n      long maxValue = Long.MIN_VALUE;\n      for(Number n : values) {\n        long v = n.longValue();\n        minValue = Math.min(minValue, v);\n        maxValue = Math.max(maxValue, v);\n      }\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n      \n      // build up our fixed-width \"simple text packed ints\"\n      // format\n      BigInteger maxBig = BigInteger.valueOf(maxValue);\n      BigInteger minBig = BigInteger.valueOf(minValue);\n      BigInteger diffBig = maxBig.subtract(minBig);\n      int maxBytesPerValue = diffBig.toString().length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      final String patternString = sb.toString();\n      \n      final DecimalFormat encoder = new DecimalFormat(patternString, new DecimalFormatSymbols(Locale.ROOT));\n      \n      int numDocsWritten = 0;\n\n      // second pass to write the values\n      for(Number n : values) {\n        long value = n.longValue();\n        assert value >= minValue;\n        Number delta = BigInteger.valueOf(value).subtract(BigInteger.valueOf(minValue));\n        String s = encoder.format(delta);\n        assert s.length() == patternString.length();\n        SimpleTextUtil.write(data, s, scratch);\n        SimpleTextUtil.writeNewline(data);\n        numDocsWritten++;\n        assert numDocsWritten <= numDocs;\n      }\n\n      assert numDocs == numDocsWritten: \"numDocs=\" + numDocs + \" numDocsWritten=\" + numDocsWritten;\n    }\n\n","sourceOld":"    @Override\n    public void addNumericField(FieldInfo field, Iterable<Number> values) throws IOException {\n      assert fieldSeen(field.name);\n      // nocommit: this must be multiple asserts\n      //assert (field.getDocValuesType() != null && (DocValues.isNumber(field.getDocValuesType()) || DocValues.isFloat(field.getDocValuesType()))) ||\n      //  (field.getNormType() != null && (DocValues.isNumber(field.getNormType()) || DocValues.isFloat(field.getNormType()))): \"field=\" + field.name;\n      writeFieldEntry(field);\n\n      // first pass to find min/max\n      long minValue = Long.MAX_VALUE;\n      long maxValue = Long.MIN_VALUE;\n      for(Number n : values) {\n        long v = n.longValue();\n        minValue = Math.min(minValue, v);\n        maxValue = Math.max(maxValue, v);\n      }\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n      \n      // build up our fixed-width \"simple text packed ints\"\n      // format\n      BigInteger maxBig = BigInteger.valueOf(maxValue);\n      BigInteger minBig = BigInteger.valueOf(minValue);\n      BigInteger diffBig = maxBig.subtract(minBig);\n      int maxBytesPerValue = diffBig.toString().length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      final String patternString = sb.toString();\n      \n      final DecimalFormat encoder = new DecimalFormat(patternString, new DecimalFormatSymbols(Locale.ROOT));\n      \n      int numDocsWritten = 0;\n\n      // second pass to write the values\n      for(Number n : values) {\n        long value = n.longValue();\n        assert value >= minValue;\n        Number delta = BigInteger.valueOf(value).subtract(BigInteger.valueOf(minValue));\n        String s = encoder.format(delta);\n        assert s.length() == patternString.length();\n        SimpleTextUtil.write(data, s, scratch);\n        SimpleTextUtil.writeNewline(data);\n        numDocsWritten++;\n        assert numDocsWritten <= numDocs;\n      }\n\n      assert numDocs == numDocsWritten: \"numDocs=\" + numDocs + \" numDocsWritten=\" + numDocsWritten;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200":["0837ab0472feecb3a54260729d845f839e1cbd72"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0837ab0472feecb3a54260729d845f839e1cbd72":["32fb848e256860b63adc9c2b068f386032c77b67"],"32fb848e256860b63adc9c2b068f386032c77b67":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["32fb848e256860b63adc9c2b068f386032c77b67","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0837ab0472feecb3a54260729d845f839e1cbd72":["b8acf0807ca5f38beda8e0f7d5ab46ff39f81200"],"32fb848e256860b63adc9c2b068f386032c77b67":["0837ab0472feecb3a54260729d845f839e1cbd72"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b8acf0807ca5f38beda8e0f7d5ab46ff39f81200","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}