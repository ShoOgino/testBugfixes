{"path":"src/java/org/apache/lucene/analysis/standard/StandardTokenizerTokenManager#getNextToken().mjava","commits":[{"id":"9dc3f3d3156ee3e335155b8a8f44f7e926db09ef","date":1063245093,"type":0,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/standard/StandardTokenizerTokenManager#getNextToken().mjava","pathOld":"/dev/null","sourceNew":"public Token getNextToken() \n{\n  int kind;\n  Token specialToken = null;\n  Token matchedToken;\n  int curPos = 0;\n\n  EOFLoop :\n  for (;;)\n  {   \n   try   \n   {     \n      curChar = input_stream.BeginToken();\n   }     \n   catch(java.io.IOException e)\n   {        \n      jjmatchedKind = 0;\n      matchedToken = jjFillToken();\n      return matchedToken;\n   }\n\n   jjmatchedKind = 0x7fffffff;\n   jjmatchedPos = 0;\n   curPos = jjMoveStringLiteralDfa0_0();\n   if (jjmatchedPos == 0 && jjmatchedKind > 13)\n   {\n      jjmatchedKind = 13;\n   }\n   if (jjmatchedKind != 0x7fffffff)\n   {\n      if (jjmatchedPos + 1 < curPos)\n         input_stream.backup(curPos - jjmatchedPos - 1);\n      if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)\n      {\n         matchedToken = jjFillToken();\n         return matchedToken;\n      }\n      else\n      {\n         continue EOFLoop;\n      }\n   }\n   int error_line = input_stream.getEndLine();\n   int error_column = input_stream.getEndColumn();\n   String error_after = null;\n   boolean EOFSeen = false;\n   try { input_stream.readChar(); input_stream.backup(1); }\n   catch (java.io.IOException e1) {\n      EOFSeen = true;\n      error_after = curPos <= 1 ? \"\" : input_stream.GetImage();\n      if (curChar == '\\n' || curChar == '\\r') {\n         error_line++;\n         error_column = 0;\n      }\n      else\n         error_column++;\n   }\n   if (!EOFSeen) {\n      input_stream.backup(1);\n      error_after = curPos <= 1 ? \"\" : input_stream.GetImage();\n   }\n   throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);\n  }\n}\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5782c80b3147b120883d1d92770063bd1056db3a","date":1065026366,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/standard/StandardTokenizerTokenManager#getNextToken().mjava","pathOld":"src/java/org/apache/lucene/analysis/standard/StandardTokenizerTokenManager#getNextToken().mjava","sourceNew":"public Token getNextToken() \n{\n  int kind;\n  Token specialToken = null;\n  Token matchedToken;\n  int curPos = 0;\n\n  EOFLoop :\n  for (;;)\n  {   \n   try   \n   {     \n      curChar = input_stream.BeginToken();\n   }     \n   catch(java.io.IOException e)\n   {        \n      jjmatchedKind = 0;\n      matchedToken = jjFillToken();\n      return matchedToken;\n   }\n\n   jjmatchedKind = 0x7fffffff;\n   jjmatchedPos = 0;\n   curPos = jjMoveStringLiteralDfa0_0();\n   if (jjmatchedPos == 0 && jjmatchedKind > 15)\n   {\n      jjmatchedKind = 15;\n   }\n   if (jjmatchedKind != 0x7fffffff)\n   {\n      if (jjmatchedPos + 1 < curPos)\n         input_stream.backup(curPos - jjmatchedPos - 1);\n      if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)\n      {\n         matchedToken = jjFillToken();\n         return matchedToken;\n      }\n      else\n      {\n         continue EOFLoop;\n      }\n   }\n   int error_line = input_stream.getEndLine();\n   int error_column = input_stream.getEndColumn();\n   String error_after = null;\n   boolean EOFSeen = false;\n   try { input_stream.readChar(); input_stream.backup(1); }\n   catch (java.io.IOException e1) {\n      EOFSeen = true;\n      error_after = curPos <= 1 ? \"\" : input_stream.GetImage();\n      if (curChar == '\\n' || curChar == '\\r') {\n         error_line++;\n         error_column = 0;\n      }\n      else\n         error_column++;\n   }\n   if (!EOFSeen) {\n      input_stream.backup(1);\n      error_after = curPos <= 1 ? \"\" : input_stream.GetImage();\n   }\n   throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);\n  }\n}\n\n","sourceOld":"public Token getNextToken() \n{\n  int kind;\n  Token specialToken = null;\n  Token matchedToken;\n  int curPos = 0;\n\n  EOFLoop :\n  for (;;)\n  {   \n   try   \n   {     \n      curChar = input_stream.BeginToken();\n   }     \n   catch(java.io.IOException e)\n   {        \n      jjmatchedKind = 0;\n      matchedToken = jjFillToken();\n      return matchedToken;\n   }\n\n   jjmatchedKind = 0x7fffffff;\n   jjmatchedPos = 0;\n   curPos = jjMoveStringLiteralDfa0_0();\n   if (jjmatchedPos == 0 && jjmatchedKind > 13)\n   {\n      jjmatchedKind = 13;\n   }\n   if (jjmatchedKind != 0x7fffffff)\n   {\n      if (jjmatchedPos + 1 < curPos)\n         input_stream.backup(curPos - jjmatchedPos - 1);\n      if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)\n      {\n         matchedToken = jjFillToken();\n         return matchedToken;\n      }\n      else\n      {\n         continue EOFLoop;\n      }\n   }\n   int error_line = input_stream.getEndLine();\n   int error_column = input_stream.getEndColumn();\n   String error_after = null;\n   boolean EOFSeen = false;\n   try { input_stream.readChar(); input_stream.backup(1); }\n   catch (java.io.IOException e1) {\n      EOFSeen = true;\n      error_after = curPos <= 1 ? \"\" : input_stream.GetImage();\n      if (curChar == '\\n' || curChar == '\\r') {\n         error_line++;\n         error_column = 0;\n      }\n      else\n         error_column++;\n   }\n   if (!EOFSeen) {\n      input_stream.backup(1);\n      error_after = curPos <= 1 ? \"\" : input_stream.GetImage();\n   }\n   throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);\n  }\n}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1fd7097d0d90763c9ce3e1eb1def624524118259","date":1072131144,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/standard/StandardTokenizerTokenManager#getNextToken().mjava","pathOld":"src/java/org/apache/lucene/analysis/standard/StandardTokenizerTokenManager#getNextToken().mjava","sourceNew":"public Token getNextToken() \n{\n  int kind;\n  Token specialToken = null;\n  Token matchedToken;\n  int curPos = 0;\n\n  EOFLoop :\n  for (;;)\n  {   \n   try   \n   {     \n      curChar = input_stream.BeginToken();\n   }     \n   catch(java.io.IOException e)\n   {        \n      jjmatchedKind = 0;\n      matchedToken = jjFillToken();\n      return matchedToken;\n   }\n\n   jjmatchedKind = 0x7fffffff;\n   jjmatchedPos = 0;\n   curPos = jjMoveStringLiteralDfa0_0();\n   if (jjmatchedPos == 0 && jjmatchedKind > 14)\n   {\n      jjmatchedKind = 14;\n   }\n   if (jjmatchedKind != 0x7fffffff)\n   {\n      if (jjmatchedPos + 1 < curPos)\n         input_stream.backup(curPos - jjmatchedPos - 1);\n      if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)\n      {\n         matchedToken = jjFillToken();\n         return matchedToken;\n      }\n      else\n      {\n         continue EOFLoop;\n      }\n   }\n   int error_line = input_stream.getEndLine();\n   int error_column = input_stream.getEndColumn();\n   String error_after = null;\n   boolean EOFSeen = false;\n   try { input_stream.readChar(); input_stream.backup(1); }\n   catch (java.io.IOException e1) {\n      EOFSeen = true;\n      error_after = curPos <= 1 ? \"\" : input_stream.GetImage();\n      if (curChar == '\\n' || curChar == '\\r') {\n         error_line++;\n         error_column = 0;\n      }\n      else\n         error_column++;\n   }\n   if (!EOFSeen) {\n      input_stream.backup(1);\n      error_after = curPos <= 1 ? \"\" : input_stream.GetImage();\n   }\n   throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);\n  }\n}\n\n","sourceOld":"public Token getNextToken() \n{\n  int kind;\n  Token specialToken = null;\n  Token matchedToken;\n  int curPos = 0;\n\n  EOFLoop :\n  for (;;)\n  {   \n   try   \n   {     \n      curChar = input_stream.BeginToken();\n   }     \n   catch(java.io.IOException e)\n   {        \n      jjmatchedKind = 0;\n      matchedToken = jjFillToken();\n      return matchedToken;\n   }\n\n   jjmatchedKind = 0x7fffffff;\n   jjmatchedPos = 0;\n   curPos = jjMoveStringLiteralDfa0_0();\n   if (jjmatchedPos == 0 && jjmatchedKind > 15)\n   {\n      jjmatchedKind = 15;\n   }\n   if (jjmatchedKind != 0x7fffffff)\n   {\n      if (jjmatchedPos + 1 < curPos)\n         input_stream.backup(curPos - jjmatchedPos - 1);\n      if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)\n      {\n         matchedToken = jjFillToken();\n         return matchedToken;\n      }\n      else\n      {\n         continue EOFLoop;\n      }\n   }\n   int error_line = input_stream.getEndLine();\n   int error_column = input_stream.getEndColumn();\n   String error_after = null;\n   boolean EOFSeen = false;\n   try { input_stream.readChar(); input_stream.backup(1); }\n   catch (java.io.IOException e1) {\n      EOFSeen = true;\n      error_after = curPos <= 1 ? \"\" : input_stream.GetImage();\n      if (curChar == '\\n' || curChar == '\\r') {\n         error_line++;\n         error_column = 0;\n      }\n      else\n         error_column++;\n   }\n   if (!EOFSeen) {\n      input_stream.backup(1);\n      error_after = curPos <= 1 ? \"\" : input_stream.GetImage();\n   }\n   throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);\n  }\n}\n\n","bugFix":null,"bugIntro":["71440939a99e296b53d3d64630c7355b914f55a2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"71440939a99e296b53d3d64630c7355b914f55a2","date":1131784401,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/standard/StandardTokenizerTokenManager#getNextToken().mjava","pathOld":"src/java/org/apache/lucene/analysis/standard/StandardTokenizerTokenManager#getNextToken().mjava","sourceNew":"public Token getNextToken() \n{\n  int kind;\n  Token specialToken = null;\n  Token matchedToken;\n  int curPos = 0;\n\n  EOFLoop :\n  for (;;)\n  {   \n   try   \n   {     \n      curChar = input_stream.BeginToken();\n   }     \n   catch(java.io.IOException e)\n   {        \n      jjmatchedKind = 0;\n      matchedToken = jjFillToken();\n      return matchedToken;\n   }\n\n   jjmatchedKind = 0x7fffffff;\n   jjmatchedPos = 0;\n   curPos = jjMoveStringLiteralDfa0_0();\n   if (jjmatchedPos == 0 && jjmatchedKind > 15)\n   {\n      jjmatchedKind = 15;\n   }\n   if (jjmatchedKind != 0x7fffffff)\n   {\n      if (jjmatchedPos + 1 < curPos)\n         input_stream.backup(curPos - jjmatchedPos - 1);\n      if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)\n      {\n         matchedToken = jjFillToken();\n         return matchedToken;\n      }\n      else\n      {\n         continue EOFLoop;\n      }\n   }\n   int error_line = input_stream.getEndLine();\n   int error_column = input_stream.getEndColumn();\n   String error_after = null;\n   boolean EOFSeen = false;\n   try { input_stream.readChar(); input_stream.backup(1); }\n   catch (java.io.IOException e1) {\n      EOFSeen = true;\n      error_after = curPos <= 1 ? \"\" : input_stream.GetImage();\n      if (curChar == '\\n' || curChar == '\\r') {\n         error_line++;\n         error_column = 0;\n      }\n      else\n         error_column++;\n   }\n   if (!EOFSeen) {\n      input_stream.backup(1);\n      error_after = curPos <= 1 ? \"\" : input_stream.GetImage();\n   }\n   throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);\n  }\n}\n\n","sourceOld":"public Token getNextToken() \n{\n  int kind;\n  Token specialToken = null;\n  Token matchedToken;\n  int curPos = 0;\n\n  EOFLoop :\n  for (;;)\n  {   \n   try   \n   {     \n      curChar = input_stream.BeginToken();\n   }     \n   catch(java.io.IOException e)\n   {        \n      jjmatchedKind = 0;\n      matchedToken = jjFillToken();\n      return matchedToken;\n   }\n\n   jjmatchedKind = 0x7fffffff;\n   jjmatchedPos = 0;\n   curPos = jjMoveStringLiteralDfa0_0();\n   if (jjmatchedPos == 0 && jjmatchedKind > 14)\n   {\n      jjmatchedKind = 14;\n   }\n   if (jjmatchedKind != 0x7fffffff)\n   {\n      if (jjmatchedPos + 1 < curPos)\n         input_stream.backup(curPos - jjmatchedPos - 1);\n      if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)\n      {\n         matchedToken = jjFillToken();\n         return matchedToken;\n      }\n      else\n      {\n         continue EOFLoop;\n      }\n   }\n   int error_line = input_stream.getEndLine();\n   int error_column = input_stream.getEndColumn();\n   String error_after = null;\n   boolean EOFSeen = false;\n   try { input_stream.readChar(); input_stream.backup(1); }\n   catch (java.io.IOException e1) {\n      EOFSeen = true;\n      error_after = curPos <= 1 ? \"\" : input_stream.GetImage();\n      if (curChar == '\\n' || curChar == '\\r') {\n         error_line++;\n         error_column = 0;\n      }\n      else\n         error_column++;\n   }\n   if (!EOFSeen) {\n      input_stream.backup(1);\n      error_after = curPos <= 1 ? \"\" : input_stream.GetImage();\n   }\n   throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);\n  }\n}\n\n","bugFix":["1fd7097d0d90763c9ce3e1eb1def624524118259"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8e191901ff30c9f34f5e72d2e7b6f6c975eb9b4e","date":1186612004,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/analysis/standard/StandardTokenizerTokenManager#getNextToken().mjava","sourceNew":null,"sourceOld":"public Token getNextToken() \n{\n  int kind;\n  Token specialToken = null;\n  Token matchedToken;\n  int curPos = 0;\n\n  EOFLoop :\n  for (;;)\n  {   \n   try   \n   {     \n      curChar = input_stream.BeginToken();\n   }     \n   catch(java.io.IOException e)\n   {        \n      jjmatchedKind = 0;\n      matchedToken = jjFillToken();\n      return matchedToken;\n   }\n\n   jjmatchedKind = 0x7fffffff;\n   jjmatchedPos = 0;\n   curPos = jjMoveStringLiteralDfa0_0();\n   if (jjmatchedPos == 0 && jjmatchedKind > 15)\n   {\n      jjmatchedKind = 15;\n   }\n   if (jjmatchedKind != 0x7fffffff)\n   {\n      if (jjmatchedPos + 1 < curPos)\n         input_stream.backup(curPos - jjmatchedPos - 1);\n      if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)\n      {\n         matchedToken = jjFillToken();\n         return matchedToken;\n      }\n      else\n      {\n         continue EOFLoop;\n      }\n   }\n   int error_line = input_stream.getEndLine();\n   int error_column = input_stream.getEndColumn();\n   String error_after = null;\n   boolean EOFSeen = false;\n   try { input_stream.readChar(); input_stream.backup(1); }\n   catch (java.io.IOException e1) {\n      EOFSeen = true;\n      error_after = curPos <= 1 ? \"\" : input_stream.GetImage();\n      if (curChar == '\\n' || curChar == '\\r') {\n         error_line++;\n         error_column = 0;\n      }\n      else\n         error_column++;\n   }\n   if (!EOFSeen) {\n      input_stream.backup(1);\n      error_after = curPos <= 1 ? \"\" : input_stream.GetImage();\n   }\n   throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);\n  }\n}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5782c80b3147b120883d1d92770063bd1056db3a":["9dc3f3d3156ee3e335155b8a8f44f7e926db09ef"],"1fd7097d0d90763c9ce3e1eb1def624524118259":["5782c80b3147b120883d1d92770063bd1056db3a"],"9dc3f3d3156ee3e335155b8a8f44f7e926db09ef":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8e191901ff30c9f34f5e72d2e7b6f6c975eb9b4e":["71440939a99e296b53d3d64630c7355b914f55a2"],"71440939a99e296b53d3d64630c7355b914f55a2":["1fd7097d0d90763c9ce3e1eb1def624524118259"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8e191901ff30c9f34f5e72d2e7b6f6c975eb9b4e"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9dc3f3d3156ee3e335155b8a8f44f7e926db09ef"],"5782c80b3147b120883d1d92770063bd1056db3a":["1fd7097d0d90763c9ce3e1eb1def624524118259"],"1fd7097d0d90763c9ce3e1eb1def624524118259":["71440939a99e296b53d3d64630c7355b914f55a2"],"9dc3f3d3156ee3e335155b8a8f44f7e926db09ef":["5782c80b3147b120883d1d92770063bd1056db3a"],"8e191901ff30c9f34f5e72d2e7b6f6c975eb9b4e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"71440939a99e296b53d3d64630c7355b914f55a2":["8e191901ff30c9f34f5e72d2e7b6f6c975eb9b4e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}