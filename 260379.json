{"path":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],DocSet).mjava","commits":[{"id":"7a2ba67a463f52915e77a5fd8714aa7d36faf59c","date":1348538193,"type":1,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","sourceNew":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots(NamedList<Integer> superFacets,\n                                             String field, String subField, Deque<String> fnames,\n                                             DocSet docs) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= minMatch) {\n\n        // may be null when using facet.missing\n        final String fieldValue = kv.getKey(); \n\n        // don't reuse the same BytesRef each time since we will be \n        // constructing Term objects used in TermQueries that may be cached.\n        BytesRef termval = null;\n\n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        if (null == fieldValue) {\n          pivot.add( \"value\", null );\n        } else {\n          termval = new BytesRef();\n          ftype.readableToIndexed(fieldValue, termval);\n          pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        }\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          DocSet subset = null;\n          if ( null == termval ) {\n            DocSet hasVal = searcher.getDocSet\n              (new TermRangeQuery(field, null, null, false, false));\n            subset = docs.andNot(hasVal);\n          } else {\n            Query query = new TermQuery(new Term(field, termval));\n            subset = searcher.getDocSet(query, docs);\n          }\n          super.docs = subset;//used by getTermCounts()\n\n          NamedList<Integer> nl = this.getTermCounts(subField);\n          if (nl.size() >= minMatch) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, subset) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","sourceOld":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= minMatch ) {\n\n        // may be null when using facet.missing\n        final String fieldValue = kv.getKey(); \n\n        // don't reuse the same BytesRef each time since we will be \n        // constructing Term objects used in TermQueries that may be cached.\n        BytesRef termval = null;\n\n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        if (null == fieldValue) {\n          pivot.add( \"value\", null );\n        } else {\n          termval = new BytesRef();\n          ftype.readableToIndexed(fieldValue, termval);\n          pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        }\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          DocSet subset = null;\n          if ( null == termval ) {\n            DocSet hasVal = searcher.getDocSet\n              (new TermRangeQuery(field, null, null, false, false));\n            subset = docs.andNot(hasVal);\n          } else {\n            Query query = new TermQuery(new Term(field, termval));\n            subset = searcher.getDocSet(query, docs);\n          }\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() >= minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],DocSet).mjava","sourceNew":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots(NamedList<Integer> superFacets,\n                                             String field, String subField, Deque<String> fnames,\n                                             DocSet docs) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= minMatch) {\n\n        // may be null when using facet.missing\n        final String fieldValue = kv.getKey(); \n\n        // don't reuse the same BytesRef each time since we will be \n        // constructing Term objects used in TermQueries that may be cached.\n        BytesRef termval = null;\n\n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<>();\n        pivot.add( \"field\", field );\n        if (null == fieldValue) {\n          pivot.add( \"value\", null );\n        } else {\n          termval = new BytesRef();\n          ftype.readableToIndexed(fieldValue, termval);\n          pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        }\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          DocSet subset = null;\n          if ( null == termval ) {\n            DocSet hasVal = searcher.getDocSet\n              (new TermRangeQuery(field, null, null, false, false));\n            subset = docs.andNot(hasVal);\n          } else {\n            Query query = new TermQuery(new Term(field, termval));\n            subset = searcher.getDocSet(query, docs);\n          }\n          super.docs = subset;//used by getTermCounts()\n\n          NamedList<Integer> nl = this.getTermCounts(subField);\n          if (nl.size() >= minMatch) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, subset) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","sourceOld":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots(NamedList<Integer> superFacets,\n                                             String field, String subField, Deque<String> fnames,\n                                             DocSet docs) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= minMatch) {\n\n        // may be null when using facet.missing\n        final String fieldValue = kv.getKey(); \n\n        // don't reuse the same BytesRef each time since we will be \n        // constructing Term objects used in TermQueries that may be cached.\n        BytesRef termval = null;\n\n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        if (null == fieldValue) {\n          pivot.add( \"value\", null );\n        } else {\n          termval = new BytesRef();\n          ftype.readableToIndexed(fieldValue, termval);\n          pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        }\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          DocSet subset = null;\n          if ( null == termval ) {\n            DocSet hasVal = searcher.getDocSet\n              (new TermRangeQuery(field, null, null, false, false));\n            subset = docs.andNot(hasVal);\n          } else {\n            Query query = new TermQuery(new Term(field, termval));\n            subset = searcher.getDocSet(query, docs);\n          }\n          super.docs = subset;//used by getTermCounts()\n\n          NamedList<Integer> nl = this.getTermCounts(subField);\n          if (nl.size() >= minMatch) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, subset) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],DocSet).mjava","sourceNew":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots(NamedList<Integer> superFacets,\n                                             String field, String subField, Deque<String> fnames,\n                                             DocSet docs) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= minMatch) {\n\n        // may be null when using facet.missing\n        final String fieldValue = kv.getKey(); \n\n        // don't reuse the same BytesRef each time since we will be \n        // constructing Term objects used in TermQueries that may be cached.\n        BytesRefBuilder termval = null;\n\n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<>();\n        pivot.add( \"field\", field );\n        if (null == fieldValue) {\n          pivot.add( \"value\", null );\n        } else {\n          termval = new BytesRefBuilder();\n          ftype.readableToIndexed(fieldValue, termval);\n          pivot.add( \"value\", ftype.toObject(sfield, termval.get()) );\n        }\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          DocSet subset = null;\n          if ( null == termval ) {\n            DocSet hasVal = searcher.getDocSet\n              (new TermRangeQuery(field, null, null, false, false));\n            subset = docs.andNot(hasVal);\n          } else {\n            Query query = new TermQuery(new Term(field, termval.get()));\n            subset = searcher.getDocSet(query, docs);\n          }\n          super.docs = subset;//used by getTermCounts()\n\n          NamedList<Integer> nl = this.getTermCounts(subField);\n          if (nl.size() >= minMatch) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, subset) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","sourceOld":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots(NamedList<Integer> superFacets,\n                                             String field, String subField, Deque<String> fnames,\n                                             DocSet docs) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= minMatch) {\n\n        // may be null when using facet.missing\n        final String fieldValue = kv.getKey(); \n\n        // don't reuse the same BytesRef each time since we will be \n        // constructing Term objects used in TermQueries that may be cached.\n        BytesRef termval = null;\n\n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<>();\n        pivot.add( \"field\", field );\n        if (null == fieldValue) {\n          pivot.add( \"value\", null );\n        } else {\n          termval = new BytesRef();\n          ftype.readableToIndexed(fieldValue, termval);\n          pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        }\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          DocSet subset = null;\n          if ( null == termval ) {\n            DocSet hasVal = searcher.getDocSet\n              (new TermRangeQuery(field, null, null, false, false));\n            subset = docs.andNot(hasVal);\n          } else {\n            Query query = new TermQuery(new Term(field, termval));\n            subset = searcher.getDocSet(query, docs);\n          }\n          super.docs = subset;//used by getTermCounts()\n\n          NamedList<Integer> nl = this.getTermCounts(subField);\n          if (nl.size() >= minMatch) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, subset) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","bugFix":["e250f610380dc5c3ba65cb770f4076d47d2c1d89"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"92751ba9273251eab6a2e379ec42a1697a32ff96","date":1407954233,"type":5,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#doPivots(NamedList[Integer],String,String,Deque[String],Deque[String],DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],DocSet).mjava","sourceNew":"  /**\n   * Recursive function to compute all the pivot counts for the values under teh specified field\n   */\n  protected List<NamedList<Object>> doPivots(NamedList<Integer> superFacets,\n      String field, String subField, Deque<String> fnames,Deque<String> vnames,DocSet docs) throws IOException {\n\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    // re-useable BytesRefBuilder for conversion of term values to Objects\n    BytesRefBuilder termval = new BytesRefBuilder(); \n\n    List<NamedList<Object>> values = new ArrayList<>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= getMinCountForField(field)) {  \n        final String fieldValue = kv.getKey();\n\n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<>();\n        pivot.add( \"field\", field );\n        if (null == fieldValue) {\n          pivot.add( \"value\", null );\n        } else {\n          ftype.readableToIndexed(fieldValue, termval);\n          pivot.add( \"value\", ftype.toObject(sfield, termval.get()) );\n        }\n        pivot.add( \"count\", kv.getValue() );\n\n        DocSet subset = getSubset(docs, sfield, fieldValue);\n        \n        if( subField != null )  {\n          NamedList<Integer> facetCounts;\n          if(!vnames.isEmpty()){\n            String val = vnames.pop();\n            facetCounts = new NamedList<Integer>();\n            facetCounts.add(val, getSubsetSize(subset,\n                                               searcher.getSchema().getField(subField),\n                                               val));\n          } else {\n            facetCounts = this.getTermCountsForPivots(subField, subset);\n          }\n\n          if (facetCounts.size() >= 1) {\n            pivot.add( \"pivot\", doPivots( facetCounts, subField, nextField, fnames, vnames, subset) );\n          }\n        }\n        values.add( pivot );\n      }\n\n    }\n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","sourceOld":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots(NamedList<Integer> superFacets,\n                                             String field, String subField, Deque<String> fnames,\n                                             DocSet docs) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= minMatch) {\n\n        // may be null when using facet.missing\n        final String fieldValue = kv.getKey(); \n\n        // don't reuse the same BytesRef each time since we will be \n        // constructing Term objects used in TermQueries that may be cached.\n        BytesRefBuilder termval = null;\n\n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<>();\n        pivot.add( \"field\", field );\n        if (null == fieldValue) {\n          pivot.add( \"value\", null );\n        } else {\n          termval = new BytesRefBuilder();\n          ftype.readableToIndexed(fieldValue, termval);\n          pivot.add( \"value\", ftype.toObject(sfield, termval.get()) );\n        }\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          DocSet subset = null;\n          if ( null == termval ) {\n            DocSet hasVal = searcher.getDocSet\n              (new TermRangeQuery(field, null, null, false, false));\n            subset = docs.andNot(hasVal);\n          } else {\n            Query query = new TermQuery(new Term(field, termval.get()));\n            subset = searcher.getDocSet(query, docs);\n          }\n          super.docs = subset;//used by getTermCounts()\n\n          NamedList<Integer> nl = this.getTermCounts(subField);\n          if (nl.size() >= minMatch) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, subset) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["7a2ba67a463f52915e77a5fd8714aa7d36faf59c"],"92751ba9273251eab6a2e379ec42a1697a32ff96":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7a2ba67a463f52915e77a5fd8714aa7d36faf59c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["92751ba9273251eab6a2e379ec42a1697a32ff96"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"92751ba9273251eab6a2e379ec42a1697a32ff96":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7a2ba67a463f52915e77a5fd8714aa7d36faf59c"],"7a2ba67a463f52915e77a5fd8714aa7d36faf59c":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["92751ba9273251eab6a2e379ec42a1697a32ff96"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}