{"path":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c30a2043fa096da35fb57b6f35ec8f1adc6e919a","date":1361818479,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n    // switch queries\n    assertQ(\"test matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case.z=Yonik} x \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik}  \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=''}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=$qq}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test matching switch query w/deref\",\n            req(\"q\", \"{!switch case.x=$d case.z=Yonik} x \",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik}asdf\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik v=$qq}\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n\n    try {\n      ignoreException(\"No\\\\ default\\\\, and no switch case\");\n      assertQ(\"no match and no default\",\n              req(\"q\", \"{!switch case.x=Dude case.z=Yonik}asdf\")\n              ,\"//result[@numFound='BOGUS']\");\n      fail(\"Should have gotten an error w/o default\");\n    } catch (RuntimeException exp) {\n      assertTrue(\"exp cause is wrong\", \n                 exp.getCause() instanceof SolrException);\n      SolrException e = (SolrException) exp.getCause();\n      assertEquals(\"error isn't user error\", 400, e.code());\n      assertTrue(\"Error doesn't include bad switch case: \" + e.getMessage(),\n                 e.getMessage().contains(\"asdf\"));\n    } finally {\n      resetExceptionIgnores();\n    }\n                \n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ebd748c27c397d7a0310bf98d57110e777d24381","date":1363369216,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n    assertU(adoc(\"id\",\"10\",\"text_no_analyzer\",\"should just work\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n    // switch queries\n    assertQ(\"test matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case.z=Yonik} x \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik}  \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=''}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=$qq}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test matching switch query w/deref\",\n            req(\"q\", \"{!switch case.x=$d case.z=Yonik} x \",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik}asdf\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik v=$qq}\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n\n    try {\n      ignoreException(\"No\\\\ default\\\\, and no switch case\");\n      assertQ(\"no match and no default\",\n              req(\"q\", \"{!switch case.x=Dude case.z=Yonik}asdf\")\n              ,\"//result[@numFound='BOGUS']\");\n      fail(\"Should have gotten an error w/o default\");\n    } catch (RuntimeException exp) {\n      assertTrue(\"exp cause is wrong\", \n                 exp.getCause() instanceof SolrException);\n      SolrException e = (SolrException) exp.getCause();\n      assertEquals(\"error isn't user error\", 400, e.code());\n      assertTrue(\"Error doesn't include bad switch case: \" + e.getMessage(),\n                 e.getMessage().contains(\"asdf\"));\n    } finally {\n      resetExceptionIgnores();\n    }\n                \n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"Test text field with no analysis doesn't NPE with wildcards (SOLR-4318)\",\n        req(\"q\", \"text_no_analyzer:should*\"), \"//result[@numFound='1']\");\n\n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n    // switch queries\n    assertQ(\"test matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case.z=Yonik} x \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik}  \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=''}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=$qq}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test matching switch query w/deref\",\n            req(\"q\", \"{!switch case.x=$d case.z=Yonik} x \",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik}asdf\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik v=$qq}\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n\n    try {\n      ignoreException(\"No\\\\ default\\\\, and no switch case\");\n      assertQ(\"no match and no default\",\n              req(\"q\", \"{!switch case.x=Dude case.z=Yonik}asdf\")\n              ,\"//result[@numFound='BOGUS']\");\n      fail(\"Should have gotten an error w/o default\");\n    } catch (RuntimeException exp) {\n      assertTrue(\"exp cause is wrong\", \n                 exp.getCause() instanceof SolrException);\n      SolrException e = (SolrException) exp.getCause();\n      assertEquals(\"error isn't user error\", 400, e.code());\n      assertTrue(\"Error doesn't include bad switch case: \" + e.getMessage(),\n                 e.getMessage().contains(\"asdf\"));\n    } finally {\n      resetExceptionIgnores();\n    }\n                \n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"19275ba31e621f6da1b83bf13af75233876fd3d4","date":1374846698,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n    assertU(adoc(\"id\",\"10\",\"text_no_analyzer\",\"should just work\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n    // switch queries\n    assertQ(\"test matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case.z=Yonik} x \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik}  \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=''}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=$qq}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test matching switch query w/deref\",\n            req(\"q\", \"{!switch case.x=$d case.z=Yonik} x \",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik}asdf\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik v=$qq}\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n\n    try {\n      ignoreException(\"No\\\\ default\\\\, and no switch case\");\n      assertQ(\"no match and no default\",\n              req(\"q\", \"{!switch case.x=Dude case.z=Yonik}asdf\")\n              ,\"//result[@numFound='BOGUS']\");\n      fail(\"Should have gotten an error w/o default\");\n    } catch (RuntimeException exp) {\n      assertTrue(\"exp cause is wrong\", \n                 exp.getCause() instanceof SolrException);\n      SolrException e = (SolrException) exp.getCause();\n      assertEquals(\"error isn't user error\", 400, e.code());\n      assertTrue(\"Error doesn't include bad switch case: \" + e.getMessage(),\n                 e.getMessage().contains(\"asdf\"));\n    } finally {\n      resetExceptionIgnores();\n    }\n                \n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"Test text field with no analysis doesn't NPE with wildcards (SOLR-4318)\",\n        req(\"q\", \"text_no_analyzer:should*\"), \"//result[@numFound='1']\");\n\n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n    assertU(adoc(\"id\",\"10\",\"text_no_analyzer\",\"should just work\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n    // switch queries\n    assertQ(\"test matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case.z=Yonik} x \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik}  \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=''}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=$qq}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test matching switch query w/deref\",\n            req(\"q\", \"{!switch case.x=$d case.z=Yonik} x \",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik}asdf\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik v=$qq}\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n\n    try {\n      ignoreException(\"No\\\\ default\\\\, and no switch case\");\n      assertQ(\"no match and no default\",\n              req(\"q\", \"{!switch case.x=Dude case.z=Yonik}asdf\")\n              ,\"//result[@numFound='BOGUS']\");\n      fail(\"Should have gotten an error w/o default\");\n    } catch (RuntimeException exp) {\n      assertTrue(\"exp cause is wrong\", \n                 exp.getCause() instanceof SolrException);\n      SolrException e = (SolrException) exp.getCause();\n      assertEquals(\"error isn't user error\", 400, e.code());\n      assertTrue(\"Error doesn't include bad switch case: \" + e.getMessage(),\n                 e.getMessage().contains(\"asdf\"));\n    } finally {\n      resetExceptionIgnores();\n    }\n                \n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"Test text field with no analysis doesn't NPE with wildcards (SOLR-4318)\",\n        req(\"q\", \"text_no_analyzer:should*\"), \"//result[@numFound='1']\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n    assertU(adoc(\"id\",\"10\",\"text_no_analyzer\",\"should just work\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n    // switch queries\n    assertQ(\"test matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case.z=Yonik} x \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik}  \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=''}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=$qq}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test matching switch query w/deref\",\n            req(\"q\", \"{!switch case.x=$d case.z=Yonik} x \",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik}asdf\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik v=$qq}\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n\n    try {\n      ignoreException(\"No\\\\ default\\\\, and no switch case\");\n      assertQ(\"no match and no default\",\n              req(\"q\", \"{!switch case.x=Dude case.z=Yonik}asdf\")\n              ,\"//result[@numFound='BOGUS']\");\n      fail(\"Should have gotten an error w/o default\");\n    } catch (RuntimeException exp) {\n      assertTrue(\"exp cause is wrong\", \n                 exp.getCause() instanceof SolrException);\n      SolrException e = (SolrException) exp.getCause();\n      assertEquals(\"error isn't user error\", 400, e.code());\n      assertTrue(\"Error doesn't include bad switch case: \" + e.getMessage(),\n                 e.getMessage().contains(\"asdf\"));\n    } finally {\n      resetExceptionIgnores();\n    }\n                \n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"Test text field with no analysis doesn't NPE with wildcards (SOLR-4318)\",\n        req(\"q\", \"text_no_analyzer:should*\"), \"//result[@numFound='1']\");\n\n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n    assertU(adoc(\"id\",\"10\",\"text_no_analyzer\",\"should just work\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n    // switch queries\n    assertQ(\"test matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case.z=Yonik} x \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik}  \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=''}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=$qq}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test matching switch query w/deref\",\n            req(\"q\", \"{!switch case.x=$d case.z=Yonik} x \",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik}asdf\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik v=$qq}\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n\n    try {\n      ignoreException(\"No\\\\ default\\\\, and no switch case\");\n      assertQ(\"no match and no default\",\n              req(\"q\", \"{!switch case.x=Dude case.z=Yonik}asdf\")\n              ,\"//result[@numFound='BOGUS']\");\n      fail(\"Should have gotten an error w/o default\");\n    } catch (RuntimeException exp) {\n      assertTrue(\"exp cause is wrong\", \n                 exp.getCause() instanceof SolrException);\n      SolrException e = (SolrException) exp.getCause();\n      assertEquals(\"error isn't user error\", 400, e.code());\n      assertTrue(\"Error doesn't include bad switch case: \" + e.getMessage(),\n                 e.getMessage().contains(\"asdf\"));\n    } finally {\n      resetExceptionIgnores();\n    }\n                \n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"Test text field with no analysis doesn't NPE with wildcards (SOLR-4318)\",\n        req(\"q\", \"text_no_analyzer:should*\"), \"//result[@numFound='1']\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cd601dcb2e94bd4cc97a3f603ab1c65b480a0be3","date":1407434411,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n    assertU(adoc(\"id\",\"10\",\"text_no_analyzer\",\"should just work\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // term qparser\n      assertQ(req( \"q\", \"{!term f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // terms qparser\n      //wrap in spaces if space separated\n      final String separator = f == \"v_s\" ? \"separator='|'\" : \"\";//defaults to space separated\n      String vMod = separator == \"\" && random().nextBoolean() ? \" \" + v + \" \" : v;\n      assertQ(req( \"q\", \"{!terms \" + separator + \" f=\" +f+\"}\"+vMod)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // terms qparser, no values matches nothing\n    assertQ(req( \"q\", \"*:*\", \"fq\", \"{!terms f=v_s}\")\n        ,\"//result[@numFound='0']\"\n    );\n\n    String termsMethod = new String[]{\"termsFilter\", \"booleanQuery\", \"automaton\", \"docValuesTermsFilter\"}[random().nextInt(4)];\n    assertQ(req( \"q\", \"{!terms f=v_s method=\" + termsMethod + \" separator=|}other stuff|wow dude\")\n        ,\"//result[@numFound='2']\"\n    );\n\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n    // switch queries\n    assertQ(\"test matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case.z=Yonik} x \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik}  \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=''}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=$qq}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test matching switch query w/deref\",\n            req(\"q\", \"{!switch case.x=$d case.z=Yonik} x \",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik}asdf\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik v=$qq}\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n\n    try {\n      ignoreException(\"No\\\\ default\\\\, and no switch case\");\n      assertQ(\"no match and no default\",\n              req(\"q\", \"{!switch case.x=Dude case.z=Yonik}asdf\")\n              ,\"//result[@numFound='BOGUS']\");\n      fail(\"Should have gotten an error w/o default\");\n    } catch (RuntimeException exp) {\n      assertTrue(\"exp cause is wrong\", \n                 exp.getCause() instanceof SolrException);\n      SolrException e = (SolrException) exp.getCause();\n      assertEquals(\"error isn't user error\", 400, e.code());\n      assertTrue(\"Error doesn't include bad switch case: \" + e.getMessage(),\n                 e.getMessage().contains(\"asdf\"));\n    } finally {\n      resetExceptionIgnores();\n    }\n                \n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"Test text field with no analysis doesn't NPE with wildcards (SOLR-4318)\",\n        req(\"q\", \"text_no_analyzer:should*\"), \"//result[@numFound='1']\");\n\n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n    assertU(adoc(\"id\",\"10\",\"text_no_analyzer\",\"should just work\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n    // switch queries\n    assertQ(\"test matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case.z=Yonik} x \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik}  \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=''}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=$qq}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test matching switch query w/deref\",\n            req(\"q\", \"{!switch case.x=$d case.z=Yonik} x \",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik}asdf\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik v=$qq}\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n\n    try {\n      ignoreException(\"No\\\\ default\\\\, and no switch case\");\n      assertQ(\"no match and no default\",\n              req(\"q\", \"{!switch case.x=Dude case.z=Yonik}asdf\")\n              ,\"//result[@numFound='BOGUS']\");\n      fail(\"Should have gotten an error w/o default\");\n    } catch (RuntimeException exp) {\n      assertTrue(\"exp cause is wrong\", \n                 exp.getCause() instanceof SolrException);\n      SolrException e = (SolrException) exp.getCause();\n      assertEquals(\"error isn't user error\", 400, e.code());\n      assertTrue(\"Error doesn't include bad switch case: \" + e.getMessage(),\n                 e.getMessage().contains(\"asdf\"));\n    } finally {\n      resetExceptionIgnores();\n    }\n                \n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"Test text field with no analysis doesn't NPE with wildcards (SOLR-4318)\",\n        req(\"q\", \"text_no_analyzer:should*\"), \"//result[@numFound='1']\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f4861e30a499100f61274a97de931c33fe3ea1b0","date":1407450280,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n    assertU(adoc(\"id\",\"10\",\"text_no_analyzer\",\"should just work\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // term qparser\n      assertQ(req( \"q\", \"{!term f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // terms qparser\n      //wrap in spaces sometimes if space separated\n      final String separator = f == \"v_s\" ? \"\" : \"separator=' '\";//use space separated when field isn't v_s\n      String vMod = separator != \"\" && random().nextBoolean() ? \" \" + v + \" \" : v;\n      assertQ(req( \"q\", \"{!terms \" + separator + \" f=\" +f+\"}\"+vMod)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // terms qparser, no values matches nothing\n    assertQ(req( \"q\", \"*:*\", \"fq\", \"{!terms f=v_s}\")\n        ,\"//result[@numFound='0']\"\n    );\n\n    String termsMethod = new String[]{\"termsFilter\", \"booleanQuery\", \"automaton\", \"docValuesTermsFilter\"}[random().nextInt(4)];\n    assertQ(req( \"q\", \"{!terms f=v_s method=\" + termsMethod + \" }other stuff,wow dude\")\n        ,\"//result[@numFound='2']\"\n    );\n\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n    // switch queries\n    assertQ(\"test matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case.z=Yonik} x \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik}  \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=''}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=$qq}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test matching switch query w/deref\",\n            req(\"q\", \"{!switch case.x=$d case.z=Yonik} x \",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik}asdf\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik v=$qq}\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n\n    try {\n      ignoreException(\"No\\\\ default\\\\, and no switch case\");\n      assertQ(\"no match and no default\",\n              req(\"q\", \"{!switch case.x=Dude case.z=Yonik}asdf\")\n              ,\"//result[@numFound='BOGUS']\");\n      fail(\"Should have gotten an error w/o default\");\n    } catch (RuntimeException exp) {\n      assertTrue(\"exp cause is wrong\", \n                 exp.getCause() instanceof SolrException);\n      SolrException e = (SolrException) exp.getCause();\n      assertEquals(\"error isn't user error\", 400, e.code());\n      assertTrue(\"Error doesn't include bad switch case: \" + e.getMessage(),\n                 e.getMessage().contains(\"asdf\"));\n    } finally {\n      resetExceptionIgnores();\n    }\n                \n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"Test text field with no analysis doesn't NPE with wildcards (SOLR-4318)\",\n        req(\"q\", \"text_no_analyzer:should*\"), \"//result[@numFound='1']\");\n\n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n    assertU(adoc(\"id\",\"10\",\"text_no_analyzer\",\"should just work\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // term qparser\n      assertQ(req( \"q\", \"{!term f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // terms qparser\n      //wrap in spaces if space separated\n      final String separator = f == \"v_s\" ? \"separator='|'\" : \"\";//defaults to space separated\n      String vMod = separator == \"\" && random().nextBoolean() ? \" \" + v + \" \" : v;\n      assertQ(req( \"q\", \"{!terms \" + separator + \" f=\" +f+\"}\"+vMod)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // terms qparser, no values matches nothing\n    assertQ(req( \"q\", \"*:*\", \"fq\", \"{!terms f=v_s}\")\n        ,\"//result[@numFound='0']\"\n    );\n\n    String termsMethod = new String[]{\"termsFilter\", \"booleanQuery\", \"automaton\", \"docValuesTermsFilter\"}[random().nextInt(4)];\n    assertQ(req( \"q\", \"{!terms f=v_s method=\" + termsMethod + \" separator=|}other stuff|wow dude\")\n        ,\"//result[@numFound='2']\"\n    );\n\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n    // switch queries\n    assertQ(\"test matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case.z=Yonik} x \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik}  \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=''}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=$qq}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test matching switch query w/deref\",\n            req(\"q\", \"{!switch case.x=$d case.z=Yonik} x \",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik}asdf\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik v=$qq}\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n\n    try {\n      ignoreException(\"No\\\\ default\\\\, and no switch case\");\n      assertQ(\"no match and no default\",\n              req(\"q\", \"{!switch case.x=Dude case.z=Yonik}asdf\")\n              ,\"//result[@numFound='BOGUS']\");\n      fail(\"Should have gotten an error w/o default\");\n    } catch (RuntimeException exp) {\n      assertTrue(\"exp cause is wrong\", \n                 exp.getCause() instanceof SolrException);\n      SolrException e = (SolrException) exp.getCause();\n      assertEquals(\"error isn't user error\", 400, e.code());\n      assertTrue(\"Error doesn't include bad switch case: \" + e.getMessage(),\n                 e.getMessage().contains(\"asdf\"));\n    } finally {\n      resetExceptionIgnores();\n    }\n                \n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"Test text field with no analysis doesn't NPE with wildcards (SOLR-4318)\",\n        req(\"q\", \"text_no_analyzer:should*\"), \"//result[@numFound='1']\");\n\n  }\n\n","bugFix":null,"bugIntro":["de5f7f4e540abb3a137e7a296e06a94c90d21f8c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"92f8ab19a30ff70981e43b8cc78069cb0941476e","date":1497374252,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n    assertU(adoc(\"id\",\"10\",\"text_no_analyzer\",\"should just work\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // term qparser\n      assertQ(req( \"q\", \"{!term f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // terms qparser\n      //wrap in spaces sometimes if space separated\n      final String separator = f == \"v_s\" ? \"\" : \"separator=' '\";//use space separated when field isn't v_s\n      String vMod = separator != \"\" && random().nextBoolean() ? \" \" + v + \" \" : v;\n      assertQ(req( \"q\", \"{!terms \" + separator + \" f=\" +f+\"}\"+vMod)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // terms qparser, no values matches nothing\n    assertQ(req( \"q\", \"*:*\", \"fq\", \"{!terms f=v_s}\")\n        ,\"//result[@numFound='0']\"\n    );\n\n    String termsMethod = new String[]{\"termsFilter\", \"booleanQuery\", \"automaton\", \"docValuesTermsFilter\"}[random().nextInt(4)];\n    assertQ(req( \"q\", \"{!terms f=v_s method=\" + termsMethod + \" }other stuff,wow dude\")\n        ,\"//result[@numFound='2']\"\n    );\n\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n    // switch queries\n    assertQ(\"test matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case.z=Yonik} x \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik}  \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=''}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=$qq}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test matching switch query w/deref\",\n            req(\"q\", \"{!switch case.x=$d case.z=Yonik} x \",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik}asdf\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik v=$qq}\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n\n    try {\n      ignoreException(\"No\\\\ default\\\\, and no switch case\");\n      assertQ(\"no match and no default\",\n              req(\"q\", \"{!switch case.x=Dude case.z=Yonik}asdf\")\n              ,\"//result[@numFound='BOGUS']\");\n      fail(\"Should have gotten an error w/o default\");\n    } catch (RuntimeException exp) {\n      assertTrue(\"exp cause is wrong\", \n                 exp.getCause() instanceof SolrException);\n      SolrException e = (SolrException) exp.getCause();\n      assertEquals(\"error isn't user error\", 400, e.code());\n      assertTrue(\"Error doesn't include bad switch case: \" + e.getMessage(),\n                 e.getMessage().contains(\"asdf\"));\n    } finally {\n      resetExceptionIgnores();\n    }\n                \n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"Test text field with no analysis doesn't NPE with wildcards (SOLR-4318)\",\n        req(\"q\", \"text_no_analyzer:should*\"), \"//result[@numFound='1']\");\n\n    \n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n    assertU(adoc(\"id\",\"10\",\"text_no_analyzer\",\"should just work\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // term qparser\n      assertQ(req( \"q\", \"{!term f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // terms qparser\n      //wrap in spaces sometimes if space separated\n      final String separator = f == \"v_s\" ? \"\" : \"separator=' '\";//use space separated when field isn't v_s\n      String vMod = separator != \"\" && random().nextBoolean() ? \" \" + v + \" \" : v;\n      assertQ(req( \"q\", \"{!terms \" + separator + \" f=\" +f+\"}\"+vMod)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // terms qparser, no values matches nothing\n    assertQ(req( \"q\", \"*:*\", \"fq\", \"{!terms f=v_s}\")\n        ,\"//result[@numFound='0']\"\n    );\n\n    String termsMethod = new String[]{\"termsFilter\", \"booleanQuery\", \"automaton\", \"docValuesTermsFilter\"}[random().nextInt(4)];\n    assertQ(req( \"q\", \"{!terms f=v_s method=\" + termsMethod + \" }other stuff,wow dude\")\n        ,\"//result[@numFound='2']\"\n    );\n\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n    // switch queries\n    assertQ(\"test matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case.z=Yonik} x \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik}  \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=''}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=$qq}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test matching switch query w/deref\",\n            req(\"q\", \"{!switch case.x=$d case.z=Yonik} x \",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik}asdf\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik v=$qq}\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n\n    try {\n      ignoreException(\"No\\\\ default\\\\, and no switch case\");\n      assertQ(\"no match and no default\",\n              req(\"q\", \"{!switch case.x=Dude case.z=Yonik}asdf\")\n              ,\"//result[@numFound='BOGUS']\");\n      fail(\"Should have gotten an error w/o default\");\n    } catch (RuntimeException exp) {\n      assertTrue(\"exp cause is wrong\", \n                 exp.getCause() instanceof SolrException);\n      SolrException e = (SolrException) exp.getCause();\n      assertEquals(\"error isn't user error\", 400, e.code());\n      assertTrue(\"Error doesn't include bad switch case: \" + e.getMessage(),\n                 e.getMessage().contains(\"asdf\"));\n    } finally {\n      resetExceptionIgnores();\n    }\n                \n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"Test text field with no analysis doesn't NPE with wildcards (SOLR-4318)\",\n        req(\"q\", \"text_no_analyzer:should*\"), \"//result[@numFound='1']\");\n\n  }\n\n","bugFix":["99ae3203affce3343d4924964062c41727ea4ee3"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a71f63026529f3c1f03cfdd664910873ab2369ae","date":1497543264,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n    assertU(adoc(\"id\",\"10\",\"text_no_analyzer\",\"should just work\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // term qparser\n      assertQ(req( \"q\", \"{!term f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // terms qparser\n      //wrap in spaces sometimes if space separated\n      final String separator = f == \"v_s\" ? \"\" : \"separator=' '\";//use space separated when field isn't v_s\n      String vMod = separator != \"\" && random().nextBoolean() ? \" \" + v + \" \" : v;\n      assertQ(req( \"q\", \"{!terms \" + separator + \" f=\" +f+\"}\"+vMod)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // terms qparser, no values matches nothing\n    assertQ(req( \"q\", \"*:*\", \"fq\", \"{!terms f=v_s}\")\n        ,\"//result[@numFound='0']\"\n    );\n\n    String termsMethod = new String[]{\"termsFilter\", \"booleanQuery\", \"automaton\", \"docValuesTermsFilter\"}[random().nextInt(4)];\n    assertQ(req( \"q\", \"{!terms f=v_s method=\" + termsMethod + \" }other stuff,wow dude\")\n        ,\"//result[@numFound='2']\"\n    );\n\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id_i\",999\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id_i\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n    // switch queries\n    assertQ(\"test matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case.z=Yonik} x \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik}  \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=''}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=$qq}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test matching switch query w/deref\",\n            req(\"q\", \"{!switch case.x=$d case.z=Yonik} x \",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik}asdf\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test empty default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik v=$qq}\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n\n    try {\n      ignoreException(\"No\\\\ default\\\\, and no switch case\");\n      assertQ(\"no match and no default\",\n              req(\"q\", \"{!switch case.x=Dude case.z=Yonik}asdf\")\n              ,\"//result[@numFound='BOGUS']\");\n      fail(\"Should have gotten an error w/o default\");\n    } catch (RuntimeException exp) {\n      assertTrue(\"exp cause is wrong\", \n                 exp.getCause() instanceof SolrException);\n      SolrException e = (SolrException) exp.getCause();\n      assertEquals(\"error isn't user error\", 400, e.code());\n      assertTrue(\"Error doesn't include bad switch case: \" + e.getMessage(),\n                 e.getMessage().contains(\"asdf\"));\n    } finally {\n      resetExceptionIgnores();\n    }\n                \n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"Test text field with no analysis doesn't NPE with wildcards (SOLR-4318)\",\n        req(\"q\", \"text_no_analyzer:should*\"), \"//result[@numFound='1']\");\n\n    \n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n    assertU(adoc(\"id\",\"10\",\"text_no_analyzer\",\"should just work\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // term qparser\n      assertQ(req( \"q\", \"{!term f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // terms qparser\n      //wrap in spaces sometimes if space separated\n      final String separator = f == \"v_s\" ? \"\" : \"separator=' '\";//use space separated when field isn't v_s\n      String vMod = separator != \"\" && random().nextBoolean() ? \" \" + v + \" \" : v;\n      assertQ(req( \"q\", \"{!terms \" + separator + \" f=\" +f+\"}\"+vMod)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // terms qparser, no values matches nothing\n    assertQ(req( \"q\", \"*:*\", \"fq\", \"{!terms f=v_s}\")\n        ,\"//result[@numFound='0']\"\n    );\n\n    String termsMethod = new String[]{\"termsFilter\", \"booleanQuery\", \"automaton\", \"docValuesTermsFilter\"}[random().nextInt(4)];\n    assertQ(req( \"q\", \"{!terms f=v_s method=\" + termsMethod + \" }other stuff,wow dude\")\n        ,\"//result[@numFound='2']\"\n    );\n\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n    // switch queries\n    assertQ(\"test matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case.z=Yonik} x \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik}  \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=''}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=$qq}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test matching switch query w/deref\",\n            req(\"q\", \"{!switch case.x=$d case.z=Yonik} x \",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik}asdf\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik v=$qq}\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n\n    try {\n      ignoreException(\"No\\\\ default\\\\, and no switch case\");\n      assertQ(\"no match and no default\",\n              req(\"q\", \"{!switch case.x=Dude case.z=Yonik}asdf\")\n              ,\"//result[@numFound='BOGUS']\");\n      fail(\"Should have gotten an error w/o default\");\n    } catch (RuntimeException exp) {\n      assertTrue(\"exp cause is wrong\", \n                 exp.getCause() instanceof SolrException);\n      SolrException e = (SolrException) exp.getCause();\n      assertEquals(\"error isn't user error\", 400, e.code());\n      assertTrue(\"Error doesn't include bad switch case: \" + e.getMessage(),\n                 e.getMessage().contains(\"asdf\"));\n    } finally {\n      resetExceptionIgnores();\n    }\n                \n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"Test text field with no analysis doesn't NPE with wildcards (SOLR-4318)\",\n        req(\"q\", \"text_no_analyzer:should*\"), \"//result[@numFound='1']\");\n\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n    assertU(adoc(\"id\",\"10\",\"text_no_analyzer\",\"should just work\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // term qparser\n      assertQ(req( \"q\", \"{!term f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // terms qparser\n      //wrap in spaces sometimes if space separated\n      final String separator = f == \"v_s\" ? \"\" : \"separator=' '\";//use space separated when field isn't v_s\n      String vMod = separator != \"\" && random().nextBoolean() ? \" \" + v + \" \" : v;\n      assertQ(req( \"q\", \"{!terms \" + separator + \" f=\" +f+\"}\"+vMod)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // terms qparser, no values matches nothing\n    assertQ(req( \"q\", \"*:*\", \"fq\", \"{!terms f=v_s}\")\n        ,\"//result[@numFound='0']\"\n    );\n\n    String termsMethod = new String[]{\"termsFilter\", \"booleanQuery\", \"automaton\", \"docValuesTermsFilter\"}[random().nextInt(4)];\n    assertQ(req( \"q\", \"{!terms f=v_s method=\" + termsMethod + \" }other stuff,wow dude\")\n        ,\"//result[@numFound='2']\"\n    );\n\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id_i\",999\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id_i\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n    // switch queries\n    assertQ(\"test matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case.z=Yonik} x \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik}  \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=''}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=$qq}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test matching switch query w/deref\",\n            req(\"q\", \"{!switch case.x=$d case.z=Yonik} x \",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik}asdf\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test empty default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik v=$qq}\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n\n    try {\n      ignoreException(\"No\\\\ default\\\\, and no switch case\");\n      assertQ(\"no match and no default\",\n              req(\"q\", \"{!switch case.x=Dude case.z=Yonik}asdf\")\n              ,\"//result[@numFound='BOGUS']\");\n      fail(\"Should have gotten an error w/o default\");\n    } catch (RuntimeException exp) {\n      assertTrue(\"exp cause is wrong\", \n                 exp.getCause() instanceof SolrException);\n      SolrException e = (SolrException) exp.getCause();\n      assertEquals(\"error isn't user error\", 400, e.code());\n      assertTrue(\"Error doesn't include bad switch case: \" + e.getMessage(),\n                 e.getMessage().contains(\"asdf\"));\n    } finally {\n      resetExceptionIgnores();\n    }\n                \n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"Test text field with no analysis doesn't NPE with wildcards (SOLR-4318)\",\n        req(\"q\", \"text_no_analyzer:should*\"), \"//result[@numFound='1']\");\n\n    \n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n    assertU(adoc(\"id\",\"10\",\"text_no_analyzer\",\"should just work\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // term qparser\n      assertQ(req( \"q\", \"{!term f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // terms qparser\n      //wrap in spaces sometimes if space separated\n      final String separator = f == \"v_s\" ? \"\" : \"separator=' '\";//use space separated when field isn't v_s\n      String vMod = separator != \"\" && random().nextBoolean() ? \" \" + v + \" \" : v;\n      assertQ(req( \"q\", \"{!terms \" + separator + \" f=\" +f+\"}\"+vMod)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // terms qparser, no values matches nothing\n    assertQ(req( \"q\", \"*:*\", \"fq\", \"{!terms f=v_s}\")\n        ,\"//result[@numFound='0']\"\n    );\n\n    String termsMethod = new String[]{\"termsFilter\", \"booleanQuery\", \"automaton\", \"docValuesTermsFilter\"}[random().nextInt(4)];\n    assertQ(req( \"q\", \"{!terms f=v_s method=\" + termsMethod + \" }other stuff,wow dude\")\n        ,\"//result[@numFound='2']\"\n    );\n\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n    // switch queries\n    assertQ(\"test matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case.z=Yonik} x \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik}  \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=''}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=$qq}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test matching switch query w/deref\",\n            req(\"q\", \"{!switch case.x=$d case.z=Yonik} x \",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik}asdf\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik v=$qq}\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n\n    try {\n      ignoreException(\"No\\\\ default\\\\, and no switch case\");\n      assertQ(\"no match and no default\",\n              req(\"q\", \"{!switch case.x=Dude case.z=Yonik}asdf\")\n              ,\"//result[@numFound='BOGUS']\");\n      fail(\"Should have gotten an error w/o default\");\n    } catch (RuntimeException exp) {\n      assertTrue(\"exp cause is wrong\", \n                 exp.getCause() instanceof SolrException);\n      SolrException e = (SolrException) exp.getCause();\n      assertEquals(\"error isn't user error\", 400, e.code());\n      assertTrue(\"Error doesn't include bad switch case: \" + e.getMessage(),\n                 e.getMessage().contains(\"asdf\"));\n    } finally {\n      resetExceptionIgnores();\n    }\n                \n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"Test text field with no analysis doesn't NPE with wildcards (SOLR-4318)\",\n        req(\"q\", \"text_no_analyzer:should*\"), \"//result[@numFound='1']\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n    assertU(adoc(\"id\",\"10\",\"text_no_analyzer\",\"should just work\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // term qparser\n      assertQ(req( \"q\", \"{!term f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // terms qparser\n      //wrap in spaces sometimes if space separated\n      final String separator = f == \"v_s\" ? \"\" : \"separator=' '\";//use space separated when field isn't v_s\n      String vMod = separator != \"\" && random().nextBoolean() ? \" \" + v + \" \" : v;\n      assertQ(req( \"q\", \"{!terms \" + separator + \" f=\" +f+\"}\"+vMod)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // terms qparser, no values matches nothing\n    assertQ(req( \"q\", \"*:*\", \"fq\", \"{!terms f=v_s}\")\n        ,\"//result[@numFound='0']\"\n    );\n\n    String termsMethod = new String[]{\"termsFilter\", \"booleanQuery\", \"automaton\", \"docValuesTermsFilter\"}[random().nextInt(4)];\n    assertQ(req( \"q\", \"{!terms f=v_s method=\" + termsMethod + \" }other stuff,wow dude\")\n        ,\"//result[@numFound='2']\"\n    );\n\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id_i\",999\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id_i\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n    // switch queries\n    assertQ(\"test matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case.z=Yonik} x \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik}  \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=''}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=$qq}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test matching switch query w/deref\",\n            req(\"q\", \"{!switch case.x=$d case.z=Yonik} x \",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik}asdf\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test empty default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik v=$qq}\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n\n    try {\n      ignoreException(\"No\\\\ default\\\\, and no switch case\");\n      assertQ(\"no match and no default\",\n              req(\"q\", \"{!switch case.x=Dude case.z=Yonik}asdf\")\n              ,\"//result[@numFound='BOGUS']\");\n      fail(\"Should have gotten an error w/o default\");\n    } catch (RuntimeException exp) {\n      assertTrue(\"exp cause is wrong\", \n                 exp.getCause() instanceof SolrException);\n      SolrException e = (SolrException) exp.getCause();\n      assertEquals(\"error isn't user error\", 400, e.code());\n      assertTrue(\"Error doesn't include bad switch case: \" + e.getMessage(),\n                 e.getMessage().contains(\"asdf\"));\n    } finally {\n      resetExceptionIgnores();\n    }\n                \n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"Test text field with no analysis doesn't NPE with wildcards (SOLR-4318)\",\n        req(\"q\", \"text_no_analyzer:should*\"), \"//result[@numFound='1']\");\n\n    \n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n    assertU(adoc(\"id\",\"10\",\"text_no_analyzer\",\"should just work\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // term qparser\n      assertQ(req( \"q\", \"{!term f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // terms qparser\n      //wrap in spaces sometimes if space separated\n      final String separator = f == \"v_s\" ? \"\" : \"separator=' '\";//use space separated when field isn't v_s\n      String vMod = separator != \"\" && random().nextBoolean() ? \" \" + v + \" \" : v;\n      assertQ(req( \"q\", \"{!terms \" + separator + \" f=\" +f+\"}\"+vMod)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // terms qparser, no values matches nothing\n    assertQ(req( \"q\", \"*:*\", \"fq\", \"{!terms f=v_s}\")\n        ,\"//result[@numFound='0']\"\n    );\n\n    String termsMethod = new String[]{\"termsFilter\", \"booleanQuery\", \"automaton\", \"docValuesTermsFilter\"}[random().nextInt(4)];\n    assertQ(req( \"q\", \"{!terms f=v_s method=\" + termsMethod + \" }other stuff,wow dude\")\n        ,\"//result[@numFound='2']\"\n    );\n\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n    // switch queries\n    assertQ(\"test matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case.z=Yonik} x \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik}  \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=''}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=$qq}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2.0']\");\n    assertQ(\"test matching switch query w/deref\",\n            req(\"q\", \"{!switch case.x=$d case.z=Yonik} x \",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik}asdf\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n    assertQ(\"test empty default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik v=$qq}\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1.0']\");\n\n    try {\n      ignoreException(\"No\\\\ default\\\\, and no switch case\");\n      assertQ(\"no match and no default\",\n              req(\"q\", \"{!switch case.x=Dude case.z=Yonik}asdf\")\n              ,\"//result[@numFound='BOGUS']\");\n      fail(\"Should have gotten an error w/o default\");\n    } catch (RuntimeException exp) {\n      assertTrue(\"exp cause is wrong\", \n                 exp.getCause() instanceof SolrException);\n      SolrException e = (SolrException) exp.getCause();\n      assertEquals(\"error isn't user error\", 400, e.code());\n      assertTrue(\"Error doesn't include bad switch case: \" + e.getMessage(),\n                 e.getMessage().contains(\"asdf\"));\n    } finally {\n      resetExceptionIgnores();\n    }\n                \n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"Test text field with no analysis doesn't NPE with wildcards (SOLR-4318)\",\n        req(\"q\", \"text_no_analyzer:should*\"), \"//result[@numFound='1']\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a91f19e3f7576973404e13b7ecfb8ae94f313921","date":1511358452,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n    assertU(adoc(\"id\",\"10\",\"text_no_analyzer\",\"should just work\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // term qparser\n      assertQ(req( \"q\", \"{!term f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // terms qparser\n      //wrap in spaces sometimes if space separated\n      final String separator = f == \"v_s\" ? \"\" : \"separator=' '\";//use space separated when field isn't v_s\n      String vMod = separator != \"\" && random().nextBoolean() ? \" \" + v + \" \" : v;\n      assertQ(req( \"q\", \"{!terms \" + separator + \" f=\" +f+\"}\"+vMod)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // terms qparser, no values matches nothing\n    assertQ(req( \"q\", \"*:*\", \"fq\", \"{!terms f=v_s}\")\n        ,\"//result[@numFound='0']\"\n    );\n\n    String termsMethod = new String[]{\"termsFilter\", \"booleanQuery\", \"automaton\", \"docValuesTermsFilter\"}[random().nextInt(4)];\n    assertQ(req( \"q\", \"{!terms f=v_s method=\" + termsMethod + \" }other stuff,wow dude\")\n        ,\"//result[@numFound='2']\"\n    );\n\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id_i\",999\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id_i\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n    // switch queries\n    assertQ(\"test matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case.z=Yonik} x \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik}  \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=''}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=$qq}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test matching switch query w/deref\",\n            req(\"q\", \"{!switch case.x=$d case.z=Yonik} x \",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik}asdf\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test empty default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik v=$qq}\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n\n    try {\n      ignoreException(\"No\\\\ default\\\\, and no switch case\");\n      assertQ(\"no match and no default\",\n              req(\"q\", \"{!switch case.x=Dude case.z=Yonik}asdf\")\n              ,\"//result[@numFound='BOGUS']\");\n      fail(\"Should have gotten an error w/o default\");\n    } catch (RuntimeException exp) {\n      assertTrue(\"exp cause is wrong\", \n                 exp.getCause() instanceof SolrException);\n      SolrException e = (SolrException) exp.getCause();\n      assertEquals(\"error isn't user error\", 400, e.code());\n      assertTrue(\"Error doesn't include bad switch case: \" + e.getMessage(),\n                 e.getMessage().contains(\"asdf\"));\n    } finally {\n      resetExceptionIgnores();\n    }\n                \n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"Test text field with no analysis doesn't NPE with wildcards (SOLR-4318)\",\n        req(\"q\", \"text_no_analyzer:should*\"), \"//result[@numFound='1']\");\n\n    \n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n    assertU(adoc(\"id\",\"10\",\"text_no_analyzer\",\"should just work\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // term qparser\n      assertQ(req( \"q\", \"{!term f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // terms qparser\n      //wrap in spaces sometimes if space separated\n      final String separator = f == \"v_s\" ? \"\" : \"separator=' '\";//use space separated when field isn't v_s\n      String vMod = separator != \"\" && random().nextBoolean() ? \" \" + v + \" \" : v;\n      assertQ(req( \"q\", \"{!terms \" + separator + \" f=\" +f+\"}\"+vMod)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // terms qparser, no values matches nothing\n    assertQ(req( \"q\", \"*:*\", \"fq\", \"{!terms f=v_s}\")\n        ,\"//result[@numFound='0']\"\n    );\n\n    String termsMethod = new String[]{\"termsFilter\", \"booleanQuery\", \"automaton\", \"docValuesTermsFilter\"}[random().nextInt(4)];\n    assertQ(req( \"q\", \"{!terms f=v_s method=\" + termsMethod + \" }other stuff,wow dude\")\n        ,\"//result[@numFound='2']\"\n    );\n\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id_i\",999\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id_i\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n    // switch queries\n    assertQ(\"test matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case.z=Yonik} x \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik}  \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=''}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=$qq}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test matching switch query w/deref\",\n            req(\"q\", \"{!switch case.x=$d case.z=Yonik} x \",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik}asdf\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test empty default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik v=$qq}\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n\n    try {\n      ignoreException(\"No\\\\ default\\\\, and no switch case\");\n      assertQ(\"no match and no default\",\n              req(\"q\", \"{!switch case.x=Dude case.z=Yonik}asdf\")\n              ,\"//result[@numFound='BOGUS']\");\n      fail(\"Should have gotten an error w/o default\");\n    } catch (RuntimeException exp) {\n      assertTrue(\"exp cause is wrong\", \n                 exp.getCause() instanceof SolrException);\n      SolrException e = (SolrException) exp.getCause();\n      assertEquals(\"error isn't user error\", 400, e.code());\n      assertTrue(\"Error doesn't include bad switch case: \" + e.getMessage(),\n                 e.getMessage().contains(\"asdf\"));\n    } finally {\n      resetExceptionIgnores();\n    }\n                \n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"Test text field with no analysis doesn't NPE with wildcards (SOLR-4318)\",\n        req(\"q\", \"text_no_analyzer:should*\"), \"//result[@numFound='1']\");\n\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4aee4980038a10791618ea04e79233ce5cbf6607","date":1511366888,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n    assertU(adoc(\"id\",\"10\",\"text_no_analyzer\",\"should just work\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // term qparser\n      assertQ(req( \"q\", \"{!term f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // terms qparser\n      //wrap in spaces sometimes if space separated\n      final String separator = f == \"v_s\" ? \"\" : \"separator=' '\";//use space separated when field isn't v_s\n      String vMod = separator != \"\" && random().nextBoolean() ? \" \" + v + \" \" : v;\n      assertQ(req( \"q\", \"{!terms \" + separator + \" f=\" +f+\"}\"+vMod)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // terms qparser, no values matches nothing\n    assertQ(req( \"q\", \"*:*\", \"fq\", \"{!terms f=v_s}\")\n        ,\"//result[@numFound='0']\"\n    );\n\n    String termsMethod = new String[]{\"termsFilter\", \"booleanQuery\", \"automaton\", \"docValuesTermsFilter\"}[random().nextInt(4)];\n    assertQ(req( \"q\", \"{!terms f=v_s method=\" + termsMethod + \" }other stuff,wow dude\")\n        ,\"//result[@numFound='2']\"\n    );\n\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id_i\",999\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id_i\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n    // switch queries\n    assertQ(\"test matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case.z=Yonik} x \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik}  \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=''}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=$qq}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test matching switch query w/deref\",\n            req(\"q\", \"{!switch case.x=$d case.z=Yonik} x \",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik}asdf\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test empty default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik v=$qq}\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n\n    try {\n      ignoreException(\"No\\\\ default\\\\, and no switch case\");\n      assertQ(\"no match and no default\",\n              req(\"q\", \"{!switch case.x=Dude case.z=Yonik}asdf\")\n              ,\"//result[@numFound='BOGUS']\");\n      fail(\"Should have gotten an error w/o default\");\n    } catch (RuntimeException exp) {\n      assertTrue(\"exp cause is wrong\", \n                 exp.getCause() instanceof SolrException);\n      SolrException e = (SolrException) exp.getCause();\n      assertEquals(\"error isn't user error\", 400, e.code());\n      assertTrue(\"Error doesn't include bad switch case: \" + e.getMessage(),\n                 e.getMessage().contains(\"asdf\"));\n    } finally {\n      resetExceptionIgnores();\n    }\n                \n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"Test text field with no analysis doesn't NPE with wildcards (SOLR-4318)\",\n        req(\"q\", \"text_no_analyzer:should*\"), \"//result[@numFound='1']\");\n\n    \n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n    assertU(adoc(\"id\",\"10\",\"text_no_analyzer\",\"should just work\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // term qparser\n      assertQ(req( \"q\", \"{!term f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // terms qparser\n      //wrap in spaces sometimes if space separated\n      final String separator = f == \"v_s\" ? \"\" : \"separator=' '\";//use space separated when field isn't v_s\n      String vMod = separator != \"\" && random().nextBoolean() ? \" \" + v + \" \" : v;\n      assertQ(req( \"q\", \"{!terms \" + separator + \" f=\" +f+\"}\"+vMod)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // terms qparser, no values matches nothing\n    assertQ(req( \"q\", \"*:*\", \"fq\", \"{!terms f=v_s}\")\n        ,\"//result[@numFound='0']\"\n    );\n\n    String termsMethod = new String[]{\"termsFilter\", \"booleanQuery\", \"automaton\", \"docValuesTermsFilter\"}[random().nextInt(4)];\n    assertQ(req( \"q\", \"{!terms f=v_s method=\" + termsMethod + \" }other stuff,wow dude\")\n        ,\"//result[@numFound='2']\"\n    );\n\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id_i\",999\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id_i\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n    // switch queries\n    assertQ(\"test matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case.z=Yonik} x \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik}  \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=''}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=$qq}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test matching switch query w/deref\",\n            req(\"q\", \"{!switch case.x=$d case.z=Yonik} x \",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik}asdf\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test empty default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik v=$qq}\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n\n    try {\n      ignoreException(\"No\\\\ default\\\\, and no switch case\");\n      assertQ(\"no match and no default\",\n              req(\"q\", \"{!switch case.x=Dude case.z=Yonik}asdf\")\n              ,\"//result[@numFound='BOGUS']\");\n      fail(\"Should have gotten an error w/o default\");\n    } catch (RuntimeException exp) {\n      assertTrue(\"exp cause is wrong\", \n                 exp.getCause() instanceof SolrException);\n      SolrException e = (SolrException) exp.getCause();\n      assertEquals(\"error isn't user error\", 400, e.code());\n      assertTrue(\"Error doesn't include bad switch case: \" + e.getMessage(),\n                 e.getMessage().contains(\"asdf\"));\n    } finally {\n      resetExceptionIgnores();\n    }\n                \n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"Test text field with no analysis doesn't NPE with wildcards (SOLR-4318)\",\n        req(\"q\", \"text_no_analyzer:should*\"), \"//result[@numFound='1']\");\n\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"464e7336798bc8a1281d5cf610c649c5a0784e83","date":1541256496,"type":3,"author":"Jason Gerlowski","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n    assertU(adoc(\"id\",\"10\",\"text_no_analyzer\",\"should just work\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // term qparser\n      assertQ(req( \"q\", \"{!term f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // terms qparser\n      //wrap in spaces sometimes if space separated\n      final String separator = f == \"v_s\" ? \"\" : \"separator=' '\";//use space separated when field isn't v_s\n      String vMod = separator != \"\" && random().nextBoolean() ? \" \" + v + \" \" : v;\n      assertQ(req( \"q\", \"{!terms \" + separator + \" f=\" +f+\"}\"+vMod)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // terms qparser, no values matches nothing\n    assertQ(req( \"q\", \"*:*\", \"fq\", \"{!terms f=v_s}\")\n        ,\"//result[@numFound='0']\"\n    );\n\n    String termsMethod = new String[]{\"termsFilter\", \"booleanQuery\", \"automaton\", \"docValuesTermsFilter\"}[random().nextInt(4)];\n    assertQ(req( \"q\", \"{!terms f=v_s method=\" + termsMethod + \" }other stuff,wow dude\")\n        ,\"//result[@numFound='2']\"\n    );\n\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id_i\",999\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id_i\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n    // switch queries\n    assertQ(\"test matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case.z=Yonik} x \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik}  \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=''}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=$qq}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test matching switch query w/deref\",\n            req(\"q\", \"{!switch case.x=$d case.z=Yonik} x \",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik}asdf\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test empty default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik v=$qq}\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n\n    try {\n      ignoreException(\"No\\\\ default\\\\, and no switch case\");\n      RuntimeException exp = expectThrows(RuntimeException.class, \"Should have gotten an error w/o default\",\n          () -> assertQ(\"no match and no default\",\n              req(\"q\", \"{!switch case.x=Dude case.z=Yonik}asdf\")\n              , \"//result[@numFound='BOGUS']\")\n      );\n      assertTrue(\"exp cause is wrong\",\n          exp.getCause() instanceof SolrException);\n      SolrException e = (SolrException) exp.getCause();\n      assertEquals(\"error isn't user error\", 400, e.code());\n      assertTrue(\"Error doesn't include bad switch case: \" + e.getMessage(),\n          e.getMessage().contains(\"asdf\"));\n    } finally {\n      resetExceptionIgnores();\n    }\n                \n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"Test text field with no analysis doesn't NPE with wildcards (SOLR-4318)\",\n        req(\"q\", \"text_no_analyzer:should*\"), \"//result[@numFound='1']\");\n\n    \n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n    assertU(adoc(\"id\",\"10\",\"text_no_analyzer\",\"should just work\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // term qparser\n      assertQ(req( \"q\", \"{!term f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // terms qparser\n      //wrap in spaces sometimes if space separated\n      final String separator = f == \"v_s\" ? \"\" : \"separator=' '\";//use space separated when field isn't v_s\n      String vMod = separator != \"\" && random().nextBoolean() ? \" \" + v + \" \" : v;\n      assertQ(req( \"q\", \"{!terms \" + separator + \" f=\" +f+\"}\"+vMod)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // terms qparser, no values matches nothing\n    assertQ(req( \"q\", \"*:*\", \"fq\", \"{!terms f=v_s}\")\n        ,\"//result[@numFound='0']\"\n    );\n\n    String termsMethod = new String[]{\"termsFilter\", \"booleanQuery\", \"automaton\", \"docValuesTermsFilter\"}[random().nextInt(4)];\n    assertQ(req( \"q\", \"{!terms f=v_s method=\" + termsMethod + \" }other stuff,wow dude\")\n        ,\"//result[@numFound='2']\"\n    );\n\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id_i\",999\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id_i\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n    // switch queries\n    assertQ(\"test matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case.z=Yonik} x \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik}  \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=''}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=$qq}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test matching switch query w/deref\",\n            req(\"q\", \"{!switch case.x=$d case.z=Yonik} x \",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik}asdf\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test empty default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik v=$qq}\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n\n    try {\n      ignoreException(\"No\\\\ default\\\\, and no switch case\");\n      assertQ(\"no match and no default\",\n              req(\"q\", \"{!switch case.x=Dude case.z=Yonik}asdf\")\n              ,\"//result[@numFound='BOGUS']\");\n      fail(\"Should have gotten an error w/o default\");\n    } catch (RuntimeException exp) {\n      assertTrue(\"exp cause is wrong\", \n                 exp.getCause() instanceof SolrException);\n      SolrException e = (SolrException) exp.getCause();\n      assertEquals(\"error isn't user error\", 400, e.code());\n      assertTrue(\"Error doesn't include bad switch case: \" + e.getMessage(),\n                 e.getMessage().contains(\"asdf\"));\n    } finally {\n      resetExceptionIgnores();\n    }\n                \n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"Test text field with no analysis doesn't NPE with wildcards (SOLR-4318)\",\n        req(\"q\", \"text_no_analyzer:should*\"), \"//result[@numFound='1']\");\n\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"de5f7f4e540abb3a137e7a296e06a94c90d21f8c","date":1545416763,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n    assertU(adoc(\"id\",\"10\",\"text_no_analyzer\",\"should just work\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // term qparser\n      assertQ(req( \"q\", \"{!term f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // terms qparser\n      //wrap in spaces sometimes if space separated\n      final String separator = f == \"v_s\" ? \"\" : \"separator=' '\";//use space separated when field isn't v_s\n      String vMod = separator != \"\" && random().nextBoolean() ? \" \" + v + \" \" : v;\n      assertQ(req( \"q\", \"{!terms \" + separator + \" f=\" +f+\"}\"+vMod)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // terms qparser, no values matches nothing\n    assertQ(req( \"q\", \"*:*\", \"fq\", \"{!terms f=v_s}\")\n        ,\"//result[@numFound='0']\"\n    );\n\n    String termsMethod = new String[]{\"termsFilter\", \"booleanQuery\", \"automaton\", \"docValuesTermsFilter\"}[random().nextInt(4)];\n    assertQ(req( \"q\", \"{!terms f=v_s method=\" + termsMethod + \" }wow dude,other stuff\")//terms reverse sorted to show this works\n        ,\"//result[@numFound='2']\"\n    );\n\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id_i\",999\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id_i\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n    // switch queries\n    assertQ(\"test matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case.z=Yonik} x \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik}  \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=''}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=$qq}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test matching switch query w/deref\",\n            req(\"q\", \"{!switch case.x=$d case.z=Yonik} x \",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik}asdf\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test empty default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik v=$qq}\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n\n    try {\n      ignoreException(\"No\\\\ default\\\\, and no switch case\");\n      RuntimeException exp = expectThrows(RuntimeException.class, \"Should have gotten an error w/o default\",\n          () -> assertQ(\"no match and no default\",\n              req(\"q\", \"{!switch case.x=Dude case.z=Yonik}asdf\")\n              , \"//result[@numFound='BOGUS']\")\n      );\n      assertTrue(\"exp cause is wrong\",\n          exp.getCause() instanceof SolrException);\n      SolrException e = (SolrException) exp.getCause();\n      assertEquals(\"error isn't user error\", 400, e.code());\n      assertTrue(\"Error doesn't include bad switch case: \" + e.getMessage(),\n          e.getMessage().contains(\"asdf\"));\n    } finally {\n      resetExceptionIgnores();\n    }\n                \n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"Test text field with no analysis doesn't NPE with wildcards (SOLR-4318)\",\n        req(\"q\", \"text_no_analyzer:should*\"), \"//result[@numFound='1']\");\n\n    \n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n    assertU(adoc(\"id\",\"10\",\"text_no_analyzer\",\"should just work\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // term qparser\n      assertQ(req( \"q\", \"{!term f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // terms qparser\n      //wrap in spaces sometimes if space separated\n      final String separator = f == \"v_s\" ? \"\" : \"separator=' '\";//use space separated when field isn't v_s\n      String vMod = separator != \"\" && random().nextBoolean() ? \" \" + v + \" \" : v;\n      assertQ(req( \"q\", \"{!terms \" + separator + \" f=\" +f+\"}\"+vMod)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // terms qparser, no values matches nothing\n    assertQ(req( \"q\", \"*:*\", \"fq\", \"{!terms f=v_s}\")\n        ,\"//result[@numFound='0']\"\n    );\n\n    String termsMethod = new String[]{\"termsFilter\", \"booleanQuery\", \"automaton\", \"docValuesTermsFilter\"}[random().nextInt(4)];\n    assertQ(req( \"q\", \"{!terms f=v_s method=\" + termsMethod + \" }other stuff,wow dude\")\n        ,\"//result[@numFound='2']\"\n    );\n\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id_i\",999\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id_i\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n    // switch queries\n    assertQ(\"test matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case.z=Yonik} x \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik}  \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=''}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=$qq}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test matching switch query w/deref\",\n            req(\"q\", \"{!switch case.x=$d case.z=Yonik} x \",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik}asdf\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test empty default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik v=$qq}\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n\n    try {\n      ignoreException(\"No\\\\ default\\\\, and no switch case\");\n      RuntimeException exp = expectThrows(RuntimeException.class, \"Should have gotten an error w/o default\",\n          () -> assertQ(\"no match and no default\",\n              req(\"q\", \"{!switch case.x=Dude case.z=Yonik}asdf\")\n              , \"//result[@numFound='BOGUS']\")\n      );\n      assertTrue(\"exp cause is wrong\",\n          exp.getCause() instanceof SolrException);\n      SolrException e = (SolrException) exp.getCause();\n      assertEquals(\"error isn't user error\", 400, e.code());\n      assertTrue(\"Error doesn't include bad switch case: \" + e.getMessage(),\n          e.getMessage().contains(\"asdf\"));\n    } finally {\n      resetExceptionIgnores();\n    }\n                \n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"Test text field with no analysis doesn't NPE with wildcards (SOLR-4318)\",\n        req(\"q\", \"text_no_analyzer:should*\"), \"//result[@numFound='1']\");\n\n    \n  }\n\n","bugFix":["f4861e30a499100f61274a97de931c33fe3ea1b0"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"25ac2f9979f7ec55452db533f9abf5c603cb1996","date":1550225366,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n    assertU(adoc(\"id\",\"10\",\"text_no_analyzer\",\"should just work\"));\n\n\n    assertU(adoc(\"id\", \"200\", \"subject_t\", \"Sony Netzteil\"));\n    assertU(adoc(\"id\", \"201\", \"subject_t\", \"Other Netzteil\"));\n    assertU(adoc(\"id\", \"202\", \"subject_t\", \"Other Product\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // term qparser\n      assertQ(req( \"q\", \"{!term f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // terms qparser\n      //wrap in spaces sometimes if space separated\n      final String separator = f == \"v_s\" ? \"\" : \"separator=' '\";//use space separated when field isn't v_s\n      String vMod = separator != \"\" && random().nextBoolean() ? \" \" + v + \" \" : v;\n      assertQ(req( \"q\", \"{!terms \" + separator + \" f=\" +f+\"}\"+vMod)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // terms qparser, no values matches nothing\n    assertQ(req( \"q\", \"*:*\", \"fq\", \"{!terms f=v_s}\")\n        ,\"//result[@numFound='0']\"\n    );\n\n    String termsMethod = new String[]{\"termsFilter\", \"booleanQuery\", \"automaton\", \"docValuesTermsFilter\"}[random().nextInt(4)];\n    assertQ(req( \"q\", \"{!terms f=v_s method=\" + termsMethod + \" }wow dude,other stuff\")//terms reverse sorted to show this works\n        ,\"//result[@numFound='2']\"\n    );\n\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id_i\",999\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id_i\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n    // multiplicative boosts combine correctly\n    assertQ(\n        req(\"q\", \"{!boost b=$ymb}(+{!lucene v=$yq})\",\n            \"ymb\", \"product(query({!v=subject_t:Netzteil^=2.0},1),query({!v=subject_t:Sony^=3.0},1))\",\n            \"yq\", \"subject_t:*\",\n            \"fl\", \"*,score\", \"indent\", \"on\"),\n        \"//doc[str[@name='id'][.='200'] and float[@name='score'][.=6.0]]\",\n        \"//doc[str[@name='id'][.='202'] and float[@name='score'][.=1.0]]\",\n        \"//doc[str[@name='id'][.='201'] and float[@name='score'][.=2.0]]\"\n    );\n\n    // switch queries\n    assertQ(\"test matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case.z=Yonik} x \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik}  \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=''}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=$qq}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test matching switch query w/deref\",\n            req(\"q\", \"{!switch case.x=$d case.z=Yonik} x \",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik}asdf\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test empty default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik v=$qq}\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n\n    try {\n      ignoreException(\"No\\\\ default\\\\, and no switch case\");\n      RuntimeException exp = expectThrows(RuntimeException.class, \"Should have gotten an error w/o default\",\n          () -> assertQ(\"no match and no default\",\n              req(\"q\", \"{!switch case.x=Dude case.z=Yonik}asdf\")\n              , \"//result[@numFound='BOGUS']\")\n      );\n      assertTrue(\"exp cause is wrong\",\n          exp.getCause() instanceof SolrException);\n      SolrException e = (SolrException) exp.getCause();\n      assertEquals(\"error isn't user error\", 400, e.code());\n      assertTrue(\"Error doesn't include bad switch case: \" + e.getMessage(),\n          e.getMessage().contains(\"asdf\"));\n    } finally {\n      resetExceptionIgnores();\n    }\n                \n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"Test text field with no analysis doesn't NPE with wildcards (SOLR-4318)\",\n        req(\"q\", \"text_no_analyzer:should*\"), \"//result[@numFound='1']\");\n\n    \n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n    assertU(adoc(\"id\",\"10\",\"text_no_analyzer\",\"should just work\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // term qparser\n      assertQ(req( \"q\", \"{!term f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // terms qparser\n      //wrap in spaces sometimes if space separated\n      final String separator = f == \"v_s\" ? \"\" : \"separator=' '\";//use space separated when field isn't v_s\n      String vMod = separator != \"\" && random().nextBoolean() ? \" \" + v + \" \" : v;\n      assertQ(req( \"q\", \"{!terms \" + separator + \" f=\" +f+\"}\"+vMod)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // terms qparser, no values matches nothing\n    assertQ(req( \"q\", \"*:*\", \"fq\", \"{!terms f=v_s}\")\n        ,\"//result[@numFound='0']\"\n    );\n\n    String termsMethod = new String[]{\"termsFilter\", \"booleanQuery\", \"automaton\", \"docValuesTermsFilter\"}[random().nextInt(4)];\n    assertQ(req( \"q\", \"{!terms f=v_s method=\" + termsMethod + \" }wow dude,other stuff\")//terms reverse sorted to show this works\n        ,\"//result[@numFound='2']\"\n    );\n\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id_i\",999\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id_i\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n    // switch queries\n    assertQ(\"test matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case.z=Yonik} x \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik}  \")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=''}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test empty matching switch query\",\n            req(\"df\", \"v_t\",\n                \"q\", \"{!switch case.x=Dude case=Yonik v=$qq}\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='2']\");\n    assertQ(\"test matching switch query w/deref\",\n            req(\"q\", \"{!switch case.x=$d case.z=Yonik} x \",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik}asdf\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n    assertQ(\"test empty default switch query\",\n            req(\"q\", \"{!switch default=$d case.x=$d case.z=Yonik v=$qq}\",\n                \"df\", \"v_t\",\n                \"d\", \"Dude\")\n            ,\"//result[@numFound='1']\"\n            ,\"//*[@name='id'][.='1']\");\n\n    try {\n      ignoreException(\"No\\\\ default\\\\, and no switch case\");\n      RuntimeException exp = expectThrows(RuntimeException.class, \"Should have gotten an error w/o default\",\n          () -> assertQ(\"no match and no default\",\n              req(\"q\", \"{!switch case.x=Dude case.z=Yonik}asdf\")\n              , \"//result[@numFound='BOGUS']\")\n      );\n      assertTrue(\"exp cause is wrong\",\n          exp.getCause() instanceof SolrException);\n      SolrException e = (SolrException) exp.getCause();\n      assertEquals(\"error isn't user error\", 400, e.code());\n      assertTrue(\"Error doesn't include bad switch case: \" + e.getMessage(),\n          e.getMessage().contains(\"asdf\"));\n    } finally {\n      resetExceptionIgnores();\n    }\n                \n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"Test text field with no analysis doesn't NPE with wildcards (SOLR-4318)\",\n        req(\"q\", \"text_no_analyzer:should*\"), \"//result[@numFound='1']\");\n\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["ebd748c27c397d7a0310bf98d57110e777d24381","19275ba31e621f6da1b83bf13af75233876fd3d4"],"c30a2043fa096da35fb57b6f35ec8f1adc6e919a":["c26f00b574427b55127e869b935845554afde1fa"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"a71f63026529f3c1f03cfdd664910873ab2369ae":["92f8ab19a30ff70981e43b8cc78069cb0941476e"],"92f8ab19a30ff70981e43b8cc78069cb0941476e":["f4861e30a499100f61274a97de931c33fe3ea1b0"],"a91f19e3f7576973404e13b7ecfb8ae94f313921":["28288370235ed02234a64753cdbf0c6ec096304a"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["ebd748c27c397d7a0310bf98d57110e777d24381"],"de5f7f4e540abb3a137e7a296e06a94c90d21f8c":["464e7336798bc8a1281d5cf610c649c5a0784e83"],"25ac2f9979f7ec55452db533f9abf5c603cb1996":["de5f7f4e540abb3a137e7a296e06a94c90d21f8c"],"f4861e30a499100f61274a97de931c33fe3ea1b0":["cd601dcb2e94bd4cc97a3f603ab1c65b480a0be3"],"28288370235ed02234a64753cdbf0c6ec096304a":["f4861e30a499100f61274a97de931c33fe3ea1b0","a71f63026529f3c1f03cfdd664910873ab2369ae"],"cd601dcb2e94bd4cc97a3f603ab1c65b480a0be3":["19275ba31e621f6da1b83bf13af75233876fd3d4"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4aee4980038a10791618ea04e79233ce5cbf6607":["28288370235ed02234a64753cdbf0c6ec096304a","a91f19e3f7576973404e13b7ecfb8ae94f313921"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ebd748c27c397d7a0310bf98d57110e777d24381":["c30a2043fa096da35fb57b6f35ec8f1adc6e919a"],"464e7336798bc8a1281d5cf610c649c5a0784e83":["4aee4980038a10791618ea04e79233ce5cbf6607"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["f4861e30a499100f61274a97de931c33fe3ea1b0","a71f63026529f3c1f03cfdd664910873ab2369ae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["25ac2f9979f7ec55452db533f9abf5c603cb1996"]},"commit2Childs":{"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":[],"c30a2043fa096da35fb57b6f35ec8f1adc6e919a":["ebd748c27c397d7a0310bf98d57110e777d24381"],"c26f00b574427b55127e869b935845554afde1fa":["c30a2043fa096da35fb57b6f35ec8f1adc6e919a"],"a71f63026529f3c1f03cfdd664910873ab2369ae":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"92f8ab19a30ff70981e43b8cc78069cb0941476e":["a71f63026529f3c1f03cfdd664910873ab2369ae"],"a91f19e3f7576973404e13b7ecfb8ae94f313921":["4aee4980038a10791618ea04e79233ce5cbf6607"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","cd601dcb2e94bd4cc97a3f603ab1c65b480a0be3"],"de5f7f4e540abb3a137e7a296e06a94c90d21f8c":["25ac2f9979f7ec55452db533f9abf5c603cb1996"],"f4861e30a499100f61274a97de931c33fe3ea1b0":["92f8ab19a30ff70981e43b8cc78069cb0941476e","28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"28288370235ed02234a64753cdbf0c6ec096304a":["a91f19e3f7576973404e13b7ecfb8ae94f313921","4aee4980038a10791618ea04e79233ce5cbf6607"],"25ac2f9979f7ec55452db533f9abf5c603cb1996":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd601dcb2e94bd4cc97a3f603ab1c65b480a0be3":["f4861e30a499100f61274a97de931c33fe3ea1b0"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"4aee4980038a10791618ea04e79233ce5cbf6607":["464e7336798bc8a1281d5cf610c649c5a0784e83"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"ebd748c27c397d7a0310bf98d57110e777d24381":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","19275ba31e621f6da1b83bf13af75233876fd3d4"],"464e7336798bc8a1281d5cf610c649c5a0784e83":["de5f7f4e540abb3a137e7a296e06a94c90d21f8c"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","a258fbb26824fd104ed795e5d9033d2d040049ee","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}