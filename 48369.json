{"path":"src/java/org/apache/solr/analysis/WordDelimiterFilter#next(Token).mjava","commits":[{"id":"fe8ae1ed027200f075b0de9f264776fa32c4862f","date":1207066219,"type":1,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/solr/analysis/WordDelimiterFilter#next(Token).mjava","pathOld":"src/java/org/apache/solr/analysis/WordDelimiterFilter#next().mjava","sourceNew":"  public final Token next(Token in) throws IOException {\n\n    // check the queue first\n    if (queuePos<queue.size()) {\n      return queue.get(queuePos++);\n    }\n\n    // reset the queue if it had been previously used\n    if (queuePos!=0) {\n      queuePos=0;\n      queue.clear();\n    }\n\n\n    // optimize for the common case: assume there will be\n    // no subwords (just a simple word)\n    //\n    // Would it actually be faster to check for the common form\n    // of isLetter() isLower()*, and then backtrack if it doesn't match?\n\n    int origPosIncrement;\n    while(true) {\n      Token t = input.next();\n      if (t == null) return null;\n\n      char [] termBuffer = t.termBuffer();\n      int len = t.termLength();\n      int start=0;\n      if (len ==0) continue;\n\n      origPosIncrement = t.getPositionIncrement();\n\n      // Avoid calling charType more than once for each char (basically\n      // avoid any backtracking).\n      // makes code slightly more difficult, but faster.\n      int ch=termBuffer[start];\n      int type=charType(ch);\n\n      int numWords=0;\n\n      while (start< len) {\n        // first eat delimiters at the start of this subword\n        while ((type & SUBWORD_DELIM)!=0 && ++start< len) {\n          ch=termBuffer[start];\n          type=charType(ch);\n        }\n\n        int pos=start;\n\n        // save the type of the first char of the subword\n        // as a way to tell what type of subword token this is (number, word, etc)\n        int firstType=type;\n        int lastType=type;  // type of the previously read char\n\n\n        while (pos< len) {\n\n          if (type!=lastType) {\n            // check and remove \"'s\" from the end of a token.\n            // the pattern to check for is\n            //   ALPHA \"'\" (\"s\"|\"S\") (SUBWORD_DELIM | END)\n            if ((lastType & ALPHA)!=0) {\n              if (ch=='\\'' && pos+1< len\n                      && (termBuffer[pos+1]=='s' || termBuffer[pos+1]=='S'))\n              {\n                int subWordEnd=pos;\n                if (pos+2>= len) {\n                  // end of string detected after \"'s\"\n                  pos+=2;\n                } else {\n                  // make sure that a delimiter follows \"'s\"\n                  int ch2 = termBuffer[pos+2];\n                  int type2 = charType(ch2);\n                  if ((type2 & SUBWORD_DELIM)!=0) {\n                    // if delimiter, move position pointer\n                    // to it (skipping over \"'s\"\n                    ch=ch2;\n                    type=type2;\n                    pos+=2;\n                  }\n                }\n\n                queue.add(newTok(t,start,subWordEnd));\n                if ((firstType & ALPHA)!=0) numWords++;\n                break;\n              }\n            }\n\n            // For case changes, only split on a transition from\n            // lower to upper case, not vice-versa.\n            // That will correctly handle the\n            // case of a word starting with a capital (won't split).\n            // It will also handle pluralization of\n            // an uppercase word such as FOOs (won't split).\n\n            if (splitOnCaseChange == 0 && \n                (lastType & ALPHA) != 0 && (type & ALPHA) != 0) {\n              // ALPHA->ALPHA: always ignore if case isn't considered.\n\n            } else if ((lastType & UPPER)!=0 && (type & LOWER)!=0) {\n              // UPPER->LOWER: Don't split\n            } else {\n              // NOTE: this code currently assumes that only one flag\n              // is set for each character now, so we don't have\n              // to explicitly check for all the classes of transitions\n              // listed below.\n\n              // LOWER->UPPER\n              // ALPHA->NUMERIC\n              // NUMERIC->ALPHA\n              // *->DELIMITER\n              queue.add(newTok(t,start,pos));\n              if ((firstType & ALPHA)!=0) numWords++;\n              break;\n            }\n          }\n\n          if (++pos >= len) {\n            if (start==0) {\n              // the subword is the whole original token, so\n              // return it unchanged.\n              return t;\n            }\n\n            Token newtok = newTok(t,start,pos);\n\n            // optimization... if this is the only token,\n            // return it immediately.\n            if (queue.size()==0) {\n              newtok.setPositionIncrement(origPosIncrement);\n              return newtok;\n            }\n\n            queue.add(newtok);\n            if ((firstType & ALPHA)!=0) numWords++;\n            break;\n          }\n\n          lastType = type;\n          ch = termBuffer[pos];\n          type = charType(ch);\n        }\n\n        // start of the next subword is the current position\n        start=pos;\n      }\n\n      // System.out.println(\"##########TOKEN=\" + s + \" ######### WORD DELIMITER QUEUE=\" + str(queue));\n\n      final int numtok = queue.size();\n\n      // We reached the end of the current token.\n      // If the queue is empty, we should continue by reading\n      // the next token\n      if (numtok==0) {\n        continue;\n      }\n\n      // if number of tokens is 1, always return the single tok\n      if (numtok==1) {\n        break;\n      }\n\n      final int numNumbers = numtok - numWords;\n\n      // check conditions under which the current token\n      // queue may be used as-is (no catenations needed)\n      if (catenateAll==0    // no \"everything\" to catenate\n        && (catenateWords==0 || numWords<=1)   // no words to catenate\n        && (catenateNumbers==0 || numNumbers<=1)    // no numbers to catenate\n        && (generateWordParts!=0 || numWords==0)  // word generation is on\n        && (generateNumberParts!=0 || numNumbers==0)) // number generation is on\n      {\n        break;\n      }\n\n\n      // swap queue and the temporary working list, then clear the\n      // queue in preparation for adding all combinations back to it.\n      ArrayList<Token> tmp=tlist;\n      tlist=queue;\n      queue=tmp;\n      queue.clear();\n\n      if (numWords==0) {\n        // all numbers\n        addCombos(tlist,0,numtok,generateNumberParts!=0,catenateNumbers!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      } else if (numNumbers==0) {\n        // all words\n        addCombos(tlist,0,numtok,generateWordParts!=0,catenateWords!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      } else if (generateNumberParts==0 && generateWordParts==0 && catenateNumbers==0 && catenateWords==0) {\n        // catenate all *only*\n        // OPT:could be optimized to add to current queue...\n        addCombos(tlist,0,numtok,false,catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      }\n\n      //\n      // Find all adjacent tokens of the same type.\n      //\n      Token tok = tlist.get(0);\n      boolean isWord = (tokType(tok) & ALPHA) != 0;\n      boolean wasWord=isWord;\n\n      for(int i=0; i<numtok;) {\n          int j;\n          for (j=i+1; j<numtok; j++) {\n            wasWord=isWord;\n            tok = tlist.get(j);\n            isWord = (tokType(tok) & ALPHA) != 0;\n            if (isWord != wasWord) break;\n          }\n          if (wasWord) {\n            addCombos(tlist,i,j,generateWordParts!=0,catenateWords!=0,1);\n          } else {\n            addCombos(tlist,i,j,generateNumberParts!=0,catenateNumbers!=0,1);\n          }\n          i=j;\n      }\n\n      // take care catenating all subwords\n      if (catenateAll!=0) {\n        addCombos(tlist,0,numtok,false,true,0);\n      }\n\n      // NOTE: in certain cases, queue may be empty (for instance, if catenate\n      // and generate are both set to false).  Only exit the loop if the queue\n      // is not empty.\n      if (queue.size() > 0) break;\n    }\n\n    // System.out.println(\"##########AFTER COMBINATIONS:\"+ str(queue));\n\n    queuePos=1;\n    Token tok = queue.get(0);\n    tok.setPositionIncrement(origPosIncrement);\n    return tok;\n  }\n\n","sourceOld":"  public final Token next() throws IOException {\n\n    // check the queue first\n    if (queuePos<queue.size()) {\n      return queue.get(queuePos++);\n    }\n\n    // reset the queue if it had been previously used\n    if (queuePos!=0) {\n      queuePos=0;\n      queue.clear();\n    }\n\n\n    // optimize for the common case: assume there will be\n    // no subwords (just a simple word)\n    //\n    // Would it actually be faster to check for the common form\n    // of isLetter() isLower()*, and then backtrack if it doesn't match?\n\n    int origPosIncrement;\n    while(true) {\n      Token t = input.next();\n      if (t == null) return null;\n\n      String s = t.termText();\n      int start=0;\n      int end=s.length();\n      if (end==0) continue;\n\n      origPosIncrement = t.getPositionIncrement();\n\n      // Avoid calling charType more than once for each char (basically\n      // avoid any backtracking).\n      // makes code slightly more difficult, but faster.\n      int ch=s.charAt(start);\n      int type=charType(ch);\n\n      int numWords=0;\n\n      while (start<end) {\n        // first eat delimiters at the start of this subword\n        while ((type & SUBWORD_DELIM)!=0 && ++start<end) {\n          ch=s.charAt(start);\n          type=charType(ch);\n        }\n\n        int pos=start;\n\n        // save the type of the first char of the subword\n        // as a way to tell what type of subword token this is (number, word, etc)\n        int firstType=type;\n        int lastType=type;  // type of the previously read char\n\n\n        while (pos<end) {\n\n          if (type!=lastType) {\n            // check and remove \"'s\" from the end of a token.\n            // the pattern to check for is\n            //   ALPHA \"'\" (\"s\"|\"S\") (SUBWORD_DELIM | END)\n            if ((lastType & ALPHA)!=0) {\n              if (ch=='\\'' && pos+1<end\n                      && (s.charAt(pos+1)=='s' || s.charAt(pos+1)=='S'))\n              {\n                int subWordEnd=pos;\n                if (pos+2>=end) {\n                  // end of string detected after \"'s\"\n                  pos+=2;\n                } else {\n                  // make sure that a delimiter follows \"'s\"\n                  int ch2 = s.charAt(pos+2);\n                  int type2 = charType(ch2);\n                  if ((type2 & SUBWORD_DELIM)!=0) {\n                    // if delimiter, move position pointer\n                    // to it (skipping over \"'s\"\n                    ch=ch2;\n                    type=type2;\n                    pos+=2;\n                  }\n                }\n\n                queue.add(newTok(t,start,subWordEnd));\n                if ((firstType & ALPHA)!=0) numWords++;\n                break;\n              }\n            }\n\n            // For case changes, only split on a transition from\n            // lower to upper case, not vice-versa.\n            // That will correctly handle the\n            // case of a word starting with a capital (won't split).\n            // It will also handle pluralization of\n            // an uppercase word such as FOOs (won't split).\n\n            if (splitOnCaseChange == 0 && \n                (lastType & ALPHA) != 0 && (type & ALPHA) != 0) {\n              // ALPHA->ALPHA: always ignore if case isn't considered.\n\n            } else if ((lastType & UPPER)!=0 && (type & LOWER)!=0) {\n              // UPPER->LOWER: Don't split\n            } else {\n              // NOTE: this code currently assumes that only one flag\n              // is set for each character now, so we don't have\n              // to explicitly check for all the classes of transitions\n              // listed below.\n\n              // LOWER->UPPER\n              // ALPHA->NUMERIC\n              // NUMERIC->ALPHA\n              // *->DELIMITER\n              queue.add(newTok(t,start,pos));\n              if ((firstType & ALPHA)!=0) numWords++;\n              break;\n            }\n          }\n\n          if (++pos >= end) {\n            if (start==0) {\n              // the subword is the whole original token, so\n              // return it unchanged.\n              return t;\n            }\n\n            Token newtok = newTok(t,start,pos);\n\n            // optimization... if this is the only token,\n            // return it immediately.\n            if (queue.size()==0) {\n              newtok.setPositionIncrement(origPosIncrement);\n              return newtok;\n            }\n\n            queue.add(newtok);\n            if ((firstType & ALPHA)!=0) numWords++;\n            break;\n          }\n\n          lastType = type;\n          ch = s.charAt(pos);\n          type = charType(ch);\n        }\n\n        // start of the next subword is the current position\n        start=pos;\n      }\n\n      // System.out.println(\"##########TOKEN=\" + s + \" ######### WORD DELIMITER QUEUE=\" + str(queue));\n\n      final int numtok = queue.size();\n\n      // We reached the end of the current token.\n      // If the queue is empty, we should continue by reading\n      // the next token\n      if (numtok==0) {\n        continue;\n      }\n\n      // if number of tokens is 1, always return the single tok\n      if (numtok==1) {\n        break;\n      }\n\n      final int numNumbers = numtok - numWords;\n\n      // check conditions under which the current token\n      // queue may be used as-is (no catenations needed)\n      if (catenateAll==0    // no \"everything\" to catenate\n        && (catenateWords==0 || numWords<=1)   // no words to catenate\n        && (catenateNumbers==0 || numNumbers<=1)    // no numbers to catenate\n        && (generateWordParts!=0 || numWords==0)  // word generation is on\n        && (generateNumberParts!=0 || numNumbers==0)) // number generation is on\n      {\n        break;\n      }\n\n\n      // swap queue and the temporary working list, then clear the\n      // queue in preparation for adding all combinations back to it.\n      ArrayList<Token> tmp=tlist;\n      tlist=queue;\n      queue=tmp;\n      queue.clear();\n\n      if (numWords==0) {\n        // all numbers\n        addCombos(tlist,0,numtok,generateNumberParts!=0,catenateNumbers!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      } else if (numNumbers==0) {\n        // all words\n        addCombos(tlist,0,numtok,generateWordParts!=0,catenateWords!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      } else if (generateNumberParts==0 && generateWordParts==0 && catenateNumbers==0 && catenateWords==0) {\n        // catenate all *only*\n        // OPT:could be optimized to add to current queue...\n        addCombos(tlist,0,numtok,false,catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      }\n\n      //\n      // Find all adjacent tokens of the same type.\n      //\n      Token tok = tlist.get(0);\n      boolean isWord = (tokType(tok) & ALPHA) != 0;\n      boolean wasWord=isWord;\n\n      for(int i=0; i<numtok;) {\n          int j;\n          for (j=i+1; j<numtok; j++) {\n            wasWord=isWord;\n            tok = tlist.get(j);\n            isWord = (tokType(tok) & ALPHA) != 0;\n            if (isWord != wasWord) break;\n          }\n          if (wasWord) {\n            addCombos(tlist,i,j,generateWordParts!=0,catenateWords!=0,1);\n          } else {\n            addCombos(tlist,i,j,generateNumberParts!=0,catenateNumbers!=0,1);\n          }\n          i=j;\n      }\n\n      // take care catenating all subwords\n      if (catenateAll!=0) {\n        addCombos(tlist,0,numtok,false,true,0);\n      }\n\n      // NOTE: in certain cases, queue may be empty (for instance, if catenate\n      // and generate are both set to false).  Only exit the loop if the queue\n      // is not empty.\n      if (queue.size() > 0) break;\n    }\n\n    // System.out.println(\"##########AFTER COMBINATIONS:\"+ str(queue));\n\n    queuePos=1;\n    Token tok = queue.get(0);\n    tok.setPositionIncrement(origPosIncrement);\n    return tok;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a343ab0901fd528cc211c9731de1e0f4fd319e6d","date":1208117222,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/analysis/WordDelimiterFilter#next(Token).mjava","pathOld":"src/java/org/apache/solr/analysis/WordDelimiterFilter#next(Token).mjava","sourceNew":"  public final Token next(Token in) throws IOException {\n\n    // check the queue first\n    if (queuePos<queue.size()) {\n      return queue.get(queuePos++);\n    }\n\n    // reset the queue if it had been previously used\n    if (queuePos!=0) {\n      queuePos=0;\n      queue.clear();\n    }\n\n\n    // optimize for the common case: assume there will be\n    // no subwords (just a simple word)\n    //\n    // Would it actually be faster to check for the common form\n    // of isLetter() isLower()*, and then backtrack if it doesn't match?\n\n    int origPosIncrement;\n    while(true) {\n      // t is either returned, or a new token is made from it, so it should\n      // be safe to use the next(Token) method.\n      Token t = input.next(in);\n      if (t == null) return null;\n\n      char [] termBuffer = t.termBuffer();\n      int len = t.termLength();\n      int start=0;\n      if (len ==0) continue;\n\n      origPosIncrement = t.getPositionIncrement();\n\n      // Avoid calling charType more than once for each char (basically\n      // avoid any backtracking).\n      // makes code slightly more difficult, but faster.\n      int ch=termBuffer[start];\n      int type=charType(ch);\n\n      int numWords=0;\n\n      while (start< len) {\n        // first eat delimiters at the start of this subword\n        while ((type & SUBWORD_DELIM)!=0 && ++start< len) {\n          ch=termBuffer[start];\n          type=charType(ch);\n        }\n\n        int pos=start;\n\n        // save the type of the first char of the subword\n        // as a way to tell what type of subword token this is (number, word, etc)\n        int firstType=type;\n        int lastType=type;  // type of the previously read char\n\n\n        while (pos< len) {\n\n          if (type!=lastType) {\n            // check and remove \"'s\" from the end of a token.\n            // the pattern to check for is\n            //   ALPHA \"'\" (\"s\"|\"S\") (SUBWORD_DELIM | END)\n            if ((lastType & ALPHA)!=0) {\n              if (ch=='\\'' && pos+1< len\n                      && (termBuffer[pos+1]=='s' || termBuffer[pos+1]=='S'))\n              {\n                int subWordEnd=pos;\n                if (pos+2>= len) {\n                  // end of string detected after \"'s\"\n                  pos+=2;\n                } else {\n                  // make sure that a delimiter follows \"'s\"\n                  int ch2 = termBuffer[pos+2];\n                  int type2 = charType(ch2);\n                  if ((type2 & SUBWORD_DELIM)!=0) {\n                    // if delimiter, move position pointer\n                    // to it (skipping over \"'s\"\n                    ch=ch2;\n                    type=type2;\n                    pos+=2;\n                  }\n                }\n\n                queue.add(newTok(t,start,subWordEnd));\n                if ((firstType & ALPHA)!=0) numWords++;\n                break;\n              }\n            }\n\n            // For case changes, only split on a transition from\n            // lower to upper case, not vice-versa.\n            // That will correctly handle the\n            // case of a word starting with a capital (won't split).\n            // It will also handle pluralization of\n            // an uppercase word such as FOOs (won't split).\n\n            if (splitOnCaseChange == 0 && \n                (lastType & ALPHA) != 0 && (type & ALPHA) != 0) {\n              // ALPHA->ALPHA: always ignore if case isn't considered.\n\n            } else if ((lastType & UPPER)!=0 && (type & LOWER)!=0) {\n              // UPPER->LOWER: Don't split\n            } else {\n              // NOTE: this code currently assumes that only one flag\n              // is set for each character now, so we don't have\n              // to explicitly check for all the classes of transitions\n              // listed below.\n\n              // LOWER->UPPER\n              // ALPHA->NUMERIC\n              // NUMERIC->ALPHA\n              // *->DELIMITER\n              queue.add(newTok(t,start,pos));\n              if ((firstType & ALPHA)!=0) numWords++;\n              break;\n            }\n          }\n\n          if (++pos >= len) {\n            if (start==0) {\n              // the subword is the whole original token, so\n              // return it unchanged.\n              return t;\n            }\n\n            Token newtok = newTok(t,start,pos);\n\n            // optimization... if this is the only token,\n            // return it immediately.\n            if (queue.size()==0) {\n              newtok.setPositionIncrement(origPosIncrement);\n              return newtok;\n            }\n\n            queue.add(newtok);\n            if ((firstType & ALPHA)!=0) numWords++;\n            break;\n          }\n\n          lastType = type;\n          ch = termBuffer[pos];\n          type = charType(ch);\n        }\n\n        // start of the next subword is the current position\n        start=pos;\n      }\n\n      // System.out.println(\"##########TOKEN=\" + s + \" ######### WORD DELIMITER QUEUE=\" + str(queue));\n\n      final int numtok = queue.size();\n\n      // We reached the end of the current token.\n      // If the queue is empty, we should continue by reading\n      // the next token\n      if (numtok==0) {\n        continue;\n      }\n\n      // if number of tokens is 1, always return the single tok\n      if (numtok==1) {\n        break;\n      }\n\n      final int numNumbers = numtok - numWords;\n\n      // check conditions under which the current token\n      // queue may be used as-is (no catenations needed)\n      if (catenateAll==0    // no \"everything\" to catenate\n        && (catenateWords==0 || numWords<=1)   // no words to catenate\n        && (catenateNumbers==0 || numNumbers<=1)    // no numbers to catenate\n        && (generateWordParts!=0 || numWords==0)  // word generation is on\n        && (generateNumberParts!=0 || numNumbers==0)) // number generation is on\n      {\n        break;\n      }\n\n\n      // swap queue and the temporary working list, then clear the\n      // queue in preparation for adding all combinations back to it.\n      ArrayList<Token> tmp=tlist;\n      tlist=queue;\n      queue=tmp;\n      queue.clear();\n\n      if (numWords==0) {\n        // all numbers\n        addCombos(tlist,0,numtok,generateNumberParts!=0,catenateNumbers!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      } else if (numNumbers==0) {\n        // all words\n        addCombos(tlist,0,numtok,generateWordParts!=0,catenateWords!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      } else if (generateNumberParts==0 && generateWordParts==0 && catenateNumbers==0 && catenateWords==0) {\n        // catenate all *only*\n        // OPT:could be optimized to add to current queue...\n        addCombos(tlist,0,numtok,false,catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      }\n\n      //\n      // Find all adjacent tokens of the same type.\n      //\n      Token tok = tlist.get(0);\n      boolean isWord = (tokType(tok) & ALPHA) != 0;\n      boolean wasWord=isWord;\n\n      for(int i=0; i<numtok;) {\n          int j;\n          for (j=i+1; j<numtok; j++) {\n            wasWord=isWord;\n            tok = tlist.get(j);\n            isWord = (tokType(tok) & ALPHA) != 0;\n            if (isWord != wasWord) break;\n          }\n          if (wasWord) {\n            addCombos(tlist,i,j,generateWordParts!=0,catenateWords!=0,1);\n          } else {\n            addCombos(tlist,i,j,generateNumberParts!=0,catenateNumbers!=0,1);\n          }\n          i=j;\n      }\n\n      // take care catenating all subwords\n      if (catenateAll!=0) {\n        addCombos(tlist,0,numtok,false,true,0);\n      }\n\n      // NOTE: in certain cases, queue may be empty (for instance, if catenate\n      // and generate are both set to false).  Only exit the loop if the queue\n      // is not empty.\n      if (queue.size() > 0) break;\n    }\n\n    // System.out.println(\"##########AFTER COMBINATIONS:\"+ str(queue));\n\n    queuePos=1;\n    Token tok = queue.get(0);\n    tok.setPositionIncrement(origPosIncrement);\n    return tok;\n  }\n\n","sourceOld":"  public final Token next(Token in) throws IOException {\n\n    // check the queue first\n    if (queuePos<queue.size()) {\n      return queue.get(queuePos++);\n    }\n\n    // reset the queue if it had been previously used\n    if (queuePos!=0) {\n      queuePos=0;\n      queue.clear();\n    }\n\n\n    // optimize for the common case: assume there will be\n    // no subwords (just a simple word)\n    //\n    // Would it actually be faster to check for the common form\n    // of isLetter() isLower()*, and then backtrack if it doesn't match?\n\n    int origPosIncrement;\n    while(true) {\n      Token t = input.next();\n      if (t == null) return null;\n\n      char [] termBuffer = t.termBuffer();\n      int len = t.termLength();\n      int start=0;\n      if (len ==0) continue;\n\n      origPosIncrement = t.getPositionIncrement();\n\n      // Avoid calling charType more than once for each char (basically\n      // avoid any backtracking).\n      // makes code slightly more difficult, but faster.\n      int ch=termBuffer[start];\n      int type=charType(ch);\n\n      int numWords=0;\n\n      while (start< len) {\n        // first eat delimiters at the start of this subword\n        while ((type & SUBWORD_DELIM)!=0 && ++start< len) {\n          ch=termBuffer[start];\n          type=charType(ch);\n        }\n\n        int pos=start;\n\n        // save the type of the first char of the subword\n        // as a way to tell what type of subword token this is (number, word, etc)\n        int firstType=type;\n        int lastType=type;  // type of the previously read char\n\n\n        while (pos< len) {\n\n          if (type!=lastType) {\n            // check and remove \"'s\" from the end of a token.\n            // the pattern to check for is\n            //   ALPHA \"'\" (\"s\"|\"S\") (SUBWORD_DELIM | END)\n            if ((lastType & ALPHA)!=0) {\n              if (ch=='\\'' && pos+1< len\n                      && (termBuffer[pos+1]=='s' || termBuffer[pos+1]=='S'))\n              {\n                int subWordEnd=pos;\n                if (pos+2>= len) {\n                  // end of string detected after \"'s\"\n                  pos+=2;\n                } else {\n                  // make sure that a delimiter follows \"'s\"\n                  int ch2 = termBuffer[pos+2];\n                  int type2 = charType(ch2);\n                  if ((type2 & SUBWORD_DELIM)!=0) {\n                    // if delimiter, move position pointer\n                    // to it (skipping over \"'s\"\n                    ch=ch2;\n                    type=type2;\n                    pos+=2;\n                  }\n                }\n\n                queue.add(newTok(t,start,subWordEnd));\n                if ((firstType & ALPHA)!=0) numWords++;\n                break;\n              }\n            }\n\n            // For case changes, only split on a transition from\n            // lower to upper case, not vice-versa.\n            // That will correctly handle the\n            // case of a word starting with a capital (won't split).\n            // It will also handle pluralization of\n            // an uppercase word such as FOOs (won't split).\n\n            if (splitOnCaseChange == 0 && \n                (lastType & ALPHA) != 0 && (type & ALPHA) != 0) {\n              // ALPHA->ALPHA: always ignore if case isn't considered.\n\n            } else if ((lastType & UPPER)!=0 && (type & LOWER)!=0) {\n              // UPPER->LOWER: Don't split\n            } else {\n              // NOTE: this code currently assumes that only one flag\n              // is set for each character now, so we don't have\n              // to explicitly check for all the classes of transitions\n              // listed below.\n\n              // LOWER->UPPER\n              // ALPHA->NUMERIC\n              // NUMERIC->ALPHA\n              // *->DELIMITER\n              queue.add(newTok(t,start,pos));\n              if ((firstType & ALPHA)!=0) numWords++;\n              break;\n            }\n          }\n\n          if (++pos >= len) {\n            if (start==0) {\n              // the subword is the whole original token, so\n              // return it unchanged.\n              return t;\n            }\n\n            Token newtok = newTok(t,start,pos);\n\n            // optimization... if this is the only token,\n            // return it immediately.\n            if (queue.size()==0) {\n              newtok.setPositionIncrement(origPosIncrement);\n              return newtok;\n            }\n\n            queue.add(newtok);\n            if ((firstType & ALPHA)!=0) numWords++;\n            break;\n          }\n\n          lastType = type;\n          ch = termBuffer[pos];\n          type = charType(ch);\n        }\n\n        // start of the next subword is the current position\n        start=pos;\n      }\n\n      // System.out.println(\"##########TOKEN=\" + s + \" ######### WORD DELIMITER QUEUE=\" + str(queue));\n\n      final int numtok = queue.size();\n\n      // We reached the end of the current token.\n      // If the queue is empty, we should continue by reading\n      // the next token\n      if (numtok==0) {\n        continue;\n      }\n\n      // if number of tokens is 1, always return the single tok\n      if (numtok==1) {\n        break;\n      }\n\n      final int numNumbers = numtok - numWords;\n\n      // check conditions under which the current token\n      // queue may be used as-is (no catenations needed)\n      if (catenateAll==0    // no \"everything\" to catenate\n        && (catenateWords==0 || numWords<=1)   // no words to catenate\n        && (catenateNumbers==0 || numNumbers<=1)    // no numbers to catenate\n        && (generateWordParts!=0 || numWords==0)  // word generation is on\n        && (generateNumberParts!=0 || numNumbers==0)) // number generation is on\n      {\n        break;\n      }\n\n\n      // swap queue and the temporary working list, then clear the\n      // queue in preparation for adding all combinations back to it.\n      ArrayList<Token> tmp=tlist;\n      tlist=queue;\n      queue=tmp;\n      queue.clear();\n\n      if (numWords==0) {\n        // all numbers\n        addCombos(tlist,0,numtok,generateNumberParts!=0,catenateNumbers!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      } else if (numNumbers==0) {\n        // all words\n        addCombos(tlist,0,numtok,generateWordParts!=0,catenateWords!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      } else if (generateNumberParts==0 && generateWordParts==0 && catenateNumbers==0 && catenateWords==0) {\n        // catenate all *only*\n        // OPT:could be optimized to add to current queue...\n        addCombos(tlist,0,numtok,false,catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      }\n\n      //\n      // Find all adjacent tokens of the same type.\n      //\n      Token tok = tlist.get(0);\n      boolean isWord = (tokType(tok) & ALPHA) != 0;\n      boolean wasWord=isWord;\n\n      for(int i=0; i<numtok;) {\n          int j;\n          for (j=i+1; j<numtok; j++) {\n            wasWord=isWord;\n            tok = tlist.get(j);\n            isWord = (tokType(tok) & ALPHA) != 0;\n            if (isWord != wasWord) break;\n          }\n          if (wasWord) {\n            addCombos(tlist,i,j,generateWordParts!=0,catenateWords!=0,1);\n          } else {\n            addCombos(tlist,i,j,generateNumberParts!=0,catenateNumbers!=0,1);\n          }\n          i=j;\n      }\n\n      // take care catenating all subwords\n      if (catenateAll!=0) {\n        addCombos(tlist,0,numtok,false,true,0);\n      }\n\n      // NOTE: in certain cases, queue may be empty (for instance, if catenate\n      // and generate are both set to false).  Only exit the loop if the queue\n      // is not empty.\n      if (queue.size() > 0) break;\n    }\n\n    // System.out.println(\"##########AFTER COMBINATIONS:\"+ str(queue));\n\n    queuePos=1;\n    Token tok = queue.get(0);\n    tok.setPositionIncrement(origPosIncrement);\n    return tok;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e0d0e8297e9b3e015826cdb7e42404953c339851","date":1215099614,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/analysis/WordDelimiterFilter#next(Token).mjava","pathOld":"src/java/org/apache/solr/analysis/WordDelimiterFilter#next(Token).mjava","sourceNew":"  public final Token next(Token in) throws IOException {\n\n    // check the queue first\n    if (queuePos<queue.size()) {\n      return queue.get(queuePos++);\n    }\n\n    // reset the queue if it had been previously used\n    if (queuePos!=0) {\n      queuePos=0;\n      queue.clear();\n    }\n\n\n    // optimize for the common case: assume there will be\n    // no subwords (just a simple word)\n    //\n    // Would it actually be faster to check for the common form\n    // of isLetter() isLower()*, and then backtrack if it doesn't match?\n\n    int origPosIncrement = 0;\n    Token t;\n    while(true) {\n      // t is either returned, or a new token is made from it, so it should\n      // be safe to use the next(Token) method.\n      t = input.next(in);\n      if (t == null) return null;\n\n      char [] termBuffer = t.termBuffer();\n      int len = t.termLength();\n      int start=0;\n      if (len ==0) continue;\n\n      origPosIncrement += t.getPositionIncrement();\n\n      // Avoid calling charType more than once for each char (basically\n      // avoid any backtracking).\n      // makes code slightly more difficult, but faster.\n      int ch=termBuffer[start];\n      int type=charType(ch);\n\n      int numWords=0;\n\n      while (start< len) {\n        // first eat delimiters at the start of this subword\n        while ((type & SUBWORD_DELIM)!=0 && ++start< len) {\n          ch=termBuffer[start];\n          type=charType(ch);\n        }\n\n        int pos=start;\n\n        // save the type of the first char of the subword\n        // as a way to tell what type of subword token this is (number, word, etc)\n        int firstType=type;\n        int lastType=type;  // type of the previously read char\n\n\n        while (pos< len) {\n\n          if (type!=lastType) {\n            // check and remove \"'s\" from the end of a token.\n            // the pattern to check for is\n            //   ALPHA \"'\" (\"s\"|\"S\") (SUBWORD_DELIM | END)\n            if ((lastType & ALPHA)!=0) {\n              if (ch=='\\'' && pos+1< len\n                      && (termBuffer[pos+1]=='s' || termBuffer[pos+1]=='S'))\n              {\n                int subWordEnd=pos;\n                if (pos+2>= len) {\n                  // end of string detected after \"'s\"\n                  pos+=2;\n                } else {\n                  // make sure that a delimiter follows \"'s\"\n                  int ch2 = termBuffer[pos+2];\n                  int type2 = charType(ch2);\n                  if ((type2 & SUBWORD_DELIM)!=0) {\n                    // if delimiter, move position pointer\n                    // to it (skipping over \"'s\"\n                    ch=ch2;\n                    type=type2;\n                    pos+=2;\n                  }\n                }\n\n                queue.add(newTok(t,start,subWordEnd));\n                if ((firstType & ALPHA)!=0) numWords++;\n                break;\n              }\n            }\n\n            // For case changes, only split on a transition from\n            // lower to upper case, not vice-versa.\n            // That will correctly handle the\n            // case of a word starting with a capital (won't split).\n            // It will also handle pluralization of\n            // an uppercase word such as FOOs (won't split).\n\n            if (splitOnCaseChange == 0 && \n                (lastType & ALPHA) != 0 && (type & ALPHA) != 0) {\n              // ALPHA->ALPHA: always ignore if case isn't considered.\n\n            } else if ((lastType & UPPER)!=0 && (type & LOWER)!=0) {\n              // UPPER->LOWER: Don't split\n            } else {\n              // NOTE: this code currently assumes that only one flag\n              // is set for each character now, so we don't have\n              // to explicitly check for all the classes of transitions\n              // listed below.\n\n              // LOWER->UPPER\n              // ALPHA->NUMERIC\n              // NUMERIC->ALPHA\n              // *->DELIMITER\n              queue.add(newTok(t,start,pos));\n              if ((firstType & ALPHA)!=0) numWords++;\n              break;\n            }\n          }\n\n          if (++pos >= len) {\n            if (start==0) {\n              // the subword is the whole original token, so\n              // return it unchanged.\n              return t;\n            }\n\n            // optimization... if this is the only token,\n            // return it immediately.\n            if (queue.size()==0 && preserveOriginal == 0) {\n              // just adjust the text w/o changing the rest\n              // of the original token\n              t.setTermBuffer(termBuffer, start, len-start);\n              return t;\n            }\n\n            Token newtok = newTok(t,start,pos);\n\n            queue.add(newtok);\n            if ((firstType & ALPHA)!=0) numWords++;\n            break;\n          }\n\n          lastType = type;\n          ch = termBuffer[pos];\n          type = charType(ch);\n        }\n\n        // start of the next subword is the current position\n        start=pos;\n      }\n\n      // System.out.println(\"##########TOKEN=\" + s + \" ######### WORD DELIMITER QUEUE=\" + str(queue));\n\n      final int numtok = queue.size();\n\n      // We reached the end of the current token.\n      // If the queue is empty, we should continue by reading\n      // the next token\n      if (numtok==0) {\n        // the token might have been all delimiters, in which\n        // case return it if we're meant to preserve it\n        if (preserveOriginal != 0) {\n          return t;\n        }\n        continue;\n      }\n\n      // if number of tokens is 1, there are no catenations to be done.\n      if (numtok==1) {\n        break;\n      }\n\n\n      final int numNumbers = numtok - numWords;\n\n      // check conditions under which the current token\n      // queue may be used as-is (no catenations needed)\n      if (catenateAll==0    // no \"everything\" to catenate\n        && (catenateWords==0 || numWords<=1)   // no words to catenate\n        && (catenateNumbers==0 || numNumbers<=1)    // no numbers to catenate\n        && (generateWordParts!=0 || numWords==0)  // word generation is on\n        && (generateNumberParts!=0 || numNumbers==0)) // number generation is on\n      {\n        break;\n      }\n\n\n      // swap queue and the temporary working list, then clear the\n      // queue in preparation for adding all combinations back to it.\n      ArrayList<Token> tmp=tlist;\n      tlist=queue;\n      queue=tmp;\n      queue.clear();\n\n      if (numWords==0) {\n        // all numbers\n        addCombos(tlist,0,numtok,generateNumberParts!=0,catenateNumbers!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      } else if (numNumbers==0) {\n        // all words\n        addCombos(tlist,0,numtok,generateWordParts!=0,catenateWords!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      } else if (generateNumberParts==0 && generateWordParts==0 && catenateNumbers==0 && catenateWords==0) {\n        // catenate all *only*\n        // OPT:could be optimized to add to current queue...\n        addCombos(tlist,0,numtok,false,catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      }\n\n      //\n      // Find all adjacent tokens of the same type.\n      //\n      Token tok = tlist.get(0);\n      boolean isWord = (tokType(tok) & ALPHA) != 0;\n      boolean wasWord=isWord;\n\n      for(int i=0; i<numtok;) {\n          int j;\n          for (j=i+1; j<numtok; j++) {\n            wasWord=isWord;\n            tok = tlist.get(j);\n            isWord = (tokType(tok) & ALPHA) != 0;\n            if (isWord != wasWord) break;\n          }\n          if (wasWord) {\n            addCombos(tlist,i,j,generateWordParts!=0,catenateWords!=0,1);\n          } else {\n            addCombos(tlist,i,j,generateNumberParts!=0,catenateNumbers!=0,1);\n          }\n          i=j;\n      }\n\n      // take care catenating all subwords\n      if (catenateAll!=0) {\n        addCombos(tlist,0,numtok,false,true,0);\n      }\n\n      // NOTE: in certain cases, queue may be empty (for instance, if catenate\n      // and generate are both set to false).  Only exit the loop if the queue\n      // is not empty.\n      if (queue.size() > 0 || preserveOriginal!=0) break;\n    }\n\n    // System.out.println(\"##########AFTER COMBINATIONS:\"+ str(queue));\n\n    if (preserveOriginal != 0) {\n      queuePos = 0;\n      if (queue.size() > 0) {\n        // overlap first token with the original\n        queue.get(0).setPositionIncrement(0);\n      }\n      return t;  // return the original\n    } else {\n      queuePos=1;\n      Token tok = queue.get(0);\n      tok.setPositionIncrement(origPosIncrement);\n      return tok;\n    }\n  }\n\n","sourceOld":"  public final Token next(Token in) throws IOException {\n\n    // check the queue first\n    if (queuePos<queue.size()) {\n      return queue.get(queuePos++);\n    }\n\n    // reset the queue if it had been previously used\n    if (queuePos!=0) {\n      queuePos=0;\n      queue.clear();\n    }\n\n\n    // optimize for the common case: assume there will be\n    // no subwords (just a simple word)\n    //\n    // Would it actually be faster to check for the common form\n    // of isLetter() isLower()*, and then backtrack if it doesn't match?\n\n    int origPosIncrement;\n    while(true) {\n      // t is either returned, or a new token is made from it, so it should\n      // be safe to use the next(Token) method.\n      Token t = input.next(in);\n      if (t == null) return null;\n\n      char [] termBuffer = t.termBuffer();\n      int len = t.termLength();\n      int start=0;\n      if (len ==0) continue;\n\n      origPosIncrement = t.getPositionIncrement();\n\n      // Avoid calling charType more than once for each char (basically\n      // avoid any backtracking).\n      // makes code slightly more difficult, but faster.\n      int ch=termBuffer[start];\n      int type=charType(ch);\n\n      int numWords=0;\n\n      while (start< len) {\n        // first eat delimiters at the start of this subword\n        while ((type & SUBWORD_DELIM)!=0 && ++start< len) {\n          ch=termBuffer[start];\n          type=charType(ch);\n        }\n\n        int pos=start;\n\n        // save the type of the first char of the subword\n        // as a way to tell what type of subword token this is (number, word, etc)\n        int firstType=type;\n        int lastType=type;  // type of the previously read char\n\n\n        while (pos< len) {\n\n          if (type!=lastType) {\n            // check and remove \"'s\" from the end of a token.\n            // the pattern to check for is\n            //   ALPHA \"'\" (\"s\"|\"S\") (SUBWORD_DELIM | END)\n            if ((lastType & ALPHA)!=0) {\n              if (ch=='\\'' && pos+1< len\n                      && (termBuffer[pos+1]=='s' || termBuffer[pos+1]=='S'))\n              {\n                int subWordEnd=pos;\n                if (pos+2>= len) {\n                  // end of string detected after \"'s\"\n                  pos+=2;\n                } else {\n                  // make sure that a delimiter follows \"'s\"\n                  int ch2 = termBuffer[pos+2];\n                  int type2 = charType(ch2);\n                  if ((type2 & SUBWORD_DELIM)!=0) {\n                    // if delimiter, move position pointer\n                    // to it (skipping over \"'s\"\n                    ch=ch2;\n                    type=type2;\n                    pos+=2;\n                  }\n                }\n\n                queue.add(newTok(t,start,subWordEnd));\n                if ((firstType & ALPHA)!=0) numWords++;\n                break;\n              }\n            }\n\n            // For case changes, only split on a transition from\n            // lower to upper case, not vice-versa.\n            // That will correctly handle the\n            // case of a word starting with a capital (won't split).\n            // It will also handle pluralization of\n            // an uppercase word such as FOOs (won't split).\n\n            if (splitOnCaseChange == 0 && \n                (lastType & ALPHA) != 0 && (type & ALPHA) != 0) {\n              // ALPHA->ALPHA: always ignore if case isn't considered.\n\n            } else if ((lastType & UPPER)!=0 && (type & LOWER)!=0) {\n              // UPPER->LOWER: Don't split\n            } else {\n              // NOTE: this code currently assumes that only one flag\n              // is set for each character now, so we don't have\n              // to explicitly check for all the classes of transitions\n              // listed below.\n\n              // LOWER->UPPER\n              // ALPHA->NUMERIC\n              // NUMERIC->ALPHA\n              // *->DELIMITER\n              queue.add(newTok(t,start,pos));\n              if ((firstType & ALPHA)!=0) numWords++;\n              break;\n            }\n          }\n\n          if (++pos >= len) {\n            if (start==0) {\n              // the subword is the whole original token, so\n              // return it unchanged.\n              return t;\n            }\n\n            Token newtok = newTok(t,start,pos);\n\n            // optimization... if this is the only token,\n            // return it immediately.\n            if (queue.size()==0) {\n              newtok.setPositionIncrement(origPosIncrement);\n              return newtok;\n            }\n\n            queue.add(newtok);\n            if ((firstType & ALPHA)!=0) numWords++;\n            break;\n          }\n\n          lastType = type;\n          ch = termBuffer[pos];\n          type = charType(ch);\n        }\n\n        // start of the next subword is the current position\n        start=pos;\n      }\n\n      // System.out.println(\"##########TOKEN=\" + s + \" ######### WORD DELIMITER QUEUE=\" + str(queue));\n\n      final int numtok = queue.size();\n\n      // We reached the end of the current token.\n      // If the queue is empty, we should continue by reading\n      // the next token\n      if (numtok==0) {\n        continue;\n      }\n\n      // if number of tokens is 1, always return the single tok\n      if (numtok==1) {\n        break;\n      }\n\n      final int numNumbers = numtok - numWords;\n\n      // check conditions under which the current token\n      // queue may be used as-is (no catenations needed)\n      if (catenateAll==0    // no \"everything\" to catenate\n        && (catenateWords==0 || numWords<=1)   // no words to catenate\n        && (catenateNumbers==0 || numNumbers<=1)    // no numbers to catenate\n        && (generateWordParts!=0 || numWords==0)  // word generation is on\n        && (generateNumberParts!=0 || numNumbers==0)) // number generation is on\n      {\n        break;\n      }\n\n\n      // swap queue and the temporary working list, then clear the\n      // queue in preparation for adding all combinations back to it.\n      ArrayList<Token> tmp=tlist;\n      tlist=queue;\n      queue=tmp;\n      queue.clear();\n\n      if (numWords==0) {\n        // all numbers\n        addCombos(tlist,0,numtok,generateNumberParts!=0,catenateNumbers!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      } else if (numNumbers==0) {\n        // all words\n        addCombos(tlist,0,numtok,generateWordParts!=0,catenateWords!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      } else if (generateNumberParts==0 && generateWordParts==0 && catenateNumbers==0 && catenateWords==0) {\n        // catenate all *only*\n        // OPT:could be optimized to add to current queue...\n        addCombos(tlist,0,numtok,false,catenateAll!=0, 1);\n        if (queue.size() > 0) break; else continue;\n      }\n\n      //\n      // Find all adjacent tokens of the same type.\n      //\n      Token tok = tlist.get(0);\n      boolean isWord = (tokType(tok) & ALPHA) != 0;\n      boolean wasWord=isWord;\n\n      for(int i=0; i<numtok;) {\n          int j;\n          for (j=i+1; j<numtok; j++) {\n            wasWord=isWord;\n            tok = tlist.get(j);\n            isWord = (tokType(tok) & ALPHA) != 0;\n            if (isWord != wasWord) break;\n          }\n          if (wasWord) {\n            addCombos(tlist,i,j,generateWordParts!=0,catenateWords!=0,1);\n          } else {\n            addCombos(tlist,i,j,generateNumberParts!=0,catenateNumbers!=0,1);\n          }\n          i=j;\n      }\n\n      // take care catenating all subwords\n      if (catenateAll!=0) {\n        addCombos(tlist,0,numtok,false,true,0);\n      }\n\n      // NOTE: in certain cases, queue may be empty (for instance, if catenate\n      // and generate are both set to false).  Only exit the loop if the queue\n      // is not empty.\n      if (queue.size() > 0) break;\n    }\n\n    // System.out.println(\"##########AFTER COMBINATIONS:\"+ str(queue));\n\n    queuePos=1;\n    Token tok = queue.get(0);\n    tok.setPositionIncrement(origPosIncrement);\n    return tok;\n  }\n\n","bugFix":null,"bugIntro":["1d786062be6da940351591ec2372ddd0ae56bd39"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29b4037cea5df1dd9c2c97042c70fd258218165a","date":1225837186,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/analysis/WordDelimiterFilter#next(Token).mjava","pathOld":"src/java/org/apache/solr/analysis/WordDelimiterFilter#next(Token).mjava","sourceNew":"  public final Token next(Token in) throws IOException {\n\n    // check the queue first\n    if (queuePos<queue.size()) {\n      return queue.get(queuePos++);\n    }\n\n    // reset the queue if it had been previously used\n    if (queuePos!=0) {\n      queuePos=0;\n      queue.clear();\n    }\n\n\n    // optimize for the common case: assume there will be\n    // no subwords (just a simple word)\n    //\n    // Would it actually be faster to check for the common form\n    // of isLetter() isLower()*, and then backtrack if it doesn't match?\n\n    int origPosIncrement = 0;\n    Token t;\n    while(true) {\n      // t is either returned, or a new token is made from it, so it should\n      // be safe to use the next(Token) method.\n      t = input.next(in);\n      if (t == null) return null;\n\n      char [] termBuffer = t.termBuffer();\n      int len = t.termLength();\n      int start=0;\n      if (len ==0) continue;\n\n      origPosIncrement += t.getPositionIncrement();\n\n      // Avoid calling charType more than once for each char (basically\n      // avoid any backtracking).\n      // makes code slightly more difficult, but faster.\n      int ch=termBuffer[start];\n      int type=charType(ch);\n\n      int numWords=0;\n\n      while (start< len) {\n        // first eat delimiters at the start of this subword\n        while ((type & SUBWORD_DELIM)!=0 && ++start< len) {\n          ch=termBuffer[start];\n          type=charType(ch);\n        }\n\n        int pos=start;\n\n        // save the type of the first char of the subword\n        // as a way to tell what type of subword token this is (number, word, etc)\n        int firstType=type;\n        int lastType=type;  // type of the previously read char\n\n\n        while (pos< len) {\n\n          if (type!=lastType) {\n            // check and remove \"'s\" from the end of a token.\n            // the pattern to check for is\n            //   ALPHA \"'\" (\"s\"|\"S\") (SUBWORD_DELIM | END)\n            if ((lastType & ALPHA)!=0) {\n              if (ch=='\\'' && pos+1< len\n                      && (termBuffer[pos+1]=='s' || termBuffer[pos+1]=='S'))\n              {\n                int subWordEnd=pos;\n                if (pos+2>= len) {\n                  // end of string detected after \"'s\"\n                  pos+=2;\n                } else {\n                  // make sure that a delimiter follows \"'s\"\n                  int ch2 = termBuffer[pos+2];\n                  int type2 = charType(ch2);\n                  if ((type2 & SUBWORD_DELIM)!=0) {\n                    // if delimiter, move position pointer\n                    // to it (skipping over \"'s\"\n                    ch=ch2;\n                    type=type2;\n                    pos+=2;\n                  }\n                }\n\n                queue.add(newTok(t,start,subWordEnd));\n                if ((firstType & ALPHA)!=0) numWords++;\n                break;\n              }\n            }\n\n            // For case changes, only split on a transition from\n            // lower to upper case, not vice-versa.\n            // That will correctly handle the\n            // case of a word starting with a capital (won't split).\n            // It will also handle pluralization of\n            // an uppercase word such as FOOs (won't split).\n\n            if (splitOnCaseChange == 0 && \n                (lastType & ALPHA) != 0 && (type & ALPHA) != 0) {\n              // ALPHA->ALPHA: always ignore if case isn't considered.\n\n            } else if ((lastType & UPPER)!=0 && (type & LOWER)!=0) {\n              // UPPER->LOWER: Don't split\n            } else {\n              // NOTE: this code currently assumes that only one flag\n              // is set for each character now, so we don't have\n              // to explicitly check for all the classes of transitions\n              // listed below.\n\n              // LOWER->UPPER\n              // ALPHA->NUMERIC\n              // NUMERIC->ALPHA\n              // *->DELIMITER\n              queue.add(newTok(t,start,pos));\n              if ((firstType & ALPHA)!=0) numWords++;\n              break;\n            }\n          }\n\n          if (++pos >= len) {\n            if (start==0) {\n              // the subword is the whole original token, so\n              // return it unchanged.\n              return t;\n            }\n\n            // optimization... if this is the only token,\n            // return it immediately.\n            if (queue.size()==0 && preserveOriginal == 0) {\n              // just adjust the text w/o changing the rest\n              // of the original token\n              t.setTermBuffer(termBuffer, start, len-start);\n              t.setStartOffset(t.startOffset() + start);\n              return t;\n            }\n\n            Token newtok = newTok(t,start,pos);\n\n            queue.add(newtok);\n            if ((firstType & ALPHA)!=0) numWords++;\n            break;\n          }\n\n          lastType = type;\n          ch = termBuffer[pos];\n          type = charType(ch);\n        }\n\n        // start of the next subword is the current position\n        start=pos;\n      }\n\n      // System.out.println(\"##########TOKEN=\" + s + \" ######### WORD DELIMITER QUEUE=\" + str(queue));\n\n      final int numtok = queue.size();\n\n      // We reached the end of the current token.\n      // If the queue is empty, we should continue by reading\n      // the next token\n      if (numtok==0) {\n        // the token might have been all delimiters, in which\n        // case return it if we're meant to preserve it\n        if (preserveOriginal != 0) {\n          return t;\n        }\n        continue;\n      }\n\n      // if number of tokens is 1, there are no catenations to be done.\n      if (numtok==1) {\n        break;\n      }\n\n\n      final int numNumbers = numtok - numWords;\n\n      // check conditions under which the current token\n      // queue may be used as-is (no catenations needed)\n      if (catenateAll==0    // no \"everything\" to catenate\n        && (catenateWords==0 || numWords<=1)   // no words to catenate\n        && (catenateNumbers==0 || numNumbers<=1)    // no numbers to catenate\n        && (generateWordParts!=0 || numWords==0)  // word generation is on\n        && (generateNumberParts!=0 || numNumbers==0)) // number generation is on\n      {\n        break;\n      }\n\n\n      // swap queue and the temporary working list, then clear the\n      // queue in preparation for adding all combinations back to it.\n      ArrayList<Token> tmp=tlist;\n      tlist=queue;\n      queue=tmp;\n      queue.clear();\n\n      if (numWords==0) {\n        // all numbers\n        addCombos(tlist,0,numtok,generateNumberParts!=0,catenateNumbers!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      } else if (numNumbers==0) {\n        // all words\n        addCombos(tlist,0,numtok,generateWordParts!=0,catenateWords!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      } else if (generateNumberParts==0 && generateWordParts==0 && catenateNumbers==0 && catenateWords==0) {\n        // catenate all *only*\n        // OPT:could be optimized to add to current queue...\n        addCombos(tlist,0,numtok,false,catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      }\n\n      //\n      // Find all adjacent tokens of the same type.\n      //\n      Token tok = tlist.get(0);\n      boolean isWord = (tokType(tok) & ALPHA) != 0;\n      boolean wasWord=isWord;\n\n      for(int i=0; i<numtok;) {\n          int j;\n          for (j=i+1; j<numtok; j++) {\n            wasWord=isWord;\n            tok = tlist.get(j);\n            isWord = (tokType(tok) & ALPHA) != 0;\n            if (isWord != wasWord) break;\n          }\n          if (wasWord) {\n            addCombos(tlist,i,j,generateWordParts!=0,catenateWords!=0,1);\n          } else {\n            addCombos(tlist,i,j,generateNumberParts!=0,catenateNumbers!=0,1);\n          }\n          i=j;\n      }\n\n      // take care catenating all subwords\n      if (catenateAll!=0) {\n        addCombos(tlist,0,numtok,false,true,0);\n      }\n\n      // NOTE: in certain cases, queue may be empty (for instance, if catenate\n      // and generate are both set to false).  Only exit the loop if the queue\n      // is not empty.\n      if (queue.size() > 0 || preserveOriginal!=0) break;\n    }\n\n    // System.out.println(\"##########AFTER COMBINATIONS:\"+ str(queue));\n\n    if (preserveOriginal != 0) {\n      queuePos = 0;\n      if (queue.size() > 0) {\n        // overlap first token with the original\n        queue.get(0).setPositionIncrement(0);\n      }\n      return t;  // return the original\n    } else {\n      queuePos=1;\n      Token tok = queue.get(0);\n      tok.setPositionIncrement(origPosIncrement);\n      return tok;\n    }\n  }\n\n","sourceOld":"  public final Token next(Token in) throws IOException {\n\n    // check the queue first\n    if (queuePos<queue.size()) {\n      return queue.get(queuePos++);\n    }\n\n    // reset the queue if it had been previously used\n    if (queuePos!=0) {\n      queuePos=0;\n      queue.clear();\n    }\n\n\n    // optimize for the common case: assume there will be\n    // no subwords (just a simple word)\n    //\n    // Would it actually be faster to check for the common form\n    // of isLetter() isLower()*, and then backtrack if it doesn't match?\n\n    int origPosIncrement = 0;\n    Token t;\n    while(true) {\n      // t is either returned, or a new token is made from it, so it should\n      // be safe to use the next(Token) method.\n      t = input.next(in);\n      if (t == null) return null;\n\n      char [] termBuffer = t.termBuffer();\n      int len = t.termLength();\n      int start=0;\n      if (len ==0) continue;\n\n      origPosIncrement += t.getPositionIncrement();\n\n      // Avoid calling charType more than once for each char (basically\n      // avoid any backtracking).\n      // makes code slightly more difficult, but faster.\n      int ch=termBuffer[start];\n      int type=charType(ch);\n\n      int numWords=0;\n\n      while (start< len) {\n        // first eat delimiters at the start of this subword\n        while ((type & SUBWORD_DELIM)!=0 && ++start< len) {\n          ch=termBuffer[start];\n          type=charType(ch);\n        }\n\n        int pos=start;\n\n        // save the type of the first char of the subword\n        // as a way to tell what type of subword token this is (number, word, etc)\n        int firstType=type;\n        int lastType=type;  // type of the previously read char\n\n\n        while (pos< len) {\n\n          if (type!=lastType) {\n            // check and remove \"'s\" from the end of a token.\n            // the pattern to check for is\n            //   ALPHA \"'\" (\"s\"|\"S\") (SUBWORD_DELIM | END)\n            if ((lastType & ALPHA)!=0) {\n              if (ch=='\\'' && pos+1< len\n                      && (termBuffer[pos+1]=='s' || termBuffer[pos+1]=='S'))\n              {\n                int subWordEnd=pos;\n                if (pos+2>= len) {\n                  // end of string detected after \"'s\"\n                  pos+=2;\n                } else {\n                  // make sure that a delimiter follows \"'s\"\n                  int ch2 = termBuffer[pos+2];\n                  int type2 = charType(ch2);\n                  if ((type2 & SUBWORD_DELIM)!=0) {\n                    // if delimiter, move position pointer\n                    // to it (skipping over \"'s\"\n                    ch=ch2;\n                    type=type2;\n                    pos+=2;\n                  }\n                }\n\n                queue.add(newTok(t,start,subWordEnd));\n                if ((firstType & ALPHA)!=0) numWords++;\n                break;\n              }\n            }\n\n            // For case changes, only split on a transition from\n            // lower to upper case, not vice-versa.\n            // That will correctly handle the\n            // case of a word starting with a capital (won't split).\n            // It will also handle pluralization of\n            // an uppercase word such as FOOs (won't split).\n\n            if (splitOnCaseChange == 0 && \n                (lastType & ALPHA) != 0 && (type & ALPHA) != 0) {\n              // ALPHA->ALPHA: always ignore if case isn't considered.\n\n            } else if ((lastType & UPPER)!=0 && (type & LOWER)!=0) {\n              // UPPER->LOWER: Don't split\n            } else {\n              // NOTE: this code currently assumes that only one flag\n              // is set for each character now, so we don't have\n              // to explicitly check for all the classes of transitions\n              // listed below.\n\n              // LOWER->UPPER\n              // ALPHA->NUMERIC\n              // NUMERIC->ALPHA\n              // *->DELIMITER\n              queue.add(newTok(t,start,pos));\n              if ((firstType & ALPHA)!=0) numWords++;\n              break;\n            }\n          }\n\n          if (++pos >= len) {\n            if (start==0) {\n              // the subword is the whole original token, so\n              // return it unchanged.\n              return t;\n            }\n\n            // optimization... if this is the only token,\n            // return it immediately.\n            if (queue.size()==0 && preserveOriginal == 0) {\n              // just adjust the text w/o changing the rest\n              // of the original token\n              t.setTermBuffer(termBuffer, start, len-start);\n              return t;\n            }\n\n            Token newtok = newTok(t,start,pos);\n\n            queue.add(newtok);\n            if ((firstType & ALPHA)!=0) numWords++;\n            break;\n          }\n\n          lastType = type;\n          ch = termBuffer[pos];\n          type = charType(ch);\n        }\n\n        // start of the next subword is the current position\n        start=pos;\n      }\n\n      // System.out.println(\"##########TOKEN=\" + s + \" ######### WORD DELIMITER QUEUE=\" + str(queue));\n\n      final int numtok = queue.size();\n\n      // We reached the end of the current token.\n      // If the queue is empty, we should continue by reading\n      // the next token\n      if (numtok==0) {\n        // the token might have been all delimiters, in which\n        // case return it if we're meant to preserve it\n        if (preserveOriginal != 0) {\n          return t;\n        }\n        continue;\n      }\n\n      // if number of tokens is 1, there are no catenations to be done.\n      if (numtok==1) {\n        break;\n      }\n\n\n      final int numNumbers = numtok - numWords;\n\n      // check conditions under which the current token\n      // queue may be used as-is (no catenations needed)\n      if (catenateAll==0    // no \"everything\" to catenate\n        && (catenateWords==0 || numWords<=1)   // no words to catenate\n        && (catenateNumbers==0 || numNumbers<=1)    // no numbers to catenate\n        && (generateWordParts!=0 || numWords==0)  // word generation is on\n        && (generateNumberParts!=0 || numNumbers==0)) // number generation is on\n      {\n        break;\n      }\n\n\n      // swap queue and the temporary working list, then clear the\n      // queue in preparation for adding all combinations back to it.\n      ArrayList<Token> tmp=tlist;\n      tlist=queue;\n      queue=tmp;\n      queue.clear();\n\n      if (numWords==0) {\n        // all numbers\n        addCombos(tlist,0,numtok,generateNumberParts!=0,catenateNumbers!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      } else if (numNumbers==0) {\n        // all words\n        addCombos(tlist,0,numtok,generateWordParts!=0,catenateWords!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      } else if (generateNumberParts==0 && generateWordParts==0 && catenateNumbers==0 && catenateWords==0) {\n        // catenate all *only*\n        // OPT:could be optimized to add to current queue...\n        addCombos(tlist,0,numtok,false,catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      }\n\n      //\n      // Find all adjacent tokens of the same type.\n      //\n      Token tok = tlist.get(0);\n      boolean isWord = (tokType(tok) & ALPHA) != 0;\n      boolean wasWord=isWord;\n\n      for(int i=0; i<numtok;) {\n          int j;\n          for (j=i+1; j<numtok; j++) {\n            wasWord=isWord;\n            tok = tlist.get(j);\n            isWord = (tokType(tok) & ALPHA) != 0;\n            if (isWord != wasWord) break;\n          }\n          if (wasWord) {\n            addCombos(tlist,i,j,generateWordParts!=0,catenateWords!=0,1);\n          } else {\n            addCombos(tlist,i,j,generateNumberParts!=0,catenateNumbers!=0,1);\n          }\n          i=j;\n      }\n\n      // take care catenating all subwords\n      if (catenateAll!=0) {\n        addCombos(tlist,0,numtok,false,true,0);\n      }\n\n      // NOTE: in certain cases, queue may be empty (for instance, if catenate\n      // and generate are both set to false).  Only exit the loop if the queue\n      // is not empty.\n      if (queue.size() > 0 || preserveOriginal!=0) break;\n    }\n\n    // System.out.println(\"##########AFTER COMBINATIONS:\"+ str(queue));\n\n    if (preserveOriginal != 0) {\n      queuePos = 0;\n      if (queue.size() > 0) {\n        // overlap first token with the original\n        queue.get(0).setPositionIncrement(0);\n      }\n      return t;  // return the original\n    } else {\n      queuePos=1;\n      Token tok = queue.get(0);\n      tok.setPositionIncrement(origPosIncrement);\n      return tok;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3600cc523749f65697a76d2d0166cb0df07e458a","date":1229590227,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/analysis/WordDelimiterFilter#next(Token).mjava","pathOld":"src/java/org/apache/solr/analysis/WordDelimiterFilter#next(Token).mjava","sourceNew":"  public final Token next(Token in) throws IOException {\n\n    // check the queue first\n    if (queuePos<queue.size()) {\n      return queue.get(queuePos++);\n    }\n\n    // reset the queue if it had been previously used\n    if (queuePos!=0) {\n      queuePos=0;\n      queue.clear();\n    }\n\n\n    // optimize for the common case: assume there will be\n    // no subwords (just a simple word)\n    //\n    // Would it actually be faster to check for the common form\n    // of isLetter() isLower()*, and then backtrack if it doesn't match?\n\n    int origPosIncrement = 0;\n    Token t;\n    while(true) {\n      // t is either returned, or a new token is made from it, so it should\n      // be safe to use the next(Token) method.\n      t = input.next(in);\n      if (t == null) return null;\n\n      char [] termBuffer = t.termBuffer();\n      int len = t.termLength();\n      int start=0;\n      if (len ==0) continue;\n\n      //skip protected tokens\n      if (protWords != null && protWords.contains(termBuffer, 0, len)) {\n        return t;\n      }\n\n      origPosIncrement += t.getPositionIncrement();\n\n      // Avoid calling charType more than once for each char (basically\n      // avoid any backtracking).\n      // makes code slightly more difficult, but faster.\n      int ch=termBuffer[start];\n      int type=charType(ch);\n\n      int numWords=0;\n\n      while (start< len) {\n        // first eat delimiters at the start of this subword\n        while ((type & SUBWORD_DELIM)!=0 && ++start< len) {\n          ch=termBuffer[start];\n          type=charType(ch);\n        }\n\n        int pos=start;\n\n        // save the type of the first char of the subword\n        // as a way to tell what type of subword token this is (number, word, etc)\n        int firstType=type;\n        int lastType=type;  // type of the previously read char\n\n\n        while (pos< len) {\n\n          if (type!=lastType) {\n            // check and remove \"'s\" from the end of a token.\n            // the pattern to check for is\n            //   ALPHA \"'\" (\"s\"|\"S\") (SUBWORD_DELIM | END)\n            if ((lastType & ALPHA)!=0) {\n              if (ch=='\\'' && pos+1< len\n                      && (termBuffer[pos+1]=='s' || termBuffer[pos+1]=='S'))\n              {\n                int subWordEnd=pos;\n                if (pos+2>= len) {\n                  // end of string detected after \"'s\"\n                  pos+=2;\n                } else {\n                  // make sure that a delimiter follows \"'s\"\n                  int ch2 = termBuffer[pos+2];\n                  int type2 = charType(ch2);\n                  if ((type2 & SUBWORD_DELIM)!=0) {\n                    // if delimiter, move position pointer\n                    // to it (skipping over \"'s\"\n                    ch=ch2;\n                    type=type2;\n                    pos+=2;\n                  }\n                }\n\n                queue.add(newTok(t,start,subWordEnd));\n                if ((firstType & ALPHA)!=0) numWords++;\n                break;\n              }\n            }\n\n            // For case changes, only split on a transition from\n            // lower to upper case, not vice-versa.\n            // That will correctly handle the\n            // case of a word starting with a capital (won't split).\n            // It will also handle pluralization of\n            // an uppercase word such as FOOs (won't split).\n\n            if (splitOnCaseChange == 0 && \n                (lastType & ALPHA) != 0 && (type & ALPHA) != 0) {\n              // ALPHA->ALPHA: always ignore if case isn't considered.\n\n            } else if ((lastType & UPPER)!=0 && (type & LOWER)!=0) {\n              // UPPER->LOWER: Don't split\n            } else if(splitOnNumerics == 0 &&\n                ( ((lastType &  ALPHA) != 0 && (type & DIGIT) != 0) || ((lastType &  DIGIT) != 0 && (type & ALPHA) != 0) ) ) {\n              // ALPHA->NUMERIC, NUMERIC->ALPHA :Don't split\n            } else {\n              // NOTE: this code currently assumes that only one flag\n              // is set for each character now, so we don't have\n              // to explicitly check for all the classes of transitions\n              // listed below.\n\n              // LOWER->UPPER\n              // ALPHA->NUMERIC\n              // NUMERIC->ALPHA\n              // *->DELIMITER\n              queue.add(newTok(t,start,pos));\n              if ((firstType & ALPHA)!=0) numWords++;\n              break;\n            }\n          }\n\n          if (++pos >= len) {\n            if (start==0) {\n              // the subword is the whole original token, so\n              // return it unchanged.\n              return t;\n            }\n\n            // optimization... if this is the only token,\n            // return it immediately.\n            if (queue.size()==0 && preserveOriginal == 0) {\n              // just adjust the text w/o changing the rest\n              // of the original token\n              t.setTermBuffer(termBuffer, start, len-start);\n              t.setStartOffset(t.startOffset() + start);\n              return t;\n            }\n\n            Token newtok = newTok(t,start,pos);\n\n            queue.add(newtok);\n            if ((firstType & ALPHA)!=0) numWords++;\n            break;\n          }\n\n          lastType = type;\n          ch = termBuffer[pos];\n          type = charType(ch);\n        }\n\n        // start of the next subword is the current position\n        start=pos;\n      }\n\n      // System.out.println(\"##########TOKEN=\" + s + \" ######### WORD DELIMITER QUEUE=\" + str(queue));\n\n      final int numtok = queue.size();\n\n      // We reached the end of the current token.\n      // If the queue is empty, we should continue by reading\n      // the next token\n      if (numtok==0) {\n        // the token might have been all delimiters, in which\n        // case return it if we're meant to preserve it\n        if (preserveOriginal != 0) {\n          return t;\n        }\n        continue;\n      }\n\n      // if number of tokens is 1, there are no catenations to be done.\n      if (numtok==1) {\n        break;\n      }\n\n\n      final int numNumbers = numtok - numWords;\n\n      // check conditions under which the current token\n      // queue may be used as-is (no catenations needed)\n      if (catenateAll==0    // no \"everything\" to catenate\n        && (catenateWords==0 || numWords<=1)   // no words to catenate\n        && (catenateNumbers==0 || numNumbers<=1)    // no numbers to catenate\n        && (generateWordParts!=0 || numWords==0)  // word generation is on\n        && (generateNumberParts!=0 || numNumbers==0)) // number generation is on\n      {\n        break;\n      }\n\n\n      // swap queue and the temporary working list, then clear the\n      // queue in preparation for adding all combinations back to it.\n      ArrayList<Token> tmp=tlist;\n      tlist=queue;\n      queue=tmp;\n      queue.clear();\n\n      if (numWords==0) {\n        // all numbers\n        addCombos(tlist,0,numtok,generateNumberParts!=0,catenateNumbers!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      } else if (numNumbers==0) {\n        // all words\n        addCombos(tlist,0,numtok,generateWordParts!=0,catenateWords!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      } else if (generateNumberParts==0 && generateWordParts==0 && catenateNumbers==0 && catenateWords==0) {\n        // catenate all *only*\n        // OPT:could be optimized to add to current queue...\n        addCombos(tlist,0,numtok,false,catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      }\n\n      //\n      // Find all adjacent tokens of the same type.\n      //\n      Token tok = tlist.get(0);\n      boolean isWord = (tokType(tok) & ALPHA) != 0;\n      boolean wasWord=isWord;\n\n      for(int i=0; i<numtok;) {\n          int j;\n          for (j=i+1; j<numtok; j++) {\n            wasWord=isWord;\n            tok = tlist.get(j);\n            isWord = (tokType(tok) & ALPHA) != 0;\n            if (isWord != wasWord) break;\n          }\n          if (wasWord) {\n            addCombos(tlist,i,j,generateWordParts!=0,catenateWords!=0,1);\n          } else {\n            addCombos(tlist,i,j,generateNumberParts!=0,catenateNumbers!=0,1);\n          }\n          i=j;\n      }\n\n      // take care catenating all subwords\n      if (catenateAll!=0) {\n        addCombos(tlist,0,numtok,false,true,0);\n      }\n\n      // NOTE: in certain cases, queue may be empty (for instance, if catenate\n      // and generate are both set to false).  Only exit the loop if the queue\n      // is not empty.\n      if (queue.size() > 0 || preserveOriginal!=0) break;\n    }\n\n    // System.out.println(\"##########AFTER COMBINATIONS:\"+ str(queue));\n\n    if (preserveOriginal != 0) {\n      queuePos = 0;\n      if (queue.size() > 0) {\n        // overlap first token with the original\n        queue.get(0).setPositionIncrement(0);\n      }\n      return t;  // return the original\n    } else {\n      queuePos=1;\n      Token tok = queue.get(0);\n      tok.setPositionIncrement(origPosIncrement);\n      return tok;\n    }\n  }\n\n","sourceOld":"  public final Token next(Token in) throws IOException {\n\n    // check the queue first\n    if (queuePos<queue.size()) {\n      return queue.get(queuePos++);\n    }\n\n    // reset the queue if it had been previously used\n    if (queuePos!=0) {\n      queuePos=0;\n      queue.clear();\n    }\n\n\n    // optimize for the common case: assume there will be\n    // no subwords (just a simple word)\n    //\n    // Would it actually be faster to check for the common form\n    // of isLetter() isLower()*, and then backtrack if it doesn't match?\n\n    int origPosIncrement = 0;\n    Token t;\n    while(true) {\n      // t is either returned, or a new token is made from it, so it should\n      // be safe to use the next(Token) method.\n      t = input.next(in);\n      if (t == null) return null;\n\n      char [] termBuffer = t.termBuffer();\n      int len = t.termLength();\n      int start=0;\n      if (len ==0) continue;\n\n      origPosIncrement += t.getPositionIncrement();\n\n      // Avoid calling charType more than once for each char (basically\n      // avoid any backtracking).\n      // makes code slightly more difficult, but faster.\n      int ch=termBuffer[start];\n      int type=charType(ch);\n\n      int numWords=0;\n\n      while (start< len) {\n        // first eat delimiters at the start of this subword\n        while ((type & SUBWORD_DELIM)!=0 && ++start< len) {\n          ch=termBuffer[start];\n          type=charType(ch);\n        }\n\n        int pos=start;\n\n        // save the type of the first char of the subword\n        // as a way to tell what type of subword token this is (number, word, etc)\n        int firstType=type;\n        int lastType=type;  // type of the previously read char\n\n\n        while (pos< len) {\n\n          if (type!=lastType) {\n            // check and remove \"'s\" from the end of a token.\n            // the pattern to check for is\n            //   ALPHA \"'\" (\"s\"|\"S\") (SUBWORD_DELIM | END)\n            if ((lastType & ALPHA)!=0) {\n              if (ch=='\\'' && pos+1< len\n                      && (termBuffer[pos+1]=='s' || termBuffer[pos+1]=='S'))\n              {\n                int subWordEnd=pos;\n                if (pos+2>= len) {\n                  // end of string detected after \"'s\"\n                  pos+=2;\n                } else {\n                  // make sure that a delimiter follows \"'s\"\n                  int ch2 = termBuffer[pos+2];\n                  int type2 = charType(ch2);\n                  if ((type2 & SUBWORD_DELIM)!=0) {\n                    // if delimiter, move position pointer\n                    // to it (skipping over \"'s\"\n                    ch=ch2;\n                    type=type2;\n                    pos+=2;\n                  }\n                }\n\n                queue.add(newTok(t,start,subWordEnd));\n                if ((firstType & ALPHA)!=0) numWords++;\n                break;\n              }\n            }\n\n            // For case changes, only split on a transition from\n            // lower to upper case, not vice-versa.\n            // That will correctly handle the\n            // case of a word starting with a capital (won't split).\n            // It will also handle pluralization of\n            // an uppercase word such as FOOs (won't split).\n\n            if (splitOnCaseChange == 0 && \n                (lastType & ALPHA) != 0 && (type & ALPHA) != 0) {\n              // ALPHA->ALPHA: always ignore if case isn't considered.\n\n            } else if ((lastType & UPPER)!=0 && (type & LOWER)!=0) {\n              // UPPER->LOWER: Don't split\n            } else {\n              // NOTE: this code currently assumes that only one flag\n              // is set for each character now, so we don't have\n              // to explicitly check for all the classes of transitions\n              // listed below.\n\n              // LOWER->UPPER\n              // ALPHA->NUMERIC\n              // NUMERIC->ALPHA\n              // *->DELIMITER\n              queue.add(newTok(t,start,pos));\n              if ((firstType & ALPHA)!=0) numWords++;\n              break;\n            }\n          }\n\n          if (++pos >= len) {\n            if (start==0) {\n              // the subword is the whole original token, so\n              // return it unchanged.\n              return t;\n            }\n\n            // optimization... if this is the only token,\n            // return it immediately.\n            if (queue.size()==0 && preserveOriginal == 0) {\n              // just adjust the text w/o changing the rest\n              // of the original token\n              t.setTermBuffer(termBuffer, start, len-start);\n              t.setStartOffset(t.startOffset() + start);\n              return t;\n            }\n\n            Token newtok = newTok(t,start,pos);\n\n            queue.add(newtok);\n            if ((firstType & ALPHA)!=0) numWords++;\n            break;\n          }\n\n          lastType = type;\n          ch = termBuffer[pos];\n          type = charType(ch);\n        }\n\n        // start of the next subword is the current position\n        start=pos;\n      }\n\n      // System.out.println(\"##########TOKEN=\" + s + \" ######### WORD DELIMITER QUEUE=\" + str(queue));\n\n      final int numtok = queue.size();\n\n      // We reached the end of the current token.\n      // If the queue is empty, we should continue by reading\n      // the next token\n      if (numtok==0) {\n        // the token might have been all delimiters, in which\n        // case return it if we're meant to preserve it\n        if (preserveOriginal != 0) {\n          return t;\n        }\n        continue;\n      }\n\n      // if number of tokens is 1, there are no catenations to be done.\n      if (numtok==1) {\n        break;\n      }\n\n\n      final int numNumbers = numtok - numWords;\n\n      // check conditions under which the current token\n      // queue may be used as-is (no catenations needed)\n      if (catenateAll==0    // no \"everything\" to catenate\n        && (catenateWords==0 || numWords<=1)   // no words to catenate\n        && (catenateNumbers==0 || numNumbers<=1)    // no numbers to catenate\n        && (generateWordParts!=0 || numWords==0)  // word generation is on\n        && (generateNumberParts!=0 || numNumbers==0)) // number generation is on\n      {\n        break;\n      }\n\n\n      // swap queue and the temporary working list, then clear the\n      // queue in preparation for adding all combinations back to it.\n      ArrayList<Token> tmp=tlist;\n      tlist=queue;\n      queue=tmp;\n      queue.clear();\n\n      if (numWords==0) {\n        // all numbers\n        addCombos(tlist,0,numtok,generateNumberParts!=0,catenateNumbers!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      } else if (numNumbers==0) {\n        // all words\n        addCombos(tlist,0,numtok,generateWordParts!=0,catenateWords!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      } else if (generateNumberParts==0 && generateWordParts==0 && catenateNumbers==0 && catenateWords==0) {\n        // catenate all *only*\n        // OPT:could be optimized to add to current queue...\n        addCombos(tlist,0,numtok,false,catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      }\n\n      //\n      // Find all adjacent tokens of the same type.\n      //\n      Token tok = tlist.get(0);\n      boolean isWord = (tokType(tok) & ALPHA) != 0;\n      boolean wasWord=isWord;\n\n      for(int i=0; i<numtok;) {\n          int j;\n          for (j=i+1; j<numtok; j++) {\n            wasWord=isWord;\n            tok = tlist.get(j);\n            isWord = (tokType(tok) & ALPHA) != 0;\n            if (isWord != wasWord) break;\n          }\n          if (wasWord) {\n            addCombos(tlist,i,j,generateWordParts!=0,catenateWords!=0,1);\n          } else {\n            addCombos(tlist,i,j,generateNumberParts!=0,catenateNumbers!=0,1);\n          }\n          i=j;\n      }\n\n      // take care catenating all subwords\n      if (catenateAll!=0) {\n        addCombos(tlist,0,numtok,false,true,0);\n      }\n\n      // NOTE: in certain cases, queue may be empty (for instance, if catenate\n      // and generate are both set to false).  Only exit the loop if the queue\n      // is not empty.\n      if (queue.size() > 0 || preserveOriginal!=0) break;\n    }\n\n    // System.out.println(\"##########AFTER COMBINATIONS:\"+ str(queue));\n\n    if (preserveOriginal != 0) {\n      queuePos = 0;\n      if (queue.size() > 0) {\n        // overlap first token with the original\n        queue.get(0).setPositionIncrement(0);\n      }\n      return t;  // return the original\n    } else {\n      queuePos=1;\n      Token tok = queue.get(0);\n      tok.setPositionIncrement(origPosIncrement);\n      return tok;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c1ed809566041553006ceafee9618c9c07f2ed15","date":1241814307,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/analysis/WordDelimiterFilter#next(Token).mjava","pathOld":"src/java/org/apache/solr/analysis/WordDelimiterFilter#next(Token).mjava","sourceNew":"  public final Token next(Token in) throws IOException {\n\n    // check the queue first\n    if (queuePos<queue.size()) {\n      return queue.get(queuePos++);\n    }\n\n    // reset the queue if it had been previously used\n    if (queuePos!=0) {\n      queuePos=0;\n      queue.clear();\n    }\n\n\n    // optimize for the common case: assume there will be\n    // no subwords (just a simple word)\n    //\n    // Would it actually be faster to check for the common form\n    // of isLetter() isLower()*, and then backtrack if it doesn't match?\n\n    int origPosIncrement = 0;\n    Token t;\n    while(true) {\n      // t is either returned, or a new token is made from it, so it should\n      // be safe to use the next(Token) method.\n      t = input.next(in);\n      if (t == null) return null;\n\n      char [] termBuffer = t.termBuffer();\n      int len = t.termLength();\n      int start=0;\n      if (len ==0) continue;\n\n      //skip protected tokens\n      if (protWords != null && protWords.contains(termBuffer, 0, len)) {\n        return t;\n      }\n\n      origPosIncrement += t.getPositionIncrement();\n\n      // Avoid calling charType more than once for each char (basically\n      // avoid any backtracking).\n      // makes code slightly more difficult, but faster.\n      int ch=termBuffer[start];\n      int type=charType(ch);\n\n      int numWords=0;\n\n      while (start< len) {\n        // first eat delimiters at the start of this subword\n        while ((type & SUBWORD_DELIM)!=0 && ++start< len) {\n          ch=termBuffer[start];\n          type=charType(ch);\n        }\n\n        int pos=start;\n\n        // save the type of the first char of the subword\n        // as a way to tell what type of subword token this is (number, word, etc)\n        int firstType=type;\n        int lastType=type;  // type of the previously read char\n\n\n        while (pos< len) {\n\n          if ((type & lastType)==0) {  // no overlap in character type\n            // check and remove \"'s\" from the end of a token.\n            // the pattern to check for is\n            //   ALPHA \"'\" (\"s\"|\"S\") (SUBWORD_DELIM | END)\n            if ((lastType & ALPHA)!=0) {\n              if (ch=='\\'' && pos+1< len\n                      && (termBuffer[pos+1]=='s' || termBuffer[pos+1]=='S'))\n              {\n                int subWordEnd=pos;\n                if (pos+2>= len) {\n                  // end of string detected after \"'s\"\n                  pos+=2;\n                } else {\n                  // make sure that a delimiter follows \"'s\"\n                  int ch2 = termBuffer[pos+2];\n                  int type2 = charType(ch2);\n                  if ((type2 & SUBWORD_DELIM)!=0) {\n                    // if delimiter, move position pointer\n                    // to it (skipping over \"'s\"\n                    ch=ch2;\n                    type=type2;\n                    pos+=2;\n                  }\n                }\n\n                queue.add(newTok(t,start,subWordEnd));\n                if ((firstType & ALPHA)!=0) numWords++;\n                break;\n              }\n            }\n\n            // For case changes, only split on a transition from\n            // lower to upper case, not vice-versa.\n            // That will correctly handle the\n            // case of a word starting with a capital (won't split).\n            // It will also handle pluralization of\n            // an uppercase word such as FOOs (won't split).\n\n            if (splitOnCaseChange == 0 && \n                (lastType & ALPHA) != 0 && (type & ALPHA) != 0) {\n              // ALPHA->ALPHA: always ignore if case isn't considered.\n            } else if ((lastType & UPPER)!=0 && (type & ALPHA)!=0) {\n              // UPPER->letter: Don't split\n            } else if(splitOnNumerics == 0 &&\n                ( ((lastType &  ALPHA) != 0 && (type & DIGIT) != 0) || ((lastType &  DIGIT) != 0 && (type & ALPHA) != 0) ) ) {\n              // ALPHA->NUMERIC, NUMERIC->ALPHA :Don't split\n            } else {\n              // NOTE: this code currently assumes that only one flag\n              // is set for each character now, so we don't have\n              // to explicitly check for all the classes of transitions\n              // listed below.\n\n              // LOWER->UPPER\n              // ALPHA->NUMERIC\n              // NUMERIC->ALPHA\n              // *->DELIMITER\n              queue.add(newTok(t,start,pos));\n              if ((firstType & ALPHA)!=0) numWords++;\n              break;\n            }\n          }\n\n          if (++pos >= len) {\n            if (start==0) {\n              // the subword is the whole original token, so\n              // return it unchanged.\n              return t;\n            }\n\n            // optimization... if this is the only token,\n            // return it immediately.\n            if (queue.size()==0 && preserveOriginal == 0) {\n              // just adjust the text w/o changing the rest\n              // of the original token\n              t.setTermBuffer(termBuffer, start, len-start);\n              t.setStartOffset(t.startOffset() + start);\n              return t;\n            }\n\n            Token newtok = newTok(t,start,pos);\n\n            queue.add(newtok);\n            if ((firstType & ALPHA)!=0) numWords++;\n            break;\n          }\n\n          lastType = type;\n          ch = termBuffer[pos];\n          type = charType(ch);\n        }\n\n        // start of the next subword is the current position\n        start=pos;\n      }\n\n      // System.out.println(\"##########TOKEN=\" + s + \" ######### WORD DELIMITER QUEUE=\" + str(queue));\n\n      final int numtok = queue.size();\n\n      // We reached the end of the current token.\n      // If the queue is empty, we should continue by reading\n      // the next token\n      if (numtok==0) {\n        // the token might have been all delimiters, in which\n        // case return it if we're meant to preserve it\n        if (preserveOriginal != 0) {\n          return t;\n        }\n        continue;\n      }\n\n      // if number of tokens is 1, there are no catenations to be done.\n      if (numtok==1) {\n        break;\n      }\n\n\n      final int numNumbers = numtok - numWords;\n\n      // check conditions under which the current token\n      // queue may be used as-is (no catenations needed)\n      if (catenateAll==0    // no \"everything\" to catenate\n        && (catenateWords==0 || numWords<=1)   // no words to catenate\n        && (catenateNumbers==0 || numNumbers<=1)    // no numbers to catenate\n        && (generateWordParts!=0 || numWords==0)  // word generation is on\n        && (generateNumberParts!=0 || numNumbers==0)) // number generation is on\n      {\n        break;\n      }\n\n\n      // swap queue and the temporary working list, then clear the\n      // queue in preparation for adding all combinations back to it.\n      ArrayList<Token> tmp=tlist;\n      tlist=queue;\n      queue=tmp;\n      queue.clear();\n\n      if (numWords==0) {\n        // all numbers\n        addCombos(tlist,0,numtok,generateNumberParts!=0,catenateNumbers!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      } else if (numNumbers==0) {\n        // all words\n        addCombos(tlist,0,numtok,generateWordParts!=0,catenateWords!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      } else if (generateNumberParts==0 && generateWordParts==0 && catenateNumbers==0 && catenateWords==0) {\n        // catenate all *only*\n        // OPT:could be optimized to add to current queue...\n        addCombos(tlist,0,numtok,false,catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      }\n\n      //\n      // Find all adjacent tokens of the same type.\n      //\n      Token tok = tlist.get(0);\n      boolean isWord = (tokType(tok) & ALPHA) != 0;\n      boolean wasWord=isWord;\n\n      for(int i=0; i<numtok;) {\n          int j;\n          for (j=i+1; j<numtok; j++) {\n            wasWord=isWord;\n            tok = tlist.get(j);\n            isWord = (tokType(tok) & ALPHA) != 0;\n            if (isWord != wasWord) break;\n          }\n          if (wasWord) {\n            addCombos(tlist,i,j,generateWordParts!=0,catenateWords!=0,1);\n          } else {\n            addCombos(tlist,i,j,generateNumberParts!=0,catenateNumbers!=0,1);\n          }\n          i=j;\n      }\n\n      // take care catenating all subwords\n      if (catenateAll!=0) {\n        addCombos(tlist,0,numtok,false,true,0);\n      }\n\n      // NOTE: in certain cases, queue may be empty (for instance, if catenate\n      // and generate are both set to false).  Only exit the loop if the queue\n      // is not empty.\n      if (queue.size() > 0 || preserveOriginal!=0) break;\n    }\n\n    // System.out.println(\"##########AFTER COMBINATIONS:\"+ str(queue));\n\n    if (preserveOriginal != 0) {\n      queuePos = 0;\n      if (queue.size() > 0) {\n        // overlap first token with the original\n        queue.get(0).setPositionIncrement(0);\n      }\n      return t;  // return the original\n    } else {\n      queuePos=1;\n      Token tok = queue.get(0);\n      tok.setPositionIncrement(origPosIncrement);\n      return tok;\n    }\n  }\n\n","sourceOld":"  public final Token next(Token in) throws IOException {\n\n    // check the queue first\n    if (queuePos<queue.size()) {\n      return queue.get(queuePos++);\n    }\n\n    // reset the queue if it had been previously used\n    if (queuePos!=0) {\n      queuePos=0;\n      queue.clear();\n    }\n\n\n    // optimize for the common case: assume there will be\n    // no subwords (just a simple word)\n    //\n    // Would it actually be faster to check for the common form\n    // of isLetter() isLower()*, and then backtrack if it doesn't match?\n\n    int origPosIncrement = 0;\n    Token t;\n    while(true) {\n      // t is either returned, or a new token is made from it, so it should\n      // be safe to use the next(Token) method.\n      t = input.next(in);\n      if (t == null) return null;\n\n      char [] termBuffer = t.termBuffer();\n      int len = t.termLength();\n      int start=0;\n      if (len ==0) continue;\n\n      //skip protected tokens\n      if (protWords != null && protWords.contains(termBuffer, 0, len)) {\n        return t;\n      }\n\n      origPosIncrement += t.getPositionIncrement();\n\n      // Avoid calling charType more than once for each char (basically\n      // avoid any backtracking).\n      // makes code slightly more difficult, but faster.\n      int ch=termBuffer[start];\n      int type=charType(ch);\n\n      int numWords=0;\n\n      while (start< len) {\n        // first eat delimiters at the start of this subword\n        while ((type & SUBWORD_DELIM)!=0 && ++start< len) {\n          ch=termBuffer[start];\n          type=charType(ch);\n        }\n\n        int pos=start;\n\n        // save the type of the first char of the subword\n        // as a way to tell what type of subword token this is (number, word, etc)\n        int firstType=type;\n        int lastType=type;  // type of the previously read char\n\n\n        while (pos< len) {\n\n          if (type!=lastType) {\n            // check and remove \"'s\" from the end of a token.\n            // the pattern to check for is\n            //   ALPHA \"'\" (\"s\"|\"S\") (SUBWORD_DELIM | END)\n            if ((lastType & ALPHA)!=0) {\n              if (ch=='\\'' && pos+1< len\n                      && (termBuffer[pos+1]=='s' || termBuffer[pos+1]=='S'))\n              {\n                int subWordEnd=pos;\n                if (pos+2>= len) {\n                  // end of string detected after \"'s\"\n                  pos+=2;\n                } else {\n                  // make sure that a delimiter follows \"'s\"\n                  int ch2 = termBuffer[pos+2];\n                  int type2 = charType(ch2);\n                  if ((type2 & SUBWORD_DELIM)!=0) {\n                    // if delimiter, move position pointer\n                    // to it (skipping over \"'s\"\n                    ch=ch2;\n                    type=type2;\n                    pos+=2;\n                  }\n                }\n\n                queue.add(newTok(t,start,subWordEnd));\n                if ((firstType & ALPHA)!=0) numWords++;\n                break;\n              }\n            }\n\n            // For case changes, only split on a transition from\n            // lower to upper case, not vice-versa.\n            // That will correctly handle the\n            // case of a word starting with a capital (won't split).\n            // It will also handle pluralization of\n            // an uppercase word such as FOOs (won't split).\n\n            if (splitOnCaseChange == 0 && \n                (lastType & ALPHA) != 0 && (type & ALPHA) != 0) {\n              // ALPHA->ALPHA: always ignore if case isn't considered.\n\n            } else if ((lastType & UPPER)!=0 && (type & LOWER)!=0) {\n              // UPPER->LOWER: Don't split\n            } else if(splitOnNumerics == 0 &&\n                ( ((lastType &  ALPHA) != 0 && (type & DIGIT) != 0) || ((lastType &  DIGIT) != 0 && (type & ALPHA) != 0) ) ) {\n              // ALPHA->NUMERIC, NUMERIC->ALPHA :Don't split\n            } else {\n              // NOTE: this code currently assumes that only one flag\n              // is set for each character now, so we don't have\n              // to explicitly check for all the classes of transitions\n              // listed below.\n\n              // LOWER->UPPER\n              // ALPHA->NUMERIC\n              // NUMERIC->ALPHA\n              // *->DELIMITER\n              queue.add(newTok(t,start,pos));\n              if ((firstType & ALPHA)!=0) numWords++;\n              break;\n            }\n          }\n\n          if (++pos >= len) {\n            if (start==0) {\n              // the subword is the whole original token, so\n              // return it unchanged.\n              return t;\n            }\n\n            // optimization... if this is the only token,\n            // return it immediately.\n            if (queue.size()==0 && preserveOriginal == 0) {\n              // just adjust the text w/o changing the rest\n              // of the original token\n              t.setTermBuffer(termBuffer, start, len-start);\n              t.setStartOffset(t.startOffset() + start);\n              return t;\n            }\n\n            Token newtok = newTok(t,start,pos);\n\n            queue.add(newtok);\n            if ((firstType & ALPHA)!=0) numWords++;\n            break;\n          }\n\n          lastType = type;\n          ch = termBuffer[pos];\n          type = charType(ch);\n        }\n\n        // start of the next subword is the current position\n        start=pos;\n      }\n\n      // System.out.println(\"##########TOKEN=\" + s + \" ######### WORD DELIMITER QUEUE=\" + str(queue));\n\n      final int numtok = queue.size();\n\n      // We reached the end of the current token.\n      // If the queue is empty, we should continue by reading\n      // the next token\n      if (numtok==0) {\n        // the token might have been all delimiters, in which\n        // case return it if we're meant to preserve it\n        if (preserveOriginal != 0) {\n          return t;\n        }\n        continue;\n      }\n\n      // if number of tokens is 1, there are no catenations to be done.\n      if (numtok==1) {\n        break;\n      }\n\n\n      final int numNumbers = numtok - numWords;\n\n      // check conditions under which the current token\n      // queue may be used as-is (no catenations needed)\n      if (catenateAll==0    // no \"everything\" to catenate\n        && (catenateWords==0 || numWords<=1)   // no words to catenate\n        && (catenateNumbers==0 || numNumbers<=1)    // no numbers to catenate\n        && (generateWordParts!=0 || numWords==0)  // word generation is on\n        && (generateNumberParts!=0 || numNumbers==0)) // number generation is on\n      {\n        break;\n      }\n\n\n      // swap queue and the temporary working list, then clear the\n      // queue in preparation for adding all combinations back to it.\n      ArrayList<Token> tmp=tlist;\n      tlist=queue;\n      queue=tmp;\n      queue.clear();\n\n      if (numWords==0) {\n        // all numbers\n        addCombos(tlist,0,numtok,generateNumberParts!=0,catenateNumbers!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      } else if (numNumbers==0) {\n        // all words\n        addCombos(tlist,0,numtok,generateWordParts!=0,catenateWords!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      } else if (generateNumberParts==0 && generateWordParts==0 && catenateNumbers==0 && catenateWords==0) {\n        // catenate all *only*\n        // OPT:could be optimized to add to current queue...\n        addCombos(tlist,0,numtok,false,catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      }\n\n      //\n      // Find all adjacent tokens of the same type.\n      //\n      Token tok = tlist.get(0);\n      boolean isWord = (tokType(tok) & ALPHA) != 0;\n      boolean wasWord=isWord;\n\n      for(int i=0; i<numtok;) {\n          int j;\n          for (j=i+1; j<numtok; j++) {\n            wasWord=isWord;\n            tok = tlist.get(j);\n            isWord = (tokType(tok) & ALPHA) != 0;\n            if (isWord != wasWord) break;\n          }\n          if (wasWord) {\n            addCombos(tlist,i,j,generateWordParts!=0,catenateWords!=0,1);\n          } else {\n            addCombos(tlist,i,j,generateNumberParts!=0,catenateNumbers!=0,1);\n          }\n          i=j;\n      }\n\n      // take care catenating all subwords\n      if (catenateAll!=0) {\n        addCombos(tlist,0,numtok,false,true,0);\n      }\n\n      // NOTE: in certain cases, queue may be empty (for instance, if catenate\n      // and generate are both set to false).  Only exit the loop if the queue\n      // is not empty.\n      if (queue.size() > 0 || preserveOriginal!=0) break;\n    }\n\n    // System.out.println(\"##########AFTER COMBINATIONS:\"+ str(queue));\n\n    if (preserveOriginal != 0) {\n      queuePos = 0;\n      if (queue.size() > 0) {\n        // overlap first token with the original\n        queue.get(0).setPositionIncrement(0);\n      }\n      return t;  // return the original\n    } else {\n      queuePos=1;\n      Token tok = queue.get(0);\n      tok.setPositionIncrement(origPosIncrement);\n      return tok;\n    }\n  }\n\n","bugFix":["32765564f95f9c4beea3e121f7f8831ce1a89539","0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"660378637a9b6a034e3c28b6ee5bca287f414435","date":1247254833,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/analysis/WordDelimiterFilter#next(Token).mjava","pathOld":"src/java/org/apache/solr/analysis/WordDelimiterFilter#next(Token).mjava","sourceNew":"  public final Token next(Token in) throws IOException {\n\n    // check the queue first\n    if (queuePos<queue.size()) {\n      return queue.get(queuePos++);\n    }\n\n    // reset the queue if it had been previously used\n    if (queuePos!=0) {\n      queuePos=0;\n      queue.clear();\n    }\n\n\n    // optimize for the common case: assume there will be\n    // no subwords (just a simple word)\n    //\n    // Would it actually be faster to check for the common form\n    // of isLetter() isLower()*, and then backtrack if it doesn't match?\n\n    int origPosIncrement = 0;\n    Token t;\n    while(true) {\n      // t is either returned, or a new token is made from it, so it should\n      // be safe to use the next(Token) method.\n      t = input.next(in);\n      if (t == null) return null;\n\n      char [] termBuffer = t.termBuffer();\n      int len = t.termLength();\n      int start=0;\n      if (len ==0) continue;\n\n      //skip protected tokens\n      if (protWords != null && protWords.contains(termBuffer, 0, len)) {\n        return t;\n      }\n\n      origPosIncrement += t.getPositionIncrement();\n\n      // Avoid calling charType more than once for each char (basically\n      // avoid any backtracking).\n      // makes code slightly more difficult, but faster.\n      int ch=termBuffer[start];\n      int type=charType(ch);\n\n      int numWords=0;\n\n      while (start< len) {\n        // first eat delimiters at the start of this subword\n        while ((type & SUBWORD_DELIM)!=0 && ++start< len) {\n          ch=termBuffer[start];\n          type=charType(ch);\n        }\n\n        int pos=start;\n\n        // save the type of the first char of the subword\n        // as a way to tell what type of subword token this is (number, word, etc)\n        int firstType=type;\n        int lastType=type;  // type of the previously read char\n\n\n        while (pos< len) {\n\n          if ((type & lastType)==0) {  // no overlap in character type\n            // check and remove \"'s\" from the end of a token.\n            // the pattern to check for is\n            //   ALPHA \"'\" (\"s\"|\"S\") (SUBWORD_DELIM | END)\n            if (stemEnglishPossessive != 0 && ((lastType & ALPHA)!=0)) {\n              if (ch=='\\'' && pos+1< len\n                      && (termBuffer[pos+1]=='s' || termBuffer[pos+1]=='S'))\n              {\n                int subWordEnd=pos;\n                if (pos+2>= len) {\n                  // end of string detected after \"'s\"\n                  pos+=2;\n                } else {\n                  // make sure that a delimiter follows \"'s\"\n                  int ch2 = termBuffer[pos+2];\n                  int type2 = charType(ch2);\n                  if ((type2 & SUBWORD_DELIM)!=0) {\n                    // if delimiter, move position pointer\n                    // to it (skipping over \"'s\"\n                    ch=ch2;\n                    type=type2;\n                    pos+=2;\n                  }\n                }\n\n                queue.add(newTok(t,start,subWordEnd));\n                if ((firstType & ALPHA)!=0) numWords++;\n                break;\n              }\n            }\n\n            // For case changes, only split on a transition from\n            // lower to upper case, not vice-versa.\n            // That will correctly handle the\n            // case of a word starting with a capital (won't split).\n            // It will also handle pluralization of\n            // an uppercase word such as FOOs (won't split).\n\n            if (splitOnCaseChange == 0 && \n                (lastType & ALPHA) != 0 && (type & ALPHA) != 0) {\n              // ALPHA->ALPHA: always ignore if case isn't considered.\n            } else if ((lastType & UPPER)!=0 && (type & ALPHA)!=0) {\n              // UPPER->letter: Don't split\n            } else if(splitOnNumerics == 0 &&\n                ( ((lastType &  ALPHA) != 0 && (type & DIGIT) != 0) || ((lastType &  DIGIT) != 0 && (type & ALPHA) != 0) ) ) {\n              // ALPHA->NUMERIC, NUMERIC->ALPHA :Don't split\n            } else {\n              // NOTE: this code currently assumes that only one flag\n              // is set for each character now, so we don't have\n              // to explicitly check for all the classes of transitions\n              // listed below.\n\n              // LOWER->UPPER\n              // ALPHA->NUMERIC\n              // NUMERIC->ALPHA\n              // *->DELIMITER\n              queue.add(newTok(t,start,pos));\n              if ((firstType & ALPHA)!=0) numWords++;\n              break;\n            }\n          }\n\n          if (++pos >= len) {\n            if (start==0) {\n              // the subword is the whole original token, so\n              // return it unchanged.\n              return t;\n            }\n\n            // optimization... if this is the only token,\n            // return it immediately.\n            if (queue.size()==0 && preserveOriginal == 0) {\n              // just adjust the text w/o changing the rest\n              // of the original token\n              t.setTermBuffer(termBuffer, start, len-start);\n              t.setStartOffset(t.startOffset() + start);\n              return t;\n            }\n\n            Token newtok = newTok(t,start,pos);\n\n            queue.add(newtok);\n            if ((firstType & ALPHA)!=0) numWords++;\n            break;\n          }\n\n          lastType = type;\n          ch = termBuffer[pos];\n          type = charType(ch);\n        }\n\n        // start of the next subword is the current position\n        start=pos;\n      }\n\n      // System.out.println(\"##########TOKEN=\" + s + \" ######### WORD DELIMITER QUEUE=\" + str(queue));\n\n      final int numtok = queue.size();\n\n      // We reached the end of the current token.\n      // If the queue is empty, we should continue by reading\n      // the next token\n      if (numtok==0) {\n        // the token might have been all delimiters, in which\n        // case return it if we're meant to preserve it\n        if (preserveOriginal != 0) {\n          return t;\n        }\n        continue;\n      }\n\n      // if number of tokens is 1, there are no catenations to be done.\n      if (numtok==1) {\n        break;\n      }\n\n\n      final int numNumbers = numtok - numWords;\n\n      // check conditions under which the current token\n      // queue may be used as-is (no catenations needed)\n      if (catenateAll==0    // no \"everything\" to catenate\n        && (catenateWords==0 || numWords<=1)   // no words to catenate\n        && (catenateNumbers==0 || numNumbers<=1)    // no numbers to catenate\n        && (generateWordParts!=0 || numWords==0)  // word generation is on\n        && (generateNumberParts!=0 || numNumbers==0)) // number generation is on\n      {\n        break;\n      }\n\n\n      // swap queue and the temporary working list, then clear the\n      // queue in preparation for adding all combinations back to it.\n      ArrayList<Token> tmp=tlist;\n      tlist=queue;\n      queue=tmp;\n      queue.clear();\n\n      if (numWords==0) {\n        // all numbers\n        addCombos(tlist,0,numtok,generateNumberParts!=0,catenateNumbers!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      } else if (numNumbers==0) {\n        // all words\n        addCombos(tlist,0,numtok,generateWordParts!=0,catenateWords!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      } else if (generateNumberParts==0 && generateWordParts==0 && catenateNumbers==0 && catenateWords==0) {\n        // catenate all *only*\n        // OPT:could be optimized to add to current queue...\n        addCombos(tlist,0,numtok,false,catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      }\n\n      //\n      // Find all adjacent tokens of the same type.\n      //\n      Token tok = tlist.get(0);\n      boolean isWord = (tokType(tok) & ALPHA) != 0;\n      boolean wasWord=isWord;\n\n      for(int i=0; i<numtok;) {\n          int j;\n          for (j=i+1; j<numtok; j++) {\n            wasWord=isWord;\n            tok = tlist.get(j);\n            isWord = (tokType(tok) & ALPHA) != 0;\n            if (isWord != wasWord) break;\n          }\n          if (wasWord) {\n            addCombos(tlist,i,j,generateWordParts!=0,catenateWords!=0,1);\n          } else {\n            addCombos(tlist,i,j,generateNumberParts!=0,catenateNumbers!=0,1);\n          }\n          i=j;\n      }\n\n      // take care catenating all subwords\n      if (catenateAll!=0) {\n        addCombos(tlist,0,numtok,false,true,0);\n      }\n\n      // NOTE: in certain cases, queue may be empty (for instance, if catenate\n      // and generate are both set to false).  Only exit the loop if the queue\n      // is not empty.\n      if (queue.size() > 0 || preserveOriginal!=0) break;\n    }\n\n    // System.out.println(\"##########AFTER COMBINATIONS:\"+ str(queue));\n\n    if (preserveOriginal != 0) {\n      queuePos = 0;\n      if (queue.size() > 0) {\n        // overlap first token with the original\n        queue.get(0).setPositionIncrement(0);\n      }\n      return t;  // return the original\n    } else {\n      queuePos=1;\n      Token tok = queue.get(0);\n      tok.setPositionIncrement(origPosIncrement);\n      return tok;\n    }\n  }\n\n","sourceOld":"  public final Token next(Token in) throws IOException {\n\n    // check the queue first\n    if (queuePos<queue.size()) {\n      return queue.get(queuePos++);\n    }\n\n    // reset the queue if it had been previously used\n    if (queuePos!=0) {\n      queuePos=0;\n      queue.clear();\n    }\n\n\n    // optimize for the common case: assume there will be\n    // no subwords (just a simple word)\n    //\n    // Would it actually be faster to check for the common form\n    // of isLetter() isLower()*, and then backtrack if it doesn't match?\n\n    int origPosIncrement = 0;\n    Token t;\n    while(true) {\n      // t is either returned, or a new token is made from it, so it should\n      // be safe to use the next(Token) method.\n      t = input.next(in);\n      if (t == null) return null;\n\n      char [] termBuffer = t.termBuffer();\n      int len = t.termLength();\n      int start=0;\n      if (len ==0) continue;\n\n      //skip protected tokens\n      if (protWords != null && protWords.contains(termBuffer, 0, len)) {\n        return t;\n      }\n\n      origPosIncrement += t.getPositionIncrement();\n\n      // Avoid calling charType more than once for each char (basically\n      // avoid any backtracking).\n      // makes code slightly more difficult, but faster.\n      int ch=termBuffer[start];\n      int type=charType(ch);\n\n      int numWords=0;\n\n      while (start< len) {\n        // first eat delimiters at the start of this subword\n        while ((type & SUBWORD_DELIM)!=0 && ++start< len) {\n          ch=termBuffer[start];\n          type=charType(ch);\n        }\n\n        int pos=start;\n\n        // save the type of the first char of the subword\n        // as a way to tell what type of subword token this is (number, word, etc)\n        int firstType=type;\n        int lastType=type;  // type of the previously read char\n\n\n        while (pos< len) {\n\n          if ((type & lastType)==0) {  // no overlap in character type\n            // check and remove \"'s\" from the end of a token.\n            // the pattern to check for is\n            //   ALPHA \"'\" (\"s\"|\"S\") (SUBWORD_DELIM | END)\n            if ((lastType & ALPHA)!=0) {\n              if (ch=='\\'' && pos+1< len\n                      && (termBuffer[pos+1]=='s' || termBuffer[pos+1]=='S'))\n              {\n                int subWordEnd=pos;\n                if (pos+2>= len) {\n                  // end of string detected after \"'s\"\n                  pos+=2;\n                } else {\n                  // make sure that a delimiter follows \"'s\"\n                  int ch2 = termBuffer[pos+2];\n                  int type2 = charType(ch2);\n                  if ((type2 & SUBWORD_DELIM)!=0) {\n                    // if delimiter, move position pointer\n                    // to it (skipping over \"'s\"\n                    ch=ch2;\n                    type=type2;\n                    pos+=2;\n                  }\n                }\n\n                queue.add(newTok(t,start,subWordEnd));\n                if ((firstType & ALPHA)!=0) numWords++;\n                break;\n              }\n            }\n\n            // For case changes, only split on a transition from\n            // lower to upper case, not vice-versa.\n            // That will correctly handle the\n            // case of a word starting with a capital (won't split).\n            // It will also handle pluralization of\n            // an uppercase word such as FOOs (won't split).\n\n            if (splitOnCaseChange == 0 && \n                (lastType & ALPHA) != 0 && (type & ALPHA) != 0) {\n              // ALPHA->ALPHA: always ignore if case isn't considered.\n            } else if ((lastType & UPPER)!=0 && (type & ALPHA)!=0) {\n              // UPPER->letter: Don't split\n            } else if(splitOnNumerics == 0 &&\n                ( ((lastType &  ALPHA) != 0 && (type & DIGIT) != 0) || ((lastType &  DIGIT) != 0 && (type & ALPHA) != 0) ) ) {\n              // ALPHA->NUMERIC, NUMERIC->ALPHA :Don't split\n            } else {\n              // NOTE: this code currently assumes that only one flag\n              // is set for each character now, so we don't have\n              // to explicitly check for all the classes of transitions\n              // listed below.\n\n              // LOWER->UPPER\n              // ALPHA->NUMERIC\n              // NUMERIC->ALPHA\n              // *->DELIMITER\n              queue.add(newTok(t,start,pos));\n              if ((firstType & ALPHA)!=0) numWords++;\n              break;\n            }\n          }\n\n          if (++pos >= len) {\n            if (start==0) {\n              // the subword is the whole original token, so\n              // return it unchanged.\n              return t;\n            }\n\n            // optimization... if this is the only token,\n            // return it immediately.\n            if (queue.size()==0 && preserveOriginal == 0) {\n              // just adjust the text w/o changing the rest\n              // of the original token\n              t.setTermBuffer(termBuffer, start, len-start);\n              t.setStartOffset(t.startOffset() + start);\n              return t;\n            }\n\n            Token newtok = newTok(t,start,pos);\n\n            queue.add(newtok);\n            if ((firstType & ALPHA)!=0) numWords++;\n            break;\n          }\n\n          lastType = type;\n          ch = termBuffer[pos];\n          type = charType(ch);\n        }\n\n        // start of the next subword is the current position\n        start=pos;\n      }\n\n      // System.out.println(\"##########TOKEN=\" + s + \" ######### WORD DELIMITER QUEUE=\" + str(queue));\n\n      final int numtok = queue.size();\n\n      // We reached the end of the current token.\n      // If the queue is empty, we should continue by reading\n      // the next token\n      if (numtok==0) {\n        // the token might have been all delimiters, in which\n        // case return it if we're meant to preserve it\n        if (preserveOriginal != 0) {\n          return t;\n        }\n        continue;\n      }\n\n      // if number of tokens is 1, there are no catenations to be done.\n      if (numtok==1) {\n        break;\n      }\n\n\n      final int numNumbers = numtok - numWords;\n\n      // check conditions under which the current token\n      // queue may be used as-is (no catenations needed)\n      if (catenateAll==0    // no \"everything\" to catenate\n        && (catenateWords==0 || numWords<=1)   // no words to catenate\n        && (catenateNumbers==0 || numNumbers<=1)    // no numbers to catenate\n        && (generateWordParts!=0 || numWords==0)  // word generation is on\n        && (generateNumberParts!=0 || numNumbers==0)) // number generation is on\n      {\n        break;\n      }\n\n\n      // swap queue and the temporary working list, then clear the\n      // queue in preparation for adding all combinations back to it.\n      ArrayList<Token> tmp=tlist;\n      tlist=queue;\n      queue=tmp;\n      queue.clear();\n\n      if (numWords==0) {\n        // all numbers\n        addCombos(tlist,0,numtok,generateNumberParts!=0,catenateNumbers!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      } else if (numNumbers==0) {\n        // all words\n        addCombos(tlist,0,numtok,generateWordParts!=0,catenateWords!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      } else if (generateNumberParts==0 && generateWordParts==0 && catenateNumbers==0 && catenateWords==0) {\n        // catenate all *only*\n        // OPT:could be optimized to add to current queue...\n        addCombos(tlist,0,numtok,false,catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      }\n\n      //\n      // Find all adjacent tokens of the same type.\n      //\n      Token tok = tlist.get(0);\n      boolean isWord = (tokType(tok) & ALPHA) != 0;\n      boolean wasWord=isWord;\n\n      for(int i=0; i<numtok;) {\n          int j;\n          for (j=i+1; j<numtok; j++) {\n            wasWord=isWord;\n            tok = tlist.get(j);\n            isWord = (tokType(tok) & ALPHA) != 0;\n            if (isWord != wasWord) break;\n          }\n          if (wasWord) {\n            addCombos(tlist,i,j,generateWordParts!=0,catenateWords!=0,1);\n          } else {\n            addCombos(tlist,i,j,generateNumberParts!=0,catenateNumbers!=0,1);\n          }\n          i=j;\n      }\n\n      // take care catenating all subwords\n      if (catenateAll!=0) {\n        addCombos(tlist,0,numtok,false,true,0);\n      }\n\n      // NOTE: in certain cases, queue may be empty (for instance, if catenate\n      // and generate are both set to false).  Only exit the loop if the queue\n      // is not empty.\n      if (queue.size() > 0 || preserveOriginal!=0) break;\n    }\n\n    // System.out.println(\"##########AFTER COMBINATIONS:\"+ str(queue));\n\n    if (preserveOriginal != 0) {\n      queuePos = 0;\n      if (queue.size() > 0) {\n        // overlap first token with the original\n        queue.get(0).setPositionIncrement(0);\n      }\n      return t;  // return the original\n    } else {\n      queuePos=1;\n      Token tok = queue.get(0);\n      tok.setPositionIncrement(origPosIncrement);\n      return tok;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1d786062be6da940351591ec2372ddd0ae56bd39","date":1251293566,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/analysis/WordDelimiterFilter#next(Token).mjava","pathOld":"src/java/org/apache/solr/analysis/WordDelimiterFilter#next(Token).mjava","sourceNew":"  public final Token next(Token in) throws IOException {\n\n    // check the queue first\n    if (queuePos<queue.size()) {\n      return queue.get(queuePos++);\n    }\n\n    // reset the queue if it had been previously used\n    if (queuePos!=0) {\n      queuePos=0;\n      queue.clear();\n    }\n\n\n    // optimize for the common case: assume there will be\n    // no subwords (just a simple word)\n    //\n    // Would it actually be faster to check for the common form\n    // of isLetter() isLower()*, and then backtrack if it doesn't match?\n\n    int origPosIncrement = 0;\n    Token t;\n    while(true) {\n      // t is either returned, or a new token is made from it, so it should\n      // be safe to use the next(Token) method.\n      t = input.next(in);\n      if (t == null) return null;\n\n      char [] termBuffer = t.termBuffer();\n      int len = t.termLength();\n      int start=0;\n      if (len ==0) continue;\n\n      int posInc = t.getPositionIncrement();\n      origPosIncrement += posInc;\n\n      //skip protected tokens\n      if (protWords != null && protWords.contains(termBuffer, 0, len)) {\n        t.setPositionIncrement(origPosIncrement);\n        return t;\n      }\n\n      // Avoid calling charType more than once for each char (basically\n      // avoid any backtracking).\n      // makes code slightly more difficult, but faster.\n      int ch=termBuffer[start];\n      int type=charType(ch);\n\n      int numWords=0;\n\n      while (start< len) {\n        // first eat delimiters at the start of this subword\n        while ((type & SUBWORD_DELIM)!=0 && ++start< len) {\n          ch=termBuffer[start];\n          type=charType(ch);\n        }\n\n        int pos=start;\n\n        // save the type of the first char of the subword\n        // as a way to tell what type of subword token this is (number, word, etc)\n        int firstType=type;\n        int lastType=type;  // type of the previously read char\n\n\n        while (pos< len) {\n\n          if ((type & lastType)==0) {  // no overlap in character type\n            // check and remove \"'s\" from the end of a token.\n            // the pattern to check for is\n            //   ALPHA \"'\" (\"s\"|\"S\") (SUBWORD_DELIM | END)\n            if (stemEnglishPossessive != 0 && ((lastType & ALPHA)!=0)) {\n              if (ch=='\\'' && pos+1< len\n                      && (termBuffer[pos+1]=='s' || termBuffer[pos+1]=='S'))\n              {\n                int subWordEnd=pos;\n                if (pos+2>= len) {\n                  // end of string detected after \"'s\"\n                  pos+=2;\n                } else {\n                  // make sure that a delimiter follows \"'s\"\n                  int ch2 = termBuffer[pos+2];\n                  int type2 = charType(ch2);\n                  if ((type2 & SUBWORD_DELIM)!=0) {\n                    // if delimiter, move position pointer\n                    // to it (skipping over \"'s\"\n                    ch=ch2;\n                    type=type2;\n                    pos+=2;\n                  }\n                }\n\n                queue.add(newTok(t,start,subWordEnd));\n                if ((firstType & ALPHA)!=0) numWords++;\n                break;\n              }\n            }\n\n            // For case changes, only split on a transition from\n            // lower to upper case, not vice-versa.\n            // That will correctly handle the\n            // case of a word starting with a capital (won't split).\n            // It will also handle pluralization of\n            // an uppercase word such as FOOs (won't split).\n\n            if (splitOnCaseChange == 0 && \n                (lastType & ALPHA) != 0 && (type & ALPHA) != 0) {\n              // ALPHA->ALPHA: always ignore if case isn't considered.\n            } else if ((lastType & UPPER)!=0 && (type & ALPHA)!=0) {\n              // UPPER->letter: Don't split\n            } else if(splitOnNumerics == 0 &&\n                ( ((lastType &  ALPHA) != 0 && (type & DIGIT) != 0) || ((lastType &  DIGIT) != 0 && (type & ALPHA) != 0) ) ) {\n              // ALPHA->NUMERIC, NUMERIC->ALPHA :Don't split\n            } else {\n              // NOTE: this code currently assumes that only one flag\n              // is set for each character now, so we don't have\n              // to explicitly check for all the classes of transitions\n              // listed below.\n\n              // LOWER->UPPER\n              // ALPHA->NUMERIC\n              // NUMERIC->ALPHA\n              // *->DELIMITER\n              queue.add(newTok(t,start,pos));\n              if ((firstType & ALPHA)!=0) numWords++;\n              break;\n            }\n          }\n\n          if (++pos >= len) {\n            if (start==0) {\n              // the subword is the whole original token, so\n              // return it unchanged.\n              t.setPositionIncrement(origPosIncrement);\n              return t;\n            }\n\n            // optimization... if this is the only token,\n            // return it immediately.\n            if (queue.size()==0 && preserveOriginal == 0) {\n              // just adjust the text w/o changing the rest\n              // of the original token\n              t.setTermBuffer(termBuffer, start, len-start);\n              t.setStartOffset(t.startOffset() + start);\n              t.setPositionIncrement(origPosIncrement);              \n              return t;\n            }\n\n            Token newtok = newTok(t,start,pos);\n\n            queue.add(newtok);\n            if ((firstType & ALPHA)!=0) numWords++;\n            break;\n          }\n\n          lastType = type;\n          ch = termBuffer[pos];\n          type = charType(ch);\n        }\n\n        // start of the next subword is the current position\n        start=pos;\n      }\n\n      // System.out.println(\"##########TOKEN=\" + s + \" ######### WORD DELIMITER QUEUE=\" + str(queue));\n\n      final int numtok = queue.size();\n\n      // We reached the end of the current token.\n      // If the queue is empty, we should continue by reading\n      // the next token\n      if (numtok==0) {\n        // the token might have been all delimiters, in which\n        // case return it if we're meant to preserve it\n        if (preserveOriginal != 0) {\n          return t;\n        }\n\n        // if this token had a \"normal\" gap of 1, remove it.\n        if (posInc==1) origPosIncrement-=1;\n        continue;\n      }\n\n      // if number of tokens is 1, there are no catenations to be done.\n      if (numtok==1) {\n        break;\n      }\n\n\n      final int numNumbers = numtok - numWords;\n\n      // check conditions under which the current token\n      // queue may be used as-is (no catenations needed)\n      if (catenateAll==0    // no \"everything\" to catenate\n        && (catenateWords==0 || numWords<=1)   // no words to catenate\n        && (catenateNumbers==0 || numNumbers<=1)    // no numbers to catenate\n        && (generateWordParts!=0 || numWords==0)  // word generation is on\n        && (generateNumberParts!=0 || numNumbers==0)) // number generation is on\n      {\n        break;\n      }\n\n\n      // swap queue and the temporary working list, then clear the\n      // queue in preparation for adding all combinations back to it.\n      ArrayList<Token> tmp=tlist;\n      tlist=queue;\n      queue=tmp;\n      queue.clear();\n\n      if (numWords==0) {\n        // all numbers\n        addCombos(tlist,0,numtok,generateNumberParts!=0,catenateNumbers!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      } else if (numNumbers==0) {\n        // all words\n        addCombos(tlist,0,numtok,generateWordParts!=0,catenateWords!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      } else if (generateNumberParts==0 && generateWordParts==0 && catenateNumbers==0 && catenateWords==0) {\n        // catenate all *only*\n        // OPT:could be optimized to add to current queue...\n        addCombos(tlist,0,numtok,false,catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      }\n\n      //\n      // Find all adjacent tokens of the same type.\n      //\n      Token tok = tlist.get(0);\n      boolean isWord = (tokType(tok) & ALPHA) != 0;\n      boolean wasWord=isWord;\n\n      for(int i=0; i<numtok;) {\n          int j;\n          for (j=i+1; j<numtok; j++) {\n            wasWord=isWord;\n            tok = tlist.get(j);\n            isWord = (tokType(tok) & ALPHA) != 0;\n            if (isWord != wasWord) break;\n          }\n          if (wasWord) {\n            addCombos(tlist,i,j,generateWordParts!=0,catenateWords!=0,1);\n          } else {\n            addCombos(tlist,i,j,generateNumberParts!=0,catenateNumbers!=0,1);\n          }\n          i=j;\n      }\n\n      // take care catenating all subwords\n      if (catenateAll!=0) {\n        addCombos(tlist,0,numtok,false,true,0);\n      }\n\n      // NOTE: in certain cases, queue may be empty (for instance, if catenate\n      // and generate are both set to false).  Only exit the loop if the queue\n      // is not empty.\n      if (queue.size() > 0 || preserveOriginal!=0) break;\n    }\n\n    // System.out.println(\"##########AFTER COMBINATIONS:\"+ str(queue));\n\n    if (preserveOriginal != 0) {\n      queuePos = 0;\n      if (queue.size() > 0) {\n        // overlap first token with the original\n        queue.get(0).setPositionIncrement(0);\n      }\n      return t;  // return the original\n    } else {\n      queuePos=1;\n      Token tok = queue.get(0);\n      tok.setPositionIncrement(origPosIncrement);\n      return tok;\n    }\n  }\n\n","sourceOld":"  public final Token next(Token in) throws IOException {\n\n    // check the queue first\n    if (queuePos<queue.size()) {\n      return queue.get(queuePos++);\n    }\n\n    // reset the queue if it had been previously used\n    if (queuePos!=0) {\n      queuePos=0;\n      queue.clear();\n    }\n\n\n    // optimize for the common case: assume there will be\n    // no subwords (just a simple word)\n    //\n    // Would it actually be faster to check for the common form\n    // of isLetter() isLower()*, and then backtrack if it doesn't match?\n\n    int origPosIncrement = 0;\n    Token t;\n    while(true) {\n      // t is either returned, or a new token is made from it, so it should\n      // be safe to use the next(Token) method.\n      t = input.next(in);\n      if (t == null) return null;\n\n      char [] termBuffer = t.termBuffer();\n      int len = t.termLength();\n      int start=0;\n      if (len ==0) continue;\n\n      //skip protected tokens\n      if (protWords != null && protWords.contains(termBuffer, 0, len)) {\n        return t;\n      }\n\n      origPosIncrement += t.getPositionIncrement();\n\n      // Avoid calling charType more than once for each char (basically\n      // avoid any backtracking).\n      // makes code slightly more difficult, but faster.\n      int ch=termBuffer[start];\n      int type=charType(ch);\n\n      int numWords=0;\n\n      while (start< len) {\n        // first eat delimiters at the start of this subword\n        while ((type & SUBWORD_DELIM)!=0 && ++start< len) {\n          ch=termBuffer[start];\n          type=charType(ch);\n        }\n\n        int pos=start;\n\n        // save the type of the first char of the subword\n        // as a way to tell what type of subword token this is (number, word, etc)\n        int firstType=type;\n        int lastType=type;  // type of the previously read char\n\n\n        while (pos< len) {\n\n          if ((type & lastType)==0) {  // no overlap in character type\n            // check and remove \"'s\" from the end of a token.\n            // the pattern to check for is\n            //   ALPHA \"'\" (\"s\"|\"S\") (SUBWORD_DELIM | END)\n            if (stemEnglishPossessive != 0 && ((lastType & ALPHA)!=0)) {\n              if (ch=='\\'' && pos+1< len\n                      && (termBuffer[pos+1]=='s' || termBuffer[pos+1]=='S'))\n              {\n                int subWordEnd=pos;\n                if (pos+2>= len) {\n                  // end of string detected after \"'s\"\n                  pos+=2;\n                } else {\n                  // make sure that a delimiter follows \"'s\"\n                  int ch2 = termBuffer[pos+2];\n                  int type2 = charType(ch2);\n                  if ((type2 & SUBWORD_DELIM)!=0) {\n                    // if delimiter, move position pointer\n                    // to it (skipping over \"'s\"\n                    ch=ch2;\n                    type=type2;\n                    pos+=2;\n                  }\n                }\n\n                queue.add(newTok(t,start,subWordEnd));\n                if ((firstType & ALPHA)!=0) numWords++;\n                break;\n              }\n            }\n\n            // For case changes, only split on a transition from\n            // lower to upper case, not vice-versa.\n            // That will correctly handle the\n            // case of a word starting with a capital (won't split).\n            // It will also handle pluralization of\n            // an uppercase word such as FOOs (won't split).\n\n            if (splitOnCaseChange == 0 && \n                (lastType & ALPHA) != 0 && (type & ALPHA) != 0) {\n              // ALPHA->ALPHA: always ignore if case isn't considered.\n            } else if ((lastType & UPPER)!=0 && (type & ALPHA)!=0) {\n              // UPPER->letter: Don't split\n            } else if(splitOnNumerics == 0 &&\n                ( ((lastType &  ALPHA) != 0 && (type & DIGIT) != 0) || ((lastType &  DIGIT) != 0 && (type & ALPHA) != 0) ) ) {\n              // ALPHA->NUMERIC, NUMERIC->ALPHA :Don't split\n            } else {\n              // NOTE: this code currently assumes that only one flag\n              // is set for each character now, so we don't have\n              // to explicitly check for all the classes of transitions\n              // listed below.\n\n              // LOWER->UPPER\n              // ALPHA->NUMERIC\n              // NUMERIC->ALPHA\n              // *->DELIMITER\n              queue.add(newTok(t,start,pos));\n              if ((firstType & ALPHA)!=0) numWords++;\n              break;\n            }\n          }\n\n          if (++pos >= len) {\n            if (start==0) {\n              // the subword is the whole original token, so\n              // return it unchanged.\n              return t;\n            }\n\n            // optimization... if this is the only token,\n            // return it immediately.\n            if (queue.size()==0 && preserveOriginal == 0) {\n              // just adjust the text w/o changing the rest\n              // of the original token\n              t.setTermBuffer(termBuffer, start, len-start);\n              t.setStartOffset(t.startOffset() + start);\n              return t;\n            }\n\n            Token newtok = newTok(t,start,pos);\n\n            queue.add(newtok);\n            if ((firstType & ALPHA)!=0) numWords++;\n            break;\n          }\n\n          lastType = type;\n          ch = termBuffer[pos];\n          type = charType(ch);\n        }\n\n        // start of the next subword is the current position\n        start=pos;\n      }\n\n      // System.out.println(\"##########TOKEN=\" + s + \" ######### WORD DELIMITER QUEUE=\" + str(queue));\n\n      final int numtok = queue.size();\n\n      // We reached the end of the current token.\n      // If the queue is empty, we should continue by reading\n      // the next token\n      if (numtok==0) {\n        // the token might have been all delimiters, in which\n        // case return it if we're meant to preserve it\n        if (preserveOriginal != 0) {\n          return t;\n        }\n        continue;\n      }\n\n      // if number of tokens is 1, there are no catenations to be done.\n      if (numtok==1) {\n        break;\n      }\n\n\n      final int numNumbers = numtok - numWords;\n\n      // check conditions under which the current token\n      // queue may be used as-is (no catenations needed)\n      if (catenateAll==0    // no \"everything\" to catenate\n        && (catenateWords==0 || numWords<=1)   // no words to catenate\n        && (catenateNumbers==0 || numNumbers<=1)    // no numbers to catenate\n        && (generateWordParts!=0 || numWords==0)  // word generation is on\n        && (generateNumberParts!=0 || numNumbers==0)) // number generation is on\n      {\n        break;\n      }\n\n\n      // swap queue and the temporary working list, then clear the\n      // queue in preparation for adding all combinations back to it.\n      ArrayList<Token> tmp=tlist;\n      tlist=queue;\n      queue=tmp;\n      queue.clear();\n\n      if (numWords==0) {\n        // all numbers\n        addCombos(tlist,0,numtok,generateNumberParts!=0,catenateNumbers!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      } else if (numNumbers==0) {\n        // all words\n        addCombos(tlist,0,numtok,generateWordParts!=0,catenateWords!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      } else if (generateNumberParts==0 && generateWordParts==0 && catenateNumbers==0 && catenateWords==0) {\n        // catenate all *only*\n        // OPT:could be optimized to add to current queue...\n        addCombos(tlist,0,numtok,false,catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      }\n\n      //\n      // Find all adjacent tokens of the same type.\n      //\n      Token tok = tlist.get(0);\n      boolean isWord = (tokType(tok) & ALPHA) != 0;\n      boolean wasWord=isWord;\n\n      for(int i=0; i<numtok;) {\n          int j;\n          for (j=i+1; j<numtok; j++) {\n            wasWord=isWord;\n            tok = tlist.get(j);\n            isWord = (tokType(tok) & ALPHA) != 0;\n            if (isWord != wasWord) break;\n          }\n          if (wasWord) {\n            addCombos(tlist,i,j,generateWordParts!=0,catenateWords!=0,1);\n          } else {\n            addCombos(tlist,i,j,generateNumberParts!=0,catenateNumbers!=0,1);\n          }\n          i=j;\n      }\n\n      // take care catenating all subwords\n      if (catenateAll!=0) {\n        addCombos(tlist,0,numtok,false,true,0);\n      }\n\n      // NOTE: in certain cases, queue may be empty (for instance, if catenate\n      // and generate are both set to false).  Only exit the loop if the queue\n      // is not empty.\n      if (queue.size() > 0 || preserveOriginal!=0) break;\n    }\n\n    // System.out.println(\"##########AFTER COMBINATIONS:\"+ str(queue));\n\n    if (preserveOriginal != 0) {\n      queuePos = 0;\n      if (queue.size() > 0) {\n        // overlap first token with the original\n        queue.get(0).setPositionIncrement(0);\n      }\n      return t;  // return the original\n    } else {\n      queuePos=1;\n      Token tok = queue.get(0);\n      tok.setPositionIncrement(origPosIncrement);\n      return tok;\n    }\n  }\n\n","bugFix":["1a817c5efd0d36cbf334b211e29e06d5995fe98b","e0d0e8297e9b3e015826cdb7e42404953c339851"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ef28ac95f5f85bbf872801277448c0924b0a6827","date":1268600312,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/solr/analysis/WordDelimiterFilter#next(Token).mjava","sourceNew":null,"sourceOld":"  public final Token next(Token in) throws IOException {\n\n    // check the queue first\n    if (queuePos<queue.size()) {\n      return queue.get(queuePos++);\n    }\n\n    // reset the queue if it had been previously used\n    if (queuePos!=0) {\n      queuePos=0;\n      queue.clear();\n    }\n\n\n    // optimize for the common case: assume there will be\n    // no subwords (just a simple word)\n    //\n    // Would it actually be faster to check for the common form\n    // of isLetter() isLower()*, and then backtrack if it doesn't match?\n\n    int origPosIncrement = 0;\n    Token t;\n    while(true) {\n      // t is either returned, or a new token is made from it, so it should\n      // be safe to use the next(Token) method.\n      t = input.next(in);\n      if (t == null) return null;\n\n      char [] termBuffer = t.termBuffer();\n      int len = t.termLength();\n      int start=0;\n      if (len ==0) continue;\n\n      int posInc = t.getPositionIncrement();\n      origPosIncrement += posInc;\n\n      //skip protected tokens\n      if (protWords != null && protWords.contains(termBuffer, 0, len)) {\n        t.setPositionIncrement(origPosIncrement);\n        return t;\n      }\n\n      // Avoid calling charType more than once for each char (basically\n      // avoid any backtracking).\n      // makes code slightly more difficult, but faster.\n      int ch=termBuffer[start];\n      int type=charType(ch);\n\n      int numWords=0;\n\n      while (start< len) {\n        // first eat delimiters at the start of this subword\n        while ((type & SUBWORD_DELIM)!=0 && ++start< len) {\n          ch=termBuffer[start];\n          type=charType(ch);\n        }\n\n        int pos=start;\n\n        // save the type of the first char of the subword\n        // as a way to tell what type of subword token this is (number, word, etc)\n        int firstType=type;\n        int lastType=type;  // type of the previously read char\n\n\n        while (pos< len) {\n\n          if ((type & lastType)==0) {  // no overlap in character type\n            // check and remove \"'s\" from the end of a token.\n            // the pattern to check for is\n            //   ALPHA \"'\" (\"s\"|\"S\") (SUBWORD_DELIM | END)\n            if (stemEnglishPossessive != 0 && ((lastType & ALPHA)!=0)) {\n              if (ch=='\\'' && pos+1< len\n                      && (termBuffer[pos+1]=='s' || termBuffer[pos+1]=='S'))\n              {\n                int subWordEnd=pos;\n                if (pos+2>= len) {\n                  // end of string detected after \"'s\"\n                  pos+=2;\n                } else {\n                  // make sure that a delimiter follows \"'s\"\n                  int ch2 = termBuffer[pos+2];\n                  int type2 = charType(ch2);\n                  if ((type2 & SUBWORD_DELIM)!=0) {\n                    // if delimiter, move position pointer\n                    // to it (skipping over \"'s\"\n                    ch=ch2;\n                    type=type2;\n                    pos+=2;\n                  }\n                }\n\n                queue.add(newTok(t,start,subWordEnd));\n                if ((firstType & ALPHA)!=0) numWords++;\n                break;\n              }\n            }\n\n            // For case changes, only split on a transition from\n            // lower to upper case, not vice-versa.\n            // That will correctly handle the\n            // case of a word starting with a capital (won't split).\n            // It will also handle pluralization of\n            // an uppercase word such as FOOs (won't split).\n\n            if (splitOnCaseChange == 0 && \n                (lastType & ALPHA) != 0 && (type & ALPHA) != 0) {\n              // ALPHA->ALPHA: always ignore if case isn't considered.\n            } else if ((lastType & UPPER)!=0 && (type & ALPHA)!=0) {\n              // UPPER->letter: Don't split\n            } else if(splitOnNumerics == 0 &&\n                ( ((lastType &  ALPHA) != 0 && (type & DIGIT) != 0) || ((lastType &  DIGIT) != 0 && (type & ALPHA) != 0) ) ) {\n              // ALPHA->NUMERIC, NUMERIC->ALPHA :Don't split\n            } else {\n              // NOTE: this code currently assumes that only one flag\n              // is set for each character now, so we don't have\n              // to explicitly check for all the classes of transitions\n              // listed below.\n\n              // LOWER->UPPER\n              // ALPHA->NUMERIC\n              // NUMERIC->ALPHA\n              // *->DELIMITER\n              queue.add(newTok(t,start,pos));\n              if ((firstType & ALPHA)!=0) numWords++;\n              break;\n            }\n          }\n\n          if (++pos >= len) {\n            if (start==0) {\n              // the subword is the whole original token, so\n              // return it unchanged.\n              t.setPositionIncrement(origPosIncrement);\n              return t;\n            }\n\n            // optimization... if this is the only token,\n            // return it immediately.\n            if (queue.size()==0 && preserveOriginal == 0) {\n              // just adjust the text w/o changing the rest\n              // of the original token\n              t.setTermBuffer(termBuffer, start, len-start);\n              t.setStartOffset(t.startOffset() + start);\n              t.setPositionIncrement(origPosIncrement);              \n              return t;\n            }\n\n            Token newtok = newTok(t,start,pos);\n\n            queue.add(newtok);\n            if ((firstType & ALPHA)!=0) numWords++;\n            break;\n          }\n\n          lastType = type;\n          ch = termBuffer[pos];\n          type = charType(ch);\n        }\n\n        // start of the next subword is the current position\n        start=pos;\n      }\n\n      // System.out.println(\"##########TOKEN=\" + s + \" ######### WORD DELIMITER QUEUE=\" + str(queue));\n\n      final int numtok = queue.size();\n\n      // We reached the end of the current token.\n      // If the queue is empty, we should continue by reading\n      // the next token\n      if (numtok==0) {\n        // the token might have been all delimiters, in which\n        // case return it if we're meant to preserve it\n        if (preserveOriginal != 0) {\n          return t;\n        }\n\n        // if this token had a \"normal\" gap of 1, remove it.\n        if (posInc==1) origPosIncrement-=1;\n        continue;\n      }\n\n      // if number of tokens is 1, there are no catenations to be done.\n      if (numtok==1) {\n        break;\n      }\n\n\n      final int numNumbers = numtok - numWords;\n\n      // check conditions under which the current token\n      // queue may be used as-is (no catenations needed)\n      if (catenateAll==0    // no \"everything\" to catenate\n        && (catenateWords==0 || numWords<=1)   // no words to catenate\n        && (catenateNumbers==0 || numNumbers<=1)    // no numbers to catenate\n        && (generateWordParts!=0 || numWords==0)  // word generation is on\n        && (generateNumberParts!=0 || numNumbers==0)) // number generation is on\n      {\n        break;\n      }\n\n\n      // swap queue and the temporary working list, then clear the\n      // queue in preparation for adding all combinations back to it.\n      ArrayList<Token> tmp=tlist;\n      tlist=queue;\n      queue=tmp;\n      queue.clear();\n\n      if (numWords==0) {\n        // all numbers\n        addCombos(tlist,0,numtok,generateNumberParts!=0,catenateNumbers!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      } else if (numNumbers==0) {\n        // all words\n        addCombos(tlist,0,numtok,generateWordParts!=0,catenateWords!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      } else if (generateNumberParts==0 && generateWordParts==0 && catenateNumbers==0 && catenateWords==0) {\n        // catenate all *only*\n        // OPT:could be optimized to add to current queue...\n        addCombos(tlist,0,numtok,false,catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      }\n\n      //\n      // Find all adjacent tokens of the same type.\n      //\n      Token tok = tlist.get(0);\n      boolean isWord = (tokType(tok) & ALPHA) != 0;\n      boolean wasWord=isWord;\n\n      for(int i=0; i<numtok;) {\n          int j;\n          for (j=i+1; j<numtok; j++) {\n            wasWord=isWord;\n            tok = tlist.get(j);\n            isWord = (tokType(tok) & ALPHA) != 0;\n            if (isWord != wasWord) break;\n          }\n          if (wasWord) {\n            addCombos(tlist,i,j,generateWordParts!=0,catenateWords!=0,1);\n          } else {\n            addCombos(tlist,i,j,generateNumberParts!=0,catenateNumbers!=0,1);\n          }\n          i=j;\n      }\n\n      // take care catenating all subwords\n      if (catenateAll!=0) {\n        addCombos(tlist,0,numtok,false,true,0);\n      }\n\n      // NOTE: in certain cases, queue may be empty (for instance, if catenate\n      // and generate are both set to false).  Only exit the loop if the queue\n      // is not empty.\n      if (queue.size() > 0 || preserveOriginal!=0) break;\n    }\n\n    // System.out.println(\"##########AFTER COMBINATIONS:\"+ str(queue));\n\n    if (preserveOriginal != 0) {\n      queuePos = 0;\n      if (queue.size() > 0) {\n        // overlap first token with the original\n        queue.get(0).setPositionIncrement(0);\n      }\n      return t;  // return the original\n    } else {\n      queuePos=1;\n      Token tok = queue.get(0);\n      tok.setPositionIncrement(origPosIncrement);\n      return tok;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fe8ae1ed027200f075b0de9f264776fa32c4862f":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"1d786062be6da940351591ec2372ddd0ae56bd39":["660378637a9b6a034e3c28b6ee5bca287f414435"],"3600cc523749f65697a76d2d0166cb0df07e458a":["29b4037cea5df1dd9c2c97042c70fd258218165a"],"c1ed809566041553006ceafee9618c9c07f2ed15":["3600cc523749f65697a76d2d0166cb0df07e458a"],"e0d0e8297e9b3e015826cdb7e42404953c339851":["a343ab0901fd528cc211c9731de1e0f4fd319e6d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"ef28ac95f5f85bbf872801277448c0924b0a6827":["1d786062be6da940351591ec2372ddd0ae56bd39"],"29b4037cea5df1dd9c2c97042c70fd258218165a":["e0d0e8297e9b3e015826cdb7e42404953c339851"],"660378637a9b6a034e3c28b6ee5bca287f414435":["c1ed809566041553006ceafee9618c9c07f2ed15"],"a343ab0901fd528cc211c9731de1e0f4fd319e6d":["fe8ae1ed027200f075b0de9f264776fa32c4862f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"fe8ae1ed027200f075b0de9f264776fa32c4862f":["a343ab0901fd528cc211c9731de1e0f4fd319e6d"],"1d786062be6da940351591ec2372ddd0ae56bd39":["ef28ac95f5f85bbf872801277448c0924b0a6827"],"3600cc523749f65697a76d2d0166cb0df07e458a":["c1ed809566041553006ceafee9618c9c07f2ed15"],"c1ed809566041553006ceafee9618c9c07f2ed15":["660378637a9b6a034e3c28b6ee5bca287f414435"],"e0d0e8297e9b3e015826cdb7e42404953c339851":["29b4037cea5df1dd9c2c97042c70fd258218165a"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["fe8ae1ed027200f075b0de9f264776fa32c4862f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"29b4037cea5df1dd9c2c97042c70fd258218165a":["3600cc523749f65697a76d2d0166cb0df07e458a"],"ef28ac95f5f85bbf872801277448c0924b0a6827":[],"660378637a9b6a034e3c28b6ee5bca287f414435":["1d786062be6da940351591ec2372ddd0ae56bd39"],"a343ab0901fd528cc211c9731de1e0f4fd319e6d":["e0d0e8297e9b3e015826cdb7e42404953c339851"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ef28ac95f5f85bbf872801277448c0924b0a6827","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}